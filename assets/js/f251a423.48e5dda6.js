"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[9430],{876:(t,e,n)=>{n.d(e,{Zo:()=>l,kt:()=>h});var o=n(2784);function p(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){p(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function c(t,e){if(null==t)return{};var n,o,p=function(t,e){if(null==t)return{};var n,o,p={},r=Object.keys(t);for(o=0;o<r.length;o++)n=r[o],e.indexOf(n)>=0||(p[n]=t[n]);return p}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)n=r[o],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(p[n]=t[n])}return p}var i=o.createContext({}),a=function(t){var e=o.useContext(i),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},l=function(t){var e=a(t.components);return o.createElement(i.Provider,{value:e},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var e=t.children;return o.createElement(o.Fragment,{},e)}},d=o.forwardRef((function(t,e){var n=t.components,p=t.mdxType,r=t.originalType,i=t.parentName,l=c(t,["components","mdxType","originalType","parentName"]),u=a(n),d=p,h=u["".concat(i,".").concat(d)]||u[d]||m[d]||r;return n?o.createElement(h,s(s({ref:e},l),{},{components:n})):o.createElement(h,s({ref:e},l))}));function h(t,e){var n=arguments,p=e&&e.mdxType;if("string"==typeof t||p){var r=n.length,s=new Array(r);s[0]=d;var c={};for(var i in e)hasOwnProperty.call(e,i)&&(c[i]=e[i]);c.originalType=t,c[u]="string"==typeof t?t:p,s[1]=c;for(var a=2;a<r;a++)s[a]=n[a];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3851:(t,e,n)=>{n.d(e,{Z:()=>u});var o=n(7896),p=n(2784),r=n(6277),s=n(1077),c=n(7683),i=n(9817);const a="anchorWithStickyNavbar_fF9Z",l="anchorWithHideOnScrollNavbar_Yh18";function u(t){let{as:e,id:n,...u}=t;const{navbar:{hideOnScroll:m}}=(0,c.L)();if("h1"===e||!n)return p.createElement(e,(0,o.Z)({},u,{id:void 0}));const d=(0,s.I)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:"string"==typeof u.children?u.children:n});return p.createElement(e,(0,o.Z)({},u,{className:(0,r.Z)("anchor",m?l:a,u.className),id:n}),u.children,p.createElement(i.Z,{className:"hash-link",to:`#${n}`,"aria-label":d,title:d},"\u200b"))}},2072:(t,e,n)=>{n.d(e,{Z:()=>s});var o=n(2784),p=n(8617),r=n(1930);function s(t){let{url:e}=t;const n=(0,p.rG)()(e);return o.createElement(r.Z,{reflection:n,headless:!0})}},8146:(t,e,n)=>{n.d(e,{Z:()=>_tn});var o={};n.r(o),n.d(o,{content_0_0:()=>i,content_0_10:()=>D,content_0_100:()=>te,content_0_1000:()=>Oy,content_0_1002:()=>By,content_0_1004:()=>Uy,content_0_1006:()=>Vy,content_0_1008:()=>jy,content_0_1010:()=>Qy,content_0_1012:()=>$y,content_0_1014:()=>Jy,content_0_1016:()=>eD,content_0_1018:()=>oD,content_0_102:()=>ne,content_0_1020:()=>rD,content_0_1022:()=>cD,content_0_1024:()=>aD,content_0_1026:()=>uD,content_0_1028:()=>dD,content_0_1030:()=>fD,content_0_1032:()=>yD,content_0_1034:()=>MD,content_0_1036:()=>_D,content_0_1038:()=>gD,content_0_104:()=>pe,content_0_1040:()=>CD,content_0_1042:()=>vD,content_0_1044:()=>ZD,content_0_1046:()=>ND,content_0_1048:()=>AD,content_0_1050:()=>ID,content_0_1052:()=>PD,content_0_1054:()=>OD,content_0_1056:()=>BD,content_0_1058:()=>UD,content_0_106:()=>se,content_0_1060:()=>VD,content_0_1062:()=>jD,content_0_1064:()=>QD,content_0_1066:()=>$D,content_0_1068:()=>JD,content_0_1070:()=>eM,content_0_1072:()=>oM,content_0_1074:()=>rM,content_0_1076:()=>cM,content_0_1078:()=>aM,content_0_108:()=>ie,content_0_1080:()=>uM,content_0_1082:()=>dM,content_0_1084:()=>fM,content_0_1086:()=>yM,content_0_1088:()=>MM,content_0_1090:()=>_M,content_0_1092:()=>gM,content_0_1094:()=>CM,content_0_1096:()=>vM,content_0_1098:()=>ZM,content_0_110:()=>le,content_0_1100:()=>NM,content_0_1102:()=>AM,content_0_1104:()=>IM,content_0_1106:()=>PM,content_0_1108:()=>OM,content_0_1110:()=>BM,content_0_1112:()=>UM,content_0_1114:()=>VM,content_0_1116:()=>jM,content_0_1118:()=>QM,content_0_112:()=>me,content_0_1120:()=>$M,content_0_1122:()=>JM,content_0_1124:()=>ew,content_0_1126:()=>ow,content_0_1128:()=>rw,content_0_1130:()=>cw,content_0_1132:()=>aw,content_0_1134:()=>uw,content_0_1136:()=>dw,content_0_1138:()=>fw,content_0_114:()=>he,content_0_1140:()=>yw,content_0_1142:()=>Mw,content_0_1144:()=>_w,content_0_1146:()=>gw,content_0_1148:()=>Cw,content_0_1150:()=>vw,content_0_1152:()=>Zw,content_0_1154:()=>Nw,content_0_1156:()=>Aw,content_0_1158:()=>Iw,content_0_116:()=>ke,content_0_1160:()=>Pw,content_0_1162:()=>Ow,content_0_1164:()=>Bw,content_0_1166:()=>Uw,content_0_1168:()=>Vw,content_0_1170:()=>jw,content_0_1172:()=>Qw,content_0_1174:()=>$w,content_0_1176:()=>Jw,content_0_1178:()=>e_,content_0_118:()=>De,content_0_1180:()=>o_,content_0_1182:()=>r_,content_0_1184:()=>c_,content_0_1186:()=>a_,content_0_1188:()=>u_,content_0_1190:()=>d_,content_0_1192:()=>f_,content_0_1194:()=>y_,content_0_1196:()=>M_,content_0_1198:()=>__,content_0_12:()=>w,content_0_120:()=>we,content_0_1200:()=>g_,content_0_1202:()=>C_,content_0_1204:()=>v_,content_0_1206:()=>Z_,content_0_1208:()=>N_,content_0_1210:()=>A_,content_0_1212:()=>I_,content_0_1214:()=>P_,content_0_1216:()=>O_,content_0_1218:()=>B_,content_0_122:()=>Xe,content_0_1220:()=>U_,content_0_1222:()=>V_,content_0_1224:()=>j_,content_0_1226:()=>Q_,content_0_1228:()=>$_,content_0_1230:()=>J_,content_0_1232:()=>eX,content_0_1234:()=>oX,content_0_1236:()=>rX,content_0_1238:()=>cX,content_0_124:()=>Te,content_0_1240:()=>aX,content_0_1242:()=>uX,content_0_1244:()=>dX,content_0_1246:()=>fX,content_0_1248:()=>yX,content_0_1250:()=>MX,content_0_1252:()=>_X,content_0_1254:()=>gX,content_0_1256:()=>CX,content_0_1258:()=>vX,content_0_126:()=>xe,content_0_1260:()=>ZX,content_0_1262:()=>NX,content_0_1264:()=>AX,content_0_1266:()=>IX,content_0_1268:()=>PX,content_0_1270:()=>OX,content_0_1272:()=>BX,content_0_1274:()=>UX,content_0_1276:()=>VX,content_0_1278:()=>jX,content_0_128:()=>Le,content_0_1280:()=>QX,content_0_1282:()=>$X,content_0_1284:()=>JX,content_0_1286:()=>eg,content_0_1288:()=>og,content_0_1290:()=>rg,content_0_1292:()=>cg,content_0_1294:()=>ag,content_0_1296:()=>ug,content_0_1298:()=>dg,content_0_130:()=>be,content_0_1300:()=>fg,content_0_1302:()=>yg,content_0_1304:()=>Mg,content_0_1306:()=>_g,content_0_1308:()=>gg,content_0_1310:()=>Cg,content_0_1312:()=>vg,content_0_1314:()=>Zg,content_0_1316:()=>Ng,content_0_1318:()=>Ag,content_0_132:()=>ze,content_0_1320:()=>Ig,content_0_1322:()=>Pg,content_0_1324:()=>Og,content_0_1326:()=>Bg,content_0_1328:()=>Ug,content_0_1330:()=>Vg,content_0_1332:()=>jg,content_0_1334:()=>Qg,content_0_1336:()=>$g,content_0_1338:()=>Jg,content_0_134:()=>We,content_0_1340:()=>eT,content_0_1342:()=>oT,content_0_1344:()=>rT,content_0_1346:()=>cT,content_0_1348:()=>aT,content_0_1350:()=>uT,content_0_1352:()=>dT,content_0_1354:()=>fT,content_0_1356:()=>yT,content_0_1358:()=>MT,content_0_136:()=>Re,content_0_1360:()=>_T,content_0_1362:()=>gT,content_0_1364:()=>CT,content_0_1366:()=>vT,content_0_1368:()=>ZT,content_0_1370:()=>NT,content_0_1372:()=>AT,content_0_1374:()=>IT,content_0_1376:()=>PT,content_0_1378:()=>OT,content_0_138:()=>Se,content_0_1380:()=>BT,content_0_1382:()=>UT,content_0_1384:()=>VT,content_0_1386:()=>jT,content_0_1388:()=>QT,content_0_1390:()=>$T,content_0_1392:()=>JT,content_0_1394:()=>eC,content_0_1396:()=>oC,content_0_1398:()=>rC,content_0_14:()=>X,content_0_140:()=>Ee,content_0_1400:()=>cC,content_0_1402:()=>aC,content_0_1404:()=>uC,content_0_1406:()=>dC,content_0_1408:()=>fC,content_0_1410:()=>yC,content_0_1412:()=>MC,content_0_1414:()=>_C,content_0_1416:()=>gC,content_0_1418:()=>CC,content_0_142:()=>Ge,content_0_1420:()=>vC,content_0_1422:()=>ZC,content_0_1424:()=>NC,content_0_1426:()=>AC,content_0_1428:()=>IC,content_0_1430:()=>PC,content_0_1432:()=>OC,content_0_1434:()=>BC,content_0_1436:()=>UC,content_0_1438:()=>VC,content_0_144:()=>Fe,content_0_1440:()=>jC,content_0_1442:()=>QC,content_0_1444:()=>$C,content_0_1446:()=>JC,content_0_1448:()=>ex,content_0_1450:()=>ox,content_0_1452:()=>rx,content_0_1454:()=>cx,content_0_1456:()=>ax,content_0_1458:()=>ux,content_0_146:()=>qe,content_0_1460:()=>dx,content_0_1462:()=>fx,content_0_1464:()=>yx,content_0_1466:()=>Mx,content_0_1468:()=>_x,content_0_1470:()=>gx,content_0_1472:()=>Cx,content_0_1474:()=>vx,content_0_1476:()=>Zx,content_0_1478:()=>Nx,content_0_148:()=>He,content_0_1480:()=>Ax,content_0_1482:()=>Ix,content_0_1484:()=>Px,content_0_1486:()=>Ox,content_0_1488:()=>Bx,content_0_1490:()=>Ux,content_0_1492:()=>Vx,content_0_1494:()=>jx,content_0_1496:()=>Qx,content_0_1498:()=>$x,content_0_150:()=>Ye,content_0_1500:()=>Jx,content_0_1502:()=>ev,content_0_1504:()=>ov,content_0_1506:()=>rv,content_0_1508:()=>cv,content_0_1510:()=>av,content_0_1512:()=>uv,content_0_1514:()=>dv,content_0_1516:()=>fv,content_0_1518:()=>yv,content_0_152:()=>Ke,content_0_1520:()=>Mv,content_0_1522:()=>_v,content_0_1524:()=>gv,content_0_1526:()=>Cv,content_0_1528:()=>vv,content_0_1530:()=>Zv,content_0_1532:()=>Nv,content_0_1534:()=>Av,content_0_1536:()=>Iv,content_0_1538:()=>Pv,content_0_154:()=>tn,content_0_1540:()=>Ov,content_0_1542:()=>Bv,content_0_1544:()=>Uv,content_0_1546:()=>Vv,content_0_1548:()=>jv,content_0_1550:()=>Qv,content_0_1552:()=>$v,content_0_1554:()=>Jv,content_0_1556:()=>eL,content_0_1558:()=>oL,content_0_156:()=>nn,content_0_1560:()=>rL,content_0_1562:()=>cL,content_0_1564:()=>aL,content_0_1566:()=>uL,content_0_1568:()=>dL,content_0_1570:()=>fL,content_0_1572:()=>yL,content_0_1574:()=>ML,content_0_1576:()=>_L,content_0_1578:()=>gL,content_0_158:()=>pn,content_0_1580:()=>CL,content_0_1582:()=>vL,content_0_1584:()=>ZL,content_0_1586:()=>NL,content_0_1588:()=>AL,content_0_1590:()=>IL,content_0_1592:()=>PL,content_0_1594:()=>OL,content_0_1596:()=>BL,content_0_1598:()=>UL,content_0_16:()=>T,content_0_160:()=>sn,content_0_1600:()=>VL,content_0_1602:()=>jL,content_0_1604:()=>QL,content_0_1606:()=>$L,content_0_1608:()=>JL,content_0_1610:()=>eZ,content_0_1612:()=>oZ,content_0_1614:()=>rZ,content_0_1616:()=>cZ,content_0_1618:()=>aZ,content_0_162:()=>an,content_0_1620:()=>uZ,content_0_1622:()=>dZ,content_0_1624:()=>fZ,content_0_1626:()=>yZ,content_0_1628:()=>MZ,content_0_1630:()=>_Z,content_0_1632:()=>gZ,content_0_1634:()=>CZ,content_0_1636:()=>vZ,content_0_1638:()=>ZZ,content_0_164:()=>un,content_0_1640:()=>NZ,content_0_1642:()=>AZ,content_0_1644:()=>IZ,content_0_1646:()=>PZ,content_0_1648:()=>OZ,content_0_1650:()=>BZ,content_0_1652:()=>UZ,content_0_1654:()=>VZ,content_0_1656:()=>jZ,content_0_1658:()=>QZ,content_0_166:()=>dn,content_0_1660:()=>$Z,content_0_1662:()=>JZ,content_0_1664:()=>eb,content_0_1666:()=>ob,content_0_1668:()=>rb,content_0_1670:()=>cb,content_0_1672:()=>ab,content_0_1674:()=>ub,content_0_168:()=>fn,content_0_170:()=>yn,content_0_172:()=>Mn,content_0_174:()=>_n,content_0_176:()=>gn,content_0_178:()=>Cn,content_0_18:()=>x,content_0_180:()=>vn,content_0_182:()=>Zn,content_0_184:()=>Nn,content_0_186:()=>An,content_0_188:()=>In,content_0_190:()=>Pn,content_0_192:()=>On,content_0_194:()=>Bn,content_0_196:()=>Un,content_0_198:()=>Vn,content_0_2:()=>l,content_0_20:()=>L,content_0_200:()=>jn,content_0_202:()=>Qn,content_0_204:()=>$n,content_0_206:()=>Jn,content_0_208:()=>eo,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>co,content_0_216:()=>ao,content_0_218:()=>uo,content_0_22:()=>b,content_0_220:()=>ho,content_0_222:()=>ko,content_0_224:()=>Do,content_0_226:()=>wo,content_0_228:()=>Xo,content_0_230:()=>To,content_0_232:()=>xo,content_0_234:()=>Lo,content_0_236:()=>bo,content_0_238:()=>zo,content_0_24:()=>z,content_0_240:()=>Wo,content_0_242:()=>Ro,content_0_244:()=>So,content_0_246:()=>Eo,content_0_248:()=>Go,content_0_250:()=>Fo,content_0_252:()=>qo,content_0_254:()=>Ho,content_0_256:()=>Yo,content_0_258:()=>Ko,content_0_26:()=>W,content_0_260:()=>tp,content_0_262:()=>np,content_0_264:()=>pp,content_0_266:()=>sp,content_0_268:()=>ip,content_0_270:()=>lp,content_0_272:()=>mp,content_0_274:()=>hp,content_0_276:()=>kp,content_0_278:()=>Dp,content_0_28:()=>R,content_0_280:()=>wp,content_0_282:()=>Xp,content_0_284:()=>Tp,content_0_286:()=>xp,content_0_288:()=>Lp,content_0_290:()=>bp,content_0_292:()=>zp,content_0_294:()=>Wp,content_0_296:()=>Rp,content_0_298:()=>Sp,content_0_30:()=>S,content_0_300:()=>Ep,content_0_302:()=>Gp,content_0_304:()=>Fp,content_0_306:()=>qp,content_0_308:()=>Hp,content_0_310:()=>Yp,content_0_312:()=>Kp,content_0_314:()=>tr,content_0_316:()=>nr,content_0_318:()=>pr,content_0_32:()=>E,content_0_320:()=>sr,content_0_322:()=>ir,content_0_324:()=>lr,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>kr,content_0_332:()=>Dr,content_0_334:()=>wr,content_0_336:()=>Xr,content_0_338:()=>Tr,content_0_34:()=>G,content_0_340:()=>xr,content_0_342:()=>Lr,content_0_344:()=>br,content_0_346:()=>zr,content_0_348:()=>Wr,content_0_350:()=>Rr,content_0_352:()=>Sr,content_0_354:()=>Er,content_0_356:()=>Gr,content_0_358:()=>Fr,content_0_36:()=>F,content_0_360:()=>qr,content_0_362:()=>Hr,content_0_364:()=>Yr,content_0_366:()=>Kr,content_0_368:()=>ts,content_0_370:()=>ns,content_0_372:()=>ps,content_0_374:()=>ss,content_0_376:()=>is,content_0_378:()=>ls,content_0_38:()=>q,content_0_380:()=>ms,content_0_382:()=>hs,content_0_384:()=>ks,content_0_386:()=>Ds,content_0_388:()=>ws,content_0_390:()=>Xs,content_0_392:()=>Ts,content_0_394:()=>xs,content_0_396:()=>Ls,content_0_398:()=>bs,content_0_4:()=>m,content_0_40:()=>H,content_0_400:()=>zs,content_0_402:()=>Ws,content_0_404:()=>Rs,content_0_406:()=>Ss,content_0_408:()=>Es,content_0_410:()=>Gs,content_0_412:()=>Fs,content_0_414:()=>qs,content_0_416:()=>Hs,content_0_418:()=>Ys,content_0_42:()=>Y,content_0_420:()=>Ks,content_0_422:()=>tc,content_0_424:()=>nc,content_0_426:()=>pc,content_0_428:()=>sc,content_0_430:()=>ic,content_0_432:()=>lc,content_0_434:()=>mc,content_0_436:()=>hc,content_0_438:()=>kc,content_0_44:()=>K,content_0_440:()=>Dc,content_0_442:()=>wc,content_0_444:()=>Xc,content_0_446:()=>Tc,content_0_448:()=>xc,content_0_450:()=>Lc,content_0_452:()=>bc,content_0_454:()=>zc,content_0_456:()=>Wc,content_0_458:()=>Rc,content_0_46:()=>tt,content_0_460:()=>Sc,content_0_462:()=>Ec,content_0_464:()=>Gc,content_0_466:()=>Fc,content_0_468:()=>qc,content_0_470:()=>Hc,content_0_472:()=>Yc,content_0_474:()=>Kc,content_0_476:()=>ti,content_0_478:()=>ni,content_0_48:()=>nt,content_0_480:()=>pi,content_0_482:()=>si,content_0_484:()=>ii,content_0_486:()=>li,content_0_488:()=>mi,content_0_490:()=>hi,content_0_492:()=>ki,content_0_494:()=>Di,content_0_496:()=>wi,content_0_498:()=>Xi,content_0_50:()=>pt,content_0_500:()=>Ti,content_0_502:()=>xi,content_0_504:()=>Li,content_0_506:()=>bi,content_0_508:()=>zi,content_0_510:()=>Wi,content_0_512:()=>Ri,content_0_514:()=>Si,content_0_516:()=>Ei,content_0_518:()=>Gi,content_0_52:()=>st,content_0_520:()=>Fi,content_0_522:()=>qi,content_0_524:()=>Hi,content_0_526:()=>Yi,content_0_528:()=>Ki,content_0_530:()=>ta,content_0_532:()=>na,content_0_534:()=>pa,content_0_536:()=>sa,content_0_538:()=>ia,content_0_54:()=>it,content_0_540:()=>la,content_0_542:()=>ma,content_0_544:()=>ha,content_0_546:()=>ka,content_0_548:()=>Da,content_0_550:()=>wa,content_0_552:()=>Xa,content_0_554:()=>Ta,content_0_556:()=>xa,content_0_558:()=>La,content_0_56:()=>lt,content_0_560:()=>ba,content_0_562:()=>za,content_0_564:()=>Wa,content_0_566:()=>Ra,content_0_568:()=>Sa,content_0_570:()=>Ea,content_0_572:()=>Ga,content_0_574:()=>Fa,content_0_576:()=>qa,content_0_578:()=>Ha,content_0_58:()=>mt,content_0_580:()=>Ya,content_0_582:()=>Ka,content_0_584:()=>tl,content_0_586:()=>nl,content_0_588:()=>pl,content_0_590:()=>sl,content_0_592:()=>il,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>kl,content_0_602:()=>Dl,content_0_604:()=>wl,content_0_606:()=>Xl,content_0_608:()=>Tl,content_0_610:()=>xl,content_0_612:()=>Ll,content_0_614:()=>bl,content_0_616:()=>zl,content_0_618:()=>Wl,content_0_62:()=>kt,content_0_620:()=>Rl,content_0_622:()=>Sl,content_0_624:()=>El,content_0_626:()=>Gl,content_0_628:()=>Fl,content_0_630:()=>ql,content_0_632:()=>Hl,content_0_634:()=>Yl,content_0_636:()=>Kl,content_0_638:()=>tu,content_0_64:()=>Dt,content_0_640:()=>nu,content_0_642:()=>pu,content_0_644:()=>su,content_0_646:()=>iu,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>ku,content_0_656:()=>Du,content_0_658:()=>wu,content_0_66:()=>wt,content_0_660:()=>Xu,content_0_662:()=>Tu,content_0_664:()=>xu,content_0_666:()=>Lu,content_0_668:()=>bu,content_0_670:()=>zu,content_0_672:()=>Wu,content_0_674:()=>Ru,content_0_676:()=>Su,content_0_678:()=>Eu,content_0_68:()=>Xt,content_0_680:()=>Gu,content_0_682:()=>Fu,content_0_684:()=>qu,content_0_686:()=>Hu,content_0_688:()=>Yu,content_0_690:()=>Ku,content_0_692:()=>tm,content_0_694:()=>nm,content_0_696:()=>pm,content_0_698:()=>sm,content_0_70:()=>Tt,content_0_700:()=>im,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>km,content_0_710:()=>Dm,content_0_712:()=>wm,content_0_714:()=>Xm,content_0_716:()=>Tm,content_0_718:()=>xm,content_0_72:()=>xt,content_0_720:()=>Lm,content_0_722:()=>bm,content_0_724:()=>zm,content_0_726:()=>Wm,content_0_728:()=>Rm,content_0_730:()=>Sm,content_0_732:()=>Em,content_0_734:()=>Gm,content_0_736:()=>Fm,content_0_738:()=>qm,content_0_74:()=>Lt,content_0_740:()=>Hm,content_0_742:()=>Ym,content_0_744:()=>Km,content_0_746:()=>td,content_0_748:()=>nd,content_0_750:()=>pd,content_0_752:()=>sd,content_0_754:()=>id,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>bt,content_0_760:()=>hd,content_0_762:()=>kd,content_0_764:()=>Dd,content_0_766:()=>wd,content_0_768:()=>Xd,content_0_770:()=>Td,content_0_772:()=>xd,content_0_774:()=>Ld,content_0_776:()=>bd,content_0_778:()=>zd,content_0_78:()=>zt,content_0_780:()=>Wd,content_0_782:()=>Rd,content_0_784:()=>Sd,content_0_786:()=>Ed,content_0_788:()=>Gd,content_0_790:()=>Fd,content_0_792:()=>qd,content_0_794:()=>Hd,content_0_796:()=>Yd,content_0_798:()=>Kd,content_0_8:()=>k,content_0_80:()=>Wt,content_0_800:()=>th,content_0_802:()=>nh,content_0_804:()=>ph,content_0_806:()=>sh,content_0_808:()=>ih,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>kh,content_0_818:()=>Dh,content_0_82:()=>Rt,content_0_820:()=>wh,content_0_822:()=>Xh,content_0_824:()=>Th,content_0_826:()=>xh,content_0_828:()=>Lh,content_0_830:()=>bh,content_0_832:()=>zh,content_0_834:()=>Wh,content_0_836:()=>Rh,content_0_838:()=>Sh,content_0_84:()=>St,content_0_840:()=>Eh,content_0_842:()=>Gh,content_0_844:()=>Fh,content_0_846:()=>qh,content_0_848:()=>Hh,content_0_850:()=>Yh,content_0_852:()=>Kh,content_0_854:()=>tf,content_0_856:()=>nf,content_0_858:()=>pf,content_0_86:()=>Et,content_0_860:()=>sf,content_0_862:()=>af,content_0_864:()=>uf,content_0_866:()=>df,content_0_868:()=>ff,content_0_870:()=>yf,content_0_872:()=>Mf,content_0_874:()=>_f,content_0_876:()=>gf,content_0_878:()=>Cf,content_0_88:()=>Gt,content_0_880:()=>vf,content_0_882:()=>Zf,content_0_884:()=>Nf,content_0_886:()=>Af,content_0_888:()=>If,content_0_890:()=>Pf,content_0_892:()=>Of,content_0_894:()=>Bf,content_0_896:()=>Uf,content_0_898:()=>Vf,content_0_90:()=>Ft,content_0_900:()=>jf,content_0_902:()=>Qf,content_0_904:()=>$f,content_0_906:()=>Jf,content_0_908:()=>ek,content_0_910:()=>ok,content_0_912:()=>rk,content_0_914:()=>ck,content_0_916:()=>ak,content_0_918:()=>uk,content_0_92:()=>qt,content_0_920:()=>dk,content_0_922:()=>fk,content_0_924:()=>yk,content_0_926:()=>Mk,content_0_928:()=>_k,content_0_930:()=>gk,content_0_932:()=>Ck,content_0_934:()=>vk,content_0_936:()=>Zk,content_0_938:()=>Nk,content_0_94:()=>Ht,content_0_940:()=>Ak,content_0_942:()=>Ik,content_0_944:()=>Pk,content_0_946:()=>Ok,content_0_948:()=>Bk,content_0_950:()=>Uk,content_0_952:()=>Vk,content_0_954:()=>jk,content_0_956:()=>Qk,content_0_958:()=>$k,content_0_96:()=>Yt,content_0_960:()=>Jk,content_0_962:()=>ey,content_0_964:()=>oy,content_0_966:()=>ry,content_0_968:()=>cy,content_0_970:()=>ay,content_0_972:()=>uy,content_0_974:()=>dy,content_0_976:()=>fy,content_0_978:()=>yy,content_0_98:()=>Kt,content_0_980:()=>My,content_0_982:()=>_y,content_0_984:()=>gy,content_0_986:()=>Cy,content_0_988:()=>vy,content_0_990:()=>Zy,content_0_992:()=>Ny,content_0_994:()=>Ay,content_0_996:()=>Iy,content_0_998:()=>Py,content_3558_0:()=>db,content_3558_10:()=>gb,content_3558_100:()=>rz,content_3558_1000:()=>BH,content_3558_1002:()=>UH,content_3558_1004:()=>VH,content_3558_1006:()=>jH,content_3558_1008:()=>QH,content_3558_1010:()=>$H,content_3558_1012:()=>JH,content_3558_1014:()=>eQ,content_3558_1016:()=>oQ,content_3558_1018:()=>rQ,content_3558_102:()=>cz,content_3558_1020:()=>cQ,content_3558_1022:()=>aQ,content_3558_1024:()=>uQ,content_3558_1026:()=>dQ,content_3558_1028:()=>fQ,content_3558_1030:()=>yQ,content_3558_1032:()=>MQ,content_3558_1034:()=>_Q,content_3558_1036:()=>gQ,content_3558_1038:()=>CQ,content_3558_104:()=>az,content_3558_1040:()=>vQ,content_3558_1042:()=>ZQ,content_3558_1044:()=>NQ,content_3558_1046:()=>AQ,content_3558_1048:()=>IQ,content_3558_1050:()=>PQ,content_3558_1052:()=>OQ,content_3558_1054:()=>BQ,content_3558_1056:()=>UQ,content_3558_1058:()=>VQ,content_3558_106:()=>uz,content_3558_1060:()=>jQ,content_3558_1062:()=>QQ,content_3558_1064:()=>$Q,content_3558_1066:()=>JQ,content_3558_1068:()=>eY,content_3558_1070:()=>oY,content_3558_1072:()=>rY,content_3558_1074:()=>cY,content_3558_1076:()=>aY,content_3558_1078:()=>uY,content_3558_108:()=>dz,content_3558_1080:()=>dY,content_3558_1082:()=>fY,content_3558_1084:()=>yY,content_3558_1086:()=>MY,content_3558_1088:()=>_Y,content_3558_1090:()=>gY,content_3558_1092:()=>CY,content_3558_1094:()=>vY,content_3558_1096:()=>ZY,content_3558_1098:()=>NY,content_3558_110:()=>fz,content_3558_1100:()=>AY,content_3558_1102:()=>IY,content_3558_1104:()=>PY,content_3558_1106:()=>OY,content_3558_1108:()=>BY,content_3558_1110:()=>UY,content_3558_1112:()=>VY,content_3558_1114:()=>jY,content_3558_1116:()=>QY,content_3558_1118:()=>$Y,content_3558_112:()=>yz,content_3558_1120:()=>JY,content_3558_1122:()=>e$,content_3558_1124:()=>o$,content_3558_1126:()=>r$,content_3558_1128:()=>c$,content_3558_1130:()=>a$,content_3558_1132:()=>u$,content_3558_1134:()=>d$,content_3558_1136:()=>f$,content_3558_1138:()=>y$,content_3558_114:()=>Mz,content_3558_1140:()=>M$,content_3558_1142:()=>_$,content_3558_1144:()=>g$,content_3558_1146:()=>C$,content_3558_1148:()=>v$,content_3558_1150:()=>Z$,content_3558_1152:()=>N$,content_3558_1154:()=>A$,content_3558_1156:()=>I$,content_3558_1158:()=>P$,content_3558_116:()=>_z,content_3558_1160:()=>O$,content_3558_1162:()=>B$,content_3558_1164:()=>U$,content_3558_1166:()=>V$,content_3558_1168:()=>j$,content_3558_1170:()=>Q$,content_3558_1172:()=>$$,content_3558_1174:()=>J$,content_3558_1176:()=>eK,content_3558_1178:()=>oK,content_3558_118:()=>gz,content_3558_1180:()=>rK,content_3558_1182:()=>cK,content_3558_1184:()=>aK,content_3558_1186:()=>uK,content_3558_1188:()=>dK,content_3558_1190:()=>fK,content_3558_1192:()=>yK,content_3558_1194:()=>MK,content_3558_1196:()=>_K,content_3558_1198:()=>gK,content_3558_12:()=>Cb,content_3558_120:()=>Cz,content_3558_1200:()=>CK,content_3558_1202:()=>vK,content_3558_1204:()=>ZK,content_3558_1206:()=>NK,content_3558_1208:()=>AK,content_3558_1210:()=>IK,content_3558_1212:()=>PK,content_3558_1214:()=>OK,content_3558_1216:()=>BK,content_3558_1218:()=>UK,content_3558_122:()=>vz,content_3558_1220:()=>VK,content_3558_1222:()=>jK,content_3558_1224:()=>QK,content_3558_1226:()=>$K,content_3558_1228:()=>JK,content_3558_1230:()=>eJ,content_3558_1232:()=>oJ,content_3558_1234:()=>rJ,content_3558_1236:()=>cJ,content_3558_1238:()=>aJ,content_3558_124:()=>Zz,content_3558_1240:()=>uJ,content_3558_1242:()=>dJ,content_3558_1244:()=>fJ,content_3558_1246:()=>yJ,content_3558_1248:()=>MJ,content_3558_1250:()=>_J,content_3558_1252:()=>gJ,content_3558_1254:()=>CJ,content_3558_1256:()=>vJ,content_3558_1258:()=>ZJ,content_3558_126:()=>Nz,content_3558_1260:()=>NJ,content_3558_1262:()=>AJ,content_3558_1264:()=>IJ,content_3558_1266:()=>PJ,content_3558_1268:()=>OJ,content_3558_1270:()=>BJ,content_3558_1272:()=>UJ,content_3558_1274:()=>VJ,content_3558_1276:()=>jJ,content_3558_1278:()=>QJ,content_3558_128:()=>Az,content_3558_1280:()=>$J,content_3558_1282:()=>JJ,content_3558_1284:()=>e0,content_3558_1286:()=>o0,content_3558_1288:()=>r0,content_3558_1290:()=>c0,content_3558_1292:()=>a0,content_3558_1294:()=>u0,content_3558_1296:()=>d0,content_3558_1298:()=>f0,content_3558_130:()=>Iz,content_3558_1300:()=>y0,content_3558_1302:()=>M0,content_3558_1304:()=>_0,content_3558_1306:()=>g0,content_3558_1308:()=>C0,content_3558_1310:()=>v0,content_3558_1312:()=>Z0,content_3558_1314:()=>N0,content_3558_1316:()=>A0,content_3558_1318:()=>I0,content_3558_132:()=>Pz,content_3558_1320:()=>P0,content_3558_1322:()=>O0,content_3558_1324:()=>B0,content_3558_1326:()=>U0,content_3558_1328:()=>V0,content_3558_1330:()=>j0,content_3558_1332:()=>Q0,content_3558_1334:()=>$0,content_3558_1336:()=>J0,content_3558_1338:()=>e5,content_3558_134:()=>Oz,content_3558_1340:()=>o5,content_3558_1342:()=>r5,content_3558_1344:()=>c5,content_3558_1346:()=>a5,content_3558_1348:()=>u5,content_3558_1350:()=>d5,content_3558_1352:()=>f5,content_3558_1354:()=>y5,content_3558_1356:()=>M5,content_3558_1358:()=>_5,content_3558_136:()=>Bz,content_3558_1360:()=>g5,content_3558_1362:()=>C5,content_3558_1364:()=>v5,content_3558_1366:()=>Z5,content_3558_1368:()=>N5,content_3558_1370:()=>A5,content_3558_1372:()=>I5,content_3558_1374:()=>P5,content_3558_1376:()=>O5,content_3558_1378:()=>B5,content_3558_138:()=>Uz,content_3558_1380:()=>U5,content_3558_1382:()=>V5,content_3558_1384:()=>j5,content_3558_1386:()=>Q5,content_3558_1388:()=>$5,content_3558_1390:()=>J5,content_3558_1392:()=>e8,content_3558_1394:()=>o8,content_3558_1396:()=>r8,content_3558_1398:()=>c8,content_3558_14:()=>vb,content_3558_140:()=>Vz,content_3558_1400:()=>a8,content_3558_1402:()=>u8,content_3558_1404:()=>d8,content_3558_1406:()=>f8,content_3558_1408:()=>y8,content_3558_1410:()=>M8,content_3558_1412:()=>_8,content_3558_1414:()=>g8,content_3558_1416:()=>C8,content_3558_1418:()=>v8,content_3558_142:()=>jz,content_3558_1420:()=>Z8,content_3558_1422:()=>N8,content_3558_1424:()=>A8,content_3558_1426:()=>I8,content_3558_1428:()=>P8,content_3558_1430:()=>O8,content_3558_1432:()=>B8,content_3558_1434:()=>U8,content_3558_1436:()=>V8,content_3558_1438:()=>j8,content_3558_144:()=>Qz,content_3558_1440:()=>Q8,content_3558_1442:()=>$8,content_3558_1444:()=>J8,content_3558_1446:()=>e3,content_3558_1448:()=>o3,content_3558_1450:()=>r3,content_3558_1452:()=>c3,content_3558_1454:()=>a3,content_3558_1456:()=>u3,content_3558_1458:()=>d3,content_3558_146:()=>$z,content_3558_1460:()=>f3,content_3558_1462:()=>y3,content_3558_1464:()=>M3,content_3558_1466:()=>_3,content_3558_1468:()=>g3,content_3558_1470:()=>C3,content_3558_1472:()=>v3,content_3558_1474:()=>Z3,content_3558_1476:()=>N3,content_3558_1478:()=>A3,content_3558_148:()=>Jz,content_3558_1480:()=>I3,content_3558_1482:()=>P3,content_3558_1484:()=>O3,content_3558_1486:()=>B3,content_3558_1488:()=>U3,content_3558_1490:()=>V3,content_3558_1492:()=>j3,content_3558_1494:()=>Q3,content_3558_1496:()=>$3,content_3558_1498:()=>J3,content_3558_150:()=>eA,content_3558_1500:()=>e2,content_3558_1502:()=>o2,content_3558_1504:()=>r2,content_3558_1506:()=>c2,content_3558_1508:()=>a2,content_3558_1510:()=>u2,content_3558_1512:()=>d2,content_3558_1514:()=>f2,content_3558_1516:()=>y2,content_3558_1518:()=>M2,content_3558_152:()=>oA,content_3558_1520:()=>_2,content_3558_1522:()=>g2,content_3558_1524:()=>C2,content_3558_1526:()=>v2,content_3558_1528:()=>Z2,content_3558_1530:()=>N2,content_3558_1532:()=>A2,content_3558_1534:()=>I2,content_3558_1536:()=>P2,content_3558_1538:()=>O2,content_3558_154:()=>rA,content_3558_1540:()=>B2,content_3558_1542:()=>U2,content_3558_1544:()=>V2,content_3558_1546:()=>j2,content_3558_1548:()=>Q2,content_3558_1550:()=>$2,content_3558_1552:()=>J2,content_3558_1554:()=>e1,content_3558_1556:()=>o1,content_3558_1558:()=>r1,content_3558_156:()=>cA,content_3558_1560:()=>c1,content_3558_1562:()=>a1,content_3558_1564:()=>u1,content_3558_1566:()=>d1,content_3558_1568:()=>f1,content_3558_1570:()=>y1,content_3558_1572:()=>M1,content_3558_1574:()=>_1,content_3558_1576:()=>g1,content_3558_1578:()=>C1,content_3558_158:()=>aA,content_3558_1580:()=>v1,content_3558_1582:()=>Z1,content_3558_1584:()=>N1,content_3558_1586:()=>A1,content_3558_1588:()=>I1,content_3558_1590:()=>P1,content_3558_1592:()=>O1,content_3558_1594:()=>B1,content_3558_1596:()=>U1,content_3558_1598:()=>V1,content_3558_16:()=>Zb,content_3558_160:()=>uA,content_3558_1600:()=>j1,content_3558_1602:()=>Q1,content_3558_1604:()=>$1,content_3558_1606:()=>J1,content_3558_1608:()=>e4,content_3558_1610:()=>o4,content_3558_1612:()=>r4,content_3558_1614:()=>c4,content_3558_1616:()=>a4,content_3558_1618:()=>u4,content_3558_162:()=>dA,content_3558_1620:()=>d4,content_3558_1622:()=>f4,content_3558_1624:()=>y4,content_3558_1626:()=>M4,content_3558_1628:()=>_4,content_3558_1630:()=>g4,content_3558_1632:()=>C4,content_3558_1634:()=>v4,content_3558_1636:()=>Z4,content_3558_1638:()=>N4,content_3558_164:()=>fA,content_3558_1640:()=>A4,content_3558_1642:()=>I4,content_3558_1644:()=>P4,content_3558_1646:()=>O4,content_3558_1648:()=>B4,content_3558_1650:()=>U4,content_3558_1652:()=>V4,content_3558_1654:()=>j4,content_3558_1656:()=>Q4,content_3558_1658:()=>$4,content_3558_166:()=>yA,content_3558_1660:()=>J4,content_3558_1662:()=>e6,content_3558_1664:()=>o6,content_3558_1666:()=>r6,content_3558_1668:()=>c6,content_3558_1670:()=>a6,content_3558_1672:()=>u6,content_3558_1674:()=>d6,content_3558_1676:()=>f6,content_3558_1678:()=>y6,content_3558_168:()=>MA,content_3558_1680:()=>M6,content_3558_1682:()=>_6,content_3558_1684:()=>g6,content_3558_1686:()=>C6,content_3558_1688:()=>v6,content_3558_1690:()=>Z6,content_3558_1692:()=>N6,content_3558_1694:()=>A6,content_3558_1696:()=>I6,content_3558_1698:()=>P6,content_3558_170:()=>_A,content_3558_1700:()=>O6,content_3558_1702:()=>B6,content_3558_1704:()=>U6,content_3558_1706:()=>V6,content_3558_1708:()=>j6,content_3558_1710:()=>Q6,content_3558_1712:()=>$6,content_3558_1714:()=>J6,content_3558_1716:()=>e7,content_3558_1718:()=>o7,content_3558_172:()=>gA,content_3558_1720:()=>r7,content_3558_1722:()=>c7,content_3558_1724:()=>a7,content_3558_1726:()=>u7,content_3558_1728:()=>d7,content_3558_1730:()=>f7,content_3558_1732:()=>y7,content_3558_1734:()=>M7,content_3558_1736:()=>_7,content_3558_1738:()=>g7,content_3558_174:()=>CA,content_3558_1740:()=>C7,content_3558_1742:()=>v7,content_3558_1744:()=>Z7,content_3558_1746:()=>N7,content_3558_1748:()=>A7,content_3558_1750:()=>I7,content_3558_1752:()=>P7,content_3558_1754:()=>O7,content_3558_1756:()=>B7,content_3558_1758:()=>U7,content_3558_176:()=>vA,content_3558_1760:()=>V7,content_3558_1762:()=>j7,content_3558_1764:()=>Q7,content_3558_1766:()=>$7,content_3558_1768:()=>J7,content_3558_1770:()=>e9,content_3558_1772:()=>o9,content_3558_1774:()=>r9,content_3558_1776:()=>c9,content_3558_1778:()=>a9,content_3558_178:()=>ZA,content_3558_1780:()=>u9,content_3558_1782:()=>d9,content_3558_1784:()=>f9,content_3558_1786:()=>y9,content_3558_1788:()=>M9,content_3558_1790:()=>_9,content_3558_1792:()=>g9,content_3558_1794:()=>C9,content_3558_1796:()=>v9,content_3558_1798:()=>Z9,content_3558_18:()=>Nb,content_3558_180:()=>NA,content_3558_1800:()=>N9,content_3558_1802:()=>A9,content_3558_1804:()=>I9,content_3558_1806:()=>P9,content_3558_1808:()=>O9,content_3558_1810:()=>B9,content_3558_1812:()=>U9,content_3558_1814:()=>V9,content_3558_1816:()=>j9,content_3558_1818:()=>Q9,content_3558_182:()=>AA,content_3558_1820:()=>$9,content_3558_1822:()=>J9,content_3558_1824:()=>ett,content_3558_1826:()=>ott,content_3558_1828:()=>rtt,content_3558_1830:()=>ctt,content_3558_1832:()=>att,content_3558_1834:()=>utt,content_3558_1836:()=>dtt,content_3558_1838:()=>ftt,content_3558_184:()=>IA,content_3558_1840:()=>ytt,content_3558_1842:()=>Mtt,content_3558_1844:()=>_tt,content_3558_1846:()=>gtt,content_3558_1848:()=>Ctt,content_3558_1850:()=>vtt,content_3558_1852:()=>Ztt,content_3558_1854:()=>Ntt,content_3558_1856:()=>Att,content_3558_1858:()=>Itt,content_3558_186:()=>PA,content_3558_1860:()=>Ptt,content_3558_1862:()=>Ott,content_3558_1864:()=>Btt,content_3558_1866:()=>Utt,content_3558_1868:()=>Vtt,content_3558_1870:()=>jtt,content_3558_1872:()=>Qtt,content_3558_1874:()=>$tt,content_3558_1876:()=>Jtt,content_3558_1878:()=>eet,content_3558_188:()=>OA,content_3558_1880:()=>oet,content_3558_1882:()=>ret,content_3558_1884:()=>cet,content_3558_1886:()=>aet,content_3558_1888:()=>met,content_3558_1890:()=>het,content_3558_1892:()=>ket,content_3558_1894:()=>Det,content_3558_1896:()=>wet,content_3558_1898:()=>Xet,content_3558_190:()=>BA,content_3558_1900:()=>Tet,content_3558_1902:()=>xet,content_3558_1904:()=>Let,content_3558_1906:()=>bet,content_3558_1908:()=>zet,content_3558_1910:()=>Wet,content_3558_1912:()=>Ret,content_3558_1914:()=>Set,content_3558_1916:()=>Eet,content_3558_1918:()=>Get,content_3558_192:()=>UA,content_3558_1920:()=>Fet,content_3558_1922:()=>qet,content_3558_1924:()=>Het,content_3558_1926:()=>Yet,content_3558_1928:()=>Ket,content_3558_1930:()=>tnt,content_3558_1932:()=>nnt,content_3558_1934:()=>pnt,content_3558_1936:()=>snt,content_3558_1938:()=>int,content_3558_194:()=>VA,content_3558_1940:()=>lnt,content_3558_1942:()=>mnt,content_3558_1944:()=>hnt,content_3558_1946:()=>knt,content_3558_1948:()=>Dnt,content_3558_1950:()=>wnt,content_3558_1952:()=>Xnt,content_3558_1954:()=>Tnt,content_3558_1956:()=>xnt,content_3558_1958:()=>Lnt,content_3558_196:()=>jA,content_3558_1960:()=>bnt,content_3558_1962:()=>znt,content_3558_1964:()=>Wnt,content_3558_1966:()=>Rnt,content_3558_1968:()=>Snt,content_3558_1970:()=>Ent,content_3558_1972:()=>Gnt,content_3558_1974:()=>Fnt,content_3558_1976:()=>qnt,content_3558_1978:()=>Hnt,content_3558_198:()=>QA,content_3558_1980:()=>Ynt,content_3558_1982:()=>Knt,content_3558_1984:()=>tot,content_3558_1986:()=>not,content_3558_1988:()=>pot,content_3558_1990:()=>sot,content_3558_1992:()=>iot,content_3558_1994:()=>lot,content_3558_1996:()=>mot,content_3558_1998:()=>hot,content_3558_2:()=>fb,content_3558_20:()=>Ab,content_3558_200:()=>$A,content_3558_2000:()=>kot,content_3558_2002:()=>Dot,content_3558_2004:()=>wot,content_3558_2006:()=>Xot,content_3558_2008:()=>Tot,content_3558_2010:()=>xot,content_3558_2012:()=>Lot,content_3558_2014:()=>bot,content_3558_2016:()=>zot,content_3558_2018:()=>Wot,content_3558_202:()=>JA,content_3558_2020:()=>Rot,content_3558_2022:()=>Sot,content_3558_2024:()=>Eot,content_3558_2026:()=>Got,content_3558_2028:()=>Fot,content_3558_2030:()=>qot,content_3558_2032:()=>Hot,content_3558_2034:()=>Yot,content_3558_2036:()=>Kot,content_3558_2038:()=>tpt,content_3558_204:()=>eW,content_3558_2040:()=>npt,content_3558_2042:()=>ppt,content_3558_2044:()=>spt,content_3558_2046:()=>ipt,content_3558_2048:()=>lpt,content_3558_2050:()=>mpt,content_3558_2052:()=>hpt,content_3558_2054:()=>kpt,content_3558_2056:()=>Dpt,content_3558_2058:()=>wpt,content_3558_206:()=>oW,content_3558_2060:()=>Xpt,content_3558_2062:()=>Tpt,content_3558_2064:()=>xpt,content_3558_2066:()=>Lpt,content_3558_2068:()=>bpt,content_3558_2070:()=>zpt,content_3558_2072:()=>Wpt,content_3558_2074:()=>Rpt,content_3558_2076:()=>Spt,content_3558_2078:()=>Ept,content_3558_208:()=>rW,content_3558_2080:()=>Gpt,content_3558_2082:()=>Fpt,content_3558_2084:()=>qpt,content_3558_2086:()=>Hpt,content_3558_2088:()=>Ypt,content_3558_2090:()=>Kpt,content_3558_2092:()=>trt,content_3558_2094:()=>nrt,content_3558_2096:()=>prt,content_3558_2098:()=>srt,content_3558_210:()=>cW,content_3558_2100:()=>irt,content_3558_2102:()=>lrt,content_3558_2104:()=>mrt,content_3558_2106:()=>hrt,content_3558_2108:()=>krt,content_3558_2110:()=>Drt,content_3558_2112:()=>wrt,content_3558_2114:()=>Xrt,content_3558_2116:()=>Trt,content_3558_2118:()=>xrt,content_3558_212:()=>aW,content_3558_2120:()=>Lrt,content_3558_2122:()=>brt,content_3558_2124:()=>zrt,content_3558_2126:()=>Wrt,content_3558_2128:()=>Rrt,content_3558_2130:()=>Srt,content_3558_2132:()=>Ert,content_3558_2134:()=>Grt,content_3558_2136:()=>Frt,content_3558_2138:()=>qrt,content_3558_214:()=>uW,content_3558_2140:()=>Hrt,content_3558_2142:()=>Yrt,content_3558_2144:()=>Krt,content_3558_2146:()=>tst,content_3558_2148:()=>nst,content_3558_2150:()=>pst,content_3558_2152:()=>sst,content_3558_2154:()=>ist,content_3558_2156:()=>lst,content_3558_2158:()=>mst,content_3558_216:()=>dW,content_3558_2160:()=>hst,content_3558_2162:()=>kst,content_3558_2164:()=>Dst,content_3558_2166:()=>wst,content_3558_2168:()=>Xst,content_3558_2170:()=>Tst,content_3558_2172:()=>xst,content_3558_2174:()=>Lst,content_3558_2176:()=>bst,content_3558_2178:()=>zst,content_3558_218:()=>fW,content_3558_2180:()=>Wst,content_3558_2182:()=>Rst,content_3558_2184:()=>Sst,content_3558_2186:()=>Est,content_3558_2188:()=>Gst,content_3558_2190:()=>Fst,content_3558_2192:()=>qst,content_3558_2194:()=>Hst,content_3558_2196:()=>Yst,content_3558_2198:()=>Kst,content_3558_22:()=>Ib,content_3558_220:()=>yW,content_3558_2200:()=>tct,content_3558_2202:()=>nct,content_3558_2204:()=>pct,content_3558_2206:()=>sct,content_3558_2208:()=>ict,content_3558_2210:()=>lct,content_3558_2212:()=>mct,content_3558_2214:()=>hct,content_3558_2216:()=>kct,content_3558_2218:()=>Dct,content_3558_222:()=>MW,content_3558_2220:()=>wct,content_3558_2222:()=>Xct,content_3558_2224:()=>Tct,content_3558_2226:()=>xct,content_3558_2228:()=>Lct,content_3558_2230:()=>bct,content_3558_2232:()=>zct,content_3558_2234:()=>Wct,content_3558_2236:()=>Rct,content_3558_2238:()=>Sct,content_3558_224:()=>_W,content_3558_2240:()=>Ect,content_3558_2242:()=>Gct,content_3558_2244:()=>Fct,content_3558_2246:()=>qct,content_3558_2248:()=>Hct,content_3558_2250:()=>Yct,content_3558_2252:()=>Kct,content_3558_2254:()=>tit,content_3558_2256:()=>nit,content_3558_2258:()=>pit,content_3558_226:()=>gW,content_3558_2260:()=>sit,content_3558_2262:()=>iit,content_3558_2264:()=>lit,content_3558_2266:()=>mit,content_3558_2268:()=>hit,content_3558_2270:()=>kit,content_3558_2272:()=>Dit,content_3558_2274:()=>wit,content_3558_2276:()=>Xit,content_3558_2278:()=>Tit,content_3558_228:()=>CW,content_3558_2280:()=>xit,content_3558_2282:()=>Lit,content_3558_2284:()=>bit,content_3558_2286:()=>zit,content_3558_2288:()=>Wit,content_3558_2290:()=>Rit,content_3558_2292:()=>Sit,content_3558_2294:()=>Eit,content_3558_2296:()=>Git,content_3558_2298:()=>Fit,content_3558_230:()=>vW,content_3558_2300:()=>qit,content_3558_2302:()=>Hit,content_3558_2304:()=>Yit,content_3558_2306:()=>Kit,content_3558_2308:()=>tat,content_3558_2310:()=>nat,content_3558_2312:()=>pat,content_3558_2314:()=>sat,content_3558_2316:()=>iat,content_3558_2318:()=>lat,content_3558_232:()=>ZW,content_3558_2320:()=>mat,content_3558_2322:()=>hat,content_3558_2324:()=>kat,content_3558_2326:()=>Dat,content_3558_2328:()=>wat,content_3558_2330:()=>Xat,content_3558_2332:()=>Tat,content_3558_2334:()=>xat,content_3558_2336:()=>Lat,content_3558_2338:()=>bat,content_3558_234:()=>NW,content_3558_2340:()=>zat,content_3558_2342:()=>Wat,content_3558_2344:()=>Rat,content_3558_2346:()=>Sat,content_3558_2348:()=>Eat,content_3558_2350:()=>Gat,content_3558_2352:()=>Fat,content_3558_2354:()=>qat,content_3558_2356:()=>Hat,content_3558_2358:()=>Yat,content_3558_236:()=>AW,content_3558_2360:()=>Kat,content_3558_2362:()=>tlt,content_3558_2364:()=>nlt,content_3558_2366:()=>plt,content_3558_2368:()=>slt,content_3558_2370:()=>ilt,content_3558_2372:()=>llt,content_3558_2374:()=>mlt,content_3558_2376:()=>hlt,content_3558_2378:()=>klt,content_3558_238:()=>IW,content_3558_2380:()=>Dlt,content_3558_2382:()=>wlt,content_3558_2384:()=>Xlt,content_3558_2386:()=>Tlt,content_3558_2388:()=>xlt,content_3558_2390:()=>Llt,content_3558_2392:()=>blt,content_3558_2394:()=>zlt,content_3558_2396:()=>Wlt,content_3558_2398:()=>Rlt,content_3558_24:()=>Pb,content_3558_240:()=>PW,content_3558_2400:()=>Slt,content_3558_2402:()=>Elt,content_3558_2404:()=>Glt,content_3558_2406:()=>Flt,content_3558_2408:()=>qlt,content_3558_2410:()=>Hlt,content_3558_2412:()=>Ylt,content_3558_2414:()=>Klt,content_3558_2416:()=>tut,content_3558_2418:()=>nut,content_3558_242:()=>OW,content_3558_2420:()=>put,content_3558_2422:()=>sut,content_3558_2424:()=>iut,content_3558_2426:()=>lut,content_3558_2428:()=>mut,content_3558_2430:()=>hut,content_3558_2432:()=>kut,content_3558_2434:()=>Dut,content_3558_2436:()=>wut,content_3558_2438:()=>Xut,content_3558_244:()=>BW,content_3558_2440:()=>Tut,content_3558_2442:()=>xut,content_3558_2444:()=>Lut,content_3558_2446:()=>but,content_3558_2448:()=>zut,content_3558_2450:()=>Wut,content_3558_2452:()=>Rut,content_3558_2454:()=>Sut,content_3558_2456:()=>Eut,content_3558_2458:()=>Gut,content_3558_246:()=>UW,content_3558_2460:()=>Fut,content_3558_2462:()=>qut,content_3558_2464:()=>Hut,content_3558_2466:()=>Yut,content_3558_2468:()=>Kut,content_3558_2470:()=>tmt,content_3558_2472:()=>nmt,content_3558_2474:()=>pmt,content_3558_2476:()=>smt,content_3558_2478:()=>imt,content_3558_248:()=>VW,content_3558_2480:()=>lmt,content_3558_2482:()=>mmt,content_3558_2484:()=>hmt,content_3558_2486:()=>kmt,content_3558_2488:()=>Dmt,content_3558_2490:()=>wmt,content_3558_2492:()=>Xmt,content_3558_2494:()=>Tmt,content_3558_2496:()=>xmt,content_3558_2498:()=>Lmt,content_3558_250:()=>jW,content_3558_2500:()=>bmt,content_3558_2502:()=>zmt,content_3558_2504:()=>Wmt,content_3558_2506:()=>Rmt,content_3558_2508:()=>Smt,content_3558_2510:()=>Emt,content_3558_2512:()=>Gmt,content_3558_2514:()=>Fmt,content_3558_2516:()=>qmt,content_3558_2518:()=>Hmt,content_3558_252:()=>QW,content_3558_2520:()=>Ymt,content_3558_2522:()=>Kmt,content_3558_2524:()=>tdt,content_3558_2526:()=>ndt,content_3558_2528:()=>pdt,content_3558_2530:()=>sdt,content_3558_2532:()=>idt,content_3558_2534:()=>ldt,content_3558_2536:()=>mdt,content_3558_2538:()=>hdt,content_3558_254:()=>$W,content_3558_2540:()=>kdt,content_3558_2542:()=>Ddt,content_3558_2544:()=>wdt,content_3558_2546:()=>Xdt,content_3558_2548:()=>Tdt,content_3558_2550:()=>xdt,content_3558_2552:()=>Ldt,content_3558_2554:()=>bdt,content_3558_2556:()=>zdt,content_3558_2558:()=>Wdt,content_3558_256:()=>JW,content_3558_2560:()=>Rdt,content_3558_2562:()=>Sdt,content_3558_2564:()=>Edt,content_3558_2566:()=>Gdt,content_3558_2568:()=>Fdt,content_3558_2570:()=>qdt,content_3558_2572:()=>Hdt,content_3558_2574:()=>Ydt,content_3558_2576:()=>Kdt,content_3558_2578:()=>tht,content_3558_258:()=>eI,content_3558_2580:()=>nht,content_3558_2582:()=>pht,content_3558_2584:()=>sht,content_3558_2586:()=>iht,content_3558_2588:()=>lht,content_3558_2590:()=>mht,content_3558_2592:()=>hht,content_3558_2594:()=>kht,content_3558_2596:()=>Dht,content_3558_2598:()=>wht,content_3558_26:()=>Ob,content_3558_260:()=>oI,content_3558_2600:()=>Xht,content_3558_2602:()=>Tht,content_3558_2604:()=>xht,content_3558_2606:()=>Lht,content_3558_2608:()=>bht,content_3558_2610:()=>zht,content_3558_2612:()=>Wht,content_3558_2614:()=>Rht,content_3558_2616:()=>Sht,content_3558_2618:()=>Eht,content_3558_262:()=>rI,content_3558_2620:()=>Ght,content_3558_2622:()=>Fht,content_3558_2624:()=>qht,content_3558_2626:()=>Hht,content_3558_2628:()=>Yht,content_3558_2630:()=>Kht,content_3558_2632:()=>tft,content_3558_2634:()=>nft,content_3558_2636:()=>pft,content_3558_2638:()=>sft,content_3558_264:()=>cI,content_3558_2640:()=>ift,content_3558_2642:()=>lft,content_3558_2644:()=>mft,content_3558_2646:()=>hft,content_3558_2648:()=>kft,content_3558_2650:()=>Dft,content_3558_2652:()=>wft,content_3558_2654:()=>Xft,content_3558_2656:()=>Tft,content_3558_2658:()=>xft,content_3558_266:()=>aI,content_3558_2660:()=>Lft,content_3558_2662:()=>bft,content_3558_2664:()=>zft,content_3558_2666:()=>Wft,content_3558_2668:()=>Rft,content_3558_2670:()=>Sft,content_3558_2672:()=>Eft,content_3558_2674:()=>Gft,content_3558_2676:()=>Fft,content_3558_2678:()=>qft,content_3558_268:()=>uI,content_3558_2680:()=>Hft,content_3558_2682:()=>Yft,content_3558_2684:()=>Kft,content_3558_2686:()=>tkt,content_3558_2688:()=>nkt,content_3558_2690:()=>pkt,content_3558_2692:()=>skt,content_3558_2694:()=>ikt,content_3558_2696:()=>lkt,content_3558_2698:()=>mkt,content_3558_270:()=>dI,content_3558_2700:()=>hkt,content_3558_2702:()=>kkt,content_3558_2704:()=>Dkt,content_3558_2706:()=>wkt,content_3558_2708:()=>Xkt,content_3558_2710:()=>Tkt,content_3558_2712:()=>xkt,content_3558_2714:()=>Lkt,content_3558_2716:()=>bkt,content_3558_2718:()=>zkt,content_3558_272:()=>fI,content_3558_2720:()=>Wkt,content_3558_2722:()=>Rkt,content_3558_2724:()=>Skt,content_3558_2726:()=>Ekt,content_3558_2728:()=>Gkt,content_3558_2730:()=>Fkt,content_3558_2732:()=>qkt,content_3558_2734:()=>Hkt,content_3558_2736:()=>Ykt,content_3558_2738:()=>Kkt,content_3558_274:()=>yI,content_3558_2740:()=>tyt,content_3558_2742:()=>nyt,content_3558_2744:()=>pyt,content_3558_2746:()=>syt,content_3558_2748:()=>iyt,content_3558_2750:()=>lyt,content_3558_2752:()=>myt,content_3558_2754:()=>hyt,content_3558_2756:()=>kyt,content_3558_2758:()=>Dyt,content_3558_276:()=>MI,content_3558_2760:()=>wyt,content_3558_2762:()=>Xyt,content_3558_2764:()=>Tyt,content_3558_2766:()=>xyt,content_3558_2768:()=>Lyt,content_3558_2770:()=>byt,content_3558_2772:()=>zyt,content_3558_2774:()=>Wyt,content_3558_2776:()=>Ryt,content_3558_2778:()=>Syt,content_3558_278:()=>_I,content_3558_2780:()=>Eyt,content_3558_2782:()=>Gyt,content_3558_2784:()=>Fyt,content_3558_2786:()=>qyt,content_3558_2788:()=>Hyt,content_3558_2790:()=>Yyt,content_3558_2792:()=>Kyt,content_3558_2794:()=>tDt,content_3558_2796:()=>nDt,content_3558_2798:()=>pDt,content_3558_28:()=>Bb,content_3558_280:()=>gI,content_3558_2800:()=>sDt,content_3558_2802:()=>iDt,content_3558_2804:()=>lDt,content_3558_2806:()=>mDt,content_3558_2808:()=>hDt,content_3558_2810:()=>kDt,content_3558_2812:()=>DDt,content_3558_2814:()=>wDt,content_3558_2816:()=>XDt,content_3558_2818:()=>TDt,content_3558_282:()=>CI,content_3558_2820:()=>xDt,content_3558_2822:()=>LDt,content_3558_2824:()=>bDt,content_3558_2826:()=>zDt,content_3558_2828:()=>WDt,content_3558_2830:()=>RDt,content_3558_2832:()=>SDt,content_3558_2834:()=>EDt,content_3558_2836:()=>GDt,content_3558_2838:()=>FDt,content_3558_284:()=>vI,content_3558_2840:()=>qDt,content_3558_2842:()=>HDt,content_3558_2844:()=>YDt,content_3558_2846:()=>KDt,content_3558_2848:()=>tMt,content_3558_2850:()=>nMt,content_3558_2852:()=>pMt,content_3558_2854:()=>sMt,content_3558_2856:()=>iMt,content_3558_2858:()=>lMt,content_3558_286:()=>ZI,content_3558_2860:()=>mMt,content_3558_2862:()=>hMt,content_3558_2864:()=>kMt,content_3558_2866:()=>DMt,content_3558_2868:()=>wMt,content_3558_2870:()=>XMt,content_3558_2872:()=>TMt,content_3558_2874:()=>xMt,content_3558_2876:()=>LMt,content_3558_2878:()=>bMt,content_3558_288:()=>NI,content_3558_2880:()=>zMt,content_3558_2882:()=>WMt,content_3558_2884:()=>RMt,content_3558_2886:()=>SMt,content_3558_2888:()=>EMt,content_3558_2890:()=>GMt,content_3558_2892:()=>FMt,content_3558_2894:()=>qMt,content_3558_2896:()=>HMt,content_3558_2898:()=>YMt,content_3558_290:()=>AI,content_3558_2900:()=>KMt,content_3558_2902:()=>twt,content_3558_2904:()=>nwt,content_3558_2906:()=>pwt,content_3558_2908:()=>swt,content_3558_2910:()=>iwt,content_3558_2912:()=>lwt,content_3558_2914:()=>mwt,content_3558_2916:()=>hwt,content_3558_2918:()=>kwt,content_3558_292:()=>II,content_3558_2920:()=>Dwt,content_3558_2922:()=>wwt,content_3558_2924:()=>Xwt,content_3558_2926:()=>Twt,content_3558_2928:()=>xwt,content_3558_2930:()=>Lwt,content_3558_2932:()=>bwt,content_3558_2934:()=>zwt,content_3558_2936:()=>Wwt,content_3558_2938:()=>Rwt,content_3558_294:()=>PI,content_3558_2940:()=>Swt,content_3558_2942:()=>Ewt,content_3558_2944:()=>Gwt,content_3558_2946:()=>Fwt,content_3558_2948:()=>qwt,content_3558_2950:()=>Hwt,content_3558_2952:()=>Ywt,content_3558_2954:()=>Kwt,content_3558_2956:()=>t_t,content_3558_2958:()=>n_t,content_3558_296:()=>OI,content_3558_2960:()=>p_t,content_3558_2962:()=>s_t,content_3558_2964:()=>i_t,content_3558_2966:()=>l_t,content_3558_2968:()=>m_t,content_3558_2970:()=>h_t,content_3558_2972:()=>k_t,content_3558_2974:()=>D_t,content_3558_2976:()=>w_t,content_3558_2978:()=>X_t,content_3558_298:()=>BI,content_3558_2980:()=>T_t,content_3558_2982:()=>x_t,content_3558_2984:()=>L_t,content_3558_2986:()=>b_t,content_3558_2988:()=>z_t,content_3558_2990:()=>W_t,content_3558_2992:()=>R_t,content_3558_2994:()=>S_t,content_3558_2996:()=>E_t,content_3558_2998:()=>G_t,content_3558_30:()=>Ub,content_3558_300:()=>UI,content_3558_3000:()=>F_t,content_3558_3002:()=>q_t,content_3558_3004:()=>H_t,content_3558_3006:()=>Y_t,content_3558_3008:()=>K_t,content_3558_3010:()=>tXt,content_3558_3012:()=>nXt,content_3558_3014:()=>pXt,content_3558_3016:()=>sXt,content_3558_3018:()=>iXt,content_3558_302:()=>VI,content_3558_3020:()=>lXt,content_3558_3022:()=>mXt,content_3558_3024:()=>hXt,content_3558_3026:()=>kXt,content_3558_3028:()=>DXt,content_3558_3030:()=>wXt,content_3558_3032:()=>XXt,content_3558_3034:()=>TXt,content_3558_3036:()=>xXt,content_3558_3038:()=>LXt,content_3558_304:()=>jI,content_3558_3040:()=>bXt,content_3558_3042:()=>zXt,content_3558_3044:()=>WXt,content_3558_3046:()=>RXt,content_3558_3048:()=>SXt,content_3558_3050:()=>EXt,content_3558_3052:()=>GXt,content_3558_3054:()=>FXt,content_3558_3056:()=>qXt,content_3558_3058:()=>HXt,content_3558_306:()=>QI,content_3558_3060:()=>YXt,content_3558_3062:()=>KXt,content_3558_3064:()=>tgt,content_3558_3066:()=>ngt,content_3558_3068:()=>pgt,content_3558_3070:()=>sgt,content_3558_3072:()=>igt,content_3558_3074:()=>lgt,content_3558_3076:()=>mgt,content_3558_3078:()=>hgt,content_3558_308:()=>$I,content_3558_3080:()=>kgt,content_3558_3082:()=>Dgt,content_3558_3084:()=>wgt,content_3558_3086:()=>Xgt,content_3558_3088:()=>Tgt,content_3558_3090:()=>xgt,content_3558_3092:()=>Lgt,content_3558_3094:()=>bgt,content_3558_3096:()=>zgt,content_3558_3098:()=>Wgt,content_3558_310:()=>JI,content_3558_3100:()=>Rgt,content_3558_3102:()=>Sgt,content_3558_3104:()=>Egt,content_3558_3106:()=>Ggt,content_3558_3108:()=>Fgt,content_3558_3110:()=>qgt,content_3558_3112:()=>Hgt,content_3558_3114:()=>Ygt,content_3558_3116:()=>Kgt,content_3558_3118:()=>tTt,content_3558_312:()=>eR,content_3558_3120:()=>nTt,content_3558_3122:()=>pTt,content_3558_3124:()=>sTt,content_3558_3126:()=>iTt,content_3558_3128:()=>lTt,content_3558_3130:()=>mTt,content_3558_3132:()=>hTt,content_3558_3134:()=>kTt,content_3558_3136:()=>DTt,content_3558_3138:()=>wTt,content_3558_314:()=>oR,content_3558_3140:()=>XTt,content_3558_3142:()=>TTt,content_3558_3144:()=>xTt,content_3558_3146:()=>LTt,content_3558_3148:()=>bTt,content_3558_3150:()=>zTt,content_3558_3152:()=>WTt,content_3558_3154:()=>RTt,content_3558_3156:()=>STt,content_3558_3158:()=>ETt,content_3558_316:()=>rR,content_3558_3160:()=>GTt,content_3558_3162:()=>FTt,content_3558_3164:()=>qTt,content_3558_3166:()=>HTt,content_3558_3168:()=>YTt,content_3558_3170:()=>KTt,content_3558_3172:()=>tCt,content_3558_3174:()=>nCt,content_3558_3176:()=>pCt,content_3558_3178:()=>sCt,content_3558_318:()=>cR,content_3558_3180:()=>iCt,content_3558_3182:()=>lCt,content_3558_3184:()=>mCt,content_3558_3186:()=>hCt,content_3558_3188:()=>kCt,content_3558_3190:()=>DCt,content_3558_3192:()=>wCt,content_3558_3194:()=>XCt,content_3558_3196:()=>TCt,content_3558_3198:()=>xCt,content_3558_32:()=>Vb,content_3558_320:()=>aR,content_3558_3200:()=>LCt,content_3558_3202:()=>bCt,content_3558_3204:()=>zCt,content_3558_3206:()=>WCt,content_3558_3208:()=>RCt,content_3558_3210:()=>SCt,content_3558_3212:()=>ECt,content_3558_3214:()=>GCt,content_3558_3216:()=>FCt,content_3558_3218:()=>qCt,content_3558_322:()=>uR,content_3558_3220:()=>HCt,content_3558_3222:()=>YCt,content_3558_3224:()=>KCt,content_3558_3226:()=>txt,content_3558_3228:()=>nxt,content_3558_3230:()=>pxt,content_3558_3232:()=>sxt,content_3558_3234:()=>ixt,content_3558_3236:()=>lxt,content_3558_3238:()=>mxt,content_3558_324:()=>dR,content_3558_3240:()=>hxt,content_3558_3242:()=>kxt,content_3558_3244:()=>Dxt,content_3558_3246:()=>wxt,content_3558_3248:()=>Xxt,content_3558_3250:()=>Txt,content_3558_3252:()=>xxt,content_3558_3254:()=>Lxt,content_3558_3256:()=>bxt,content_3558_3258:()=>zxt,content_3558_326:()=>fR,content_3558_3260:()=>Wxt,content_3558_3262:()=>Rxt,content_3558_3264:()=>Sxt,content_3558_3266:()=>Ext,content_3558_3268:()=>Gxt,content_3558_3270:()=>Fxt,content_3558_3272:()=>qxt,content_3558_3274:()=>Hxt,content_3558_3276:()=>Yxt,content_3558_3278:()=>Kxt,content_3558_328:()=>yR,content_3558_3280:()=>tvt,content_3558_3282:()=>nvt,content_3558_3284:()=>pvt,content_3558_3286:()=>svt,content_3558_3288:()=>ivt,content_3558_3290:()=>lvt,content_3558_3292:()=>mvt,content_3558_3294:()=>hvt,content_3558_3296:()=>kvt,content_3558_3298:()=>Dvt,content_3558_330:()=>MR,content_3558_3300:()=>wvt,content_3558_3302:()=>Xvt,content_3558_3304:()=>Tvt,content_3558_3306:()=>xvt,content_3558_3308:()=>Lvt,content_3558_3310:()=>bvt,content_3558_3312:()=>zvt,content_3558_3314:()=>Wvt,content_3558_3316:()=>Rvt,content_3558_3318:()=>Svt,content_3558_332:()=>_R,content_3558_3320:()=>Evt,content_3558_3322:()=>Gvt,content_3558_3324:()=>Fvt,content_3558_3326:()=>qvt,content_3558_3328:()=>Hvt,content_3558_3330:()=>Yvt,content_3558_3332:()=>Kvt,content_3558_3334:()=>tLt,content_3558_3336:()=>nLt,content_3558_3338:()=>pLt,content_3558_334:()=>gR,content_3558_3340:()=>sLt,content_3558_3342:()=>iLt,content_3558_3344:()=>lLt,content_3558_3346:()=>mLt,content_3558_3348:()=>hLt,content_3558_3350:()=>kLt,content_3558_3352:()=>DLt,content_3558_3354:()=>wLt,content_3558_3356:()=>XLt,content_3558_3358:()=>TLt,content_3558_336:()=>CR,content_3558_3360:()=>xLt,content_3558_3362:()=>LLt,content_3558_3364:()=>bLt,content_3558_3366:()=>zLt,content_3558_3368:()=>WLt,content_3558_3370:()=>RLt,content_3558_3372:()=>SLt,content_3558_3374:()=>ELt,content_3558_3376:()=>GLt,content_3558_3378:()=>FLt,content_3558_338:()=>vR,content_3558_3380:()=>qLt,content_3558_3382:()=>HLt,content_3558_3384:()=>YLt,content_3558_3386:()=>KLt,content_3558_3388:()=>tZt,content_3558_3390:()=>nZt,content_3558_3392:()=>pZt,content_3558_3394:()=>sZt,content_3558_3396:()=>iZt,content_3558_3398:()=>lZt,content_3558_34:()=>jb,content_3558_340:()=>ZR,content_3558_3400:()=>mZt,content_3558_3402:()=>hZt,content_3558_3404:()=>kZt,content_3558_3406:()=>DZt,content_3558_3408:()=>wZt,content_3558_3410:()=>XZt,content_3558_3412:()=>TZt,content_3558_3414:()=>xZt,content_3558_3416:()=>LZt,content_3558_3418:()=>bZt,content_3558_342:()=>NR,content_3558_3420:()=>zZt,content_3558_3422:()=>WZt,content_3558_3424:()=>RZt,content_3558_3426:()=>SZt,content_3558_3428:()=>EZt,content_3558_3430:()=>GZt,content_3558_3432:()=>FZt,content_3558_3434:()=>qZt,content_3558_3436:()=>HZt,content_3558_3438:()=>YZt,content_3558_344:()=>AR,content_3558_3440:()=>KZt,content_3558_3442:()=>tbt,content_3558_3444:()=>nbt,content_3558_3446:()=>pbt,content_3558_3448:()=>sbt,content_3558_3450:()=>ibt,content_3558_3452:()=>lbt,content_3558_3454:()=>mbt,content_3558_3456:()=>hbt,content_3558_3458:()=>kbt,content_3558_346:()=>IR,content_3558_3460:()=>Dbt,content_3558_3462:()=>wbt,content_3558_3464:()=>Xbt,content_3558_3466:()=>Tbt,content_3558_3468:()=>xbt,content_3558_3470:()=>Lbt,content_3558_3472:()=>bbt,content_3558_3474:()=>zbt,content_3558_3476:()=>Wbt,content_3558_3478:()=>Rbt,content_3558_348:()=>PR,content_3558_3480:()=>Sbt,content_3558_3482:()=>Ebt,content_3558_3484:()=>Gbt,content_3558_3486:()=>Fbt,content_3558_3488:()=>qbt,content_3558_3490:()=>Hbt,content_3558_3492:()=>Ybt,content_3558_3494:()=>Kbt,content_3558_3496:()=>tNt,content_3558_3498:()=>nNt,content_3558_350:()=>OR,content_3558_3500:()=>pNt,content_3558_3502:()=>sNt,content_3558_3504:()=>iNt,content_3558_3506:()=>lNt,content_3558_3508:()=>mNt,content_3558_3510:()=>hNt,content_3558_3512:()=>kNt,content_3558_3514:()=>DNt,content_3558_3516:()=>wNt,content_3558_3518:()=>XNt,content_3558_352:()=>BR,content_3558_3520:()=>TNt,content_3558_3522:()=>xNt,content_3558_3524:()=>LNt,content_3558_3526:()=>bNt,content_3558_3528:()=>zNt,content_3558_3530:()=>WNt,content_3558_3532:()=>RNt,content_3558_3534:()=>SNt,content_3558_3536:()=>ENt,content_3558_3538:()=>GNt,content_3558_354:()=>UR,content_3558_3540:()=>FNt,content_3558_3542:()=>qNt,content_3558_3544:()=>HNt,content_3558_3546:()=>YNt,content_3558_3548:()=>KNt,content_3558_3550:()=>tzt,content_3558_3552:()=>nzt,content_3558_3554:()=>pzt,content_3558_3556:()=>szt,content_3558_3558:()=>izt,content_3558_356:()=>VR,content_3558_3560:()=>lzt,content_3558_3562:()=>mzt,content_3558_3564:()=>hzt,content_3558_3566:()=>kzt,content_3558_3568:()=>Dzt,content_3558_3570:()=>wzt,content_3558_3572:()=>Xzt,content_3558_3574:()=>Tzt,content_3558_3576:()=>xzt,content_3558_3578:()=>Lzt,content_3558_358:()=>jR,content_3558_3580:()=>bzt,content_3558_3582:()=>zzt,content_3558_3584:()=>Wzt,content_3558_3586:()=>Rzt,content_3558_3588:()=>Szt,content_3558_3590:()=>Ezt,content_3558_3592:()=>Gzt,content_3558_3594:()=>Fzt,content_3558_3596:()=>qzt,content_3558_3598:()=>Hzt,content_3558_36:()=>Qb,content_3558_360:()=>QR,content_3558_3600:()=>Yzt,content_3558_3602:()=>Kzt,content_3558_3604:()=>tAt,content_3558_3606:()=>nAt,content_3558_3608:()=>pAt,content_3558_3610:()=>sAt,content_3558_3612:()=>iAt,content_3558_3614:()=>lAt,content_3558_3616:()=>mAt,content_3558_3618:()=>hAt,content_3558_362:()=>$R,content_3558_3620:()=>kAt,content_3558_3622:()=>DAt,content_3558_3624:()=>wAt,content_3558_3626:()=>XAt,content_3558_3628:()=>TAt,content_3558_3630:()=>xAt,content_3558_3632:()=>LAt,content_3558_3634:()=>bAt,content_3558_3636:()=>zAt,content_3558_3638:()=>WAt,content_3558_364:()=>JR,content_3558_3640:()=>RAt,content_3558_3642:()=>SAt,content_3558_3644:()=>EAt,content_3558_3646:()=>GAt,content_3558_3648:()=>FAt,content_3558_3650:()=>qAt,content_3558_3652:()=>HAt,content_3558_3654:()=>YAt,content_3558_3656:()=>KAt,content_3558_3658:()=>tWt,content_3558_366:()=>eP,content_3558_3660:()=>nWt,content_3558_3662:()=>pWt,content_3558_3664:()=>sWt,content_3558_3666:()=>iWt,content_3558_3668:()=>lWt,content_3558_3670:()=>mWt,content_3558_3672:()=>hWt,content_3558_3674:()=>kWt,content_3558_3676:()=>DWt,content_3558_3678:()=>wWt,content_3558_368:()=>oP,content_3558_3680:()=>XWt,content_3558_3682:()=>TWt,content_3558_3684:()=>xWt,content_3558_3686:()=>LWt,content_3558_3688:()=>bWt,content_3558_3690:()=>zWt,content_3558_3692:()=>WWt,content_3558_3694:()=>RWt,content_3558_3696:()=>SWt,content_3558_3698:()=>EWt,content_3558_370:()=>rP,content_3558_3700:()=>GWt,content_3558_3702:()=>FWt,content_3558_3704:()=>qWt,content_3558_3706:()=>HWt,content_3558_3708:()=>YWt,content_3558_3710:()=>KWt,content_3558_3712:()=>tIt,content_3558_3714:()=>nIt,content_3558_3716:()=>pIt,content_3558_3718:()=>sIt,content_3558_372:()=>cP,content_3558_3720:()=>iIt,content_3558_3722:()=>lIt,content_3558_3724:()=>mIt,content_3558_3726:()=>hIt,content_3558_3728:()=>kIt,content_3558_3730:()=>DIt,content_3558_3732:()=>wIt,content_3558_3734:()=>XIt,content_3558_3736:()=>TIt,content_3558_3738:()=>xIt,content_3558_374:()=>aP,content_3558_3740:()=>LIt,content_3558_3742:()=>bIt,content_3558_3744:()=>zIt,content_3558_3746:()=>WIt,content_3558_3748:()=>RIt,content_3558_3750:()=>SIt,content_3558_3752:()=>EIt,content_3558_3754:()=>GIt,content_3558_3756:()=>FIt,content_3558_3758:()=>qIt,content_3558_376:()=>uP,content_3558_3760:()=>HIt,content_3558_3762:()=>YIt,content_3558_3764:()=>KIt,content_3558_3766:()=>tRt,content_3558_3768:()=>nRt,content_3558_3770:()=>pRt,content_3558_3772:()=>sRt,content_3558_3774:()=>iRt,content_3558_3776:()=>lRt,content_3558_3778:()=>mRt,content_3558_378:()=>dP,content_3558_3780:()=>hRt,content_3558_3782:()=>kRt,content_3558_3784:()=>DRt,content_3558_3786:()=>wRt,content_3558_3788:()=>XRt,content_3558_3790:()=>TRt,content_3558_3792:()=>xRt,content_3558_3794:()=>LRt,content_3558_3796:()=>bRt,content_3558_3798:()=>zRt,content_3558_38:()=>$b,content_3558_380:()=>fP,content_3558_3800:()=>WRt,content_3558_3802:()=>RRt,content_3558_3804:()=>SRt,content_3558_3806:()=>ERt,content_3558_3808:()=>GRt,content_3558_3810:()=>FRt,content_3558_3812:()=>qRt,content_3558_3814:()=>HRt,content_3558_3816:()=>YRt,content_3558_3818:()=>KRt,content_3558_382:()=>yP,content_3558_3820:()=>tPt,content_3558_3822:()=>nPt,content_3558_3824:()=>pPt,content_3558_3826:()=>sPt,content_3558_3828:()=>iPt,content_3558_3830:()=>lPt,content_3558_3832:()=>mPt,content_3558_3834:()=>hPt,content_3558_3836:()=>kPt,content_3558_3838:()=>DPt,content_3558_384:()=>MP,content_3558_3840:()=>wPt,content_3558_3842:()=>XPt,content_3558_3844:()=>TPt,content_3558_3846:()=>xPt,content_3558_3848:()=>LPt,content_3558_3850:()=>bPt,content_3558_3852:()=>zPt,content_3558_3854:()=>WPt,content_3558_3856:()=>RPt,content_3558_3858:()=>SPt,content_3558_386:()=>_P,content_3558_3860:()=>EPt,content_3558_3862:()=>GPt,content_3558_3864:()=>FPt,content_3558_3866:()=>qPt,content_3558_3868:()=>HPt,content_3558_3870:()=>YPt,content_3558_3872:()=>KPt,content_3558_3874:()=>tSt,content_3558_3876:()=>nSt,content_3558_3878:()=>pSt,content_3558_388:()=>gP,content_3558_3880:()=>sSt,content_3558_3882:()=>iSt,content_3558_3884:()=>lSt,content_3558_3886:()=>mSt,content_3558_3888:()=>hSt,content_3558_3890:()=>kSt,content_3558_3892:()=>DSt,content_3558_3894:()=>wSt,content_3558_3896:()=>XSt,content_3558_3898:()=>TSt,content_3558_390:()=>CP,content_3558_3900:()=>xSt,content_3558_3902:()=>LSt,content_3558_3904:()=>bSt,content_3558_3906:()=>zSt,content_3558_3908:()=>WSt,content_3558_3910:()=>RSt,content_3558_3912:()=>SSt,content_3558_3914:()=>ESt,content_3558_3916:()=>GSt,content_3558_3918:()=>FSt,content_3558_392:()=>vP,content_3558_3920:()=>qSt,content_3558_3922:()=>HSt,content_3558_3924:()=>YSt,content_3558_3926:()=>KSt,content_3558_3928:()=>tOt,content_3558_3930:()=>nOt,content_3558_3932:()=>pOt,content_3558_3934:()=>sOt,content_3558_3936:()=>iOt,content_3558_3938:()=>lOt,content_3558_394:()=>ZP,content_3558_3940:()=>mOt,content_3558_3942:()=>hOt,content_3558_3944:()=>kOt,content_3558_3946:()=>DOt,content_3558_3948:()=>wOt,content_3558_3950:()=>XOt,content_3558_3952:()=>TOt,content_3558_3954:()=>xOt,content_3558_3956:()=>LOt,content_3558_3958:()=>bOt,content_3558_396:()=>NP,content_3558_3960:()=>zOt,content_3558_3962:()=>WOt,content_3558_3964:()=>ROt,content_3558_3966:()=>SOt,content_3558_3968:()=>EOt,content_3558_3970:()=>GOt,content_3558_3972:()=>FOt,content_3558_3974:()=>qOt,content_3558_3976:()=>HOt,content_3558_3978:()=>YOt,content_3558_398:()=>AP,content_3558_3980:()=>KOt,content_3558_3982:()=>tEt,content_3558_3984:()=>nEt,content_3558_3986:()=>pEt,content_3558_3988:()=>sEt,content_3558_3990:()=>iEt,content_3558_3992:()=>lEt,content_3558_3994:()=>mEt,content_3558_3996:()=>hEt,content_3558_3998:()=>kEt,content_3558_4:()=>yb,content_3558_40:()=>Jb,content_3558_400:()=>IP,content_3558_4000:()=>DEt,content_3558_4002:()=>wEt,content_3558_4004:()=>XEt,content_3558_4006:()=>TEt,content_3558_4008:()=>xEt,content_3558_4010:()=>LEt,content_3558_4012:()=>bEt,content_3558_4014:()=>zEt,content_3558_4016:()=>WEt,content_3558_4018:()=>REt,content_3558_402:()=>PP,content_3558_4020:()=>SEt,content_3558_4022:()=>EEt,content_3558_4024:()=>GEt,content_3558_4026:()=>FEt,content_3558_4028:()=>qEt,content_3558_4030:()=>HEt,content_3558_4032:()=>YEt,content_3558_4034:()=>KEt,content_3558_4036:()=>tBt,content_3558_4038:()=>nBt,content_3558_404:()=>OP,content_3558_4040:()=>pBt,content_3558_4042:()=>sBt,content_3558_4044:()=>iBt,content_3558_4046:()=>lBt,content_3558_4048:()=>mBt,content_3558_4050:()=>hBt,content_3558_4052:()=>kBt,content_3558_4054:()=>DBt,content_3558_4056:()=>wBt,content_3558_4058:()=>XBt,content_3558_406:()=>BP,content_3558_4060:()=>TBt,content_3558_4062:()=>xBt,content_3558_4064:()=>LBt,content_3558_4066:()=>bBt,content_3558_4068:()=>zBt,content_3558_4070:()=>WBt,content_3558_4072:()=>RBt,content_3558_4074:()=>SBt,content_3558_4076:()=>EBt,content_3558_4078:()=>GBt,content_3558_408:()=>UP,content_3558_4080:()=>FBt,content_3558_4082:()=>qBt,content_3558_4084:()=>HBt,content_3558_4086:()=>YBt,content_3558_4088:()=>KBt,content_3558_4090:()=>tGt,content_3558_4092:()=>nGt,content_3558_4094:()=>pGt,content_3558_4096:()=>sGt,content_3558_4098:()=>iGt,content_3558_410:()=>VP,content_3558_4100:()=>lGt,content_3558_4102:()=>mGt,content_3558_4104:()=>hGt,content_3558_4106:()=>kGt,content_3558_4108:()=>DGt,content_3558_4110:()=>wGt,content_3558_4112:()=>XGt,content_3558_4114:()=>TGt,content_3558_4116:()=>xGt,content_3558_4118:()=>LGt,content_3558_412:()=>jP,content_3558_4120:()=>bGt,content_3558_4122:()=>zGt,content_3558_4124:()=>WGt,content_3558_4126:()=>RGt,content_3558_4128:()=>SGt,content_3558_4130:()=>EGt,content_3558_4132:()=>GGt,content_3558_4134:()=>FGt,content_3558_4136:()=>qGt,content_3558_4138:()=>HGt,content_3558_414:()=>QP,content_3558_4140:()=>YGt,content_3558_4142:()=>KGt,content_3558_4144:()=>tUt,content_3558_4146:()=>nUt,content_3558_4148:()=>pUt,content_3558_4150:()=>sUt,content_3558_4152:()=>iUt,content_3558_4154:()=>lUt,content_3558_4156:()=>mUt,content_3558_4158:()=>hUt,content_3558_416:()=>$P,content_3558_4160:()=>kUt,content_3558_4162:()=>DUt,content_3558_4164:()=>wUt,content_3558_4166:()=>XUt,content_3558_4168:()=>TUt,content_3558_4170:()=>xUt,content_3558_4172:()=>LUt,content_3558_4174:()=>bUt,content_3558_4176:()=>zUt,content_3558_4178:()=>WUt,content_3558_418:()=>JP,content_3558_4180:()=>RUt,content_3558_4182:()=>SUt,content_3558_4184:()=>EUt,content_3558_4186:()=>GUt,content_3558_4188:()=>FUt,content_3558_4190:()=>qUt,content_3558_4192:()=>HUt,content_3558_4194:()=>YUt,content_3558_4196:()=>KUt,content_3558_4198:()=>tFt,content_3558_42:()=>eN,content_3558_420:()=>eS,content_3558_4200:()=>nFt,content_3558_4202:()=>pFt,content_3558_4204:()=>sFt,content_3558_4206:()=>iFt,content_3558_4208:()=>lFt,content_3558_4210:()=>mFt,content_3558_4212:()=>hFt,content_3558_4214:()=>kFt,content_3558_4216:()=>DFt,content_3558_4218:()=>wFt,content_3558_422:()=>oS,content_3558_4220:()=>XFt,content_3558_4222:()=>TFt,content_3558_4224:()=>xFt,content_3558_4226:()=>LFt,content_3558_4228:()=>bFt,content_3558_4230:()=>zFt,content_3558_4232:()=>WFt,content_3558_4234:()=>RFt,content_3558_4236:()=>SFt,content_3558_4238:()=>EFt,content_3558_424:()=>rS,content_3558_4240:()=>GFt,content_3558_4242:()=>FFt,content_3558_4244:()=>qFt,content_3558_4246:()=>HFt,content_3558_4248:()=>YFt,content_3558_4250:()=>KFt,content_3558_4252:()=>tVt,content_3558_4254:()=>nVt,content_3558_4256:()=>pVt,content_3558_4258:()=>sVt,content_3558_426:()=>cS,content_3558_4260:()=>iVt,content_3558_4262:()=>lVt,content_3558_4264:()=>mVt,content_3558_4266:()=>hVt,content_3558_4268:()=>kVt,content_3558_4270:()=>DVt,content_3558_4272:()=>wVt,content_3558_4274:()=>XVt,content_3558_4276:()=>TVt,content_3558_4278:()=>xVt,content_3558_428:()=>aS,content_3558_4280:()=>LVt,content_3558_4282:()=>bVt,content_3558_4284:()=>zVt,content_3558_4286:()=>WVt,content_3558_4288:()=>RVt,content_3558_4290:()=>SVt,content_3558_4292:()=>EVt,content_3558_4294:()=>GVt,content_3558_4296:()=>FVt,content_3558_4298:()=>qVt,content_3558_430:()=>uS,content_3558_4300:()=>HVt,content_3558_4302:()=>YVt,content_3558_4304:()=>KVt,content_3558_4306:()=>tqt,content_3558_4308:()=>nqt,content_3558_4310:()=>pqt,content_3558_4312:()=>sqt,content_3558_4314:()=>iqt,content_3558_4316:()=>lqt,content_3558_4318:()=>mqt,content_3558_432:()=>dS,content_3558_4320:()=>hqt,content_3558_4322:()=>kqt,content_3558_4324:()=>Dqt,content_3558_4326:()=>wqt,content_3558_4328:()=>Xqt,content_3558_4330:()=>Tqt,content_3558_4332:()=>xqt,content_3558_4334:()=>Lqt,content_3558_4336:()=>bqt,content_3558_4338:()=>zqt,content_3558_434:()=>fS,content_3558_4340:()=>Wqt,content_3558_4342:()=>Rqt,content_3558_4344:()=>Sqt,content_3558_4346:()=>Eqt,content_3558_4348:()=>Gqt,content_3558_4350:()=>Fqt,content_3558_4352:()=>qqt,content_3558_4354:()=>Hqt,content_3558_4356:()=>Yqt,content_3558_4358:()=>Kqt,content_3558_436:()=>yS,content_3558_4360:()=>tjt,content_3558_4362:()=>njt,content_3558_4364:()=>pjt,content_3558_4366:()=>sjt,content_3558_4368:()=>ijt,content_3558_4370:()=>ljt,content_3558_4372:()=>mjt,content_3558_4374:()=>hjt,content_3558_4376:()=>kjt,content_3558_4378:()=>Djt,content_3558_438:()=>MS,content_3558_4380:()=>wjt,content_3558_4382:()=>Xjt,content_3558_4384:()=>Tjt,content_3558_4386:()=>xjt,content_3558_4388:()=>Ljt,content_3558_4390:()=>bjt,content_3558_4392:()=>zjt,content_3558_4394:()=>Wjt,content_3558_4396:()=>Rjt,content_3558_4398:()=>Sjt,content_3558_44:()=>oN,content_3558_440:()=>_S,content_3558_4400:()=>Ejt,content_3558_4402:()=>Gjt,content_3558_4404:()=>Fjt,content_3558_4406:()=>qjt,content_3558_4408:()=>Hjt,content_3558_4410:()=>Yjt,content_3558_4412:()=>Kjt,content_3558_4414:()=>tHt,content_3558_4416:()=>nHt,content_3558_4418:()=>pHt,content_3558_442:()=>gS,content_3558_4420:()=>sHt,content_3558_4422:()=>iHt,content_3558_4424:()=>lHt,content_3558_4426:()=>mHt,content_3558_4428:()=>hHt,content_3558_4430:()=>kHt,content_3558_4432:()=>DHt,content_3558_4434:()=>wHt,content_3558_4436:()=>XHt,content_3558_4438:()=>THt,content_3558_444:()=>CS,content_3558_4440:()=>xHt,content_3558_4442:()=>LHt,content_3558_4444:()=>bHt,content_3558_4446:()=>zHt,content_3558_4448:()=>WHt,content_3558_4450:()=>RHt,content_3558_4452:()=>SHt,content_3558_4454:()=>EHt,content_3558_4456:()=>GHt,content_3558_4458:()=>FHt,content_3558_446:()=>vS,content_3558_4460:()=>qHt,content_3558_4462:()=>HHt,content_3558_4464:()=>YHt,content_3558_4466:()=>KHt,content_3558_4468:()=>tQt,content_3558_4470:()=>nQt,content_3558_4472:()=>pQt,content_3558_4474:()=>sQt,content_3558_4476:()=>iQt,content_3558_4478:()=>lQt,content_3558_448:()=>ZS,content_3558_4480:()=>mQt,content_3558_4482:()=>hQt,content_3558_4484:()=>kQt,content_3558_4486:()=>DQt,content_3558_4488:()=>wQt,content_3558_4490:()=>XQt,content_3558_4492:()=>TQt,content_3558_4494:()=>xQt,content_3558_4496:()=>LQt,content_3558_4498:()=>bQt,content_3558_450:()=>NS,content_3558_4500:()=>zQt,content_3558_4502:()=>WQt,content_3558_4504:()=>RQt,content_3558_4506:()=>SQt,content_3558_4508:()=>EQt,content_3558_4510:()=>GQt,content_3558_4512:()=>FQt,content_3558_4514:()=>qQt,content_3558_4516:()=>HQt,content_3558_4518:()=>YQt,content_3558_452:()=>AS,content_3558_4520:()=>KQt,content_3558_4522:()=>tYt,content_3558_4524:()=>nYt,content_3558_4526:()=>pYt,content_3558_4528:()=>sYt,content_3558_4530:()=>iYt,content_3558_4532:()=>lYt,content_3558_4534:()=>mYt,content_3558_4536:()=>hYt,content_3558_4538:()=>kYt,content_3558_454:()=>IS,content_3558_4540:()=>DYt,content_3558_4542:()=>wYt,content_3558_4544:()=>XYt,content_3558_4546:()=>TYt,content_3558_4548:()=>xYt,content_3558_4550:()=>LYt,content_3558_4552:()=>bYt,content_3558_4554:()=>zYt,content_3558_4556:()=>WYt,content_3558_4558:()=>RYt,content_3558_456:()=>PS,content_3558_4560:()=>SYt,content_3558_4562:()=>EYt,content_3558_4564:()=>GYt,content_3558_4566:()=>FYt,content_3558_4568:()=>qYt,content_3558_4570:()=>HYt,content_3558_4572:()=>YYt,content_3558_4574:()=>KYt,content_3558_4576:()=>t$t,content_3558_4578:()=>n$t,content_3558_458:()=>OS,content_3558_4580:()=>p$t,content_3558_4582:()=>s$t,content_3558_4584:()=>i$t,content_3558_4586:()=>l$t,content_3558_4588:()=>m$t,content_3558_4590:()=>h$t,content_3558_4592:()=>k$t,content_3558_4594:()=>D$t,content_3558_4596:()=>w$t,content_3558_4598:()=>X$t,content_3558_46:()=>rN,content_3558_460:()=>BS,content_3558_4600:()=>T$t,content_3558_4602:()=>x$t,content_3558_4604:()=>L$t,content_3558_4606:()=>b$t,content_3558_4608:()=>z$t,content_3558_4610:()=>W$t,content_3558_4612:()=>R$t,content_3558_4614:()=>S$t,content_3558_4616:()=>E$t,content_3558_4618:()=>G$t,content_3558_462:()=>US,content_3558_4620:()=>F$t,content_3558_4622:()=>q$t,content_3558_4624:()=>H$t,content_3558_4626:()=>Y$t,content_3558_4628:()=>K$t,content_3558_4630:()=>tKt,content_3558_4632:()=>nKt,content_3558_4634:()=>pKt,content_3558_4636:()=>sKt,content_3558_4638:()=>iKt,content_3558_464:()=>VS,content_3558_4640:()=>lKt,content_3558_4642:()=>mKt,content_3558_4644:()=>hKt,content_3558_4646:()=>kKt,content_3558_4648:()=>DKt,content_3558_4650:()=>wKt,content_3558_4652:()=>XKt,content_3558_4654:()=>TKt,content_3558_4656:()=>xKt,content_3558_4658:()=>LKt,content_3558_466:()=>jS,content_3558_4660:()=>bKt,content_3558_4662:()=>zKt,content_3558_4664:()=>WKt,content_3558_4666:()=>RKt,content_3558_4668:()=>SKt,content_3558_4670:()=>EKt,content_3558_4672:()=>GKt,content_3558_4674:()=>FKt,content_3558_4676:()=>qKt,content_3558_4678:()=>HKt,content_3558_468:()=>QS,content_3558_4680:()=>YKt,content_3558_4682:()=>KKt,content_3558_4684:()=>tJt,content_3558_4686:()=>nJt,content_3558_4688:()=>pJt,content_3558_4690:()=>sJt,content_3558_4692:()=>iJt,content_3558_4694:()=>lJt,content_3558_4696:()=>mJt,content_3558_4698:()=>hJt,content_3558_470:()=>$S,content_3558_4700:()=>kJt,content_3558_4702:()=>DJt,content_3558_4704:()=>wJt,content_3558_4706:()=>XJt,content_3558_4708:()=>TJt,content_3558_4710:()=>xJt,content_3558_4712:()=>LJt,content_3558_4714:()=>bJt,content_3558_4716:()=>zJt,content_3558_4718:()=>WJt,content_3558_472:()=>JS,content_3558_4720:()=>RJt,content_3558_4722:()=>SJt,content_3558_4724:()=>EJt,content_3558_4726:()=>GJt,content_3558_4728:()=>FJt,content_3558_4730:()=>qJt,content_3558_4732:()=>HJt,content_3558_4734:()=>YJt,content_3558_4736:()=>KJt,content_3558_4738:()=>t0t,content_3558_474:()=>eO,content_3558_4740:()=>n0t,content_3558_4742:()=>p0t,content_3558_4744:()=>s0t,content_3558_4746:()=>i0t,content_3558_4748:()=>l0t,content_3558_4750:()=>m0t,content_3558_4752:()=>h0t,content_3558_4754:()=>k0t,content_3558_4756:()=>D0t,content_3558_4758:()=>w0t,content_3558_476:()=>oO,content_3558_4760:()=>X0t,content_3558_4762:()=>T0t,content_3558_4764:()=>x0t,content_3558_4766:()=>L0t,content_3558_4768:()=>b0t,content_3558_4770:()=>z0t,content_3558_4772:()=>W0t,content_3558_4774:()=>R0t,content_3558_4776:()=>S0t,content_3558_4778:()=>E0t,content_3558_478:()=>rO,content_3558_4780:()=>G0t,content_3558_4782:()=>F0t,content_3558_4784:()=>q0t,content_3558_4786:()=>H0t,content_3558_4788:()=>Y0t,content_3558_4790:()=>K0t,content_3558_4792:()=>t5t,content_3558_4794:()=>n5t,content_3558_4796:()=>p5t,content_3558_4798:()=>s5t,content_3558_48:()=>cN,content_3558_480:()=>cO,content_3558_4800:()=>i5t,content_3558_4802:()=>l5t,content_3558_4804:()=>m5t,content_3558_4806:()=>h5t,content_3558_4808:()=>k5t,content_3558_4810:()=>D5t,content_3558_4812:()=>w5t,content_3558_4814:()=>X5t,content_3558_4816:()=>T5t,content_3558_4818:()=>x5t,content_3558_482:()=>aO,content_3558_4820:()=>L5t,content_3558_4822:()=>b5t,content_3558_4824:()=>z5t,content_3558_4826:()=>W5t,content_3558_4828:()=>R5t,content_3558_4830:()=>S5t,content_3558_4832:()=>E5t,content_3558_4834:()=>G5t,content_3558_4836:()=>F5t,content_3558_4838:()=>q5t,content_3558_484:()=>uO,content_3558_4840:()=>H5t,content_3558_4842:()=>Y5t,content_3558_4844:()=>K5t,content_3558_4846:()=>t8t,content_3558_4848:()=>n8t,content_3558_4850:()=>p8t,content_3558_4852:()=>s8t,content_3558_4854:()=>i8t,content_3558_4856:()=>l8t,content_3558_4858:()=>m8t,content_3558_486:()=>dO,content_3558_4860:()=>h8t,content_3558_4862:()=>k8t,content_3558_4864:()=>D8t,content_3558_4866:()=>w8t,content_3558_4868:()=>X8t,content_3558_4870:()=>T8t,content_3558_4872:()=>x8t,content_3558_4874:()=>L8t,content_3558_4876:()=>b8t,content_3558_4878:()=>z8t,content_3558_488:()=>fO,content_3558_4880:()=>W8t,content_3558_4882:()=>R8t,content_3558_4884:()=>S8t,content_3558_4886:()=>E8t,content_3558_4888:()=>G8t,content_3558_4890:()=>F8t,content_3558_4892:()=>q8t,content_3558_4894:()=>H8t,content_3558_4896:()=>Y8t,content_3558_4898:()=>K8t,content_3558_490:()=>yO,content_3558_4900:()=>t3t,content_3558_4902:()=>n3t,content_3558_4904:()=>p3t,content_3558_4906:()=>s3t,content_3558_4908:()=>i3t,content_3558_4910:()=>l3t,content_3558_4912:()=>m3t,content_3558_4914:()=>h3t,content_3558_4916:()=>k3t,content_3558_4918:()=>D3t,content_3558_492:()=>MO,content_3558_4920:()=>w3t,content_3558_4922:()=>X3t,content_3558_4924:()=>T3t,content_3558_4926:()=>x3t,content_3558_4928:()=>L3t,content_3558_4930:()=>b3t,content_3558_4932:()=>z3t,content_3558_4934:()=>W3t,content_3558_4936:()=>R3t,content_3558_4938:()=>S3t,content_3558_494:()=>_O,content_3558_4940:()=>E3t,content_3558_4942:()=>G3t,content_3558_4944:()=>F3t,content_3558_4946:()=>q3t,content_3558_4948:()=>H3t,content_3558_4950:()=>Y3t,content_3558_4952:()=>K3t,content_3558_4954:()=>t2t,content_3558_4956:()=>n2t,content_3558_4958:()=>p2t,content_3558_496:()=>gO,content_3558_4960:()=>s2t,content_3558_4962:()=>i2t,content_3558_4964:()=>l2t,content_3558_4966:()=>m2t,content_3558_4968:()=>h2t,content_3558_4970:()=>k2t,content_3558_4972:()=>D2t,content_3558_4974:()=>w2t,content_3558_4976:()=>X2t,content_3558_4978:()=>T2t,content_3558_498:()=>CO,content_3558_4980:()=>x2t,content_3558_4982:()=>L2t,content_3558_4984:()=>b2t,content_3558_4986:()=>z2t,content_3558_4988:()=>W2t,content_3558_4990:()=>R2t,content_3558_4992:()=>S2t,content_3558_4994:()=>E2t,content_3558_4996:()=>G2t,content_3558_4998:()=>F2t,content_3558_50:()=>aN,content_3558_500:()=>vO,content_3558_5000:()=>q2t,content_3558_5002:()=>H2t,content_3558_5004:()=>Y2t,content_3558_5006:()=>K2t,content_3558_5008:()=>t1t,content_3558_5010:()=>n1t,content_3558_5012:()=>p1t,content_3558_5014:()=>s1t,content_3558_5016:()=>i1t,content_3558_5018:()=>l1t,content_3558_502:()=>ZO,content_3558_5020:()=>m1t,content_3558_5022:()=>h1t,content_3558_5024:()=>k1t,content_3558_5026:()=>D1t,content_3558_5028:()=>w1t,content_3558_5030:()=>X1t,content_3558_5032:()=>T1t,content_3558_5034:()=>x1t,content_3558_5036:()=>L1t,content_3558_5038:()=>b1t,content_3558_504:()=>NO,content_3558_5040:()=>z1t,content_3558_5042:()=>W1t,content_3558_5044:()=>R1t,content_3558_5046:()=>S1t,content_3558_5048:()=>E1t,content_3558_5050:()=>G1t,content_3558_5052:()=>F1t,content_3558_5054:()=>q1t,content_3558_5056:()=>H1t,content_3558_5058:()=>Y1t,content_3558_506:()=>AO,content_3558_5060:()=>K1t,content_3558_5062:()=>t4t,content_3558_5064:()=>n4t,content_3558_5066:()=>p4t,content_3558_5068:()=>s4t,content_3558_5070:()=>i4t,content_3558_5072:()=>l4t,content_3558_5074:()=>m4t,content_3558_5076:()=>h4t,content_3558_5078:()=>k4t,content_3558_508:()=>IO,content_3558_5080:()=>D4t,content_3558_5082:()=>w4t,content_3558_5084:()=>X4t,content_3558_5086:()=>T4t,content_3558_5088:()=>x4t,content_3558_5090:()=>L4t,content_3558_5092:()=>b4t,content_3558_5094:()=>z4t,content_3558_5096:()=>W4t,content_3558_5098:()=>R4t,content_3558_510:()=>PO,content_3558_5100:()=>S4t,content_3558_5102:()=>E4t,content_3558_5104:()=>G4t,content_3558_5106:()=>F4t,content_3558_5108:()=>q4t,content_3558_5110:()=>H4t,content_3558_5112:()=>Y4t,content_3558_5114:()=>K4t,content_3558_5116:()=>t6t,content_3558_5118:()=>n6t,content_3558_512:()=>OO,content_3558_5120:()=>p6t,content_3558_5122:()=>s6t,content_3558_5124:()=>i6t,content_3558_5126:()=>l6t,content_3558_5128:()=>m6t,content_3558_5130:()=>h6t,content_3558_5132:()=>k6t,content_3558_5134:()=>D6t,content_3558_5136:()=>w6t,content_3558_5138:()=>X6t,content_3558_514:()=>BO,content_3558_5140:()=>T6t,content_3558_5142:()=>x6t,content_3558_5144:()=>L6t,content_3558_5146:()=>b6t,content_3558_5148:()=>z6t,content_3558_5150:()=>W6t,content_3558_5152:()=>R6t,content_3558_5154:()=>S6t,content_3558_5156:()=>E6t,content_3558_5158:()=>G6t,content_3558_516:()=>UO,content_3558_5160:()=>F6t,content_3558_5162:()=>q6t,content_3558_5164:()=>H6t,content_3558_5166:()=>Y6t,content_3558_5168:()=>K6t,content_3558_5170:()=>t7t,content_3558_5172:()=>n7t,content_3558_5174:()=>p7t,content_3558_5176:()=>s7t,content_3558_5178:()=>i7t,content_3558_518:()=>VO,content_3558_5180:()=>l7t,content_3558_5182:()=>m7t,content_3558_5184:()=>h7t,content_3558_5186:()=>k7t,content_3558_5188:()=>D7t,content_3558_5190:()=>w7t,content_3558_5192:()=>X7t,content_3558_5194:()=>T7t,content_3558_5196:()=>x7t,content_3558_5198:()=>L7t,content_3558_52:()=>uN,content_3558_520:()=>jO,content_3558_5200:()=>b7t,content_3558_5202:()=>z7t,content_3558_5204:()=>W7t,content_3558_5206:()=>R7t,content_3558_5208:()=>S7t,content_3558_5210:()=>E7t,content_3558_5212:()=>G7t,content_3558_5214:()=>F7t,content_3558_5216:()=>q7t,content_3558_5218:()=>H7t,content_3558_522:()=>QO,content_3558_5220:()=>Y7t,content_3558_5222:()=>K7t,content_3558_5224:()=>t9t,content_3558_5226:()=>n9t,content_3558_5228:()=>p9t,content_3558_5230:()=>s9t,content_3558_5232:()=>i9t,content_3558_5234:()=>l9t,content_3558_5236:()=>m9t,content_3558_5238:()=>h9t,content_3558_524:()=>$O,content_3558_5240:()=>k9t,content_3558_5242:()=>D9t,content_3558_5244:()=>w9t,content_3558_5246:()=>X9t,content_3558_5248:()=>T9t,content_3558_5250:()=>x9t,content_3558_5252:()=>L9t,content_3558_5254:()=>b9t,content_3558_5256:()=>z9t,content_3558_5258:()=>W9t,content_3558_526:()=>JO,content_3558_5260:()=>R9t,content_3558_5262:()=>S9t,content_3558_5264:()=>E9t,content_3558_5266:()=>G9t,content_3558_5268:()=>F9t,content_3558_5270:()=>q9t,content_3558_5272:()=>H9t,content_3558_5274:()=>Y9t,content_3558_5276:()=>K9t,content_3558_5278:()=>tte,content_3558_528:()=>eE,content_3558_5280:()=>nte,content_3558_5282:()=>pte,content_3558_5284:()=>ste,content_3558_5286:()=>ite,content_3558_5288:()=>lte,content_3558_5290:()=>mte,content_3558_5292:()=>hte,content_3558_5294:()=>kte,content_3558_5296:()=>Dte,content_3558_5298:()=>wte,content_3558_530:()=>oE,content_3558_5300:()=>Xte,content_3558_5302:()=>Tte,content_3558_5304:()=>xte,content_3558_5306:()=>Lte,content_3558_5308:()=>bte,content_3558_5310:()=>zte,content_3558_5312:()=>Wte,content_3558_5314:()=>Rte,content_3558_5316:()=>Ste,content_3558_5318:()=>Ete,content_3558_532:()=>rE,content_3558_5320:()=>Gte,content_3558_5322:()=>Fte,content_3558_5324:()=>qte,content_3558_5326:()=>Hte,content_3558_5328:()=>Yte,content_3558_5330:()=>Kte,content_3558_5332:()=>tee,content_3558_5334:()=>nee,content_3558_5336:()=>pee,content_3558_5338:()=>see,content_3558_534:()=>cE,content_3558_5340:()=>iee,content_3558_5342:()=>lee,content_3558_5344:()=>mee,content_3558_5346:()=>hee,content_3558_5348:()=>kee,content_3558_5350:()=>Dee,content_3558_5352:()=>wee,content_3558_5354:()=>Xee,content_3558_5356:()=>Tee,content_3558_5358:()=>xee,content_3558_536:()=>aE,content_3558_5360:()=>Lee,content_3558_5362:()=>bee,content_3558_5364:()=>zee,content_3558_5366:()=>Wee,content_3558_5368:()=>Ree,content_3558_5370:()=>See,content_3558_5372:()=>Eee,content_3558_5374:()=>Gee,content_3558_5376:()=>Fee,content_3558_5378:()=>qee,content_3558_538:()=>uE,content_3558_5380:()=>Hee,content_3558_5382:()=>Yee,content_3558_5384:()=>Kee,content_3558_5386:()=>tne,content_3558_5388:()=>nne,content_3558_5390:()=>pne,content_3558_5392:()=>sne,content_3558_5394:()=>ine,content_3558_5396:()=>lne,content_3558_5398:()=>mne,content_3558_54:()=>dN,content_3558_540:()=>dE,content_3558_5400:()=>hne,content_3558_5402:()=>kne,content_3558_5404:()=>Dne,content_3558_5406:()=>wne,content_3558_5408:()=>Xne,content_3558_5410:()=>Tne,content_3558_5412:()=>xne,content_3558_5414:()=>Lne,content_3558_5416:()=>bne,content_3558_5418:()=>zne,content_3558_542:()=>fE,content_3558_5420:()=>Wne,content_3558_5422:()=>Rne,content_3558_5424:()=>Sne,content_3558_5426:()=>Ene,content_3558_5428:()=>Gne,content_3558_5430:()=>Fne,content_3558_5432:()=>qne,content_3558_5434:()=>Hne,content_3558_5436:()=>Yne,content_3558_5438:()=>Kne,content_3558_544:()=>yE,content_3558_5440:()=>toe,content_3558_5442:()=>noe,content_3558_5444:()=>poe,content_3558_5446:()=>soe,content_3558_5448:()=>ioe,content_3558_5450:()=>loe,content_3558_5452:()=>moe,content_3558_5454:()=>hoe,content_3558_5456:()=>koe,content_3558_5458:()=>Doe,content_3558_546:()=>ME,content_3558_5460:()=>woe,content_3558_5462:()=>Xoe,content_3558_5464:()=>Toe,content_3558_5466:()=>xoe,content_3558_5468:()=>Loe,content_3558_5470:()=>boe,content_3558_5472:()=>zoe,content_3558_5474:()=>Woe,content_3558_5476:()=>Roe,content_3558_5478:()=>Soe,content_3558_548:()=>_E,content_3558_5480:()=>Eoe,content_3558_5482:()=>Goe,content_3558_5484:()=>Foe,content_3558_5486:()=>qoe,content_3558_5488:()=>Hoe,content_3558_5490:()=>Yoe,content_3558_5492:()=>Koe,content_3558_5494:()=>tpe,content_3558_5496:()=>npe,content_3558_5498:()=>ppe,content_3558_550:()=>gE,content_3558_5500:()=>spe,content_3558_5502:()=>ipe,content_3558_5504:()=>lpe,content_3558_5506:()=>mpe,content_3558_5508:()=>hpe,content_3558_5510:()=>kpe,content_3558_5512:()=>Dpe,content_3558_5514:()=>wpe,content_3558_5516:()=>Xpe,content_3558_5518:()=>Tpe,content_3558_552:()=>CE,content_3558_5520:()=>xpe,content_3558_5522:()=>Lpe,content_3558_5524:()=>bpe,content_3558_5526:()=>zpe,content_3558_5528:()=>Wpe,content_3558_5530:()=>Rpe,content_3558_5532:()=>Spe,content_3558_5534:()=>Epe,content_3558_5536:()=>Gpe,content_3558_5538:()=>Fpe,content_3558_554:()=>vE,content_3558_5540:()=>qpe,content_3558_5542:()=>Hpe,content_3558_5544:()=>Ype,content_3558_5546:()=>Kpe,content_3558_5548:()=>tre,content_3558_5550:()=>nre,content_3558_5552:()=>pre,content_3558_5554:()=>sre,content_3558_5556:()=>ire,content_3558_5558:()=>lre,content_3558_556:()=>ZE,content_3558_5560:()=>mre,content_3558_5562:()=>hre,content_3558_5564:()=>kre,content_3558_5566:()=>Dre,content_3558_5568:()=>wre,content_3558_5570:()=>Xre,content_3558_5572:()=>Tre,content_3558_5574:()=>xre,content_3558_5576:()=>Lre,content_3558_5578:()=>bre,content_3558_558:()=>NE,content_3558_5580:()=>zre,content_3558_5582:()=>Wre,content_3558_5584:()=>Rre,content_3558_5586:()=>Sre,content_3558_5588:()=>Ere,content_3558_5590:()=>Gre,content_3558_5592:()=>Fre,content_3558_5594:()=>qre,content_3558_5596:()=>Hre,content_3558_5598:()=>Yre,content_3558_56:()=>fN,content_3558_560:()=>AE,content_3558_5600:()=>Kre,content_3558_5602:()=>tse,content_3558_5604:()=>nse,content_3558_5606:()=>pse,content_3558_5608:()=>sse,content_3558_5610:()=>ise,content_3558_5612:()=>lse,content_3558_5614:()=>mse,content_3558_5616:()=>hse,content_3558_5618:()=>kse,content_3558_562:()=>IE,content_3558_5620:()=>Dse,content_3558_5622:()=>wse,content_3558_5624:()=>Xse,content_3558_5626:()=>Tse,content_3558_5628:()=>xse,content_3558_5630:()=>Lse,content_3558_5632:()=>bse,content_3558_5634:()=>zse,content_3558_5636:()=>Wse,content_3558_5638:()=>Rse,content_3558_564:()=>PE,content_3558_5640:()=>Sse,content_3558_5642:()=>Ese,content_3558_5644:()=>Gse,content_3558_5646:()=>Fse,content_3558_5648:()=>qse,content_3558_5650:()=>Hse,content_3558_5652:()=>Yse,content_3558_5654:()=>Kse,content_3558_5656:()=>tce,content_3558_5658:()=>nce,content_3558_566:()=>OE,content_3558_5660:()=>pce,content_3558_5662:()=>sce,content_3558_5664:()=>ice,content_3558_5666:()=>lce,content_3558_5668:()=>mce,content_3558_5670:()=>hce,content_3558_5672:()=>kce,content_3558_5674:()=>Dce,content_3558_5676:()=>wce,content_3558_5678:()=>Xce,content_3558_568:()=>BE,content_3558_5680:()=>Tce,content_3558_5682:()=>xce,content_3558_5684:()=>Lce,content_3558_5686:()=>bce,content_3558_5688:()=>zce,content_3558_5690:()=>Wce,content_3558_5692:()=>Rce,content_3558_5694:()=>Sce,content_3558_5696:()=>Ece,content_3558_5698:()=>Gce,content_3558_570:()=>UE,content_3558_5700:()=>Fce,content_3558_5702:()=>qce,content_3558_5704:()=>Hce,content_3558_5706:()=>Yce,content_3558_5708:()=>Kce,content_3558_5710:()=>tie,content_3558_5712:()=>nie,content_3558_5714:()=>pie,content_3558_5716:()=>sie,content_3558_5718:()=>iie,content_3558_572:()=>VE,content_3558_5720:()=>lie,content_3558_5722:()=>mie,content_3558_5724:()=>hie,content_3558_5726:()=>kie,content_3558_5728:()=>Die,content_3558_5730:()=>wie,content_3558_5732:()=>Xie,content_3558_5734:()=>Tie,content_3558_5736:()=>xie,content_3558_5738:()=>Lie,content_3558_574:()=>jE,content_3558_5740:()=>bie,content_3558_5742:()=>zie,content_3558_5744:()=>Wie,content_3558_5746:()=>Rie,content_3558_5748:()=>Sie,content_3558_5750:()=>Eie,content_3558_5752:()=>Gie,content_3558_5754:()=>Fie,content_3558_5756:()=>qie,content_3558_5758:()=>Hie,content_3558_576:()=>QE,content_3558_5760:()=>Yie,content_3558_5762:()=>Kie,content_3558_5764:()=>tae,content_3558_5766:()=>nae,content_3558_5768:()=>pae,content_3558_5770:()=>sae,content_3558_5772:()=>iae,content_3558_5774:()=>lae,content_3558_5776:()=>mae,content_3558_5778:()=>hae,content_3558_578:()=>$E,content_3558_5780:()=>kae,content_3558_5782:()=>Dae,content_3558_5784:()=>wae,content_3558_5786:()=>Xae,content_3558_5788:()=>Tae,content_3558_5790:()=>xae,content_3558_5792:()=>Lae,content_3558_5794:()=>bae,content_3558_5796:()=>zae,content_3558_5798:()=>Wae,content_3558_58:()=>yN,content_3558_580:()=>JE,content_3558_5800:()=>Rae,content_3558_5802:()=>Sae,content_3558_5804:()=>Eae,content_3558_5806:()=>Gae,content_3558_5808:()=>Fae,content_3558_5810:()=>qae,content_3558_5812:()=>Hae,content_3558_5814:()=>Yae,content_3558_5816:()=>Kae,content_3558_5818:()=>tle,content_3558_582:()=>eB,content_3558_5820:()=>nle,content_3558_5822:()=>ple,content_3558_5824:()=>sle,content_3558_5826:()=>ile,content_3558_5828:()=>lle,content_3558_5830:()=>mle,content_3558_5832:()=>hle,content_3558_5834:()=>kle,content_3558_5836:()=>Dle,content_3558_5838:()=>wle,content_3558_584:()=>oB,content_3558_5840:()=>Xle,content_3558_5842:()=>Tle,content_3558_5844:()=>xle,content_3558_5846:()=>Lle,content_3558_5848:()=>ble,content_3558_5850:()=>zle,content_3558_5852:()=>Wle,content_3558_5854:()=>Rle,content_3558_5856:()=>Sle,content_3558_5858:()=>Ele,content_3558_586:()=>rB,content_3558_5860:()=>Gle,content_3558_5862:()=>Fle,content_3558_5864:()=>qle,content_3558_5866:()=>Hle,content_3558_5868:()=>Yle,content_3558_5870:()=>Kle,content_3558_5872:()=>tue,content_3558_5874:()=>nue,content_3558_5876:()=>pue,content_3558_5878:()=>sue,content_3558_588:()=>cB,content_3558_5880:()=>iue,content_3558_5882:()=>lue,content_3558_5884:()=>mue,content_3558_5886:()=>hue,content_3558_5888:()=>kue,content_3558_5890:()=>Due,content_3558_5892:()=>wue,content_3558_5894:()=>Xue,content_3558_5896:()=>Tue,content_3558_5898:()=>xue,content_3558_590:()=>aB,content_3558_5900:()=>Lue,content_3558_5902:()=>bue,content_3558_5904:()=>zue,content_3558_5906:()=>Wue,content_3558_5908:()=>Rue,content_3558_5910:()=>Sue,content_3558_5912:()=>Eue,content_3558_5914:()=>Gue,content_3558_5916:()=>Fue,content_3558_5918:()=>que,content_3558_592:()=>uB,content_3558_5920:()=>Hue,content_3558_5922:()=>Yue,content_3558_5924:()=>Kue,content_3558_5926:()=>tme,content_3558_5928:()=>nme,content_3558_5930:()=>pme,content_3558_5932:()=>sme,content_3558_5934:()=>ime,content_3558_5936:()=>lme,content_3558_5938:()=>mme,content_3558_594:()=>dB,content_3558_5940:()=>hme,content_3558_5942:()=>kme,content_3558_5944:()=>Dme,content_3558_5946:()=>wme,content_3558_5948:()=>Xme,content_3558_5950:()=>Tme,content_3558_5952:()=>xme,content_3558_5954:()=>Lme,content_3558_5956:()=>bme,content_3558_5958:()=>zme,content_3558_596:()=>fB,content_3558_5960:()=>Wme,content_3558_5962:()=>Rme,content_3558_5964:()=>Sme,content_3558_5966:()=>Eme,content_3558_5968:()=>Gme,content_3558_5970:()=>Fme,content_3558_5972:()=>qme,content_3558_5974:()=>Hme,content_3558_5976:()=>Yme,content_3558_5978:()=>Kme,content_3558_598:()=>yB,content_3558_5980:()=>tde,content_3558_5982:()=>nde,content_3558_5984:()=>pde,content_3558_5986:()=>sde,content_3558_5988:()=>ide,content_3558_5990:()=>lde,content_3558_5992:()=>mde,content_3558_5994:()=>hde,content_3558_5996:()=>kde,content_3558_5998:()=>Dde,content_3558_6:()=>Mb,content_3558_60:()=>MN,content_3558_600:()=>MB,content_3558_6000:()=>wde,content_3558_6002:()=>Xde,content_3558_6004:()=>Tde,content_3558_6006:()=>xde,content_3558_6008:()=>Lde,content_3558_6010:()=>bde,content_3558_6012:()=>zde,content_3558_6014:()=>Wde,content_3558_6016:()=>Rde,content_3558_6018:()=>Sde,content_3558_602:()=>_B,content_3558_6020:()=>Ede,content_3558_6022:()=>Gde,content_3558_6024:()=>Fde,content_3558_6026:()=>qde,content_3558_6028:()=>Hde,content_3558_6030:()=>Yde,content_3558_6032:()=>Kde,content_3558_6034:()=>the,content_3558_6036:()=>nhe,content_3558_6038:()=>phe,content_3558_604:()=>gB,content_3558_6040:()=>she,content_3558_6042:()=>ihe,content_3558_6044:()=>lhe,content_3558_6046:()=>mhe,content_3558_6048:()=>hhe,content_3558_6050:()=>khe,content_3558_6052:()=>Dhe,content_3558_6054:()=>whe,content_3558_6056:()=>Xhe,content_3558_6058:()=>The,content_3558_606:()=>CB,content_3558_6060:()=>xhe,content_3558_6062:()=>Lhe,content_3558_6064:()=>bhe,content_3558_6066:()=>zhe,content_3558_6068:()=>Whe,content_3558_6070:()=>Rhe,content_3558_6072:()=>She,content_3558_6074:()=>Ehe,content_3558_6076:()=>Ghe,content_3558_6078:()=>Fhe,content_3558_608:()=>vB,content_3558_6080:()=>qhe,content_3558_6082:()=>Hhe,content_3558_6084:()=>Yhe,content_3558_6086:()=>Khe,content_3558_6088:()=>tfe,content_3558_6090:()=>nfe,content_3558_6092:()=>pfe,content_3558_6094:()=>sfe,content_3558_6096:()=>ife,content_3558_6098:()=>lfe,content_3558_610:()=>ZB,content_3558_6100:()=>mfe,content_3558_6102:()=>hfe,content_3558_6104:()=>kfe,content_3558_6106:()=>Dfe,content_3558_6108:()=>wfe,content_3558_6110:()=>Xfe,content_3558_6112:()=>Tfe,content_3558_6114:()=>xfe,content_3558_6116:()=>Lfe,content_3558_6118:()=>bfe,content_3558_612:()=>NB,content_3558_6120:()=>zfe,content_3558_6122:()=>Wfe,content_3558_6124:()=>Rfe,content_3558_6126:()=>Sfe,content_3558_6128:()=>Efe,content_3558_6130:()=>Gfe,content_3558_6132:()=>Ffe,content_3558_6134:()=>qfe,content_3558_6136:()=>Hfe,content_3558_6138:()=>Yfe,content_3558_614:()=>AB,content_3558_6140:()=>Kfe,content_3558_6142:()=>tke,content_3558_6144:()=>nke,content_3558_6146:()=>pke,content_3558_6148:()=>ske,content_3558_6150:()=>ike,content_3558_6152:()=>lke,content_3558_6154:()=>mke,content_3558_6156:()=>hke,content_3558_6158:()=>kke,content_3558_616:()=>IB,content_3558_6160:()=>Dke,content_3558_6162:()=>wke,content_3558_6164:()=>Xke,content_3558_6166:()=>Tke,content_3558_6168:()=>xke,content_3558_6170:()=>Lke,content_3558_6172:()=>bke,content_3558_6174:()=>zke,content_3558_6176:()=>Wke,content_3558_6178:()=>Rke,content_3558_618:()=>PB,content_3558_6180:()=>Ske,content_3558_6182:()=>Eke,content_3558_6184:()=>Gke,content_3558_6186:()=>Fke,content_3558_6188:()=>qke,content_3558_6190:()=>Hke,content_3558_6192:()=>Yke,content_3558_6194:()=>Kke,content_3558_6196:()=>tye,content_3558_6198:()=>nye,content_3558_62:()=>_N,content_3558_620:()=>OB,content_3558_6200:()=>pye,content_3558_6202:()=>sye,content_3558_6204:()=>iye,content_3558_6206:()=>lye,content_3558_6208:()=>mye,content_3558_6210:()=>hye,content_3558_6212:()=>kye,content_3558_6214:()=>Dye,content_3558_6216:()=>wye,content_3558_6218:()=>Xye,content_3558_622:()=>BB,content_3558_6220:()=>Tye,content_3558_6222:()=>xye,content_3558_6224:()=>Lye,content_3558_6226:()=>bye,content_3558_6228:()=>zye,content_3558_6230:()=>Wye,content_3558_6232:()=>Rye,content_3558_6234:()=>Sye,content_3558_6236:()=>Eye,content_3558_6238:()=>Gye,content_3558_624:()=>UB,content_3558_6240:()=>Fye,content_3558_6242:()=>qye,content_3558_6244:()=>Hye,content_3558_6246:()=>Yye,content_3558_6248:()=>Kye,content_3558_6250:()=>tDe,content_3558_6252:()=>nDe,content_3558_6254:()=>pDe,content_3558_6256:()=>sDe,content_3558_6258:()=>iDe,content_3558_626:()=>VB,content_3558_6260:()=>lDe,content_3558_6262:()=>mDe,content_3558_6264:()=>hDe,content_3558_6266:()=>kDe,content_3558_6268:()=>DDe,content_3558_6270:()=>wDe,content_3558_6272:()=>XDe,content_3558_6274:()=>TDe,content_3558_6276:()=>xDe,content_3558_6278:()=>LDe,content_3558_628:()=>jB,content_3558_6280:()=>bDe,content_3558_6282:()=>zDe,content_3558_6284:()=>WDe,content_3558_6286:()=>RDe,content_3558_6288:()=>SDe,content_3558_6290:()=>EDe,content_3558_6292:()=>GDe,content_3558_6294:()=>FDe,content_3558_6296:()=>qDe,content_3558_6298:()=>HDe,content_3558_630:()=>QB,content_3558_6300:()=>YDe,content_3558_6302:()=>KDe,content_3558_6304:()=>tMe,content_3558_6306:()=>nMe,content_3558_6308:()=>pMe,content_3558_6310:()=>sMe,content_3558_6312:()=>iMe,content_3558_6314:()=>lMe,content_3558_6316:()=>mMe,content_3558_6318:()=>hMe,content_3558_632:()=>$B,content_3558_6320:()=>kMe,content_3558_6322:()=>DMe,content_3558_6324:()=>wMe,content_3558_6326:()=>XMe,content_3558_6328:()=>TMe,content_3558_6330:()=>xMe,content_3558_6332:()=>LMe,content_3558_6334:()=>bMe,content_3558_6336:()=>zMe,content_3558_6338:()=>WMe,content_3558_634:()=>JB,content_3558_6340:()=>RMe,content_3558_6342:()=>SMe,content_3558_6344:()=>EMe,content_3558_6346:()=>GMe,content_3558_6348:()=>FMe,content_3558_6350:()=>qMe,content_3558_6352:()=>HMe,content_3558_6354:()=>YMe,content_3558_6356:()=>KMe,content_3558_6358:()=>twe,content_3558_636:()=>eG,content_3558_6360:()=>nwe,content_3558_6362:()=>pwe,content_3558_6364:()=>swe,content_3558_6366:()=>iwe,content_3558_6368:()=>lwe,content_3558_6370:()=>mwe,content_3558_6372:()=>hwe,content_3558_6374:()=>kwe,content_3558_6376:()=>Dwe,content_3558_6378:()=>wwe,content_3558_638:()=>oG,content_3558_6380:()=>Xwe,content_3558_6382:()=>Twe,content_3558_6384:()=>xwe,content_3558_6386:()=>Lwe,content_3558_6388:()=>bwe,content_3558_6390:()=>zwe,content_3558_6392:()=>Wwe,content_3558_6394:()=>Rwe,content_3558_6396:()=>Swe,content_3558_6398:()=>Ewe,content_3558_64:()=>gN,content_3558_640:()=>rG,content_3558_6400:()=>Gwe,content_3558_6402:()=>Fwe,content_3558_6404:()=>qwe,content_3558_6406:()=>Hwe,content_3558_6408:()=>Ywe,content_3558_6410:()=>Kwe,content_3558_6412:()=>t_e,content_3558_6414:()=>n_e,content_3558_6416:()=>p_e,content_3558_6418:()=>s_e,content_3558_642:()=>cG,content_3558_6420:()=>i_e,content_3558_6422:()=>l_e,content_3558_6424:()=>m_e,content_3558_6426:()=>h_e,content_3558_6428:()=>k_e,content_3558_6430:()=>D_e,content_3558_6432:()=>w_e,content_3558_6434:()=>X_e,content_3558_6436:()=>T_e,content_3558_6438:()=>x_e,content_3558_644:()=>aG,content_3558_6440:()=>L_e,content_3558_6442:()=>b_e,content_3558_6444:()=>z_e,content_3558_6446:()=>W_e,content_3558_6448:()=>R_e,content_3558_6450:()=>S_e,content_3558_6452:()=>E_e,content_3558_6454:()=>G_e,content_3558_6456:()=>F_e,content_3558_6458:()=>q_e,content_3558_646:()=>uG,content_3558_6460:()=>H_e,content_3558_6462:()=>Y_e,content_3558_6464:()=>K_e,content_3558_6466:()=>tXe,content_3558_6468:()=>nXe,content_3558_6470:()=>pXe,content_3558_6472:()=>sXe,content_3558_6474:()=>iXe,content_3558_6476:()=>lXe,content_3558_6478:()=>mXe,content_3558_648:()=>dG,content_3558_6480:()=>hXe,content_3558_6482:()=>kXe,content_3558_6484:()=>DXe,content_3558_6486:()=>wXe,content_3558_6488:()=>XXe,content_3558_6490:()=>TXe,content_3558_6492:()=>xXe,content_3558_6494:()=>LXe,content_3558_6496:()=>bXe,content_3558_6498:()=>zXe,content_3558_650:()=>fG,content_3558_6500:()=>WXe,content_3558_6502:()=>RXe,content_3558_6504:()=>SXe,content_3558_6506:()=>EXe,content_3558_6508:()=>GXe,content_3558_6510:()=>FXe,content_3558_6512:()=>qXe,content_3558_6514:()=>HXe,content_3558_6516:()=>YXe,content_3558_6518:()=>KXe,content_3558_652:()=>yG,content_3558_6520:()=>tge,content_3558_6522:()=>nge,content_3558_6524:()=>pge,content_3558_6526:()=>sge,content_3558_6528:()=>ige,content_3558_6530:()=>lge,content_3558_6532:()=>mge,content_3558_6534:()=>hge,content_3558_6536:()=>kge,content_3558_6538:()=>Dge,content_3558_654:()=>MG,content_3558_6540:()=>wge,content_3558_6542:()=>Xge,content_3558_6544:()=>Tge,content_3558_6546:()=>xge,content_3558_6548:()=>Lge,content_3558_6550:()=>bge,content_3558_6552:()=>zge,content_3558_6554:()=>Wge,content_3558_6556:()=>Rge,content_3558_6558:()=>Sge,content_3558_656:()=>_G,content_3558_6560:()=>Ege,content_3558_6562:()=>Gge,content_3558_6564:()=>Fge,content_3558_6566:()=>qge,content_3558_6568:()=>Hge,content_3558_6570:()=>Yge,content_3558_6572:()=>Kge,content_3558_6574:()=>tTe,content_3558_6576:()=>nTe,content_3558_6578:()=>pTe,content_3558_658:()=>gG,content_3558_6580:()=>sTe,content_3558_6582:()=>iTe,content_3558_6584:()=>lTe,content_3558_6586:()=>mTe,content_3558_6588:()=>hTe,content_3558_6590:()=>kTe,content_3558_6592:()=>DTe,content_3558_6594:()=>wTe,content_3558_6596:()=>XTe,content_3558_6598:()=>TTe,content_3558_66:()=>CN,content_3558_660:()=>CG,content_3558_6600:()=>xTe,content_3558_6602:()=>LTe,content_3558_6604:()=>bTe,content_3558_6606:()=>zTe,content_3558_6608:()=>WTe,content_3558_6610:()=>RTe,content_3558_6612:()=>STe,content_3558_6614:()=>ETe,content_3558_6616:()=>GTe,content_3558_6618:()=>FTe,content_3558_662:()=>vG,content_3558_6620:()=>qTe,content_3558_6622:()=>HTe,content_3558_6624:()=>YTe,content_3558_6626:()=>KTe,content_3558_6628:()=>tCe,content_3558_6630:()=>nCe,content_3558_6632:()=>pCe,content_3558_6634:()=>sCe,content_3558_6636:()=>iCe,content_3558_6638:()=>lCe,content_3558_664:()=>ZG,content_3558_6640:()=>mCe,content_3558_6642:()=>hCe,content_3558_6644:()=>kCe,content_3558_6646:()=>DCe,content_3558_6648:()=>wCe,content_3558_6650:()=>XCe,content_3558_6652:()=>TCe,content_3558_6654:()=>xCe,content_3558_6656:()=>LCe,content_3558_6658:()=>bCe,content_3558_666:()=>NG,content_3558_6660:()=>zCe,content_3558_6662:()=>WCe,content_3558_6664:()=>RCe,content_3558_6666:()=>SCe,content_3558_6668:()=>ECe,content_3558_6670:()=>GCe,content_3558_6672:()=>FCe,content_3558_6674:()=>qCe,content_3558_6676:()=>HCe,content_3558_6678:()=>YCe,content_3558_668:()=>AG,content_3558_6680:()=>KCe,content_3558_6682:()=>txe,content_3558_6684:()=>nxe,content_3558_6686:()=>pxe,content_3558_6688:()=>sxe,content_3558_6690:()=>ixe,content_3558_6692:()=>lxe,content_3558_6694:()=>mxe,content_3558_6696:()=>hxe,content_3558_6698:()=>kxe,content_3558_670:()=>IG,content_3558_6700:()=>Dxe,content_3558_6702:()=>wxe,content_3558_6704:()=>Xxe,content_3558_6706:()=>Txe,content_3558_6708:()=>xxe,content_3558_6710:()=>Lxe,content_3558_6712:()=>bxe,content_3558_6714:()=>zxe,content_3558_6716:()=>Wxe,content_3558_6718:()=>Rxe,content_3558_672:()=>PG,content_3558_6720:()=>Sxe,content_3558_6722:()=>Exe,content_3558_6724:()=>Gxe,content_3558_6726:()=>Fxe,content_3558_6728:()=>qxe,content_3558_6730:()=>Hxe,content_3558_6732:()=>Yxe,content_3558_6734:()=>Kxe,content_3558_6736:()=>tve,content_3558_6738:()=>nve,content_3558_674:()=>OG,content_3558_6740:()=>pve,content_3558_6742:()=>sve,content_3558_6744:()=>ive,content_3558_6746:()=>lve,content_3558_6748:()=>mve,content_3558_6750:()=>hve,content_3558_6752:()=>kve,content_3558_6754:()=>Dve,content_3558_6756:()=>wve,content_3558_6758:()=>Xve,content_3558_676:()=>BG,content_3558_6760:()=>Tve,content_3558_6762:()=>xve,content_3558_6764:()=>Lve,content_3558_6766:()=>bve,content_3558_6768:()=>zve,content_3558_6770:()=>Wve,content_3558_6772:()=>Rve,content_3558_6774:()=>Sve,content_3558_6776:()=>Eve,content_3558_6778:()=>Gve,content_3558_678:()=>UG,content_3558_6780:()=>Fve,content_3558_6782:()=>qve,content_3558_6784:()=>Hve,content_3558_6786:()=>Yve,content_3558_6788:()=>Kve,content_3558_6790:()=>tLe,content_3558_6792:()=>nLe,content_3558_6794:()=>pLe,content_3558_6796:()=>sLe,content_3558_6798:()=>iLe,content_3558_68:()=>vN,content_3558_680:()=>VG,content_3558_6800:()=>lLe,content_3558_6802:()=>mLe,content_3558_6804:()=>hLe,content_3558_6806:()=>kLe,content_3558_6808:()=>DLe,content_3558_6810:()=>wLe,content_3558_6812:()=>XLe,content_3558_6814:()=>TLe,content_3558_6816:()=>xLe,content_3558_6818:()=>LLe,content_3558_682:()=>jG,content_3558_6820:()=>bLe,content_3558_6822:()=>zLe,content_3558_6824:()=>WLe,content_3558_6826:()=>RLe,content_3558_6828:()=>SLe,content_3558_6830:()=>ELe,content_3558_6832:()=>GLe,content_3558_6834:()=>FLe,content_3558_6836:()=>qLe,content_3558_6838:()=>HLe,content_3558_684:()=>QG,content_3558_6840:()=>YLe,content_3558_6842:()=>KLe,content_3558_6844:()=>tZe,content_3558_6846:()=>nZe,content_3558_6848:()=>pZe,content_3558_6850:()=>sZe,content_3558_6852:()=>iZe,content_3558_6854:()=>lZe,content_3558_6856:()=>mZe,content_3558_6858:()=>hZe,content_3558_686:()=>$G,content_3558_6860:()=>kZe,content_3558_6862:()=>DZe,content_3558_6864:()=>wZe,content_3558_6866:()=>XZe,content_3558_6868:()=>TZe,content_3558_6870:()=>xZe,content_3558_6872:()=>LZe,content_3558_6874:()=>bZe,content_3558_6876:()=>zZe,content_3558_6878:()=>WZe,content_3558_688:()=>JG,content_3558_6880:()=>RZe,content_3558_6882:()=>SZe,content_3558_6884:()=>EZe,content_3558_6886:()=>GZe,content_3558_6888:()=>FZe,content_3558_6890:()=>qZe,content_3558_6892:()=>HZe,content_3558_6894:()=>YZe,content_3558_6896:()=>KZe,content_3558_6898:()=>tbe,content_3558_690:()=>eU,content_3558_6900:()=>nbe,content_3558_6902:()=>pbe,content_3558_6904:()=>sbe,content_3558_6906:()=>ibe,content_3558_6908:()=>lbe,content_3558_6910:()=>mbe,content_3558_6912:()=>hbe,content_3558_6914:()=>kbe,content_3558_6916:()=>Dbe,content_3558_6918:()=>wbe,content_3558_692:()=>oU,content_3558_6920:()=>Xbe,content_3558_6922:()=>Tbe,content_3558_6924:()=>xbe,content_3558_6926:()=>Lbe,content_3558_6928:()=>bbe,content_3558_6930:()=>zbe,content_3558_6932:()=>Wbe,content_3558_6934:()=>Rbe,content_3558_6936:()=>Sbe,content_3558_6938:()=>Ebe,content_3558_694:()=>rU,content_3558_6940:()=>Gbe,content_3558_6942:()=>Fbe,content_3558_6944:()=>qbe,content_3558_6946:()=>Hbe,content_3558_6948:()=>Ybe,content_3558_6950:()=>Kbe,content_3558_6952:()=>tNe,content_3558_6954:()=>nNe,content_3558_6956:()=>pNe,content_3558_6958:()=>sNe,content_3558_696:()=>cU,content_3558_6960:()=>iNe,content_3558_6962:()=>lNe,content_3558_6964:()=>mNe,content_3558_6966:()=>hNe,content_3558_6968:()=>kNe,content_3558_6970:()=>DNe,content_3558_6972:()=>wNe,content_3558_6974:()=>XNe,content_3558_6976:()=>TNe,content_3558_6978:()=>xNe,content_3558_698:()=>aU,content_3558_6980:()=>LNe,content_3558_6982:()=>bNe,content_3558_6984:()=>zNe,content_3558_6986:()=>WNe,content_3558_6988:()=>RNe,content_3558_6990:()=>SNe,content_3558_6992:()=>ENe,content_3558_6994:()=>GNe,content_3558_6996:()=>FNe,content_3558_6998:()=>qNe,content_3558_70:()=>ZN,content_3558_700:()=>uU,content_3558_7000:()=>HNe,content_3558_7002:()=>YNe,content_3558_7004:()=>KNe,content_3558_7006:()=>tze,content_3558_7008:()=>nze,content_3558_7010:()=>pze,content_3558_7012:()=>sze,content_3558_7014:()=>ize,content_3558_7016:()=>lze,content_3558_7018:()=>mze,content_3558_702:()=>dU,content_3558_7020:()=>hze,content_3558_7022:()=>kze,content_3558_7024:()=>Dze,content_3558_7026:()=>wze,content_3558_7028:()=>Xze,content_3558_7030:()=>Tze,content_3558_7032:()=>xze,content_3558_7034:()=>Lze,content_3558_7036:()=>bze,content_3558_7038:()=>zze,content_3558_704:()=>fU,content_3558_7040:()=>Wze,content_3558_7042:()=>Rze,content_3558_7044:()=>Sze,content_3558_7046:()=>Eze,content_3558_7048:()=>Gze,content_3558_7050:()=>Fze,content_3558_7052:()=>qze,content_3558_7054:()=>Hze,content_3558_7056:()=>Yze,content_3558_7058:()=>Kze,content_3558_706:()=>yU,content_3558_7060:()=>tAe,content_3558_7062:()=>nAe,content_3558_7064:()=>pAe,content_3558_7066:()=>sAe,content_3558_7068:()=>iAe,content_3558_7070:()=>lAe,content_3558_7072:()=>mAe,content_3558_7074:()=>hAe,content_3558_7076:()=>kAe,content_3558_7078:()=>DAe,content_3558_708:()=>MU,content_3558_7080:()=>wAe,content_3558_7082:()=>XAe,content_3558_7084:()=>TAe,content_3558_7086:()=>xAe,content_3558_7088:()=>LAe,content_3558_7090:()=>bAe,content_3558_7092:()=>zAe,content_3558_7094:()=>WAe,content_3558_7096:()=>RAe,content_3558_7098:()=>SAe,content_3558_710:()=>_U,content_3558_7100:()=>EAe,content_3558_7102:()=>GAe,content_3558_7104:()=>FAe,content_3558_7106:()=>qAe,content_3558_7108:()=>HAe,content_3558_7110:()=>YAe,content_3558_7112:()=>KAe,content_3558_7114:()=>tWe,content_3558_7116:()=>nWe,content_3558_7118:()=>pWe,content_3558_712:()=>gU,content_3558_7120:()=>sWe,content_3558_7122:()=>iWe,content_3558_7124:()=>lWe,content_3558_7126:()=>mWe,content_3558_7128:()=>hWe,content_3558_7130:()=>kWe,content_3558_7132:()=>DWe,content_3558_7134:()=>wWe,content_3558_7136:()=>XWe,content_3558_7138:()=>TWe,content_3558_714:()=>CU,content_3558_7140:()=>xWe,content_3558_7142:()=>LWe,content_3558_7144:()=>bWe,content_3558_7146:()=>zWe,content_3558_7148:()=>WWe,content_3558_7150:()=>RWe,content_3558_7152:()=>SWe,content_3558_7154:()=>EWe,content_3558_7156:()=>GWe,content_3558_7158:()=>FWe,content_3558_716:()=>vU,content_3558_7160:()=>qWe,content_3558_7162:()=>HWe,content_3558_7164:()=>YWe,content_3558_7166:()=>KWe,content_3558_7168:()=>tIe,content_3558_7170:()=>nIe,content_3558_7172:()=>pIe,content_3558_7174:()=>sIe,content_3558_7176:()=>iIe,content_3558_7178:()=>lIe,content_3558_718:()=>ZU,content_3558_7180:()=>mIe,content_3558_7182:()=>hIe,content_3558_7184:()=>kIe,content_3558_7186:()=>DIe,content_3558_7188:()=>wIe,content_3558_7190:()=>XIe,content_3558_7192:()=>TIe,content_3558_7194:()=>xIe,content_3558_7196:()=>LIe,content_3558_7198:()=>bIe,content_3558_72:()=>NN,content_3558_720:()=>NU,content_3558_7200:()=>zIe,content_3558_7202:()=>WIe,content_3558_7204:()=>RIe,content_3558_7206:()=>SIe,content_3558_7208:()=>EIe,content_3558_7210:()=>GIe,content_3558_7212:()=>FIe,content_3558_7214:()=>qIe,content_3558_7216:()=>HIe,content_3558_7218:()=>YIe,content_3558_722:()=>AU,content_3558_7220:()=>KIe,content_3558_7222:()=>tRe,content_3558_7224:()=>nRe,content_3558_7226:()=>pRe,content_3558_7228:()=>sRe,content_3558_7230:()=>iRe,content_3558_7232:()=>lRe,content_3558_7234:()=>mRe,content_3558_7236:()=>hRe,content_3558_7238:()=>kRe,content_3558_724:()=>IU,content_3558_7240:()=>DRe,content_3558_7242:()=>wRe,content_3558_7244:()=>XRe,content_3558_7246:()=>TRe,content_3558_7248:()=>xRe,content_3558_7250:()=>LRe,content_3558_7252:()=>bRe,content_3558_7254:()=>zRe,content_3558_7256:()=>WRe,content_3558_7258:()=>RRe,content_3558_726:()=>PU,content_3558_7260:()=>SRe,content_3558_7262:()=>ERe,content_3558_7264:()=>GRe,content_3558_7266:()=>FRe,content_3558_7268:()=>qRe,content_3558_7270:()=>HRe,content_3558_7272:()=>YRe,content_3558_7274:()=>KRe,content_3558_7276:()=>tPe,content_3558_7278:()=>nPe,content_3558_728:()=>OU,content_3558_7280:()=>pPe,content_3558_7282:()=>sPe,content_3558_7284:()=>iPe,content_3558_7286:()=>lPe,content_3558_7288:()=>mPe,content_3558_7290:()=>hPe,content_3558_7292:()=>kPe,content_3558_7294:()=>DPe,content_3558_7296:()=>wPe,content_3558_7298:()=>XPe,content_3558_730:()=>BU,content_3558_7300:()=>TPe,content_3558_7302:()=>xPe,content_3558_7304:()=>LPe,content_3558_7306:()=>bPe,content_3558_7308:()=>zPe,content_3558_7310:()=>WPe,content_3558_7312:()=>RPe,content_3558_7314:()=>SPe,content_3558_7316:()=>EPe,content_3558_7318:()=>GPe,content_3558_732:()=>UU,content_3558_7320:()=>FPe,content_3558_7322:()=>qPe,content_3558_7324:()=>HPe,content_3558_7326:()=>YPe,content_3558_7328:()=>KPe,content_3558_7330:()=>tSe,content_3558_7332:()=>nSe,content_3558_7334:()=>pSe,content_3558_7336:()=>sSe,content_3558_7338:()=>iSe,content_3558_734:()=>VU,content_3558_7340:()=>lSe,content_3558_7342:()=>mSe,content_3558_7344:()=>hSe,content_3558_7346:()=>kSe,content_3558_7348:()=>DSe,content_3558_7350:()=>wSe,content_3558_7352:()=>XSe,content_3558_7354:()=>TSe,content_3558_7356:()=>xSe,content_3558_7358:()=>LSe,content_3558_736:()=>jU,content_3558_7360:()=>bSe,content_3558_7362:()=>zSe,content_3558_7364:()=>WSe,content_3558_7366:()=>RSe,content_3558_7368:()=>SSe,content_3558_7370:()=>ESe,content_3558_7372:()=>GSe,content_3558_7374:()=>FSe,content_3558_7376:()=>qSe,content_3558_7378:()=>HSe,content_3558_738:()=>QU,content_3558_7380:()=>YSe,content_3558_7382:()=>KSe,content_3558_7384:()=>tOe,content_3558_7386:()=>nOe,content_3558_7388:()=>pOe,content_3558_7390:()=>sOe,content_3558_7392:()=>iOe,content_3558_7394:()=>lOe,content_3558_7396:()=>mOe,content_3558_7398:()=>hOe,content_3558_74:()=>AN,content_3558_740:()=>$U,content_3558_7400:()=>kOe,content_3558_7402:()=>DOe,content_3558_7404:()=>wOe,content_3558_7406:()=>XOe,content_3558_7408:()=>TOe,content_3558_7410:()=>xOe,content_3558_7412:()=>LOe,content_3558_7414:()=>bOe,content_3558_7416:()=>zOe,content_3558_7418:()=>WOe,content_3558_742:()=>JU,content_3558_7420:()=>ROe,content_3558_7422:()=>SOe,content_3558_7424:()=>EOe,content_3558_7426:()=>GOe,content_3558_7428:()=>FOe,content_3558_7430:()=>qOe,content_3558_7432:()=>HOe,content_3558_7434:()=>YOe,content_3558_7436:()=>KOe,content_3558_7438:()=>tEe,content_3558_744:()=>eF,content_3558_7440:()=>nEe,content_3558_7442:()=>pEe,content_3558_7444:()=>sEe,content_3558_7446:()=>iEe,content_3558_7448:()=>lEe,content_3558_7450:()=>mEe,content_3558_7452:()=>hEe,content_3558_7454:()=>kEe,content_3558_7456:()=>DEe,content_3558_7458:()=>wEe,content_3558_746:()=>oF,content_3558_7460:()=>XEe,content_3558_7462:()=>TEe,content_3558_7464:()=>xEe,content_3558_7466:()=>LEe,content_3558_7468:()=>bEe,content_3558_7470:()=>zEe,content_3558_7472:()=>WEe,content_3558_7474:()=>REe,content_3558_7476:()=>SEe,content_3558_7478:()=>EEe,content_3558_748:()=>rF,content_3558_7480:()=>GEe,content_3558_7482:()=>FEe,content_3558_7484:()=>qEe,content_3558_7486:()=>HEe,content_3558_7488:()=>YEe,content_3558_7490:()=>KEe,content_3558_7492:()=>tBe,content_3558_7494:()=>nBe,content_3558_7496:()=>pBe,content_3558_7498:()=>sBe,content_3558_750:()=>cF,content_3558_7500:()=>iBe,content_3558_7502:()=>lBe,content_3558_7504:()=>mBe,content_3558_7506:()=>hBe,content_3558_7508:()=>kBe,content_3558_7510:()=>DBe,content_3558_7512:()=>wBe,content_3558_7514:()=>XBe,content_3558_7516:()=>TBe,content_3558_7518:()=>xBe,content_3558_752:()=>aF,content_3558_7520:()=>LBe,content_3558_7522:()=>bBe,content_3558_7524:()=>zBe,content_3558_7526:()=>WBe,content_3558_7528:()=>RBe,content_3558_7530:()=>SBe,content_3558_7532:()=>EBe,content_3558_7534:()=>GBe,content_3558_7536:()=>FBe,content_3558_7538:()=>qBe,content_3558_754:()=>uF,content_3558_7540:()=>HBe,content_3558_7542:()=>YBe,content_3558_7544:()=>KBe,content_3558_7546:()=>tGe,content_3558_7548:()=>nGe,content_3558_7550:()=>pGe,content_3558_7552:()=>sGe,content_3558_7554:()=>iGe,content_3558_7556:()=>lGe,content_3558_7558:()=>mGe,content_3558_756:()=>dF,content_3558_7560:()=>hGe,content_3558_7562:()=>kGe,content_3558_7564:()=>DGe,content_3558_7566:()=>wGe,content_3558_7568:()=>XGe,content_3558_7570:()=>TGe,content_3558_7572:()=>xGe,content_3558_7574:()=>LGe,content_3558_7576:()=>bGe,content_3558_7578:()=>zGe,content_3558_758:()=>fF,content_3558_7580:()=>WGe,content_3558_7582:()=>RGe,content_3558_7584:()=>SGe,content_3558_7586:()=>EGe,content_3558_7588:()=>GGe,content_3558_7590:()=>FGe,content_3558_7592:()=>qGe,content_3558_7594:()=>HGe,content_3558_7596:()=>YGe,content_3558_7598:()=>KGe,content_3558_76:()=>IN,content_3558_760:()=>yF,content_3558_7600:()=>tUe,content_3558_7602:()=>nUe,content_3558_7604:()=>pUe,content_3558_7606:()=>sUe,content_3558_7608:()=>iUe,content_3558_7610:()=>lUe,content_3558_7612:()=>mUe,content_3558_7614:()=>hUe,content_3558_7616:()=>kUe,content_3558_7618:()=>DUe,content_3558_762:()=>MF,content_3558_7620:()=>wUe,content_3558_7622:()=>XUe,content_3558_7624:()=>TUe,content_3558_7626:()=>xUe,content_3558_7628:()=>LUe,content_3558_7630:()=>bUe,content_3558_7632:()=>zUe,content_3558_7634:()=>WUe,content_3558_7636:()=>RUe,content_3558_7638:()=>SUe,content_3558_764:()=>_F,content_3558_7640:()=>EUe,content_3558_7642:()=>GUe,content_3558_7644:()=>FUe,content_3558_7646:()=>qUe,content_3558_7648:()=>HUe,content_3558_7650:()=>YUe,content_3558_7652:()=>KUe,content_3558_7654:()=>tFe,content_3558_7656:()=>nFe,content_3558_7658:()=>pFe,content_3558_766:()=>gF,content_3558_7660:()=>sFe,content_3558_7662:()=>iFe,content_3558_7664:()=>lFe,content_3558_7666:()=>mFe,content_3558_7668:()=>hFe,content_3558_7670:()=>kFe,content_3558_7672:()=>DFe,content_3558_7674:()=>wFe,content_3558_7676:()=>XFe,content_3558_7678:()=>TFe,content_3558_768:()=>CF,content_3558_7680:()=>xFe,content_3558_7682:()=>LFe,content_3558_7684:()=>bFe,content_3558_7686:()=>zFe,content_3558_7688:()=>WFe,content_3558_7690:()=>RFe,content_3558_7692:()=>SFe,content_3558_7694:()=>EFe,content_3558_7696:()=>GFe,content_3558_7698:()=>FFe,content_3558_770:()=>vF,content_3558_7700:()=>qFe,content_3558_7702:()=>HFe,content_3558_7704:()=>YFe,content_3558_7706:()=>KFe,content_3558_7708:()=>tVe,content_3558_7710:()=>nVe,content_3558_7712:()=>pVe,content_3558_7714:()=>sVe,content_3558_7716:()=>iVe,content_3558_7718:()=>lVe,content_3558_772:()=>ZF,content_3558_7720:()=>mVe,content_3558_7722:()=>hVe,content_3558_7724:()=>kVe,content_3558_7726:()=>DVe,content_3558_7728:()=>wVe,content_3558_7730:()=>XVe,content_3558_7732:()=>TVe,content_3558_7734:()=>xVe,content_3558_7736:()=>LVe,content_3558_7738:()=>bVe,content_3558_774:()=>NF,content_3558_7740:()=>zVe,content_3558_7742:()=>WVe,content_3558_7744:()=>RVe,content_3558_7746:()=>SVe,content_3558_7748:()=>EVe,content_3558_7750:()=>GVe,content_3558_7752:()=>FVe,content_3558_7754:()=>qVe,content_3558_7756:()=>HVe,content_3558_7758:()=>YVe,content_3558_776:()=>AF,content_3558_7760:()=>KVe,content_3558_7762:()=>tqe,content_3558_7764:()=>nqe,content_3558_7766:()=>pqe,content_3558_7768:()=>sqe,content_3558_7770:()=>iqe,content_3558_7772:()=>lqe,content_3558_7774:()=>mqe,content_3558_7776:()=>hqe,content_3558_7778:()=>kqe,content_3558_778:()=>IF,content_3558_7780:()=>Dqe,content_3558_7782:()=>wqe,content_3558_7784:()=>Xqe,content_3558_7786:()=>Tqe,content_3558_7788:()=>xqe,content_3558_7790:()=>Lqe,content_3558_7792:()=>bqe,content_3558_7794:()=>zqe,content_3558_7796:()=>Wqe,content_3558_7798:()=>Rqe,content_3558_78:()=>PN,content_3558_780:()=>PF,content_3558_7800:()=>Sqe,content_3558_7802:()=>Eqe,content_3558_7804:()=>Gqe,content_3558_7806:()=>Fqe,content_3558_7808:()=>qqe,content_3558_7810:()=>Hqe,content_3558_7812:()=>Yqe,content_3558_7814:()=>Kqe,content_3558_7816:()=>tje,content_3558_7818:()=>nje,content_3558_782:()=>OF,content_3558_7820:()=>pje,content_3558_7822:()=>sje,content_3558_7824:()=>ije,content_3558_7826:()=>lje,content_3558_7828:()=>mje,content_3558_7830:()=>hje,content_3558_7832:()=>kje,content_3558_7834:()=>Dje,content_3558_7836:()=>wje,content_3558_7838:()=>Xje,content_3558_784:()=>BF,content_3558_7840:()=>Tje,content_3558_7842:()=>xje,content_3558_7844:()=>Lje,content_3558_7846:()=>bje,content_3558_7848:()=>zje,content_3558_7850:()=>Wje,content_3558_7852:()=>Rje,content_3558_7854:()=>Sje,content_3558_7856:()=>Eje,content_3558_7858:()=>Gje,content_3558_786:()=>UF,content_3558_7860:()=>Fje,content_3558_7862:()=>qje,content_3558_7864:()=>Hje,content_3558_7866:()=>Yje,content_3558_7868:()=>Kje,content_3558_7870:()=>tHe,content_3558_7872:()=>nHe,content_3558_7874:()=>pHe,content_3558_7876:()=>sHe,content_3558_7878:()=>iHe,content_3558_788:()=>VF,content_3558_7880:()=>lHe,content_3558_7882:()=>mHe,content_3558_7884:()=>hHe,content_3558_7886:()=>kHe,content_3558_7888:()=>DHe,content_3558_7890:()=>wHe,content_3558_7892:()=>XHe,content_3558_7894:()=>THe,content_3558_7896:()=>xHe,content_3558_7898:()=>LHe,content_3558_790:()=>jF,content_3558_7900:()=>bHe,content_3558_7902:()=>zHe,content_3558_7904:()=>WHe,content_3558_7906:()=>RHe,content_3558_7908:()=>SHe,content_3558_7910:()=>EHe,content_3558_7912:()=>GHe,content_3558_7914:()=>FHe,content_3558_7916:()=>qHe,content_3558_7918:()=>HHe,content_3558_792:()=>QF,content_3558_7920:()=>YHe,content_3558_7922:()=>KHe,content_3558_7924:()=>tQe,content_3558_7926:()=>nQe,content_3558_7928:()=>pQe,content_3558_7930:()=>sQe,content_3558_7932:()=>iQe,content_3558_7934:()=>lQe,content_3558_7936:()=>mQe,content_3558_7938:()=>hQe,content_3558_794:()=>$F,content_3558_7940:()=>kQe,content_3558_7942:()=>DQe,content_3558_7944:()=>wQe,content_3558_7946:()=>XQe,content_3558_7948:()=>TQe,content_3558_7950:()=>xQe,content_3558_7952:()=>LQe,content_3558_7954:()=>bQe,content_3558_7956:()=>zQe,content_3558_7958:()=>WQe,content_3558_796:()=>JF,content_3558_7960:()=>RQe,content_3558_7962:()=>SQe,content_3558_7964:()=>EQe,content_3558_7966:()=>GQe,content_3558_7968:()=>FQe,content_3558_7970:()=>qQe,content_3558_7972:()=>HQe,content_3558_7974:()=>YQe,content_3558_7976:()=>KQe,content_3558_7978:()=>tYe,content_3558_798:()=>eV,content_3558_7980:()=>nYe,content_3558_7982:()=>pYe,content_3558_7984:()=>sYe,content_3558_7986:()=>iYe,content_3558_7988:()=>lYe,content_3558_7990:()=>mYe,content_3558_7992:()=>hYe,content_3558_7994:()=>kYe,content_3558_7996:()=>DYe,content_3558_7998:()=>wYe,content_3558_8:()=>_b,content_3558_80:()=>ON,content_3558_800:()=>oV,content_3558_8000:()=>XYe,content_3558_8002:()=>TYe,content_3558_8004:()=>xYe,content_3558_8006:()=>LYe,content_3558_8008:()=>bYe,content_3558_8010:()=>zYe,content_3558_8012:()=>WYe,content_3558_8014:()=>RYe,content_3558_8016:()=>SYe,content_3558_8018:()=>EYe,content_3558_802:()=>rV,content_3558_8020:()=>GYe,content_3558_8022:()=>FYe,content_3558_8024:()=>qYe,content_3558_8026:()=>HYe,content_3558_8028:()=>YYe,content_3558_8030:()=>KYe,content_3558_8032:()=>t$e,content_3558_8034:()=>n$e,content_3558_8036:()=>p$e,content_3558_8038:()=>s$e,content_3558_804:()=>cV,content_3558_8040:()=>i$e,content_3558_8042:()=>l$e,content_3558_8044:()=>m$e,content_3558_8046:()=>h$e,content_3558_8048:()=>k$e,content_3558_8050:()=>D$e,content_3558_8052:()=>w$e,content_3558_8054:()=>X$e,content_3558_8056:()=>T$e,content_3558_8058:()=>x$e,content_3558_806:()=>aV,content_3558_8060:()=>L$e,content_3558_8062:()=>b$e,content_3558_8064:()=>z$e,content_3558_8066:()=>W$e,content_3558_8068:()=>R$e,content_3558_8070:()=>S$e,content_3558_8072:()=>E$e,content_3558_8074:()=>G$e,content_3558_8076:()=>F$e,content_3558_8078:()=>q$e,content_3558_808:()=>uV,content_3558_8080:()=>H$e,content_3558_8082:()=>Y$e,content_3558_8084:()=>K$e,content_3558_8086:()=>tKe,content_3558_8088:()=>nKe,content_3558_8090:()=>pKe,content_3558_8092:()=>sKe,content_3558_8094:()=>iKe,content_3558_8096:()=>lKe,content_3558_8098:()=>mKe,content_3558_810:()=>dV,content_3558_8100:()=>hKe,content_3558_8102:()=>kKe,content_3558_8104:()=>DKe,content_3558_8106:()=>wKe,content_3558_8108:()=>XKe,content_3558_8110:()=>TKe,content_3558_8112:()=>xKe,content_3558_8114:()=>LKe,content_3558_8116:()=>bKe,content_3558_8118:()=>zKe,content_3558_812:()=>fV,content_3558_8120:()=>WKe,content_3558_8122:()=>RKe,content_3558_8124:()=>SKe,content_3558_8126:()=>EKe,content_3558_8128:()=>GKe,content_3558_8130:()=>FKe,content_3558_8132:()=>qKe,content_3558_8134:()=>HKe,content_3558_8136:()=>YKe,content_3558_8138:()=>KKe,content_3558_814:()=>yV,content_3558_8140:()=>tJe,content_3558_8142:()=>nJe,content_3558_8144:()=>pJe,content_3558_8146:()=>sJe,content_3558_8148:()=>iJe,content_3558_8150:()=>lJe,content_3558_8152:()=>mJe,content_3558_8154:()=>hJe,content_3558_8156:()=>kJe,content_3558_8158:()=>DJe,content_3558_816:()=>MV,content_3558_8160:()=>wJe,content_3558_8162:()=>XJe,content_3558_8164:()=>TJe,content_3558_8166:()=>xJe,content_3558_8168:()=>LJe,content_3558_8170:()=>bJe,content_3558_8172:()=>zJe,content_3558_8174:()=>WJe,content_3558_8176:()=>RJe,content_3558_8178:()=>SJe,content_3558_818:()=>_V,content_3558_8180:()=>EJe,content_3558_8182:()=>GJe,content_3558_8184:()=>FJe,content_3558_8186:()=>qJe,content_3558_8188:()=>HJe,content_3558_8190:()=>YJe,content_3558_8192:()=>KJe,content_3558_8194:()=>t0e,content_3558_8196:()=>n0e,content_3558_8198:()=>p0e,content_3558_82:()=>BN,content_3558_820:()=>gV,content_3558_8200:()=>s0e,content_3558_8202:()=>i0e,content_3558_8204:()=>l0e,content_3558_8206:()=>m0e,content_3558_8208:()=>h0e,content_3558_8210:()=>k0e,content_3558_8212:()=>D0e,content_3558_8214:()=>w0e,content_3558_8216:()=>X0e,content_3558_8218:()=>T0e,content_3558_822:()=>CV,content_3558_8220:()=>x0e,content_3558_8222:()=>L0e,content_3558_8224:()=>b0e,content_3558_8226:()=>z0e,content_3558_8228:()=>W0e,content_3558_8230:()=>R0e,content_3558_8232:()=>S0e,content_3558_8234:()=>E0e,content_3558_8236:()=>G0e,content_3558_8238:()=>F0e,content_3558_824:()=>vV,content_3558_8240:()=>q0e,content_3558_8242:()=>H0e,content_3558_8244:()=>Y0e,content_3558_8246:()=>K0e,content_3558_8248:()=>t5e,content_3558_8250:()=>n5e,content_3558_8252:()=>p5e,content_3558_8254:()=>s5e,content_3558_8256:()=>i5e,content_3558_8258:()=>l5e,content_3558_826:()=>ZV,content_3558_8260:()=>m5e,content_3558_8262:()=>h5e,content_3558_8264:()=>k5e,content_3558_8266:()=>D5e,content_3558_8268:()=>w5e,content_3558_8270:()=>X5e,content_3558_8272:()=>T5e,content_3558_8274:()=>x5e,content_3558_8276:()=>L5e,content_3558_8278:()=>b5e,content_3558_828:()=>NV,content_3558_8280:()=>z5e,content_3558_8282:()=>W5e,content_3558_8284:()=>R5e,content_3558_8286:()=>S5e,content_3558_8288:()=>E5e,content_3558_8290:()=>G5e,content_3558_8292:()=>F5e,content_3558_8294:()=>q5e,content_3558_8296:()=>H5e,content_3558_8298:()=>Y5e,content_3558_830:()=>AV,content_3558_8300:()=>K5e,content_3558_8302:()=>t8e,content_3558_8304:()=>n8e,content_3558_8306:()=>p8e,content_3558_8308:()=>s8e,content_3558_8310:()=>i8e,content_3558_8312:()=>l8e,content_3558_8314:()=>m8e,content_3558_8316:()=>h8e,content_3558_8318:()=>k8e,content_3558_832:()=>IV,content_3558_8320:()=>D8e,content_3558_8322:()=>w8e,content_3558_8324:()=>X8e,content_3558_8326:()=>T8e,content_3558_8328:()=>x8e,content_3558_8330:()=>L8e,content_3558_8332:()=>b8e,content_3558_8334:()=>z8e,content_3558_8336:()=>W8e,content_3558_8338:()=>R8e,content_3558_834:()=>PV,content_3558_8340:()=>S8e,content_3558_8342:()=>E8e,content_3558_8344:()=>G8e,content_3558_8346:()=>F8e,content_3558_8348:()=>q8e,content_3558_8350:()=>H8e,content_3558_8352:()=>Y8e,content_3558_8354:()=>K8e,content_3558_8356:()=>t3e,content_3558_8358:()=>n3e,content_3558_836:()=>OV,content_3558_8360:()=>p3e,content_3558_8362:()=>s3e,content_3558_8364:()=>i3e,content_3558_8366:()=>l3e,content_3558_8368:()=>m3e,content_3558_8370:()=>h3e,content_3558_8372:()=>k3e,content_3558_8374:()=>D3e,content_3558_8376:()=>w3e,content_3558_8378:()=>X3e,content_3558_838:()=>BV,content_3558_8380:()=>T3e,content_3558_8382:()=>x3e,content_3558_8384:()=>L3e,content_3558_8386:()=>b3e,content_3558_8388:()=>z3e,content_3558_8390:()=>W3e,content_3558_8392:()=>R3e,content_3558_8394:()=>S3e,content_3558_8396:()=>E3e,content_3558_8398:()=>G3e,content_3558_84:()=>UN,content_3558_840:()=>UV,content_3558_8400:()=>F3e,content_3558_8402:()=>q3e,content_3558_8404:()=>H3e,content_3558_8406:()=>Y3e,content_3558_8408:()=>K3e,content_3558_8410:()=>t2e,content_3558_8412:()=>n2e,content_3558_8414:()=>p2e,content_3558_8416:()=>s2e,content_3558_8418:()=>i2e,content_3558_842:()=>VV,content_3558_8420:()=>l2e,content_3558_8422:()=>m2e,content_3558_8424:()=>h2e,content_3558_8426:()=>k2e,content_3558_8428:()=>D2e,content_3558_8430:()=>w2e,content_3558_8432:()=>X2e,content_3558_8434:()=>T2e,content_3558_8436:()=>x2e,content_3558_8438:()=>L2e,content_3558_844:()=>jV,content_3558_8440:()=>b2e,content_3558_8442:()=>z2e,content_3558_8444:()=>W2e,content_3558_8446:()=>R2e,content_3558_8448:()=>S2e,content_3558_8450:()=>E2e,content_3558_8452:()=>G2e,content_3558_8454:()=>F2e,content_3558_8456:()=>q2e,content_3558_8458:()=>H2e,content_3558_846:()=>QV,content_3558_8460:()=>Y2e,content_3558_8462:()=>K2e,content_3558_8464:()=>t1e,content_3558_8466:()=>n1e,content_3558_8468:()=>p1e,content_3558_8470:()=>s1e,content_3558_8472:()=>i1e,content_3558_8474:()=>l1e,content_3558_8476:()=>m1e,content_3558_8478:()=>h1e,content_3558_848:()=>$V,content_3558_8480:()=>k1e,content_3558_8482:()=>D1e,content_3558_8484:()=>w1e,content_3558_8486:()=>X1e,content_3558_8488:()=>T1e,content_3558_8490:()=>x1e,content_3558_8492:()=>L1e,content_3558_8494:()=>b1e,content_3558_8496:()=>z1e,content_3558_8498:()=>W1e,content_3558_850:()=>JV,content_3558_8500:()=>R1e,content_3558_8502:()=>S1e,content_3558_8504:()=>E1e,content_3558_8506:()=>G1e,content_3558_8508:()=>F1e,content_3558_8510:()=>q1e,content_3558_8512:()=>H1e,content_3558_8514:()=>Y1e,content_3558_8516:()=>K1e,content_3558_8518:()=>t4e,content_3558_852:()=>eq,content_3558_8520:()=>n4e,content_3558_8522:()=>p4e,content_3558_8524:()=>s4e,content_3558_8526:()=>i4e,content_3558_8528:()=>l4e,content_3558_8530:()=>m4e,content_3558_8532:()=>h4e,content_3558_8534:()=>k4e,content_3558_8536:()=>D4e,content_3558_8538:()=>w4e,content_3558_854:()=>oq,content_3558_8540:()=>X4e,content_3558_8542:()=>T4e,content_3558_8544:()=>x4e,content_3558_8546:()=>L4e,content_3558_8548:()=>b4e,content_3558_8550:()=>z4e,content_3558_8552:()=>W4e,content_3558_8554:()=>R4e,content_3558_8556:()=>S4e,content_3558_8558:()=>E4e,content_3558_856:()=>rq,content_3558_8560:()=>G4e,content_3558_8562:()=>F4e,content_3558_8564:()=>q4e,content_3558_8566:()=>H4e,content_3558_8568:()=>Y4e,content_3558_8570:()=>K4e,content_3558_8572:()=>t6e,content_3558_8574:()=>n6e,content_3558_8576:()=>p6e,content_3558_8578:()=>s6e,content_3558_858:()=>cq,content_3558_8580:()=>i6e,content_3558_8582:()=>l6e,content_3558_8584:()=>m6e,content_3558_8586:()=>h6e,content_3558_8588:()=>k6e,content_3558_8590:()=>D6e,content_3558_8592:()=>w6e,content_3558_8594:()=>X6e,content_3558_8596:()=>T6e,content_3558_8598:()=>x6e,content_3558_86:()=>VN,content_3558_860:()=>aq,content_3558_8600:()=>L6e,content_3558_8602:()=>b6e,content_3558_8604:()=>z6e,content_3558_8606:()=>W6e,content_3558_8608:()=>R6e,content_3558_8610:()=>S6e,content_3558_8612:()=>E6e,content_3558_8614:()=>G6e,content_3558_8616:()=>F6e,content_3558_8618:()=>q6e,content_3558_862:()=>uq,content_3558_8620:()=>H6e,content_3558_8622:()=>Y6e,content_3558_8624:()=>K6e,content_3558_8626:()=>t7e,content_3558_8628:()=>n7e,content_3558_8630:()=>p7e,content_3558_8632:()=>s7e,content_3558_8634:()=>i7e,content_3558_8636:()=>l7e,content_3558_8638:()=>m7e,content_3558_864:()=>dq,content_3558_8640:()=>h7e,content_3558_8642:()=>k7e,content_3558_8644:()=>D7e,content_3558_8646:()=>w7e,content_3558_8648:()=>X7e,content_3558_8650:()=>T7e,content_3558_8652:()=>x7e,content_3558_8654:()=>L7e,content_3558_8656:()=>b7e,content_3558_8658:()=>z7e,content_3558_866:()=>fq,content_3558_8660:()=>W7e,content_3558_8662:()=>R7e,content_3558_8664:()=>S7e,content_3558_8666:()=>E7e,content_3558_8668:()=>G7e,content_3558_8670:()=>F7e,content_3558_8672:()=>q7e,content_3558_8674:()=>H7e,content_3558_8676:()=>Y7e,content_3558_8678:()=>K7e,content_3558_868:()=>yq,content_3558_8680:()=>t9e,content_3558_8682:()=>n9e,content_3558_8684:()=>p9e,content_3558_8686:()=>s9e,content_3558_8688:()=>i9e,content_3558_8690:()=>l9e,content_3558_8692:()=>m9e,content_3558_8694:()=>h9e,content_3558_8696:()=>k9e,content_3558_8698:()=>D9e,content_3558_870:()=>Mq,content_3558_8700:()=>w9e,content_3558_8702:()=>X9e,content_3558_8704:()=>T9e,content_3558_8706:()=>x9e,content_3558_8708:()=>L9e,content_3558_8710:()=>b9e,content_3558_8712:()=>z9e,content_3558_8714:()=>W9e,content_3558_8716:()=>R9e,content_3558_8718:()=>S9e,content_3558_872:()=>_q,content_3558_8720:()=>E9e,content_3558_8722:()=>G9e,content_3558_8724:()=>F9e,content_3558_8726:()=>q9e,content_3558_8728:()=>H9e,content_3558_8730:()=>Y9e,content_3558_8732:()=>K9e,content_3558_8734:()=>ttn,content_3558_8736:()=>ntn,content_3558_8738:()=>ptn,content_3558_874:()=>gq,content_3558_8740:()=>stn,content_3558_8742:()=>itn,content_3558_8744:()=>ltn,content_3558_8746:()=>mtn,content_3558_8748:()=>htn,content_3558_8750:()=>ktn,content_3558_8752:()=>Dtn,content_3558_8754:()=>wtn,content_3558_876:()=>Cq,content_3558_878:()=>vq,content_3558_88:()=>jN,content_3558_880:()=>Zq,content_3558_882:()=>Nq,content_3558_884:()=>Aq,content_3558_886:()=>Iq,content_3558_888:()=>Pq,content_3558_890:()=>Oq,content_3558_892:()=>Bq,content_3558_894:()=>Uq,content_3558_896:()=>Vq,content_3558_898:()=>jq,content_3558_90:()=>QN,content_3558_900:()=>Qq,content_3558_902:()=>$q,content_3558_904:()=>Jq,content_3558_906:()=>ej,content_3558_908:()=>oj,content_3558_910:()=>rj,content_3558_912:()=>cj,content_3558_914:()=>aj,content_3558_916:()=>uj,content_3558_918:()=>dj,content_3558_92:()=>$N,content_3558_920:()=>fj,content_3558_922:()=>yj,content_3558_924:()=>Mj,content_3558_926:()=>_j,content_3558_928:()=>gj,content_3558_930:()=>Cj,content_3558_932:()=>vj,content_3558_934:()=>Zj,content_3558_936:()=>Nj,content_3558_938:()=>Aj,content_3558_94:()=>JN,content_3558_940:()=>Ij,content_3558_942:()=>Pj,content_3558_944:()=>Oj,content_3558_946:()=>Bj,content_3558_948:()=>Uj,content_3558_950:()=>Vj,content_3558_952:()=>jj,content_3558_954:()=>Qj,content_3558_956:()=>$j,content_3558_958:()=>Jj,content_3558_96:()=>ez,content_3558_960:()=>eH,content_3558_962:()=>oH,content_3558_964:()=>rH,content_3558_966:()=>cH,content_3558_968:()=>aH,content_3558_970:()=>uH,content_3558_972:()=>dH,content_3558_974:()=>fH,content_3558_976:()=>yH,content_3558_978:()=>MH,content_3558_98:()=>oz,content_3558_980:()=>_H,content_3558_982:()=>gH,content_3558_984:()=>CH,content_3558_986:()=>vH,content_3558_988:()=>ZH,content_3558_990:()=>NH,content_3558_992:()=>AH,content_3558_994:()=>IH,content_3558_996:()=>PH,content_3558_998:()=>OH});var p=n(2784),r=n(7896),s=n(876);const c={toc:[]};function i(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Main Motion Canvas classes."))}i.isMDXComponent=!0;const a={toc:[]};function l(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when a new message is logged."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A read-only representation of the playback."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert frames to seconds using the current framerate."))}h.isMDXComponent=!0;const f={toc:[]};function k(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frames to convert."))}k.isMDXComponent=!0;const y={toc:[]};function D(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert seconds to frames using the current framerate."))}D.isMDXComponent=!0;const M={toc:[]};function w(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seconds to convert."))}w.isMDXComponent=!0;const _={toc:[]};function X(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class builds on top of the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to provide a simple\ninterface similar to other media players. It plays through the animation\nusing a real-time update loop and optionally synchronises it with audio."))}X.isMDXComponent=!0;const g={toc:[]};function T(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player logic used by the editor and embeddable player."))}T.isMDXComponent=!0;const C={toc:[]};function x(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to provide visual feedback."))}x.isMDXComponent=!0;const v={toc:[]};function L(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered right after recalculation finishes."))}L.isMDXComponent=!0;const Z={toc:[]};function b(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Player does not perform any rendering on its own. For the animation to be\nvisible, another class must subscribe to this event and perform the\nrendering itself. ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Stage"},(0,s.kt)("inlineCode",{parentName:"a"},"Stage"))," can be used to display the animation."))}b.isMDXComponent=!0;const N={toc:[]};function z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered during each iteration of the update loop when the frame is ready\nto be rendered."))}z.isMDXComponent=!0;const A={toc:[]};function W(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A player needs to be active in order for the update loop to run. Each\nplayer is active by default."))}W.isMDXComponent=!0;const I={toc:[]};function R(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Activate the player."))}R.isMDXComponent=!0;const P={toc:[]};function S(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivating the player prevents its update loop from running. This should\nbe done before disposing the player, to prevent it from running in the\nbackground."),(0,s.kt)("p",null,"Just pausing the player does not stop the loop."))}S.isMDXComponent=!0;const O={toc:[]};function E(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivate the player."))}E.isMDXComponent=!0;const B={toc:[]};function G(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing presentation process."))}G.isMDXComponent=!0;const U={toc:[]};function F(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Present the animation."))}F.isMDXComponent=!0;const V={toc:[]};function q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presentation settings."))}q.isMDXComponent=!0;const j={toc:[]};function H(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Resume the presentation if waiting for the next slide."))}H.isMDXComponent=!0;const Q={toc:[]};function Y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Y.isMDXComponent=!0;const $={toc:[]};function K(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}K.isMDXComponent=!0;const J={toc:[]};function tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tt.isMDXComponent=!0;const et={toc:[]};function nt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}nt.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}pt.isMDXComponent=!0;const rt={toc:[]};function st(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}st.isMDXComponent=!0;const ct={toc:[]};function it(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}it.isMDXComponent=!0;const at={toc:[]};function lt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},at,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}ht.isMDXComponent=!0;const ft={toc:[]};function kt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}kt.isMDXComponent=!0;const yt={toc:[]};function Dt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Dt.isMDXComponent=!0;const Mt={toc:[]};function wt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}wt.isMDXComponent=!0;const _t={toc:[]};function Xt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Xt.isMDXComponent=!0;const gt={toc:[]};function Tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class uses the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to render animations. In contrast to a\nplayer, a renderer does not use an update loop. It plays through the\nanimation as fast as it can, occasionally pausing to keep the UI responsive."),(0,s.kt)("p",null,"The actual exporting is outsourced to an ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Exporter"},(0,s.kt)("inlineCode",{parentName:"a"},"Exporter")),"."))}Tt.isMDXComponent=!0;const Ct={toc:[]};function xt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering logic used by the editor to export animations."))}xt.isMDXComponent=!0;const vt={toc:[]};function Lt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing render process."))}Lt.isMDXComponent=!0;const Zt={toc:[]};function bt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the animation using the provided settings."))}bt.isMDXComponent=!0;const Nt={toc:[]};function zt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}zt.isMDXComponent=!0;const At={toc:[]};function Wt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},At,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method always uses the default ",(0,s.kt)("inlineCode",{parentName:"p"},"ImageExporter"),"."))}Wt.isMDXComponent=!0;const It={toc:[]};function Rt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},It,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export an individual frame."))}Rt.isMDXComponent=!0;const Pt={toc:[]};function St(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}St.isMDXComponent=!0;const Ot={toc:[]};function Et(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timestamp to export."))}Et.isMDXComponent=!0;const Bt={toc:[]};function Gt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Manages canvases on which an animation can be displayed."))}Gt.isMDXComponent=!0;const Ut={toc:[]};function Ft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for implementing custom exporters."))}Ft.isMDXComponent=!0;const Vt={toc:[]};function qt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called at the beginning of the rendering process, before anything else has\nbeen set up. The returned value can be used to override the rendering\nsettings provided by the user."))}qt.isMDXComponent=!0;const jt={toc:[]};function Ht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the rendering configuration."))}Ht.isMDXComponent=!0;const Qt={toc:[]};function Yt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called each time after a frame is rendered."))}Yt.isMDXComponent=!0;const $t={toc:[]};function Kt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export a frame."))}Kt.isMDXComponent=!0;const Jt={toc:[]};function te(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A canvas containing the rendered frame."))}te.isMDXComponent=!0;const ee={toc:[]};function ne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number."))}ne.isMDXComponent=!0;const oe={toc:[]};function pe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number within the scene."))}pe.isMDXComponent=!0;const re={toc:[]};function se(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the scene with which the frame is associated."))}se.isMDXComponent=!0;const ce={toc:[]};function ie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An abort signal triggered if the user aborts the rendering."))}ie.isMDXComponent=!0;const ae={toc:[]};function le(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.kt)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.kt)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}le.isMDXComponent=!0;const ue={toc:[]};function me(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Begin the rendering process."))}me.isMDXComponent=!0;const de={toc:[]};function he(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},de,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Can be used to finalize the exporting and perform any necessary\nclean-up."))}he.isMDXComponent=!0;const fe={toc:[]};function ke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Finish the rendering process."))}ke.isMDXComponent=!0;const ye={toc:[]};function De(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The result of the rendering."))}De.isMDXComponent=!0;const Me={toc:[]};function we(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The static interface for exporters."))}we.isMDXComponent=!0;const _e={toc:[]};function Xe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This name will be displayed in the editor."))}Xe.isMDXComponent=!0;const ge={toc:[]};function Te(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this exporter."))}Te.isMDXComponent=!0;const Ce={toc:[]};function xe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This identifier will be used to store the settings of this exporter.\nIt's recommended to prepend it with the name of the package to avoid\ncollisions."))}xe.isMDXComponent=!0;const ve={toc:[]};function Le(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The unique identifier of this exporter."))}Le.isMDXComponent=!0;const Ze={toc:[]};function be(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A new exporter is created whenever the user starts a new rendering process."))}be.isMDXComponent=!0;const Ne={toc:[]};function ze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this exporter."))}ze.isMDXComponent=!0;const Ae={toc:[]};function We(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current project."))}We.isMDXComponent=!0;const Ie={toc:[]};function Re(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}Re.isMDXComponent=!0;const Pe={toc:[]};function Se(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a meta field representing the options of this exporter."))}Se.isMDXComponent=!0;const Oe={toc:[]};function Ee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configure the offset in the Video Settings tab of th editor."))}Ee.isMDXComponent=!0;const Be={toc:[]};function Ge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Be,n,{components:e,mdxType:"MDXLayout"}))}Ge.isMDXComponent=!0;const Ue={toc:[]};function Fe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the settings metadata."))}Fe.isMDXComponent=!0;const Ve={toc:[]};function qe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the settings metadata."))}qe.isMDXComponent=!0;const je={toc:[]};function He(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Property decorators."))}He.isMDXComponent=!0;const Qe={toc:[]};function Ye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}Ye.isMDXComponent=!0;const $e={toc:[]};function Ke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a lazy decorator."))}Ke.isMDXComponent=!0;const Je={toc:[]};function tn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the value of this property."))}tn.isMDXComponent=!0;const en={toc:[]};function nn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},en,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscriptions and triggering of events."))}nn.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},on,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}pn.isMDXComponent=!0;const rn={toc:[]};function sn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}sn.isMDXComponent=!0;const cn={toc:[]};function an(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches an asynchronous ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}dn.isMDXComponent=!0;const hn={toc:[]};function fn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}fn.isMDXComponent=!0;const kn={toc:[]};function yn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}yn.isMDXComponent=!0;const Dn={toc:[]};function Mn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Mn.isMDXComponent=!0;const wn={toc:[]};function _n(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}_n.isMDXComponent=!0;const Xn={toc:[]};function gn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}gn.isMDXComponent=!0;const Tn={toc:[]};function Cn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}Cn.isMDXComponent=!0;const xn={toc:[]};function vn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}vn.isMDXComponent=!0;const Ln={toc:[]};function Zn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Zn.isMDXComponent=!0;const bn={toc:[]};function Nn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Nn.isMDXComponent=!0;const zn={toc:[]};function An(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}An.isMDXComponent=!0;const Wn={toc:[]};function In(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}In.isMDXComponent=!0;const Rn={toc:[]};function Pn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Pn.isMDXComponent=!0;const Sn={toc:[]};function On(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}On.isMDXComponent=!0;const En={toc:[]};function Bn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},En,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value argument to subscribers."))}Bn.isMDXComponent=!0;const Gn={toc:[]};function Un(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A base for dispatching ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Un.isMDXComponent=!0;const Fn={toc:[]};function Vn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Vn.isMDXComponent=!0;const qn={toc:[]};function jn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}jn.isMDXComponent=!0;const Hn={toc:[]};function Qn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Qn.isMDXComponent=!0;const Yn={toc:[]};function $n(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}$n.isMDXComponent=!0;const Kn={toc:[]};function Jn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Jn.isMDXComponent=!0;const to={toc:[]};function eo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},to,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}eo.isMDXComponent=!0;const no={toc:[]};function oo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},no,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}oo.isMDXComponent=!0;const po={toc:[]};function ro(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},po,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}ro.isMDXComponent=!0;const so={toc:[]};function co(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},so,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}co.isMDXComponent=!0;const io={toc:[]};function ao(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},io,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}ao.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}ho.isMDXComponent=!0;const fo={toc:[]};function ko(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Are subscribers being notified?"))}ko.isMDXComponent=!0;const yo={toc:[]};function Do(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Notify all current and future subscribers."))}Do.isMDXComponent=!0;const Mo={toc:[]};function wo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Stop notifying future subscribers."))}wo.isMDXComponent=!0;const _o={toc:[]};function Xo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Xo.isMDXComponent=!0;const go={toc:[]};function To(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},go,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}To.isMDXComponent=!0;const Co={toc:[]};function xo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Co,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}xo.isMDXComponent=!0;const vo={toc:[]};function Lo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Lo.isMDXComponent=!0;const Zo={toc:[]};function bo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}bo.isMDXComponent=!0;const No={toc:[]};function zo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},No,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}zo.isMDXComponent=!0;const Ao={toc:[]};function Wo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Wo.isMDXComponent=!0;const Io={toc:[]};function Ro(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Io,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Ro.isMDXComponent=!0;const Po={toc:[]};function So(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Po,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}So.isMDXComponent=!0;const Oo={toc:[]};function Eo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Eo.isMDXComponent=!0;const Bo={toc:[]};function Go(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Go.isMDXComponent=!0;const Uo={toc:[]};function Fo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Fo.isMDXComponent=!0;const Vo={toc:[]};function qo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}qo.isMDXComponent=!0;const jo={toc:[]};function Ho(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}Ho.isMDXComponent=!0;const Qo={toc:[]};function Yo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Yo.isMDXComponent=!0;const $o={toc:[]};function Ko(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}Ko.isMDXComponent=!0;const Jo={toc:[]};function tp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}tp.isMDXComponent=!0;const ep={toc:[]};function np(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}np.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},op,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}pp.isMDXComponent=!0;const rp={toc:[]};function sp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}sp.isMDXComponent=!0;const cp={toc:[]};function ip(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}ip.isMDXComponent=!0;const ap={toc:[]};function lp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},up,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}hp.isMDXComponent=!0;const fp={toc:[]};function kp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}kp.isMDXComponent=!0;const yp={toc:[]};function Dp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Dp.isMDXComponent=!0;const Mp={toc:[]};function wp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}wp.isMDXComponent=!0;const _p={toc:[]};function Xp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Xp.isMDXComponent=!0;const gp={toc:[]};function Tp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Tp.isMDXComponent=!0;const Cp={toc:[]};function xp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value."))}xp.isMDXComponent=!0;const vp={toc:[]};function Lp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}Lp.isMDXComponent=!0;const Zp={toc:[]};function bp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Setting the value will immediately notify all subscribers."))}bp.isMDXComponent=!0;const Np={toc:[]};function zp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Np,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value of this dispatcher."))}zp.isMDXComponent=!0;const Ap={toc:[]};function Wp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Wp.isMDXComponent=!0;const Ip={toc:[]};function Rp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Rp.isMDXComponent=!0;const Pp={toc:[]};function Sp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}Sp.isMDXComponent=!0;const Op={toc:[]};function Ep(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Op,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ep.isMDXComponent=!0;const Bp={toc:[]};function Gp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Gp.isMDXComponent=!0;const Up={toc:[]};function Fp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Up,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Fp.isMDXComponent=!0;const Vp={toc:[]};function qp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}qp.isMDXComponent=!0;const jp={toc:[]};function Hp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Hp.isMDXComponent=!0;const Qp={toc:[]};function Yp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Yp.isMDXComponent=!0;const $p={toc:[]};function Kp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Kp.isMDXComponent=!0;const Jp={toc:[]};function tr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}tr.isMDXComponent=!0;const er={toc:[]};function nr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},er,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}nr.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},or,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}pr.isMDXComponent=!0;const rr={toc:[]};function sr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}sr.isMDXComponent=!0;const cr={toc:[]};function ir(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}ir.isMDXComponent=!0;const ar={toc:[]};function lr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}hr.isMDXComponent=!0;const fr={toc:[]};function kr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of times the timer has ticked."))}kr.isMDXComponent=!0;const yr={toc:[]};function Dr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator responsible for running this timer."))}Dr.isMDXComponent=!0;const Mr={toc:[]};function wr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the timer ticks."))}wr.isMDXComponent=!0;const _r={toc:[]};function Xr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current iteration index."))}Xr.isMDXComponent=!0;const gr={toc:[]};function Tr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Tr.isMDXComponent=!0;const Cr={toc:[]};function xr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}xr.isMDXComponent=!0;const vr={toc:[]};function Lr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Lr.isMDXComponent=!0;const Zr={toc:[]};function br(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}br.isMDXComponent=!0;const Nr={toc:[]};function zr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}zr.isMDXComponent=!0;const Ar={toc:[]};function Wr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Wr.isMDXComponent=!0;const Ir={toc:[]};function Rr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Rr.isMDXComponent=!0;const Pr={toc:[]};function Sr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run tasks one after another."))}Sr.isMDXComponent=!0;const Or={toc:[]};function Er(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Or,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Er.isMDXComponent=!0;const Br={toc:[]};function Gr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Br,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}Gr.isMDXComponent=!0;const Ur={toc:[]};function Fr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Fr.isMDXComponent=!0;const Vr={toc:[]};function qr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay in seconds"))}qr.isMDXComponent=!0;const jr={toc:[]};function Hr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task or callback to run after the delay."))}Hr.isMDXComponent=!0;const Qr={toc:[]};function Yr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}Yr.isMDXComponent=!0;const $r={toc:[]};function Kr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Call the given callback every N seconds."))}Kr.isMDXComponent=!0;const Jr={toc:[]};function ts(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interval between subsequent calls."))}ts.isMDXComponent=!0;const es={toc:[]};function ns(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},es,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to be called."))}ns.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},os,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each iteration waits until the previous one is completed."))}ps.isMDXComponent=!0;const rs={toc:[]};function ss(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}ss.isMDXComponent=!0;const cs={toc:[]};function is(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator N times."))}is.isMDXComponent=!0;const as={toc:[]};function ls(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},as,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of iterations."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},us,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ds,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}hs.isMDXComponent=!0;const fs={toc:[]};function ks(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}ks.isMDXComponent=!0;const ys={toc:[]};function Ds(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ys,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop for the given amount of time."))}Ds.isMDXComponent=!0;const Ms={toc:[]};function ws(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ms,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration in seconds."))}ws.isMDXComponent=!0;const _s={toc:[]};function Xs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_s,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Xs.isMDXComponent=!0;const gs={toc:[]};function Ts(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Ts.isMDXComponent=!0;const Cs={toc:[]};function xs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}xs.isMDXComponent=!0;const vs={toc:[]};function Ls(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop until the given time event."))}Ls.isMDXComponent=!0;const Zs={toc:[]};function bs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The event."))}bs.isMDXComponent=!0;const Ns={toc:[]};function zs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ns,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}zs.isMDXComponent=!0;const As={toc:[]};function Ws(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},As,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Do nothing."))}Ws.isMDXComponent=!0;const Is={toc:[]};function Rs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Is,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Rs.isMDXComponent=!0;const Ps={toc:[]};function Ss(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ps,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Ss.isMDXComponent=!0;const Os={toc:[]};function Es(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Os,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Es.isMDXComponent=!0;const Bs={toc:[]};function Gs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Gs.isMDXComponent=!0;const Us={toc:[]};function Fs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Us,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Fs.isMDXComponent=!0;const Vs={toc:[]};function qs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional name used when displaying this generator in the UI."))}qs.isMDXComponent=!0;const js={toc:[]};function Hs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},js,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Hs.isMDXComponent=!0;const Qs={toc:[]};function Ys(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Ys.isMDXComponent=!0;const $s={toc:[]};function Ks(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$s,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Ks.isMDXComponent=!0;const Js={toc:[]};function tc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Js,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Start all tasks one after another with a constant delay between."))}tc.isMDXComponent=!0;const ec={toc:[]};function nc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ec,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay between each of the tasks."))}nc.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to be run in a sequence."))}pc.isMDXComponent=!0;const rc={toc:[]};function sc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}sc.isMDXComponent=!0;const cc={toc:[]};function ic(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the given amount of time."))}ic.isMDXComponent=!0;const ac={toc:[]};function lc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ac,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The relative time in seconds."))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}hc.isMDXComponent=!0;const fc={toc:[]};function kc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}kc.isMDXComponent=!0;const yc={toc:[]};function Dc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the given time event."))}Dc.isMDXComponent=!0;const Mc={toc:[]};function wc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the time event."))}wc.isMDXComponent=!0;const _c={toc:[]};function Xc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}Xc.isMDXComponent=!0;const gc={toc:[]};function Tc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multi-media management."))}Tc.isMDXComponent=!0;const Cc={toc:[]};function xc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}xc.isMDXComponent=!0;const vc={toc:[]};function Lc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause/resume the audio."))}Lc.isMDXComponent=!0;const Zc={toc:[]};function bc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the audio should be paused or resumed."))}bc.isMDXComponent=!0;const Nc={toc:[]};function zc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The absolute biggest value from the peaks array."))}zc.isMDXComponent=!0;const Ac={toc:[]};function Wc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ac,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of samples taken."))}Wc.isMDXComponent=!0;const Ic={toc:[]};function Rc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ic,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Rc.isMDXComponent=!0;const Pc={toc:[]};function Sc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Samples per seconds."))}Sc.isMDXComponent=!0;const Oc={toc:[]};function Ec(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime representation of meta files."))}Ec.isMDXComponent=!0;const Bc={toc:[]};function Gc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a boolean value stored in a meta file."))}Gc.isMDXComponent=!0;const Uc={toc:[]};function Fc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Fc.isMDXComponent=!0;const Vc={toc:[]};function qc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}qc.isMDXComponent=!0;const jc={toc:[]};function Hc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Hc.isMDXComponent=!0;const Qc={toc:[]};function Yc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Yc.isMDXComponent=!0;const $c={toc:[]};function Kc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Kc.isMDXComponent=!0;const Jc={toc:[]};function ti(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}ti.isMDXComponent=!0;const ei={toc:[]};function ni(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ei,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}ni.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}pi.isMDXComponent=!0;const ri={toc:[]};function si(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ri,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}si.isMDXComponent=!0;const ci={toc:[]};function ii(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ci,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}ii.isMDXComponent=!0;const ai={toc:[]};function li(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ai,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ui,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},di,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}hi.isMDXComponent=!0;const fi={toc:[]};function ki(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}ki.isMDXComponent=!0;const yi={toc:[]};function Di(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Di.isMDXComponent=!0;const Mi={toc:[]};function wi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}wi.isMDXComponent=!0;const _i={toc:[]};function Xi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_i,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Xi.isMDXComponent=!0;const gi={toc:[]};function Ti(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Ti.isMDXComponent=!0;const Ci={toc:[]};function xi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ci,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}xi.isMDXComponent=!0;const vi={toc:[]};function Li(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Li.isMDXComponent=!0;const Zi={toc:[]};function bi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color stored in a meta file."))}bi.isMDXComponent=!0;const Ni={toc:[]};function zi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ni,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zi.isMDXComponent=!0;const Ai={toc:[]};function Wi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ai,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Wi.isMDXComponent=!0;const Ii={toc:[]};function Ri(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ii,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Ri.isMDXComponent=!0;const Pi={toc:[]};function Si(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Si.isMDXComponent=!0;const Oi={toc:[]};function Ei(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Ei.isMDXComponent=!0;const Bi={toc:[]};function Gi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Gi.isMDXComponent=!0;const Ui={toc:[]};function Fi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ui,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Fi.isMDXComponent=!0;const Vi={toc:[]};function qi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}qi.isMDXComponent=!0;const ji={toc:[]};function Hi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ji,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Hi.isMDXComponent=!0;const Qi={toc:[]};function Yi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Yi.isMDXComponent=!0;const $i={toc:[]};function Ki(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$i,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ki.isMDXComponent=!0;const Ji={toc:[]};function ta(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ji,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}ta.isMDXComponent=!0;const ea={toc:[]};function na(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ea,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}na.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}pa.isMDXComponent=!0;const ra={toc:[]};function sa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ra,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}sa.isMDXComponent=!0;const ca={toc:[]};function ia(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ca,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}ia.isMDXComponent=!0;const aa={toc:[]};function la(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ua,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},da,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ha.isMDXComponent=!0;const fa={toc:[]};function ka(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}ka.isMDXComponent=!0;const ya={toc:[]};function Da(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ya,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an enum value stored in a meta file."))}Da.isMDXComponent=!0;const Ma={toc:[]};function wa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ma,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}wa.isMDXComponent=!0;const _a={toc:[]};function Xa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Xa.isMDXComponent=!0;const ga={toc:[]};function Ta(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ga,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Ta.isMDXComponent=!0;const Ca={toc:[]};function xa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ca,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}xa.isMDXComponent=!0;const va={toc:[]};function La(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},va,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}La.isMDXComponent=!0;const Za={toc:[]};function ba(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Za,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}ba.isMDXComponent=!0;const Na={toc:[]};function za(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Na,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}za.isMDXComponent=!0;const Aa={toc:[]};function Wa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Wa.isMDXComponent=!0;const Ia={toc:[]};function Ra(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ia,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ra.isMDXComponent=!0;const Pa={toc:[]};function Sa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Sa.isMDXComponent=!0;const Oa={toc:[]};function Ea(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ea.isMDXComponent=!0;const Ba={toc:[]};function Ga(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ba,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Ga.isMDXComponent=!0;const Ua={toc:[]};function Fa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ua,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Fa.isMDXComponent=!0;const Va={toc:[]};function qa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Va,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}qa.isMDXComponent=!0;const ja={toc:[]};function Ha(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ja,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Ha.isMDXComponent=!0;const Qa={toc:[]};function Ya(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Ya.isMDXComponent=!0;const $a={toc:[]};function Ka(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Ka.isMDXComponent=!0;const Ja={toc:[]};function tl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ja,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}tl.isMDXComponent=!0;const el={toc:[]};function nl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},el,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the exporter configuration."))}nl.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ol,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}pl.isMDXComponent=!0;const rl={toc:[]};function sl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}sl.isMDXComponent=!0;const cl={toc:[]};function il(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}il.isMDXComponent=!0;const al={toc:[]};function ll(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},al,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ul,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}hl.isMDXComponent=!0;const fl={toc:[]};function kl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}kl.isMDXComponent=!0;const yl={toc:[]};function Dl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Dl.isMDXComponent=!0;const Ml={toc:[]};function wl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ml,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}wl.isMDXComponent=!0;const _l={toc:[]};function Xl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_l,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Xl.isMDXComponent=!0;const gl={toc:[]};function Tl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Tl.isMDXComponent=!0;const Cl={toc:[]};function xl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}xl.isMDXComponent=!0;const vl={toc:[]};function Ll(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Ll.isMDXComponent=!0;const Zl={toc:[]};function bl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}bl.isMDXComponent=!0;const Nl={toc:[]};function zl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}zl.isMDXComponent=!0;const Al={toc:[]};function Wl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Al,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Wl.isMDXComponent=!0;const Il={toc:[]};function Rl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Il,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Rl.isMDXComponent=!0;const Pl={toc:[]};function Sl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Sl.isMDXComponent=!0;const Ol={toc:[]};function El(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ol,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}El.isMDXComponent=!0;const Bl={toc:[]};function Gl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an entry in the meta file."))}Gl.isMDXComponent=!0;const Ul={toc:[]};function Fl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ul,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Fl.isMDXComponent=!0;const Vl={toc:[]};function ql(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}ql.isMDXComponent=!0;const jl={toc:[]};function Hl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Hl.isMDXComponent=!0;const Ql={toc:[]};function Yl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ql,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Yl.isMDXComponent=!0;const $l={toc:[]};function Kl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$l,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Kl.isMDXComponent=!0;const Jl={toc:[]};function tu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tu.isMDXComponent=!0;const eu={toc:[]};function nu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}nu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ou,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}pu.isMDXComponent=!0;const ru={toc:[]};function su(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ru,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}su.isMDXComponent=!0;const cu={toc:[]};function iu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}iu.isMDXComponent=!0;const au={toc:[]};function lu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},au,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},du,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}hu.isMDXComponent=!0;const fu={toc:[]};function ku(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}ku.isMDXComponent=!0;const yu={toc:[]};function Du(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Du.isMDXComponent=!0;const Mu={toc:[]};function wu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}wu.isMDXComponent=!0;const _u={toc:[]};function Xu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Xu.isMDXComponent=!0;const gu={toc:[]};function Tu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Tu.isMDXComponent=!0;const Cu={toc:[]};function xu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}xu.isMDXComponent=!0;const vu={toc:[]};function Lu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Lu.isMDXComponent=!0;const Zu={toc:[]};function bu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type used to store this field in the meta\nfile."))}bu.isMDXComponent=!0;const Nu={toc:[]};function zu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime type of this field."))}zu.isMDXComponent=!0;const Au={toc:[]};function Wu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Au,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a number stored in a meta file."))}Wu.isMDXComponent=!0;const Iu={toc:[]};function Ru(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Ru.isMDXComponent=!0;const Pu={toc:[]};function Su(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Su.isMDXComponent=!0;const Ou={toc:[]};function Eu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ou,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Eu.isMDXComponent=!0;const Bu={toc:[]};function Gu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Gu.isMDXComponent=!0;const Uu={toc:[]};function Fu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Fu.isMDXComponent=!0;const Vu={toc:[]};function qu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}qu.isMDXComponent=!0;const ju={toc:[]};function Hu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ju,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Hu.isMDXComponent=!0;const Qu={toc:[]};function Yu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Yu.isMDXComponent=!0;const $u={toc:[]};function Ku(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Ku.isMDXComponent=!0;const Ju={toc:[]};function tm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ju,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}tm.isMDXComponent=!0;const em={toc:[]};function nm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},em,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}nm.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},om,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}pm.isMDXComponent=!0;const rm={toc:[]};function sm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}sm.isMDXComponent=!0;const cm={toc:[]};function im(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}im.isMDXComponent=!0;const am={toc:[]};function lm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},am,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},um,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}hm.isMDXComponent=!0;const fm={toc:[]};function km(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}km.isMDXComponent=!0;const ym={toc:[]};function Dm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ym,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Dm.isMDXComponent=!0;const Mm={toc:[]};function wm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}wm.isMDXComponent=!0;const _m={toc:[]};function Xm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_m,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Range is an array with two elements denoting the beginning and end of a\nrange, respectively."))}Xm.isMDXComponent=!0;const gm={toc:[]};function Tm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a range stored in a meta file."))}Tm.isMDXComponent=!0;const Cm={toc:[]};function xm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}xm.isMDXComponent=!0;const vm={toc:[]};function Lm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Lm.isMDXComponent=!0;const Zm={toc:[]};function bm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bm.isMDXComponent=!0;const Nm={toc:[]};function zm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zm.isMDXComponent=!0;const Am={toc:[]};function Wm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Am,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Wm.isMDXComponent=!0;const Im={toc:[]};function Rm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Im,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Rm.isMDXComponent=!0;const Pm={toc:[]};function Sm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Sm.isMDXComponent=!0;const Om={toc:[]};function Em(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Om,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Em.isMDXComponent=!0;const Bm={toc:[]};function Gm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Gm.isMDXComponent=!0;const Um={toc:[]};function Fm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Um,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Fm.isMDXComponent=!0;const Vm={toc:[]};function qm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}qm.isMDXComponent=!0;const jm={toc:[]};function Hm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Hm.isMDXComponent=!0;const Qm={toc:[]};function Ym(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ym.isMDXComponent=!0;const $m={toc:[]};function Km(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$m,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Km.isMDXComponent=!0;const Jm={toc:[]};function td(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}td.isMDXComponent=!0;const ed={toc:[]};function nd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ed,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}nd.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},od,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}pd.isMDXComponent=!0;const rd={toc:[]};function sd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sd.isMDXComponent=!0;const cd={toc:[]};function id(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}id.isMDXComponent=!0;const ad={toc:[]};function ld(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ad,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ud,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This helper method applies additional validation to the range, preventing\nit from overflowing the timeline."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given range from frames to seconds and update this field."))}hd.isMDXComponent=!0;const fd={toc:[]};function kd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The beginning of the range."))}kd.isMDXComponent=!0;const yd={toc:[]};function Dd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}Dd.isMDXComponent=!0;const Md={toc:[]};function wd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Md,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current duration in frames."))}wd.isMDXComponent=!0;const _d={toc:[]};function Xd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current framerate."))}Xd.isMDXComponent=!0;const gd={toc:[]};function Td(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a string stored in a meta file."))}Td.isMDXComponent=!0;const Cd={toc:[]};function xd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}xd.isMDXComponent=!0;const vd={toc:[]};function Ld(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Ld.isMDXComponent=!0;const Zd={toc:[]};function bd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bd.isMDXComponent=!0;const Nd={toc:[]};function zd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zd.isMDXComponent=!0;const Ad={toc:[]};function Wd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ad,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Wd.isMDXComponent=!0;const Id={toc:[]};function Rd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Id,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Rd.isMDXComponent=!0;const Pd={toc:[]};function Sd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Sd.isMDXComponent=!0;const Od={toc:[]};function Ed(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Od,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Ed.isMDXComponent=!0;const Bd={toc:[]};function Gd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Gd.isMDXComponent=!0;const Ud={toc:[]};function Fd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ud,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Fd.isMDXComponent=!0;const Vd={toc:[]};function qd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}qd.isMDXComponent=!0;const jd={toc:[]};function Hd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Hd.isMDXComponent=!0;const Qd={toc:[]};function Yd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Yd.isMDXComponent=!0;const $d={toc:[]};function Kd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Kd.isMDXComponent=!0;const Jd={toc:[]};function th(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}th.isMDXComponent=!0;const eh={toc:[]};function nh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}nh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}ph.isMDXComponent=!0;const rh={toc:[]};function sh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sh.isMDXComponent=!0;const ch={toc:[]};function ih(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ch,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ih.isMDXComponent=!0;const ah={toc:[]};function lh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ah,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector stored in a meta file."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}hh.isMDXComponent=!0;const fh={toc:[]};function kh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}kh.isMDXComponent=!0;const yh={toc:[]};function Dh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Dh.isMDXComponent=!0;const Mh={toc:[]};function wh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}wh.isMDXComponent=!0;const _h={toc:[]};function Xh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_h,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Xh.isMDXComponent=!0;const gh={toc:[]};function Th(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Th.isMDXComponent=!0;const Ch={toc:[]};function xh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ch,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}xh.isMDXComponent=!0;const vh={toc:[]};function Lh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Lh.isMDXComponent=!0;const Zh={toc:[]};function bh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}bh.isMDXComponent=!0;const Nh={toc:[]};function zh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}zh.isMDXComponent=!0;const Ah={toc:[]};function Wh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ah,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Wh.isMDXComponent=!0;const Ih={toc:[]};function Rh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ih,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Rh.isMDXComponent=!0;const Ph={toc:[]};function Sh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ph,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Sh.isMDXComponent=!0;const Oh={toc:[]};function Eh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Eh.isMDXComponent=!0;const Bh={toc:[]};function Gh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Gh.isMDXComponent=!0;const Uh={toc:[]};function Fh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Fh.isMDXComponent=!0;const Vh={toc:[]};function qh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}qh.isMDXComponent=!0;const jh={toc:[]};function Hh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Hh.isMDXComponent=!0;const Qh={toc:[]};function Yh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Yh.isMDXComponent=!0;const $h={toc:[]};function Kh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$h,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Kh.isMDXComponent=!0;const Jh={toc:[]};function tf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}tf.isMDXComponent=!0;const ef={toc:[]};function nf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ef,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}nf.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},of,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a runtime Motion Canvas plugin."))}pf.isMDXComponent=!0;const rf={toc:[]};function sf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide custom exporters for the project."))}sf.isMDXComponent=!0;const cf={toc:[]};function af(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the player instance right after it is initialized."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player instance."))}df.isMDXComponent=!0;const hf={toc:[]};function ff(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the presenter instance right after it is initialized."))}ff.isMDXComponent=!0;const kf={toc:[]};function yf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presenter instance."))}yf.isMDXComponent=!0;const Df={toc:[]};function Mf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Df,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the project instance right after it is initialized."))}Mf.isMDXComponent=!0;const wf={toc:[]};function _f(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}_f.isMDXComponent=!0;const Xf={toc:[]};function gf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the renderer instance right after it is initialized."))}gf.isMDXComponent=!0;const Tf={toc:[]};function Cf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The renderer instance."))}Cf.isMDXComponent=!0;const xf={toc:[]};function vf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Modify the project settings before the project is initialized."))}vf.isMDXComponent=!0;const Lf={toc:[]};function Zf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project settings."))}Zf.isMDXComponent=!0;const bf={toc:[]};function Nf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makePlugin({\n  name: 'my-custom-plugin',\n});\n")))}Nf.isMDXComponent=!0;const zf={toc:[]};function Af(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper function for exporting Motion Canvas plugins."))}Af.isMDXComponent=!0;const Wf={toc:[]};function If(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The plugin configuration."))}If.isMDXComponent=!0;const Rf={toc:[]};function Pf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abstract scene representations and related utilities."))}Pf.isMDXComponent=!0;const Sf={toc:[]};function Of(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Signifies the various stages of a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}Of.isMDXComponent=!0;const Ef={toc:[]};function Bf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ef,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs after a render ends."))}Bf.isMDXComponent=!0;const Gf={toc:[]};function Uf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}Uf.isMDXComponent=!0;const Ff={toc:[]};function Vf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ff,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Vf.isMDXComponent=!0;const qf={toc:[]};function jf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}jf.isMDXComponent=!0;const Hf={toc:[]};function Qf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes the state of a scene."))}Qf.isMDXComponent=!0;const Yf={toc:[]};function $f(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}$f.isMDXComponent=!0;const Kf={toc:[]};function Jf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished transitioning in."))}Jf.isMDXComponent=!0;const tk={toc:[]};function ek(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}ek.isMDXComponent=!0;const nk={toc:[]};function ok(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene is ready to transition out."))}ok.isMDXComponent=!0;const pk={toc:[]};function rk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoking ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}rk.isMDXComponent=!0;const sk={toc:[]};function ck(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished."))}ck.isMDXComponent=!0;const ik={toc:[]};function ak(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ik,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has just been created/reset."))}ak.isMDXComponent=!0;const lk={toc:[]};function uk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The default implementation of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.kt)("p",null,"Uses generators to control the animation."))}uk.isMDXComponent=!0;const mk={toc:[]};function dk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}dk.isMDXComponent=!0;const hk={toc:[]};function fk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}fk.isMDXComponent=!0;const kk={toc:[]};function yk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}yk.isMDXComponent=!0;const Dk={toc:[]};function Mk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Mk.isMDXComponent=!0;const wk={toc:[]};function _k(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}_k.isMDXComponent=!0;const Xk={toc:[]};function gk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}gk.isMDXComponent=!0;const Tk={toc:[]};function Ck(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}Ck.isMDXComponent=!0;const xk={toc:[]};function vk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}vk.isMDXComponent=!0;const Lk={toc:[]};function Zk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}Zk.isMDXComponent=!0;const bk={toc:[]};function Nk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}Nk.isMDXComponent=!0;const zk={toc:[]};function Ak(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Ak.isMDXComponent=!0;const Wk={toc:[]};function Ik(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}Ik.isMDXComponent=!0;const Rk={toc:[]};function Pk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}Pk.isMDXComponent=!0;const Sk={toc:[]};function Ok(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Ok.isMDXComponent=!0;const Ek={toc:[]};function Bk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ek,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Bk.isMDXComponent=!0;const Gk={toc:[]};function Uk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Uk.isMDXComponent=!0;const Fk={toc:[]};function Vk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}Vk.isMDXComponent=!0;const qk={toc:[]};function jk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}jk.isMDXComponent=!0;const Hk={toc:[]};function Qk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}Qk.isMDXComponent=!0;const Yk={toc:[]};function $k(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}$k.isMDXComponent=!0;const Kk={toc:[]};function Jk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}Jk.isMDXComponent=!0;const ty={toc:[]};function ey(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ty,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}ey.isMDXComponent=!0;const ny={toc:[]};function oy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ny,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}oy.isMDXComponent=!0;const py={toc:[]};function ry(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},py,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}ry.isMDXComponent=!0;const sy={toc:[]};function cy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}cy.isMDXComponent=!0;const iy={toc:[]};function ay(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}ay.isMDXComponent=!0;const ly={toc:[]};function uy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ly,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}uy.isMDXComponent=!0;const my={toc:[]};function dy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},my,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}dy.isMDXComponent=!0;const hy={toc:[]};function fy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}fy.isMDXComponent=!0;const ky={toc:[]};function yy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ky,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}yy.isMDXComponent=!0;const Dy={toc:[]};function My(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}My.isMDXComponent=!0;const wy={toc:[]};function _y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}_y.isMDXComponent=!0;const Xy={toc:[]};function gy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}gy.isMDXComponent=!0;const Ty={toc:[]};function Cy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ty,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}Cy.isMDXComponent=!0;const xy={toc:[]};function vy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}vy.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ly,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}Zy.isMDXComponent=!0;const by={toc:[]};function Ny(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},by,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Lifecycle events for ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Ny.isMDXComponent=!0;const zy={toc:[]};function Ay(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A random number generator based on\n",(0,s.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Ay.isMDXComponent=!0;const Wy={toc:[]};function Iy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random floats in the given range."))}Iy.isMDXComponent=!0;const Ry={toc:[]};function Py(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ry,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."))}Py.isMDXComponent=!0;const Sy={toc:[]};function Oy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}Oy.isMDXComponent=!0;const Ey={toc:[]};function By(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ey,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}By.isMDXComponent=!0;const Gy={toc:[]};function Uy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a random float from a gaussian distribution."))}Uy.isMDXComponent=!0;const Fy={toc:[]};function Vy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The mean of the distribution."))}Vy.isMDXComponent=!0;const qy={toc:[]};function jy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The standard deviation of the distribution."))}jy.isMDXComponent=!0;const Hy={toc:[]};function Qy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random integers in the given range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"}),(0,s.kt)("li",{parentName:"ul"})))}Qy.isMDXComponent=!0;const Yy={toc:[]};function $y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}$y.isMDXComponent=!0;const Ky={toc:[]};function Jy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ky,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}Jy.isMDXComponent=!0;const tD={toc:[]};function eD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}eD.isMDXComponent=!0;const nD={toc:[]};function oD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random float in the given range."))}oD.isMDXComponent=!0;const pD={toc:[]};function rD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}rD.isMDXComponent=!0;const sD={toc:[]};function cD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}cD.isMDXComponent=!0;const iD={toc:[]};function aD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random integer in the given range."))}aD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}dD.isMDXComponent=!0;const hD={toc:[]};function fD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a new independent generator."))}fD.isMDXComponent=!0;const kD={toc:[]};function yD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}yD.isMDXComponent=!0;const DD={toc:[]};function MD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the variable."))}MD.isMDXComponent=!0;const wD={toc:[]};function _D(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}_D.isMDXComponent=!0;const XD={toc:[]};function gD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}gD.isMDXComponent=!0;const TD={toc:[]};function CD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset all stored signals."))}CD.isMDXComponent=!0;const xD={toc:[]};function vD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update all signals with new project variable values."))}vD.isMDXComponent=!0;const LD={toc:[]};function ZD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes cached information about the timing of a scene."))}ZD.isMDXComponent=!0;const bD={toc:[]};function ND(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a complete scene together with the meta file."))}ND.isMDXComponent=!0;const zD={toc:[]};function AD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}AD.isMDXComponent=!0;const WD={toc:[]};function ID(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}ID.isMDXComponent=!0;const RD={toc:[]};function PD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}PD.isMDXComponent=!0;const SD={toc:[]};function OD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}OD.isMDXComponent=!0;const ED={toc:[]};function BD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ED,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}BD.isMDXComponent=!0;const GD={toc:[]};function UD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}UD.isMDXComponent=!0;const FD={toc:[]};function VD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for the inspected element."))}VD.isMDXComponent=!0;const qD={toc:[]};function jD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element for which to draw an overlay."))}jD.isMDXComponent=!0;const HD={toc:[]};function QD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}QD.isMDXComponent=!0;const YD={toc:[]};function $D(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$D.isMDXComponent=!0;const KD={toc:[]};function JD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}JD.isMDXComponent=!0;const tM={toc:[]};function eM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the attributes of the inspected element."))}eM.isMDXComponent=!0;const nM={toc:[]};function oM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to inspect."))}oM.isMDXComponent=!0;const pM={toc:[]};function rM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a possible element to inspect at a given position."))}rM.isMDXComponent=!0;const sM={toc:[]};function cM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}cM.isMDXComponent=!0;const iM={toc:[]};function aM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}aM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transform the absolute mouse coordinates into the scene's coordinate system."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}dM.isMDXComponent=!0;const hM={toc:[]};function fM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}fM.isMDXComponent=!0;const kM={toc:[]};function yM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}yM.isMDXComponent=!0;const DM={toc:[]};function MM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the inspected element is still valid."))}MM.isMDXComponent=!0;const wM={toc:[]};function _M(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to validate."))}_M.isMDXComponent=!0;const XM={toc:[]};function gM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}gM.isMDXComponent=!0;const TM={toc:[]};function CM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for scenes."))}CM.isMDXComponent=!0;const xM={toc:[]};function vM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}vM.isMDXComponent=!0;const LM={toc:[]};function ZM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}ZM.isMDXComponent=!0;const bM={toc:[]};function NM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}NM.isMDXComponent=!0;const zM={toc:[]};function AM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}AM.isMDXComponent=!0;const WM={toc:[]};function IM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}IM.isMDXComponent=!0;const RM={toc:[]};function PM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}PM.isMDXComponent=!0;const SM={toc:[]};function OM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}OM.isMDXComponent=!0;const EM={toc:[]};function BM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}BM.isMDXComponent=!0;const GM={toc:[]};function UM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}UM.isMDXComponent=!0;const FM={toc:[]};function VM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}VM.isMDXComponent=!0;const qM={toc:[]};function jM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}jM.isMDXComponent=!0;const HM={toc:[]};function QM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}QM.isMDXComponent=!0;const YM={toc:[]};function $M(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}$M.isMDXComponent=!0;const KM={toc:[]};function JM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}JM.isMDXComponent=!0;const tw={toc:[]};function ew(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}ew.isMDXComponent=!0;const nw={toc:[]};function ow(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}ow.isMDXComponent=!0;const pw={toc:[]};function rw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}rw.isMDXComponent=!0;const sw={toc:[]};function cw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}cw.isMDXComponent=!0;const iw={toc:[]};function aw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}aw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}dw.isMDXComponent=!0;const hw={toc:[]};function fw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}fw.isMDXComponent=!0;const kw={toc:[]};function yw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}yw.isMDXComponent=!0;const Dw={toc:[]};function Mw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Mw.isMDXComponent=!0;const ww={toc:[]};function _w(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ww,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}_w.isMDXComponent=!0;const Xw={toc:[]};function gw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}gw.isMDXComponent=!0;const Tw={toc:[]};function Cw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}Cw.isMDXComponent=!0;const xw={toc:[]};function vw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}vw.isMDXComponent=!0;const Lw={toc:[]};function Zw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}Zw.isMDXComponent=!0;const bw={toc:[]};function Nw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}Nw.isMDXComponent=!0;const zw={toc:[]};function Aw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}Aw.isMDXComponent=!0;const Ww={toc:[]};function Iw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ww,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}Iw.isMDXComponent=!0;const Rw={toc:[]};function Pw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}Pw.isMDXComponent=!0;const Sw={toc:[]};function Ow(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each class implementing the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}Ow.isMDXComponent=!0;const Ew={toc:[]};function Bw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ew,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constructor used when creating new scenes."))}Bw.isMDXComponent=!0;const Gw={toc:[]};function Uw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.kt)("inlineCode",{parentName:"a"},"config")),"."))}Uw.isMDXComponent=!0;const Fw={toc:[]};function Vw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a scene exposed by scene files."))}Vw.isMDXComponent=!0;const qw={toc:[]};function jw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}jw.isMDXComponent=!0;const Hw={toc:[]};function Qw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}Qw.isMDXComponent=!0;const Yw={toc:[]};function $w(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}$w.isMDXComponent=!0;const Kw={toc:[]};function Jw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}Jw.isMDXComponent=!0;const t_={toc:[]};function e_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A part of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}e_.isMDXComponent=!0;const n_={toc:[]};function o_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}o_.isMDXComponent=!0;const p_={toc:[]};function r_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}r_.isMDXComponent=!0;const s_={toc:[]};function c_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}c_.isMDXComponent=!0;const i_={toc:[]};function a_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}a_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents attributes of an inspected element."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}d_.isMDXComponent=!0;const h_={toc:[]};function f_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an element to inspect."))}f_.isMDXComponent=!0;const k_={toc:[]};function y_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the scene metadata."))}y_.isMDXComponent=!0;const D_={toc:[]};function M_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the scene metadata."))}M_.isMDXComponent=!0;const w_={toc:[]};function __(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}__.isMDXComponent=!0;const X_={toc:[]};function g_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}g_.isMDXComponent=!0;const T_={toc:[]};function C_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}C_.isMDXComponent=!0;const x_={toc:[]};function v_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}v_.isMDXComponent=!0;const L_={toc:[]};function Z_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Z_.isMDXComponent=!0;const b_={toc:[]};function N_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}N_.isMDXComponent=!0;const z_={toc:[]};function A_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}A_.isMDXComponent=!0;const W_={toc:[]};function I_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}I_.isMDXComponent=!0;const R_={toc:[]};function P_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}P_.isMDXComponent=!0;const S_={toc:[]};function O_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}O_.isMDXComponent=!0;const E_={toc:[]};function B_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}B_.isMDXComponent=!0;const G_={toc:[]};function U_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}U_.isMDXComponent=!0;const F_={toc:[]};function V_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}V_.isMDXComponent=!0;const q_={toc:[]};function j_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}j_.isMDXComponent=!0;const H_={toc:[]};function Q_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Q_.isMDXComponent=!0;const Y_={toc:[]};function $_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}$_.isMDXComponent=!0;const K_={toc:[]};function J_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}J_.isMDXComponent=!0;const tX={toc:[]};function eX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}eX.isMDXComponent=!0;const nX={toc:[]};function oX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}oX.isMDXComponent=!0;const pX={toc:[]};function rX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}rX.isMDXComponent=!0;const sX={toc:[]};function cX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}cX.isMDXComponent=!0;const iX={toc:[]};function aX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}aX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}dX.isMDXComponent=!0;const hX={toc:[]};function fX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}fX.isMDXComponent=!0;const kX={toc:[]};function yX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween back to the original value."))}yX.isMDXComponent=!0;const DX={toc:[]};function MX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}MX.isMDXComponent=!0;const wX={toc:[]};function _X(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function of the tween."))}_X.isMDXComponent=!0;const XX={toc:[]};function gX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function of the tween."))}gX.isMDXComponent=!0;const TX={toc:[]};function CX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback."))}CX.isMDXComponent=!0;const xX={toc:[]};function vX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}vX.isMDXComponent=!0;const LX={toc:[]};function ZX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given task."))}ZX.isMDXComponent=!0;const bX={toc:[]};function NX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator to run."))}NX.isMDXComponent=!0;const zX={toc:[]};function AX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween to the specified value."))}AX.isMDXComponent=!0;const WX={toc:[]};function IX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the specified duration."))}IX.isMDXComponent=!0;const RX={toc:[]};function PX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration to wait."))}PX.isMDXComponent=!0;const SX={toc:[]};function OX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread management."))}OX.isMDXComponent=!0;const EX={toc:[]};function BX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}BX.isMDXComponent=!0;const GX={toc:[]};function UX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A class representing an individual thread."))}UX.isMDXComponent=!0;const FX={toc:[]};function VX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}VX.isMDXComponent=!0;const qX={toc:[]};function jX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}jX.isMDXComponent=!0;const HX={toc:[]};function QX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}QX.isMDXComponent=!0;const YX={toc:[]};function $X(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current time of this thread."))}$X.isMDXComponent=!0;const KX={toc:[]};function JX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The next value to be passed to the wrapped generator."))}JX.isMDXComponent=!0;const tg={toc:[]};function eg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}eg.isMDXComponent=!0;const ng={toc:[]};function og(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ng,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}og.isMDXComponent=!0;const pg={toc:[]};function rg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The fixed time of this thread."))}rg.isMDXComponent=!0;const sg={toc:[]};function cg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress the wrapped generator once."))}cg.isMDXComponent=!0;const ig={toc:[]};function ag(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ig,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the thread for the next update cycle."))}ag.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delta time of the next cycle."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a normal function that returns a generator."))}dg.isMDXComponent=!0;const hg={toc:[]};function fg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.kt)("p",null,"Progress to the next frame:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.kt)("p",null,"Run another generator synchronously:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.kt)("p",null,"Run another generator concurrently:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.kt)("p",null,"Await a Promise:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}fg.isMDXComponent=!0;const kg={toc:[]};function yg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}yg.isMDXComponent=!0;const Dg={toc:[]};function Mg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Cancel all listed tasks."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Mg.isMDXComponent=!0;const wg={toc:[]};function _g(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to cancel."))}_g.isMDXComponent=!0;const Xg={toc:[]};function gg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}gg.isMDXComponent=!0;const Tg={toc:[]};function Cg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}Cg.isMDXComponent=!0;const xg={toc:[]};function vg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}vg.isMDXComponent=!0;const Lg={toc:[]};function Zg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible thread ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Zg.isMDXComponent=!0;const bg={toc:[]};function Ng(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}Ng.isMDXComponent=!0;const zg={toc:[]};function Ag(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}Ag.isMDXComponent=!0;const Wg={toc:[]};function Ig(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Ig.isMDXComponent=!0;const Rg={toc:[]};function Pg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}Pg.isMDXComponent=!0;const Sg={toc:[]};function Og(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until listed tasks are finished."))}Og.isMDXComponent=!0;const Eg={toc:[]};function Bg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}Bg.isMDXComponent=!0;const Gg={toc:[]};function Ug(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Ug.isMDXComponent=!0;const Fg={toc:[]};function Vg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"From the perspective of the external generator, ",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}Vg.isMDXComponent=!0;const qg={toc:[]};function jg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}jg.isMDXComponent=!0;const Hg={toc:[]};function Qg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a context in which generators can be run concurrently."))}Qg.isMDXComponent=!0;const Yg={toc:[]};function $g(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the generator to run."))}$g.isMDXComponent=!0;const Kg={toc:[]};function Jg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}Jg.isMDXComponent=!0;const tT={toc:[]};function eT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transitions between scenes."))}eT.isMDXComponent=!0;const nT={toc:[]};function oT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that fades between the scenes."))}oT.isMDXComponent=!0;const pT={toc:[]};function rT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}rT.isMDXComponent=!0;const sT={toc:[]};function cT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}cT.isMDXComponent=!0;const iT={toc:[]};function aT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The direction in which to slide."))}aT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}dT.isMDXComponent=!0;const hT={toc:[]};function fT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the current scene is rendered."))}fT.isMDXComponent=!0;const kT={toc:[]};function yT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the previous scene is rendered."))}yT.isMDXComponent=!0;const DT={toc:[]};function MT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}MT.isMDXComponent=!0;const wT={toc:[]};function _T(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area on which to zoom in."))}_T.isMDXComponent=!0;const XT={toc:[]};function gT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}gT.isMDXComponent=!0;const TT={toc:[]};function CT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}CT.isMDXComponent=!0;const xT={toc:[]};function vT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area from which to zoom out."))}vT.isMDXComponent=!0;const LT={toc:[]};function ZT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}ZT.isMDXComponent=!0;const bT={toc:[]};function NT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolation and timing of tweens."))}NT.isMDXComponent=!0;const zT={toc:[]};function AT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any old key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"})))}AT.isMDXComponent=!0;const WT={toc:[]};function IT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}IT.isMDXComponent=!0;const RT={toc:[]};function PT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}PT.isMDXComponent=!0;const ST={toc:[]};function OT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ST,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}OT.isMDXComponent=!0;const ET={toc:[]};function BT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ET,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}BT.isMDXComponent=!0;const GT={toc:[]};function UT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}UT.isMDXComponent=!0;const FT={toc:[]};function VT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}VT.isMDXComponent=!0;const qT={toc:[]};function jT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}jT.isMDXComponent=!0;const HT={toc:[]};function QT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}QT.isMDXComponent=!0;const YT={toc:[]};function $T(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}$T.isMDXComponent=!0;const KT={toc:[]};function JT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}JT.isMDXComponent=!0;const tC={toc:[]};function eC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Complex types used in animations."))}eC.isMDXComponent=!0;const nC={toc:[]};function oC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}oC.isMDXComponent=!0;const pC={toc:[]};function rC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the determinant of the matrix."))}rC.isMDXComponent=!0;const sC={toc:[]};function cC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}cC.isMDXComponent=!0;const iC={toc:[]};function aC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}aC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the inverse of the matrix."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}dC.isMDXComponent=!0;const hC={toc:[]};function fC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}fC.isMDXComponent=!0;const kC={toc:[]};function yC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the provided matrix to this matrix."))}yC.isMDXComponent=!0;const DC={toc:[]};function MC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to add"))}MC.isMDXComponent=!0;const wC={toc:[]};function _C(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}_C.isMDXComponent=!0;const XC={toc:[]};function gC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}gC.isMDXComponent=!0;const TC={toc:[]};function CC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the component vector to retrieve."))}CC.isMDXComponent=!0;const xC={toc:[]};function vC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}vC.isMDXComponent=!0;const LC={toc:[]};function ZC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}ZC.isMDXComponent=!0;const bC={toc:[]};function NC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}NC.isMDXComponent=!0;const zC={toc:[]};function AC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to multiply with"))}AC.isMDXComponent=!0;const WC={toc:[]};function IC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}IC.isMDXComponent=!0;const RC={toc:[]};function PC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}PC.isMDXComponent=!0;const SC={toc:[]};function OC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to scale each term"))}OC.isMDXComponent=!0;const EC={toc:[]};function BC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}BC.isMDXComponent=!0;const GC={toc:[]};function UC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}UC.isMDXComponent=!0;const FC={toc:[]};function VC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}VC.isMDXComponent=!0;const qC={toc:[]};function jC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate the matrix."))}jC.isMDXComponent=!0;const HC={toc:[]};function QC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the angle is provided in degrees."))}QC.isMDXComponent=!0;const YC={toc:[]};function $C(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}$C.isMDXComponent=!0;const KC={toc:[]};function JC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}JC.isMDXComponent=!0;const tx={toc:[]};function ex(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the row to retrieve."))}ex.isMDXComponent=!0;const nx={toc:[]};function ox(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}ox.isMDXComponent=!0;const px={toc:[]};function rx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},px,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}rx.isMDXComponent=!0;const sx={toc:[]};function cx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scale the x and y component vectors of the matrix."))}cx.isMDXComponent=!0;const ix={toc:[]};function ax(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ix,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The factor by which to scale the matrix"))}ax.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}dx.isMDXComponent=!0;const hx={toc:[]};function fx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subtract the provided matrix from this matrix."))}fx.isMDXComponent=!0;const kx={toc:[]};function yx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to subract"))}yx.isMDXComponent=!0;const Dx={toc:[]};function Mx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Mx.isMDXComponent=!0;const wx={toc:[]};function _x(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}_x.isMDXComponent=!0;const Xx={toc:[]};function gx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}gx.isMDXComponent=!0;const Tx={toc:[]};function Cx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector by which to translate the matrix"))}Cx.isMDXComponent=!0;const xx={toc:[]};function vx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector."))}vx.isMDXComponent=!0;const Lx={toc:[]};function Zx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}Zx.isMDXComponent=!0;const bx={toc:[]};function Nx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}Nx.isMDXComponent=!0;const zx={toc:[]};function Ax(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}Ax.isMDXComponent=!0;const Wx={toc:[]};function Ix(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}Ix.isMDXComponent=!0;const Rx={toc:[]};function Px(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are equal to each other."))}Px.isMDXComponent=!0;const Sx={toc:[]};function Ox(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}Ox.isMDXComponent=!0;const Ex={toc:[]};function Bx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ex,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The allowed error threshold when comparing the vectors."))}Bx.isMDXComponent=!0;const Gx={toc:[]};function Ux(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}Ux.isMDXComponent=!0;const Fx={toc:[]};function Vx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are exactly equal to each other."))}Vx.isMDXComponent=!0;const qx={toc:[]};function jx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}jx.isMDXComponent=!0;const Hx={toc:[]};function Qx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotates the vector around a point by the provided angle."))}Qx.isMDXComponent=!0;const Yx={toc:[]};function $x(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate in degrees."))}$x.isMDXComponent=!0;const Kx={toc:[]};function Jx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}Jx.isMDXComponent=!0;const tv={toc:[]};function ev(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Helper function to create a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#static-polarLerp"},(0,s.kt)("inlineCode",{parentName:"a"},"polarLerp"))," interpolation\nfunction with additional parameters."))}ev.isMDXComponent=!0;const nv={toc:[]};function ov(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the point should get rotated\ncounterclockwise."))}ov.isMDXComponent=!0;const pv={toc:[]};function rv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}rv.isMDXComponent=!0;const sv={toc:[]};function cv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}cv.isMDXComponent=!0;const iv={toc:[]};function av(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}av.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}dv.isMDXComponent=!0;const hv={toc:[]};function fv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This function is useful when used in conjunction with ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"rotate"))," to\nanimate an object's position on a circular arc (see examples)."))}fv.isMDXComponent=!0;const kv={toc:[]};function yv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Animating an object in a circle around the origin"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.polarLerp\n);\n")))}yv.isMDXComponent=!0;const Dv={toc:[]};function Mv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotating an object around the point ",(0,s.kt)("inlineCode",{parentName:"p"},"[-200, 100]")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180, [-200, 100]),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(false, [-200, 100]),\n);\n")))}Mv.isMDXComponent=!0;const wv={toc:[]};function _v(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotating an object counterclockwise around the origin"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(true),\n);\n")))}_v.isMDXComponent=!0;const Xv={toc:[]};function gv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolates between two vectors on the polar plane by interpolating\nthe angles and magnitudes of the vectors individually."))}gv.isMDXComponent=!0;const Tv={toc:[]};function Cv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting vector."))}Cv.isMDXComponent=!0;const xv={toc:[]};function vv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The target vector."))}vv.isMDXComponent=!0;const Lv={toc:[]};function Zv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t-value of the interpolation."))}Zv.isMDXComponent=!0;const bv={toc:[]};function Nv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the vector should get rotated\ncounterclockwise. Defaults to ",(0,s.kt)("inlineCode",{parentName:"p"},"false"),"."))}Nv.isMDXComponent=!0;const zv={toc:[]};function Av(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}Av.isMDXComponent=!0;const Wv={toc:[]};function Iv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}Iv.isMDXComponent=!0;const Rv={toc:[]};function Pv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}Pv.isMDXComponent=!0;const Sv={toc:[]};function Ov(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}Ov.isMDXComponent=!0;const Ev={toc:[]};function Bv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ev,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same class as the one created by\n",(0,s.kt)("a",{parentName:"p",href:"https://gka.github.io/chroma.js/"},(0,s.kt)("inlineCode",{parentName:"a"},"chroma.js")),". Check out their\ndocumentation for more information on how to use it."))}Bv.isMDXComponent=!0;const Gv={toc:[]};function Uv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color."))}Uv.isMDXComponent=!0;const Fv={toc:[]};function Vv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}Vv.isMDXComponent=!0;const qv={toc:[]};function jv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given origin to a vector representing its offset."))}jv.isMDXComponent=!0;const Hv={toc:[]};function Qv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin to convert."))}Qv.isMDXComponent=!0;const Yv={toc:[]};function $v(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"General utilities and helper functions."))}$v.isMDXComponent=!0;const Kv={toc:[]};function Jv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}Jv.isMDXComponent=!0;const tL={toc:[]};function eL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}eL.isMDXComponent=!0;const nL={toc:[]};function oL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}oL.isMDXComponent=!0;const pL={toc:[]};function rL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of the transformed references."))}rL.isMDXComponent=!0;const sL={toc:[]};function cL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Maps the references in this group to a new array."))}cL.isMDXComponent=!0;const iL={toc:[]};function aL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to transform each reference."))}aL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting degrees to radians"))}dL.isMDXComponent=!0;const hL={toc:[]};function fL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}fL.isMDXComponent=!0;const kL={toc:[]};function yL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting radians to degrees"))}yL.isMDXComponent=!0;const DL={toc:[]};function ML(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned object is both an array and a reference that can be passed\ndirectly to the ",(0,s.kt)("inlineCode",{parentName:"p"},"ref")," property of a node."))}ML.isMDXComponent=!0;const wL={toc:[]};function _L(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefArray<Txt>();\n\nview.add(['A', 'B'].map(text => <Txt ref={labels}>{text}</Txt>));\nview.add(<Txt ref={labels}>C</Txt>);\n\n// accessing the references individually:\nyield* labels[0].text('A changes', 0.3);\nyield* labels[1].text('B changes', 0.3);\nyield* labels[2].text('C changes', 0.3);\n\n// accessing all references at once:\nyield* all(...labels.map(label => label.fill('white', 0.3)));\n")))}_L.isMDXComponent=!0;const XL={toc:[]};function gL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array of references."))}gL.isMDXComponent=!0;const TL={toc:[]};function CL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned object lets you easily create multiple references to the same\ntype without initializing them individually."),(0,s.kt)("p",null,"You can retrieve references by accessing the object's properties. If the\nreference for a given property does not exist, it will be created\nautomatically."))}CL.isMDXComponent=!0;const xL={toc:[]};function vL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefMap<Txt>();\n\nview.add(\n  <>\n    <Txt ref={labels.a}>A</Txt>\n    <Txt ref={labels.b}>B</Txt>\n    <Txt ref={labels.c}>C</Txt>\n  </>,\n);\n\n// accessing the references individually:\nyield* labels.a().text('A changes', 0.3);\nyield* labels.b().text('B changes', 0.3);\nyield* labels.c().text('C changes', 0.3);\n\n// checking if the given reference exists:\nif ('d' in labels) {\n  yield* labels.d().text('D changes', 0.3);\n}\n\n// accessing all references at once:\nyield* all(...labels.mapRefs(label => label.fill('white', 0.3)));\n")))}vL.isMDXComponent=!0;const LL={toc:[]};function ZL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a group of references."))}ZL.isMDXComponent=!0;const bL={toc:[]};function NL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is a shortcut for calling ",(0,s.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}NL.isMDXComponent=!0;const zL={toc:[]};function AL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}AL.isMDXComponent=!0;const WL={toc:[]};function IL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Logs a debug message with an arbitrary payload."))}IL.isMDXComponent=!0;const RL={toc:[]};function PL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The payload to log"))}PL.isMDXComponent=!0;const SL={toc:[]};function OL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the given function as deprecated."))}OL.isMDXComponent=!0;const EL={toc:[]};function BL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to deprecate."))}BL.isMDXComponent=!0;const GL={toc:[]};function UL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log message."))}UL.isMDXComponent=!0;const FL={toc:[]};function VL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The optional log remarks."))}VL.isMDXComponent=!0;const qL={toc:[]};function jL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}jL.isMDXComponent=!0;const HL={toc:[]};function QL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the current scene as ready to transition out."))}QL.isMDXComponent=!0;const YL={toc:[]};function $L(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}$L.isMDXComponent=!0;const KL={toc:[]};function JL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}JL.isMDXComponent=!0;const tZ={toc:[]};function eZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}eZ.isMDXComponent=!0;const nZ={toc:[]};function oZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function rZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The length of the array."))}rZ.isMDXComponent=!0;const sZ={toc:[]};function cZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}cZ.isMDXComponent=!0;const iZ={toc:[]};function aZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}aZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function fZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}fZ.isMDXComponent=!0;const kZ={toc:[]};function yZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}yZ.isMDXComponent=!0;const DZ={toc:[]};function MZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}MZ.isMDXComponent=!0;const wZ={toc:[]};function _Z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}_Z.isMDXComponent=!0;const XZ={toc:[]};function gZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to increment or decrement."))}gZ.isMDXComponent=!0;const TZ={toc:[]};function CZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}CZ.isMDXComponent=!0;const xZ={toc:[]};function vZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context before render."))}vZ.isMDXComponent=!0;const LZ={toc:[]};function ZZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}ZZ.isMDXComponent=!0;const bZ={toc:[]};function NZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context after render."))}NZ.isMDXComponent=!0;const zZ={toc:[]};function AZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}AZ.isMDXComponent=!0;const WZ={toc:[]};function IZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}IZ.isMDXComponent=!0;const RZ={toc:[]};function PZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the event in seconds."))}PZ.isMDXComponent=!0;const SZ={toc:[]};function OZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Register a time event and get its duration in seconds."))}OZ.isMDXComponent=!0;const EZ={toc:[]};function BZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the event."))}BZ.isMDXComponent=!0;const GZ={toc:[]};function UZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the playback status."))}UZ.isMDXComponent=!0;const FZ={toc:[]};function VZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the current scene."))}VZ.isMDXComponent=!0;const qZ={toc:[]};function jZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the given seed."))}jZ.isMDXComponent=!0;const HZ={toc:[]};function QZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seed for the generator."))}QZ.isMDXComponent=!0;const YZ={toc:[]};function $Z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}$Z.isMDXComponent=!0;const KZ={toc:[]};function JZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current scene."))}JZ.isMDXComponent=!0;const tb={toc:[]};function eb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current thread."))}eb.isMDXComponent=!0;const nb={toc:[]};function ob(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}ob.isMDXComponent=!0;const pb={toc:[]};function rb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}rb.isMDXComponent=!0;const sb={toc:[]};function cb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real time since the start of the animation."))}cb.isMDXComponent=!0;const ib={toc:[]};function ab(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ib,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This rewrites a remote url like ",(0,s.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}ab.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Route the given url through a local proxy."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}db.isMDXComponent=!0;const hb={toc:[]};function fb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}fb.isMDXComponent=!0;const kb={toc:[]};function yb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}yb.isMDXComponent=!0;const Db={toc:[]};function Mb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Db,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Mb.isMDXComponent=!0;const wb={toc:[]};function _b(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}_b.isMDXComponent=!0;const Xb={toc:[]};function gb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}gb.isMDXComponent=!0;const Tb={toc:[]};function Cb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Cb.isMDXComponent=!0;const xb={toc:[]};function vb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}vb.isMDXComponent=!0;const Lb={toc:[]};function Zb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Zb.isMDXComponent=!0;const bb={toc:[]};function Nb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Nb.isMDXComponent=!0;const zb={toc:[]};function Ab(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Ab.isMDXComponent=!0;const Wb={toc:[]};function Ib(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Ib.isMDXComponent=!0;const Rb={toc:[]};function Pb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Pb.isMDXComponent=!0;const Sb={toc:[]};function Ob(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ob.isMDXComponent=!0;const Eb={toc:[]};function Bb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Bb.isMDXComponent=!0;const Gb={toc:[]};function Ub(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Ub.isMDXComponent=!0;const Fb={toc:[]};function Vb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Vb.isMDXComponent=!0;const qb={toc:[]};function jb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}jb.isMDXComponent=!0;const Hb={toc:[]};function Qb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Qb.isMDXComponent=!0;const Yb={toc:[]};function $b(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}$b.isMDXComponent=!0;const Kb={toc:[]};function Jb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Jb.isMDXComponent=!0;const tN={toc:[]};function eN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}eN.isMDXComponent=!0;const nN={toc:[]};function oN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}oN.isMDXComponent=!0;const pN={toc:[]};function rN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}rN.isMDXComponent=!0;const sN={toc:[]};function cN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}cN.isMDXComponent=!0;const iN={toc:[]};function aN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}aN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}dN.isMDXComponent=!0;const hN={toc:[]};function fN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}fN.isMDXComponent=!0;const kN={toc:[]};function yN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}yN.isMDXComponent=!0;const DN={toc:[]};function MN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}MN.isMDXComponent=!0;const wN={toc:[]};function _N(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}_N.isMDXComponent=!0;const XN={toc:[]};function gN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}gN.isMDXComponent=!0;const TN={toc:[]};function CN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}CN.isMDXComponent=!0;const xN={toc:[]};function vN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}vN.isMDXComponent=!0;const LN={toc:[]};function ZN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ZN.isMDXComponent=!0;const bN={toc:[]};function NN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}NN.isMDXComponent=!0;const zN={toc:[]};function AN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}AN.isMDXComponent=!0;const WN={toc:[]};function IN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}IN.isMDXComponent=!0;const RN={toc:[]};function PN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}PN.isMDXComponent=!0;const SN={toc:[]};function ON(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ON.isMDXComponent=!0;const EN={toc:[]};function BN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}BN.isMDXComponent=!0;const GN={toc:[]};function UN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}UN.isMDXComponent=!0;const FN={toc:[]};function VN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}VN.isMDXComponent=!0;const qN={toc:[]};function jN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}jN.isMDXComponent=!0;const HN={toc:[]};function QN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}QN.isMDXComponent=!0;const YN={toc:[]};function $N(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}$N.isMDXComponent=!0;const KN={toc:[]};function JN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}JN.isMDXComponent=!0;const tz={toc:[]};function ez(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}ez.isMDXComponent=!0;const nz={toc:[]};function oz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}oz.isMDXComponent=!0;const pz={toc:[]};function rz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}rz.isMDXComponent=!0;const sz={toc:[]};function cz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}cz.isMDXComponent=!0;const iz={toc:[]};function az(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}az.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}dz.isMDXComponent=!0;const hz={toc:[]};function fz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}fz.isMDXComponent=!0;const kz={toc:[]};function yz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}yz.isMDXComponent=!0;const Dz={toc:[]};function Mz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Mz.isMDXComponent=!0;const wz={toc:[]};function _z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}_z.isMDXComponent=!0;const Xz={toc:[]};function gz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}gz.isMDXComponent=!0;const Tz={toc:[]};function Cz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Cz.isMDXComponent=!0;const xz={toc:[]};function vz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}vz.isMDXComponent=!0;const Lz={toc:[]};function Zz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Zz.isMDXComponent=!0;const bz={toc:[]};function Nz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Nz.isMDXComponent=!0;const zz={toc:[]};function Az(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Az.isMDXComponent=!0;const Wz={toc:[]};function Iz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Iz.isMDXComponent=!0;const Rz={toc:[]};function Pz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Pz.isMDXComponent=!0;const Sz={toc:[]};function Oz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Oz.isMDXComponent=!0;const Ez={toc:[]};function Bz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ez,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Bz.isMDXComponent=!0;const Gz={toc:[]};function Uz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Uz.isMDXComponent=!0;const Fz={toc:[]};function Vz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Vz.isMDXComponent=!0;const qz={toc:[]};function jz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}jz.isMDXComponent=!0;const Hz={toc:[]};function Qz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Qz.isMDXComponent=!0;const Yz={toc:[]};function $z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}$z.isMDXComponent=!0;const Kz={toc:[]};function Jz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Jz.isMDXComponent=!0;const tA={toc:[]};function eA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}eA.isMDXComponent=!0;const nA={toc:[]};function oA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}oA.isMDXComponent=!0;const pA={toc:[]};function rA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}rA.isMDXComponent=!0;const sA={toc:[]};function cA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cA.isMDXComponent=!0;const iA={toc:[]};function aA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}aA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}dA.isMDXComponent=!0;const hA={toc:[]};function fA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}fA.isMDXComponent=!0;const kA={toc:[]};function yA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}yA.isMDXComponent=!0;const DA={toc:[]};function MA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}MA.isMDXComponent=!0;const wA={toc:[]};function _A(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}_A.isMDXComponent=!0;const XA={toc:[]};function gA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}gA.isMDXComponent=!0;const TA={toc:[]};function CA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}CA.isMDXComponent=!0;const xA={toc:[]};function vA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}vA.isMDXComponent=!0;const LA={toc:[]};function ZA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}ZA.isMDXComponent=!0;const bA={toc:[]};function NA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}NA.isMDXComponent=!0;const zA={toc:[]};function AA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}AA.isMDXComponent=!0;const WA={toc:[]};function IA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}IA.isMDXComponent=!0;const RA={toc:[]};function PA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}PA.isMDXComponent=!0;const SA={toc:[]};function OA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}OA.isMDXComponent=!0;const EA={toc:[]};function BA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}BA.isMDXComponent=!0;const GA={toc:[]};function UA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}UA.isMDXComponent=!0;const FA={toc:[]};function VA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}VA.isMDXComponent=!0;const qA={toc:[]};function jA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}jA.isMDXComponent=!0;const HA={toc:[]};function QA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}QA.isMDXComponent=!0;const YA={toc:[]};function $A(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}$A.isMDXComponent=!0;const KA={toc:[]};function JA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}JA.isMDXComponent=!0;const tW={toc:[]};function eW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}eW.isMDXComponent=!0;const nW={toc:[]};function oW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}oW.isMDXComponent=!0;const pW={toc:[]};function rW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}rW.isMDXComponent=!0;const sW={toc:[]};function cW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}cW.isMDXComponent=!0;const iW={toc:[]};function aW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}aW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}dW.isMDXComponent=!0;const hW={toc:[]};function fW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}fW.isMDXComponent=!0;const kW={toc:[]};function yW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}yW.isMDXComponent=!0;const DW={toc:[]};function MW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}MW.isMDXComponent=!0;const wW={toc:[]};function _W(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}_W.isMDXComponent=!0;const XW={toc:[]};function gW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}gW.isMDXComponent=!0;const TW={toc:[]};function CW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}CW.isMDXComponent=!0;const xW={toc:[]};function vW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}vW.isMDXComponent=!0;const LW={toc:[]};function ZW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}ZW.isMDXComponent=!0;const bW={toc:[]};function NW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}NW.isMDXComponent=!0;const zW={toc:[]};function AW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}AW.isMDXComponent=!0;const WW={toc:[]};function IW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}IW.isMDXComponent=!0;const RW={toc:[]};function PW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}PW.isMDXComponent=!0;const SW={toc:[]};function OW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}OW.isMDXComponent=!0;const EW={toc:[]};function BW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}BW.isMDXComponent=!0;const GW={toc:[]};function UW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}UW.isMDXComponent=!0;const FW={toc:[]};function VW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}VW.isMDXComponent=!0;const qW={toc:[]};function jW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}jW.isMDXComponent=!0;const HW={toc:[]};function QW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}QW.isMDXComponent=!0;const YW={toc:[]};function $W(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}$W.isMDXComponent=!0;const KW={toc:[]};function JW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}JW.isMDXComponent=!0;const tI={toc:[]};function eI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}eI.isMDXComponent=!0;const nI={toc:[]};function oI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}oI.isMDXComponent=!0;const pI={toc:[]};function rI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}rI.isMDXComponent=!0;const sI={toc:[]};function cI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}cI.isMDXComponent=!0;const iI={toc:[]};function aI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}aI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dI.isMDXComponent=!0;const hI={toc:[]};function fI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}fI.isMDXComponent=!0;const kI={toc:[]};function yI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}yI.isMDXComponent=!0;const DI={toc:[]};function MI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}MI.isMDXComponent=!0;const wI={toc:[]};function _I(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}_I.isMDXComponent=!0;const XI={toc:[]};function gI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}gI.isMDXComponent=!0;const TI={toc:[]};function CI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}CI.isMDXComponent=!0;const xI={toc:[]};function vI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}vI.isMDXComponent=!0;const LI={toc:[]};function ZI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}ZI.isMDXComponent=!0;const bI={toc:[]};function NI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}NI.isMDXComponent=!0;const zI={toc:[]};function AI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}AI.isMDXComponent=!0;const WI={toc:[]};function II(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}II.isMDXComponent=!0;const RI={toc:[]};function PI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}PI.isMDXComponent=!0;const SI={toc:[]};function OI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}OI.isMDXComponent=!0;const EI={toc:[]};function BI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}BI.isMDXComponent=!0;const GI={toc:[]};function UI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}UI.isMDXComponent=!0;const FI={toc:[]};function VI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}VI.isMDXComponent=!0;const qI={toc:[]};function jI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}jI.isMDXComponent=!0;const HI={toc:[]};function QI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}QI.isMDXComponent=!0;const YI={toc:[]};function $I(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}$I.isMDXComponent=!0;const KI={toc:[]};function JI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}JI.isMDXComponent=!0;const tR={toc:[]};function eR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}eR.isMDXComponent=!0;const nR={toc:[]};function oR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}oR.isMDXComponent=!0;const pR={toc:[]};function rR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}rR.isMDXComponent=!0;const sR={toc:[]};function cR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}cR.isMDXComponent=!0;const iR={toc:[]};function aR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}aR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}dR.isMDXComponent=!0;const hR={toc:[]};function fR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}fR.isMDXComponent=!0;const kR={toc:[]};function yR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}yR.isMDXComponent=!0;const DR={toc:[]};function MR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}MR.isMDXComponent=!0;const wR={toc:[]};function _R(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}_R.isMDXComponent=!0;const XR={toc:[]};function gR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}gR.isMDXComponent=!0;const TR={toc:[]};function CR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}CR.isMDXComponent=!0;const xR={toc:[]};function vR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}vR.isMDXComponent=!0;const LR={toc:[]};function ZR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}ZR.isMDXComponent=!0;const bR={toc:[]};function NR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}NR.isMDXComponent=!0;const zR={toc:[]};function AR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n\n// snippet Curve properties:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {all, createRef, easeInCubic, easeOutCubic} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      endAngle={270}\n      endArrow\n    />,\n  );\n\n  yield* all(ref().start(1, 1), ref().rotation(180, 1, easeInCubic));\n  ref().start(0).end(0);\n  yield* all(ref().end(1, 1), ref().rotation(360, 1, easeOutCubic));\n});\n")))}AR.isMDXComponent=!0;const WR={toc:[]};function IR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing circular shapes."))}IR.isMDXComponent=!0;const RR={toc:[]};function PR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}PR.isMDXComponent=!0;const SR={toc:[]};function OR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}OR.isMDXComponent=!0;const ER={toc:[]};function BR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ER,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}BR.isMDXComponent=!0;const GR={toc:[]};function UR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}UR.isMDXComponent=!0;const FR={toc:[]};function VR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}VR.isMDXComponent=!0;const qR={toc:[]};function jR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}jR.isMDXComponent=!0;const HR={toc:[]};function QR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}QR.isMDXComponent=!0;const YR={toc:[]};function $R(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}$R.isMDXComponent=!0;const KR={toc:[]};function JR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}JR.isMDXComponent=!0;const tP={toc:[]};function eP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}eP.isMDXComponent=!0;const nP={toc:[]};function oP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}oP.isMDXComponent=!0;const pP={toc:[]};function rP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}rP.isMDXComponent=!0;const sP={toc:[]};function cP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}cP.isMDXComponent=!0;const iP={toc:[]};function aP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}aP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A closed circle will look like a pie chart:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.kt)("p",null,"An open one will look like an arc:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}dP.isMDXComponent=!0;const hP={toc:[]};function fP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"false"))}fP.isMDXComponent=!0;const kP={toc:[]};function yP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}yP.isMDXComponent=!0;const DP={toc:[]};function MP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the circle begins at ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}MP.isMDXComponent=!0;const wP={toc:[]};function _P(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the circle sector should be drawn counterclockwise."))}_P.isMDXComponent=!0;const XP={toc:[]};function gP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}gP.isMDXComponent=!0;const TP={toc:[]};function CP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}CP.isMDXComponent=!0;const xP={toc:[]};function vP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}vP.isMDXComponent=!0;const LP={toc:[]};function ZP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"360"))}ZP.isMDXComponent=!0;const bP={toc:[]};function NP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}NP.isMDXComponent=!0;const zP={toc:[]};function AP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}AP.isMDXComponent=!0;const WP={toc:[]};function IP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}IP.isMDXComponent=!0;const RP={toc:[]};function PP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}PP.isMDXComponent=!0;const SP={toc:[]};function OP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}OP.isMDXComponent=!0;const EP={toc:[]};function BP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}BP.isMDXComponent=!0;const GP={toc:[]};function UP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}UP.isMDXComponent=!0;const FP={toc:[]};function VP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}VP.isMDXComponent=!0;const qP={toc:[]};function jP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}jP.isMDXComponent=!0;const HP={toc:[]};function QP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}QP.isMDXComponent=!0;const YP={toc:[]};function $P(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}$P.isMDXComponent=!0;const KP={toc:[]};function JP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}JP.isMDXComponent=!0;const tS={toc:[]};function eS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}eS.isMDXComponent=!0;const nS={toc:[]};function oS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}oS.isMDXComponent=!0;const pS={toc:[]};function rS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}rS.isMDXComponent=!0;const sS={toc:[]};function cS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}cS.isMDXComponent=!0;const iS={toc:[]};function aS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}aS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}dS.isMDXComponent=!0;const hS={toc:[]};function fS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}fS.isMDXComponent=!0;const kS={toc:[]};function yS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}yS.isMDXComponent=!0;const DS={toc:[]};function MS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}MS.isMDXComponent=!0;const wS={toc:[]};function _S(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}_S.isMDXComponent=!0;const XS={toc:[]};function gS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}gS.isMDXComponent=!0;const TS={toc:[]};function CS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}CS.isMDXComponent=!0;const xS={toc:[]};function vS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}vS.isMDXComponent=!0;const LS={toc:[]};function ZS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ZS.isMDXComponent=!0;const bS={toc:[]};function NS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}NS.isMDXComponent=!0;const zS={toc:[]};function AS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}AS.isMDXComponent=!0;const WS={toc:[]};function IS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}IS.isMDXComponent=!0;const RS={toc:[]};function PS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}PS.isMDXComponent=!0;const SS={toc:[]};function OS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}OS.isMDXComponent=!0;const ES={toc:[]};function BS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ES,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}BS.isMDXComponent=!0;const GS={toc:[]};function US(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}US.isMDXComponent=!0;const FS={toc:[]};function VS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}VS.isMDXComponent=!0;const qS={toc:[]};function jS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}jS.isMDXComponent=!0;const HS={toc:[]};function QS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}QS.isMDXComponent=!0;const YS={toc:[]};function $S(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}$S.isMDXComponent=!0;const KS={toc:[]};function JS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}JS.isMDXComponent=!0;const tO={toc:[]};function eO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}eO.isMDXComponent=!0;const nO={toc:[]};function oO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}oO.isMDXComponent=!0;const pO={toc:[]};function rO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}rO.isMDXComponent=!0;const sO={toc:[]};function cO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}cO.isMDXComponent=!0;const iO={toc:[]};function aO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}aO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}dO.isMDXComponent=!0;const hO={toc:[]};function fO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}fO.isMDXComponent=!0;const kO={toc:[]};function yO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}yO.isMDXComponent=!0;const DO={toc:[]};function MO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}MO.isMDXComponent=!0;const wO={toc:[]};function _O(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}_O.isMDXComponent=!0;const XO={toc:[]};function gO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}gO.isMDXComponent=!0;const TO={toc:[]};function CO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}CO.isMDXComponent=!0;const xO={toc:[]};function vO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}vO.isMDXComponent=!0;const LO={toc:[]};function ZO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}ZO.isMDXComponent=!0;const bO={toc:[]};function NO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}NO.isMDXComponent=!0;const zO={toc:[]};function AO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}AO.isMDXComponent=!0;const WO={toc:[]};function IO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}IO.isMDXComponent=!0;const RO={toc:[]};function PO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}PO.isMDXComponent=!0;const SO={toc:[]};function OO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}OO.isMDXComponent=!0;const EO={toc:[]};function BO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}BO.isMDXComponent=!0;const GO={toc:[]};function UO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}UO.isMDXComponent=!0;const FO={toc:[]};function VO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}VO.isMDXComponent=!0;const qO={toc:[]};function jO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}jO.isMDXComponent=!0;const HO={toc:[]};function QO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}QO.isMDXComponent=!0;const YO={toc:[]};function $O(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$O.isMDXComponent=!0;const KO={toc:[]};function JO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}JO.isMDXComponent=!0;const tE={toc:[]};function eE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}eE.isMDXComponent=!0;const nE={toc:[]};function oE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}oE.isMDXComponent=!0;const pE={toc:[]};function rE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}rE.isMDXComponent=!0;const sE={toc:[]};function cE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}cE.isMDXComponent=!0;const iE={toc:[]};function aE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}aE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}dE.isMDXComponent=!0;const hE={toc:[]};function fE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}fE.isMDXComponent=!0;const kE={toc:[]};function yE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}yE.isMDXComponent=!0;const DE={toc:[]};function ME(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}ME.isMDXComponent=!0;const wE={toc:[]};function _E(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}_E.isMDXComponent=!0;const XE={toc:[]};function gE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}gE.isMDXComponent=!0;const TE={toc:[]};function CE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}CE.isMDXComponent=!0;const xE={toc:[]};function vE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}vE.isMDXComponent=!0;const LE={toc:[]};function ZE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}ZE.isMDXComponent=!0;const bE={toc:[]};function NE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}NE.isMDXComponent=!0;const zE={toc:[]};function AE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}AE.isMDXComponent=!0;const WE={toc:[]};function IE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}IE.isMDXComponent=!0;const RE={toc:[]};function PE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}PE.isMDXComponent=!0;const SE={toc:[]};function OE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}OE.isMDXComponent=!0;const EE={toc:[]};function BE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}BE.isMDXComponent=!0;const GE={toc:[]};function UE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}UE.isMDXComponent=!0;const FE={toc:[]};function VE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}VE.isMDXComponent=!0;const qE={toc:[]};function jE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}jE.isMDXComponent=!0;const HE={toc:[]};function QE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}QE.isMDXComponent=!0;const YE={toc:[]};function $E(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}$E.isMDXComponent=!0;const KE={toc:[]};function JE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}JE.isMDXComponent=!0;const tB={toc:[]};function eB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}eB.isMDXComponent=!0;const nB={toc:[]};function oB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}oB.isMDXComponent=!0;const pB={toc:[]};function rB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}rB.isMDXComponent=!0;const sB={toc:[]};function cB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}cB.isMDXComponent=!0;const iB={toc:[]};function aB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}aB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}dB.isMDXComponent=!0;const hB={toc:[]};function fB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}fB.isMDXComponent=!0;const kB={toc:[]};function yB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}yB.isMDXComponent=!0;const DB={toc:[]};function MB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}MB.isMDXComponent=!0;const wB={toc:[]};function _B(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}_B.isMDXComponent=!0;const XB={toc:[]};function gB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}gB.isMDXComponent=!0;const TB={toc:[]};function CB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}CB.isMDXComponent=!0;const xB={toc:[]};function vB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}vB.isMDXComponent=!0;const LB={toc:[]};function ZB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}ZB.isMDXComponent=!0;const bB={toc:[]};function NB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}NB.isMDXComponent=!0;const zB={toc:[]};function AB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}AB.isMDXComponent=!0;const WB={toc:[]};function IB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}IB.isMDXComponent=!0;const RB={toc:[]};function PB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}PB.isMDXComponent=!0;const SB={toc:[]};function OB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}OB.isMDXComponent=!0;const EB={toc:[]};function BB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}BB.isMDXComponent=!0;const GB={toc:[]};function UB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}UB.isMDXComponent=!0;const FB={toc:[]};function VB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}VB.isMDXComponent=!0;const qB={toc:[]};function jB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}jB.isMDXComponent=!0;const HB={toc:[]};function QB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}QB.isMDXComponent=!0;const YB={toc:[]};function $B(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}$B.isMDXComponent=!0;const KB={toc:[]};function JB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}JB.isMDXComponent=!0;const tG={toc:[]};function eG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}eG.isMDXComponent=!0;const nG={toc:[]};function oG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}oG.isMDXComponent=!0;const pG={toc:[]};function rG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}rG.isMDXComponent=!0;const sG={toc:[]};function cG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}cG.isMDXComponent=!0;const iG={toc:[]};function aG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}aG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}dG.isMDXComponent=!0;const hG={toc:[]};function fG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}fG.isMDXComponent=!0;const kG={toc:[]};function yG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}yG.isMDXComponent=!0;const DG={toc:[]};function MG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}MG.isMDXComponent=!0;const wG={toc:[]};function _G(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}_G.isMDXComponent=!0;const XG={toc:[]};function gG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}gG.isMDXComponent=!0;const TG={toc:[]};function CG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}CG.isMDXComponent=!0;const xG={toc:[]};function vG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}vG.isMDXComponent=!0;const LG={toc:[]};function ZG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}ZG.isMDXComponent=!0;const bG={toc:[]};function NG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}NG.isMDXComponent=!0;const zG={toc:[]};function AG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}AG.isMDXComponent=!0;const WG={toc:[]};function IG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}IG.isMDXComponent=!0;const RG={toc:[]};function PG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}PG.isMDXComponent=!0;const SG={toc:[]};function OG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}OG.isMDXComponent=!0;const EG={toc:[]};function BG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}BG.isMDXComponent=!0;const GG={toc:[]};function UG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}UG.isMDXComponent=!0;const FG={toc:[]};function VG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}VG.isMDXComponent=!0;const qG={toc:[]};function jG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}jG.isMDXComponent=!0;const HG={toc:[]};function QG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}QG.isMDXComponent=!0;const YG={toc:[]};function $G(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}$G.isMDXComponent=!0;const KG={toc:[]};function JG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}JG.isMDXComponent=!0;const tU={toc:[]};function eU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}eU.isMDXComponent=!0;const nU={toc:[]};function oU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}oU.isMDXComponent=!0;const pU={toc:[]};function rU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}rU.isMDXComponent=!0;const sU={toc:[]};function cU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}cU.isMDXComponent=!0;const iU={toc:[]};function aU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}aU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}dU.isMDXComponent=!0;const hU={toc:[]};function fU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}fU.isMDXComponent=!0;const kU={toc:[]};function yU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}yU.isMDXComponent=!0;const DU={toc:[]};function MU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}MU.isMDXComponent=!0;const wU={toc:[]};function _U(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, CubicBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  view.add(\n    <CubicBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, -100]}\n      p1={[100, -100]}\n      p2={[-100, 100]}\n      p3={[200, 100]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}_U.isMDXComponent=!0;const XU={toc:[]};function gU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a cubic B\xe9zier curve."))}gU.isMDXComponent=!0;const TU={toc:[]};function CU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}CU.isMDXComponent=!0;const xU={toc:[]};function vU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}vU.isMDXComponent=!0;const LU={toc:[]};function ZU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ZU.isMDXComponent=!0;const bU={toc:[]};function NU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}NU.isMDXComponent=!0;const zU={toc:[]};function AU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}AU.isMDXComponent=!0;const WU={toc:[]};function IU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}IU.isMDXComponent=!0;const RU={toc:[]};function PU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}PU.isMDXComponent=!0;const SU={toc:[]};function OU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}OU.isMDXComponent=!0;const EU={toc:[]};function BU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}BU.isMDXComponent=!0;const GU={toc:[]};function UU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}UU.isMDXComponent=!0;const FU={toc:[]};function VU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}VU.isMDXComponent=!0;const qU={toc:[]};function jU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}jU.isMDXComponent=!0;const HU={toc:[]};function QU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}QU.isMDXComponent=!0;const YU={toc:[]};function $U(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}$U.isMDXComponent=!0;const KU={toc:[]};function JU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}JU.isMDXComponent=!0;const tF={toc:[]};function eF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}eF.isMDXComponent=!0;const nF={toc:[]};function oF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}oF.isMDXComponent=!0;const pF={toc:[]};function rF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}rF.isMDXComponent=!0;const sF={toc:[]};function cF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cF.isMDXComponent=!0;const iF={toc:[]};function aF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}aF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}dF.isMDXComponent=!0;const hF={toc:[]};function fF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}fF.isMDXComponent=!0;const kF={toc:[]};function yF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}yF.isMDXComponent=!0;const DF={toc:[]};function MF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}MF.isMDXComponent=!0;const wF={toc:[]};function _F(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}_F.isMDXComponent=!0;const XF={toc:[]};function gF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}gF.isMDXComponent=!0;const TF={toc:[]};function CF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}CF.isMDXComponent=!0;const xF={toc:[]};function vF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}vF.isMDXComponent=!0;const LF={toc:[]};function ZF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The first control point of the B\xe9zier curve."))}ZF.isMDXComponent=!0;const bF={toc:[]};function NF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The second control point of the B\xe9zier curve."))}NF.isMDXComponent=!0;const zF={toc:[]};function AF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}AF.isMDXComponent=!0;const WF={toc:[]};function IF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}IF.isMDXComponent=!0;const RF={toc:[]};function PF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}PF.isMDXComponent=!0;const SF={toc:[]};function OF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}OF.isMDXComponent=!0;const EF={toc:[]};function BF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}BF.isMDXComponent=!0;const GF={toc:[]};function UF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}UF.isMDXComponent=!0;const FF={toc:[]};function VF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}VF.isMDXComponent=!0;const qF={toc:[]};function jF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}jF.isMDXComponent=!0;const HF={toc:[]};function QF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}QF.isMDXComponent=!0;const YF={toc:[]};function $F(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}$F.isMDXComponent=!0;const KF={toc:[]};function JF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}JF.isMDXComponent=!0;const tV={toc:[]};function eV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}eV.isMDXComponent=!0;const nV={toc:[]};function oV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}oV.isMDXComponent=!0;const pV={toc:[]};function rV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}rV.isMDXComponent=!0;const sV={toc:[]};function cV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}cV.isMDXComponent=!0;const iV={toc:[]};function aV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}aV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}dV.isMDXComponent=!0;const hV={toc:[]};function fV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}fV.isMDXComponent=!0;const kV={toc:[]};function yV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}yV.isMDXComponent=!0;const DV={toc:[]};function MV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}MV.isMDXComponent=!0;const wV={toc:[]};function _V(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}_V.isMDXComponent=!0;const XV={toc:[]};function gV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}gV.isMDXComponent=!0;const TV={toc:[]};function CV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}CV.isMDXComponent=!0;const xV={toc:[]};function vV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}vV.isMDXComponent=!0;const LV={toc:[]};function ZV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}ZV.isMDXComponent=!0;const bV={toc:[]};function NV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}NV.isMDXComponent=!0;const zV={toc:[]};function AV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}AV.isMDXComponent=!0;const WV={toc:[]};function IV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}IV.isMDXComponent=!0;const RV={toc:[]};function PV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}PV.isMDXComponent=!0;const SV={toc:[]};function OV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}OV.isMDXComponent=!0;const EV={toc:[]};function BV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}BV.isMDXComponent=!0;const GV={toc:[]};function UV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}UV.isMDXComponent=!0;const FV={toc:[]};function VV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}VV.isMDXComponent=!0;const qV={toc:[]};function jV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}jV.isMDXComponent=!0;const HV={toc:[]};function QV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}QV.isMDXComponent=!0;const YV={toc:[]};function $V(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}$V.isMDXComponent=!0;const KV={toc:[]};function JV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}JV.isMDXComponent=!0;const tq={toc:[]};function eq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}eq.isMDXComponent=!0;const nq={toc:[]};function oq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}oq.isMDXComponent=!0;const pq={toc:[]};function rq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}rq.isMDXComponent=!0;const sq={toc:[]};function cq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}cq.isMDXComponent=!0;const iq={toc:[]};function aq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}aq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}dq.isMDXComponent=!0;const hq={toc:[]};function fq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}fq.isMDXComponent=!0;const kq={toc:[]};function yq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}yq.isMDXComponent=!0;const Dq={toc:[]};function Mq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Mq.isMDXComponent=!0;const wq={toc:[]};function _q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}_q.isMDXComponent=!0;const Xq={toc:[]};function gq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}gq.isMDXComponent=!0;const Tq={toc:[]};function Cq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Cq.isMDXComponent=!0;const xq={toc:[]};function vq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}vq.isMDXComponent=!0;const Lq={toc:[]};function Zq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Zq.isMDXComponent=!0;const bq={toc:[]};function Nq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Nq.isMDXComponent=!0;const zq={toc:[]};function Aq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Aq.isMDXComponent=!0;const Wq={toc:[]};function Iq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Iq.isMDXComponent=!0;const Rq={toc:[]};function Pq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Pq.isMDXComponent=!0;const Sq={toc:[]};function Oq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Oq.isMDXComponent=!0;const Eq={toc:[]};function Bq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Bq.isMDXComponent=!0;const Gq={toc:[]};function Uq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Uq.isMDXComponent=!0;const Fq={toc:[]};function Vq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Vq.isMDXComponent=!0;const qq={toc:[]};function jq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}jq.isMDXComponent=!0;const Hq={toc:[]};function Qq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Qq.isMDXComponent=!0;const Yq={toc:[]};function $q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}$q.isMDXComponent=!0;const Kq={toc:[]};function Jq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Jq.isMDXComponent=!0;const tj={toc:[]};function ej(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}ej.isMDXComponent=!0;const nj={toc:[]};function oj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}oj.isMDXComponent=!0;const pj={toc:[]};function rj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}rj.isMDXComponent=!0;const sj={toc:[]};function cj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}cj.isMDXComponent=!0;const ij={toc:[]};function aj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ij,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}aj.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}dj.isMDXComponent=!0;const hj={toc:[]};function fj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}fj.isMDXComponent=!0;const kj={toc:[]};function yj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}yj.isMDXComponent=!0;const Dj={toc:[]};function Mj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Mj.isMDXComponent=!0;const wj={toc:[]};function _j(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}_j.isMDXComponent=!0;const Xj={toc:[]};function gj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}gj.isMDXComponent=!0;const Tj={toc:[]};function Cj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Cj.isMDXComponent=!0;const xj={toc:[]};function vj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}vj.isMDXComponent=!0;const Lj={toc:[]};function Zj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Zj.isMDXComponent=!0;const bj={toc:[]};function Nj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Nj.isMDXComponent=!0;const zj={toc:[]};function Aj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Aj.isMDXComponent=!0;const Wj={toc:[]};function Ij(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Ij.isMDXComponent=!0;const Rj={toc:[]};function Pj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Pj.isMDXComponent=!0;const Sj={toc:[]};function Oj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Oj.isMDXComponent=!0;const Ej={toc:[]};function Bj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ej,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Bj.isMDXComponent=!0;const Gj={toc:[]};function Uj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Uj.isMDXComponent=!0;const Fj={toc:[]};function Vj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Vj.isMDXComponent=!0;const qj={toc:[]};function jj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}jj.isMDXComponent=!0;const Hj={toc:[]};function Qj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Qj.isMDXComponent=!0;const Yj={toc:[]};function $j(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}$j.isMDXComponent=!0;const Kj={toc:[]};function Jj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Jj.isMDXComponent=!0;const tH={toc:[]};function eH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}eH.isMDXComponent=!0;const nH={toc:[]};function oH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}oH.isMDXComponent=!0;const pH={toc:[]};function rH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}rH.isMDXComponent=!0;const sH={toc:[]};function cH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}cH.isMDXComponent=!0;const iH={toc:[]};function aH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}aH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}dH.isMDXComponent=!0;const hH={toc:[]};function fH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}fH.isMDXComponent=!0;const kH={toc:[]};function yH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}yH.isMDXComponent=!0;const DH={toc:[]};function MH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}MH.isMDXComponent=!0;const wH={toc:[]};function _H(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}_H.isMDXComponent=!0;const XH={toc:[]};function gH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}gH.isMDXComponent=!0;const TH={toc:[]};function CH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}CH.isMDXComponent=!0;const xH={toc:[]};function vH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}vH.isMDXComponent=!0;const LH={toc:[]};function ZH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ZH.isMDXComponent=!0;const bH={toc:[]};function NH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}NH.isMDXComponent=!0;const zH={toc:[]};function AH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}AH.isMDXComponent=!0;const WH={toc:[]};function IH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}IH.isMDXComponent=!0;const RH={toc:[]};function PH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}PH.isMDXComponent=!0;const SH={toc:[]};function OH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}OH.isMDXComponent=!0;const EH={toc:[]};function BH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}BH.isMDXComponent=!0;const GH={toc:[]};function UH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}UH.isMDXComponent=!0;const FH={toc:[]};function VH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}VH.isMDXComponent=!0;const qH={toc:[]};function jH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}jH.isMDXComponent=!0;const HH={toc:[]};function QH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}QH.isMDXComponent=!0;const YH={toc:[]};function $H(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}$H.isMDXComponent=!0;const KH={toc:[]};function JH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}JH.isMDXComponent=!0;const tQ={toc:[]};function eQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}eQ.isMDXComponent=!0;const nQ={toc:[]};function oQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}oQ.isMDXComponent=!0;const pQ={toc:[]};function rQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}rQ.isMDXComponent=!0;const sQ={toc:[]};function cQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cQ.isMDXComponent=!0;const iQ={toc:[]};function aQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}aQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function fQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}fQ.isMDXComponent=!0;const kQ={toc:[]};function yQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}yQ.isMDXComponent=!0;const DQ={toc:[]};function MQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}MQ.isMDXComponent=!0;const wQ={toc:[]};function _Q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}_Q.isMDXComponent=!0;const XQ={toc:[]};function gQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}gQ.isMDXComponent=!0;const TQ={toc:[]};function CQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}CQ.isMDXComponent=!0;const xQ={toc:[]};function vQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}vQ.isMDXComponent=!0;const LQ={toc:[]};function ZQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ZQ.isMDXComponent=!0;const bQ={toc:[]};function NQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}NQ.isMDXComponent=!0;const zQ={toc:[]};function AQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}AQ.isMDXComponent=!0;const WQ={toc:[]};function IQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}IQ.isMDXComponent=!0;const RQ={toc:[]};function PQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}PQ.isMDXComponent=!0;const SQ={toc:[]};function OQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}OQ.isMDXComponent=!0;const EQ={toc:[]};function BQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}BQ.isMDXComponent=!0;const GQ={toc:[]};function UQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}UQ.isMDXComponent=!0;const FQ={toc:[]};function VQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}VQ.isMDXComponent=!0;const qQ={toc:[]};function jQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}jQ.isMDXComponent=!0;const HQ={toc:[]};function QQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}QQ.isMDXComponent=!0;const YQ={toc:[]};function $Q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}$Q.isMDXComponent=!0;const KQ={toc:[]};function JQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}JQ.isMDXComponent=!0;const tY={toc:[]};function eY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}eY.isMDXComponent=!0;const nY={toc:[]};function oY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}oY.isMDXComponent=!0;const pY={toc:[]};function rY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}rY.isMDXComponent=!0;const sY={toc:[]};function cY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}cY.isMDXComponent=!0;const iY={toc:[]};function aY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}aY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}dY.isMDXComponent=!0;const hY={toc:[]};function fY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}fY.isMDXComponent=!0;const kY={toc:[]};function yY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}yY.isMDXComponent=!0;const DY={toc:[]};function MY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}MY.isMDXComponent=!0;const wY={toc:[]};function _Y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}_Y.isMDXComponent=!0;const XY={toc:[]};function gY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}gY.isMDXComponent=!0;const TY={toc:[]};function CY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}CY.isMDXComponent=!0;const xY={toc:[]};function vY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}vY.isMDXComponent=!0;const LY={toc:[]};function ZY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}ZY.isMDXComponent=!0;const bY={toc:[]};function NY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}NY.isMDXComponent=!0;const zY={toc:[]};function AY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}AY.isMDXComponent=!0;const WY={toc:[]};function IY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}IY.isMDXComponent=!0;const RY={toc:[]};function PY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}PY.isMDXComponent=!0;const SY={toc:[]};function OY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}OY.isMDXComponent=!0;const EY={toc:[]};function BY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}BY.isMDXComponent=!0;const GY={toc:[]};function UY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}UY.isMDXComponent=!0;const FY={toc:[]};function VY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}VY.isMDXComponent=!0;const qY={toc:[]};function jY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}jY.isMDXComponent=!0;const HY={toc:[]};function QY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}QY.isMDXComponent=!0;const YY={toc:[]};function $Y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}$Y.isMDXComponent=!0;const KY={toc:[]};function JY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}JY.isMDXComponent=!0;const t$={toc:[]};function e$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}e$.isMDXComponent=!0;const n$={toc:[]};function o$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}o$.isMDXComponent=!0;const p$={toc:[]};function r$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}r$.isMDXComponent=!0;const s$={toc:[]};function c$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}c$.isMDXComponent=!0;const i$={toc:[]};function a$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}a$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}d$.isMDXComponent=!0;const h$={toc:[]};function f$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}f$.isMDXComponent=!0;const k$={toc:[]};function y$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}y$.isMDXComponent=!0;const D$={toc:[]};function M$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}M$.isMDXComponent=!0;const w$={toc:[]};function _$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}_$.isMDXComponent=!0;const X$={toc:[]};function g$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}g$.isMDXComponent=!0;const T$={toc:[]};function C$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}C$.isMDXComponent=!0;const x$={toc:[]};function v$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}v$.isMDXComponent=!0;const L$={toc:[]};function Z$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Z$.isMDXComponent=!0;const b$={toc:[]};function N$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}N$.isMDXComponent=!0;const z$={toc:[]};function A$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}A$.isMDXComponent=!0;const W$={toc:[]};function I$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}I$.isMDXComponent=!0;const R$={toc:[]};function P$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}P$.isMDXComponent=!0;const S$={toc:[]};function O$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}O$.isMDXComponent=!0;const E$={toc:[]};function B$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}B$.isMDXComponent=!0;const G$={toc:[]};function U$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}U$.isMDXComponent=!0;const F$={toc:[]};function V$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}V$.isMDXComponent=!0;const q$={toc:[]};function j$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}j$.isMDXComponent=!0;const H$={toc:[]};function Q$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Q$.isMDXComponent=!0;const Y$={toc:[]};function $$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}$$.isMDXComponent=!0;const K$={toc:[]};function J$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}J$.isMDXComponent=!0;const tK={toc:[]};function eK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}eK.isMDXComponent=!0;const nK={toc:[]};function oK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}oK.isMDXComponent=!0;const pK={toc:[]};function rK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}rK.isMDXComponent=!0;const sK={toc:[]};function cK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}cK.isMDXComponent=!0;const iK={toc:[]};function aK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}aK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}dK.isMDXComponent=!0;const hK={toc:[]};function fK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}fK.isMDXComponent=!0;const kK={toc:[]};function yK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}yK.isMDXComponent=!0;const DK={toc:[]};function MK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}MK.isMDXComponent=!0;const wK={toc:[]};function _K(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}_K.isMDXComponent=!0;const XK={toc:[]};function gK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}gK.isMDXComponent=!0;const TK={toc:[]};function CK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}CK.isMDXComponent=!0;const xK={toc:[]};function vK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}vK.isMDXComponent=!0;const LK={toc:[]};function ZK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}ZK.isMDXComponent=!0;const bK={toc:[]};function NK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}NK.isMDXComponent=!0;const zK={toc:[]};function AK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}AK.isMDXComponent=!0;const WK={toc:[]};function IK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}IK.isMDXComponent=!0;const RK={toc:[]};function PK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}PK.isMDXComponent=!0;const SK={toc:[]};function OK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}OK.isMDXComponent=!0;const EK={toc:[]};function BK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}BK.isMDXComponent=!0;const GK={toc:[]};function UK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}UK.isMDXComponent=!0;const FK={toc:[]};function VK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}VK.isMDXComponent=!0;const qK={toc:[]};function jK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}jK.isMDXComponent=!0;const HK={toc:[]};function QK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}QK.isMDXComponent=!0;const YK={toc:[]};function $K(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$K.isMDXComponent=!0;const KK={toc:[]};function JK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}JK.isMDXComponent=!0;const tJ={toc:[]};function eJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}eJ.isMDXComponent=!0;const nJ={toc:[]};function oJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}oJ.isMDXComponent=!0;const pJ={toc:[]};function rJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}rJ.isMDXComponent=!0;const sJ={toc:[]};function cJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}cJ.isMDXComponent=!0;const iJ={toc:[]};function aJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}aJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function fJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}fJ.isMDXComponent=!0;const kJ={toc:[]};function yJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}yJ.isMDXComponent=!0;const DJ={toc:[]};function MJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}MJ.isMDXComponent=!0;const wJ={toc:[]};function _J(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}_J.isMDXComponent=!0;const XJ={toc:[]};function gJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}gJ.isMDXComponent=!0;const TJ={toc:[]};function CJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}CJ.isMDXComponent=!0;const xJ={toc:[]};function vJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}vJ.isMDXComponent=!0;const LJ={toc:[]};function ZJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ZJ.isMDXComponent=!0;const bJ={toc:[]};function NJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}NJ.isMDXComponent=!0;const zJ={toc:[]};function AJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}AJ.isMDXComponent=!0;const WJ={toc:[]};function IJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}IJ.isMDXComponent=!0;const RJ={toc:[]};function PJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}PJ.isMDXComponent=!0;const SJ={toc:[]};function OJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}OJ.isMDXComponent=!0;const EJ={toc:[]};function BJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}BJ.isMDXComponent=!0;const GJ={toc:[]};function UJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}UJ.isMDXComponent=!0;const FJ={toc:[]};function VJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}VJ.isMDXComponent=!0;const qJ={toc:[]};function jJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}jJ.isMDXComponent=!0;const HJ={toc:[]};function QJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}QJ.isMDXComponent=!0;const YJ={toc:[]};function $J(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}$J.isMDXComponent=!0;const KJ={toc:[]};function JJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}JJ.isMDXComponent=!0;const t0={toc:[]};function e0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}e0.isMDXComponent=!0;const n0={toc:[]};function o0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}o0.isMDXComponent=!0;const p0={toc:[]};function r0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}r0.isMDXComponent=!0;const s0={toc:[]};function c0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}c0.isMDXComponent=!0;const i0={toc:[]};function a0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}a0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}d0.isMDXComponent=!0;const h0={toc:[]};function f0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}f0.isMDXComponent=!0;const k0={toc:[]};function y0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}y0.isMDXComponent=!0;const D0={toc:[]};function M0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}M0.isMDXComponent=!0;const w0={toc:[]};function _0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}_0.isMDXComponent=!0;const X0={toc:[]};function g0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}g0.isMDXComponent=!0;const T0={toc:[]};function C0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}C0.isMDXComponent=!0;const x0={toc:[]};function v0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}v0.isMDXComponent=!0;const L0={toc:[]};function Z0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Z0.isMDXComponent=!0;const b0={toc:[]};function N0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}N0.isMDXComponent=!0;const z0={toc:[]};function A0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}A0.isMDXComponent=!0;const W0={toc:[]};function I0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}I0.isMDXComponent=!0;const R0={toc:[]};function P0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}P0.isMDXComponent=!0;const S0={toc:[]};function O0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}O0.isMDXComponent=!0;const E0={toc:[]};function B0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}B0.isMDXComponent=!0;const G0={toc:[]};function U0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}U0.isMDXComponent=!0;const F0={toc:[]};function V0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}V0.isMDXComponent=!0;const q0={toc:[]};function j0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}j0.isMDXComponent=!0;const H0={toc:[]};function Q0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Q0.isMDXComponent=!0;const Y0={toc:[]};function $0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}$0.isMDXComponent=!0;const K0={toc:[]};function J0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}J0.isMDXComponent=!0;const t5={toc:[]};function e5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}e5.isMDXComponent=!0;const n5={toc:[]};function o5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}o5.isMDXComponent=!0;const p5={toc:[]};function r5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}r5.isMDXComponent=!0;const s5={toc:[]};function c5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}c5.isMDXComponent=!0;const i5={toc:[]};function a5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}a5.isMDXComponent=!0;const l5={toc:[]};function u5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}u5.isMDXComponent=!0;const m5={toc:[]};function d5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}d5.isMDXComponent=!0;const h5={toc:[]};function f5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}f5.isMDXComponent=!0;const k5={toc:[]};function y5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}y5.isMDXComponent=!0;const D5={toc:[]};function M5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}M5.isMDXComponent=!0;const w5={toc:[]};function _5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}_5.isMDXComponent=!0;const X5={toc:[]};function g5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}g5.isMDXComponent=!0;const T5={toc:[]};function C5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}C5.isMDXComponent=!0;const x5={toc:[]};function v5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}v5.isMDXComponent=!0;const L5={toc:[]};function Z5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Z5.isMDXComponent=!0;const b5={toc:[]};function N5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}N5.isMDXComponent=!0;const z5={toc:[]};function A5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}A5.isMDXComponent=!0;const W5={toc:[]};function I5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}I5.isMDXComponent=!0;const R5={toc:[]};function P5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}P5.isMDXComponent=!0;const S5={toc:[]};function O5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}O5.isMDXComponent=!0;const E5={toc:[]};function B5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}B5.isMDXComponent=!0;const G5={toc:[]};function U5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}U5.isMDXComponent=!0;const F5={toc:[]};function V5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}V5.isMDXComponent=!0;const q5={toc:[]};function j5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}j5.isMDXComponent=!0;const H5={toc:[]};function Q5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Q5.isMDXComponent=!0;const Y5={toc:[]};function $5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}$5.isMDXComponent=!0;const K5={toc:[]};function J5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}J5.isMDXComponent=!0;const t8={toc:[]};function e8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}e8.isMDXComponent=!0;const n8={toc:[]};function o8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}o8.isMDXComponent=!0;const p8={toc:[]};function r8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}r8.isMDXComponent=!0;const s8={toc:[]};function c8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}c8.isMDXComponent=!0;const i8={toc:[]};function a8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}a8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}d8.isMDXComponent=!0;const h8={toc:[]};function f8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Grid, makeScene2D} from '@motion-canvas/2d';\nimport {all, createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const grid = createRef<Grid>();\n\n  view.add(\n    <Grid\n      ref={grid}\n      width={'100%'}\n      height={'100%'}\n      stroke={'#666'}\n      start={0}\n      end={1}\n    />,\n  );\n\n  yield* all(\n    grid().end(0.5, 1).to(1, 1).wait(1),\n    grid().start(0.5, 1).to(0, 1).wait(1),\n  );\n});\n")))}f8.isMDXComponent=!0;const k8={toc:[]};function y8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a two-dimensional grid."))}y8.isMDXComponent=!0;const D8={toc:[]};function M8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}M8.isMDXComponent=!0;const w8={toc:[]};function _8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}_8.isMDXComponent=!0;const X8={toc:[]};function g8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}g8.isMDXComponent=!0;const T8={toc:[]};function C8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}C8.isMDXComponent=!0;const x8={toc:[]};function v8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}v8.isMDXComponent=!0;const L8={toc:[]};function Z8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Z8.isMDXComponent=!0;const b8={toc:[]};function N8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}N8.isMDXComponent=!0;const z8={toc:[]};function A8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}A8.isMDXComponent=!0;const W8={toc:[]};function I8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}I8.isMDXComponent=!0;const R8={toc:[]};function P8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}P8.isMDXComponent=!0;const S8={toc:[]};function O8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}O8.isMDXComponent=!0;const E8={toc:[]};function B8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}B8.isMDXComponent=!0;const G8={toc:[]};function U8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}U8.isMDXComponent=!0;const F8={toc:[]};function V8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the end of each grid line."))}V8.isMDXComponent=!0;const q8={toc:[]};function j8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}j8.isMDXComponent=!0;const H8={toc:[]};function Q8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Q8.isMDXComponent=!0;const Y8={toc:[]};function $8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}$8.isMDXComponent=!0;const K8={toc:[]};function J8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}J8.isMDXComponent=!0;const t3={toc:[]};function e3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}e3.isMDXComponent=!0;const n3={toc:[]};function o3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}o3.isMDXComponent=!0;const p3={toc:[]};function r3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}r3.isMDXComponent=!0;const s3={toc:[]};function c3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}c3.isMDXComponent=!0;const i3={toc:[]};function a3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}a3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}d3.isMDXComponent=!0;const h3={toc:[]};function f3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}f3.isMDXComponent=!0;const k3={toc:[]};function y3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}y3.isMDXComponent=!0;const D3={toc:[]};function M3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}M3.isMDXComponent=!0;const w3={toc:[]};function _3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}_3.isMDXComponent=!0;const X3={toc:[]};function g3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}g3.isMDXComponent=!0;const T3={toc:[]};function C3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The spacing between the grid lines."))}C3.isMDXComponent=!0;const x3={toc:[]};function v3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}v3.isMDXComponent=!0;const L3={toc:[]};function Z3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}Z3.isMDXComponent=!0;const b3={toc:[]};function N3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}N3.isMDXComponent=!0;const z3={toc:[]};function A3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}A3.isMDXComponent=!0;const W3={toc:[]};function I3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}I3.isMDXComponent=!0;const R3={toc:[]};function P3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}P3.isMDXComponent=!0;const S3={toc:[]};function O3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}O3.isMDXComponent=!0;const E3={toc:[]};function B3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}B3.isMDXComponent=!0;const G3={toc:[]};function U3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}U3.isMDXComponent=!0;const F3={toc:[]};function V3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}V3.isMDXComponent=!0;const q3={toc:[]};function j3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}j3.isMDXComponent=!0;const H3={toc:[]};function Q3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Q3.isMDXComponent=!0;const Y3={toc:[]};function $3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}$3.isMDXComponent=!0;const K3={toc:[]};function J3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}J3.isMDXComponent=!0;const t2={toc:[]};function e2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}e2.isMDXComponent=!0;const n2={toc:[]};function o2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}o2.isMDXComponent=!0;const p2={toc:[]};function r2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}r2.isMDXComponent=!0;const s2={toc:[]};function c2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}c2.isMDXComponent=!0;const i2={toc:[]};function a2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}a2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}d2.isMDXComponent=!0;const h2={toc:[]};function f2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}f2.isMDXComponent=!0;const k2={toc:[]};function y2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}y2.isMDXComponent=!0;const D2={toc:[]};function M2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}M2.isMDXComponent=!0;const w2={toc:[]};function _2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}_2.isMDXComponent=!0;const X2={toc:[]};function g2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}g2.isMDXComponent=!0;const T2={toc:[]};function C2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}C2.isMDXComponent=!0;const x2={toc:[]};function v2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}v2.isMDXComponent=!0;const L2={toc:[]};function Z2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Z2.isMDXComponent=!0;const b2={toc:[]};function N2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}N2.isMDXComponent=!0;const z2={toc:[]};function A2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}A2.isMDXComponent=!0;const W2={toc:[]};function I2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}I2.isMDXComponent=!0;const R2={toc:[]};function P2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}P2.isMDXComponent=!0;const S2={toc:[]};function O2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}O2.isMDXComponent=!0;const E2={toc:[]};function B2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}B2.isMDXComponent=!0;const G2={toc:[]};function U2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}U2.isMDXComponent=!0;const F2={toc:[]};function V2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}V2.isMDXComponent=!0;const q2={toc:[]};function j2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}j2.isMDXComponent=!0;const H2={toc:[]};function Q2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Q2.isMDXComponent=!0;const Y2={toc:[]};function $2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}$2.isMDXComponent=!0;const K2={toc:[]};function J2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}J2.isMDXComponent=!0;const t1={toc:[]};function e1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}e1.isMDXComponent=!0;const n1={toc:[]};function o1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}o1.isMDXComponent=!0;const p1={toc:[]};function r1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}r1.isMDXComponent=!0;const s1={toc:[]};function c1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}c1.isMDXComponent=!0;const i1={toc:[]};function a1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}a1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}d1.isMDXComponent=!0;const h1={toc:[]};function f1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}f1.isMDXComponent=!0;const k1={toc:[]};function y1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}y1.isMDXComponent=!0;const D1={toc:[]};function M1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}M1.isMDXComponent=!0;const w1={toc:[]};function _1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}_1.isMDXComponent=!0;const X1={toc:[]};function g1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}g1.isMDXComponent=!0;const T1={toc:[]};function C1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}C1.isMDXComponent=!0;const x1={toc:[]};function v1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}v1.isMDXComponent=!0;const L1={toc:[]};function Z1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Z1.isMDXComponent=!0;const b1={toc:[]};function N1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}N1.isMDXComponent=!0;const z1={toc:[]};function A1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}A1.isMDXComponent=!0;const W1={toc:[]};function I1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}I1.isMDXComponent=!0;const R1={toc:[]};function P1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}P1.isMDXComponent=!0;const S1={toc:[]};function O1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}O1.isMDXComponent=!0;const E1={toc:[]};function B1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}B1.isMDXComponent=!0;const G1={toc:[]};function U1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}U1.isMDXComponent=!0;const F1={toc:[]};function V1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}V1.isMDXComponent=!0;const q1={toc:[]};function j1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}j1.isMDXComponent=!0;const H1={toc:[]};function Q1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Q1.isMDXComponent=!0;const Y1={toc:[]};function $1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}$1.isMDXComponent=!0;const K1={toc:[]};function J1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}J1.isMDXComponent=!0;const t4={toc:[]};function e4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}e4.isMDXComponent=!0;const n4={toc:[]};function o4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}o4.isMDXComponent=!0;const p4={toc:[]};function r4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}r4.isMDXComponent=!0;const s4={toc:[]};function c4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}c4.isMDXComponent=!0;const i4={toc:[]};function a4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}a4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}d4.isMDXComponent=!0;const h4={toc:[]};function f4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}f4.isMDXComponent=!0;const k4={toc:[]};function y4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}y4.isMDXComponent=!0;const D4={toc:[]};function M4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}M4.isMDXComponent=!0;const w4={toc:[]};function _4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}_4.isMDXComponent=!0;const X4={toc:[]};function g4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}g4.isMDXComponent=!0;const T4={toc:[]};function C4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}C4.isMDXComponent=!0;const x4={toc:[]};function v4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}v4.isMDXComponent=!0;const L4={toc:[]};function Z4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Z4.isMDXComponent=!0;const b4={toc:[]};function N4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}N4.isMDXComponent=!0;const z4={toc:[]};function A4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}A4.isMDXComponent=!0;const W4={toc:[]};function I4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}I4.isMDXComponent=!0;const R4={toc:[]};function P4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}P4.isMDXComponent=!0;const S4={toc:[]};function O4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}O4.isMDXComponent=!0;const E4={toc:[]};function B4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}B4.isMDXComponent=!0;const G4={toc:[]};function U4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}U4.isMDXComponent=!0;const F4={toc:[]};function V4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}V4.isMDXComponent=!0;const q4={toc:[]};function j4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}j4.isMDXComponent=!0;const H4={toc:[]};function Q4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Q4.isMDXComponent=!0;const Y4={toc:[]};function $4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}$4.isMDXComponent=!0;const K4={toc:[]};function J4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}J4.isMDXComponent=!0;const t6={toc:[]};function e6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}e6.isMDXComponent=!0;const n6={toc:[]};function o6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}o6.isMDXComponent=!0;const p6={toc:[]};function r6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}r6.isMDXComponent=!0;const s6={toc:[]};function c6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}c6.isMDXComponent=!0;const i6={toc:[]};function a6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}a6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}d6.isMDXComponent=!0;const h6={toc:[]};function f6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}f6.isMDXComponent=!0;const k6={toc:[]};function y6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}y6.isMDXComponent=!0;const D6={toc:[]};function M6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}M6.isMDXComponent=!0;const w6={toc:[]};function _6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}_6.isMDXComponent=!0;const X6={toc:[]};function g6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}g6.isMDXComponent=!0;const T6={toc:[]};function C6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}C6.isMDXComponent=!0;const x6={toc:[]};function v6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}v6.isMDXComponent=!0;const L6={toc:[]};function Z6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Z6.isMDXComponent=!0;const b6={toc:[]};function N6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}N6.isMDXComponent=!0;const z6={toc:[]};function A6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}A6.isMDXComponent=!0;const W6={toc:[]};function I6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}I6.isMDXComponent=!0;const R6={toc:[]};function P6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An Icon Component that provides easy access to over 150k icons.\nSee ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}P6.isMDXComponent=!0;const S6={toc:[]};function O6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}O6.isMDXComponent=!0;const E6={toc:[]};function B6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}B6.isMDXComponent=!0;const G6={toc:[]};function U6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}U6.isMDXComponent=!0;const F6={toc:[]};function V6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}V6.isMDXComponent=!0;const q6={toc:[]};function j6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}j6.isMDXComponent=!0;const H6={toc:[]};function Q6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Q6.isMDXComponent=!0;const Y6={toc:[]};function $6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}$6.isMDXComponent=!0;const K6={toc:[]};function J6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}J6.isMDXComponent=!0;const t7={toc:[]};function e7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}e7.isMDXComponent=!0;const n7={toc:[]};function o7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}o7.isMDXComponent=!0;const p7={toc:[]};function r7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}r7.isMDXComponent=!0;const s7={toc:[]};function c7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}c7.isMDXComponent=!0;const i7={toc:[]};function a7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}a7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}d7.isMDXComponent=!0;const h7={toc:[]};function f7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}f7.isMDXComponent=!0;const k7={toc:[]};function y7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}y7.isMDXComponent=!0;const D7={toc:[]};function M7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}M7.isMDXComponent=!0;const w7={toc:[]};function _7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}_7.isMDXComponent=!0;const X7={toc:[]};function g7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"'white'"))}g7.isMDXComponent=!0;const T7={toc:[]};function C7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}C7.isMDXComponent=!0;const x7={toc:[]};function v7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}v7.isMDXComponent=!0;const L7={toc:[]};function Z7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Z7.isMDXComponent=!0;const b7={toc:[]};function N7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}N7.isMDXComponent=!0;const z7={toc:[]};function A7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}A7.isMDXComponent=!0;const W7={toc:[]};function I7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}I7.isMDXComponent=!0;const R7={toc:[]};function P7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}P7.isMDXComponent=!0;const S7={toc:[]};function O7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}O7.isMDXComponent=!0;const E7={toc:[]};function B7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}B7.isMDXComponent=!0;const G7={toc:[]};function U7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}U7.isMDXComponent=!0;const F7={toc:[]};function V7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}V7.isMDXComponent=!0;const q7={toc:[]};function j7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}j7.isMDXComponent=!0;const H7={toc:[]};function Q7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Q7.isMDXComponent=!0;const Y7={toc:[]};function $7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}$7.isMDXComponent=!0;const K7={toc:[]};function J7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}J7.isMDXComponent=!0;const t9={toc:[]};function e9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}e9.isMDXComponent=!0;const n9={toc:[]};function o9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}o9.isMDXComponent=!0;const p9={toc:[]};function r9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}r9.isMDXComponent=!0;const s9={toc:[]};function c9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}c9.isMDXComponent=!0;const i9={toc:[]};function a9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}a9.isMDXComponent=!0;const l9={toc:[]};function u9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}u9.isMDXComponent=!0;const m9={toc:[]};function d9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}d9.isMDXComponent=!0;const h9={toc:[]};function f9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}f9.isMDXComponent=!0;const k9={toc:[]};function y9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}y9.isMDXComponent=!0;const D9={toc:[]};function M9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}M9.isMDXComponent=!0;const w9={toc:[]};function _9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}_9.isMDXComponent=!0;const X9={toc:[]};function g9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}g9.isMDXComponent=!0;const T9={toc:[]};function C9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}C9.isMDXComponent=!0;const x9={toc:[]};function v9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}v9.isMDXComponent=!0;const L9={toc:[]};function Z9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Z9.isMDXComponent=!0;const b9={toc:[]};function N9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}N9.isMDXComponent=!0;const z9={toc:[]};function A9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}A9.isMDXComponent=!0;const W9={toc:[]};function I9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}I9.isMDXComponent=!0;const R9={toc:[]};function P9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}P9.isMDXComponent=!0;const S9={toc:[]};function O9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}O9.isMDXComponent=!0;const E9={toc:[]};function B9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}B9.isMDXComponent=!0;const G9={toc:[]};function U9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}U9.isMDXComponent=!0;const F9={toc:[]};function V9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}V9.isMDXComponent=!0;const q9={toc:[]};function j9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}j9.isMDXComponent=!0;const H9={toc:[]};function Q9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Q9.isMDXComponent=!0;const Y9={toc:[]};function $9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}$9.isMDXComponent=!0;const K9={toc:[]};function J9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}J9.isMDXComponent=!0;const ttt={toc:[]};function ett(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ttt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ett.isMDXComponent=!0;const ntt={toc:[]};function ott(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ntt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}ott.isMDXComponent=!0;const ptt={toc:[]};function rtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ptt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}rtt.isMDXComponent=!0;const stt={toc:[]};function ctt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},stt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}ctt.isMDXComponent=!0;const itt={toc:[]};function att(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},itt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}att.isMDXComponent=!0;const ltt={toc:[]};function utt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ltt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}utt.isMDXComponent=!0;const mtt={toc:[]};function dtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}dtt.isMDXComponent=!0;const htt={toc:[]};function ftt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},htt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}ftt.isMDXComponent=!0;const ktt={toc:[]};function ytt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ktt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}ytt.isMDXComponent=!0;const Dtt={toc:[]};function Mtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Mtt.isMDXComponent=!0;const wtt={toc:[]};function _tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}_tt.isMDXComponent=!0;const Xtt={toc:[]};function gtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}gtt.isMDXComponent=!0;const Ttt={toc:[]};function Ctt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ttt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Ctt.isMDXComponent=!0;const xtt={toc:[]};function vtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}vtt.isMDXComponent=!0;const Ltt={toc:[]};function Ztt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ltt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Ztt.isMDXComponent=!0;const btt={toc:[]};function Ntt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},btt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Ntt.isMDXComponent=!0;const ztt={toc:[]};function Att(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ztt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Att.isMDXComponent=!0;const Wtt={toc:[]};function Itt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Itt.isMDXComponent=!0;const Rtt={toc:[]};function Ptt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Ptt.isMDXComponent=!0;const Stt={toc:[]};function Ott(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Stt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Ott.isMDXComponent=!0;const Ett={toc:[]};function Btt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ett,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Btt.isMDXComponent=!0;const Gtt={toc:[]};function Utt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Utt.isMDXComponent=!0;const Ftt={toc:[]};function Vtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ftt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Vtt.isMDXComponent=!0;const qtt={toc:[]};function jtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}jtt.isMDXComponent=!0;const Htt={toc:[]};function Qtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Htt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Qtt.isMDXComponent=!0;const Ytt={toc:[]};function $tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ytt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}$tt.isMDXComponent=!0;const Ktt={toc:[]};function Jtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ktt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Jtt.isMDXComponent=!0;const tet={toc:[]};function eet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}eet.isMDXComponent=!0;const net={toc:[]};function oet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},net,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}oet.isMDXComponent=!0;const pet={toc:[]};function ret(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}ret.isMDXComponent=!0;const set={toc:[]};function cet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},set,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}cet.isMDXComponent=!0;const iet={toc:[]};function aet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}aet.isMDXComponent=!0;const uet={toc:[]};function met(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}met.isMDXComponent=!0;const det={toc:[]};function het(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},det,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}het.isMDXComponent=!0;const fet={toc:[]};function ket(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}ket.isMDXComponent=!0;const yet={toc:[]};function Det(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Det.isMDXComponent=!0;const Met={toc:[]};function wet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Met,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}wet.isMDXComponent=!0;const _et={toc:[]};function Xet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Xet.isMDXComponent=!0;const get={toc:[]};function Tet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},get,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Tet.isMDXComponent=!0;const Cet={toc:[]};function xet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}xet.isMDXComponent=!0;const vet={toc:[]};function Let(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Let.isMDXComponent=!0;const Zet={toc:[]};function bet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}bet.isMDXComponent=!0;const Net={toc:[]};function zet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Net,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}zet.isMDXComponent=!0;const Aet={toc:[]};function Wet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Wet.isMDXComponent=!0;const Iet={toc:[]};function Ret(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Ret.isMDXComponent=!0;const Pet={toc:[]};function Set(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Set.isMDXComponent=!0;const Oet={toc:[]};function Eet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Eet.isMDXComponent=!0;const Bet={toc:[]};function Get(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}Get.isMDXComponent=!0;const Uet={toc:[]};function Fet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}Fet.isMDXComponent=!0;const Vet={toc:[]};function qet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}qet.isMDXComponent=!0;const jet={toc:[]};function Het(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}Het.isMDXComponent=!0;const Qet={toc:[]};function Yet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}Yet.isMDXComponent=!0;const $et={toc:[]};function Ket(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Ket.isMDXComponent=!0;const Jet={toc:[]};function tnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}tnt.isMDXComponent=!0;const ent={toc:[]};function nnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ent,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}nnt.isMDXComponent=!0;const ont={toc:[]};function pnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ont,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}pnt.isMDXComponent=!0;const rnt={toc:[]};function snt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}snt.isMDXComponent=!0;const cnt={toc:[]};function int(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}int.isMDXComponent=!0;const ant={toc:[]};function lnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ant,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}lnt.isMDXComponent=!0;const unt={toc:[]};function mnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},unt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}mnt.isMDXComponent=!0;const dnt={toc:[]};function hnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}hnt.isMDXComponent=!0;const fnt={toc:[]};function knt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}knt.isMDXComponent=!0;const ynt={toc:[]};function Dnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ynt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Dnt.isMDXComponent=!0;const Mnt={toc:[]};function wnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}wnt.isMDXComponent=!0;const _nt={toc:[]};function Xnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Xnt.isMDXComponent=!0;const gnt={toc:[]};function Tnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Tnt.isMDXComponent=!0;const Cnt={toc:[]};function xnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}xnt.isMDXComponent=!0;const vnt={toc:[]};function Lnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Lnt.isMDXComponent=!0;const Znt={toc:[]};function bnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Znt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}bnt.isMDXComponent=!0;const Nnt={toc:[]};function znt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}znt.isMDXComponent=!0;const Ant={toc:[]};function Wnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ant,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Wnt.isMDXComponent=!0;const Int={toc:[]};function Rnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Int,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Rnt.isMDXComponent=!0;const Pnt={toc:[]};function Snt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Snt.isMDXComponent=!0;const Ont={toc:[]};function Ent(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ont,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Ent.isMDXComponent=!0;const Bnt={toc:[]};function Gnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Gnt.isMDXComponent=!0;const Unt={toc:[]};function Fnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Unt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Fnt.isMDXComponent=!0;const Vnt={toc:[]};function qnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}qnt.isMDXComponent=!0;const jnt={toc:[]};function Hnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Hnt.isMDXComponent=!0;const Qnt={toc:[]};function Ynt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Ynt.isMDXComponent=!0;const $nt={toc:[]};function Knt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Knt.isMDXComponent=!0;const Jnt={toc:[]};function tot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}tot.isMDXComponent=!0;const eot={toc:[]};function not(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}not.isMDXComponent=!0;const oot={toc:[]};function pot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}pot.isMDXComponent=!0;const rot={toc:[]};function sot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}sot.isMDXComponent=!0;const cot={toc:[]};function iot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}iot.isMDXComponent=!0;const aot={toc:[]};function lot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}lot.isMDXComponent=!0;const uot={toc:[]};function mot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}mot.isMDXComponent=!0;const dot={toc:[]};function hot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}hot.isMDXComponent=!0;const fot={toc:[]};function kot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}kot.isMDXComponent=!0;const yot={toc:[]};function Dot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Dot.isMDXComponent=!0;const Mot={toc:[]};function wot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}wot.isMDXComponent=!0;const _ot={toc:[]};function Xot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Xot.isMDXComponent=!0;const got={toc:[]};function Tot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},got,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Tot.isMDXComponent=!0;const Cot={toc:[]};function xot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}xot.isMDXComponent=!0;const vot={toc:[]};function Lot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}Lot.isMDXComponent=!0;const Zot={toc:[]};function bot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}bot.isMDXComponent=!0;const Not={toc:[]};function zot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Not,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}zot.isMDXComponent=!0;const Aot={toc:[]};function Wot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Wot.isMDXComponent=!0;const Iot={toc:[]};function Rot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Rot.isMDXComponent=!0;const Pot={toc:[]};function Sot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Sot.isMDXComponent=!0;const Oot={toc:[]};function Eot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Eot.isMDXComponent=!0;const Bot={toc:[]};function Got(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Got.isMDXComponent=!0;const Uot={toc:[]};function Fot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Fot.isMDXComponent=!0;const Vot={toc:[]};function qot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}qot.isMDXComponent=!0;const jot={toc:[]};function Hot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Hot.isMDXComponent=!0;const Qot={toc:[]};function Yot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Yot.isMDXComponent=!0;const $ot={toc:[]};function Kot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Kot.isMDXComponent=!0;const Jot={toc:[]};function tpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}tpt.isMDXComponent=!0;const ept={toc:[]};function npt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ept,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}npt.isMDXComponent=!0;const opt={toc:[]};function ppt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},opt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}ppt.isMDXComponent=!0;const rpt={toc:[]};function spt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}spt.isMDXComponent=!0;const cpt={toc:[]};function ipt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}ipt.isMDXComponent=!0;const apt={toc:[]};function lpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},apt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}lpt.isMDXComponent=!0;const upt={toc:[]};function mpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}mpt.isMDXComponent=!0;const dpt={toc:[]};function hpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}hpt.isMDXComponent=!0;const fpt={toc:[]};function kpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}kpt.isMDXComponent=!0;const ypt={toc:[]};function Dpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ypt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Dpt.isMDXComponent=!0;const Mpt={toc:[]};function wpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}wpt.isMDXComponent=!0;const _pt={toc:[]};function Xpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Xpt.isMDXComponent=!0;const gpt={toc:[]};function Tpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Tpt.isMDXComponent=!0;const Cpt={toc:[]};function xpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}xpt.isMDXComponent=!0;const vpt={toc:[]};function Lpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Lpt.isMDXComponent=!0;const Zpt={toc:[]};function bpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}bpt.isMDXComponent=!0;const Npt={toc:[]};function zpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}zpt.isMDXComponent=!0;const Apt={toc:[]};function Wpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Apt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Wpt.isMDXComponent=!0;const Ipt={toc:[]};function Rpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ipt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Rpt.isMDXComponent=!0;const Ppt={toc:[]};function Spt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ppt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Spt.isMDXComponent=!0;const Opt={toc:[]};function Ept(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Opt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Ept.isMDXComponent=!0;const Bpt={toc:[]};function Gpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Gpt.isMDXComponent=!0;const Upt={toc:[]};function Fpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Upt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Address to Iconify API for the requested Icon."))}Fpt.isMDXComponent=!0;const Vpt={toc:[]};function qpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create the URL that will be used as the Image source"))}qpt.isMDXComponent=!0;const jpt={toc:[]};function Hpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Hpt.isMDXComponent=!0;const Qpt={toc:[]};function Ypt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Ypt.isMDXComponent=!0;const $pt={toc:[]};function Kpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Kpt.isMDXComponent=!0;const Jpt={toc:[]};function trt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}trt.isMDXComponent=!0;const ert={toc:[]};function nrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ert,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}nrt.isMDXComponent=!0;const ort={toc:[]};function prt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ort,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}prt.isMDXComponent=!0;const rrt={toc:[]};function srt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}srt.isMDXComponent=!0;const crt={toc:[]};function irt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},crt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}irt.isMDXComponent=!0;const art={toc:[]};function lrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},art,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lrt.isMDXComponent=!0;const urt={toc:[]};function mrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},urt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}mrt.isMDXComponent=!0;const drt={toc:[]};function hrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},drt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  yield view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}hrt.isMDXComponent=!0;const frt={toc:[]};function krt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},frt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}krt.isMDXComponent=!0;const yrt={toc:[]};function Drt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Drt.isMDXComponent=!0;const Mrt={toc:[]};function wrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}wrt.isMDXComponent=!0;const _rt={toc:[]};function Xrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Xrt.isMDXComponent=!0;const grt={toc:[]};function Trt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},grt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Trt.isMDXComponent=!0;const Crt={toc:[]};function xrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Crt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}xrt.isMDXComponent=!0;const vrt={toc:[]};function Lrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Lrt.isMDXComponent=!0;const Zrt={toc:[]};function brt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}brt.isMDXComponent=!0;const Nrt={toc:[]};function zrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}zrt.isMDXComponent=!0;const Art={toc:[]};function Wrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Art,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Wrt.isMDXComponent=!0;const Irt={toc:[]};function Rrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Irt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Rrt.isMDXComponent=!0;const Prt={toc:[]};function Srt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Prt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Srt.isMDXComponent=!0;const Ort={toc:[]};function Ert(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ort,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Ert.isMDXComponent=!0;const Brt={toc:[]};function Grt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Brt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Grt.isMDXComponent=!0;const Urt={toc:[]};function Frt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Urt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Frt.isMDXComponent=!0;const Vrt={toc:[]};function qrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}qrt.isMDXComponent=!0;const jrt={toc:[]};function Hrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Hrt.isMDXComponent=!0;const Qrt={toc:[]};function Yrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Yrt.isMDXComponent=!0;const $rt={toc:[]};function Krt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Krt.isMDXComponent=!0;const Jrt={toc:[]};function tst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}tst.isMDXComponent=!0;const est={toc:[]};function nst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},est,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}nst.isMDXComponent=!0;const ost={toc:[]};function pst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ost,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}pst.isMDXComponent=!0;const rst={toc:[]};function sst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}sst.isMDXComponent=!0;const cst={toc:[]};function ist(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}ist.isMDXComponent=!0;const ast={toc:[]};function lst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ast,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lst.isMDXComponent=!0;const ust={toc:[]};function mst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ust,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}mst.isMDXComponent=!0;const dst={toc:[]};function hst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}hst.isMDXComponent=!0;const fst={toc:[]};function kst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}kst.isMDXComponent=!0;const yst={toc:[]};function Dst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Dst.isMDXComponent=!0;const Mst={toc:[]};function wst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}wst.isMDXComponent=!0;const _st={toc:[]};function Xst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_st,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Xst.isMDXComponent=!0;const gst={toc:[]};function Tst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Tst.isMDXComponent=!0;const Cst={toc:[]};function xst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}xst.isMDXComponent=!0;const vst={toc:[]};function Lst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Lst.isMDXComponent=!0;const Zst={toc:[]};function bst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}bst.isMDXComponent=!0;const Nst={toc:[]};function zst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}zst.isMDXComponent=!0;const Ast={toc:[]};function Wst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ast,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Wst.isMDXComponent=!0;const Ist={toc:[]};function Rst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ist,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Rst.isMDXComponent=!0;const Pst={toc:[]};function Sst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Sst.isMDXComponent=!0;const Ost={toc:[]};function Est(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ost,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Est.isMDXComponent=!0;const Bst={toc:[]};function Gst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Gst.isMDXComponent=!0;const Ust={toc:[]};function Fst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ust,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Fst.isMDXComponent=!0;const Vst={toc:[]};function qst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}qst.isMDXComponent=!0;const jst={toc:[]};function Hst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Hst.isMDXComponent=!0;const Qst={toc:[]};function Yst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Yst.isMDXComponent=!0;const $st={toc:[]};function Kst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$st,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Kst.isMDXComponent=!0;const Jst={toc:[]};function tct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}tct.isMDXComponent=!0;const ect={toc:[]};function nct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ect,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}nct.isMDXComponent=!0;const oct={toc:[]};function pct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}pct.isMDXComponent=!0;const rct={toc:[]};function sct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}sct.isMDXComponent=!0;const cct={toc:[]};function ict(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}ict.isMDXComponent=!0;const act={toc:[]};function lct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},act,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}lct.isMDXComponent=!0;const uct={toc:[]};function mct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}mct.isMDXComponent=!0;const dct={toc:[]};function hct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}hct.isMDXComponent=!0;const fct={toc:[]};function kct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}kct.isMDXComponent=!0;const yct={toc:[]};function Dct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Dct.isMDXComponent=!0;const Mct={toc:[]};function wct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wct.isMDXComponent=!0;const _ct={toc:[]};function Xct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Xct.isMDXComponent=!0;const gct={toc:[]};function Tct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Tct.isMDXComponent=!0;const Cct={toc:[]};function xct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}xct.isMDXComponent=!0;const vct={toc:[]};function Lct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Lct.isMDXComponent=!0;const Zct={toc:[]};function bct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}bct.isMDXComponent=!0;const Nct={toc:[]};function zct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}zct.isMDXComponent=!0;const Act={toc:[]};function Wct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Act,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Wct.isMDXComponent=!0;const Ict={toc:[]};function Rct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ict,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Rct.isMDXComponent=!0;const Pct={toc:[]};function Sct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Sct.isMDXComponent=!0;const Oct={toc:[]};function Ect(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Ect.isMDXComponent=!0;const Bct={toc:[]};function Gct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Gct.isMDXComponent=!0;const Uct={toc:[]};function Fct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Fct.isMDXComponent=!0;const Vct={toc:[]};function qct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}qct.isMDXComponent=!0;const jct={toc:[]};function Hct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Hct.isMDXComponent=!0;const Qct={toc:[]};function Yct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Yct.isMDXComponent=!0;const $ct={toc:[]};function Kct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Kct.isMDXComponent=!0;const Jct={toc:[]};function tit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}tit.isMDXComponent=!0;const eit={toc:[]};function nit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}nit.isMDXComponent=!0;const oit={toc:[]};function pit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}pit.isMDXComponent=!0;const rit={toc:[]};function sit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}sit.isMDXComponent=!0;const cit={toc:[]};function iit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}iit.isMDXComponent=!0;const ait={toc:[]};function lit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ait,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}lit.isMDXComponent=!0;const uit={toc:[]};function mit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}mit.isMDXComponent=!0;const dit={toc:[]};function hit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}hit.isMDXComponent=!0;const fit={toc:[]};function kit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}kit.isMDXComponent=!0;const yit={toc:[]};function Dit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Dit.isMDXComponent=!0;const Mit={toc:[]};function wit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}wit.isMDXComponent=!0;const _it={toc:[]};function Xit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_it,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Xit.isMDXComponent=!0;const git={toc:[]};function Tit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},git,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Tit.isMDXComponent=!0;const Cit={toc:[]};function xit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}xit.isMDXComponent=!0;const vit={toc:[]};function Lit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Lit.isMDXComponent=!0;const Zit={toc:[]};function bit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}bit.isMDXComponent=!0;const Nit={toc:[]};function zit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}zit.isMDXComponent=!0;const Ait={toc:[]};function Wit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ait,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Wit.isMDXComponent=!0;const Iit={toc:[]};function Rit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Rit.isMDXComponent=!0;const Pit={toc:[]};function Sit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Sit.isMDXComponent=!0;const Oit={toc:[]};function Eit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Eit.isMDXComponent=!0;const Bit={toc:[]};function Git(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Git.isMDXComponent=!0;const Uit={toc:[]};function Fit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Fit.isMDXComponent=!0;const Vit={toc:[]};function qit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qit.isMDXComponent=!0;const jit={toc:[]};function Hit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Hit.isMDXComponent=!0;const Qit={toc:[]};function Yit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Yit.isMDXComponent=!0;const $it={toc:[]};function Kit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$it,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Kit.isMDXComponent=!0;const Jit={toc:[]};function tat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}tat.isMDXComponent=!0;const eat={toc:[]};function nat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}nat.isMDXComponent=!0;const oat={toc:[]};function pat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}pat.isMDXComponent=!0;const rat={toc:[]};function sat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}sat.isMDXComponent=!0;const cat={toc:[]};function iat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}iat.isMDXComponent=!0;const aat={toc:[]};function lat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}lat.isMDXComponent=!0;const uat={toc:[]};function mat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}mat.isMDXComponent=!0;const dat={toc:[]};function hat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}hat.isMDXComponent=!0;const fat={toc:[]};function kat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}kat.isMDXComponent=!0;const yat={toc:[]};function Dat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Dat.isMDXComponent=!0;const Mat={toc:[]};function wat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}wat.isMDXComponent=!0;const _at={toc:[]};function Xat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_at,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Xat.isMDXComponent=!0;const gat={toc:[]};function Tat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Tat.isMDXComponent=!0;const Cat={toc:[]};function xat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}xat.isMDXComponent=!0;const vat={toc:[]};function Lat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Lat.isMDXComponent=!0;const Zat={toc:[]};function bat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}bat.isMDXComponent=!0;const Nat={toc:[]};function zat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}zat.isMDXComponent=!0;const Aat={toc:[]};function Wat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Wat.isMDXComponent=!0;const Iat={toc:[]};function Rat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Rat.isMDXComponent=!0;const Pat={toc:[]};function Sat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Sat.isMDXComponent=!0;const Oat={toc:[]};function Eat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Eat.isMDXComponent=!0;const Bat={toc:[]};function Gat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Gat.isMDXComponent=!0;const Uat={toc:[]};function Fat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Fat.isMDXComponent=!0;const Vat={toc:[]};function qat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}qat.isMDXComponent=!0;const jat={toc:[]};function Hat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Hat.isMDXComponent=!0;const Qat={toc:[]};function Yat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Yat.isMDXComponent=!0;const $at={toc:[]};function Kat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$at,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Kat.isMDXComponent=!0;const Jat={toc:[]};function tlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}tlt.isMDXComponent=!0;const elt={toc:[]};function nlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},elt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}nlt.isMDXComponent=!0;const olt={toc:[]};function plt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},olt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}plt.isMDXComponent=!0;const rlt={toc:[]};function slt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}slt.isMDXComponent=!0;const clt={toc:[]};function ilt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},clt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}ilt.isMDXComponent=!0;const alt={toc:[]};function llt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},alt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}llt.isMDXComponent=!0;const ult={toc:[]};function mlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ult,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}mlt.isMDXComponent=!0;const dlt={toc:[]};function hlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}hlt.isMDXComponent=!0;const flt={toc:[]};function klt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},flt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}klt.isMDXComponent=!0;const ylt={toc:[]};function Dlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ylt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Dlt.isMDXComponent=!0;const Mlt={toc:[]};function wlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}wlt.isMDXComponent=!0;const _lt={toc:[]};function Xlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Xlt.isMDXComponent=!0;const glt={toc:[]};function Tlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},glt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Tlt.isMDXComponent=!0;const Clt={toc:[]};function xlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Clt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}xlt.isMDXComponent=!0;const vlt={toc:[]};function Llt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Llt.isMDXComponent=!0;const Zlt={toc:[]};function blt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}blt.isMDXComponent=!0;const Nlt={toc:[]};function zlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}zlt.isMDXComponent=!0;const Alt={toc:[]};function Wlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Alt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Wlt.isMDXComponent=!0;const Ilt={toc:[]};function Rlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ilt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Rlt.isMDXComponent=!0;const Plt={toc:[]};function Slt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Plt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Slt.isMDXComponent=!0;const Olt={toc:[]};function Elt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Olt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Elt.isMDXComponent=!0;const Blt={toc:[]};function Glt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Blt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Glt.isMDXComponent=!0;const Ult={toc:[]};function Flt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ult,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Flt.isMDXComponent=!0;const Vlt={toc:[]};function qlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}qlt.isMDXComponent=!0;const jlt={toc:[]};function Hlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}Hlt.isMDXComponent=!0;const Qlt={toc:[]};function Ylt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Ylt.isMDXComponent=!0;const $lt={toc:[]};function Klt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Klt.isMDXComponent=!0;const Jlt={toc:[]};function tut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}tut.isMDXComponent=!0;const eut={toc:[]};function nut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}nut.isMDXComponent=!0;const out={toc:[]};function put(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},out,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}put.isMDXComponent=!0;const rut={toc:[]};function sut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}sut.isMDXComponent=!0;const cut={toc:[]};function iut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}iut.isMDXComponent=!0;const aut={toc:[]};function lut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lut.isMDXComponent=!0;const uut={toc:[]};function mut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}mut.isMDXComponent=!0;const dut={toc:[]};function hut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}hut.isMDXComponent=!0;const fut={toc:[]};function kut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}kut.isMDXComponent=!0;const yut={toc:[]};function Dut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Dut.isMDXComponent=!0;const Mut={toc:[]};function wut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}wut.isMDXComponent=!0;const _ut={toc:[]};function Xut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Xut.isMDXComponent=!0;const gut={toc:[]};function Tut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Tut.isMDXComponent=!0;const Cut={toc:[]};function xut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}xut.isMDXComponent=!0;const vut={toc:[]};function Lut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Lut.isMDXComponent=!0;const Zut={toc:[]};function but(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}but.isMDXComponent=!0;const Nut={toc:[]};function zut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}zut.isMDXComponent=!0;const Aut={toc:[]};function Wut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Wut.isMDXComponent=!0;const Iut={toc:[]};function Rut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Rut.isMDXComponent=!0;const Put={toc:[]};function Sut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Put,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Sut.isMDXComponent=!0;const Out={toc:[]};function Eut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Out,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Eut.isMDXComponent=!0;const But={toc:[]};function Gut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},But,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Gut.isMDXComponent=!0;const Uut={toc:[]};function Fut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Fut.isMDXComponent=!0;const Vut={toc:[]};function qut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}qut.isMDXComponent=!0;const jut={toc:[]};function Hut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Hut.isMDXComponent=!0;const Qut={toc:[]};function Yut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Yut.isMDXComponent=!0;const $ut={toc:[]};function Kut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Kut.isMDXComponent=!0;const Jut={toc:[]};function tmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}tmt.isMDXComponent=!0;const emt={toc:[]};function nmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},emt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}nmt.isMDXComponent=!0;const omt={toc:[]};function pmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},omt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pmt.isMDXComponent=!0;const rmt={toc:[]};function smt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}smt.isMDXComponent=!0;const cmt={toc:[]};function imt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}imt.isMDXComponent=!0;const amt={toc:[]};function lmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},amt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lmt.isMDXComponent=!0;const umt={toc:[]};function mmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},umt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}mmt.isMDXComponent=!0;const dmt={toc:[]};function hmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}hmt.isMDXComponent=!0;const fmt={toc:[]};function kmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}kmt.isMDXComponent=!0;const ymt={toc:[]};function Dmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ymt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Dmt.isMDXComponent=!0;const Mmt={toc:[]};function wmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}wmt.isMDXComponent=!0;const _mt={toc:[]};function Xmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Xmt.isMDXComponent=!0;const gmt={toc:[]};function Tmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Tmt.isMDXComponent=!0;const Cmt={toc:[]};function xmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}xmt.isMDXComponent=!0;const vmt={toc:[]};function Lmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node representing a knot of a ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}Lmt.isMDXComponent=!0;const Zmt={toc:[]};function bmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}bmt.isMDXComponent=!0;const Nmt={toc:[]};function zmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}zmt.isMDXComponent=!0;const Amt={toc:[]};function Wmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Amt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Wmt.isMDXComponent=!0;const Imt={toc:[]};function Rmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Imt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Rmt.isMDXComponent=!0;const Pmt={toc:[]};function Smt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Smt.isMDXComponent=!0;const Omt={toc:[]};function Emt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Omt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Emt.isMDXComponent=!0;const Bmt={toc:[]};function Gmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}Gmt.isMDXComponent=!0;const Umt={toc:[]};function Fmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Umt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}Fmt.isMDXComponent=!0;const Vmt={toc:[]};function qmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}qmt.isMDXComponent=!0;const jmt={toc:[]};function Hmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Hmt.isMDXComponent=!0;const Qmt={toc:[]};function Ymt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the startHandle."))}Ymt.isMDXComponent=!0;const $mt={toc:[]};function Kmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}Kmt.isMDXComponent=!0;const Jmt={toc:[]};function tdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}tdt.isMDXComponent=!0;const edt={toc:[]};function ndt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},edt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}ndt.isMDXComponent=!0;const odt={toc:[]};function pdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},odt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}pdt.isMDXComponent=!0;const rdt={toc:[]};function sdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}sdt.isMDXComponent=!0;const cdt={toc:[]};function idt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}idt.isMDXComponent=!0;const adt={toc:[]};function ldt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},adt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}ldt.isMDXComponent=!0;const udt={toc:[]};function mdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},udt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the endHandle."))}mdt.isMDXComponent=!0;const ddt={toc:[]};function hdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ddt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}hdt.isMDXComponent=!0;const fdt={toc:[]};function kdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}kdt.isMDXComponent=!0;const ydt={toc:[]};function Ddt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ydt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Ddt.isMDXComponent=!0;const Mdt={toc:[]};function wdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}wdt.isMDXComponent=!0;const _dt={toc:[]};function Xdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Xdt.isMDXComponent=!0;const gdt={toc:[]};function Tdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Tdt.isMDXComponent=!0;const Cdt={toc:[]};function xdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}xdt.isMDXComponent=!0;const vdt={toc:[]};function Ldt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Ldt.isMDXComponent=!0;const Zdt={toc:[]};function bdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}bdt.isMDXComponent=!0;const Ndt={toc:[]};function zdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ndt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}zdt.isMDXComponent=!0;const Adt={toc:[]};function Wdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Adt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Wdt.isMDXComponent=!0;const Idt={toc:[]};function Rdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Idt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Rdt.isMDXComponent=!0;const Pdt={toc:[]};function Sdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Sdt.isMDXComponent=!0;const Odt={toc:[]};function Edt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Odt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Edt.isMDXComponent=!0;const Bdt={toc:[]};function Gdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Gdt.isMDXComponent=!0;const Udt={toc:[]};function Fdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Udt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Fdt.isMDXComponent=!0;const Vdt={toc:[]};function qdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}qdt.isMDXComponent=!0;const jdt={toc:[]};function Hdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Hdt.isMDXComponent=!0;const Qdt={toc:[]};function Ydt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Ydt.isMDXComponent=!0;const $dt={toc:[]};function Kdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Kdt.isMDXComponent=!0;const Jdt={toc:[]};function tht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}tht.isMDXComponent=!0;const eht={toc:[]};function nht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}nht.isMDXComponent=!0;const oht={toc:[]};function pht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}pht.isMDXComponent=!0;const rht={toc:[]};function sht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}sht.isMDXComponent=!0;const cht={toc:[]};function iht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}iht.isMDXComponent=!0;const aht={toc:[]};function lht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lht.isMDXComponent=!0;const uht={toc:[]};function mht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}mht.isMDXComponent=!0;const dht={toc:[]};function hht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}hht.isMDXComponent=!0;const fht={toc:[]};function kht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}kht.isMDXComponent=!0;const yht={toc:[]};function Dht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Dht.isMDXComponent=!0;const Mht={toc:[]};function wht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}wht.isMDXComponent=!0;const _ht={toc:[]};function Xht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Xht.isMDXComponent=!0;const ght={toc:[]};function Tht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ght,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Tht.isMDXComponent=!0;const Cht={toc:[]};function xht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}xht.isMDXComponent=!0;const vht={toc:[]};function Lht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Lht.isMDXComponent=!0;const Zht={toc:[]};function bht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}bht.isMDXComponent=!0;const Nht={toc:[]};function zht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}zht.isMDXComponent=!0;const Aht={toc:[]};function Wht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Wht.isMDXComponent=!0;const Iht={toc:[]};function Rht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Rht.isMDXComponent=!0;const Pht={toc:[]};function Sht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Sht.isMDXComponent=!0;const Oht={toc:[]};function Eht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Eht.isMDXComponent=!0;const Bht={toc:[]};function Ght(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Ght.isMDXComponent=!0;const Uht={toc:[]};function Fht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Fht.isMDXComponent=!0;const Vht={toc:[]};function qht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}qht.isMDXComponent=!0;const jht={toc:[]};function Hht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Hht.isMDXComponent=!0;const Qht={toc:[]};function Yht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Yht.isMDXComponent=!0;const $ht={toc:[]};function Kht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Kht.isMDXComponent=!0;const Jht={toc:[]};function tft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}tft.isMDXComponent=!0;const eft={toc:[]};function nft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}nft.isMDXComponent=!0;const oft={toc:[]};function pft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}pft.isMDXComponent=!0;const rft={toc:[]};function sft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}sft.isMDXComponent=!0;const cft={toc:[]};function ift(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}ift.isMDXComponent=!0;const aft={toc:[]};function lft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}lft.isMDXComponent=!0;const uft={toc:[]};function mft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}mft.isMDXComponent=!0;const dft={toc:[]};function hft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}hft.isMDXComponent=!0;const fft={toc:[]};function kft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}kft.isMDXComponent=!0;const yft={toc:[]};function Dft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Dft.isMDXComponent=!0;const Mft={toc:[]};function wft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}wft.isMDXComponent=!0;const _ft={toc:[]};function Xft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Xft.isMDXComponent=!0;const gft={toc:[]};function Tft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Tft.isMDXComponent=!0;const Cft={toc:[]};function xft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}xft.isMDXComponent=!0;const vft={toc:[]};function Lft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Lft.isMDXComponent=!0;const Zft={toc:[]};function bft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}bft.isMDXComponent=!0;const Nft={toc:[]};function zft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}zft.isMDXComponent=!0;const Aft={toc:[]};function Wft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Wft.isMDXComponent=!0;const Ift={toc:[]};function Rft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ift,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Rft.isMDXComponent=!0;const Pft={toc:[]};function Sft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Sft.isMDXComponent=!0;const Oft={toc:[]};function Eft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Eft.isMDXComponent=!0;const Bft={toc:[]};function Gft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Gft.isMDXComponent=!0;const Uft={toc:[]};function Fft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Fft.isMDXComponent=!0;const Vft={toc:[]};function qft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qft.isMDXComponent=!0;const jft={toc:[]};function Hft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Hft.isMDXComponent=!0;const Qft={toc:[]};function Yft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Yft.isMDXComponent=!0;const $ft={toc:[]};function Kft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Kft.isMDXComponent=!0;const Jft={toc:[]};function tkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}tkt.isMDXComponent=!0;const ekt={toc:[]};function nkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ekt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}nkt.isMDXComponent=!0;const okt={toc:[]};function pkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},okt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}pkt.isMDXComponent=!0;const rkt={toc:[]};function skt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}skt.isMDXComponent=!0;const ckt={toc:[]};function ikt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ckt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}ikt.isMDXComponent=!0;const akt={toc:[]};function lkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},akt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}lkt.isMDXComponent=!0;const ukt={toc:[]};function mkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ukt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}mkt.isMDXComponent=!0;const dkt={toc:[]};function hkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}hkt.isMDXComponent=!0;const fkt={toc:[]};function kkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}kkt.isMDXComponent=!0;const ykt={toc:[]};function Dkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ykt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Dkt.isMDXComponent=!0;const Mkt={toc:[]};function wkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}wkt.isMDXComponent=!0;const _kt={toc:[]};function Xkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Xkt.isMDXComponent=!0;const gkt={toc:[]};function Tkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Tkt.isMDXComponent=!0;const Ckt={toc:[]};function xkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ckt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}xkt.isMDXComponent=!0;const vkt={toc:[]};function Lkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Lkt.isMDXComponent=!0;const Zkt={toc:[]};function bkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}bkt.isMDXComponent=!0;const Nkt={toc:[]};function zkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}zkt.isMDXComponent=!0;const Akt={toc:[]};function Wkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Akt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Wkt.isMDXComponent=!0;const Ikt={toc:[]};function Rkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ikt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Rkt.isMDXComponent=!0;const Pkt={toc:[]};function Skt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Skt.isMDXComponent=!0;const Okt={toc:[]};function Ekt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Okt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Ekt.isMDXComponent=!0;const Bkt={toc:[]};function Gkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Gkt.isMDXComponent=!0;const Ukt={toc:[]};function Fkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ukt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Fkt.isMDXComponent=!0;const Vkt={toc:[]};function qkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Latex, makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Latex\n      // Note how this uses \\color to set the color.\n      tex=\"{\\color{white} ax^2+bx+c=0 \\implies x=\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}}\"\n      width={600} // height and width can calculate based on each other\n    />,\n  );\n});\n")))}qkt.isMDXComponent=!0;const jkt={toc:[]};function Hkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for rendering equations with LaTeX."))}Hkt.isMDXComponent=!0;const Qkt={toc:[]};function Ykt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Ykt.isMDXComponent=!0;const $kt={toc:[]};function Kkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Kkt.isMDXComponent=!0;const Jkt={toc:[]};function tyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}tyt.isMDXComponent=!0;const eyt={toc:[]};function nyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}nyt.isMDXComponent=!0;const oyt={toc:[]};function pyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}pyt.isMDXComponent=!0;const ryt={toc:[]};function syt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ryt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}syt.isMDXComponent=!0;const cyt={toc:[]};function iyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}iyt.isMDXComponent=!0;const ayt={toc:[]};function lyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ayt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}lyt.isMDXComponent=!0;const uyt={toc:[]};function myt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}myt.isMDXComponent=!0;const dyt={toc:[]};function hyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}hyt.isMDXComponent=!0;const fyt={toc:[]};function kyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}kyt.isMDXComponent=!0;const yyt={toc:[]};function Dyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Dyt.isMDXComponent=!0;const Myt={toc:[]};function wyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Myt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}wyt.isMDXComponent=!0;const _yt={toc:[]};function Xyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Xyt.isMDXComponent=!0;const gyt={toc:[]};function Tyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Tyt.isMDXComponent=!0;const Cyt={toc:[]};function xyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}xyt.isMDXComponent=!0;const vyt={toc:[]};function Lyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Lyt.isMDXComponent=!0;const Zyt={toc:[]};function byt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}byt.isMDXComponent=!0;const Nyt={toc:[]};function zyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}zyt.isMDXComponent=!0;const Ayt={toc:[]};function Wyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ayt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Wyt.isMDXComponent=!0;const Iyt={toc:[]};function Ryt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Ryt.isMDXComponent=!0;const Pyt={toc:[]};function Syt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Syt.isMDXComponent=!0;const Oyt={toc:[]};function Eyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Eyt.isMDXComponent=!0;const Byt={toc:[]};function Gyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Byt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Gyt.isMDXComponent=!0;const Uyt={toc:[]};function Fyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Fyt.isMDXComponent=!0;const Vyt={toc:[]};function qyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}qyt.isMDXComponent=!0;const jyt={toc:[]};function Hyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Hyt.isMDXComponent=!0;const Qyt={toc:[]};function Yyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Yyt.isMDXComponent=!0;const $yt={toc:[]};function Kyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Kyt.isMDXComponent=!0;const Jyt={toc:[]};function tDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}tDt.isMDXComponent=!0;const eDt={toc:[]};function nDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}nDt.isMDXComponent=!0;const oDt={toc:[]};function pDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}pDt.isMDXComponent=!0;const rDt={toc:[]};function sDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}sDt.isMDXComponent=!0;const cDt={toc:[]};function iDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}iDt.isMDXComponent=!0;const aDt={toc:[]};function lDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}lDt.isMDXComponent=!0;const uDt={toc:[]};function mDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}mDt.isMDXComponent=!0;const dDt={toc:[]};function hDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}hDt.isMDXComponent=!0;const fDt={toc:[]};function kDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}kDt.isMDXComponent=!0;const yDt={toc:[]};function DDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}DDt.isMDXComponent=!0;const MDt={toc:[]};function wDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}wDt.isMDXComponent=!0;const _Dt={toc:[]};function XDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}XDt.isMDXComponent=!0;const gDt={toc:[]};function TDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}TDt.isMDXComponent=!0;const CDt={toc:[]};function xDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}xDt.isMDXComponent=!0;const vDt={toc:[]};function LDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}LDt.isMDXComponent=!0;const ZDt={toc:[]};function bDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}bDt.isMDXComponent=!0;const NDt={toc:[]};function zDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}zDt.isMDXComponent=!0;const ADt={toc:[]};function WDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}WDt.isMDXComponent=!0;const IDt={toc:[]};function RDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}RDt.isMDXComponent=!0;const PDt={toc:[]};function SDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}SDt.isMDXComponent=!0;const ODt={toc:[]};function EDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ODt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}EDt.isMDXComponent=!0;const BDt={toc:[]};function GDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}GDt.isMDXComponent=!0;const UDt={toc:[]};function FDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}FDt.isMDXComponent=!0;const VDt={toc:[]};function qDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}qDt.isMDXComponent=!0;const jDt={toc:[]};function HDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}HDt.isMDXComponent=!0;const QDt={toc:[]};function YDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}YDt.isMDXComponent=!0;const $Dt={toc:[]};function KDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}KDt.isMDXComponent=!0;const JDt={toc:[]};function tMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}tMt.isMDXComponent=!0;const eMt={toc:[]};function nMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nMt.isMDXComponent=!0;const oMt={toc:[]};function pMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}pMt.isMDXComponent=!0;const rMt={toc:[]};function sMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}sMt.isMDXComponent=!0;const cMt={toc:[]};function iMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}iMt.isMDXComponent=!0;const aMt={toc:[]};function lMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}lMt.isMDXComponent=!0;const uMt={toc:[]};function mMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}mMt.isMDXComponent=!0;const dMt={toc:[]};function hMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}hMt.isMDXComponent=!0;const fMt={toc:[]};function kMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}kMt.isMDXComponent=!0;const yMt={toc:[]};function DMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}DMt.isMDXComponent=!0;const MMt={toc:[]};function wMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}wMt.isMDXComponent=!0;const _Mt={toc:[]};function XMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}XMt.isMDXComponent=!0;const gMt={toc:[]};function TMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}TMt.isMDXComponent=!0;const CMt={toc:[]};function xMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}xMt.isMDXComponent=!0;const vMt={toc:[]};function LMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}LMt.isMDXComponent=!0;const ZMt={toc:[]};function bMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}bMt.isMDXComponent=!0;const NMt={toc:[]};function zMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}zMt.isMDXComponent=!0;const AMt={toc:[]};function WMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}WMt.isMDXComponent=!0;const IMt={toc:[]};function RMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}RMt.isMDXComponent=!0;const PMt={toc:[]};function SMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}SMt.isMDXComponent=!0;const OMt={toc:[]};function EMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}EMt.isMDXComponent=!0;const BMt={toc:[]};function GMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}GMt.isMDXComponent=!0;const UMt={toc:[]};function FMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}FMt.isMDXComponent=!0;const VMt={toc:[]};function qMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}qMt.isMDXComponent=!0;const jMt={toc:[]};function HMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}HMt.isMDXComponent=!0;const QMt={toc:[]};function YMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}YMt.isMDXComponent=!0;const $Mt={toc:[]};function KMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}KMt.isMDXComponent=!0;const JMt={toc:[]};function twt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}twt.isMDXComponent=!0;const ewt={toc:[]};function nwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ewt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}nwt.isMDXComponent=!0;const owt={toc:[]};function pwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},owt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}pwt.isMDXComponent=!0;const rwt={toc:[]};function swt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}swt.isMDXComponent=!0;const cwt={toc:[]};function iwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}iwt.isMDXComponent=!0;const awt={toc:[]};function lwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}lwt.isMDXComponent=!0;const uwt={toc:[]};function mwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}mwt.isMDXComponent=!0;const dwt={toc:[]};function hwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}hwt.isMDXComponent=!0;const fwt={toc:[]};function kwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}kwt.isMDXComponent=!0;const ywt={toc:[]};function Dwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ywt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Dwt.isMDXComponent=!0;const Mwt={toc:[]};function wwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}wwt.isMDXComponent=!0;const _wt={toc:[]};function Xwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Xwt.isMDXComponent=!0;const gwt={toc:[]};function Twt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Twt.isMDXComponent=!0;const Cwt={toc:[]};function xwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}xwt.isMDXComponent=!0;const vwt={toc:[]};function Lwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Lwt.isMDXComponent=!0;const Zwt={toc:[]};function bwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}bwt.isMDXComponent=!0;const Nwt={toc:[]};function zwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}zwt.isMDXComponent=!0;const Awt={toc:[]};function Wwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Wwt.isMDXComponent=!0;const Iwt={toc:[]};function Rwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Rwt.isMDXComponent=!0;const Pwt={toc:[]};function Swt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Swt.isMDXComponent=!0;const Owt={toc:[]};function Ewt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Owt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Ewt.isMDXComponent=!0;const Bwt={toc:[]};function Gwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}Gwt.isMDXComponent=!0;const Uwt={toc:[]};function Fwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}Fwt.isMDXComponent=!0;const Vwt={toc:[]};function qwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}qwt.isMDXComponent=!0;const jwt={toc:[]};function Hwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}Hwt.isMDXComponent=!0;const Qwt={toc:[]};function Ywt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Ywt.isMDXComponent=!0;const $wt={toc:[]};function Kwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Kwt.isMDXComponent=!0;const Jwt={toc:[]};function t_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}t_t.isMDXComponent=!0;const e_t={toc:[]};function n_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}n_t.isMDXComponent=!0;const o_t={toc:[]};function p_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}p_t.isMDXComponent=!0;const r_t={toc:[]};function s_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}s_t.isMDXComponent=!0;const c_t={toc:[]};function i_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}i_t.isMDXComponent=!0;const a_t={toc:[]};function l_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}l_t.isMDXComponent=!0;const u_t={toc:[]};function m_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}m_t.isMDXComponent=!0;const d_t={toc:[]};function h_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}h_t.isMDXComponent=!0;const f_t={toc:[]};function k_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}k_t.isMDXComponent=!0;const y_t={toc:[]};function D_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}D_t.isMDXComponent=!0;const M_t={toc:[]};function w_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}w_t.isMDXComponent=!0;const __t={toc:[]};function X_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},__t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}X_t.isMDXComponent=!0;const g_t={toc:[]};function T_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}T_t.isMDXComponent=!0;const C_t={toc:[]};function x_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}x_t.isMDXComponent=!0;const v_t={toc:[]};function L_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}L_t.isMDXComponent=!0;const Z_t={toc:[]};function b_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}b_t.isMDXComponent=!0;const N_t={toc:[]};function z_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}z_t.isMDXComponent=!0;const A_t={toc:[]};function W_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}W_t.isMDXComponent=!0;const I_t={toc:[]};function R_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}R_t.isMDXComponent=!0;const P_t={toc:[]};function S_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}S_t.isMDXComponent=!0;const O_t={toc:[]};function E_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}E_t.isMDXComponent=!0;const B_t={toc:[]};function G_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}G_t.isMDXComponent=!0;const U_t={toc:[]};function F_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}F_t.isMDXComponent=!0;const V_t={toc:[]};function q_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}q_t.isMDXComponent=!0;const j_t={toc:[]};function H_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}H_t.isMDXComponent=!0;const Q_t={toc:[]};function Y_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Y_t.isMDXComponent=!0;const $_t={toc:[]};function K_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}K_t.isMDXComponent=!0;const J_t={toc:[]};function tXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}tXt.isMDXComponent=!0;const eXt={toc:[]};function nXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}nXt.isMDXComponent=!0;const oXt={toc:[]};function pXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}pXt.isMDXComponent=!0;const rXt={toc:[]};function sXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}sXt.isMDXComponent=!0;const cXt={toc:[]};function iXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}iXt.isMDXComponent=!0;const aXt={toc:[]};function lXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}lXt.isMDXComponent=!0;const uXt={toc:[]};function mXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}mXt.isMDXComponent=!0;const dXt={toc:[]};function hXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}hXt.isMDXComponent=!0;const fXt={toc:[]};function kXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}kXt.isMDXComponent=!0;const yXt={toc:[]};function DXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}DXt.isMDXComponent=!0;const MXt={toc:[]};function wXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}wXt.isMDXComponent=!0;const _Xt={toc:[]};function XXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}XXt.isMDXComponent=!0;const gXt={toc:[]};function TXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}TXt.isMDXComponent=!0;const CXt={toc:[]};function xXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}xXt.isMDXComponent=!0;const vXt={toc:[]};function LXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}LXt.isMDXComponent=!0;const ZXt={toc:[]};function bXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}bXt.isMDXComponent=!0;const NXt={toc:[]};function zXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}zXt.isMDXComponent=!0;const AXt={toc:[]};function WXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}WXt.isMDXComponent=!0;const IXt={toc:[]};function RXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}RXt.isMDXComponent=!0;const PXt={toc:[]};function SXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}SXt.isMDXComponent=!0;const OXt={toc:[]};function EXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}EXt.isMDXComponent=!0;const BXt={toc:[]};function GXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}GXt.isMDXComponent=!0;const UXt={toc:[]};function FXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}FXt.isMDXComponent=!0;const VXt={toc:[]};function qXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}qXt.isMDXComponent=!0;const jXt={toc:[]};function HXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}HXt.isMDXComponent=!0;const QXt={toc:[]};function YXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}YXt.isMDXComponent=!0;const $Xt={toc:[]};function KXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}KXt.isMDXComponent=!0;const JXt={toc:[]};function tgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}tgt.isMDXComponent=!0;const egt={toc:[]};function ngt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},egt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}ngt.isMDXComponent=!0;const ogt={toc:[]};function pgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ogt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}pgt.isMDXComponent=!0;const rgt={toc:[]};function sgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}sgt.isMDXComponent=!0;const cgt={toc:[]};function igt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}igt.isMDXComponent=!0;const agt={toc:[]};function lgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},agt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}lgt.isMDXComponent=!0;const ugt={toc:[]};function mgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ugt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}mgt.isMDXComponent=!0;const dgt={toc:[]};function hgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}hgt.isMDXComponent=!0;const fgt={toc:[]};function kgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}kgt.isMDXComponent=!0;const ygt={toc:[]};function Dgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ygt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Dgt.isMDXComponent=!0;const Mgt={toc:[]};function wgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}wgt.isMDXComponent=!0;const _gt={toc:[]};function Xgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Xgt.isMDXComponent=!0;const ggt={toc:[]};function Tgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ggt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Tgt.isMDXComponent=!0;const Cgt={toc:[]};function xgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}xgt.isMDXComponent=!0;const vgt={toc:[]};function Lgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Lgt.isMDXComponent=!0;const Zgt={toc:[]};function bgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}bgt.isMDXComponent=!0;const Ngt={toc:[]};function zgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ngt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}zgt.isMDXComponent=!0;const Agt={toc:[]};function Wgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Agt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Wgt.isMDXComponent=!0;const Igt={toc:[]};function Rgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Igt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Rgt.isMDXComponent=!0;const Pgt={toc:[]};function Sgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Sgt.isMDXComponent=!0;const Ogt={toc:[]};function Egt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ogt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Egt.isMDXComponent=!0;const Bgt={toc:[]};function Ggt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Ggt.isMDXComponent=!0;const Ugt={toc:[]};function Fgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ugt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Fgt.isMDXComponent=!0;const Vgt={toc:[]};function qgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qgt.isMDXComponent=!0;const jgt={toc:[]};function Hgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Hgt.isMDXComponent=!0;const Qgt={toc:[]};function Ygt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Ygt.isMDXComponent=!0;const $gt={toc:[]};function Kgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Kgt.isMDXComponent=!0;const Jgt={toc:[]};function tTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}tTt.isMDXComponent=!0;const eTt={toc:[]};function nTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}nTt.isMDXComponent=!0;const oTt={toc:[]};function pTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}pTt.isMDXComponent=!0;const rTt={toc:[]};function sTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}sTt.isMDXComponent=!0;const cTt={toc:[]};function iTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}iTt.isMDXComponent=!0;const aTt={toc:[]};function lTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}lTt.isMDXComponent=!0;const uTt={toc:[]};function mTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}mTt.isMDXComponent=!0;const dTt={toc:[]};function hTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}hTt.isMDXComponent=!0;const fTt={toc:[]};function kTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}kTt.isMDXComponent=!0;const yTt={toc:[]};function DTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}DTt.isMDXComponent=!0;const MTt={toc:[]};function wTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}wTt.isMDXComponent=!0;const _Tt={toc:[]};function XTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Tt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}XTt.isMDXComponent=!0;const gTt={toc:[]};function TTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}TTt.isMDXComponent=!0;const CTt={toc:[]};function xTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}xTt.isMDXComponent=!0;const vTt={toc:[]};function LTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}LTt.isMDXComponent=!0;const ZTt={toc:[]};function bTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}bTt.isMDXComponent=!0;const NTt={toc:[]};function zTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}zTt.isMDXComponent=!0;const ATt={toc:[]};function WTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ATt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}WTt.isMDXComponent=!0;const ITt={toc:[]};function RTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ITt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}RTt.isMDXComponent=!0;const PTt={toc:[]};function STt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}STt.isMDXComponent=!0;const OTt={toc:[]};function ETt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}ETt.isMDXComponent=!0;const BTt={toc:[]};function GTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}GTt.isMDXComponent=!0;const UTt={toc:[]};function FTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}FTt.isMDXComponent=!0;const VTt={toc:[]};function qTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}qTt.isMDXComponent=!0;const jTt={toc:[]};function HTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}HTt.isMDXComponent=!0;const QTt={toc:[]};function YTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}YTt.isMDXComponent=!0;const $Tt={toc:[]};function KTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Tt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}KTt.isMDXComponent=!0;const JTt={toc:[]};function tCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}tCt.isMDXComponent=!0;const eCt={toc:[]};function nCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}nCt.isMDXComponent=!0;const oCt={toc:[]};function pCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}pCt.isMDXComponent=!0;const rCt={toc:[]};function sCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}sCt.isMDXComponent=!0;const cCt={toc:[]};function iCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}iCt.isMDXComponent=!0;const aCt={toc:[]};function lCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}lCt.isMDXComponent=!0;const uCt={toc:[]};function mCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}mCt.isMDXComponent=!0;const dCt={toc:[]};function hCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}hCt.isMDXComponent=!0;const fCt={toc:[]};function kCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}kCt.isMDXComponent=!0;const yCt={toc:[]};function DCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}DCt.isMDXComponent=!0;const MCt={toc:[]};function wCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}wCt.isMDXComponent=!0;const _Ct={toc:[]};function XCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}XCt.isMDXComponent=!0;const gCt={toc:[]};function TCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}TCt.isMDXComponent=!0;const CCt={toc:[]};function xCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}xCt.isMDXComponent=!0;const vCt={toc:[]};function LCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}LCt.isMDXComponent=!0;const ZCt={toc:[]};function bCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}bCt.isMDXComponent=!0;const NCt={toc:[]};function zCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}zCt.isMDXComponent=!0;const ACt={toc:[]};function WCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ACt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}WCt.isMDXComponent=!0;const ICt={toc:[]};function RCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ICt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}RCt.isMDXComponent=!0;const PCt={toc:[]};function SCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}SCt.isMDXComponent=!0;const OCt={toc:[]};function ECt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}ECt.isMDXComponent=!0;const BCt={toc:[]};function GCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}GCt.isMDXComponent=!0;const UCt={toc:[]};function FCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}FCt.isMDXComponent=!0;const VCt={toc:[]};function qCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}qCt.isMDXComponent=!0;const jCt={toc:[]};function HCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}HCt.isMDXComponent=!0;const QCt={toc:[]};function YCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}YCt.isMDXComponent=!0;const $Ct={toc:[]};function KCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}KCt.isMDXComponent=!0;const JCt={toc:[]};function txt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}txt.isMDXComponent=!0;const ext={toc:[]};function nxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ext,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}nxt.isMDXComponent=!0;const oxt={toc:[]};function pxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pxt.isMDXComponent=!0;const rxt={toc:[]};function sxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}sxt.isMDXComponent=!0;const cxt={toc:[]};function ixt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}ixt.isMDXComponent=!0;const axt={toc:[]};function lxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},axt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lxt.isMDXComponent=!0;const uxt={toc:[]};function mxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}mxt.isMDXComponent=!0;const dxt={toc:[]};function hxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}hxt.isMDXComponent=!0;const fxt={toc:[]};function kxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kxt.isMDXComponent=!0;const yxt={toc:[]};function Dxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Dxt.isMDXComponent=!0;const Mxt={toc:[]};function wxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}wxt.isMDXComponent=!0;const _xt={toc:[]};function Xxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Xxt.isMDXComponent=!0;const gxt={toc:[]};function Txt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Txt.isMDXComponent=!0;const Cxt={toc:[]};function xxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}xxt.isMDXComponent=!0;const vxt={toc:[]};function Lxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Lxt.isMDXComponent=!0;const Zxt={toc:[]};function bxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}bxt.isMDXComponent=!0;const Nxt={toc:[]};function zxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}zxt.isMDXComponent=!0;const Axt={toc:[]};function Wxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Axt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Wxt.isMDXComponent=!0;const Ixt={toc:[]};function Rxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ixt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Rxt.isMDXComponent=!0;const Pxt={toc:[]};function Sxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Sxt.isMDXComponent=!0;const Oxt={toc:[]};function Ext(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Ext.isMDXComponent=!0;const Bxt={toc:[]};function Gxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Gxt.isMDXComponent=!0;const Uxt={toc:[]};function Fxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Fxt.isMDXComponent=!0;const Vxt={toc:[]};function qxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}qxt.isMDXComponent=!0;const jxt={toc:[]};function Hxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Hxt.isMDXComponent=!0;const Qxt={toc:[]};function Yxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Yxt.isMDXComponent=!0;const $xt={toc:[]};function Kxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Kxt.isMDXComponent=!0;const Jxt={toc:[]};function tvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}tvt.isMDXComponent=!0;const evt={toc:[]};function nvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},evt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}nvt.isMDXComponent=!0;const ovt={toc:[]};function pvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ovt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}pvt.isMDXComponent=!0;const rvt={toc:[]};function svt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}svt.isMDXComponent=!0;const cvt={toc:[]};function ivt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}ivt.isMDXComponent=!0;const avt={toc:[]};function lvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},avt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}lvt.isMDXComponent=!0;const uvt={toc:[]};function mvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}mvt.isMDXComponent=!0;const dvt={toc:[]};function hvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}hvt.isMDXComponent=!0;const fvt={toc:[]};function kvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}kvt.isMDXComponent=!0;const yvt={toc:[]};function Dvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Dvt.isMDXComponent=!0;const Mvt={toc:[]};function wvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wvt.isMDXComponent=!0;const _vt={toc:[]};function Xvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Xvt.isMDXComponent=!0;const gvt={toc:[]};function Tvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Tvt.isMDXComponent=!0;const Cvt={toc:[]};function xvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}xvt.isMDXComponent=!0;const vvt={toc:[]};function Lvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Lvt.isMDXComponent=!0;const Zvt={toc:[]};function bvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}bvt.isMDXComponent=!0;const Nvt={toc:[]};function zvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}zvt.isMDXComponent=!0;const Avt={toc:[]};function Wvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Avt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Wvt.isMDXComponent=!0;const Ivt={toc:[]};function Rvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ivt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Rvt.isMDXComponent=!0;const Pvt={toc:[]};function Svt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Svt.isMDXComponent=!0;const Ovt={toc:[]};function Evt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ovt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Evt.isMDXComponent=!0;const Bvt={toc:[]};function Gvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Gvt.isMDXComponent=!0;const Uvt={toc:[]};function Fvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Fvt.isMDXComponent=!0;const Vvt={toc:[]};function qvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}qvt.isMDXComponent=!0;const jvt={toc:[]};function Hvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Hvt.isMDXComponent=!0;const Qvt={toc:[]};function Yvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Yvt.isMDXComponent=!0;const $vt={toc:[]};function Kvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Kvt.isMDXComponent=!0;const Jvt={toc:[]};function tLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}tLt.isMDXComponent=!0;const eLt={toc:[]};function nLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}nLt.isMDXComponent=!0;const oLt={toc:[]};function pLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}pLt.isMDXComponent=!0;const rLt={toc:[]};function sLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}sLt.isMDXComponent=!0;const cLt={toc:[]};function iLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}iLt.isMDXComponent=!0;const aLt={toc:[]};function lLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lLt.isMDXComponent=!0;const uLt={toc:[]};function mLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}mLt.isMDXComponent=!0;const dLt={toc:[]};function hLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}hLt.isMDXComponent=!0;const fLt={toc:[]};function kLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}kLt.isMDXComponent=!0;const yLt={toc:[]};function DLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}DLt.isMDXComponent=!0;const MLt={toc:[]};function wLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}wLt.isMDXComponent=!0;const _Lt={toc:[]};function XLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}XLt.isMDXComponent=!0;const gLt={toc:[]};function TLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}TLt.isMDXComponent=!0;const CLt={toc:[]};function xLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}xLt.isMDXComponent=!0;const vLt={toc:[]};function LLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}LLt.isMDXComponent=!0;const ZLt={toc:[]};function bLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}bLt.isMDXComponent=!0;const NLt={toc:[]};function zLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}zLt.isMDXComponent=!0;const ALt={toc:[]};function WLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ALt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}WLt.isMDXComponent=!0;const ILt={toc:[]};function RLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ILt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}RLt.isMDXComponent=!0;const PLt={toc:[]};function SLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}SLt.isMDXComponent=!0;const OLt={toc:[]};function ELt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}ELt.isMDXComponent=!0;const BLt={toc:[]};function GLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}GLt.isMDXComponent=!0;const ULt={toc:[]};function FLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ULt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}FLt.isMDXComponent=!0;const VLt={toc:[]};function qLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qLt.isMDXComponent=!0;const jLt={toc:[]};function HLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}HLt.isMDXComponent=!0;const QLt={toc:[]};function YLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}YLt.isMDXComponent=!0;const $Lt={toc:[]};function KLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}KLt.isMDXComponent=!0;const JLt={toc:[]};function tZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}tZt.isMDXComponent=!0;const eZt={toc:[]};function nZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}nZt.isMDXComponent=!0;const oZt={toc:[]};function pZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}pZt.isMDXComponent=!0;const rZt={toc:[]};function sZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}sZt.isMDXComponent=!0;const cZt={toc:[]};function iZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}iZt.isMDXComponent=!0;const aZt={toc:[]};function lZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lZt.isMDXComponent=!0;const uZt={toc:[]};function mZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}mZt.isMDXComponent=!0;const dZt={toc:[]};function hZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}hZt.isMDXComponent=!0;const fZt={toc:[]};function kZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}kZt.isMDXComponent=!0;const yZt={toc:[]};function DZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}DZt.isMDXComponent=!0;const MZt={toc:[]};function wZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}wZt.isMDXComponent=!0;const _Zt={toc:[]};function XZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}XZt.isMDXComponent=!0;const gZt={toc:[]};function TZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}TZt.isMDXComponent=!0;const CZt={toc:[]};function xZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}xZt.isMDXComponent=!0;const vZt={toc:[]};function LZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}LZt.isMDXComponent=!0;const ZZt={toc:[]};function bZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}bZt.isMDXComponent=!0;const NZt={toc:[]};function zZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zZt.isMDXComponent=!0;const AZt={toc:[]};function WZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}WZt.isMDXComponent=!0;const IZt={toc:[]};function RZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}RZt.isMDXComponent=!0;const PZt={toc:[]};function SZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}SZt.isMDXComponent=!0;const OZt={toc:[]};function EZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}EZt.isMDXComponent=!0;const BZt={toc:[]};function GZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}GZt.isMDXComponent=!0;const UZt={toc:[]};function FZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}FZt.isMDXComponent=!0;const VZt={toc:[]};function qZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qZt.isMDXComponent=!0;const jZt={toc:[]};function HZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}HZt.isMDXComponent=!0;const QZt={toc:[]};function YZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}YZt.isMDXComponent=!0;const $Zt={toc:[]};function KZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}KZt.isMDXComponent=!0;const JZt={toc:[]};function tbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}tbt.isMDXComponent=!0;const ebt={toc:[]};function nbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ebt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}nbt.isMDXComponent=!0;const obt={toc:[]};function pbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},obt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}pbt.isMDXComponent=!0;const rbt={toc:[]};function sbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}sbt.isMDXComponent=!0;const cbt={toc:[]};function ibt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}ibt.isMDXComponent=!0;const abt={toc:[]};function lbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},abt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}lbt.isMDXComponent=!0;const ubt={toc:[]};function mbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ubt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}mbt.isMDXComponent=!0;const dbt={toc:[]};function hbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}hbt.isMDXComponent=!0;const fbt={toc:[]};function kbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}kbt.isMDXComponent=!0;const ybt={toc:[]};function Dbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ybt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Dbt.isMDXComponent=!0;const Mbt={toc:[]};function wbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}wbt.isMDXComponent=!0;const _bt={toc:[]};function Xbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Xbt.isMDXComponent=!0;const gbt={toc:[]};function Tbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Tbt.isMDXComponent=!0;const Cbt={toc:[]};function xbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}xbt.isMDXComponent=!0;const vbt={toc:[]};function Lbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Lbt.isMDXComponent=!0;const Zbt={toc:[]};function bbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}bbt.isMDXComponent=!0;const Nbt={toc:[]};function zbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}zbt.isMDXComponent=!0;const Abt={toc:[]};function Wbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Abt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Wbt.isMDXComponent=!0;const Ibt={toc:[]};function Rbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ibt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Rbt.isMDXComponent=!0;const Pbt={toc:[]};function Sbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Sbt.isMDXComponent=!0;const Obt={toc:[]};function Ebt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Obt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ebt.isMDXComponent=!0;const Bbt={toc:[]};function Gbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Gbt.isMDXComponent=!0;const Ubt={toc:[]};function Fbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ubt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Fbt.isMDXComponent=!0;const Vbt={toc:[]};function qbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}qbt.isMDXComponent=!0;const jbt={toc:[]};function Hbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Hbt.isMDXComponent=!0;const Qbt={toc:[]};function Ybt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Ybt.isMDXComponent=!0;const $bt={toc:[]};function Kbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Kbt.isMDXComponent=!0;const Jbt={toc:[]};function tNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}tNt.isMDXComponent=!0;const eNt={toc:[]};function nNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}nNt.isMDXComponent=!0;const oNt={toc:[]};function pNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}pNt.isMDXComponent=!0;const rNt={toc:[]};function sNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}sNt.isMDXComponent=!0;const cNt={toc:[]};function iNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}iNt.isMDXComponent=!0;const aNt={toc:[]};function lNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}lNt.isMDXComponent=!0;const uNt={toc:[]};function mNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}mNt.isMDXComponent=!0;const dNt={toc:[]};function hNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}hNt.isMDXComponent=!0;const fNt={toc:[]};function kNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}kNt.isMDXComponent=!0;const yNt={toc:[]};function DNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}DNt.isMDXComponent=!0;const MNt={toc:[]};function wNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}wNt.isMDXComponent=!0;const _Nt={toc:[]};function XNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}XNt.isMDXComponent=!0;const gNt={toc:[]};function TNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}TNt.isMDXComponent=!0;const CNt={toc:[]};function xNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}xNt.isMDXComponent=!0;const vNt={toc:[]};function LNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}LNt.isMDXComponent=!0;const ZNt={toc:[]};function bNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}bNt.isMDXComponent=!0;const NNt={toc:[]};function zNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}zNt.isMDXComponent=!0;const ANt={toc:[]};function WNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ANt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}WNt.isMDXComponent=!0;const INt={toc:[]};function RNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},INt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}RNt.isMDXComponent=!0;const PNt={toc:[]};function SNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}SNt.isMDXComponent=!0;const ONt={toc:[]};function ENt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ONt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}ENt.isMDXComponent=!0;const BNt={toc:[]};function GNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}GNt.isMDXComponent=!0;const UNt={toc:[]};function FNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}FNt.isMDXComponent=!0;const VNt={toc:[]};function qNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}qNt.isMDXComponent=!0;const jNt={toc:[]};function HNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}HNt.isMDXComponent=!0;const QNt={toc:[]};function YNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}YNt.isMDXComponent=!0;const $Nt={toc:[]};function KNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}KNt.isMDXComponent=!0;const JNt={toc:[]};function tzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}tzt.isMDXComponent=!0;const ezt={toc:[]};function nzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ezt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}nzt.isMDXComponent=!0;const ozt={toc:[]};function pzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ozt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pzt.isMDXComponent=!0;const rzt={toc:[]};function szt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}szt.isMDXComponent=!0;const czt={toc:[]};function izt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},czt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}izt.isMDXComponent=!0;const azt={toc:[]};function lzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},azt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}lzt.isMDXComponent=!0;const uzt={toc:[]};function mzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}mzt.isMDXComponent=!0;const dzt={toc:[]};function hzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}hzt.isMDXComponent=!0;const fzt={toc:[]};function kzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}kzt.isMDXComponent=!0;const yzt={toc:[]};function Dzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Dzt.isMDXComponent=!0;const Mzt={toc:[]};function wzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wzt.isMDXComponent=!0;const _zt={toc:[]};function Xzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Xzt.isMDXComponent=!0;const gzt={toc:[]};function Tzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Tzt.isMDXComponent=!0;const Czt={toc:[]};function xzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Czt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}xzt.isMDXComponent=!0;const vzt={toc:[]};function Lzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Lzt.isMDXComponent=!0;const Zzt={toc:[]};function bzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}bzt.isMDXComponent=!0;const Nzt={toc:[]};function zzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}zzt.isMDXComponent=!0;const Azt={toc:[]};function Wzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Azt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Wzt.isMDXComponent=!0;const Izt={toc:[]};function Rzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Izt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Rzt.isMDXComponent=!0;const Pzt={toc:[]};function Szt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Szt.isMDXComponent=!0;const Ozt={toc:[]};function Ezt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ozt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Ezt.isMDXComponent=!0;const Bzt={toc:[]};function Gzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Gzt.isMDXComponent=!0;const Uzt={toc:[]};function Fzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Fzt.isMDXComponent=!0;const Vzt={toc:[]};function qzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}qzt.isMDXComponent=!0;const jzt={toc:[]};function Hzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Hzt.isMDXComponent=!0;const Qzt={toc:[]};function Yzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Yzt.isMDXComponent=!0;const $zt={toc:[]};function Kzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Kzt.isMDXComponent=!0;const Jzt={toc:[]};function tAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}tAt.isMDXComponent=!0;const eAt={toc:[]};function nAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}nAt.isMDXComponent=!0;const oAt={toc:[]};function pAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}pAt.isMDXComponent=!0;const rAt={toc:[]};function sAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}sAt.isMDXComponent=!0;const cAt={toc:[]};function iAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}iAt.isMDXComponent=!0;const aAt={toc:[]};function lAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}lAt.isMDXComponent=!0;const uAt={toc:[]};function mAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}mAt.isMDXComponent=!0;const dAt={toc:[]};function hAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}hAt.isMDXComponent=!0;const fAt={toc:[]};function kAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}kAt.isMDXComponent=!0;const yAt={toc:[]};function DAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}DAt.isMDXComponent=!0;const MAt={toc:[]};function wAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}wAt.isMDXComponent=!0;const _At={toc:[]};function XAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_At,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}XAt.isMDXComponent=!0;const gAt={toc:[]};function TAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}TAt.isMDXComponent=!0;const CAt={toc:[]};function xAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}xAt.isMDXComponent=!0;const vAt={toc:[]};function LAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}LAt.isMDXComponent=!0;const ZAt={toc:[]};function bAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}bAt.isMDXComponent=!0;const NAt={toc:[]};function zAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}zAt.isMDXComponent=!0;const AAt={toc:[]};function WAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}WAt.isMDXComponent=!0;const IAt={toc:[]};function RAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}RAt.isMDXComponent=!0;const PAt={toc:[]};function SAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}SAt.isMDXComponent=!0;const OAt={toc:[]};function EAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}EAt.isMDXComponent=!0;const BAt={toc:[]};function GAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}GAt.isMDXComponent=!0;const UAt={toc:[]};function FAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}FAt.isMDXComponent=!0;const VAt={toc:[]};function qAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}qAt.isMDXComponent=!0;const jAt={toc:[]};function HAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}HAt.isMDXComponent=!0;const QAt={toc:[]};function YAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}YAt.isMDXComponent=!0;const $At={toc:[]};function KAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$At,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}KAt.isMDXComponent=!0;const JAt={toc:[]};function tWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}tWt.isMDXComponent=!0;const eWt={toc:[]};function nWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}nWt.isMDXComponent=!0;const oWt={toc:[]};function pWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}pWt.isMDXComponent=!0;const rWt={toc:[]};function sWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}sWt.isMDXComponent=!0;const cWt={toc:[]};function iWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}iWt.isMDXComponent=!0;const aWt={toc:[]};function lWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}lWt.isMDXComponent=!0;const uWt={toc:[]};function mWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}mWt.isMDXComponent=!0;const dWt={toc:[]};function hWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hWt.isMDXComponent=!0;const fWt={toc:[]};function kWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}kWt.isMDXComponent=!0;const yWt={toc:[]};function DWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}DWt.isMDXComponent=!0;const MWt={toc:[]};function wWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}wWt.isMDXComponent=!0;const _Wt={toc:[]};function XWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}XWt.isMDXComponent=!0;const gWt={toc:[]};function TWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}TWt.isMDXComponent=!0;const CWt={toc:[]};function xWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}xWt.isMDXComponent=!0;const vWt={toc:[]};function LWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}LWt.isMDXComponent=!0;const ZWt={toc:[]};function bWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}bWt.isMDXComponent=!0;const NWt={toc:[]};function zWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}zWt.isMDXComponent=!0;const AWt={toc:[]};function WWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}WWt.isMDXComponent=!0;const IWt={toc:[]};function RWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}RWt.isMDXComponent=!0;const PWt={toc:[]};function SWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}SWt.isMDXComponent=!0;const OWt={toc:[]};function EWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}EWt.isMDXComponent=!0;const BWt={toc:[]};function GWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}GWt.isMDXComponent=!0;const UWt={toc:[]};function FWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}FWt.isMDXComponent=!0;const VWt={toc:[]};function qWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}qWt.isMDXComponent=!0;const jWt={toc:[]};function HWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}HWt.isMDXComponent=!0;const QWt={toc:[]};function YWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}YWt.isMDXComponent=!0;const $Wt={toc:[]};function KWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}KWt.isMDXComponent=!0;const JWt={toc:[]};function tIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}tIt.isMDXComponent=!0;const eIt={toc:[]};function nIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}nIt.isMDXComponent=!0;const oIt={toc:[]};function pIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}pIt.isMDXComponent=!0;const rIt={toc:[]};function sIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}sIt.isMDXComponent=!0;const cIt={toc:[]};function iIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}iIt.isMDXComponent=!0;const aIt={toc:[]};function lIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lIt.isMDXComponent=!0;const uIt={toc:[]};function mIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}mIt.isMDXComponent=!0;const dIt={toc:[]};function hIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}hIt.isMDXComponent=!0;const fIt={toc:[]};function kIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}kIt.isMDXComponent=!0;const yIt={toc:[]};function DIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}DIt.isMDXComponent=!0;const MIt={toc:[]};function wIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}wIt.isMDXComponent=!0;const _It={toc:[]};function XIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_It,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}XIt.isMDXComponent=!0;const gIt={toc:[]};function TIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}TIt.isMDXComponent=!0;const CIt={toc:[]};function xIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}xIt.isMDXComponent=!0;const vIt={toc:[]};function LIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}LIt.isMDXComponent=!0;const ZIt={toc:[]};function bIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}bIt.isMDXComponent=!0;const NIt={toc:[]};function zIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}zIt.isMDXComponent=!0;const AIt={toc:[]};function WIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}WIt.isMDXComponent=!0;const IIt={toc:[]};function RIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}RIt.isMDXComponent=!0;const PIt={toc:[]};function SIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}SIt.isMDXComponent=!0;const OIt={toc:[]};function EIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}EIt.isMDXComponent=!0;const BIt={toc:[]};function GIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}GIt.isMDXComponent=!0;const UIt={toc:[]};function FIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}FIt.isMDXComponent=!0;const VIt={toc:[]};function qIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}qIt.isMDXComponent=!0;const jIt={toc:[]};function HIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}HIt.isMDXComponent=!0;const QIt={toc:[]};function YIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}YIt.isMDXComponent=!0;const $It={toc:[]};function KIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$It,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}KIt.isMDXComponent=!0;const JIt={toc:[]};function tRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}tRt.isMDXComponent=!0;const eRt={toc:[]};function nRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}nRt.isMDXComponent=!0;const oRt={toc:[]};function pRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}pRt.isMDXComponent=!0;const rRt={toc:[]};function sRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}sRt.isMDXComponent=!0;const cRt={toc:[]};function iRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}iRt.isMDXComponent=!0;const aRt={toc:[]};function lRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}lRt.isMDXComponent=!0;const uRt={toc:[]};function mRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}mRt.isMDXComponent=!0;const dRt={toc:[]};function hRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}hRt.isMDXComponent=!0;const fRt={toc:[]};function kRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}kRt.isMDXComponent=!0;const yRt={toc:[]};function DRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}DRt.isMDXComponent=!0;const MRt={toc:[]};function wRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}wRt.isMDXComponent=!0;const _Rt={toc:[]};function XRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}XRt.isMDXComponent=!0;const gRt={toc:[]};function TRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}TRt.isMDXComponent=!0;const CRt={toc:[]};function xRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}xRt.isMDXComponent=!0;const vRt={toc:[]};function LRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}LRt.isMDXComponent=!0;const ZRt={toc:[]};function bRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}bRt.isMDXComponent=!0;const NRt={toc:[]};function zRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}zRt.isMDXComponent=!0;const ARt={toc:[]};function WRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ARt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}WRt.isMDXComponent=!0;const IRt={toc:[]};function RRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}RRt.isMDXComponent=!0;const PRt={toc:[]};function SRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}SRt.isMDXComponent=!0;const ORt={toc:[]};function ERt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ORt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ERt.isMDXComponent=!0;const BRt={toc:[]};function GRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}GRt.isMDXComponent=!0;const URt={toc:[]};function FRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},URt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}FRt.isMDXComponent=!0;const VRt={toc:[]};function qRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}qRt.isMDXComponent=!0;const jRt={toc:[]};function HRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}HRt.isMDXComponent=!0;const QRt={toc:[]};function YRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}YRt.isMDXComponent=!0;const $Rt={toc:[]};function KRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}KRt.isMDXComponent=!0;const JRt={toc:[]};function tPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}tPt.isMDXComponent=!0;const ePt={toc:[]};function nPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ePt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}nPt.isMDXComponent=!0;const oPt={toc:[]};function pPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}pPt.isMDXComponent=!0;const rPt={toc:[]};function sPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}sPt.isMDXComponent=!0;const cPt={toc:[]};function iPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}iPt.isMDXComponent=!0;const aPt={toc:[]};function lPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}lPt.isMDXComponent=!0;const uPt={toc:[]};function mPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}mPt.isMDXComponent=!0;const dPt={toc:[]};function hPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}hPt.isMDXComponent=!0;const fPt={toc:[]};function kPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}kPt.isMDXComponent=!0;const yPt={toc:[]};function DPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}DPt.isMDXComponent=!0;const MPt={toc:[]};function wPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}wPt.isMDXComponent=!0;const _Pt={toc:[]};function XPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}XPt.isMDXComponent=!0;const gPt={toc:[]};function TPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}TPt.isMDXComponent=!0;const CPt={toc:[]};function xPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}xPt.isMDXComponent=!0;const vPt={toc:[]};function LPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}LPt.isMDXComponent=!0;const ZPt={toc:[]};function bPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}bPt.isMDXComponent=!0;const NPt={toc:[]};function zPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}zPt.isMDXComponent=!0;const APt={toc:[]};function WPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},APt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}WPt.isMDXComponent=!0;const IPt={toc:[]};function RPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}RPt.isMDXComponent=!0;const PPt={toc:[]};function SPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}SPt.isMDXComponent=!0;const OPt={toc:[]};function EPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}EPt.isMDXComponent=!0;const BPt={toc:[]};function GPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}GPt.isMDXComponent=!0;const UPt={toc:[]};function FPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}FPt.isMDXComponent=!0;const VPt={toc:[]};function qPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}qPt.isMDXComponent=!0;const jPt={toc:[]};function HPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}HPt.isMDXComponent=!0;const QPt={toc:[]};function YPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}YPt.isMDXComponent=!0;const $Pt={toc:[]};function KPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}KPt.isMDXComponent=!0;const JPt={toc:[]};function tSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}tSt.isMDXComponent=!0;const eSt={toc:[]};function nSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}nSt.isMDXComponent=!0;const oSt={toc:[]};function pSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}pSt.isMDXComponent=!0;const rSt={toc:[]};function sSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}sSt.isMDXComponent=!0;const cSt={toc:[]};function iSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}iSt.isMDXComponent=!0;const aSt={toc:[]};function lSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}lSt.isMDXComponent=!0;const uSt={toc:[]};function mSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}mSt.isMDXComponent=!0;const dSt={toc:[]};function hSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}hSt.isMDXComponent=!0;const fSt={toc:[]};function kSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}kSt.isMDXComponent=!0;const ySt={toc:[]};function DSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ySt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}DSt.isMDXComponent=!0;const MSt={toc:[]};function wSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}wSt.isMDXComponent=!0;const _St={toc:[]};function XSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_St,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}XSt.isMDXComponent=!0;const gSt={toc:[]};function TSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}TSt.isMDXComponent=!0;const CSt={toc:[]};function xSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}xSt.isMDXComponent=!0;const vSt={toc:[]};function LSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}LSt.isMDXComponent=!0;const ZSt={toc:[]};function bSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}bSt.isMDXComponent=!0;const NSt={toc:[]};function zSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}zSt.isMDXComponent=!0;const ASt={toc:[]};function WSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ASt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}WSt.isMDXComponent=!0;const ISt={toc:[]};function RSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ISt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}RSt.isMDXComponent=!0;const PSt={toc:[]};function SSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}SSt.isMDXComponent=!0;const OSt={toc:[]};function ESt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}ESt.isMDXComponent=!0;const BSt={toc:[]};function GSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}GSt.isMDXComponent=!0;const USt={toc:[]};function FSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},USt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}FSt.isMDXComponent=!0;const VSt={toc:[]};function qSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}qSt.isMDXComponent=!0;const jSt={toc:[]};function HSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}HSt.isMDXComponent=!0;const QSt={toc:[]};function YSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}YSt.isMDXComponent=!0;const $St={toc:[]};function KSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$St,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}KSt.isMDXComponent=!0;const JSt={toc:[]};function tOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}tOt.isMDXComponent=!0;const eOt={toc:[]};function nOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}nOt.isMDXComponent=!0;const oOt={toc:[]};function pOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}pOt.isMDXComponent=!0;const rOt={toc:[]};function sOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}sOt.isMDXComponent=!0;const cOt={toc:[]};function iOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}iOt.isMDXComponent=!0;const aOt={toc:[]};function lOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lOt.isMDXComponent=!0;const uOt={toc:[]};function mOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}mOt.isMDXComponent=!0;const dOt={toc:[]};function hOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}hOt.isMDXComponent=!0;const fOt={toc:[]};function kOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}kOt.isMDXComponent=!0;const yOt={toc:[]};function DOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}DOt.isMDXComponent=!0;const MOt={toc:[]};function wOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wOt.isMDXComponent=!0;const _Ot={toc:[]};function XOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}XOt.isMDXComponent=!0;const gOt={toc:[]};function TOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}TOt.isMDXComponent=!0;const COt={toc:[]};function xOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},COt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}xOt.isMDXComponent=!0;const vOt={toc:[]};function LOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}LOt.isMDXComponent=!0;const ZOt={toc:[]};function bOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}bOt.isMDXComponent=!0;const NOt={toc:[]};function zOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}zOt.isMDXComponent=!0;const AOt={toc:[]};function WOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}WOt.isMDXComponent=!0;const IOt={toc:[]};function ROt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}ROt.isMDXComponent=!0;const POt={toc:[]};function SOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},POt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}SOt.isMDXComponent=!0;const OOt={toc:[]};function EOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}EOt.isMDXComponent=!0;const BOt={toc:[]};function GOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}GOt.isMDXComponent=!0;const UOt={toc:[]};function FOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}FOt.isMDXComponent=!0;const VOt={toc:[]};function qOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qOt.isMDXComponent=!0;const jOt={toc:[]};function HOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}HOt.isMDXComponent=!0;const QOt={toc:[]};function YOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}YOt.isMDXComponent=!0;const $Ot={toc:[]};function KOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}KOt.isMDXComponent=!0;const JOt={toc:[]};function tEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}tEt.isMDXComponent=!0;const eEt={toc:[]};function nEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}nEt.isMDXComponent=!0;const oEt={toc:[]};function pEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}pEt.isMDXComponent=!0;const rEt={toc:[]};function sEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}sEt.isMDXComponent=!0;const cEt={toc:[]};function iEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}iEt.isMDXComponent=!0;const aEt={toc:[]};function lEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}lEt.isMDXComponent=!0;const uEt={toc:[]};function mEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}mEt.isMDXComponent=!0;const dEt={toc:[]};function hEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}hEt.isMDXComponent=!0;const fEt={toc:[]};function kEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}kEt.isMDXComponent=!0;const yEt={toc:[]};function DEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}DEt.isMDXComponent=!0;const MEt={toc:[]};function wEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}wEt.isMDXComponent=!0;const _Et={toc:[]};function XEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}XEt.isMDXComponent=!0;const gEt={toc:[]};function TEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}TEt.isMDXComponent=!0;const CEt={toc:[]};function xEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}xEt.isMDXComponent=!0;const vEt={toc:[]};function LEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}LEt.isMDXComponent=!0;const ZEt={toc:[]};function bEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}bEt.isMDXComponent=!0;const NEt={toc:[]};function zEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}zEt.isMDXComponent=!0;const AEt={toc:[]};function WEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}WEt.isMDXComponent=!0;const IEt={toc:[]};function REt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}REt.isMDXComponent=!0;const PEt={toc:[]};function SEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}SEt.isMDXComponent=!0;const OEt={toc:[]};function EEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}EEt.isMDXComponent=!0;const BEt={toc:[]};function GEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}GEt.isMDXComponent=!0;const UEt={toc:[]};function FEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}FEt.isMDXComponent=!0;const VEt={toc:[]};function qEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}qEt.isMDXComponent=!0;const jEt={toc:[]};function HEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}HEt.isMDXComponent=!0;const QEt={toc:[]};function YEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}YEt.isMDXComponent=!0;const $Et={toc:[]};function KEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}KEt.isMDXComponent=!0;const JEt={toc:[]};function tBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}tBt.isMDXComponent=!0;const eBt={toc:[]};function nBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nBt.isMDXComponent=!0;const oBt={toc:[]};function pBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}pBt.isMDXComponent=!0;const rBt={toc:[]};function sBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}sBt.isMDXComponent=!0;const cBt={toc:[]};function iBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}iBt.isMDXComponent=!0;const aBt={toc:[]};function lBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}lBt.isMDXComponent=!0;const uBt={toc:[]};function mBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}mBt.isMDXComponent=!0;const dBt={toc:[]};function hBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}hBt.isMDXComponent=!0;const fBt={toc:[]};function kBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}kBt.isMDXComponent=!0;const yBt={toc:[]};function DBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}DBt.isMDXComponent=!0;const MBt={toc:[]};function wBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}wBt.isMDXComponent=!0;const _Bt={toc:[]};function XBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}XBt.isMDXComponent=!0;const gBt={toc:[]};function TBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}TBt.isMDXComponent=!0;const CBt={toc:[]};function xBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}xBt.isMDXComponent=!0;const vBt={toc:[]};function LBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}LBt.isMDXComponent=!0;const ZBt={toc:[]};function bBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}bBt.isMDXComponent=!0;const NBt={toc:[]};function zBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}zBt.isMDXComponent=!0;const ABt={toc:[]};function WBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ABt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}WBt.isMDXComponent=!0;const IBt={toc:[]};function RBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}RBt.isMDXComponent=!0;const PBt={toc:[]};function SBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}SBt.isMDXComponent=!0;const OBt={toc:[]};function EBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}EBt.isMDXComponent=!0;const BBt={toc:[]};function GBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}GBt.isMDXComponent=!0;const UBt={toc:[]};function FBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}FBt.isMDXComponent=!0;const VBt={toc:[]};function qBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}qBt.isMDXComponent=!0;const jBt={toc:[]};function HBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}HBt.isMDXComponent=!0;const QBt={toc:[]};function YBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}YBt.isMDXComponent=!0;const $Bt={toc:[]};function KBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}KBt.isMDXComponent=!0;const JBt={toc:[]};function tGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}tGt.isMDXComponent=!0;const eGt={toc:[]};function nGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}nGt.isMDXComponent=!0;const oGt={toc:[]};function pGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}pGt.isMDXComponent=!0;const rGt={toc:[]};function sGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}sGt.isMDXComponent=!0;const cGt={toc:[]};function iGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}iGt.isMDXComponent=!0;const aGt={toc:[]};function lGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}lGt.isMDXComponent=!0;const uGt={toc:[]};function mGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}mGt.isMDXComponent=!0;const dGt={toc:[]};function hGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}hGt.isMDXComponent=!0;const fGt={toc:[]};function kGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}kGt.isMDXComponent=!0;const yGt={toc:[]};function DGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}DGt.isMDXComponent=!0;const MGt={toc:[]};function wGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}wGt.isMDXComponent=!0;const _Gt={toc:[]};function XGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}XGt.isMDXComponent=!0;const gGt={toc:[]};function TGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}TGt.isMDXComponent=!0;const CGt={toc:[]};function xGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}xGt.isMDXComponent=!0;const vGt={toc:[]};function LGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}LGt.isMDXComponent=!0;const ZGt={toc:[]};function bGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}bGt.isMDXComponent=!0;const NGt={toc:[]};function zGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}zGt.isMDXComponent=!0;const AGt={toc:[]};function WGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}WGt.isMDXComponent=!0;const IGt={toc:[]};function RGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}RGt.isMDXComponent=!0;const PGt={toc:[]};function SGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}SGt.isMDXComponent=!0;const OGt={toc:[]};function EGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}EGt.isMDXComponent=!0;const BGt={toc:[]};function GGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}GGt.isMDXComponent=!0;const UGt={toc:[]};function FGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}FGt.isMDXComponent=!0;const VGt={toc:[]};function qGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}qGt.isMDXComponent=!0;const jGt={toc:[]};function HGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}HGt.isMDXComponent=!0;const QGt={toc:[]};function YGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}YGt.isMDXComponent=!0;const $Gt={toc:[]};function KGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}KGt.isMDXComponent=!0;const JGt={toc:[]};function tUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}tUt.isMDXComponent=!0;const eUt={toc:[]};function nUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}nUt.isMDXComponent=!0;const oUt={toc:[]};function pUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}pUt.isMDXComponent=!0;const rUt={toc:[]};function sUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}sUt.isMDXComponent=!0;const cUt={toc:[]};function iUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}iUt.isMDXComponent=!0;const aUt={toc:[]};function lUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}lUt.isMDXComponent=!0;const uUt={toc:[]};function mUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}mUt.isMDXComponent=!0;const dUt={toc:[]};function hUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}hUt.isMDXComponent=!0;const fUt={toc:[]};function kUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}kUt.isMDXComponent=!0;const yUt={toc:[]};function DUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}DUt.isMDXComponent=!0;const MUt={toc:[]};function wUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}wUt.isMDXComponent=!0;const _Ut={toc:[]};function XUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}XUt.isMDXComponent=!0;const gUt={toc:[]};function TUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}TUt.isMDXComponent=!0;const CUt={toc:[]};function xUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}xUt.isMDXComponent=!0;const vUt={toc:[]};function LUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}LUt.isMDXComponent=!0;const ZUt={toc:[]};function bUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}bUt.isMDXComponent=!0;const NUt={toc:[]};function zUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}zUt.isMDXComponent=!0;const AUt={toc:[]};function WUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}WUt.isMDXComponent=!0;const IUt={toc:[]};function RUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}RUt.isMDXComponent=!0;const PUt={toc:[]};function SUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}SUt.isMDXComponent=!0;const OUt={toc:[]};function EUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}EUt.isMDXComponent=!0;const BUt={toc:[]};function GUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}GUt.isMDXComponent=!0;const UUt={toc:[]};function FUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}FUt.isMDXComponent=!0;const VUt={toc:[]};function qUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}qUt.isMDXComponent=!0;const jUt={toc:[]};function HUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}HUt.isMDXComponent=!0;const QUt={toc:[]};function YUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}YUt.isMDXComponent=!0;const $Ut={toc:[]};function KUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}KUt.isMDXComponent=!0;const JUt={toc:[]};function tFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}tFt.isMDXComponent=!0;const eFt={toc:[]};function nFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}nFt.isMDXComponent=!0;const oFt={toc:[]};function pFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}pFt.isMDXComponent=!0;const rFt={toc:[]};function sFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}sFt.isMDXComponent=!0;const cFt={toc:[]};function iFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}iFt.isMDXComponent=!0;const aFt={toc:[]};function lFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}lFt.isMDXComponent=!0;const uFt={toc:[]};function mFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}mFt.isMDXComponent=!0;const dFt={toc:[]};function hFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}hFt.isMDXComponent=!0;const fFt={toc:[]};function kFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}kFt.isMDXComponent=!0;const yFt={toc:[]};function DFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}DFt.isMDXComponent=!0;const MFt={toc:[]};function wFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}wFt.isMDXComponent=!0;const _Ft={toc:[]};function XFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}XFt.isMDXComponent=!0;const gFt={toc:[]};function TFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}TFt.isMDXComponent=!0;const CFt={toc:[]};function xFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}xFt.isMDXComponent=!0;const vFt={toc:[]};function LFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}LFt.isMDXComponent=!0;const ZFt={toc:[]};function bFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bFt.isMDXComponent=!0;const NFt={toc:[]};function zFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}zFt.isMDXComponent=!0;const AFt={toc:[]};function WFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}WFt.isMDXComponent=!0;const IFt={toc:[]};function RFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}RFt.isMDXComponent=!0;const PFt={toc:[]};function SFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}SFt.isMDXComponent=!0;const OFt={toc:[]};function EFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}EFt.isMDXComponent=!0;const BFt={toc:[]};function GFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}GFt.isMDXComponent=!0;const UFt={toc:[]};function FFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}FFt.isMDXComponent=!0;const VFt={toc:[]};function qFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}qFt.isMDXComponent=!0;const jFt={toc:[]};function HFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}HFt.isMDXComponent=!0;const QFt={toc:[]};function YFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}YFt.isMDXComponent=!0;const $Ft={toc:[]};function KFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}KFt.isMDXComponent=!0;const JFt={toc:[]};function tVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}tVt.isMDXComponent=!0;const eVt={toc:[]};function nVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}nVt.isMDXComponent=!0;const oVt={toc:[]};function pVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}pVt.isMDXComponent=!0;const rVt={toc:[]};function sVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}sVt.isMDXComponent=!0;const cVt={toc:[]};function iVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}iVt.isMDXComponent=!0;const aVt={toc:[]};function lVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}lVt.isMDXComponent=!0;const uVt={toc:[]};function mVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}mVt.isMDXComponent=!0;const dVt={toc:[]};function hVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}hVt.isMDXComponent=!0;const fVt={toc:[]};function kVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}kVt.isMDXComponent=!0;const yVt={toc:[]};function DVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}DVt.isMDXComponent=!0;const MVt={toc:[]};function wVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}wVt.isMDXComponent=!0;const _Vt={toc:[]};function XVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}XVt.isMDXComponent=!0;const gVt={toc:[]};function TVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}TVt.isMDXComponent=!0;const CVt={toc:[]};function xVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}xVt.isMDXComponent=!0;const vVt={toc:[]};function LVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}LVt.isMDXComponent=!0;const ZVt={toc:[]};function bVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}bVt.isMDXComponent=!0;const NVt={toc:[]};function zVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}zVt.isMDXComponent=!0;const AVt={toc:[]};function WVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}WVt.isMDXComponent=!0;const IVt={toc:[]};function RVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}RVt.isMDXComponent=!0;const PVt={toc:[]};function SVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}SVt.isMDXComponent=!0;const OVt={toc:[]};function EVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}EVt.isMDXComponent=!0;const BVt={toc:[]};function GVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}GVt.isMDXComponent=!0;const UVt={toc:[]};function FVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}FVt.isMDXComponent=!0;const VVt={toc:[]};function qVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}qVt.isMDXComponent=!0;const jVt={toc:[]};function HVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticeable if the number of sides is low, e.g. for a\ntriangle."))}HVt.isMDXComponent=!0;const QVt={toc:[]};function YVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}YVt.isMDXComponent=!0;const $Vt={toc:[]};function KVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing regular polygons."))}KVt.isMDXComponent=!0;const JVt={toc:[]};function tqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}tqt.isMDXComponent=!0;const eqt={toc:[]};function nqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}nqt.isMDXComponent=!0;const oqt={toc:[]};function pqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}pqt.isMDXComponent=!0;const rqt={toc:[]};function sqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}sqt.isMDXComponent=!0;const cqt={toc:[]};function iqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}iqt.isMDXComponent=!0;const aqt={toc:[]};function lqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}lqt.isMDXComponent=!0;const uqt={toc:[]};function mqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}mqt.isMDXComponent=!0;const dqt={toc:[]};function hqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}hqt.isMDXComponent=!0;const fqt={toc:[]};function kqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}kqt.isMDXComponent=!0;const yqt={toc:[]};function Dqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Dqt.isMDXComponent=!0;const Mqt={toc:[]};function wqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}wqt.isMDXComponent=!0;const _qt={toc:[]};function Xqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Xqt.isMDXComponent=!0;const gqt={toc:[]};function Tqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Tqt.isMDXComponent=!0;const Cqt={toc:[]};function xqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}xqt.isMDXComponent=!0;const vqt={toc:[]};function Lqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Lqt.isMDXComponent=!0;const Zqt={toc:[]};function bqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}bqt.isMDXComponent=!0;const Nqt={toc:[]};function zqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}zqt.isMDXComponent=!0;const Aqt={toc:[]};function Wqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Wqt.isMDXComponent=!0;const Iqt={toc:[]};function Rqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Rqt.isMDXComponent=!0;const Pqt={toc:[]};function Sqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Sqt.isMDXComponent=!0;const Oqt={toc:[]};function Eqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Eqt.isMDXComponent=!0;const Bqt={toc:[]};function Gqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Gqt.isMDXComponent=!0;const Uqt={toc:[]};function Fqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Fqt.isMDXComponent=!0;const Vqt={toc:[]};function qqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}qqt.isMDXComponent=!0;const jqt={toc:[]};function Hqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Hqt.isMDXComponent=!0;const Qqt={toc:[]};function Yqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}Yqt.isMDXComponent=!0;const $qt={toc:[]};function Kqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}Kqt.isMDXComponent=!0;const Jqt={toc:[]};function tjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}tjt.isMDXComponent=!0;const ejt={toc:[]};function njt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ejt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}njt.isMDXComponent=!0;const ojt={toc:[]};function pjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ojt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}pjt.isMDXComponent=!0;const rjt={toc:[]};function sjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}sjt.isMDXComponent=!0;const cjt={toc:[]};function ijt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}ijt.isMDXComponent=!0;const ajt={toc:[]};function ljt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ajt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}ljt.isMDXComponent=!0;const ujt={toc:[]};function mjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ujt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}mjt.isMDXComponent=!0;const djt={toc:[]};function hjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},djt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}hjt.isMDXComponent=!0;const fjt={toc:[]};function kjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}kjt.isMDXComponent=!0;const yjt={toc:[]};function Djt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Djt.isMDXComponent=!0;const Mjt={toc:[]};function wjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}wjt.isMDXComponent=!0;const _jt={toc:[]};function Xjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Xjt.isMDXComponent=!0;const gjt={toc:[]};function Tjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Tjt.isMDXComponent=!0;const Cjt={toc:[]};function xjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}xjt.isMDXComponent=!0;const vjt={toc:[]};function Ljt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Ljt.isMDXComponent=!0;const Zjt={toc:[]};function bjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}bjt.isMDXComponent=!0;const Njt={toc:[]};function zjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Njt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}zjt.isMDXComponent=!0;const Ajt={toc:[]};function Wjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ajt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Wjt.isMDXComponent=!0;const Ijt={toc:[]};function Rjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ijt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Rjt.isMDXComponent=!0;const Pjt={toc:[]};function Sjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Sjt.isMDXComponent=!0;const Ojt={toc:[]};function Ejt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ojt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Ejt.isMDXComponent=!0;const Bjt={toc:[]};function Gjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Gjt.isMDXComponent=!0;const Ujt={toc:[]};function Fjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ujt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Fjt.isMDXComponent=!0;const Vjt={toc:[]};function qjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}qjt.isMDXComponent=!0;const jjt={toc:[]};function Hjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Hjt.isMDXComponent=!0;const Qjt={toc:[]};function Yjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Yjt.isMDXComponent=!0;const $jt={toc:[]};function Kjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Kjt.isMDXComponent=!0;const Jjt={toc:[]};function tHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}tHt.isMDXComponent=!0;const eHt={toc:[]};function nHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}nHt.isMDXComponent=!0;const oHt={toc:[]};function pHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pHt.isMDXComponent=!0;const rHt={toc:[]};function sHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}sHt.isMDXComponent=!0;const cHt={toc:[]};function iHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}iHt.isMDXComponent=!0;const aHt={toc:[]};function lHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lHt.isMDXComponent=!0;const uHt={toc:[]};function mHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}mHt.isMDXComponent=!0;const dHt={toc:[]};function hHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}hHt.isMDXComponent=!0;const fHt={toc:[]};function kHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kHt.isMDXComponent=!0;const yHt={toc:[]};function DHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}DHt.isMDXComponent=!0;const MHt={toc:[]};function wHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}wHt.isMDXComponent=!0;const _Ht={toc:[]};function XHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}XHt.isMDXComponent=!0;const gHt={toc:[]};function THt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}THt.isMDXComponent=!0;const CHt={toc:[]};function xHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}xHt.isMDXComponent=!0;const vHt={toc:[]};function LHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}LHt.isMDXComponent=!0;const ZHt={toc:[]};function bHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}bHt.isMDXComponent=!0;const NHt={toc:[]};function zHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}zHt.isMDXComponent=!0;const AHt={toc:[]};function WHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}WHt.isMDXComponent=!0;const IHt={toc:[]};function RHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}RHt.isMDXComponent=!0;const PHt={toc:[]};function SHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}SHt.isMDXComponent=!0;const OHt={toc:[]};function EHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}EHt.isMDXComponent=!0;const BHt={toc:[]};function GHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}GHt.isMDXComponent=!0;const UHt={toc:[]};function FHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}FHt.isMDXComponent=!0;const VHt={toc:[]};function qHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}qHt.isMDXComponent=!0;const jHt={toc:[]};function HHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}HHt.isMDXComponent=!0;const QHt={toc:[]};function YHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}YHt.isMDXComponent=!0;const $Ht={toc:[]};function KHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}KHt.isMDXComponent=!0;const JHt={toc:[]};function tQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}tQt.isMDXComponent=!0;const eQt={toc:[]};function nQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}nQt.isMDXComponent=!0;const oQt={toc:[]};function pQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}pQt.isMDXComponent=!0;const rQt={toc:[]};function sQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}sQt.isMDXComponent=!0;const cQt={toc:[]};function iQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}iQt.isMDXComponent=!0;const aQt={toc:[]};function lQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}lQt.isMDXComponent=!0;const uQt={toc:[]};function mQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}mQt.isMDXComponent=!0;const dQt={toc:[]};function hQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}hQt.isMDXComponent=!0;const fQt={toc:[]};function kQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}kQt.isMDXComponent=!0;const yQt={toc:[]};function DQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}DQt.isMDXComponent=!0;const MQt={toc:[]};function wQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wQt.isMDXComponent=!0;const _Qt={toc:[]};function XQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}XQt.isMDXComponent=!0;const gQt={toc:[]};function TQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}TQt.isMDXComponent=!0;const CQt={toc:[]};function xQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}xQt.isMDXComponent=!0;const vQt={toc:[]};function LQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}LQt.isMDXComponent=!0;const ZQt={toc:[]};function bQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}bQt.isMDXComponent=!0;const NQt={toc:[]};function zQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}zQt.isMDXComponent=!0;const AQt={toc:[]};function WQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}WQt.isMDXComponent=!0;const IQt={toc:[]};function RQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}RQt.isMDXComponent=!0;const PQt={toc:[]};function SQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}SQt.isMDXComponent=!0;const OQt={toc:[]};function EQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}EQt.isMDXComponent=!0;const BQt={toc:[]};function GQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}GQt.isMDXComponent=!0;const UQt={toc:[]};function FQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}FQt.isMDXComponent=!0;const VQt={toc:[]};function qQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}qQt.isMDXComponent=!0;const jQt={toc:[]};function HQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}HQt.isMDXComponent=!0;const QQt={toc:[]};function YQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}YQt.isMDXComponent=!0;const $Qt={toc:[]};function KQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}KQt.isMDXComponent=!0;const JQt={toc:[]};function tYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}tYt.isMDXComponent=!0;const eYt={toc:[]};function nYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}nYt.isMDXComponent=!0;const oYt={toc:[]};function pYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}pYt.isMDXComponent=!0;const rYt={toc:[]};function sYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}sYt.isMDXComponent=!0;const cYt={toc:[]};function iYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}iYt.isMDXComponent=!0;const aYt={toc:[]};function lYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lYt.isMDXComponent=!0;const uYt={toc:[]};function mYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}mYt.isMDXComponent=!0;const dYt={toc:[]};function hYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}hYt.isMDXComponent=!0;const fYt={toc:[]};function kYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}kYt.isMDXComponent=!0;const yYt={toc:[]};function DYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}DYt.isMDXComponent=!0;const MYt={toc:[]};function wYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}wYt.isMDXComponent=!0;const _Yt={toc:[]};function XYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}XYt.isMDXComponent=!0;const gYt={toc:[]};function TYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}TYt.isMDXComponent=!0;const CYt={toc:[]};function xYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}xYt.isMDXComponent=!0;const vYt={toc:[]};function LYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}LYt.isMDXComponent=!0;const ZYt={toc:[]};function bYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}bYt.isMDXComponent=!0;const NYt={toc:[]};function zYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}zYt.isMDXComponent=!0;const AYt={toc:[]};function WYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}WYt.isMDXComponent=!0;const IYt={toc:[]};function RYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}RYt.isMDXComponent=!0;const PYt={toc:[]};function SYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}SYt.isMDXComponent=!0;const OYt={toc:[]};function EYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}EYt.isMDXComponent=!0;const BYt={toc:[]};function GYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}GYt.isMDXComponent=!0;const UYt={toc:[]};function FYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}FYt.isMDXComponent=!0;const VYt={toc:[]};function qYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qYt.isMDXComponent=!0;const jYt={toc:[]};function HYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}HYt.isMDXComponent=!0;const QYt={toc:[]};function YYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}YYt.isMDXComponent=!0;const $Yt={toc:[]};function KYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}KYt.isMDXComponent=!0;const JYt={toc:[]};function t$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}t$t.isMDXComponent=!0;const e$t={toc:[]};function n$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}n$t.isMDXComponent=!0;const o$t={toc:[]};function p$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}p$t.isMDXComponent=!0;const r$t={toc:[]};function s$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}s$t.isMDXComponent=!0;const c$t={toc:[]};function i$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}i$t.isMDXComponent=!0;const a$t={toc:[]};function l$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}l$t.isMDXComponent=!0;const u$t={toc:[]};function m$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}m$t.isMDXComponent=!0;const d$t={toc:[]};function h$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, QuadBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}h$t.isMDXComponent=!0;const f$t={toc:[]};function k$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}k$t.isMDXComponent=!0;const y$t={toc:[]};function D$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}D$t.isMDXComponent=!0;const M$t={toc:[]};function w$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}w$t.isMDXComponent=!0;const _$t={toc:[]};function X$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}X$t.isMDXComponent=!0;const g$t={toc:[]};function T$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}T$t.isMDXComponent=!0;const C$t={toc:[]};function x$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}x$t.isMDXComponent=!0;const v$t={toc:[]};function L$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}L$t.isMDXComponent=!0;const Z$t={toc:[]};function b$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}b$t.isMDXComponent=!0;const N$t={toc:[]};function z$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}z$t.isMDXComponent=!0;const A$t={toc:[]};function W$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}W$t.isMDXComponent=!0;const I$t={toc:[]};function R$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}R$t.isMDXComponent=!0;const P$t={toc:[]};function S$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}S$t.isMDXComponent=!0;const O$t={toc:[]};function E$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}E$t.isMDXComponent=!0;const B$t={toc:[]};function G$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}G$t.isMDXComponent=!0;const U$t={toc:[]};function F$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}F$t.isMDXComponent=!0;const V$t={toc:[]};function q$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}q$t.isMDXComponent=!0;const j$t={toc:[]};function H$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}H$t.isMDXComponent=!0;const Q$t={toc:[]};function Y$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Y$t.isMDXComponent=!0;const $$t={toc:[]};function K$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}K$t.isMDXComponent=!0;const J$t={toc:[]};function tKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}tKt.isMDXComponent=!0;const eKt={toc:[]};function nKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}nKt.isMDXComponent=!0;const oKt={toc:[]};function pKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}pKt.isMDXComponent=!0;const rKt={toc:[]};function sKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}sKt.isMDXComponent=!0;const cKt={toc:[]};function iKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}iKt.isMDXComponent=!0;const aKt={toc:[]};function lKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}lKt.isMDXComponent=!0;const uKt={toc:[]};function mKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}mKt.isMDXComponent=!0;const dKt={toc:[]};function hKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}hKt.isMDXComponent=!0;const fKt={toc:[]};function kKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}kKt.isMDXComponent=!0;const yKt={toc:[]};function DKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}DKt.isMDXComponent=!0;const MKt={toc:[]};function wKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}wKt.isMDXComponent=!0;const _Kt={toc:[]};function XKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The control point of the B\xe9zier curve."))}XKt.isMDXComponent=!0;const gKt={toc:[]};function TKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}TKt.isMDXComponent=!0;const CKt={toc:[]};function xKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}xKt.isMDXComponent=!0;const vKt={toc:[]};function LKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}LKt.isMDXComponent=!0;const ZKt={toc:[]};function bKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}bKt.isMDXComponent=!0;const NKt={toc:[]};function zKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}zKt.isMDXComponent=!0;const AKt={toc:[]};function WKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}WKt.isMDXComponent=!0;const IKt={toc:[]};function RKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}RKt.isMDXComponent=!0;const PKt={toc:[]};function SKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}SKt.isMDXComponent=!0;const OKt={toc:[]};function EKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}EKt.isMDXComponent=!0;const BKt={toc:[]};function GKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}GKt.isMDXComponent=!0;const UKt={toc:[]};function FKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}FKt.isMDXComponent=!0;const VKt={toc:[]};function qKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qKt.isMDXComponent=!0;const jKt={toc:[]};function HKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}HKt.isMDXComponent=!0;const QKt={toc:[]};function YKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}YKt.isMDXComponent=!0;const $Kt={toc:[]};function KKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}KKt.isMDXComponent=!0;const JKt={toc:[]};function tJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}tJt.isMDXComponent=!0;const eJt={toc:[]};function nJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}nJt.isMDXComponent=!0;const oJt={toc:[]};function pJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}pJt.isMDXComponent=!0;const rJt={toc:[]};function sJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}sJt.isMDXComponent=!0;const cJt={toc:[]};function iJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}iJt.isMDXComponent=!0;const aJt={toc:[]};function lJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lJt.isMDXComponent=!0;const uJt={toc:[]};function mJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}mJt.isMDXComponent=!0;const dJt={toc:[]};function hJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}hJt.isMDXComponent=!0;const fJt={toc:[]};function kJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}kJt.isMDXComponent=!0;const yJt={toc:[]};function DJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}DJt.isMDXComponent=!0;const MJt={toc:[]};function wJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}wJt.isMDXComponent=!0;const _Jt={toc:[]};function XJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}XJt.isMDXComponent=!0;const gJt={toc:[]};function TJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}TJt.isMDXComponent=!0;const CJt={toc:[]};function xJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}xJt.isMDXComponent=!0;const vJt={toc:[]};function LJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}LJt.isMDXComponent=!0;const ZJt={toc:[]};function bJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}bJt.isMDXComponent=!0;const NJt={toc:[]};function zJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}zJt.isMDXComponent=!0;const AJt={toc:[]};function WJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}WJt.isMDXComponent=!0;const IJt={toc:[]};function RJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}RJt.isMDXComponent=!0;const PJt={toc:[]};function SJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}SJt.isMDXComponent=!0;const OJt={toc:[]};function EJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}EJt.isMDXComponent=!0;const BJt={toc:[]};function GJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}GJt.isMDXComponent=!0;const UJt={toc:[]};function FJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}FJt.isMDXComponent=!0;const VJt={toc:[]};function qJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}qJt.isMDXComponent=!0;const jJt={toc:[]};function HJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}HJt.isMDXComponent=!0;const QJt={toc:[]};function YJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}YJt.isMDXComponent=!0;const $Jt={toc:[]};function KJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}KJt.isMDXComponent=!0;const JJt={toc:[]};function t0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}t0t.isMDXComponent=!0;const e0t={toc:[]};function n0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}n0t.isMDXComponent=!0;const o0t={toc:[]};function p0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}p0t.isMDXComponent=!0;const r0t={toc:[]};function s0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}s0t.isMDXComponent=!0;const c0t={toc:[]};function i0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}i0t.isMDXComponent=!0;const a0t={toc:[]};function l0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}l0t.isMDXComponent=!0;const u0t={toc:[]};function m0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}m0t.isMDXComponent=!0;const d0t={toc:[]};function h0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}h0t.isMDXComponent=!0;const f0t={toc:[]};function k0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}k0t.isMDXComponent=!0;const y0t={toc:[]};function D0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}D0t.isMDXComponent=!0;const M0t={toc:[]};function w0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}w0t.isMDXComponent=!0;const _0t={toc:[]};function X0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}X0t.isMDXComponent=!0;const g0t={toc:[]};function T0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}T0t.isMDXComponent=!0;const C0t={toc:[]};function x0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}x0t.isMDXComponent=!0;const v0t={toc:[]};function L0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}L0t.isMDXComponent=!0;const Z0t={toc:[]};function b0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}b0t.isMDXComponent=!0;const N0t={toc:[]};function z0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}z0t.isMDXComponent=!0;const A0t={toc:[]};function W0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}W0t.isMDXComponent=!0;const I0t={toc:[]};function R0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}R0t.isMDXComponent=!0;const P0t={toc:[]};function S0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}S0t.isMDXComponent=!0;const O0t={toc:[]};function E0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}E0t.isMDXComponent=!0;const B0t={toc:[]};function G0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}G0t.isMDXComponent=!0;const U0t={toc:[]};function F0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}F0t.isMDXComponent=!0;const V0t={toc:[]};function q0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}q0t.isMDXComponent=!0;const j0t={toc:[]};function H0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}H0t.isMDXComponent=!0;const Q0t={toc:[]};function Y0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Y0t.isMDXComponent=!0;const $0t={toc:[]};function K0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}K0t.isMDXComponent=!0;const J0t={toc:[]};function t5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}t5t.isMDXComponent=!0;const e5t={toc:[]};function n5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}n5t.isMDXComponent=!0;const o5t={toc:[]};function p5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}p5t.isMDXComponent=!0;const r5t={toc:[]};function s5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}s5t.isMDXComponent=!0;const c5t={toc:[]};function i5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}i5t.isMDXComponent=!0;const a5t={toc:[]};function l5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}l5t.isMDXComponent=!0;const u5t={toc:[]};function m5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}m5t.isMDXComponent=!0;const d5t={toc:[]};function h5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}h5t.isMDXComponent=!0;const f5t={toc:[]};function k5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}k5t.isMDXComponent=!0;const y5t={toc:[]};function D5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}D5t.isMDXComponent=!0;const M5t={toc:[]};function w5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}w5t.isMDXComponent=!0;const _5t={toc:[]};function X5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}X5t.isMDXComponent=!0;const g5t={toc:[]};function T5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}T5t.isMDXComponent=!0;const C5t={toc:[]};function x5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}x5t.isMDXComponent=!0;const v5t={toc:[]};function L5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}L5t.isMDXComponent=!0;const Z5t={toc:[]};function b5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}b5t.isMDXComponent=!0;const N5t={toc:[]};function z5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}z5t.isMDXComponent=!0;const A5t={toc:[]};function W5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}W5t.isMDXComponent=!0;const I5t={toc:[]};function R5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}R5t.isMDXComponent=!0;const P5t={toc:[]};function S5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}S5t.isMDXComponent=!0;const O5t={toc:[]};function E5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}E5t.isMDXComponent=!0;const B5t={toc:[]};function G5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}G5t.isMDXComponent=!0;const U5t={toc:[]};function F5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}F5t.isMDXComponent=!0;const V5t={toc:[]};function q5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}q5t.isMDXComponent=!0;const j5t={toc:[]};function H5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}H5t.isMDXComponent=!0;const Q5t={toc:[]};function Y5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Y5t.isMDXComponent=!0;const $5t={toc:[]};function K5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}K5t.isMDXComponent=!0;const J5t={toc:[]};function t8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}t8t.isMDXComponent=!0;const e8t={toc:[]};function n8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}n8t.isMDXComponent=!0;const o8t={toc:[]};function p8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}p8t.isMDXComponent=!0;const r8t={toc:[]};function s8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}s8t.isMDXComponent=!0;const c8t={toc:[]};function i8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}i8t.isMDXComponent=!0;const a8t={toc:[]};function l8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}l8t.isMDXComponent=!0;const u8t={toc:[]};function m8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}m8t.isMDXComponent=!0;const d8t={toc:[]};function h8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}h8t.isMDXComponent=!0;const f8t={toc:[]};function k8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}k8t.isMDXComponent=!0;const y8t={toc:[]};function D8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}D8t.isMDXComponent=!0;const M8t={toc:[]};function w8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}w8t.isMDXComponent=!0;const _8t={toc:[]};function X8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}X8t.isMDXComponent=!0;const g8t={toc:[]};function T8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}T8t.isMDXComponent=!0;const C8t={toc:[]};function x8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}x8t.isMDXComponent=!0;const v8t={toc:[]};function L8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}L8t.isMDXComponent=!0;const Z8t={toc:[]};function b8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}b8t.isMDXComponent=!0;const N8t={toc:[]};function z8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}z8t.isMDXComponent=!0;const A8t={toc:[]};function W8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}W8t.isMDXComponent=!0;const I8t={toc:[]};function R8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}R8t.isMDXComponent=!0;const P8t={toc:[]};function S8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}S8t.isMDXComponent=!0;const O8t={toc:[]};function E8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}E8t.isMDXComponent=!0;const B8t={toc:[]};function G8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}G8t.isMDXComponent=!0;const U8t={toc:[]};function F8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}F8t.isMDXComponent=!0;const V8t={toc:[]};function q8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}q8t.isMDXComponent=!0;const j8t={toc:[]};function H8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}H8t.isMDXComponent=!0;const Q8t={toc:[]};function Y8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Y8t.isMDXComponent=!0;const $8t={toc:[]};function K8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}K8t.isMDXComponent=!0;const J8t={toc:[]};function t3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}t3t.isMDXComponent=!0;const e3t={toc:[]};function n3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}n3t.isMDXComponent=!0;const o3t={toc:[]};function p3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}p3t.isMDXComponent=!0;const r3t={toc:[]};function s3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}s3t.isMDXComponent=!0;const c3t={toc:[]};function i3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}i3t.isMDXComponent=!0;const a3t={toc:[]};function l3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}l3t.isMDXComponent=!0;const u3t={toc:[]};function m3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}m3t.isMDXComponent=!0;const d3t={toc:[]};function h3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}h3t.isMDXComponent=!0;const f3t={toc:[]};function k3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}k3t.isMDXComponent=!0;const y3t={toc:[]};function D3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}D3t.isMDXComponent=!0;const M3t={toc:[]};function w3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}w3t.isMDXComponent=!0;const _3t={toc:[]};function X3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}X3t.isMDXComponent=!0;const g3t={toc:[]};function T3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}T3t.isMDXComponent=!0;const C3t={toc:[]};function x3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}x3t.isMDXComponent=!0;const v3t={toc:[]};function L3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}L3t.isMDXComponent=!0;const Z3t={toc:[]};function b3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}b3t.isMDXComponent=!0;const N3t={toc:[]};function z3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}z3t.isMDXComponent=!0;const A3t={toc:[]};function W3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}W3t.isMDXComponent=!0;const I3t={toc:[]};function R3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}R3t.isMDXComponent=!0;const P3t={toc:[]};function S3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}S3t.isMDXComponent=!0;const O3t={toc:[]};function E3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}E3t.isMDXComponent=!0;const B3t={toc:[]};function G3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d';\nimport {Ray} from '@motion-canvas/2d/lib/components';\nimport {createRef} from '@motion-canvas/core/lib/utils';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}G3t.isMDXComponent=!0;const U3t={toc:[]};function F3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing an individual line segment."))}F3t.isMDXComponent=!0;const V3t={toc:[]};function q3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}q3t.isMDXComponent=!0;const j3t={toc:[]};function H3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}H3t.isMDXComponent=!0;const Q3t={toc:[]};function Y3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Y3t.isMDXComponent=!0;const $3t={toc:[]};function K3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}K3t.isMDXComponent=!0;const J3t={toc:[]};function t2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}t2t.isMDXComponent=!0;const e2t={toc:[]};function n2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}n2t.isMDXComponent=!0;const o2t={toc:[]};function p2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}p2t.isMDXComponent=!0;const r2t={toc:[]};function s2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}s2t.isMDXComponent=!0;const c2t={toc:[]};function i2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}i2t.isMDXComponent=!0;const a2t={toc:[]};function l2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}l2t.isMDXComponent=!0;const u2t={toc:[]};function m2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}m2t.isMDXComponent=!0;const d2t={toc:[]};function h2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}h2t.isMDXComponent=!0;const f2t={toc:[]};function k2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}k2t.isMDXComponent=!0;const y2t={toc:[]};function D2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}D2t.isMDXComponent=!0;const M2t={toc:[]};function w2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}w2t.isMDXComponent=!0;const _2t={toc:[]};function X2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}X2t.isMDXComponent=!0;const g2t={toc:[]};function T2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}T2t.isMDXComponent=!0;const C2t={toc:[]};function x2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}x2t.isMDXComponent=!0;const v2t={toc:[]};function L2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}L2t.isMDXComponent=!0;const Z2t={toc:[]};function b2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}b2t.isMDXComponent=!0;const N2t={toc:[]};function z2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}z2t.isMDXComponent=!0;const A2t={toc:[]};function W2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}W2t.isMDXComponent=!0;const I2t={toc:[]};function R2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}R2t.isMDXComponent=!0;const P2t={toc:[]};function S2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}S2t.isMDXComponent=!0;const O2t={toc:[]};function E2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}E2t.isMDXComponent=!0;const B2t={toc:[]};function G2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}G2t.isMDXComponent=!0;const U2t={toc:[]};function F2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}F2t.isMDXComponent=!0;const V2t={toc:[]};function q2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}q2t.isMDXComponent=!0;const j2t={toc:[]};function H2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}H2t.isMDXComponent=!0;const Q2t={toc:[]};function Y2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Y2t.isMDXComponent=!0;const $2t={toc:[]};function K2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}K2t.isMDXComponent=!0;const J2t={toc:[]};function t1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}t1t.isMDXComponent=!0;const e1t={toc:[]};function n1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}n1t.isMDXComponent=!0;const o1t={toc:[]};function p1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}p1t.isMDXComponent=!0;const r1t={toc:[]};function s1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}s1t.isMDXComponent=!0;const c1t={toc:[]};function i1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}i1t.isMDXComponent=!0;const a1t={toc:[]};function l1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}l1t.isMDXComponent=!0;const u1t={toc:[]};function m1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}m1t.isMDXComponent=!0;const d1t={toc:[]};function h1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}h1t.isMDXComponent=!0;const f1t={toc:[]};function k1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}k1t.isMDXComponent=!0;const y1t={toc:[]};function D1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}D1t.isMDXComponent=!0;const M1t={toc:[]};function w1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}w1t.isMDXComponent=!0;const _1t={toc:[]};function X1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}X1t.isMDXComponent=!0;const g1t={toc:[]};function T1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}T1t.isMDXComponent=!0;const C1t={toc:[]};function x1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}x1t.isMDXComponent=!0;const v1t={toc:[]};function L1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}L1t.isMDXComponent=!0;const Z1t={toc:[]};function b1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}b1t.isMDXComponent=!0;const N1t={toc:[]};function z1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}z1t.isMDXComponent=!0;const A1t={toc:[]};function W1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}W1t.isMDXComponent=!0;const I1t={toc:[]};function R1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}R1t.isMDXComponent=!0;const P1t={toc:[]};function S1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}S1t.isMDXComponent=!0;const O1t={toc:[]};function E1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}E1t.isMDXComponent=!0;const B1t={toc:[]};function G1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}G1t.isMDXComponent=!0;const U1t={toc:[]};function F1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}F1t.isMDXComponent=!0;const V1t={toc:[]};function q1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}q1t.isMDXComponent=!0;const j1t={toc:[]};function H1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}H1t.isMDXComponent=!0;const Q1t={toc:[]};function Y1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Y1t.isMDXComponent=!0;const $1t={toc:[]};function K1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}K1t.isMDXComponent=!0;const J1t={toc:[]};function t4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}t4t.isMDXComponent=!0;const e4t={toc:[]};function n4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}n4t.isMDXComponent=!0;const o4t={toc:[]};function p4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}p4t.isMDXComponent=!0;const r4t={toc:[]};function s4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}s4t.isMDXComponent=!0;const c4t={toc:[]};function i4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}i4t.isMDXComponent=!0;const a4t={toc:[]};function l4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}l4t.isMDXComponent=!0;const u4t={toc:[]};function m4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}m4t.isMDXComponent=!0;const d4t={toc:[]};function h4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}h4t.isMDXComponent=!0;const f4t={toc:[]};function k4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}k4t.isMDXComponent=!0;const y4t={toc:[]};function D4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}D4t.isMDXComponent=!0;const M4t={toc:[]};function w4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}w4t.isMDXComponent=!0;const _4t={toc:[]};function X4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}X4t.isMDXComponent=!0;const g4t={toc:[]};function T4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}T4t.isMDXComponent=!0;const C4t={toc:[]};function x4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}x4t.isMDXComponent=!0;const v4t={toc:[]};function L4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}L4t.isMDXComponent=!0;const Z4t={toc:[]};function b4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}b4t.isMDXComponent=!0;const N4t={toc:[]};function z4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}z4t.isMDXComponent=!0;const A4t={toc:[]};function W4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}W4t.isMDXComponent=!0;const I4t={toc:[]};function R4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}R4t.isMDXComponent=!0;const P4t={toc:[]};function S4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}S4t.isMDXComponent=!0;const O4t={toc:[]};function E4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}E4t.isMDXComponent=!0;const B4t={toc:[]};function G4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}G4t.isMDXComponent=!0;const U4t={toc:[]};function F4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}F4t.isMDXComponent=!0;const V4t={toc:[]};function q4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}q4t.isMDXComponent=!0;const j4t={toc:[]};function H4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}H4t.isMDXComponent=!0;const Q4t={toc:[]};function Y4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Y4t.isMDXComponent=!0;const $4t={toc:[]};function K4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}K4t.isMDXComponent=!0;const J4t={toc:[]};function t6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}t6t.isMDXComponent=!0;const e6t={toc:[]};function n6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}n6t.isMDXComponent=!0;const o6t={toc:[]};function p6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}p6t.isMDXComponent=!0;const r6t={toc:[]};function s6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}s6t.isMDXComponent=!0;const c6t={toc:[]};function i6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}i6t.isMDXComponent=!0;const a6t={toc:[]};function l6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}l6t.isMDXComponent=!0;const u6t={toc:[]};function m6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}m6t.isMDXComponent=!0;const d6t={toc:[]};function h6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}h6t.isMDXComponent=!0;const f6t={toc:[]};function k6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}k6t.isMDXComponent=!0;const y6t={toc:[]};function D6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}D6t.isMDXComponent=!0;const M6t={toc:[]};function w6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}w6t.isMDXComponent=!0;const _6t={toc:[]};function X6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}X6t.isMDXComponent=!0;const g6t={toc:[]};function T6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}T6t.isMDXComponent=!0;const C6t={toc:[]};function x6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}x6t.isMDXComponent=!0;const v6t={toc:[]};function L6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}L6t.isMDXComponent=!0;const Z6t={toc:[]};function b6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}b6t.isMDXComponent=!0;const N6t={toc:[]};function z6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}z6t.isMDXComponent=!0;const A6t={toc:[]};function W6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}W6t.isMDXComponent=!0;const I6t={toc:[]};function R6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}R6t.isMDXComponent=!0;const P6t={toc:[]};function S6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}S6t.isMDXComponent=!0;const O6t={toc:[]};function E6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}E6t.isMDXComponent=!0;const B6t={toc:[]};function G6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}G6t.isMDXComponent=!0;const U6t={toc:[]};function F6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}F6t.isMDXComponent=!0;const V6t={toc:[]};function q6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}q6t.isMDXComponent=!0;const j6t={toc:[]};function H6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}H6t.isMDXComponent=!0;const Q6t={toc:[]};function Y6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Y6t.isMDXComponent=!0;const $6t={toc:[]};function K6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}K6t.isMDXComponent=!0;const J6t={toc:[]};function t7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}t7t.isMDXComponent=!0;const e7t={toc:[]};function n7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}n7t.isMDXComponent=!0;const o7t={toc:[]};function p7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}p7t.isMDXComponent=!0;const r7t={toc:[]};function s7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}s7t.isMDXComponent=!0;const c7t={toc:[]};function i7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}i7t.isMDXComponent=!0;const a7t={toc:[]};function l7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}l7t.isMDXComponent=!0;const u7t={toc:[]};function m7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}m7t.isMDXComponent=!0;const d7t={toc:[]};function h7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}h7t.isMDXComponent=!0;const f7t={toc:[]};function k7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}k7t.isMDXComponent=!0;const y7t={toc:[]};function D7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}D7t.isMDXComponent=!0;const M7t={toc:[]};function w7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}w7t.isMDXComponent=!0;const _7t={toc:[]};function X7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}X7t.isMDXComponent=!0;const g7t={toc:[]};function T7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}T7t.isMDXComponent=!0;const C7t={toc:[]};function x7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}x7t.isMDXComponent=!0;const v7t={toc:[]};function L7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}L7t.isMDXComponent=!0;const Z7t={toc:[]};function b7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}b7t.isMDXComponent=!0;const N7t={toc:[]};function z7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}z7t.isMDXComponent=!0;const A7t={toc:[]};function W7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}W7t.isMDXComponent=!0;const I7t={toc:[]};function R7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}R7t.isMDXComponent=!0;const P7t={toc:[]};function S7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}S7t.isMDXComponent=!0;const O7t={toc:[]};function E7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}E7t.isMDXComponent=!0;const B7t={toc:[]};function G7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}G7t.isMDXComponent=!0;const U7t={toc:[]};function F7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}F7t.isMDXComponent=!0;const V7t={toc:[]};function q7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}q7t.isMDXComponent=!0;const j7t={toc:[]};function H7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}H7t.isMDXComponent=!0;const Q7t={toc:[]};function Y7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Y7t.isMDXComponent=!0;const $7t={toc:[]};function K7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}K7t.isMDXComponent=!0;const J7t={toc:[]};function t9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}t9t.isMDXComponent=!0;const e9t={toc:[]};function n9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}n9t.isMDXComponent=!0;const o9t={toc:[]};function p9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}p9t.isMDXComponent=!0;const r9t={toc:[]};function s9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}s9t.isMDXComponent=!0;const c9t={toc:[]};function i9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}i9t.isMDXComponent=!0;const a9t={toc:[]};function l9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}l9t.isMDXComponent=!0;const u9t={toc:[]};function m9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}m9t.isMDXComponent=!0;const d9t={toc:[]};function h9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}h9t.isMDXComponent=!0;const f9t={toc:[]};function k9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}k9t.isMDXComponent=!0;const y9t={toc:[]};function D9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}D9t.isMDXComponent=!0;const M9t={toc:[]};function w9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}w9t.isMDXComponent=!0;const _9t={toc:[]};function X9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}X9t.isMDXComponent=!0;const g9t={toc:[]};function T9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}T9t.isMDXComponent=!0;const C9t={toc:[]};function x9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}x9t.isMDXComponent=!0;const v9t={toc:[]};function L9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}L9t.isMDXComponent=!0;const Z9t={toc:[]};function b9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}b9t.isMDXComponent=!0;const N9t={toc:[]};function z9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}z9t.isMDXComponent=!0;const A9t={toc:[]};function W9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}W9t.isMDXComponent=!0;const I9t={toc:[]};function R9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}R9t.isMDXComponent=!0;const P9t={toc:[]};function S9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}S9t.isMDXComponent=!0;const O9t={toc:[]};function E9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}E9t.isMDXComponent=!0;const B9t={toc:[]};function G9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}G9t.isMDXComponent=!0;const U9t={toc:[]};function F9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}F9t.isMDXComponent=!0;const V9t={toc:[]};function q9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}q9t.isMDXComponent=!0;const j9t={toc:[]};function H9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}H9t.isMDXComponent=!0;const Q9t={toc:[]};function Y9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Y9t.isMDXComponent=!0;const $9t={toc:[]};function K9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}K9t.isMDXComponent=!0;const J9t={toc:[]};function tte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}tte.isMDXComponent=!0;const ete={toc:[]};function nte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ete,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}nte.isMDXComponent=!0;const ote={toc:[]};function pte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ote,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}pte.isMDXComponent=!0;const rte={toc:[]};function ste(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}ste.isMDXComponent=!0;const cte={toc:[]};function ite(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}ite.isMDXComponent=!0;const ate={toc:[]};function lte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ate,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lte.isMDXComponent=!0;const ute={toc:[]};function mte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ute,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}mte.isMDXComponent=!0;const dte={toc:[]};function hte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}hte.isMDXComponent=!0;const fte={toc:[]};function kte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}kte.isMDXComponent=!0;const yte={toc:[]};function Dte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Dte.isMDXComponent=!0;const Mte={toc:[]};function wte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}wte.isMDXComponent=!0;const _te={toc:[]};function Xte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_te,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Xte.isMDXComponent=!0;const gte={toc:[]};function Tte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Tte.isMDXComponent=!0;const Cte={toc:[]};function xte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}xte.isMDXComponent=!0;const vte={toc:[]};function Lte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Lte.isMDXComponent=!0;const Zte={toc:[]};function bte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}bte.isMDXComponent=!0;const Nte={toc:[]};function zte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zte.isMDXComponent=!0;const Ate={toc:[]};function Wte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ate,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Wte.isMDXComponent=!0;const Ite={toc:[]};function Rte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ite,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Rte.isMDXComponent=!0;const Pte={toc:[]};function Ste(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Ste.isMDXComponent=!0;const Ote={toc:[]};function Ete(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ote,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ete.isMDXComponent=!0;const Bte={toc:[]};function Gte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Gte.isMDXComponent=!0;const Ute={toc:[]};function Fte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ute,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Fte.isMDXComponent=!0;const Vte={toc:[]};function qte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}qte.isMDXComponent=!0;const jte={toc:[]};function Hte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Hte.isMDXComponent=!0;const Qte={toc:[]};function Yte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Yte.isMDXComponent=!0;const $te={toc:[]};function Kte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$te,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Kte.isMDXComponent=!0;const Jte={toc:[]};function tee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}tee.isMDXComponent=!0;const eee={toc:[]};function nee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nee.isMDXComponent=!0;const oee={toc:[]};function pee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}pee.isMDXComponent=!0;const ree={toc:[]};function see(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ree,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}see.isMDXComponent=!0;const cee={toc:[]};function iee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}iee.isMDXComponent=!0;const aee={toc:[]};function lee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}lee.isMDXComponent=!0;const uee={toc:[]};function mee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}mee.isMDXComponent=!0;const dee={toc:[]};function hee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}hee.isMDXComponent=!0;const fee={toc:[]};function kee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}kee.isMDXComponent=!0;const yee={toc:[]};function Dee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Dee.isMDXComponent=!0;const Mee={toc:[]};function wee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}wee.isMDXComponent=!0;const _ee={toc:[]};function Xee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Xee.isMDXComponent=!0;const gee={toc:[]};function Tee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Tee.isMDXComponent=!0;const Cee={toc:[]};function xee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}xee.isMDXComponent=!0;const vee={toc:[]};function Lee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Lee.isMDXComponent=!0;const Zee={toc:[]};function bee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}bee.isMDXComponent=!0;const Nee={toc:[]};function zee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}zee.isMDXComponent=!0;const Aee={toc:[]};function Wee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Wee.isMDXComponent=!0;const Iee={toc:[]};function Ree(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Ree.isMDXComponent=!0;const Pee={toc:[]};function See(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}See.isMDXComponent=!0;const Oee={toc:[]};function Eee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Eee.isMDXComponent=!0;const Bee={toc:[]};function Gee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Gee.isMDXComponent=!0;const Uee={toc:[]};function Fee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Fee.isMDXComponent=!0;const Vee={toc:[]};function qee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}qee.isMDXComponent=!0;const jee={toc:[]};function Hee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Hee.isMDXComponent=!0;const Qee={toc:[]};function Yee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Yee.isMDXComponent=!0;const $ee={toc:[]};function Kee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Kee.isMDXComponent=!0;const Jee={toc:[]};function tne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}tne.isMDXComponent=!0;const ene={toc:[]};function nne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ene,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}nne.isMDXComponent=!0;const one={toc:[]};function pne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},one,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}pne.isMDXComponent=!0;const rne={toc:[]};function sne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}sne.isMDXComponent=!0;const cne={toc:[]};function ine(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}ine.isMDXComponent=!0;const ane={toc:[]};function lne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ane,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lne.isMDXComponent=!0;const une={toc:[]};function mne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},une,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}mne.isMDXComponent=!0;const dne={toc:[]};function hne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}hne.isMDXComponent=!0;const fne={toc:[]};function kne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}kne.isMDXComponent=!0;const yne={toc:[]};function Dne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Dne.isMDXComponent=!0;const Mne={toc:[]};function wne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wne.isMDXComponent=!0;const _ne={toc:[]};function Xne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Xne.isMDXComponent=!0;const gne={toc:[]};function Tne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Tne.isMDXComponent=!0;const Cne={toc:[]};function xne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}xne.isMDXComponent=!0;const vne={toc:[]};function Lne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Lne.isMDXComponent=!0;const Zne={toc:[]};function bne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}bne.isMDXComponent=!0;const Nne={toc:[]};function zne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}zne.isMDXComponent=!0;const Ane={toc:[]};function Wne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ane,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Wne.isMDXComponent=!0;const Ine={toc:[]};function Rne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ine,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Rne.isMDXComponent=!0;const Pne={toc:[]};function Sne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Sne.isMDXComponent=!0;const One={toc:[]};function Ene(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},One,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Ene.isMDXComponent=!0;const Bne={toc:[]};function Gne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Gne.isMDXComponent=!0;const Une={toc:[]};function Fne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Une,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Fne.isMDXComponent=!0;const Vne={toc:[]};function qne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qne.isMDXComponent=!0;const jne={toc:[]};function Hne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Hne.isMDXComponent=!0;const Qne={toc:[]};function Yne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Yne.isMDXComponent=!0;const $ne={toc:[]};function Kne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Kne.isMDXComponent=!0;const Jne={toc:[]};function toe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}toe.isMDXComponent=!0;const eoe={toc:[]};function noe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}noe.isMDXComponent=!0;const ooe={toc:[]};function poe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ooe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}poe.isMDXComponent=!0;const roe={toc:[]};function soe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},roe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}soe.isMDXComponent=!0;const coe={toc:[]};function ioe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},coe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}ioe.isMDXComponent=!0;const aoe={toc:[]};function loe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}loe.isMDXComponent=!0;const uoe={toc:[]};function moe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}moe.isMDXComponent=!0;const doe={toc:[]};function hoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},doe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}hoe.isMDXComponent=!0;const foe={toc:[]};function koe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},foe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}koe.isMDXComponent=!0;const yoe={toc:[]};function Doe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Doe.isMDXComponent=!0;const Moe={toc:[]};function woe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Moe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}woe.isMDXComponent=!0;const _oe={toc:[]};function Xoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Xoe.isMDXComponent=!0;const goe={toc:[]};function Toe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},goe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Toe.isMDXComponent=!0;const Coe={toc:[]};function xoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Coe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}xoe.isMDXComponent=!0;const voe={toc:[]};function Loe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},voe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Loe.isMDXComponent=!0;const Zoe={toc:[]};function boe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}boe.isMDXComponent=!0;const Noe={toc:[]};function zoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Noe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}zoe.isMDXComponent=!0;const Aoe={toc:[]};function Woe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Woe.isMDXComponent=!0;const Ioe={toc:[]};function Roe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ioe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Roe.isMDXComponent=!0;const Poe={toc:[]};function Soe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Poe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Soe.isMDXComponent=!0;const Ooe={toc:[]};function Eoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ooe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Eoe.isMDXComponent=!0;const Boe={toc:[]};function Goe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Boe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Goe.isMDXComponent=!0;const Uoe={toc:[]};function Foe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Foe.isMDXComponent=!0;const Voe={toc:[]};function qoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Voe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}qoe.isMDXComponent=!0;const joe={toc:[]};function Hoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},joe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Hoe.isMDXComponent=!0;const Qoe={toc:[]};function Yoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Yoe.isMDXComponent=!0;const $oe={toc:[]};function Koe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Koe.isMDXComponent=!0;const Joe={toc:[]};function tpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Joe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}tpe.isMDXComponent=!0;const epe={toc:[]};function npe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},epe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}npe.isMDXComponent=!0;const ope={toc:[]};function ppe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ope,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}ppe.isMDXComponent=!0;const rpe={toc:[]};function spe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}spe.isMDXComponent=!0;const cpe={toc:[]};function ipe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}ipe.isMDXComponent=!0;const ape={toc:[]};function lpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ape,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}lpe.isMDXComponent=!0;const upe={toc:[]};function mpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}mpe.isMDXComponent=!0;const dpe={toc:[]};function hpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}hpe.isMDXComponent=!0;const fpe={toc:[]};function kpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}kpe.isMDXComponent=!0;const ype={toc:[]};function Dpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ype,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Dpe.isMDXComponent=!0;const Mpe={toc:[]};function wpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wpe.isMDXComponent=!0;const _pe={toc:[]};function Xpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Xpe.isMDXComponent=!0;const gpe={toc:[]};function Tpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Tpe.isMDXComponent=!0;const Cpe={toc:[]};function xpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}xpe.isMDXComponent=!0;const vpe={toc:[]};function Lpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Lpe.isMDXComponent=!0;const Zpe={toc:[]};function bpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}bpe.isMDXComponent=!0;const Npe={toc:[]};function zpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}zpe.isMDXComponent=!0;const Ape={toc:[]};function Wpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ape,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Wpe.isMDXComponent=!0;const Ipe={toc:[]};function Rpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ipe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Rpe.isMDXComponent=!0;const Ppe={toc:[]};function Spe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ppe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Spe.isMDXComponent=!0;const Ope={toc:[]};function Epe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ope,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Epe.isMDXComponent=!0;const Bpe={toc:[]};function Gpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Gpe.isMDXComponent=!0;const Upe={toc:[]};function Fpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Upe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Fpe.isMDXComponent=!0;const Vpe={toc:[]};function qpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}qpe.isMDXComponent=!0;const jpe={toc:[]};function Hpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Hpe.isMDXComponent=!0;const Qpe={toc:[]};function Ype(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Ype.isMDXComponent=!0;const $pe={toc:[]};function Kpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Kpe.isMDXComponent=!0;const Jpe={toc:[]};function tre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}tre.isMDXComponent=!0;const ere={toc:[]};function nre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ere,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}nre.isMDXComponent=!0;const ore={toc:[]};function pre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ore,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}pre.isMDXComponent=!0;const rre={toc:[]};function sre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}sre.isMDXComponent=!0;const cre={toc:[]};function ire(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}ire.isMDXComponent=!0;const are={toc:[]};function lre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},are,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}lre.isMDXComponent=!0;const ure={toc:[]};function mre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ure,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}mre.isMDXComponent=!0;const dre={toc:[]};function hre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}hre.isMDXComponent=!0;const fre={toc:[]};function kre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}kre.isMDXComponent=!0;const yre={toc:[]};function Dre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Dre.isMDXComponent=!0;const Mre={toc:[]};function wre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}wre.isMDXComponent=!0;const _re={toc:[]};function Xre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Xre.isMDXComponent=!0;const gre={toc:[]};function Tre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Tre.isMDXComponent=!0;const Cre={toc:[]};function xre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}xre.isMDXComponent=!0;const vre={toc:[]};function Lre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Lre.isMDXComponent=!0;const Zre={toc:[]};function bre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}bre.isMDXComponent=!0;const Nre={toc:[]};function zre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}zre.isMDXComponent=!0;const Are={toc:[]};function Wre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Are,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Wre.isMDXComponent=!0;const Ire={toc:[]};function Rre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ire,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Rre.isMDXComponent=!0;const Pre={toc:[]};function Sre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Sre.isMDXComponent=!0;const Ore={toc:[]};function Ere(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ore,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Ere.isMDXComponent=!0;const Bre={toc:[]};function Gre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Gre.isMDXComponent=!0;const Ure={toc:[]};function Fre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ure,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Fre.isMDXComponent=!0;const Vre={toc:[]};function qre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}qre.isMDXComponent=!0;const jre={toc:[]};function Hre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Hre.isMDXComponent=!0;const Qre={toc:[]};function Yre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Yre.isMDXComponent=!0;const $re={toc:[]};function Kre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Kre.isMDXComponent=!0;const Jre={toc:[]};function tse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}tse.isMDXComponent=!0;const ese={toc:[]};function nse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ese,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}nse.isMDXComponent=!0;const ose={toc:[]};function pse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ose,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}pse.isMDXComponent=!0;const rse={toc:[]};function sse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}sse.isMDXComponent=!0;const cse={toc:[]};function ise(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}ise.isMDXComponent=!0;const ase={toc:[]};function lse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ase,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}lse.isMDXComponent=!0;const use={toc:[]};function mse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},use,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}mse.isMDXComponent=!0;const dse={toc:[]};function hse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}hse.isMDXComponent=!0;const fse={toc:[]};function kse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}kse.isMDXComponent=!0;const yse={toc:[]};function Dse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Dse.isMDXComponent=!0;const Mse={toc:[]};function wse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wse.isMDXComponent=!0;const _se={toc:[]};function Xse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Xse.isMDXComponent=!0;const gse={toc:[]};function Tse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Tse.isMDXComponent=!0;const Cse={toc:[]};function xse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}xse.isMDXComponent=!0;const vse={toc:[]};function Lse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Lse.isMDXComponent=!0;const Zse={toc:[]};function bse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bse.isMDXComponent=!0;const Nse={toc:[]};function zse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}zse.isMDXComponent=!0;const Ase={toc:[]};function Wse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ase,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Wse.isMDXComponent=!0;const Ise={toc:[]};function Rse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ise,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Rse.isMDXComponent=!0;const Pse={toc:[]};function Sse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Sse.isMDXComponent=!0;const Ose={toc:[]};function Ese(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ose,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Ese.isMDXComponent=!0;const Bse={toc:[]};function Gse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Gse.isMDXComponent=!0;const Use={toc:[]};function Fse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Use,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Fse.isMDXComponent=!0;const Vse={toc:[]};function qse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}qse.isMDXComponent=!0;const jse={toc:[]};function Hse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Hse.isMDXComponent=!0;const Qse={toc:[]};function Yse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Yse.isMDXComponent=!0;const $se={toc:[]};function Kse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Kse.isMDXComponent=!0;const Jse={toc:[]};function tce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}tce.isMDXComponent=!0;const ece={toc:[]};function nce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ece,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}nce.isMDXComponent=!0;const oce={toc:[]};function pce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}pce.isMDXComponent=!0;const rce={toc:[]};function sce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}sce.isMDXComponent=!0;const cce={toc:[]};function ice(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}ice.isMDXComponent=!0;const ace={toc:[]};function lce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ace,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}lce.isMDXComponent=!0;const uce={toc:[]};function mce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}mce.isMDXComponent=!0;const dce={toc:[]};function hce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}hce.isMDXComponent=!0;const fce={toc:[]};function kce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}kce.isMDXComponent=!0;const yce={toc:[]};function Dce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Dce.isMDXComponent=!0;const Mce={toc:[]};function wce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}wce.isMDXComponent=!0;const _ce={toc:[]};function Xce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Xce.isMDXComponent=!0;const gce={toc:[]};function Tce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Tce.isMDXComponent=!0;const Cce={toc:[]};function xce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}xce.isMDXComponent=!0;const vce={toc:[]};function Lce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Lce.isMDXComponent=!0;const Zce={toc:[]};function bce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}bce.isMDXComponent=!0;const Nce={toc:[]};function zce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}zce.isMDXComponent=!0;const Ace={toc:[]};function Wce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ace,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Wce.isMDXComponent=!0;const Ice={toc:[]};function Rce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ice,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Rce.isMDXComponent=!0;const Pce={toc:[]};function Sce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Sce.isMDXComponent=!0;const Oce={toc:[]};function Ece(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Ece.isMDXComponent=!0;const Bce={toc:[]};function Gce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Gce.isMDXComponent=!0;const Uce={toc:[]};function Fce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Fce.isMDXComponent=!0;const Vce={toc:[]};function qce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}qce.isMDXComponent=!0;const jce={toc:[]};function Hce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Hce.isMDXComponent=!0;const Qce={toc:[]};function Yce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Yce.isMDXComponent=!0;const $ce={toc:[]};function Kce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Kce.isMDXComponent=!0;const Jce={toc:[]};function tie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}tie.isMDXComponent=!0;const eie={toc:[]};function nie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}nie.isMDXComponent=!0;const oie={toc:[]};function pie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}pie.isMDXComponent=!0;const rie={toc:[]};function sie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}sie.isMDXComponent=!0;const cie={toc:[]};function iie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}iie.isMDXComponent=!0;const aie={toc:[]};function lie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}lie.isMDXComponent=!0;const uie={toc:[]};function mie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}mie.isMDXComponent=!0;const die={toc:[]};function hie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},die,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}hie.isMDXComponent=!0;const fie={toc:[]};function kie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}kie.isMDXComponent=!0;const yie={toc:[]};function Die(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Die.isMDXComponent=!0;const Mie={toc:[]};function wie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}wie.isMDXComponent=!0;const _ie={toc:[]};function Xie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Xie.isMDXComponent=!0;const gie={toc:[]};function Tie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Tie.isMDXComponent=!0;const Cie={toc:[]};function xie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}xie.isMDXComponent=!0;const vie={toc:[]};function Lie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Lie.isMDXComponent=!0;const Zie={toc:[]};function bie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bie.isMDXComponent=!0;const Nie={toc:[]};function zie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}zie.isMDXComponent=!0;const Aie={toc:[]};function Wie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Wie.isMDXComponent=!0;const Iie={toc:[]};function Rie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Rie.isMDXComponent=!0;const Pie={toc:[]};function Sie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Sie.isMDXComponent=!0;const Oie={toc:[]};function Eie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Eie.isMDXComponent=!0;const Bie={toc:[]};function Gie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Gie.isMDXComponent=!0;const Uie={toc:[]};function Fie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Fie.isMDXComponent=!0;const Vie={toc:[]};function qie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}qie.isMDXComponent=!0;const jie={toc:[]};function Hie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Hie.isMDXComponent=!0;const Qie={toc:[]};function Yie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Yie.isMDXComponent=!0;const $ie={toc:[]};function Kie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Kie.isMDXComponent=!0;const Jie={toc:[]};function tae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}tae.isMDXComponent=!0;const eae={toc:[]};function nae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}nae.isMDXComponent=!0;const oae={toc:[]};function pae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}pae.isMDXComponent=!0;const rae={toc:[]};function sae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}sae.isMDXComponent=!0;const cae={toc:[]};function iae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}iae.isMDXComponent=!0;const aae={toc:[]};function lae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lae.isMDXComponent=!0;const uae={toc:[]};function mae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}mae.isMDXComponent=!0;const dae={toc:[]};function hae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}hae.isMDXComponent=!0;const fae={toc:[]};function kae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}kae.isMDXComponent=!0;const yae={toc:[]};function Dae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Dae.isMDXComponent=!0;const Mae={toc:[]};function wae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}wae.isMDXComponent=!0;const _ae={toc:[]};function Xae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Xae.isMDXComponent=!0;const gae={toc:[]};function Tae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Tae.isMDXComponent=!0;const Cae={toc:[]};function xae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}xae.isMDXComponent=!0;const vae={toc:[]};function Lae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Lae.isMDXComponent=!0;const Zae={toc:[]};function bae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}bae.isMDXComponent=!0;const Nae={toc:[]};function zae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}zae.isMDXComponent=!0;const Aae={toc:[]};function Wae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Wae.isMDXComponent=!0;const Iae={toc:[]};function Rae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Rae.isMDXComponent=!0;const Pae={toc:[]};function Sae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Sae.isMDXComponent=!0;const Oae={toc:[]};function Eae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Eae.isMDXComponent=!0;const Bae={toc:[]};function Gae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Gae.isMDXComponent=!0;const Uae={toc:[]};function Fae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Fae.isMDXComponent=!0;const Vae={toc:[]};function qae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}qae.isMDXComponent=!0;const jae={toc:[]};function Hae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Hae.isMDXComponent=!0;const Qae={toc:[]};function Yae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Yae.isMDXComponent=!0;const $ae={toc:[]};function Kae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Kae.isMDXComponent=!0;const Jae={toc:[]};function tle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}tle.isMDXComponent=!0;const ele={toc:[]};function nle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ele,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}nle.isMDXComponent=!0;const ole={toc:[]};function ple(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ole,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}ple.isMDXComponent=!0;const rle={toc:[]};function sle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}sle.isMDXComponent=!0;const cle={toc:[]};function ile(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}ile.isMDXComponent=!0;const ale={toc:[]};function lle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ale,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}lle.isMDXComponent=!0;const ule={toc:[]};function mle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ule,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}mle.isMDXComponent=!0;const dle={toc:[]};function hle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}hle.isMDXComponent=!0;const fle={toc:[]};function kle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}kle.isMDXComponent=!0;const yle={toc:[]};function Dle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Dle.isMDXComponent=!0;const Mle={toc:[]};function wle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}wle.isMDXComponent=!0;const _le={toc:[]};function Xle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Xle.isMDXComponent=!0;const gle={toc:[]};function Tle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Tle.isMDXComponent=!0;const Cle={toc:[]};function xle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}xle.isMDXComponent=!0;const vle={toc:[]};function Lle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Lle.isMDXComponent=!0;const Zle={toc:[]};function ble(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}ble.isMDXComponent=!0;const Nle={toc:[]};function zle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}zle.isMDXComponent=!0;const Ale={toc:[]};function Wle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ale,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Wle.isMDXComponent=!0;const Ile={toc:[]};function Rle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ile,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Rle.isMDXComponent=!0;const Ple={toc:[]};function Sle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ple,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Sle.isMDXComponent=!0;const Ole={toc:[]};function Ele(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ole,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Ele.isMDXComponent=!0;const Ble={toc:[]};function Gle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ble,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Gle.isMDXComponent=!0;const Ule={toc:[]};function Fle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ule,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Fle.isMDXComponent=!0;const Vle={toc:[]};function qle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qle.isMDXComponent=!0;const jle={toc:[]};function Hle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Hle.isMDXComponent=!0;const Qle={toc:[]};function Yle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Yle.isMDXComponent=!0;const $le={toc:[]};function Kle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Kle.isMDXComponent=!0;const Jle={toc:[]};function tue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}tue.isMDXComponent=!0;const eue={toc:[]};function nue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}nue.isMDXComponent=!0;const oue={toc:[]};function pue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}pue.isMDXComponent=!0;const rue={toc:[]};function sue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}sue.isMDXComponent=!0;const cue={toc:[]};function iue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}iue.isMDXComponent=!0;const aue={toc:[]};function lue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}lue.isMDXComponent=!0;const uue={toc:[]};function mue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}mue.isMDXComponent=!0;const due={toc:[]};function hue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},due,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}hue.isMDXComponent=!0;const fue={toc:[]};function kue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}kue.isMDXComponent=!0;const yue={toc:[]};function Due(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Due.isMDXComponent=!0;const Mue={toc:[]};function wue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}wue.isMDXComponent=!0;const _ue={toc:[]};function Xue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Xue.isMDXComponent=!0;const gue={toc:[]};function Tue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Tue.isMDXComponent=!0;const Cue={toc:[]};function xue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}xue.isMDXComponent=!0;const vue={toc:[]};function Lue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Lue.isMDXComponent=!0;const Zue={toc:[]};function bue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}bue.isMDXComponent=!0;const Nue={toc:[]};function zue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}zue.isMDXComponent=!0;const Aue={toc:[]};function Wue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Wue.isMDXComponent=!0;const Iue={toc:[]};function Rue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Rue.isMDXComponent=!0;const Pue={toc:[]};function Sue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Sue.isMDXComponent=!0;const Oue={toc:[]};function Eue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Eue.isMDXComponent=!0;const Bue={toc:[]};function Gue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Gue.isMDXComponent=!0;const Uue={toc:[]};function Fue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Fue.isMDXComponent=!0;const Vue={toc:[]};function que(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}que.isMDXComponent=!0;const jue={toc:[]};function Hue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Hue.isMDXComponent=!0;const Que={toc:[]};function Yue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Que,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Yue.isMDXComponent=!0;const $ue={toc:[]};function Kue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Kue.isMDXComponent=!0;const Jue={toc:[]};function tme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}tme.isMDXComponent=!0;const eme={toc:[]};function nme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}nme.isMDXComponent=!0;const ome={toc:[]};function pme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ome,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}pme.isMDXComponent=!0;const rme={toc:[]};function sme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}sme.isMDXComponent=!0;const cme={toc:[]};function ime(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining knots using the ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.kt)("p",null,"Defining knots with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}ime.isMDXComponent=!0;const ame={toc:[]};function lme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ame,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a smooth line through a number of points."))}lme.isMDXComponent=!0;const ume={toc:[]};function mme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ume,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}mme.isMDXComponent=!0;const dme={toc:[]};function hme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}hme.isMDXComponent=!0;const fme={toc:[]};function kme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}kme.isMDXComponent=!0;const yme={toc:[]};function Dme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Dme.isMDXComponent=!0;const Mme={toc:[]};function wme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wme.isMDXComponent=!0;const _me={toc:[]};function Xme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Xme.isMDXComponent=!0;const gme={toc:[]};function Tme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Tme.isMDXComponent=!0;const Cme={toc:[]};function xme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}xme.isMDXComponent=!0;const vme={toc:[]};function Lme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Lme.isMDXComponent=!0;const Zme={toc:[]};function bme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}bme.isMDXComponent=!0;const Nme={toc:[]};function zme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}zme.isMDXComponent=!0;const Ame={toc:[]};function Wme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ame,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Wme.isMDXComponent=!0;const Ime={toc:[]};function Rme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ime,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Rme.isMDXComponent=!0;const Pme={toc:[]};function Sme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Sme.isMDXComponent=!0;const Ome={toc:[]};function Eme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ome,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Eme.isMDXComponent=!0;const Bme={toc:[]};function Gme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Gme.isMDXComponent=!0;const Ume={toc:[]};function Fme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ume,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Fme.isMDXComponent=!0;const Vme={toc:[]};function qme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}qme.isMDXComponent=!0;const jme={toc:[]};function Hme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Hme.isMDXComponent=!0;const Qme={toc:[]};function Yme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Yme.isMDXComponent=!0;const $me={toc:[]};function Kme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Kme.isMDXComponent=!0;const Jme={toc:[]};function tde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}tde.isMDXComponent=!0;const ede={toc:[]};function nde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ede,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}nde.isMDXComponent=!0;const ode={toc:[]};function pde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ode,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}pde.isMDXComponent=!0;const rde={toc:[]};function sde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}sde.isMDXComponent=!0;const cde={toc:[]};function ide(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}ide.isMDXComponent=!0;const ade={toc:[]};function lde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ade,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}lde.isMDXComponent=!0;const ude={toc:[]};function mde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ude,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}mde.isMDXComponent=!0;const dde={toc:[]};function hde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}hde.isMDXComponent=!0;const fde={toc:[]};function kde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}kde.isMDXComponent=!0;const yde={toc:[]};function Dde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Dde.isMDXComponent=!0;const Mde={toc:[]};function wde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}wde.isMDXComponent=!0;const _de={toc:[]};function Xde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_de,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Xde.isMDXComponent=!0;const gde={toc:[]};function Tde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Tde.isMDXComponent=!0;const Cde={toc:[]};function xde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}xde.isMDXComponent=!0;const vde={toc:[]};function Lde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Lde.isMDXComponent=!0;const Zde={toc:[]};function bde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}bde.isMDXComponent=!0;const Nde={toc:[]};function zde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}zde.isMDXComponent=!0;const Ade={toc:[]};function Wde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ade,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}Wde.isMDXComponent=!0;const Ide={toc:[]};function Rde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ide,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0.4"))}Rde.isMDXComponent=!0;const Pde={toc:[]};function Sde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}Sde.isMDXComponent=!0;const Ode={toc:[]};function Ede(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ode,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ede.isMDXComponent=!0;const Bde={toc:[]};function Gde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Gde.isMDXComponent=!0;const Ude={toc:[]};function Fde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ude,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Fde.isMDXComponent=!0;const Vde={toc:[]};function qde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}qde.isMDXComponent=!0;const jde={toc:[]};function Hde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Hde.isMDXComponent=!0;const Qde={toc:[]};function Yde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Yde.isMDXComponent=!0;const $de={toc:[]};function Kde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$de,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Kde.isMDXComponent=!0;const Jde={toc:[]};function the(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}the.isMDXComponent=!0;const ehe={toc:[]};function nhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ehe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}nhe.isMDXComponent=!0;const ohe={toc:[]};function phe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ohe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}phe.isMDXComponent=!0;const rhe={toc:[]};function she(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}she.isMDXComponent=!0;const che={toc:[]};function ihe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},che,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}ihe.isMDXComponent=!0;const ahe={toc:[]};function lhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ahe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}lhe.isMDXComponent=!0;const uhe={toc:[]};function mhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}mhe.isMDXComponent=!0;const dhe={toc:[]};function hhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}hhe.isMDXComponent=!0;const fhe={toc:[]};function khe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}khe.isMDXComponent=!0;const yhe={toc:[]};function Dhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Dhe.isMDXComponent=!0;const Mhe={toc:[]};function whe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}whe.isMDXComponent=!0;const _he={toc:[]};function Xhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_he,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Xhe.isMDXComponent=!0;const ghe={toc:[]};function The(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ghe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}The.isMDXComponent=!0;const Che={toc:[]};function xhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Che,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}xhe.isMDXComponent=!0;const vhe={toc:[]};function Lhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Lhe.isMDXComponent=!0;const Zhe={toc:[]};function bhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}bhe.isMDXComponent=!0;const Nhe={toc:[]};function zhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}zhe.isMDXComponent=!0;const Ahe={toc:[]};function Whe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ahe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Whe.isMDXComponent=!0;const Ihe={toc:[]};function Rhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ihe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Rhe.isMDXComponent=!0;const Phe={toc:[]};function She(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Phe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}She.isMDXComponent=!0;const Ohe={toc:[]};function Ehe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ohe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Ehe.isMDXComponent=!0;const Bhe={toc:[]};function Ghe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Ghe.isMDXComponent=!0;const Uhe={toc:[]};function Fhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Fhe.isMDXComponent=!0;const Vhe={toc:[]};function qhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}qhe.isMDXComponent=!0;const jhe={toc:[]};function Hhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Hhe.isMDXComponent=!0;const Qhe={toc:[]};function Yhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Yhe.isMDXComponent=!0;const $he={toc:[]};function Khe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$he,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Khe.isMDXComponent=!0;const Jhe={toc:[]};function tfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}tfe.isMDXComponent=!0;const efe={toc:[]};function nfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},efe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}nfe.isMDXComponent=!0;const ofe={toc:[]};function pfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ofe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}pfe.isMDXComponent=!0;const rfe={toc:[]};function sfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}sfe.isMDXComponent=!0;const cfe={toc:[]};function ife(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ife.isMDXComponent=!0;const afe={toc:[]};function lfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},afe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}lfe.isMDXComponent=!0;const ufe={toc:[]};function mfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ufe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}mfe.isMDXComponent=!0;const dfe={toc:[]};function hfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}hfe.isMDXComponent=!0;const ffe={toc:[]};function kfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ffe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}kfe.isMDXComponent=!0;const yfe={toc:[]};function Dfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Dfe.isMDXComponent=!0;const Mfe={toc:[]};function wfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}wfe.isMDXComponent=!0;const _fe={toc:[]};function Xfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Xfe.isMDXComponent=!0;const gfe={toc:[]};function Tfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Tfe.isMDXComponent=!0;const Cfe={toc:[]};function xfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}xfe.isMDXComponent=!0;const vfe={toc:[]};function Lfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Lfe.isMDXComponent=!0;const Zfe={toc:[]};function bfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}bfe.isMDXComponent=!0;const Nfe={toc:[]};function zfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}zfe.isMDXComponent=!0;const Afe={toc:[]};function Wfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Afe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Wfe.isMDXComponent=!0;const Ife={toc:[]};function Rfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ife,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Rfe.isMDXComponent=!0;const Pfe={toc:[]};function Sfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Sfe.isMDXComponent=!0;const Ofe={toc:[]};function Efe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ofe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Efe.isMDXComponent=!0;const Bfe={toc:[]};function Gfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Gfe.isMDXComponent=!0;const Ufe={toc:[]};function Ffe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ufe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Ffe.isMDXComponent=!0;const Vfe={toc:[]};function qfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}qfe.isMDXComponent=!0;const jfe={toc:[]};function Hfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Hfe.isMDXComponent=!0;const Qfe={toc:[]};function Yfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Yfe.isMDXComponent=!0;const $fe={toc:[]};function Kfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Kfe.isMDXComponent=!0;const Jfe={toc:[]};function tke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}tke.isMDXComponent=!0;const eke={toc:[]};function nke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}nke.isMDXComponent=!0;const oke={toc:[]};function pke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}pke.isMDXComponent=!0;const rke={toc:[]};function ske(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}ske.isMDXComponent=!0;const cke={toc:[]};function ike(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}ike.isMDXComponent=!0;const ake={toc:[]};function lke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ake,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}lke.isMDXComponent=!0;const uke={toc:[]};function mke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}mke.isMDXComponent=!0;const dke={toc:[]};function hke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}hke.isMDXComponent=!0;const fke={toc:[]};function kke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}kke.isMDXComponent=!0;const yke={toc:[]};function Dke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Dke.isMDXComponent=!0;const Mke={toc:[]};function wke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wke.isMDXComponent=!0;const _ke={toc:[]};function Xke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Xke.isMDXComponent=!0;const gke={toc:[]};function Tke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Tke.isMDXComponent=!0;const Cke={toc:[]};function xke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}xke.isMDXComponent=!0;const vke={toc:[]};function Lke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Lke.isMDXComponent=!0;const Zke={toc:[]};function bke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}bke.isMDXComponent=!0;const Nke={toc:[]};function zke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}zke.isMDXComponent=!0;const Ake={toc:[]};function Wke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ake,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Wke.isMDXComponent=!0;const Ike={toc:[]};function Rke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ike,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Rke.isMDXComponent=!0;const Pke={toc:[]};function Ske(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Ske.isMDXComponent=!0;const Oke={toc:[]};function Eke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Eke.isMDXComponent=!0;const Bke={toc:[]};function Gke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Gke.isMDXComponent=!0;const Uke={toc:[]};function Fke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Fke.isMDXComponent=!0;const Vke={toc:[]};function qke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}qke.isMDXComponent=!0;const jke={toc:[]};function Hke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Hke.isMDXComponent=!0;const Qke={toc:[]};function Yke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Yke.isMDXComponent=!0;const $ke={toc:[]};function Kke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Kke.isMDXComponent=!0;const Jke={toc:[]};function tye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}tye.isMDXComponent=!0;const eye={toc:[]};function nye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}nye.isMDXComponent=!0;const oye={toc:[]};function pye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}pye.isMDXComponent=!0;const rye={toc:[]};function sye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}sye.isMDXComponent=!0;const cye={toc:[]};function iye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}iye.isMDXComponent=!0;const aye={toc:[]};function lye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}lye.isMDXComponent=!0;const uye={toc:[]};function mye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}mye.isMDXComponent=!0;const dye={toc:[]};function hye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}hye.isMDXComponent=!0;const fye={toc:[]};function kye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}kye.isMDXComponent=!0;const yye={toc:[]};function Dye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Dye.isMDXComponent=!0;const Mye={toc:[]};function wye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}wye.isMDXComponent=!0;const _ye={toc:[]};function Xye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Xye.isMDXComponent=!0;const gye={toc:[]};function Tye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Tye.isMDXComponent=!0;const Cye={toc:[]};function xye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}xye.isMDXComponent=!0;const vye={toc:[]};function Lye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Lye.isMDXComponent=!0;const Zye={toc:[]};function bye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}bye.isMDXComponent=!0;const Nye={toc:[]};function zye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}zye.isMDXComponent=!0;const Aye={toc:[]};function Wye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Wye.isMDXComponent=!0;const Iye={toc:[]};function Rye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Rye.isMDXComponent=!0;const Pye={toc:[]};function Sye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Sye.isMDXComponent=!0;const Oye={toc:[]};function Eye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Eye.isMDXComponent=!0;const Bye={toc:[]};function Gye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Gye.isMDXComponent=!0;const Uye={toc:[]};function Fye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Fye.isMDXComponent=!0;const Vye={toc:[]};function qye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qye.isMDXComponent=!0;const jye={toc:[]};function Hye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Hye.isMDXComponent=!0;const Qye={toc:[]};function Yye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Yye.isMDXComponent=!0;const $ye={toc:[]};function Kye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Kye.isMDXComponent=!0;const Jye={toc:[]};function tDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}tDe.isMDXComponent=!0;const eDe={toc:[]};function nDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}nDe.isMDXComponent=!0;const oDe={toc:[]};function pDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}pDe.isMDXComponent=!0;const rDe={toc:[]};function sDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}sDe.isMDXComponent=!0;const cDe={toc:[]};function iDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}iDe.isMDXComponent=!0;const aDe={toc:[]};function lDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lDe.isMDXComponent=!0;const uDe={toc:[]};function mDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}mDe.isMDXComponent=!0;const dDe={toc:[]};function hDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hDe.isMDXComponent=!0;const fDe={toc:[]};function kDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}kDe.isMDXComponent=!0;const yDe={toc:[]};function DDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}DDe.isMDXComponent=!0;const MDe={toc:[]};function wDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}wDe.isMDXComponent=!0;const _De={toc:[]};function XDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_De,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}XDe.isMDXComponent=!0;const gDe={toc:[]};function TDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}TDe.isMDXComponent=!0;const CDe={toc:[]};function xDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}xDe.isMDXComponent=!0;const vDe={toc:[]};function LDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}LDe.isMDXComponent=!0;const ZDe={toc:[]};function bDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}bDe.isMDXComponent=!0;const NDe={toc:[]};function zDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}zDe.isMDXComponent=!0;const ADe={toc:[]};function WDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}WDe.isMDXComponent=!0;const IDe={toc:[]};function RDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}RDe.isMDXComponent=!0;const PDe={toc:[]};function SDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}SDe.isMDXComponent=!0;const ODe={toc:[]};function EDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ODe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}EDe.isMDXComponent=!0;const BDe={toc:[]};function GDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}GDe.isMDXComponent=!0;const UDe={toc:[]};function FDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}FDe.isMDXComponent=!0;const VDe={toc:[]};function qDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}qDe.isMDXComponent=!0;const jDe={toc:[]};function HDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}HDe.isMDXComponent=!0;const QDe={toc:[]};function YDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}YDe.isMDXComponent=!0;const $De={toc:[]};function KDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$De,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}KDe.isMDXComponent=!0;const JDe={toc:[]};function tMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}tMe.isMDXComponent=!0;const eMe={toc:[]};function nMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}nMe.isMDXComponent=!0;const oMe={toc:[]};function pMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pMe.isMDXComponent=!0;const rMe={toc:[]};function sMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}sMe.isMDXComponent=!0;const cMe={toc:[]};function iMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}iMe.isMDXComponent=!0;const aMe={toc:[]};function lMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}lMe.isMDXComponent=!0;const uMe={toc:[]};function mMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}mMe.isMDXComponent=!0;const dMe={toc:[]};function hMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}hMe.isMDXComponent=!0;const fMe={toc:[]};function kMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}kMe.isMDXComponent=!0;const yMe={toc:[]};function DMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}DMe.isMDXComponent=!0;const MMe={toc:[]};function wMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wMe.isMDXComponent=!0;const _Me={toc:[]};function XMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}XMe.isMDXComponent=!0;const gMe={toc:[]};function TMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}TMe.isMDXComponent=!0;const CMe={toc:[]};function xMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}xMe.isMDXComponent=!0;const vMe={toc:[]};function LMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}LMe.isMDXComponent=!0;const ZMe={toc:[]};function bMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}bMe.isMDXComponent=!0;const NMe={toc:[]};function zMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}zMe.isMDXComponent=!0;const AMe={toc:[]};function WMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}WMe.isMDXComponent=!0;const IMe={toc:[]};function RMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}RMe.isMDXComponent=!0;const PMe={toc:[]};function SMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}SMe.isMDXComponent=!0;const OMe={toc:[]};function EMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}EMe.isMDXComponent=!0;const BMe={toc:[]};function GMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}GMe.isMDXComponent=!0;const UMe={toc:[]};function FMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}FMe.isMDXComponent=!0;const VMe={toc:[]};function qMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}qMe.isMDXComponent=!0;const jMe={toc:[]};function HMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}HMe.isMDXComponent=!0;const QMe={toc:[]};function YMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}YMe.isMDXComponent=!0;const $Me={toc:[]};function KMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}KMe.isMDXComponent=!0;const JMe={toc:[]};function twe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}twe.isMDXComponent=!0;const ewe={toc:[]};function nwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ewe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}nwe.isMDXComponent=!0;const owe={toc:[]};function pwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},owe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}pwe.isMDXComponent=!0;const rwe={toc:[]};function swe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}swe.isMDXComponent=!0;const cwe={toc:[]};function iwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}iwe.isMDXComponent=!0;const awe={toc:[]};function lwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lwe.isMDXComponent=!0;const uwe={toc:[]};function mwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}mwe.isMDXComponent=!0;const dwe={toc:[]};function hwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}hwe.isMDXComponent=!0;const fwe={toc:[]};function kwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}kwe.isMDXComponent=!0;const ywe={toc:[]};function Dwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ywe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Dwe.isMDXComponent=!0;const Mwe={toc:[]};function wwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}wwe.isMDXComponent=!0;const _we={toc:[]};function Xwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_we,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Xwe.isMDXComponent=!0;const gwe={toc:[]};function Twe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Twe.isMDXComponent=!0;const Cwe={toc:[]};function xwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}xwe.isMDXComponent=!0;const vwe={toc:[]};function Lwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Lwe.isMDXComponent=!0;const Zwe={toc:[]};function bwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}bwe.isMDXComponent=!0;const Nwe={toc:[]};function zwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}zwe.isMDXComponent=!0;const Awe={toc:[]};function Wwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Wwe.isMDXComponent=!0;const Iwe={toc:[]};function Rwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Rwe.isMDXComponent=!0;const Pwe={toc:[]};function Swe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Swe.isMDXComponent=!0;const Owe={toc:[]};function Ewe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Owe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Ewe.isMDXComponent=!0;const Bwe={toc:[]};function Gwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Gwe.isMDXComponent=!0;const Uwe={toc:[]};function Fwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Fwe.isMDXComponent=!0;const Vwe={toc:[]};function qwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}qwe.isMDXComponent=!0;const jwe={toc:[]};function Hwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Hwe.isMDXComponent=!0;const Qwe={toc:[]};function Ywe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Ywe.isMDXComponent=!0;const $we={toc:[]};function Kwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$we,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Kwe.isMDXComponent=!0;const Jwe={toc:[]};function t_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}t_e.isMDXComponent=!0;const e_e={toc:[]};function n_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}n_e.isMDXComponent=!0;const o_e={toc:[]};function p_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}p_e.isMDXComponent=!0;const r_e={toc:[]};function s_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}s_e.isMDXComponent=!0;const c_e={toc:[]};function i_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}i_e.isMDXComponent=!0;const a_e={toc:[]};function l_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}l_e.isMDXComponent=!0;const u_e={toc:[]};function m_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}m_e.isMDXComponent=!0;const d_e={toc:[]};function h_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}h_e.isMDXComponent=!0;const f_e={toc:[]};function k_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}k_e.isMDXComponent=!0;const y_e={toc:[]};function D_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}D_e.isMDXComponent=!0;const M_e={toc:[]};function w_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}w_e.isMDXComponent=!0;const __e={toc:[]};function X_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},__e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}X_e.isMDXComponent=!0;const g_e={toc:[]};function T_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}T_e.isMDXComponent=!0;const C_e={toc:[]};function x_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}x_e.isMDXComponent=!0;const v_e={toc:[]};function L_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}L_e.isMDXComponent=!0;const Z_e={toc:[]};function b_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}b_e.isMDXComponent=!0;const N_e={toc:[]};function z_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}z_e.isMDXComponent=!0;const A_e={toc:[]};function W_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}W_e.isMDXComponent=!0;const I_e={toc:[]};function R_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}R_e.isMDXComponent=!0;const P_e={toc:[]};function S_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}S_e.isMDXComponent=!0;const O_e={toc:[]};function E_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}E_e.isMDXComponent=!0;const B_e={toc:[]};function G_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}G_e.isMDXComponent=!0;const U_e={toc:[]};function F_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}F_e.isMDXComponent=!0;const V_e={toc:[]};function q_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}q_e.isMDXComponent=!0;const j_e={toc:[]};function H_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}H_e.isMDXComponent=!0;const Q_e={toc:[]};function Y_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Y_e.isMDXComponent=!0;const $_e={toc:[]};function K_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}K_e.isMDXComponent=!0;const J_e={toc:[]};function tXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}tXe.isMDXComponent=!0;const eXe={toc:[]};function nXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}nXe.isMDXComponent=!0;const oXe={toc:[]};function pXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}pXe.isMDXComponent=!0;const rXe={toc:[]};function sXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}sXe.isMDXComponent=!0;const cXe={toc:[]};function iXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}iXe.isMDXComponent=!0;const aXe={toc:[]};function lXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}lXe.isMDXComponent=!0;const uXe={toc:[]};function mXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}mXe.isMDXComponent=!0;const dXe={toc:[]};function hXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}hXe.isMDXComponent=!0;const fXe={toc:[]};function kXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}kXe.isMDXComponent=!0;const yXe={toc:[]};function DXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}DXe.isMDXComponent=!0;const MXe={toc:[]};function wXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}wXe.isMDXComponent=!0;const _Xe={toc:[]};function XXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}XXe.isMDXComponent=!0;const gXe={toc:[]};function TXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}TXe.isMDXComponent=!0;const CXe={toc:[]};function xXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}xXe.isMDXComponent=!0;const vXe={toc:[]};function LXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}LXe.isMDXComponent=!0;const ZXe={toc:[]};function bXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bXe.isMDXComponent=!0;const NXe={toc:[]};function zXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}zXe.isMDXComponent=!0;const AXe={toc:[]};function WXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}WXe.isMDXComponent=!0;const IXe={toc:[]};function RXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}RXe.isMDXComponent=!0;const PXe={toc:[]};function SXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}SXe.isMDXComponent=!0;const OXe={toc:[]};function EXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}EXe.isMDXComponent=!0;const BXe={toc:[]};function GXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}GXe.isMDXComponent=!0;const UXe={toc:[]};function FXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}FXe.isMDXComponent=!0;const VXe={toc:[]};function qXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}qXe.isMDXComponent=!0;const jXe={toc:[]};function HXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}HXe.isMDXComponent=!0;const QXe={toc:[]};function YXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}YXe.isMDXComponent=!0;const $Xe={toc:[]};function KXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}KXe.isMDXComponent=!0;const JXe={toc:[]};function tge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}tge.isMDXComponent=!0;const ege={toc:[]};function nge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ege,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}nge.isMDXComponent=!0;const oge={toc:[]};function pge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}pge.isMDXComponent=!0;const rge={toc:[]};function sge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}sge.isMDXComponent=!0;const cge={toc:[]};function ige(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ige.isMDXComponent=!0;const age={toc:[]};function lge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},age,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}lge.isMDXComponent=!0;const uge={toc:[]};function mge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}mge.isMDXComponent=!0;const dge={toc:[]};function hge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}hge.isMDXComponent=!0;const fge={toc:[]};function kge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}kge.isMDXComponent=!0;const yge={toc:[]};function Dge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Dge.isMDXComponent=!0;const Mge={toc:[]};function wge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wge.isMDXComponent=!0;const _ge={toc:[]};function Xge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Xge.isMDXComponent=!0;const gge={toc:[]};function Tge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Tge.isMDXComponent=!0;const Cge={toc:[]};function xge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}xge.isMDXComponent=!0;const vge={toc:[]};function Lge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Lge.isMDXComponent=!0;const Zge={toc:[]};function bge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}bge.isMDXComponent=!0;const Nge={toc:[]};function zge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}zge.isMDXComponent=!0;const Age={toc:[]};function Wge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Age,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Wge.isMDXComponent=!0;const Ige={toc:[]};function Rge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ige,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Rge.isMDXComponent=!0;const Pge={toc:[]};function Sge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Sge.isMDXComponent=!0;const Oge={toc:[]};function Ege(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Ege.isMDXComponent=!0;const Bge={toc:[]};function Gge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Gge.isMDXComponent=!0;const Uge={toc:[]};function Fge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Fge.isMDXComponent=!0;const Vge={toc:[]};function qge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}qge.isMDXComponent=!0;const jge={toc:[]};function Hge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Hge.isMDXComponent=!0;const Qge={toc:[]};function Yge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Yge.isMDXComponent=!0;const $ge={toc:[]};function Kge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Kge.isMDXComponent=!0;const Jge={toc:[]};function tTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}tTe.isMDXComponent=!0;const eTe={toc:[]};function nTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}nTe.isMDXComponent=!0;const oTe={toc:[]};function pTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}pTe.isMDXComponent=!0;const rTe={toc:[]};function sTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}sTe.isMDXComponent=!0;const cTe={toc:[]};function iTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}iTe.isMDXComponent=!0;const aTe={toc:[]};function lTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}lTe.isMDXComponent=!0;const uTe={toc:[]};function mTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}mTe.isMDXComponent=!0;const dTe={toc:[]};function hTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}hTe.isMDXComponent=!0;const fTe={toc:[]};function kTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}kTe.isMDXComponent=!0;const yTe={toc:[]};function DTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}DTe.isMDXComponent=!0;const MTe={toc:[]};function wTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}wTe.isMDXComponent=!0;const _Te={toc:[]};function XTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Te,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}XTe.isMDXComponent=!0;const gTe={toc:[]};function TTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}TTe.isMDXComponent=!0;const CTe={toc:[]};function xTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}xTe.isMDXComponent=!0;const vTe={toc:[]};function LTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}LTe.isMDXComponent=!0;const ZTe={toc:[]};function bTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}bTe.isMDXComponent=!0;const NTe={toc:[]};function zTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}zTe.isMDXComponent=!0;const ATe={toc:[]};function WTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ATe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}WTe.isMDXComponent=!0;const ITe={toc:[]};function RTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ITe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}RTe.isMDXComponent=!0;const PTe={toc:[]};function STe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}STe.isMDXComponent=!0;const OTe={toc:[]};function ETe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}ETe.isMDXComponent=!0;const BTe={toc:[]};function GTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}GTe.isMDXComponent=!0;const UTe={toc:[]};function FTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}FTe.isMDXComponent=!0;const VTe={toc:[]};function qTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qTe.isMDXComponent=!0;const jTe={toc:[]};function HTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}HTe.isMDXComponent=!0;const QTe={toc:[]};function YTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}YTe.isMDXComponent=!0;const $Te={toc:[]};function KTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Te,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}KTe.isMDXComponent=!0;const JTe={toc:[]};function tCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}tCe.isMDXComponent=!0;const eCe={toc:[]};function nCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}nCe.isMDXComponent=!0;const oCe={toc:[]};function pCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}pCe.isMDXComponent=!0;const rCe={toc:[]};function sCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}sCe.isMDXComponent=!0;const cCe={toc:[]};function iCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}iCe.isMDXComponent=!0;const aCe={toc:[]};function lCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}lCe.isMDXComponent=!0;const uCe={toc:[]};function mCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}mCe.isMDXComponent=!0;const dCe={toc:[]};function hCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}hCe.isMDXComponent=!0;const fCe={toc:[]};function kCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}kCe.isMDXComponent=!0;const yCe={toc:[]};function DCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}DCe.isMDXComponent=!0;const MCe={toc:[]};function wCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}wCe.isMDXComponent=!0;const _Ce={toc:[]};function XCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}XCe.isMDXComponent=!0;const gCe={toc:[]};function TCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}TCe.isMDXComponent=!0;const CCe={toc:[]};function xCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}xCe.isMDXComponent=!0;const vCe={toc:[]};function LCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}LCe.isMDXComponent=!0;const ZCe={toc:[]};function bCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}bCe.isMDXComponent=!0;const NCe={toc:[]};function zCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}zCe.isMDXComponent=!0;const ACe={toc:[]};function WCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ACe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}WCe.isMDXComponent=!0;const ICe={toc:[]};function RCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ICe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}RCe.isMDXComponent=!0;const PCe={toc:[]};function SCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}SCe.isMDXComponent=!0;const OCe={toc:[]};function ECe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}ECe.isMDXComponent=!0;const BCe={toc:[]};function GCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}GCe.isMDXComponent=!0;const UCe={toc:[]};function FCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local video:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import video from './example.mp4';\n// ...\nview.add(<Video src={video} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Video src="https://example.com/video.mp4" />)\n')))}FCe.isMDXComponent=!0;const VCe={toc:[]};function qCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}qCe.isMDXComponent=!0;const jCe={toc:[]};function HCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}HCe.isMDXComponent=!0;const QCe={toc:[]};function YCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}YCe.isMDXComponent=!0;const $Ce={toc:[]};function KCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}KCe.isMDXComponent=!0;const JCe={toc:[]};function txe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}txe.isMDXComponent=!0;const exe={toc:[]};function nxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},exe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}nxe.isMDXComponent=!0;const oxe={toc:[]};function pxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}pxe.isMDXComponent=!0;const rxe={toc:[]};function sxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}sxe.isMDXComponent=!0;const cxe={toc:[]};function ixe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}ixe.isMDXComponent=!0;const axe={toc:[]};function lxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},axe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}lxe.isMDXComponent=!0;const uxe={toc:[]};function mxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}mxe.isMDXComponent=!0;const dxe={toc:[]};function hxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}hxe.isMDXComponent=!0;const fxe={toc:[]};function kxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}kxe.isMDXComponent=!0;const yxe={toc:[]};function Dxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Dxe.isMDXComponent=!0;const Mxe={toc:[]};function wxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}wxe.isMDXComponent=!0;const _xe={toc:[]};function Xxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Xxe.isMDXComponent=!0;const gxe={toc:[]};function Txe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Txe.isMDXComponent=!0;const Cxe={toc:[]};function xxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}xxe.isMDXComponent=!0;const vxe={toc:[]};function Lxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Lxe.isMDXComponent=!0;const Zxe={toc:[]};function bxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}bxe.isMDXComponent=!0;const Nxe={toc:[]};function zxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}zxe.isMDXComponent=!0;const Axe={toc:[]};function Wxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Axe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Wxe.isMDXComponent=!0;const Ixe={toc:[]};function Rxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ixe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Rxe.isMDXComponent=!0;const Pxe={toc:[]};function Sxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Sxe.isMDXComponent=!0;const Oxe={toc:[]};function Exe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Exe.isMDXComponent=!0;const Bxe={toc:[]};function Gxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Gxe.isMDXComponent=!0;const Uxe={toc:[]};function Fxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Fxe.isMDXComponent=!0;const Vxe={toc:[]};function qxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}qxe.isMDXComponent=!0;const jxe={toc:[]};function Hxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Hxe.isMDXComponent=!0;const Qxe={toc:[]};function Yxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Yxe.isMDXComponent=!0;const $xe={toc:[]};function Kxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Kxe.isMDXComponent=!0;const Jxe={toc:[]};function tve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}tve.isMDXComponent=!0;const eve={toc:[]};function nve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}nve.isMDXComponent=!0;const ove={toc:[]};function pve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ove,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}pve.isMDXComponent=!0;const rve={toc:[]};function sve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}sve.isMDXComponent=!0;const cve={toc:[]};function ive(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}ive.isMDXComponent=!0;const ave={toc:[]};function lve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ave,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}lve.isMDXComponent=!0;const uve={toc:[]};function mve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}mve.isMDXComponent=!0;const dve={toc:[]};function hve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}hve.isMDXComponent=!0;const fve={toc:[]};function kve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}kve.isMDXComponent=!0;const yve={toc:[]};function Dve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Dve.isMDXComponent=!0;const Mve={toc:[]};function wve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wve.isMDXComponent=!0;const _ve={toc:[]};function Xve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Xve.isMDXComponent=!0;const gve={toc:[]};function Tve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Tve.isMDXComponent=!0;const Cve={toc:[]};function xve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}xve.isMDXComponent=!0;const vve={toc:[]};function Lve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Lve.isMDXComponent=!0;const Zve={toc:[]};function bve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}bve.isMDXComponent=!0;const Nve={toc:[]};function zve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}zve.isMDXComponent=!0;const Ave={toc:[]};function Wve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ave,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Wve.isMDXComponent=!0;const Ive={toc:[]};function Rve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ive,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Rve.isMDXComponent=!0;const Pve={toc:[]};function Sve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Sve.isMDXComponent=!0;const Ove={toc:[]};function Eve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ove,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Eve.isMDXComponent=!0;const Bve={toc:[]};function Gve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Gve.isMDXComponent=!0;const Uve={toc:[]};function Fve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Fve.isMDXComponent=!0;const Vve={toc:[]};function qve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}qve.isMDXComponent=!0;const jve={toc:[]};function Hve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Hve.isMDXComponent=!0;const Qve={toc:[]};function Yve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Yve.isMDXComponent=!0;const $ve={toc:[]};function Kve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Kve.isMDXComponent=!0;const Jve={toc:[]};function tLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}tLe.isMDXComponent=!0;const eLe={toc:[]};function nLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}nLe.isMDXComponent=!0;const oLe={toc:[]};function pLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}pLe.isMDXComponent=!0;const rLe={toc:[]};function sLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}sLe.isMDXComponent=!0;const cLe={toc:[]};function iLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}iLe.isMDXComponent=!0;const aLe={toc:[]};function lLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}lLe.isMDXComponent=!0;const uLe={toc:[]};function mLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}mLe.isMDXComponent=!0;const dLe={toc:[]};function hLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}hLe.isMDXComponent=!0;const fLe={toc:[]};function kLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}kLe.isMDXComponent=!0;const yLe={toc:[]};function DLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}DLe.isMDXComponent=!0;const MLe={toc:[]};function wLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}wLe.isMDXComponent=!0;const _Le={toc:[]};function XLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}XLe.isMDXComponent=!0;const gLe={toc:[]};function TLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}TLe.isMDXComponent=!0;const CLe={toc:[]};function xLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}xLe.isMDXComponent=!0;const vLe={toc:[]};function LLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}LLe.isMDXComponent=!0;const ZLe={toc:[]};function bLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}bLe.isMDXComponent=!0;const NLe={toc:[]};function zLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}zLe.isMDXComponent=!0;const ALe={toc:[]};function WLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ALe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}WLe.isMDXComponent=!0;const ILe={toc:[]};function RLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ILe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}RLe.isMDXComponent=!0;const PLe={toc:[]};function SLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}SLe.isMDXComponent=!0;const OLe={toc:[]};function ELe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}ELe.isMDXComponent=!0;const BLe={toc:[]};function GLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}GLe.isMDXComponent=!0;const ULe={toc:[]};function FLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ULe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}FLe.isMDXComponent=!0;const VLe={toc:[]};function qLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}qLe.isMDXComponent=!0;const jLe={toc:[]};function HLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}HLe.isMDXComponent=!0;const QLe={toc:[]};function YLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}YLe.isMDXComponent=!0;const $Le={toc:[]};function KLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}KLe.isMDXComponent=!0;const JLe={toc:[]};function tZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}tZe.isMDXComponent=!0;const eZe={toc:[]};function nZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}nZe.isMDXComponent=!0;const oZe={toc:[]};function pZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}pZe.isMDXComponent=!0;const rZe={toc:[]};function sZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}sZe.isMDXComponent=!0;const cZe={toc:[]};function iZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}iZe.isMDXComponent=!0;const aZe={toc:[]};function lZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}lZe.isMDXComponent=!0;const uZe={toc:[]};function mZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}mZe.isMDXComponent=!0;const dZe={toc:[]};function hZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}hZe.isMDXComponent=!0;const fZe={toc:[]};function kZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}kZe.isMDXComponent=!0;const yZe={toc:[]};function DZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}DZe.isMDXComponent=!0;const MZe={toc:[]};function wZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}wZe.isMDXComponent=!0;const _Ze={toc:[]};function XZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}XZe.isMDXComponent=!0;const gZe={toc:[]};function TZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}TZe.isMDXComponent=!0;const CZe={toc:[]};function xZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}xZe.isMDXComponent=!0;const vZe={toc:[]};function LZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}LZe.isMDXComponent=!0;const ZZe={toc:[]};function bZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}bZe.isMDXComponent=!0;const NZe={toc:[]};function zZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}zZe.isMDXComponent=!0;const AZe={toc:[]};function WZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}WZe.isMDXComponent=!0;const IZe={toc:[]};function RZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}RZe.isMDXComponent=!0;const PZe={toc:[]};function SZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}SZe.isMDXComponent=!0;const OZe={toc:[]};function EZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}EZe.isMDXComponent=!0;const BZe={toc:[]};function GZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}GZe.isMDXComponent=!0;const UZe={toc:[]};function FZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}FZe.isMDXComponent=!0;const VZe={toc:[]};function qZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}qZe.isMDXComponent=!0;const jZe={toc:[]};function HZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}HZe.isMDXComponent=!0;const QZe={toc:[]};function YZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}YZe.isMDXComponent=!0;const $Ze={toc:[]};function KZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}KZe.isMDXComponent=!0;const JZe={toc:[]};function tbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}tbe.isMDXComponent=!0;const ebe={toc:[]};function nbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ebe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}nbe.isMDXComponent=!0;const obe={toc:[]};function pbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},obe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}pbe.isMDXComponent=!0;const rbe={toc:[]};function sbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}sbe.isMDXComponent=!0;const cbe={toc:[]};function ibe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ibe.isMDXComponent=!0;const abe={toc:[]};function lbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},abe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}lbe.isMDXComponent=!0;const ube={toc:[]};function mbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ube,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}mbe.isMDXComponent=!0;const dbe={toc:[]};function hbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}hbe.isMDXComponent=!0;const fbe={toc:[]};function kbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}kbe.isMDXComponent=!0;const ybe={toc:[]};function Dbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ybe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Dbe.isMDXComponent=!0;const Mbe={toc:[]};function wbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wbe.isMDXComponent=!0;const _be={toc:[]};function Xbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_be,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Xbe.isMDXComponent=!0;const gbe={toc:[]};function Tbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Tbe.isMDXComponent=!0;const Cbe={toc:[]};function xbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}xbe.isMDXComponent=!0;const vbe={toc:[]};function Lbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Lbe.isMDXComponent=!0;const Zbe={toc:[]};function bbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}bbe.isMDXComponent=!0;const Nbe={toc:[]};function zbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}zbe.isMDXComponent=!0;const Abe={toc:[]};function Wbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Abe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Wbe.isMDXComponent=!0;const Ibe={toc:[]};function Rbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ibe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Rbe.isMDXComponent=!0;const Pbe={toc:[]};function Sbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Sbe.isMDXComponent=!0;const Obe={toc:[]};function Ebe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Obe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Ebe.isMDXComponent=!0;const Bbe={toc:[]};function Gbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Gbe.isMDXComponent=!0;const Ube={toc:[]};function Fbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ube,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Fbe.isMDXComponent=!0;const Vbe={toc:[]};function qbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}qbe.isMDXComponent=!0;const jbe={toc:[]};function Hbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Hbe.isMDXComponent=!0;const Qbe={toc:[]};function Ybe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Ybe.isMDXComponent=!0;const $be={toc:[]};function Kbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$be,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Kbe.isMDXComponent=!0;const Jbe={toc:[]};function tNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}tNe.isMDXComponent=!0;const eNe={toc:[]};function nNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}nNe.isMDXComponent=!0;const oNe={toc:[]};function pNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}pNe.isMDXComponent=!0;const rNe={toc:[]};function sNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}sNe.isMDXComponent=!0;const cNe={toc:[]};function iNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}iNe.isMDXComponent=!0;const aNe={toc:[]};function lNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}lNe.isMDXComponent=!0;const uNe={toc:[]};function mNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}mNe.isMDXComponent=!0;const dNe={toc:[]};function hNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}hNe.isMDXComponent=!0;const fNe={toc:[]};function kNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kNe.isMDXComponent=!0;const yNe={toc:[]};function DNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}DNe.isMDXComponent=!0;const MNe={toc:[]};function wNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}wNe.isMDXComponent=!0;const _Ne={toc:[]};function XNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}XNe.isMDXComponent=!0;const gNe={toc:[]};function TNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}TNe.isMDXComponent=!0;const CNe={toc:[]};function xNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}xNe.isMDXComponent=!0;const vNe={toc:[]};function LNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}LNe.isMDXComponent=!0;const ZNe={toc:[]};function bNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}bNe.isMDXComponent=!0;const NNe={toc:[]};function zNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}zNe.isMDXComponent=!0;const ANe={toc:[]};function WNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ANe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}WNe.isMDXComponent=!0;const INe={toc:[]};function RNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},INe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}RNe.isMDXComponent=!0;const PNe={toc:[]};function SNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}SNe.isMDXComponent=!0;const ONe={toc:[]};function ENe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ONe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}ENe.isMDXComponent=!0;const BNe={toc:[]};function GNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}GNe.isMDXComponent=!0;const UNe={toc:[]};function FNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}FNe.isMDXComponent=!0;const VNe={toc:[]};function qNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}qNe.isMDXComponent=!0;const jNe={toc:[]};function HNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}HNe.isMDXComponent=!0;const QNe={toc:[]};function YNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}YNe.isMDXComponent=!0;const $Ne={toc:[]};function KNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}KNe.isMDXComponent=!0;const JNe={toc:[]};function tze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}tze.isMDXComponent=!0;const eze={toc:[]};function nze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}nze.isMDXComponent=!0;const oze={toc:[]};function pze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}pze.isMDXComponent=!0;const rze={toc:[]};function sze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}sze.isMDXComponent=!0;const cze={toc:[]};function ize(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}ize.isMDXComponent=!0;const aze={toc:[]};function lze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}lze.isMDXComponent=!0;const uze={toc:[]};function mze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}mze.isMDXComponent=!0;const dze={toc:[]};function hze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}hze.isMDXComponent=!0;const fze={toc:[]};function kze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}kze.isMDXComponent=!0;const yze={toc:[]};function Dze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Dze.isMDXComponent=!0;const Mze={toc:[]};function wze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}wze.isMDXComponent=!0;const _ze={toc:[]};function Xze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Xze.isMDXComponent=!0;const gze={toc:[]};function Tze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Tze.isMDXComponent=!0;const Cze={toc:[]};function xze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}xze.isMDXComponent=!0;const vze={toc:[]};function Lze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Lze.isMDXComponent=!0;const Zze={toc:[]};function bze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}bze.isMDXComponent=!0;const Nze={toc:[]};function zze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}zze.isMDXComponent=!0;const Aze={toc:[]};function Wze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Wze.isMDXComponent=!0;const Ize={toc:[]};function Rze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ize,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Rze.isMDXComponent=!0;const Pze={toc:[]};function Sze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Sze.isMDXComponent=!0;const Oze={toc:[]};function Eze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Eze.isMDXComponent=!0;const Bze={toc:[]};function Gze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Gze.isMDXComponent=!0;const Uze={toc:[]};function Fze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Fze.isMDXComponent=!0;const Vze={toc:[]};function qze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}qze.isMDXComponent=!0;const jze={toc:[]};function Hze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Hze.isMDXComponent=!0;const Qze={toc:[]};function Yze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Yze.isMDXComponent=!0;const $ze={toc:[]};function Kze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Kze.isMDXComponent=!0;const Jze={toc:[]};function tAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}tAe.isMDXComponent=!0;const eAe={toc:[]};function nAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}nAe.isMDXComponent=!0;const oAe={toc:[]};function pAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}pAe.isMDXComponent=!0;const rAe={toc:[]};function sAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}sAe.isMDXComponent=!0;const cAe={toc:[]};function iAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}iAe.isMDXComponent=!0;const aAe={toc:[]};function lAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}lAe.isMDXComponent=!0;const uAe={toc:[]};function mAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}mAe.isMDXComponent=!0;const dAe={toc:[]};function hAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}hAe.isMDXComponent=!0;const fAe={toc:[]};function kAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}kAe.isMDXComponent=!0;const yAe={toc:[]};function DAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}DAe.isMDXComponent=!0;const MAe={toc:[]};function wAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}wAe.isMDXComponent=!0;const _Ae={toc:[]};function XAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}XAe.isMDXComponent=!0;const gAe={toc:[]};function TAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}TAe.isMDXComponent=!0;const CAe={toc:[]};function xAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}xAe.isMDXComponent=!0;const vAe={toc:[]};function LAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}LAe.isMDXComponent=!0;const ZAe={toc:[]};function bAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}bAe.isMDXComponent=!0;const NAe={toc:[]};function zAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}zAe.isMDXComponent=!0;const AAe={toc:[]};function WAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}WAe.isMDXComponent=!0;const IAe={toc:[]};function RAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}RAe.isMDXComponent=!0;const PAe={toc:[]};function SAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}SAe.isMDXComponent=!0;const OAe={toc:[]};function EAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}EAe.isMDXComponent=!0;const BAe={toc:[]};function GAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}GAe.isMDXComponent=!0;const UAe={toc:[]};function FAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}FAe.isMDXComponent=!0;const VAe={toc:[]};function qAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}qAe.isMDXComponent=!0;const jAe={toc:[]};function HAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}HAe.isMDXComponent=!0;const QAe={toc:[]};function YAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}YAe.isMDXComponent=!0;const $Ae={toc:[]};function KAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}KAe.isMDXComponent=!0;const JAe={toc:[]};function tWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}tWe.isMDXComponent=!0;const eWe={toc:[]};function nWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}nWe.isMDXComponent=!0;const oWe={toc:[]};function pWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pWe.isMDXComponent=!0;const rWe={toc:[]};function sWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}sWe.isMDXComponent=!0;const cWe={toc:[]};function iWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}iWe.isMDXComponent=!0;const aWe={toc:[]};function lWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lWe.isMDXComponent=!0;const uWe={toc:[]};function mWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}mWe.isMDXComponent=!0;const dWe={toc:[]};function hWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}hWe.isMDXComponent=!0;const fWe={toc:[]};function kWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kWe.isMDXComponent=!0;const yWe={toc:[]};function DWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}DWe.isMDXComponent=!0;const MWe={toc:[]};function wWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}wWe.isMDXComponent=!0;const _We={toc:[]};function XWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_We,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}XWe.isMDXComponent=!0;const gWe={toc:[]};function TWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}TWe.isMDXComponent=!0;const CWe={toc:[]};function xWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}xWe.isMDXComponent=!0;const vWe={toc:[]};function LWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}LWe.isMDXComponent=!0;const ZWe={toc:[]};function bWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}bWe.isMDXComponent=!0;const NWe={toc:[]};function zWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}zWe.isMDXComponent=!0;const AWe={toc:[]};function WWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}WWe.isMDXComponent=!0;const IWe={toc:[]};function RWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}RWe.isMDXComponent=!0;const PWe={toc:[]};function SWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}SWe.isMDXComponent=!0;const OWe={toc:[]};function EWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}EWe.isMDXComponent=!0;const BWe={toc:[]};function GWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}GWe.isMDXComponent=!0;const UWe={toc:[]};function FWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}FWe.isMDXComponent=!0;const VWe={toc:[]};function qWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}qWe.isMDXComponent=!0;const jWe={toc:[]};function HWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}HWe.isMDXComponent=!0;const QWe={toc:[]};function YWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}YWe.isMDXComponent=!0;const $We={toc:[]};function KWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$We,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}KWe.isMDXComponent=!0;const JWe={toc:[]};function tIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}tIe.isMDXComponent=!0;const eIe={toc:[]};function nIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}nIe.isMDXComponent=!0;const oIe={toc:[]};function pIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}pIe.isMDXComponent=!0;const rIe={toc:[]};function sIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}sIe.isMDXComponent=!0;const cIe={toc:[]};function iIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}iIe.isMDXComponent=!0;const aIe={toc:[]};function lIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}lIe.isMDXComponent=!0;const uIe={toc:[]};function mIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}mIe.isMDXComponent=!0;const dIe={toc:[]};function hIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}hIe.isMDXComponent=!0;const fIe={toc:[]};function kIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}kIe.isMDXComponent=!0;const yIe={toc:[]};function DIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}DIe.isMDXComponent=!0;const MIe={toc:[]};function wIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wIe.isMDXComponent=!0;const _Ie={toc:[]};function XIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}XIe.isMDXComponent=!0;const gIe={toc:[]};function TIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}TIe.isMDXComponent=!0;const CIe={toc:[]};function xIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}xIe.isMDXComponent=!0;const vIe={toc:[]};function LIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}LIe.isMDXComponent=!0;const ZIe={toc:[]};function bIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}bIe.isMDXComponent=!0;const NIe={toc:[]};function zIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}zIe.isMDXComponent=!0;const AIe={toc:[]};function WIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}WIe.isMDXComponent=!0;const IIe={toc:[]};function RIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}RIe.isMDXComponent=!0;const PIe={toc:[]};function SIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}SIe.isMDXComponent=!0;const OIe={toc:[]};function EIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}EIe.isMDXComponent=!0;const BIe={toc:[]};function GIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}GIe.isMDXComponent=!0;const UIe={toc:[]};function FIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}FIe.isMDXComponent=!0;const VIe={toc:[]};function qIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}qIe.isMDXComponent=!0;const jIe={toc:[]};function HIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}HIe.isMDXComponent=!0;const QIe={toc:[]};function YIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}YIe.isMDXComponent=!0;const $Ie={toc:[]};function KIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}KIe.isMDXComponent=!0;const JIe={toc:[]};function tRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}tRe.isMDXComponent=!0;const eRe={toc:[]};function nRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}nRe.isMDXComponent=!0;const oRe={toc:[]};function pRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}pRe.isMDXComponent=!0;const rRe={toc:[]};function sRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}sRe.isMDXComponent=!0;const cRe={toc:[]};function iRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}iRe.isMDXComponent=!0;const aRe={toc:[]};function lRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lRe.isMDXComponent=!0;const uRe={toc:[]};function mRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}mRe.isMDXComponent=!0;const dRe={toc:[]};function hRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}hRe.isMDXComponent=!0;const fRe={toc:[]};function kRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}kRe.isMDXComponent=!0;const yRe={toc:[]};function DRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}DRe.isMDXComponent=!0;const MRe={toc:[]};function wRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}wRe.isMDXComponent=!0;const _Re={toc:[]};function XRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}XRe.isMDXComponent=!0;const gRe={toc:[]};function TRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}TRe.isMDXComponent=!0;const CRe={toc:[]};function xRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}xRe.isMDXComponent=!0;const vRe={toc:[]};function LRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}LRe.isMDXComponent=!0;const ZRe={toc:[]};function bRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}bRe.isMDXComponent=!0;const NRe={toc:[]};function zRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}zRe.isMDXComponent=!0;const ARe={toc:[]};function WRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ARe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}WRe.isMDXComponent=!0;const IRe={toc:[]};function RRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}RRe.isMDXComponent=!0;const PRe={toc:[]};function SRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}SRe.isMDXComponent=!0;const ORe={toc:[]};function ERe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ORe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}ERe.isMDXComponent=!0;const BRe={toc:[]};function GRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}GRe.isMDXComponent=!0;const URe={toc:[]};function FRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},URe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}FRe.isMDXComponent=!0;const VRe={toc:[]};function qRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}qRe.isMDXComponent=!0;const jRe={toc:[]};function HRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}HRe.isMDXComponent=!0;const QRe={toc:[]};function YRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}YRe.isMDXComponent=!0;const $Re={toc:[]};function KRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}KRe.isMDXComponent=!0;const JRe={toc:[]};function tPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}tPe.isMDXComponent=!0;const ePe={toc:[]};function nPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ePe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}nPe.isMDXComponent=!0;const oPe={toc:[]};function pPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pPe.isMDXComponent=!0;const rPe={toc:[]};function sPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}sPe.isMDXComponent=!0;const cPe={toc:[]};function iPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}iPe.isMDXComponent=!0;const aPe={toc:[]};function lPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lPe.isMDXComponent=!0;const uPe={toc:[]};function mPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}mPe.isMDXComponent=!0;const dPe={toc:[]};function hPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}hPe.isMDXComponent=!0;const fPe={toc:[]};function kPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}kPe.isMDXComponent=!0;const yPe={toc:[]};function DPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}DPe.isMDXComponent=!0;const MPe={toc:[]};function wPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}wPe.isMDXComponent=!0;const _Pe={toc:[]};function XPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}XPe.isMDXComponent=!0;const gPe={toc:[]};function TPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}TPe.isMDXComponent=!0;const CPe={toc:[]};function xPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}xPe.isMDXComponent=!0;const vPe={toc:[]};function LPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LPe.isMDXComponent=!0;const ZPe={toc:[]};function bPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}bPe.isMDXComponent=!0;const NPe={toc:[]};function zPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zPe.isMDXComponent=!0;const APe={toc:[]};function WPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},APe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}WPe.isMDXComponent=!0;const IPe={toc:[]};function RPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}RPe.isMDXComponent=!0;const PPe={toc:[]};function SPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}SPe.isMDXComponent=!0;const OPe={toc:[]};function EPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}EPe.isMDXComponent=!0;const BPe={toc:[]};function GPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}GPe.isMDXComponent=!0;const UPe={toc:[]};function FPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the circle begins at ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}FPe.isMDXComponent=!0;const VPe={toc:[]};function qPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the circle sector should be drawn counterclockwise."))}qPe.isMDXComponent=!0;const jPe={toc:[]};function HPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}HPe.isMDXComponent=!0;const QPe={toc:[]};function YPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}YPe.isMDXComponent=!0;const $Pe={toc:[]};function KPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KPe.isMDXComponent=!0;const JPe={toc:[]};function tSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}tSe.isMDXComponent=!0;const eSe={toc:[]};function nSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nSe.isMDXComponent=!0;const oSe={toc:[]};function pSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pSe.isMDXComponent=!0;const rSe={toc:[]};function sSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}sSe.isMDXComponent=!0;const cSe={toc:[]};function iSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}iSe.isMDXComponent=!0;const aSe={toc:[]};function lSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lSe.isMDXComponent=!0;const uSe={toc:[]};function mSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}mSe.isMDXComponent=!0;const dSe={toc:[]};function hSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hSe.isMDXComponent=!0;const fSe={toc:[]};function kSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}kSe.isMDXComponent=!0;const ySe={toc:[]};function DSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ySe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}DSe.isMDXComponent=!0;const MSe={toc:[]};function wSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}wSe.isMDXComponent=!0;const _Se={toc:[]};function XSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}XSe.isMDXComponent=!0;const gSe={toc:[]};function TSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}TSe.isMDXComponent=!0;const CSe={toc:[]};function xSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xSe.isMDXComponent=!0;const vSe={toc:[]};function LSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}LSe.isMDXComponent=!0;const ZSe={toc:[]};function bSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bSe.isMDXComponent=!0;const NSe={toc:[]};function zSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}zSe.isMDXComponent=!0;const ASe={toc:[]};function WSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ASe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WSe.isMDXComponent=!0;const ISe={toc:[]};function RSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ISe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}RSe.isMDXComponent=!0;const PSe={toc:[]};function SSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}SSe.isMDXComponent=!0;const OSe={toc:[]};function ESe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}ESe.isMDXComponent=!0;const BSe={toc:[]};function GSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}GSe.isMDXComponent=!0;const USe={toc:[]};function FSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},USe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}FSe.isMDXComponent=!0;const VSe={toc:[]};function qSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qSe.isMDXComponent=!0;const jSe={toc:[]};function HSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}HSe.isMDXComponent=!0;const QSe={toc:[]};function YSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}YSe.isMDXComponent=!0;const $Se={toc:[]};function KSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}KSe.isMDXComponent=!0;const JSe={toc:[]};function tOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tOe.isMDXComponent=!0;const eOe={toc:[]};function nOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}nOe.isMDXComponent=!0;const oOe={toc:[]};function pOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pOe.isMDXComponent=!0;const rOe={toc:[]};function sOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}sOe.isMDXComponent=!0;const cOe={toc:[]};function iOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}iOe.isMDXComponent=!0;const aOe={toc:[]};function lOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}lOe.isMDXComponent=!0;const uOe={toc:[]};function mOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}mOe.isMDXComponent=!0;const dOe={toc:[]};function hOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}hOe.isMDXComponent=!0;const fOe={toc:[]};function kOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}kOe.isMDXComponent=!0;const yOe={toc:[]};function DOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}DOe.isMDXComponent=!0;const MOe={toc:[]};function wOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wOe.isMDXComponent=!0;const _Oe={toc:[]};function XOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}XOe.isMDXComponent=!0;const gOe={toc:[]};function TOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TOe.isMDXComponent=!0;const COe={toc:[]};function xOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},COe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}xOe.isMDXComponent=!0;const vOe={toc:[]};function LOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LOe.isMDXComponent=!0;const ZOe={toc:[]};function bOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}bOe.isMDXComponent=!0;const NOe={toc:[]};function zOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}zOe.isMDXComponent=!0;const AOe={toc:[]};function WOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}WOe.isMDXComponent=!0;const IOe={toc:[]};function ROe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ROe.isMDXComponent=!0;const POe={toc:[]};function SOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},POe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}SOe.isMDXComponent=!0;const OOe={toc:[]};function EOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}EOe.isMDXComponent=!0;const BOe={toc:[]};function GOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}GOe.isMDXComponent=!0;const UOe={toc:[]};function FOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FOe.isMDXComponent=!0;const VOe={toc:[]};function qOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}qOe.isMDXComponent=!0;const jOe={toc:[]};function HOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}HOe.isMDXComponent=!0;const QOe={toc:[]};function YOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}YOe.isMDXComponent=!0;const $Oe={toc:[]};function KOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}KOe.isMDXComponent=!0;const JOe={toc:[]};function tEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}tEe.isMDXComponent=!0;const eEe={toc:[]};function nEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nEe.isMDXComponent=!0;const oEe={toc:[]};function pEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}pEe.isMDXComponent=!0;const rEe={toc:[]};function sEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}sEe.isMDXComponent=!0;const cEe={toc:[]};function iEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}iEe.isMDXComponent=!0;const aEe={toc:[]};function lEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lEe.isMDXComponent=!0;const uEe={toc:[]};function mEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}mEe.isMDXComponent=!0;const dEe={toc:[]};function hEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hEe.isMDXComponent=!0;const fEe={toc:[]};function kEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}kEe.isMDXComponent=!0;const yEe={toc:[]};function DEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}DEe.isMDXComponent=!0;const MEe={toc:[]};function wEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}wEe.isMDXComponent=!0;const _Ee={toc:[]};function XEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}XEe.isMDXComponent=!0;const gEe={toc:[]};function TEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}TEe.isMDXComponent=!0;const CEe={toc:[]};function xEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}xEe.isMDXComponent=!0;const vEe={toc:[]};function LEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}LEe.isMDXComponent=!0;const ZEe={toc:[]};function bEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bEe.isMDXComponent=!0;const NEe={toc:[]};function zEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}zEe.isMDXComponent=!0;const AEe={toc:[]};function WEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WEe.isMDXComponent=!0;const IEe={toc:[]};function REe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}REe.isMDXComponent=!0;const PEe={toc:[]};function SEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}SEe.isMDXComponent=!0;const OEe={toc:[]};function EEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}EEe.isMDXComponent=!0;const BEe={toc:[]};function GEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}GEe.isMDXComponent=!0;const UEe={toc:[]};function FEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}FEe.isMDXComponent=!0;const VEe={toc:[]};function qEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qEe.isMDXComponent=!0;const jEe={toc:[]};function HEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}HEe.isMDXComponent=!0;const QEe={toc:[]};function YEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YEe.isMDXComponent=!0;const $Ee={toc:[]};function KEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}KEe.isMDXComponent=!0;const JEe={toc:[]};function tBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}tBe.isMDXComponent=!0;const eBe={toc:[]};function nBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the end of each grid line."))}nBe.isMDXComponent=!0;const oBe={toc:[]};function pBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pBe.isMDXComponent=!0;const rBe={toc:[]};function sBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}sBe.isMDXComponent=!0;const cBe={toc:[]};function iBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iBe.isMDXComponent=!0;const aBe={toc:[]};function lBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lBe.isMDXComponent=!0;const uBe={toc:[]};function mBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The spacing between the grid lines."))}mBe.isMDXComponent=!0;const dBe={toc:[]};function hBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}hBe.isMDXComponent=!0;const fBe={toc:[]};function kBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}kBe.isMDXComponent=!0;const yBe={toc:[]};function DBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}DBe.isMDXComponent=!0;const MBe={toc:[]};function wBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}wBe.isMDXComponent=!0;const _Be={toc:[]};function XBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Be,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}XBe.isMDXComponent=!0;const gBe={toc:[]};function TBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}TBe.isMDXComponent=!0;const CBe={toc:[]};function xBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xBe.isMDXComponent=!0;const vBe={toc:[]};function LBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}LBe.isMDXComponent=!0;const ZBe={toc:[]};function bBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}bBe.isMDXComponent=!0;const NBe={toc:[]};function zBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}zBe.isMDXComponent=!0;const ABe={toc:[]};function WBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ABe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}WBe.isMDXComponent=!0;const IBe={toc:[]};function RBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}RBe.isMDXComponent=!0;const PBe={toc:[]};function SBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}SBe.isMDXComponent=!0;const OBe={toc:[]};function EBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}EBe.isMDXComponent=!0;const BBe={toc:[]};function GBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}GBe.isMDXComponent=!0;const UBe={toc:[]};function FBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}FBe.isMDXComponent=!0;const VBe={toc:[]};function qBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qBe.isMDXComponent=!0;const jBe={toc:[]};function HBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}HBe.isMDXComponent=!0;const QBe={toc:[]};function YBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}YBe.isMDXComponent=!0;const $Be={toc:[]};function KBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Be,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}KBe.isMDXComponent=!0;const JBe={toc:[]};function tGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}tGe.isMDXComponent=!0;const eGe={toc:[]};function nGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}nGe.isMDXComponent=!0;const oGe={toc:[]};function pGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}pGe.isMDXComponent=!0;const rGe={toc:[]};function sGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}sGe.isMDXComponent=!0;const cGe={toc:[]};function iGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}iGe.isMDXComponent=!0;const aGe={toc:[]};function lGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}lGe.isMDXComponent=!0;const uGe={toc:[]};function mGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}mGe.isMDXComponent=!0;const dGe={toc:[]};function hGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}hGe.isMDXComponent=!0;const fGe={toc:[]};function kGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}kGe.isMDXComponent=!0;const yGe={toc:[]};function DGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}DGe.isMDXComponent=!0;const MGe={toc:[]};function wGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}wGe.isMDXComponent=!0;const _Ge={toc:[]};function XGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}XGe.isMDXComponent=!0;const gGe={toc:[]};function TGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TGe.isMDXComponent=!0;const CGe={toc:[]};function xGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}xGe.isMDXComponent=!0;const vGe={toc:[]};function LGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}LGe.isMDXComponent=!0;const ZGe={toc:[]};function bGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}bGe.isMDXComponent=!0;const NGe={toc:[]};function zGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zGe.isMDXComponent=!0;const AGe={toc:[]};function WGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}WGe.isMDXComponent=!0;const IGe={toc:[]};function RGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}RGe.isMDXComponent=!0;const PGe={toc:[]};function SGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}SGe.isMDXComponent=!0;const OGe={toc:[]};function EGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}EGe.isMDXComponent=!0;const BGe={toc:[]};function GGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}GGe.isMDXComponent=!0;const UGe={toc:[]};function FGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}FGe.isMDXComponent=!0;const VGe={toc:[]};function qGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qGe.isMDXComponent=!0;const jGe={toc:[]};function HGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}HGe.isMDXComponent=!0;const QGe={toc:[]};function YGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}YGe.isMDXComponent=!0;const $Ge={toc:[]};function KGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}KGe.isMDXComponent=!0;const JGe={toc:[]};function tUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}tUe.isMDXComponent=!0;const eUe={toc:[]};function nUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}nUe.isMDXComponent=!0;const oUe={toc:[]};function pUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pUe.isMDXComponent=!0;const rUe={toc:[]};function sUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}sUe.isMDXComponent=!0;const cUe={toc:[]};function iUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iUe.isMDXComponent=!0;const aUe={toc:[]};function lUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lUe.isMDXComponent=!0;const uUe={toc:[]};function mUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mUe.isMDXComponent=!0;const dUe={toc:[]};function hUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}hUe.isMDXComponent=!0;const fUe={toc:[]};function kUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}kUe.isMDXComponent=!0;const yUe={toc:[]};function DUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}DUe.isMDXComponent=!0;const MUe={toc:[]};function wUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}wUe.isMDXComponent=!0;const _Ue={toc:[]};function XUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}XUe.isMDXComponent=!0;const gUe={toc:[]};function TUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TUe.isMDXComponent=!0;const CUe={toc:[]};function xUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}xUe.isMDXComponent=!0;const vUe={toc:[]};function LUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LUe.isMDXComponent=!0;const ZUe={toc:[]};function bUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}bUe.isMDXComponent=!0;const NUe={toc:[]};function zUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zUe.isMDXComponent=!0;const AUe={toc:[]};function WUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}WUe.isMDXComponent=!0;const IUe={toc:[]};function RUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}RUe.isMDXComponent=!0;const PUe={toc:[]};function SUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}SUe.isMDXComponent=!0;const OUe={toc:[]};function EUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}EUe.isMDXComponent=!0;const BUe={toc:[]};function GUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}GUe.isMDXComponent=!0;const UUe={toc:[]};function FUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}FUe.isMDXComponent=!0;const VUe={toc:[]};function qUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}qUe.isMDXComponent=!0;const jUe={toc:[]};function HUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}HUe.isMDXComponent=!0;const QUe={toc:[]};function YUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}YUe.isMDXComponent=!0;const $Ue={toc:[]};function KUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}KUe.isMDXComponent=!0;const JUe={toc:[]};function tFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}tFe.isMDXComponent=!0;const eFe={toc:[]};function nFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nFe.isMDXComponent=!0;const oFe={toc:[]};function pFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}pFe.isMDXComponent=!0;const rFe={toc:[]};function sFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}sFe.isMDXComponent=!0;const cFe={toc:[]};function iFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}iFe.isMDXComponent=!0;const aFe={toc:[]};function lFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lFe.isMDXComponent=!0;const uFe={toc:[]};function mFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}mFe.isMDXComponent=!0;const dFe={toc:[]};function hFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}hFe.isMDXComponent=!0;const fFe={toc:[]};function kFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}kFe.isMDXComponent=!0;const yFe={toc:[]};function DFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}DFe.isMDXComponent=!0;const MFe={toc:[]};function wFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}wFe.isMDXComponent=!0;const _Fe={toc:[]};function XFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}XFe.isMDXComponent=!0;const gFe={toc:[]};function TFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}TFe.isMDXComponent=!0;const CFe={toc:[]};function xFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}xFe.isMDXComponent=!0;const vFe={toc:[]};function LFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}LFe.isMDXComponent=!0;const ZFe={toc:[]};function bFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}bFe.isMDXComponent=!0;const NFe={toc:[]};function zFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}zFe.isMDXComponent=!0;const AFe={toc:[]};function WFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}WFe.isMDXComponent=!0;const IFe={toc:[]};function RFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}RFe.isMDXComponent=!0;const PFe={toc:[]};function SFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}SFe.isMDXComponent=!0;const OFe={toc:[]};function EFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}EFe.isMDXComponent=!0;const BFe={toc:[]};function GFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}GFe.isMDXComponent=!0;const UFe={toc:[]};function FFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FFe.isMDXComponent=!0;const VFe={toc:[]};function qFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}qFe.isMDXComponent=!0;const jFe={toc:[]};function HFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}HFe.isMDXComponent=!0;const QFe={toc:[]};function YFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}YFe.isMDXComponent=!0;const $Fe={toc:[]};function KFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}KFe.isMDXComponent=!0;const JFe={toc:[]};function tVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}tVe.isMDXComponent=!0;const eVe={toc:[]};function nVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}nVe.isMDXComponent=!0;const oVe={toc:[]};function pVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}pVe.isMDXComponent=!0;const rVe={toc:[]};function sVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}sVe.isMDXComponent=!0;const cVe={toc:[]};function iVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}iVe.isMDXComponent=!0;const aVe={toc:[]};function lVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}lVe.isMDXComponent=!0;const uVe={toc:[]};function mVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}mVe.isMDXComponent=!0;const dVe={toc:[]};function hVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hVe.isMDXComponent=!0;const fVe={toc:[]};function kVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}kVe.isMDXComponent=!0;const yVe={toc:[]};function DVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}DVe.isMDXComponent=!0;const MVe={toc:[]};function wVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}wVe.isMDXComponent=!0;const _Ve={toc:[]};function XVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}XVe.isMDXComponent=!0;const gVe={toc:[]};function TVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}TVe.isMDXComponent=!0;const CVe={toc:[]};function xVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}xVe.isMDXComponent=!0;const vVe={toc:[]};function LVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}LVe.isMDXComponent=!0;const ZVe={toc:[]};function bVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}bVe.isMDXComponent=!0;const NVe={toc:[]};function zVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}zVe.isMDXComponent=!0;const AVe={toc:[]};function WVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}WVe.isMDXComponent=!0;const IVe={toc:[]};function RVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}RVe.isMDXComponent=!0;const PVe={toc:[]};function SVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}SVe.isMDXComponent=!0;const OVe={toc:[]};function EVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}EVe.isMDXComponent=!0;const BVe={toc:[]};function GVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}GVe.isMDXComponent=!0;const UVe={toc:[]};function FVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}FVe.isMDXComponent=!0;const VVe={toc:[]};function qVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qVe.isMDXComponent=!0;const jVe={toc:[]};function HVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}HVe.isMDXComponent=!0;const QVe={toc:[]};function YVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}YVe.isMDXComponent=!0;const $Ve={toc:[]};function KVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}KVe.isMDXComponent=!0;const JVe={toc:[]};function tqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tqe.isMDXComponent=!0;const eqe={toc:[]};function nqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}nqe.isMDXComponent=!0;const oqe={toc:[]};function pqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}pqe.isMDXComponent=!0;const rqe={toc:[]};function sqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}sqe.isMDXComponent=!0;const cqe={toc:[]};function iqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}iqe.isMDXComponent=!0;const aqe={toc:[]};function lqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}lqe.isMDXComponent=!0;const uqe={toc:[]};function mqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}mqe.isMDXComponent=!0;const dqe={toc:[]};function hqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}hqe.isMDXComponent=!0;const fqe={toc:[]};function kqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}kqe.isMDXComponent=!0;const yqe={toc:[]};function Dqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Dqe.isMDXComponent=!0;const Mqe={toc:[]};function wqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}wqe.isMDXComponent=!0;const _qe={toc:[]};function Xqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Xqe.isMDXComponent=!0;const gqe={toc:[]};function Tqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Tqe.isMDXComponent=!0;const Cqe={toc:[]};function xqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xqe.isMDXComponent=!0;const vqe={toc:[]};function Lqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Lqe.isMDXComponent=!0;const Zqe={toc:[]};function bqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bqe.isMDXComponent=!0;const Nqe={toc:[]};function zqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}zqe.isMDXComponent=!0;const Aqe={toc:[]};function Wqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wqe.isMDXComponent=!0;const Iqe={toc:[]};function Rqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Rqe.isMDXComponent=!0;const Pqe={toc:[]};function Sqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Sqe.isMDXComponent=!0;const Oqe={toc:[]};function Eqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Eqe.isMDXComponent=!0;const Bqe={toc:[]};function Gqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Gqe.isMDXComponent=!0;const Uqe={toc:[]};function Fqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Fqe.isMDXComponent=!0;const Vqe={toc:[]};function qqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qqe.isMDXComponent=!0;const jqe={toc:[]};function Hqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Hqe.isMDXComponent=!0;const Qqe={toc:[]};function Yqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yqe.isMDXComponent=!0;const $qe={toc:[]};function Kqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Kqe.isMDXComponent=!0;const Jqe={toc:[]};function tje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tje.isMDXComponent=!0;const eje={toc:[]};function nje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}nje.isMDXComponent=!0;const oje={toc:[]};function pje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pje.isMDXComponent=!0;const rje={toc:[]};function sje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}sje.isMDXComponent=!0;const cje={toc:[]};function ije(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ije.isMDXComponent=!0;const aje={toc:[]};function lje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lje.isMDXComponent=!0;const uje={toc:[]};function mje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mje.isMDXComponent=!0;const dje={toc:[]};function hje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}hje.isMDXComponent=!0;const fje={toc:[]};function kje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}kje.isMDXComponent=!0;const yje={toc:[]};function Dje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Dje.isMDXComponent=!0;const Mje={toc:[]};function wje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wje.isMDXComponent=!0;const _je={toc:[]};function Xje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Xje.isMDXComponent=!0;const gje={toc:[]};function Tje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Tje.isMDXComponent=!0;const Cje={toc:[]};function xje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}xje.isMDXComponent=!0;const vje={toc:[]};function Lje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lje.isMDXComponent=!0;const Zje={toc:[]};function bje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}bje.isMDXComponent=!0;const Nje={toc:[]};function zje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}zje.isMDXComponent=!0;const Aje={toc:[]};function Wje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Wje.isMDXComponent=!0;const Ije={toc:[]};function Rje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ije,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Rje.isMDXComponent=!0;const Pje={toc:[]};function Sje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Sje.isMDXComponent=!0;const Oje={toc:[]};function Eje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Eje.isMDXComponent=!0;const Bje={toc:[]};function Gje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Gje.isMDXComponent=!0;const Uje={toc:[]};function Fje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Fje.isMDXComponent=!0;const Vje={toc:[]};function qje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}qje.isMDXComponent=!0;const jje={toc:[]};function Hje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Hje.isMDXComponent=!0;const Qje={toc:[]};function Yje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Yje.isMDXComponent=!0;const $je={toc:[]};function Kje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kje.isMDXComponent=!0;const Jje={toc:[]};function tHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}tHe.isMDXComponent=!0;const eHe={toc:[]};function nHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}nHe.isMDXComponent=!0;const oHe={toc:[]};function pHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}pHe.isMDXComponent=!0;const rHe={toc:[]};function sHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}sHe.isMDXComponent=!0;const cHe={toc:[]};function iHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}iHe.isMDXComponent=!0;const aHe={toc:[]};function lHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lHe.isMDXComponent=!0;const uHe={toc:[]};function mHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}mHe.isMDXComponent=!0;const dHe={toc:[]};function hHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hHe.isMDXComponent=!0;const fHe={toc:[]};function kHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}kHe.isMDXComponent=!0;const yHe={toc:[]};function DHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}DHe.isMDXComponent=!0;const MHe={toc:[]};function wHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wHe.isMDXComponent=!0;const _He={toc:[]};function XHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_He,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}XHe.isMDXComponent=!0;const gHe={toc:[]};function THe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}THe.isMDXComponent=!0;const CHe={toc:[]};function xHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}xHe.isMDXComponent=!0;const vHe={toc:[]};function LHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}LHe.isMDXComponent=!0;const ZHe={toc:[]};function bHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bHe.isMDXComponent=!0;const NHe={toc:[]};function zHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}zHe.isMDXComponent=!0;const AHe={toc:[]};function WHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WHe.isMDXComponent=!0;const IHe={toc:[]};function RHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}RHe.isMDXComponent=!0;const PHe={toc:[]};function SHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}SHe.isMDXComponent=!0;const OHe={toc:[]};function EHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}EHe.isMDXComponent=!0;const BHe={toc:[]};function GHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}GHe.isMDXComponent=!0;const UHe={toc:[]};function FHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}FHe.isMDXComponent=!0;const VHe={toc:[]};function qHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qHe.isMDXComponent=!0;const jHe={toc:[]};function HHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}HHe.isMDXComponent=!0;const QHe={toc:[]};function YHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}YHe.isMDXComponent=!0;const $He={toc:[]};function KHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$He,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}KHe.isMDXComponent=!0;const JHe={toc:[]};function tQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}tQe.isMDXComponent=!0;const eQe={toc:[]};function nQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}nQe.isMDXComponent=!0;const oQe={toc:[]};function pQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pQe.isMDXComponent=!0;const rQe={toc:[]};function sQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}sQe.isMDXComponent=!0;const cQe={toc:[]};function iQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iQe.isMDXComponent=!0;const aQe={toc:[]};function lQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lQe.isMDXComponent=!0;const uQe={toc:[]};function mQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}mQe.isMDXComponent=!0;const dQe={toc:[]};function hQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}hQe.isMDXComponent=!0;const fQe={toc:[]};function kQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kQe.isMDXComponent=!0;const yQe={toc:[]};function DQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}DQe.isMDXComponent=!0;const MQe={toc:[]};function wQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}wQe.isMDXComponent=!0;const _Qe={toc:[]};function XQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}XQe.isMDXComponent=!0;const gQe={toc:[]};function TQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TQe.isMDXComponent=!0;const CQe={toc:[]};function xQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}xQe.isMDXComponent=!0;const vQe={toc:[]};function LQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LQe.isMDXComponent=!0;const ZQe={toc:[]};function bQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}bQe.isMDXComponent=!0;const NQe={toc:[]};function zQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zQe.isMDXComponent=!0;const AQe={toc:[]};function WQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}WQe.isMDXComponent=!0;const IQe={toc:[]};function RQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}RQe.isMDXComponent=!0;const PQe={toc:[]};function SQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}SQe.isMDXComponent=!0;const OQe={toc:[]};function EQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}EQe.isMDXComponent=!0;const BQe={toc:[]};function GQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}GQe.isMDXComponent=!0;const UQe={toc:[]};function FQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FQe.isMDXComponent=!0;const VQe={toc:[]};function qQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}qQe.isMDXComponent=!0;const jQe={toc:[]};function HQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}HQe.isMDXComponent=!0;const QQe={toc:[]};function YQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}YQe.isMDXComponent=!0;const $Qe={toc:[]};function KQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KQe.isMDXComponent=!0;const JQe={toc:[]};function tYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}tYe.isMDXComponent=!0;const eYe={toc:[]};function nYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}nYe.isMDXComponent=!0;const oYe={toc:[]};function pYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}pYe.isMDXComponent=!0;const rYe={toc:[]};function sYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sYe.isMDXComponent=!0;const cYe={toc:[]};function iYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}iYe.isMDXComponent=!0;const aYe={toc:[]};function lYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lYe.isMDXComponent=!0;const uYe={toc:[]};function mYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}mYe.isMDXComponent=!0;const dYe={toc:[]};function hYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hYe.isMDXComponent=!0;const fYe={toc:[]};function kYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}kYe.isMDXComponent=!0;const yYe={toc:[]};function DYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}DYe.isMDXComponent=!0;const MYe={toc:[]};function wYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}wYe.isMDXComponent=!0;const _Ye={toc:[]};function XYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}XYe.isMDXComponent=!0;const gYe={toc:[]};function TYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}TYe.isMDXComponent=!0;const CYe={toc:[]};function xYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xYe.isMDXComponent=!0;const vYe={toc:[]};function LYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}LYe.isMDXComponent=!0;const ZYe={toc:[]};function bYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bYe.isMDXComponent=!0;const NYe={toc:[]};function zYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}zYe.isMDXComponent=!0;const AYe={toc:[]};function WYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}WYe.isMDXComponent=!0;const IYe={toc:[]};function RYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}RYe.isMDXComponent=!0;const PYe={toc:[]};function SYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}SYe.isMDXComponent=!0;const OYe={toc:[]};function EYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}EYe.isMDXComponent=!0;const BYe={toc:[]};function GYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}GYe.isMDXComponent=!0;const UYe={toc:[]};function FYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}FYe.isMDXComponent=!0;const VYe={toc:[]};function qYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}qYe.isMDXComponent=!0;const jYe={toc:[]};function HYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}HYe.isMDXComponent=!0;const QYe={toc:[]};function YYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YYe.isMDXComponent=!0;const $Ye={toc:[]};function KYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}KYe.isMDXComponent=!0;const JYe={toc:[]};function t$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}t$e.isMDXComponent=!0;const e$e={toc:[]};function n$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}n$e.isMDXComponent=!0;const o$e={toc:[]};function p$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}p$e.isMDXComponent=!0;const r$e={toc:[]};function s$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}s$e.isMDXComponent=!0;const c$e={toc:[]};function i$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}i$e.isMDXComponent=!0;const a$e={toc:[]};function l$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}l$e.isMDXComponent=!0;const u$e={toc:[]};function m$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}m$e.isMDXComponent=!0;const d$e={toc:[]};function h$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}h$e.isMDXComponent=!0;const f$e={toc:[]};function k$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}k$e.isMDXComponent=!0;const y$e={toc:[]};function D$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}D$e.isMDXComponent=!0;const M$e={toc:[]};function w$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w$e.isMDXComponent=!0;const _$e={toc:[]};function X$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}X$e.isMDXComponent=!0;const g$e={toc:[]};function T$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}T$e.isMDXComponent=!0;const C$e={toc:[]};function x$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}x$e.isMDXComponent=!0;const v$e={toc:[]};function L$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}L$e.isMDXComponent=!0;const Z$e={toc:[]};function b$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}b$e.isMDXComponent=!0;const N$e={toc:[]};function z$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}z$e.isMDXComponent=!0;const A$e={toc:[]};function W$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}W$e.isMDXComponent=!0;const I$e={toc:[]};function R$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}R$e.isMDXComponent=!0;const P$e={toc:[]};function S$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}S$e.isMDXComponent=!0;const O$e={toc:[]};function E$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}E$e.isMDXComponent=!0;const B$e={toc:[]};function G$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}G$e.isMDXComponent=!0;const U$e={toc:[]};function F$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}F$e.isMDXComponent=!0;const V$e={toc:[]};function q$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}q$e.isMDXComponent=!0;const j$e={toc:[]};function H$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}H$e.isMDXComponent=!0;const Q$e={toc:[]};function Y$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Y$e.isMDXComponent=!0;const $$e={toc:[]};function K$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}K$e.isMDXComponent=!0;const J$e={toc:[]};function tKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}tKe.isMDXComponent=!0;const eKe={toc:[]};function nKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}nKe.isMDXComponent=!0;const oKe={toc:[]};function pKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}pKe.isMDXComponent=!0;const rKe={toc:[]};function sKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}sKe.isMDXComponent=!0;const cKe={toc:[]};function iKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iKe.isMDXComponent=!0;const aKe={toc:[]};function lKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}lKe.isMDXComponent=!0;const uKe={toc:[]};function mKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mKe.isMDXComponent=!0;const dKe={toc:[]};function hKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}hKe.isMDXComponent=!0;const fKe={toc:[]};function kKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kKe.isMDXComponent=!0;const yKe={toc:[]};function DKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}DKe.isMDXComponent=!0;const MKe={toc:[]};function wKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wKe.isMDXComponent=!0;const _Ke={toc:[]};function XKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}XKe.isMDXComponent=!0;const gKe={toc:[]};function TKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}TKe.isMDXComponent=!0;const CKe={toc:[]};function xKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}xKe.isMDXComponent=!0;const vKe={toc:[]};function LKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}LKe.isMDXComponent=!0;const ZKe={toc:[]};function bKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bKe.isMDXComponent=!0;const NKe={toc:[]};function zKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}zKe.isMDXComponent=!0;const AKe={toc:[]};function WKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WKe.isMDXComponent=!0;const IKe={toc:[]};function RKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}RKe.isMDXComponent=!0;const PKe={toc:[]};function SKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}SKe.isMDXComponent=!0;const OKe={toc:[]};function EKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}EKe.isMDXComponent=!0;const BKe={toc:[]};function GKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}GKe.isMDXComponent=!0;const UKe={toc:[]};function FKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}FKe.isMDXComponent=!0;const VKe={toc:[]};function qKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qKe.isMDXComponent=!0;const jKe={toc:[]};function HKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}HKe.isMDXComponent=!0;const QKe={toc:[]};function YKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YKe.isMDXComponent=!0;const $Ke={toc:[]};function KKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}KKe.isMDXComponent=!0;const JKe={toc:[]};function tJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tJe.isMDXComponent=!0;const eJe={toc:[]};function nJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}nJe.isMDXComponent=!0;const oJe={toc:[]};function pJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}pJe.isMDXComponent=!0;const rJe={toc:[]};function sJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}sJe.isMDXComponent=!0;const cJe={toc:[]};function iJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}iJe.isMDXComponent=!0;const aJe={toc:[]};function lJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}lJe.isMDXComponent=!0;const uJe={toc:[]};function mJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}mJe.isMDXComponent=!0;const dJe={toc:[]};function hJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}hJe.isMDXComponent=!0;const fJe={toc:[]};function kJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kJe.isMDXComponent=!0;const yJe={toc:[]};function DJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}DJe.isMDXComponent=!0;const MJe={toc:[]};function wJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}wJe.isMDXComponent=!0;const _Je={toc:[]};function XJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}XJe.isMDXComponent=!0;const gJe={toc:[]};function TJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}TJe.isMDXComponent=!0;const CJe={toc:[]};function xJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}xJe.isMDXComponent=!0;const vJe={toc:[]};function LJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}LJe.isMDXComponent=!0;const ZJe={toc:[]};function bJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}bJe.isMDXComponent=!0;const NJe={toc:[]};function zJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zJe.isMDXComponent=!0;const AJe={toc:[]};function WJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}WJe.isMDXComponent=!0;const IJe={toc:[]};function RJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}RJe.isMDXComponent=!0;const PJe={toc:[]};function SJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}SJe.isMDXComponent=!0;const OJe={toc:[]};function EJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}EJe.isMDXComponent=!0;const BJe={toc:[]};function GJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}GJe.isMDXComponent=!0;const UJe={toc:[]};function FJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}FJe.isMDXComponent=!0;const VJe={toc:[]};function qJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}qJe.isMDXComponent=!0;const jJe={toc:[]};function HJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}HJe.isMDXComponent=!0;const QJe={toc:[]};function YJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}YJe.isMDXComponent=!0;const $Je={toc:[]};function KJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KJe.isMDXComponent=!0;const JJe={toc:[]};function t0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}t0e.isMDXComponent=!0;const e0e={toc:[]};function n0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}n0e.isMDXComponent=!0;const o0e={toc:[]};function p0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}p0e.isMDXComponent=!0;const r0e={toc:[]};function s0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}s0e.isMDXComponent=!0;const c0e={toc:[]};function i0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}i0e.isMDXComponent=!0;const a0e={toc:[]};function l0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}l0e.isMDXComponent=!0;const u0e={toc:[]};function m0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}m0e.isMDXComponent=!0;const d0e={toc:[]};function h0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}h0e.isMDXComponent=!0;const f0e={toc:[]};function k0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}k0e.isMDXComponent=!0;const y0e={toc:[]};function D0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}D0e.isMDXComponent=!0;const M0e={toc:[]};function w0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}w0e.isMDXComponent=!0;const _0e={toc:[]};function X0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}X0e.isMDXComponent=!0;const g0e={toc:[]};function T0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}T0e.isMDXComponent=!0;const C0e={toc:[]};function x0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}x0e.isMDXComponent=!0;const v0e={toc:[]};function L0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}L0e.isMDXComponent=!0;const Z0e={toc:[]};function b0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}b0e.isMDXComponent=!0;const N0e={toc:[]};function z0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}z0e.isMDXComponent=!0;const A0e={toc:[]};function W0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}W0e.isMDXComponent=!0;const I0e={toc:[]};function R0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}R0e.isMDXComponent=!0;const P0e={toc:[]};function S0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}S0e.isMDXComponent=!0;const O0e={toc:[]};function E0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}E0e.isMDXComponent=!0;const B0e={toc:[]};function G0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}G0e.isMDXComponent=!0;const U0e={toc:[]};function F0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}F0e.isMDXComponent=!0;const V0e={toc:[]};function q0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}q0e.isMDXComponent=!0;const j0e={toc:[]};function H0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}H0e.isMDXComponent=!0;const Q0e={toc:[]};function Y0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Y0e.isMDXComponent=!0;const $0e={toc:[]};function K0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}K0e.isMDXComponent=!0;const J0e={toc:[]};function t5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}t5e.isMDXComponent=!0;const e5e={toc:[]};function n5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}n5e.isMDXComponent=!0;const o5e={toc:[]};function p5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}p5e.isMDXComponent=!0;const r5e={toc:[]};function s5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}s5e.isMDXComponent=!0;const c5e={toc:[]};function i5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}i5e.isMDXComponent=!0;const a5e={toc:[]};function l5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}l5e.isMDXComponent=!0;const u5e={toc:[]};function m5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}m5e.isMDXComponent=!0;const d5e={toc:[]};function h5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}h5e.isMDXComponent=!0;const f5e={toc:[]};function k5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}k5e.isMDXComponent=!0;const y5e={toc:[]};function D5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}D5e.isMDXComponent=!0;const M5e={toc:[]};function w5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w5e.isMDXComponent=!0;const _5e={toc:[]};function X5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}X5e.isMDXComponent=!0;const g5e={toc:[]};function T5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Spline.points"))}T5e.isMDXComponent=!0;const C5e={toc:[]};function x5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}x5e.isMDXComponent=!0;const v5e={toc:[]};function L5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}L5e.isMDXComponent=!0;const Z5e={toc:[]};function b5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}b5e.isMDXComponent=!0;const N5e={toc:[]};function z5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}z5e.isMDXComponent=!0;const A5e={toc:[]};function W5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}W5e.isMDXComponent=!0;const I5e={toc:[]};function R5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}R5e.isMDXComponent=!0;const P5e={toc:[]};function S5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}S5e.isMDXComponent=!0;const O5e={toc:[]};function E5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}E5e.isMDXComponent=!0;const B5e={toc:[]};function G5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}G5e.isMDXComponent=!0;const U5e={toc:[]};function F5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}F5e.isMDXComponent=!0;const V5e={toc:[]};function q5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}q5e.isMDXComponent=!0;const j5e={toc:[]};function H5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}H5e.isMDXComponent=!0;const Q5e={toc:[]};function Y5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Y5e.isMDXComponent=!0;const $5e={toc:[]};function K5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}K5e.isMDXComponent=!0;const J5e={toc:[]};function t8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}t8e.isMDXComponent=!0;const e8e={toc:[]};function n8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}n8e.isMDXComponent=!0;const o8e={toc:[]};function p8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p8e.isMDXComponent=!0;const r8e={toc:[]};function s8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}s8e.isMDXComponent=!0;const c8e={toc:[]};function i8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}i8e.isMDXComponent=!0;const a8e={toc:[]};function l8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}l8e.isMDXComponent=!0;const u8e={toc:[]};function m8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}m8e.isMDXComponent=!0;const d8e={toc:[]};function h8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}h8e.isMDXComponent=!0;const f8e={toc:[]};function k8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}k8e.isMDXComponent=!0;const y8e={toc:[]};function D8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}D8e.isMDXComponent=!0;const M8e={toc:[]};function w8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w8e.isMDXComponent=!0;const _8e={toc:[]};function X8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}X8e.isMDXComponent=!0;const g8e={toc:[]};function T8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}T8e.isMDXComponent=!0;const C8e={toc:[]};function x8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}x8e.isMDXComponent=!0;const v8e={toc:[]};function L8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}L8e.isMDXComponent=!0;const Z8e={toc:[]};function b8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}b8e.isMDXComponent=!0;const N8e={toc:[]};function z8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}z8e.isMDXComponent=!0;const A8e={toc:[]};function W8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}W8e.isMDXComponent=!0;const I8e={toc:[]};function R8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}R8e.isMDXComponent=!0;const P8e={toc:[]};function S8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}S8e.isMDXComponent=!0;const O8e={toc:[]};function E8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}E8e.isMDXComponent=!0;const B8e={toc:[]};function G8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}G8e.isMDXComponent=!0;const U8e={toc:[]};function F8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}F8e.isMDXComponent=!0;const V8e={toc:[]};function q8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}q8e.isMDXComponent=!0;const j8e={toc:[]};function H8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}H8e.isMDXComponent=!0;const Q8e={toc:[]};function Y8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Y8e.isMDXComponent=!0;const $8e={toc:[]};function K8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}K8e.isMDXComponent=!0;const J8e={toc:[]};function t3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}t3e.isMDXComponent=!0;const e3e={toc:[]};function n3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}n3e.isMDXComponent=!0;const o3e={toc:[]};function p3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}p3e.isMDXComponent=!0;const r3e={toc:[]};function s3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}s3e.isMDXComponent=!0;const c3e={toc:[]};function i3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}i3e.isMDXComponent=!0;const a3e={toc:[]};function l3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}l3e.isMDXComponent=!0;const u3e={toc:[]};function m3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}m3e.isMDXComponent=!0;const d3e={toc:[]};function h3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}h3e.isMDXComponent=!0;const f3e={toc:[]};function k3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}k3e.isMDXComponent=!0;const y3e={toc:[]};function D3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}D3e.isMDXComponent=!0;const M3e={toc:[]};function w3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}w3e.isMDXComponent=!0;const _3e={toc:[]};function X3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}X3e.isMDXComponent=!0;const g3e={toc:[]};function T3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}T3e.isMDXComponent=!0;const C3e={toc:[]};function x3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}x3e.isMDXComponent=!0;const v3e={toc:[]};function L3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}L3e.isMDXComponent=!0;const Z3e={toc:[]};function b3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}b3e.isMDXComponent=!0;const N3e={toc:[]};function z3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}z3e.isMDXComponent=!0;const A3e={toc:[]};function W3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}W3e.isMDXComponent=!0;const I3e={toc:[]};function R3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}R3e.isMDXComponent=!0;const P3e={toc:[]};function S3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}S3e.isMDXComponent=!0;const O3e={toc:[]};function E3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}E3e.isMDXComponent=!0;const B3e={toc:[]};function G3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}G3e.isMDXComponent=!0;const U3e={toc:[]};function F3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}F3e.isMDXComponent=!0;const V3e={toc:[]};function q3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}q3e.isMDXComponent=!0;const j3e={toc:[]};function H3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}H3e.isMDXComponent=!0;const Q3e={toc:[]};function Y3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Y3e.isMDXComponent=!0;const $3e={toc:[]};function K3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}K3e.isMDXComponent=!0;const J3e={toc:[]};function t2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}t2e.isMDXComponent=!0;const e2e={toc:[]};function n2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}n2e.isMDXComponent=!0;const o2e={toc:[]};function p2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting time for this video in seconds."))}p2e.isMDXComponent=!0;const r2e={toc:[]};function s2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}s2e.isMDXComponent=!0;const c2e={toc:[]};function i2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}i2e.isMDXComponent=!0;const a2e={toc:[]};function l2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}l2e.isMDXComponent=!0;const u2e={toc:[]};function m2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}m2e.isMDXComponent=!0;const d2e={toc:[]};function h2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}h2e.isMDXComponent=!0;const f2e={toc:[]};function k2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}k2e.isMDXComponent=!0;const y2e={toc:[]};function D2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}D2e.isMDXComponent=!0;const M2e={toc:[]};function w2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}w2e.isMDXComponent=!0;const _2e={toc:[]};function X2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}X2e.isMDXComponent=!0;const g2e={toc:[]};function T2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}T2e.isMDXComponent=!0;const C2e={toc:[]};function x2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}x2e.isMDXComponent=!0;const v2e={toc:[]};function L2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}L2e.isMDXComponent=!0;const Z2e={toc:[]};function b2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}b2e.isMDXComponent=!0;const N2e={toc:[]};function z2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}z2e.isMDXComponent=!0;const A2e={toc:[]};function W2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}W2e.isMDXComponent=!0;const I2e={toc:[]};function R2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}R2e.isMDXComponent=!0;const P2e={toc:[]};function S2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}S2e.isMDXComponent=!0;const O2e={toc:[]};function E2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}E2e.isMDXComponent=!0;const B2e={toc:[]};function G2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}G2e.isMDXComponent=!0;const U2e={toc:[]};function F2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}F2e.isMDXComponent=!0;const V2e={toc:[]};function q2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}q2e.isMDXComponent=!0;const j2e={toc:[]};function H2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}H2e.isMDXComponent=!0;const Q2e={toc:[]};function Y2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Y2e.isMDXComponent=!0;const $2e={toc:[]};function K2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}K2e.isMDXComponent=!0;const J2e={toc:[]};function t1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}t1e.isMDXComponent=!0;const e1e={toc:[]};function n1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}n1e.isMDXComponent=!0;const o1e={toc:[]};function p1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}p1e.isMDXComponent=!0;const r1e={toc:[]};function s1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}s1e.isMDXComponent=!0;const c1e={toc:[]};function i1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}i1e.isMDXComponent=!0;const a1e={toc:[]};function l1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}l1e.isMDXComponent=!0;const u1e={toc:[]};function m1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}m1e.isMDXComponent=!0;const d1e={toc:[]};function h1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}h1e.isMDXComponent=!0;const f1e={toc:[]};function k1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}k1e.isMDXComponent=!0;const y1e={toc:[]};function D1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}D1e.isMDXComponent=!0;const M1e={toc:[]};function w1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}w1e.isMDXComponent=!0;const _1e={toc:[]};function X1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}X1e.isMDXComponent=!0;const g1e={toc:[]};function T1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}T1e.isMDXComponent=!0;const C1e={toc:[]};function x1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}x1e.isMDXComponent=!0;const v1e={toc:[]};function L1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}L1e.isMDXComponent=!0;const Z1e={toc:[]};function b1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}b1e.isMDXComponent=!0;const N1e={toc:[]};function z1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}z1e.isMDXComponent=!0;const A1e={toc:[]};function W1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}W1e.isMDXComponent=!0;const I1e={toc:[]};function R1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}R1e.isMDXComponent=!0;const P1e={toc:[]};function S1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}S1e.isMDXComponent=!0;const O1e={toc:[]};function E1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}E1e.isMDXComponent=!0;const B1e={toc:[]};function G1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}G1e.isMDXComponent=!0;const U1e={toc:[]};function F1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}F1e.isMDXComponent=!0;const V1e={toc:[]};function q1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}q1e.isMDXComponent=!0;const j1e={toc:[]};function H1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}H1e.isMDXComponent=!0;const Q1e={toc:[]};function Y1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.kt)("p",null,"Source code liberally taken from:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}Y1e.isMDXComponent=!0;const $1e={toc:[]};function K1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}K1e.isMDXComponent=!0;const J1e={toc:[]};function t4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}t4e.isMDXComponent=!0;const e4e={toc:[]};function n4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}n4e.isMDXComponent=!0;const o4e={toc:[]};function p4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}p4e.isMDXComponent=!0;const r4e={toc:[]};function s4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}s4e.isMDXComponent=!0;const c4e={toc:[]};function i4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}i4e.isMDXComponent=!0;const a4e={toc:[]};function l4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}l4e.isMDXComponent=!0;const u4e={toc:[]};function m4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}m4e.isMDXComponent=!0;const d4e={toc:[]};function h4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}h4e.isMDXComponent=!0;const f4e={toc:[]};function k4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}k4e.isMDXComponent=!0;const y4e={toc:[]};function D4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The degree of the polynomial"))}D4e.isMDXComponent=!0;const M4e={toc:[]};function w4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the nth derivative of the polynomial."))}w4e.isMDXComponent=!0;const _4e={toc:[]};function X4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of times to differentiate the polynomial."))}X4e.isMDXComponent=!0;const g4e={toc:[]};function T4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given value t."))}T4e.isMDXComponent=!0;const C4e={toc:[]};function x4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}x4e.isMDXComponent=!0;const v4e={toc:[]};function L4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}L4e.isMDXComponent=!0;const Z4e={toc:[]};function b4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}b4e.isMDXComponent=!0;const N4e={toc:[]};function z4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The derivative of the polynomial to sample from"))}z4e.isMDXComponent=!0;const A4e={toc:[]};function W4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial."))}W4e.isMDXComponent=!0;const I4e={toc:[]};function R4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}R4e.isMDXComponent=!0;const P4e={toc:[]};function S4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the output value range within the unit interval."))}S4e.isMDXComponent=!0;const O4e={toc:[]};function E4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}E4e.isMDXComponent=!0;const B4e={toc:[]};function G4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}G4e.isMDXComponent=!0;const U4e={toc:[]};function F4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}F4e.isMDXComponent=!0;const V4e={toc:[]};function q4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The point at which to split the polynomial."))}q4e.isMDXComponent=!0;const j4e={toc:[]};function H4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a constant polynomial"))}H4e.isMDXComponent=!0;const Q4e={toc:[]};function Y4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}Y4e.isMDXComponent=!0;const $4e={toc:[]};function K4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a cubic polynomial"))}K4e.isMDXComponent=!0;const J4e={toc:[]};function t6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}t6e.isMDXComponent=!0;const e6e={toc:[]};function n6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}n6e.isMDXComponent=!0;const o6e={toc:[]};function p6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}p6e.isMDXComponent=!0;const r6e={toc:[]};function s6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}s6e.isMDXComponent=!0;const c6e={toc:[]};function i6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a linear polynomial"))}i6e.isMDXComponent=!0;const a6e={toc:[]};function l6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}l6e.isMDXComponent=!0;const u6e={toc:[]};function m6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}m6e.isMDXComponent=!0;const d6e={toc:[]};function h6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a quadratic polynomial"))}h6e.isMDXComponent=!0;const f6e={toc:[]};function k6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}k6e.isMDXComponent=!0;const y6e={toc:[]};function D6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}D6e.isMDXComponent=!0;const M6e={toc:[]};function w6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}w6e.isMDXComponent=!0;const _6e={toc:[]};function X6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}X6e.isMDXComponent=!0;const g6e={toc:[]};function T6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}T6e.isMDXComponent=!0;const C6e={toc:[]};function x6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}x6e.isMDXComponent=!0;const v6e={toc:[]};function L6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}L6e.isMDXComponent=!0;const Z6e={toc:[]};function b6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}b6e.isMDXComponent=!0;const N6e={toc:[]};function z6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}z6e.isMDXComponent=!0;const A6e={toc:[]};function W6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}W6e.isMDXComponent=!0;const I6e={toc:[]};function R6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I6e,n,{components:e,mdxType:"MDXLayout"}))}R6e.isMDXComponent=!0;const P6e={toc:[]};function S6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}S6e.isMDXComponent=!0;const O6e={toc:[]};function E6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The knots defining the spline"))}E6e.isMDXComponent=!0;const B6e={toc:[]};function G6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the spline should be closed or not"))}G6e.isMDXComponent=!0;const U6e={toc:[]};function F6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}F6e.isMDXComponent=!0;const V6e={toc:[]};function q6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}q6e.isMDXComponent=!0;const j6e={toc:[]};function H6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}H6e.isMDXComponent=!0;const Q6e={toc:[]};function Y6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}Y6e.isMDXComponent=!0;const $6e={toc:[]};function K6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}K6e.isMDXComponent=!0;const J6e={toc:[]};function t7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}t7e.isMDXComponent=!0;const e7e={toc:[]};function n7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}n7e.isMDXComponent=!0;const o7e={toc:[]};function p7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}p7e.isMDXComponent=!0;const r7e={toc:[]};function s7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}s7e.isMDXComponent=!0;const c7e={toc:[]};function i7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}i7e.isMDXComponent=!0;const a7e={toc:[]};function l7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}l7e.isMDXComponent=!0;const u7e={toc:[]};function m7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.kt)("p",null,"By default, any property is cloneable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}m7e.isMDXComponent=!0;const d7e={toc:[]};function h7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}h7e.isMDXComponent=!0;const f7e={toc:[]};function k7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a cloneable property decorator."))}k7e.isMDXComponent=!0;const y7e={toc:[]};function D7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be cloneable."))}D7e.isMDXComponent=!0;const M7e={toc:[]};function w7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}w7e.isMDXComponent=!0;const _7e={toc:[]};function X7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}X7e.isMDXComponent=!0;const g7e={toc:[]};function T7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a compound property decorator."))}T7e.isMDXComponent=!0;const C7e={toc:[]};function x7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}x7e.isMDXComponent=!0;const v7e={toc:[]};function L7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}L7e.isMDXComponent=!0;const Z7e={toc:[]};function b7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a computed method decorator."))}b7e.isMDXComponent=!0;const N7e={toc:[]};function z7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the initial value of a property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}z7e.isMDXComponent=!0;const A7e={toc:[]};function W7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}W7e.isMDXComponent=!0;const I7e={toc:[]};function R7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an initial signal value decorator."))}R7e.isMDXComponent=!0;const P7e={toc:[]};function S7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the property."))}S7e.isMDXComponent=!0;const O7e={toc:[]};function E7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.kt)("p",null,"By default, any property is inspectable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}E7e.isMDXComponent=!0;const B7e={toc:[]};function G7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}G7e.isMDXComponent=!0;const U7e={toc:[]};function F7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an inspectable property decorator."))}F7e.isMDXComponent=!0;const V7e={toc:[]};function q7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be inspectable."))}q7e.isMDXComponent=!0;const j7e={toc:[]};function H7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}H7e.isMDXComponent=!0;const Q7e={toc:[]};function Y7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}Y7e.isMDXComponent=!0;const $7e={toc:[]};function K7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal interpolation function decorator."))}K7e.isMDXComponent=!0;const J7e={toc:[]};function t9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function for the property."))}t9e.isMDXComponent=!0;const e9e={toc:[]};function n9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.kt)("p",null,"If the wrapper class has a method called ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}n9e.isMDXComponent=!0;const o9e={toc:[]};function p9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}p9e.isMDXComponent=!0;const r9e={toc:[]};function s9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal parser decorator."))}s9e.isMDXComponent=!0;const c9e={toc:[]};function i9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}i9e.isMDXComponent=!0;const a9e={toc:[]};function l9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given property into a signal."),(0,s.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}l9e.isMDXComponent=!0;const u9e={toc:[]};function m9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}m9e.isMDXComponent=!0;const d9e={toc:[]};function h9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal decorator."))}h9e.isMDXComponent=!0;const f9e={toc:[]};function k9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}k9e.isMDXComponent=!0;const y9e={toc:[]};function D9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}D9e.isMDXComponent=!0;const M9e={toc:[]};function w9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal wrapper decorator."))}w9e.isMDXComponent=!0;const _9e={toc:[]};function X9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}X9e.isMDXComponent=!0;const g9e={toc:[]};function T9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unified abstraction for all CSS filters."))}T9e.isMDXComponent=!0;const C9e={toc:[]};function x9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the desired length is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}x9e.isMDXComponent=!0;const v9e={toc:[]};function L9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}L9e.isMDXComponent=!0;const Z9e={toc:[]};function b9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can be either:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'"))))}b9e.isMDXComponent=!0;const N9e={toc:[]};function z9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length used by most layout properties."))}z9e.isMDXComponent=!0;const A9e={toc:[]};function W9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,s.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}W9e.isMDXComponent=!0;const I9e={toc:[]};function R9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}R9e.isMDXComponent=!0;const P9e={toc:[]};function S9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in pixels."))}S9e.isMDXComponent=!0;const O9e={toc:[]};function E9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}E9e.isMDXComponent=!0;const B9e={toc:[]};function G9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}G9e.isMDXComponent=!0;const U9e={toc:[]};function F9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}F9e.isMDXComponent=!0;const V9e={toc:[]};function q9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}q9e.isMDXComponent=!0;const j9e={toc:[]};function H9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}H9e.isMDXComponent=!0;const Q9e={toc:[]};function Y9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}Y9e.isMDXComponent=!0;const $9e={toc:[]};function K9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}K9e.isMDXComponent=!0;const J9e={toc:[]};function ttn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in degrees."))}ttn.isMDXComponent=!0;const etn={toc:[]};function ntn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},etn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}ntn.isMDXComponent=!0;const otn={toc:[]};function ptn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},otn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}ptn.isMDXComponent=!0;const rtn={toc:[]};function stn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}stn.isMDXComponent=!0;const ctn={toc:[]};function itn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ctn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}itn.isMDXComponent=!0;const atn={toc:[]};function ltn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},atn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}ltn.isMDXComponent=!0;const utn={toc:[]};function mtn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},utn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}mtn.isMDXComponent=!0;const dtn={toc:[]};function htn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}htn.isMDXComponent=!0;const ftn={toc:[]};function ktn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ftn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}ktn.isMDXComponent=!0;const ytn={toc:[]};function Dtn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ytn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}Dtn.isMDXComponent=!0;const Mtn={toc:[]};function wtn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}function _tn(t){let{id:e}=t;const n=o[e]??p.Fragment;return p.createElement(n,null)}wtn.isMDXComponent=!0},9322:(t,e,n)=>{n.d(e,{Z:()=>m});var o=n(2784),p=n(8146),r=n(8698);const s="toggle_S_IX",c="collapsed_wdUB",i="collapse_TjTN",a="inverse_g6vW",l="clearFix_HQ1T";var u=n(6277);function m(t){let{comment:e,full:n=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@remarks"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==e?void 0:e.summaryId}),o.createElement(p.Z,{id:null==r?void 0:r.contentId}),n&&o.createElement(d,{comment:e}))}function d(t){let{comment:e}=t;const[n,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@preview"===e}))}),[e]),h=(0,o.useMemo)((()=>{var t;return(null==e||null==(t=e.blockTags)?void 0:t.filter((t=>{let{tag:e}=t;return"@example"===e})))??[]}),[e]),f=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@defaultValue"===e}))}),[e]),k=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@deprecated"===e}))}),[e]),y=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@see"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==d?void 0:d.contentId}),h.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(s,n&&c),onClick:t=>{t.preventDefault(),m(!n)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:n},o.createElement("div",{className:i},h.map((t=>o.createElement(p.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,a)})),f&&o.createElement(o.Fragment,null,"Default Value:"," ",o.createElement("code",null,f.content.map((t=>t.text)).join(""))),k&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(p.Z,{id:k.contentId})),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(p.Z,{id:y.contentId})))}},1930:(t,e,n)=>{n.d(e,{Z:()=>Gt});var o=n(2784),p=n(7390),r=n(6835),s=n(68),c=n(6277),i=n(8569);const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=n(7896);function u(t){let{width:e=24,height:n=24,...p}=t;return o.createElement("svg",(0,l.Z)({width:e,height:n,"aria-hidden":"true",viewBox:"0 0 24 24"},p),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:e,highlight:n,onClick:p,link:l}=t;const m=(0,r.F)(),d=(0,s.s2)();return o.createElement("div",{className:(0,c.Z)(i.Z.codeBlockContent,a.codeBlock,n&&a.highlight,p&&a.pointer)},o.createElement("pre",{onClick:p,onKeyDown:t=>{"Enter"===t.key&&(null==p||p())},tabIndex:0,ref:m.codeBlockRef,className:(0,c.Z)(i.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:i.Z.codeBlockLines,style:d},e)),l&&o.createElement("div",{className:i.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=n(9318);function h(t){let{children:e}=t;return o.createElement(d.Z,{as:"div",className:(0,c.Z)(a.codeBlockContainer,"language-typescript")},e)}var f=n(9817);function k(t){let{children:e,type:n,to:p,id:r,tooltip:c}=t;const i=(0,s.Ld)(n);return p?o.createElement(f.Z,(0,l.Z)({id:r,to:p,"data-tooltip":c},i),e):o.createElement("span",(0,l.Z)({id:r},i),e)}let y,D;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(y||(y={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(D||(D={}));const M={[y.None]:a.none,[y.Angle]:a.angle,[y.Curly]:a.curly,[y.Square]:a.square,[y.Parentheses]:a.parentheses};function w(t){let{children:e,type:n,separator:p=D.Comma}=t;return o.createElement("span",{className:(0,c.Z)(a.list,M[n??y.None])},o.createElement("span",{className:(0,c.Z)(a.elements,p!==D.Comma&&a.left)},(Array.isArray(e)?e:[e]).flatMap(((t,e)=>o.createElement("span",{"data-separator":p,key:e,className:a.element},t)))))}var _=n(8617);function X(t){var e;let{type:n}=t;const p=(0,_.RU)(n.project),r=null==p?void 0:p[n.id],s=n.externalUrl??(0,_.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(k,{to:s,type:s?"class-name":"constant",tooltip:!0},n.name),!(null==(e=n.typeArguments)||!e.length)&&o.createElement(w,{type:y.Angle},n.typeArguments.map(((t,e)=>o.createElement(O,{key:e,type:t})))))}function g(t){let{type:e}=t;return o.createElement(k,{type:"keyword"},e.name)}function T(t){let{type:e}=t;return e.elements?o.createElement(w,{type:y.Square},e.elements.map(((t,e)=>o.createElement(O,{key:e,type:t})))):o.createElement(o.Fragment,null,"[]")}function C(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(O,{type:e.elementType}),"[]")}function x(t){let{type:e}=t;return o.createElement(w,{type:y.Parentheses,separator:D.Pipe},e.types.map(((t,e)=>o.createElement(O,{key:e,type:t}))))}function v(t){let{type:e}=t;const[n,p]=(0,o.useMemo)((()=>{if(null===e.value)return["null","keyword"];switch(typeof e.value){case"object":return[(e.value.negative?"-":"")+e.value.value,"number"];case"boolean":return[e.value,"keyword"];case"number":return[e.value,"number"];case"string":return[`'${e.value}'`,"string"];default:return[e.value,"constant"]}}),[e.value]);return o.createElement(k,{type:p},n)}function L(t){let{type:e}=t;return e.asserts?o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"asserts "),o.createElement(k,null,e.name," ")):o.createElement(o.Fragment,null,o.createElement(k,null,e.name," "),o.createElement(k,{type:"keyword"},"is "),o.createElement(O,{type:e.targetType}))}function Z(t){let{type:e}=t;const n=(0,_.in)();return o.createElement(Y,{reflection:n(e.declaration)})}function b(t){let{type:e}=t;return o.createElement(w,{type:y.Parentheses,separator:D.Ampersand},e.types.map(((t,e)=>o.createElement(O,{key:e,type:t}))))}function N(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"string"},"`",e.head),e.tail.map(((t,e)=>{let[n,p]=t;return o.createElement(o.Fragment,null,"${",o.createElement(O,{key:e,type:n}),"}",o.createElement(k,{type:"string"},p))})),o.createElement(k,{type:"string"},"`"))}function z(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"typeof "),o.createElement(O,{type:e.queryType}))}function A(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(O,{type:e.checkType}),o.createElement(k,{type:"keyword"}," extends "),o.createElement(O,{type:e.extendsType})," ? ",o.createElement(O,{type:e.trueType})," : ",o.createElement(O,{type:e.falseType}))}function W(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"infer "),o.createElement(k,{type:"constant"},e.name))}function I(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(O,{type:e.objectType}),"[",o.createElement(O,{type:e.indexType}),"]")}function R(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},e.operator," "),o.createElement(O,{type:e.target}))}function P(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(w,{type:y.Curly},o.createElement(o.Fragment,null,"[",o.createElement(k,{type:"class"},e.parameter),o.createElement(k,{type:"keyword"}," in "),o.createElement(O,{type:e.parameterType}),"]: ",o.createElement(O,{type:e.templateType}))))}function S(t){let{type:e}=t;return o.createElement(o.Fragment,null,e.name,": ",o.createElement(O,{type:e.element}))}function O(t){const e=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return R;case"conditional":return A;case"reflection":return Z;case"query":return z;case"named-tuple-member":return S;case"union":return x;case"intrinsic":return g;case"literal":return v;case"reference":return X;case"predicate":return L;case"tuple":return T;case"array":return C;case"intersection":return b;case"inferred":return W;case"mapped":return P;case"template-literal":return N;case"indexedAccess":return I}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(e,t)}function E(t){let{flags:e,explicitAccessModifier:n}=t;const p=[];return null!=e&&e.isAbstract&&p.push("abstract"),null!=e&&e.isStatic&&p.push("static"),null!=e&&e.isConst&&p.push("const"),null!=e&&e.isReadonly&&p.push("readonly"),null!=e&&e.isPrivate&&p.push("private"),null!=e&&e.isProtected&&p.push("protected"),(null==e||!e.isPublic)&&(!n||null!=e&&e.isProtected||null!=e&&e.isPrivate)||p.push("public"),o.createElement(o.Fragment,null,p.map((t=>o.createElement(k,{key:t,type:"keyword"},t," "))))}function B(t){let{reflection:e}=t;const n="__namedParameters"===e.name?"{...}":e.name;return o.createElement(o.Fragment,null,o.createElement(E,{flags:e.flags}),e.flags.isRest&&"...",o.createElement(k,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"plain"},n),e.flags.isOptional&&"?",": ",e.type&&o.createElement(O,{type:e.type}),e.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(k,{type:"plain"},e.defaultValue)))}function G(t){let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{flags:e.flags}),e.varianceModifier&&o.createElement(k,{type:"keyword"},e.varianceModifier," "),o.createElement(k,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"class-name"},e.name),e.type&&o.createElement(o.Fragment,null," extends ",o.createElement(O,{type:e.type})),e.default&&o.createElement(o.Fragment,null," = ",o.createElement(O,{type:e.default})))}function U(t){var e,n;let{reflection:r,flags:s}=t;const c=(0,_.in)(),i="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(E,{flags:s??r.flags,explicitAccessModifier:!i}),r.kind===p.W.GetSignature&&o.createElement(k,{type:"keyword"},"get "),r.kind===p.W.SetSignature&&o.createElement(k,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(k,{to:r.overwrites.externalUrl??(0,_.Gr)(c(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===p.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(k,{to:"#",type:"keyword"},"new")," ",o.createElement(k,{type:"plain"},r.type.name)):i?"":o.createElement(k,{type:"function"},r.name),!(null==(e=r.typeParameter)||!e.length)&&o.createElement(w,{type:y.Angle},r.typeParameter.map((t=>o.createElement(G,{key:t.id,reflection:c(t)})))),null!=(n=r.parameters)&&n.length?o.createElement(w,{type:y.Parentheses},r.parameters.map((t=>o.createElement(B,{key:t,reflection:c(t)})))):"()",r.type&&o.createElement(o.Fragment,null,i?" => ":": ",o.createElement(O,{type:r.type})))}function F(t){let{reflection:e}=t;return o.createElement(B,{reflection:e})}const V={[p.W.Namespace]:"namespace",[p.W.Enum]:"enum",[p.W.Class]:"class",[p.W.Interface]:"interface"};function q(t){var e,n,p;let{reflection:r}=t;const s=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(E,{flags:r.flags}),o.createElement(k,{type:"keyword"},V[r.kind]," "),o.createElement(k,{type:"class-name"},r.name),!(null==(e=r.typeParameters)||!e.length)&&o.createElement(w,{type:y.Angle},r.typeParameters.map((t=>o.createElement(G,{key:t.id,reflection:s(t)}))))," ",!(null==(n=r.extendedTypes)||!n.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"extends "),o.createElement(w,null,r.extendedTypes.map(((t,e)=>o.createElement(O,{key:e,type:t}))))),!(null==(p=r.implementedTypes)||!p.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"implements "),o.createElement(w,null,r.implementedTypes.map(((t,e)=>o.createElement(O,{key:e,type:t}))))))}function j(t){let{reflection:e}=t;const n=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(E,{flags:e.flags}),o.createElement(k,{type:"keyword"},"type "),o.createElement(k,{type:"class-name"},e.name),e.typeParameters&&o.createElement(w,{type:y.Angle},e.typeParameters.map((t=>o.createElement(G,{key:t.id,reflection:n(t)}))))," = ",o.createElement(O,{type:e.type}))}function H(t){let{reflection:e}=t;const n=(0,_.in)();return e.signatures?o.createElement(U,{reflection:e.signatures[0]}):e.children?o.createElement(w,{type:y.Curly},e.children.map((t=>o.createElement(Y,{key:t.id,reflection:n(t)})))):o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"unknown"))}function Q(t){var e;let{reflection:n}=t;const p=(null==(e=n.signatures)?void 0:e[0])??n.getSignature??n.setSignature??n.indexSignature;return o.createElement(U,{reflection:p})}function Y(t){let{reflection:e}=t;const n=(0,o.useMemo)((()=>{switch(e.kind){case p.W.Project:case p.W.Module:case p.W.EnumMember:case p.W.Variable:case p.W.Function:break;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return q;case p.W.Constructor:return U;case p.W.Property:return F;case p.W.Method:return Q;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:break;case p.W.TypeLiteral:return H;case p.W.TypeParameter:return G;case p.W.Accessor:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return j;case p.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.id]);return o.createElement(n,{reflection:e})}function $(t){let{children:e}=t;const n=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!n.current)return;const t=n.current.closest("pre");if(t.scrollWidth>t.clientWidth){const e=Array.from(n.current.querySelectorAll(`.${a.elements}`)).sort(((t,e)=>function(t,e){return t>e?1:t<e?-1:0}(e.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&e.length>0;)e.shift().classList.add(a.wrap)}})),o.createElement(o.Fragment,null,e&&o.createElement("span",{ref:n,className:(0,c.Z)(a.line,"token-line")},e),o.createElement("br",null))}var K=n(9322),J=n(8146);function tt(t){let{parameters:e}=t;const n=(0,_.in)(),p=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,p.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(G,{reflection:t})),o.createElement(J.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{parameters:e}=t;const n=(0,_.in)(),p=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,p.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(B,{reflection:t})),o.createElement(J.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{signatures:e,flags:n,source:p}=t;const r=(0,_.in)(),s=(0,o.useMemo)((()=>e.map(r)),[e]),[c,i]=(0,o.useState)(s[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,s.map((t=>o.createElement(m,{link:null==p?void 0:p.url,key:t.id,highlight:e.length>1&&t.id===c.id,onClick:e.length>1?()=>i(t):void 0},o.createElement($,null,o.createElement(U,{reflection:t,flags:n})))))),o.createElement(K.Z,{comment:c.comment}),o.createElement(tt,{parameters:c.typeParameter}),o.createElement(et,{parameters:c.parameters}))}var ot=n(7708);function pt(t){let{width:e=24,height:n=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},p),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",st="filters_z1iC",ct="icon_ROIU";function it(){const t=(0,o.useRef)(null),[e,n]=(0,o.useState)(!1),[p,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const e=e=>{t.current&&!t.current.contains(e.target)&&n(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,c.Z)("dropdown dropdown--right margin-bottom--md",e&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),n(!e)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),n(!e))}},"Filters",o.createElement(pt,{className:ct})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,c.Z)("dropdown__link",p.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:p.private,onChange:t=>{r({...p,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&n(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,c.Z)("dropdown__link",p.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:p.inherited,onChange:t=>{r({...p,inherited:t.target.checked})}}),"Inherited members")))))}function at(t){let{children:e,kind:n}=t;return n===p.W.Class||n===p.W.Interface?o.createElement("div",{className:(0,c.Z)("row",rt)},o.createElement("div",{className:(0,c.Z)("col",st)},o.createElement(it,null)),o.createElement("div",{className:"col"},e)):o.createElement(o.Fragment,null,e)}var lt=n(3181),ut=n(3851),mt=n(4126),dt=n(2424),ht=n(2244),ft=n(4155);function kt(t){return function(t){var e;return(null==(e=o.Children.map(t,(t=>{if(!t||(0,o.isValidElement)(t)&&function(t){const{props:e}=t;return!!e&&"object"==typeof e&&"value"in e}(t))return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:e.filter(Boolean))??[]}(t).map((t=>{let{props:{value:e,label:n,attributes:o,default:p}}=t;return{value:e,label:n,attributes:o,default:p}}))}function yt(t){const{values:e,children:n}=t;return(0,o.useMemo)((()=>{const t=e??kt(n);return function(t){const e=(0,ht.l)(t,((t,e)=>t.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[e,n])}function Dt(t){let{value:e,tabValues:n}=t;return n.some((t=>t.value===e))}function Mt(t){let{queryString:e=!1,groupId:n}=t;const p=(0,lt.k6)(),r=function(t){let{queryString:e=!1,groupId:n}=t;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,dt._X)(r),(0,o.useCallback)((t=>{if(!r)return;const e=new URLSearchParams(p.location.search);e.set(r,t),p.replace({...p.location,search:e.toString()})}),[r,p])]}function wt(t){const{defaultValue:e,queryString:n=!1,groupId:p}=t,r=yt(t),[s,c]=(0,o.useState)((()=>function(t){let{defaultValue:e,tabValues:n}=t;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!Dt({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const o=n.find((t=>t.default))??n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:e,tabValues:r}))),[i,a]=Mt({queryString:n,groupId:p}),[l,u]=function(t){let{groupId:e}=t;const n=function(t){return t?`docusaurus.tab.${t}`:null}(e),[p,r]=(0,ft.Nk)(n);return[p,(0,o.useCallback)((t=>{n&&r.set(t)}),[n,r])]}({groupId:p}),m=(()=>{const t=i??l;return Dt({value:t,tabValues:r})?t:null})();(0,o.useLayoutEffect)((()=>{m&&c(m)}),[m]);return{selectedValue:s,selectValue:(0,o.useCallback)((t=>{if(!Dt({value:t,tabValues:r}))throw new Error(`Can't select invalid tab value=${t}`);c(t),a(t),u(t)}),[a,u,r]),tabValues:r}}var _t=n(9741);const Xt="tabList_M0Dn",gt="tabItem_ysIP";function Tt(t){let{className:e,block:n,selectedValue:p,selectValue:r,tabValues:s}=t;const i=[],{blockElementScrollPositionUntilNextRender:a}=(0,mt.o5)(),u=t=>{const e=t.currentTarget,n=i.indexOf(e),o=s[n].value;o!==p&&(a(e),r(o))},m=t=>{var e;let n=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const e=i.indexOf(t.currentTarget)+1;n=i[e]??i[0];break}case"ArrowLeft":{const e=i.indexOf(t.currentTarget)-1;n=i[e]??i[i.length-1];break}}null==(e=n)||e.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":n},e)},s.map((t=>{let{value:e,label:n,attributes:r}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:p===e?0:-1,"aria-selected":p===e,key:e,ref:t=>i.push(t),onKeyDown:m,onClick:u},r,{className:(0,c.Z)("tabs__item",gt,null==r?void 0:r.className,{"tabs__item--active":p===e})}),n??e)})))}function Ct(t){let{lazy:e,children:n,selectedValue:p}=t;const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const t=r.find((t=>t.props.value===p));return t?(0,o.cloneElement)(t,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},r.map(((t,e)=>(0,o.cloneElement)(t,{key:e,hidden:t.props.value!==p}))))}function xt(t){const e=wt(t);return o.createElement("div",{className:(0,c.Z)("tabs-container",Xt)},o.createElement(Tt,(0,l.Z)({},t,e)),o.createElement(Ct,(0,l.Z)({},t,e)))}function vt(t){const e=(0,_t.Z)();return o.createElement(xt,(0,l.Z)({key:String(e)},t))}const Lt="tabItem_OMyP";function Zt(t){let{children:e,hidden:n,className:p}=t;return o.createElement("div",{role:"tabpanel",className:(0,c.Z)(Lt,p),hidden:n},e)}function bt(t){let{group:e}=t;return"Constructors"===e.title&&0===e.external.length&&1===e.nested.length?o.createElement(Gt,{reflection:e.nested[0]}):o.createElement(o.Fragment,null,e.external.length>0&&o.createElement("ul",null,e.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t})))))),e.nested.length>0&&e.nested.map(((t,e)=>o.createElement(o.Fragment,{key:t.id},e>0&&o.createElement("hr",null),o.createElement(Gt,{reflection:t})))))}function Nt(t){let{group:e,project:n}=t;const p=(0,lt.TH)(),r=(0,_.RU)(n),s=p.hash.split("-")[0].slice(1),[c]=(0,ot.mN)(),i=(0,o.useMemo)((()=>(e.categories??[e]).map((t=>function(t,e,n){const o=[],p=[],r=[];for(const s of t.children){const t=e[s];t&&(0,ot.It)(n,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,r,c))).filter((t=>!!t))),[e,r,c]);return(0,o.useEffect)((()=>{if(1===i.length)return;const t=p.hash.split("-")[0].slice(1);for(const e of i)if(e.anchors.includes(t))return}),[p.hash,i]),0===i.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h2",id:e.title},e.title),i.length>1?o.createElement(vt,{groupId:e.title},i.map((t=>o.createElement(Zt,{default:t.anchors.includes(s),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(bt,{group:t}))))):o.createElement(bt,{group:i[0]}))}function zt(t){var e,n,p,r,s;let{reflection:c}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(e=c.sources)||null==(n=e[0])?void 0:n.url},o.createElement($,null,o.createElement(Y,{reflection:c})))),o.createElement(at,{kind:c.kind},o.createElement(K.Z,{comment:c.comment})),o.createElement(tt,{parameters:c.typeParameters}),(null==(p=c.implementedBy)?void 0:p.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,c.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),(null==(r=c.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,c.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),c.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:c.signatures})),null==(s=c.groups)?void 0:s.map((t=>o.createElement(Nt,{group:t,key:t.title,project:c.project}))))}function At(t){var e;let{reflection:n,headless:p}=t;const r=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!p&&(n.hasOwnPage?o.createElement("h1",null,n.name):o.createElement(ut.Z,{as:"h3",id:n.anchor},o.createElement("code",null,n.name))),o.createElement(nt,{signatures:r,flags:n.flags,source:null==(e=n.sources)?void 0:e[0]}),n.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:n.inheritedFrom}))),n.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(X,{type:n.overwrites}))))}function Wt(t){var e,n;let{reflection:p,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(p.hasOwnPage?o.createElement("h1",null,p.name):o.createElement(ut.Z,{as:"h3",id:p.anchor},o.createElement("code",null,p.name))),o.createElement(h,null,o.createElement(m,{link:null==(e=p.sources)||null==(n=e[0])?void 0:n.url},o.createElement($,null,o.createElement(F,{reflection:p})))),o.createElement(K.Z,{comment:p.comment}),p.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:p.inheritedFrom}))))}function It(t){var e,n,p;let{reflection:r}=t;const s=(0,_.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(e=r.sources)||null==(n=e[0])?void 0:n.url},o.createElement($,null,o.createElement(Y,{reflection:r})))),o.createElement(K.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:r.signatures})),null==(p=r.groups)?void 0:p.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>s[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Gt,{key:t.id,reflection:t})))))))}var Rt=n(8128);function Pt(t){var e;let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(Rt.Z,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),o.createElement(at,{kind:n.kind},o.createElement(K.Z,{comment:n.comment})),null==(e=n.groups)?void 0:e.map((t=>o.createElement(Nt,{group:t,key:t.title,project:n.project}))))}const St="cardContainer_ybwo",Ot="cardTitle_Ehd1",Et="cardDescription_b6wr";function Bt(t){let{reflection:e}=t;const n=(0,_.RU)(e.project),p=e.groups[0].children.map((t=>n[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,c.Z)("row")},p.map((t=>{var e;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(f.Z,{href:t.href,className:(0,c.Z)("card padding--lg",St)},o.createElement("h2",{className:(0,c.Z)("text--truncate",Ot)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,c.Z)("text--truncate",Et)},(null==(e=t.comment)?void 0:e.summaryText)??"\xa0")))}))))}function Gt(t){let{reflection:e,headless:n=!1}=t;const r=(0,o.useMemo)((()=>{switch(e.kind){case p.W.Project:return Bt;case p.W.Module:return Pt;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return zt;case p.W.Function:case p.W.Accessor:case p.W.Constructor:case p.W.Method:return At;case p.W.Variable:case p.W.Property:case p.W.EnumMember:return Wt;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:case p.W.TypeLiteral:case p.W.TypeParameter:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return It;case p.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.kind]);return o.createElement(r,{reflection:e,headless:n})}},7390:(t,e,n)=>{let o;n.d(e,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},8617:(t,e,n)=>{n.d(e,{Gr:()=>a,RU:()=>s,gs:()=>r,in:()=>c,rG:()=>i});var o=n(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:e,lookup:n,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:n,urlLookup:r}},e)}function s(t){const{lookup:e}=(0,o.useContext)(p);return e[t]}function c(){const{lookup:t}=(0,o.useContext)(p);return e=>{if("number"==typeof(null==e?void 0:e.project))return t[e.project][e.id]}}function i(){const{urlLookup:t,lookup:e}=(0,o.useContext)(p);return n=>{var o;const p=t[n];return p?(null==(o=e[p.projectId])?void 0:o[p.id])??null:null}}function a(t){if(t)return t.href}},68:(t,e,n)=>{n.d(e,{Ld:()=>c,Y0:()=>s,s2:()=>i});var o=n(2784),p=n(822);const r=o.createContext(null);function s(t){let{children:e}=t;const n=(0,p.p)(),s=(0,o.useMemo)((()=>function(t,e){const{plain:n}=t,o=Object.create(null),p=t.styles.reduce(((t,n)=>{const{languages:o,style:p}=n;return o&&!o.includes(e)||n.types.forEach((e=>{t[e]={...t[e],...p}})),t}),o);return p.root=n,p.plain={...n,backgroundColor:null},p}(n,"typescript")),[n]);return o.createElement(r.Provider,{value:s},e)}function c(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return{className:`token ${t}`,style:e[t]??e.plain}}function i(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return e[t]??e.plain}},7708:(t,e,n)=>{n.d(e,{It:()=>m,Wy:()=>l,mN:()=>u});var o=n(2784),p=n(1263),r=n(9741);const s="api-filters",c=p.Z.canUseDOM?localStorage.getItem(s):null,i=c?JSON.parse(c):{inherited:!0,private:!1},a=o.createContext([i,()=>{}]);function l(t){let{children:e}=t;const[n,p]=(0,o.useState)(i),c=(0,r.Z)();return o.createElement(a.Provider,{value:[n,t=>{c&&localStorage.setItem(s,JSON.stringify(t)),p(t)}]},e)}function u(){return(0,o.useContext)(a)}function m(t,e){var n,o;const p=(null==(n=e.flags)?void 0:n.isPrivate)||(null==(o=e.flags)?void 0:o.isProtected);if(!t.private&&p)return!1;const r=!!e.inheritedFrom;return!(!t.inherited&&r)}},2253:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>a,contentTitle:()=>c,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var o=n(7896),p=(n(2784),n(876)),r=n(2072);const s={sidebar_position:2,slug:"/flow"},c="Animation flow",i={unversionedId:"getting-started/flow",id:"getting-started/flow",title:"Animation flow",description:"Motion Canvas uses generator functions to describe animations.",source:"@site/docs/getting-started/flow.mdx",sourceDirName:"getting-started",slug:"/flow",permalink:"/docs/flow",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/flow.mdx",tags:[],version:"current",lastUpdatedBy:"Akshat Giri",sidebarPosition:2,frontMatter:{sidebar_position:2,slug:"/flow"},sidebar:"docs",previous:{title:"Quickstart",permalink:"/docs/quickstart"},next:{title:"Scene hierarchy",permalink:"/docs/hierarchy"}},a={},l=[{value:"Flow Generators",id:"flow-generators",level:2},{value:"<code>all</code>",id:"all",level:3},{value:"<code>any</code>",id:"any",level:3},{value:"<code>chain</code>",id:"chain",level:3},{value:"<code>delay</code>",id:"delay",level:3},{value:"<code>sequence</code>",id:"sequence",level:3},{value:"<code>loop</code>",id:"loop",level:3},{value:"Looping",id:"looping",level:2},{value:"Using <code>Array.map</code> and <code>all</code>",id:"using-arraymap-and-all",level:3},{value:"Using a <code>for</code> loop and <code>all</code>",id:"using-a-for-loop-and-all",level:3},{value:"Using a <code>for</code> loop",id:"using-a-for-loop",level:3}],u={toc:l};function m(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,o.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"animation-flow"},"Animation flow"),(0,p.kt)("p",null,"Motion Canvas uses generator functions to describe animations."),(0,p.kt)("p",null,"A generator function is a function that can return multiple values:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"function* example() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst generator = example();\n\nconsole.log(generator.next().value); // 1;\nconsole.log(generator.next().value); // 2;\nconsole.log(generator.next().value); // 3;\n")),(0,p.kt)("p",null,"When the ",(0,p.kt)("inlineCode",{parentName:"p"},"yield")," keyword is encountered, the execution of the function pauses,\nand resumes only when the caller requests another value. This is particularly\nuseful when declaring animations - usually we want to change the things on the\nscreen in incremental steps to create an illusion of movement. We also want to\nwait a constant amount of time between these updates so that our eyes can\nregister what's happening. With generators, we can update things in-between the\n",(0,p.kt)("inlineCode",{parentName:"p"},"yield")," keywords, and then wait for a bit whenever the function yields."),(0,p.kt)("p",null,"This is the fundamental idea of Motion Canvas. ",(0,p.kt)("inlineCode",{parentName:"p"},"yield"),' means: "The current frame\nis ready, display it on the screen and come back to me later."'),(0,p.kt)("p",null,"With that in mind, we can make a circle flicker on the screen using the\nfollowing code:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n  view.add(<Circle ref={circle} width={100} height={100} />);\n\n  circle().fill('red');\n  yield;\n  circle().fill('blue');\n  yield;\n  circle().fill('red');\n  yield;\n});\n")),(0,p.kt)("p",null,"Needless to say, it would be extremely cumbersome if we had to write all\nanimations like that. Fortunately, JavaScript has another keyword for use within\ngenerators - ",(0,p.kt)("inlineCode",{parentName:"p"},"yield*"),". It allows us to delegate the yielding to another\ngenerator."),(0,p.kt)("p",null,"For instance, we could extract the flickering code from the above example to a\nseparate generator and delegate our scene function to it:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"import {ThreadGenerator} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n  view.add(<Circle ref={circle} width={100} height={100} />);\n\n  yield* flicker(circle());\n});\n\nfunction* flicker(circle: Circle): ThreadGenerator {\n  circle.fill('red');\n  yield;\n  circle.fill('blue');\n  yield;\n  circle.fill('red');\n  yield;\n}\n")),(0,p.kt)("p",null,"The resulting animation is exactly the same, but now we have a reusable function\nthat we can use whenever we need some flickering."),(0,p.kt)("p",null,"Motion Canvas provides a lot of useful generators like this. You may remember\nthis snippet from ",(0,p.kt)("a",{parentName:"p",href:"/docs/quickstart"},"quickstart"),":"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield * myCircle().fill('#e6a700', 1);\n")),(0,p.kt)("p",null,"It animates the fill color of the circle from its current value to ",(0,p.kt)("inlineCode",{parentName:"p"},"#e6a700"),"\nover a span of one second. As you may guess, the result of calling\n",(0,p.kt)("inlineCode",{parentName:"p"},"fill('#e6a700', 1)")," is another generator to which we can redirect our scene\nfunction. Generators like this are called tweens, because they animate\nbe",(0,p.kt)("strong",{parentName:"p"},"tween")," two values. You can read more about them in the\n",(0,p.kt)("a",{parentName:"p",href:"/docs/tweening"},"tweening")," section."),(0,p.kt)("h2",{id:"flow-generators"},"Flow Generators"),(0,p.kt)("p",null,"Another kind of generators are ",(0,p.kt)("em",{parentName:"p"},"flow generators"),". They take one or more\ngenerators as their input and combine them together. We've mentioned the ",(0,p.kt)("inlineCode",{parentName:"p"},"all()"),"\ngenerator in the quickstart section, there's a few more:"),(0,p.kt)("h3",{id:"all"},(0,p.kt)("inlineCode",{parentName:"h3"},"all")),(0,p.kt)(r.Z,{url:"/api/core/flow#all",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"any"},(0,p.kt)("inlineCode",{parentName:"h3"},"any")),(0,p.kt)(r.Z,{url:"/api/core/flow#any",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"chain"},(0,p.kt)("inlineCode",{parentName:"h3"},"chain")),(0,p.kt)(r.Z,{url:"/api/core/flow#chain",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"delay"},(0,p.kt)("inlineCode",{parentName:"h3"},"delay")),(0,p.kt)(r.Z,{url:"/api/core/flow#delay",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"sequence"},(0,p.kt)("inlineCode",{parentName:"h3"},"sequence")),(0,p.kt)(r.Z,{url:"/api/core/flow#sequence",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"loop"},(0,p.kt)("inlineCode",{parentName:"h3"},"loop")),(0,p.kt)(r.Z,{url:"/api/core/flow#loop",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"looping"},"Looping"),(0,p.kt)("p",null,"There are many ways to animate multiple objects. Here are some examples. Try\nusing them in the below editor."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor ratio=2",editor:!0,ratio:"2"},"import {makeScene2D, Rect} from '@motion-canvas/2d';\nimport {all, waitFor, makeRef, range} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const rects: Rect[] = [];\n\n  // Create some rects\n  view.add(\n    range(5).map(i => (\n      <Rect\n        ref={makeRef(rects, i)}\n        width={100}\n        height={100}\n        x={-250 + 125 * i}\n        fill=\"#88C0D0\"\n        radius={10}\n      />\n    )),\n  );\n\n  yield* waitFor(1);\n\n  // Animate them\n  yield* all(\n    ...rects.map(rect => rect.position.y(100, 1).to(-100, 2).to(0, 1)),\n  );\n});\n")),(0,p.kt)("h3",{id:"using-arraymap-and-all"},"Using ",(0,p.kt)("inlineCode",{parentName:"h3"},"Array.map")," and ",(0,p.kt)("inlineCode",{parentName:"h3"},"all")),(0,p.kt)("p",null,"This is one of the most elegant ways to do simple tweens, but requires nesting\n",(0,p.kt)("inlineCode",{parentName:"p"},"all")," to do multiple tweens on an object since the ",(0,p.kt)("inlineCode",{parentName:"p"},"map")," callback must return a\n",(0,p.kt)("inlineCode",{parentName:"p"},"ThreadGenerator"),"."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"yield *\n  all(\n    ...rects.map(rect =>\n      // No yield or anything; we return this generator and deal with it outside\n      rect.position.y(100, 1).to(-100, 2).to(0, 1),\n    ),\n  );\n")),(0,p.kt)("h3",{id:"using-a-for-loop-and-all"},"Using a ",(0,p.kt)("inlineCode",{parentName:"h3"},"for")," loop and ",(0,p.kt)("inlineCode",{parentName:"h3"},"all")),(0,p.kt)("p",null,"This is similar to above, but uses a ",(0,p.kt)("inlineCode",{parentName:"p"},"for")," loop and an array of generators."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const generators = [];\nfor (const rect of rects) {\n  // No yield here, just store the generators.\n  generators.push(rect.position.y(100, 1).to(-100, 2).to(0, 1));\n}\n\n// Run all of the generators.\nyield * all(...generators);\n")),(0,p.kt)("h3",{id:"using-a-for-loop"},"Using a ",(0,p.kt)("inlineCode",{parentName:"h3"},"for")," loop"),(0,p.kt)("p",null,"This is a bit of a cumbersome option because you have to figure out how long it\nwould take for the generator in the loop to complete, but is useful in some\nsituations."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"for (const rect of rects) {\n  // Note the absence of a * after this yield\n  yield rect.position.y(100, 1).to(-100, 2).to(0, 1);\n}\n\n// Wait for the duration of the above generators\nyield * waitFor(4);\n")))}m.isMDXComponent=!0}}]);