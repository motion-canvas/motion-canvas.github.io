"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3805],{8046:(t,n,e)=>{e.d(n,{Z:()=>r});var o=e(7896),p=e(2784);function r(t){let{width:n=24,height:e=24,...r}=t;return p.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0,fill:"currentColor"},r),p.createElement("path",{d:"M19.8,18.4L14,10.67V6.5l1.35-1.69C15.61,4.48,15.38,4,14.96,4H9.04C8.62,4,8.39,4.48,8.65,4.81L10,6.5v4.17L4.2,18.4 C3.71,19.06,4.18,20,5,20h14C19.82,20,20.29,19.06,19.8,18.4z"}))}},2665:(t,n,e)=>{e.d(n,{Z:()=>u});var o=e(1263),p=e(6277),r=e(2784),s=e(9817),c=e(7896);function i(t){let{width:n=24,height:e=24,...o}=t;return r.createElement("svg",(0,c.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},o),r.createElement("path",{d:"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z",fill:"currentColor"}))}const a={container:"container_lQCo",small:"small_As57",banner:"banner_A4QS",player:"player_tELG",link:"link_BTzN",icon:"icon_wSGd"};function l(t){let{name:n}=t;const e=`https://github.com/motion-canvas/motion-canvas/blob/main/packages/examples/src/scenes/${n}.tsx`;return r.createElement(s.Z,{to:e,className:(0,p.Z)("padding--sm",a.link)},r.createElement("span",null,"View source code"),r.createElement(i,{className:a.icon}))}function u(t){let{name:n,banner:e,small:o,link:s}=t;return r.createElement("div",{className:(0,p.Z)(a.container,e&&a.banner,o&&a.small)},r.createElement("motion-canvas-player",{class:a.player,src:`/examples/${n}.js`,auto:e}),r.createElement(l,{name:s||n}))}o.Z.canUseDOM&&e.e(7067).then(e.bind(e,7067))},2072:(t,n,e)=>{e.d(n,{Z:()=>s});var o=e(2830),p=e(8617),r=e(2784);function s(t){let{url:n}=t;const e=(0,p.rG)()(n);return r.createElement(o.Z,{reflection:e,headless:!0})}},4237:(t,n,e)=>{e.d(n,{Z:()=>iGp});var o={};e.r(o),e.d(o,{content_0_0:()=>a,content_0_10:()=>C,content_0_100:()=>Kn,content_0_1000:()=>tv,content_0_1002:()=>ov,content_0_1004:()=>sv,content_0_1006:()=>av,content_0_1008:()=>mv,content_0_1010:()=>kv,content_0_1012:()=>Mv,content_0_1014:()=>_v,content_0_1016:()=>Cv,content_0_1018:()=>vv,content_0_102:()=>ne,content_0_1020:()=>bv,content_0_1022:()=>zv,content_0_1024:()=>Rv,content_0_1026:()=>Ev,content_0_1028:()=>Fv,content_0_1030:()=>Vv,content_0_1032:()=>Yv,content_0_1034:()=>$v,content_0_1036:()=>tL,content_0_1038:()=>oL,content_0_104:()=>pe,content_0_1040:()=>sL,content_0_1042:()=>aL,content_0_1044:()=>mL,content_0_1046:()=>kL,content_0_1048:()=>ML,content_0_1050:()=>_L,content_0_1052:()=>CL,content_0_1054:()=>vL,content_0_1056:()=>bL,content_0_1058:()=>zL,content_0_106:()=>ce,content_0_1060:()=>RL,content_0_1062:()=>EL,content_0_1064:()=>FL,content_0_1066:()=>VL,content_0_1068:()=>YL,content_0_1070:()=>$L,content_0_1072:()=>tZ,content_0_1074:()=>oZ,content_0_1076:()=>sZ,content_0_1078:()=>aZ,content_0_108:()=>le,content_0_1080:()=>mZ,content_0_1082:()=>kZ,content_0_1084:()=>MZ,content_0_1086:()=>_Z,content_0_1088:()=>CZ,content_0_1090:()=>vZ,content_0_1092:()=>bZ,content_0_1094:()=>zZ,content_0_1096:()=>RZ,content_0_1098:()=>EZ,content_0_110:()=>de,content_0_1100:()=>FZ,content_0_1102:()=>VZ,content_0_1104:()=>YZ,content_0_1106:()=>$Z,content_0_1108:()=>tb,content_0_1110:()=>ob,content_0_1112:()=>sb,content_0_1114:()=>ab,content_0_1116:()=>mb,content_0_1118:()=>kb,content_0_112:()=>fe,content_0_1120:()=>Mb,content_0_1122:()=>_b,content_0_1124:()=>Cb,content_0_1126:()=>vb,content_0_1128:()=>bb,content_0_1130:()=>zb,content_0_1132:()=>Rb,content_0_1134:()=>Eb,content_0_1136:()=>Fb,content_0_1138:()=>Vb,content_0_114:()=>De,content_0_1140:()=>Yb,content_0_1142:()=>$b,content_0_1144:()=>tN,content_0_1146:()=>oN,content_0_1148:()=>sN,content_0_1150:()=>aN,content_0_1152:()=>mN,content_0_1154:()=>kN,content_0_1156:()=>MN,content_0_1158:()=>_N,content_0_116:()=>we,content_0_1160:()=>CN,content_0_1162:()=>vN,content_0_1164:()=>bN,content_0_1166:()=>zN,content_0_1168:()=>RN,content_0_1170:()=>EN,content_0_1172:()=>FN,content_0_1174:()=>VN,content_0_1176:()=>YN,content_0_1178:()=>$N,content_0_118:()=>ge,content_0_1180:()=>tA,content_0_1182:()=>oA,content_0_1184:()=>sA,content_0_1186:()=>aA,content_0_1188:()=>mA,content_0_1190:()=>kA,content_0_1192:()=>MA,content_0_1194:()=>_A,content_0_1196:()=>CA,content_0_1198:()=>vA,content_0_12:()=>v,content_0_120:()=>Le,content_0_1200:()=>bA,content_0_1202:()=>zA,content_0_1204:()=>RA,content_0_1206:()=>EA,content_0_1208:()=>FA,content_0_1210:()=>VA,content_0_1212:()=>YA,content_0_1214:()=>$A,content_0_1216:()=>tz,content_0_1218:()=>oz,content_0_122:()=>Ne,content_0_1220:()=>sz,content_0_1222:()=>az,content_0_1224:()=>mz,content_0_1226:()=>kz,content_0_1228:()=>Mz,content_0_1230:()=>_z,content_0_1232:()=>Cz,content_0_1234:()=>vz,content_0_1236:()=>bz,content_0_1238:()=>zz,content_0_124:()=>We,content_0_1240:()=>Rz,content_0_1242:()=>Ez,content_0_1244:()=>Fz,content_0_1246:()=>Vz,content_0_1248:()=>Yz,content_0_1250:()=>$z,content_0_1252:()=>tW,content_0_1254:()=>oW,content_0_1256:()=>sW,content_0_1258:()=>aW,content_0_126:()=>Pe,content_0_1260:()=>mW,content_0_1262:()=>kW,content_0_1264:()=>MW,content_0_1266:()=>_W,content_0_1268:()=>CW,content_0_1270:()=>vW,content_0_1272:()=>bW,content_0_1274:()=>zW,content_0_1276:()=>RW,content_0_1278:()=>EW,content_0_128:()=>Ge,content_0_1280:()=>FW,content_0_1282:()=>VW,content_0_1284:()=>YW,content_0_1286:()=>$W,content_0_1288:()=>tI,content_0_1290:()=>oI,content_0_1292:()=>sI,content_0_1294:()=>aI,content_0_1296:()=>mI,content_0_1298:()=>kI,content_0_130:()=>Be,content_0_1300:()=>MI,content_0_1302:()=>_I,content_0_1304:()=>CI,content_0_1306:()=>vI,content_0_1308:()=>bI,content_0_1310:()=>zI,content_0_1312:()=>RI,content_0_1314:()=>EI,content_0_1316:()=>FI,content_0_1318:()=>VI,content_0_132:()=>qe,content_0_1320:()=>YI,content_0_1322:()=>$I,content_0_1324:()=>tR,content_0_1326:()=>oR,content_0_1328:()=>sR,content_0_1330:()=>aR,content_0_1332:()=>mR,content_0_1334:()=>kR,content_0_1336:()=>MR,content_0_1338:()=>_R,content_0_134:()=>Qe,content_0_1340:()=>CR,content_0_1342:()=>vR,content_0_1344:()=>bR,content_0_1346:()=>zR,content_0_1348:()=>RR,content_0_1350:()=>ER,content_0_1352:()=>FR,content_0_1354:()=>VR,content_0_1356:()=>YR,content_0_1358:()=>$R,content_0_136:()=>Ke,content_0_1360:()=>tP,content_0_1362:()=>oP,content_0_1364:()=>sP,content_0_1366:()=>aP,content_0_1368:()=>mP,content_0_1370:()=>kP,content_0_1372:()=>MP,content_0_1374:()=>_P,content_0_1376:()=>CP,content_0_1378:()=>vP,content_0_138:()=>no,content_0_1380:()=>bP,content_0_1382:()=>zP,content_0_1384:()=>RP,content_0_1386:()=>EP,content_0_1388:()=>FP,content_0_1390:()=>VP,content_0_1392:()=>YP,content_0_1394:()=>$P,content_0_1396:()=>tS,content_0_1398:()=>oS,content_0_14:()=>b,content_0_140:()=>po,content_0_1400:()=>sS,content_0_1402:()=>aS,content_0_1404:()=>mS,content_0_1406:()=>kS,content_0_1408:()=>MS,content_0_1410:()=>_S,content_0_1412:()=>CS,content_0_1414:()=>vS,content_0_1416:()=>bS,content_0_1418:()=>zS,content_0_142:()=>co,content_0_1420:()=>RS,content_0_1422:()=>ES,content_0_1424:()=>FS,content_0_1426:()=>VS,content_0_1428:()=>YS,content_0_1430:()=>$S,content_0_1432:()=>tE,content_0_1434:()=>oE,content_0_1436:()=>sE,content_0_1438:()=>aE,content_0_144:()=>lo,content_0_1440:()=>mE,content_0_1442:()=>kE,content_0_1444:()=>ME,content_0_1446:()=>_E,content_0_1448:()=>CE,content_0_1450:()=>vE,content_0_1452:()=>bE,content_0_1454:()=>zE,content_0_1456:()=>RE,content_0_1458:()=>EE,content_0_146:()=>ho,content_0_1460:()=>FE,content_0_1462:()=>VE,content_0_1464:()=>YE,content_0_1466:()=>$E,content_0_1468:()=>tG,content_0_1470:()=>oG,content_0_1472:()=>sG,content_0_1474:()=>aG,content_0_1476:()=>mG,content_0_1478:()=>kG,content_0_148:()=>yo,content_0_1480:()=>MG,content_0_1482:()=>_G,content_0_1484:()=>CG,content_0_1486:()=>vG,content_0_1488:()=>bG,content_0_1490:()=>zG,content_0_1492:()=>RG,content_0_1494:()=>EG,content_0_1496:()=>FG,content_0_1498:()=>VG,content_0_150:()=>Xo,content_0_1500:()=>YG,content_0_1502:()=>$G,content_0_1504:()=>tO,content_0_1506:()=>oO,content_0_1508:()=>sO,content_0_1510:()=>aO,content_0_1512:()=>mO,content_0_1514:()=>kO,content_0_1516:()=>MO,content_0_1518:()=>_O,content_0_152:()=>To,content_0_1520:()=>CO,content_0_1522:()=>vO,content_0_1524:()=>bO,content_0_1526:()=>zO,content_0_1528:()=>RO,content_0_1530:()=>EO,content_0_1532:()=>FO,content_0_1534:()=>VO,content_0_1536:()=>YO,content_0_1538:()=>$O,content_0_154:()=>xo,content_0_1540:()=>tF,content_0_1542:()=>oF,content_0_1544:()=>sF,content_0_1546:()=>aF,content_0_1548:()=>mF,content_0_1550:()=>kF,content_0_1552:()=>MF,content_0_1554:()=>_F,content_0_1556:()=>CF,content_0_1558:()=>vF,content_0_156:()=>Zo,content_0_1560:()=>bF,content_0_1562:()=>zF,content_0_1564:()=>RF,content_0_1566:()=>EF,content_0_1568:()=>FF,content_0_1570:()=>VF,content_0_1572:()=>YF,content_0_1574:()=>$F,content_0_1576:()=>tB,content_0_1578:()=>oB,content_0_158:()=>Ao,content_0_1580:()=>sB,content_0_1582:()=>aB,content_0_1584:()=>mB,content_0_1586:()=>kB,content_0_1588:()=>MB,content_0_1590:()=>_B,content_0_1592:()=>CB,content_0_1594:()=>vB,content_0_1596:()=>bB,content_0_1598:()=>zB,content_0_16:()=>z,content_0_160:()=>Io,content_0_1600:()=>RB,content_0_1602:()=>EB,content_0_1604:()=>FB,content_0_1606:()=>VB,content_0_1608:()=>YB,content_0_1610:()=>$B,content_0_1612:()=>tU,content_0_1614:()=>oU,content_0_1616:()=>sU,content_0_1618:()=>aU,content_0_162:()=>So,content_0_1620:()=>mU,content_0_1622:()=>kU,content_0_1624:()=>MU,content_0_1626:()=>_U,content_0_1628:()=>CU,content_0_1630:()=>vU,content_0_1632:()=>bU,content_0_1634:()=>zU,content_0_1636:()=>RU,content_0_1638:()=>EU,content_0_164:()=>Oo,content_0_1640:()=>FU,content_0_1642:()=>VU,content_0_1644:()=>YU,content_0_1646:()=>$U,content_0_1648:()=>tV,content_0_1650:()=>oV,content_0_1652:()=>sV,content_0_1654:()=>aV,content_0_1656:()=>mV,content_0_1658:()=>kV,content_0_166:()=>Uo,content_0_1660:()=>MV,content_0_1662:()=>_V,content_0_1664:()=>CV,content_0_1666:()=>vV,content_0_1668:()=>bV,content_0_1670:()=>zV,content_0_1672:()=>RV,content_0_1674:()=>EV,content_0_1676:()=>FV,content_0_1678:()=>VV,content_0_168:()=>jo,content_0_1680:()=>YV,content_0_1682:()=>$V,content_0_1684:()=>tq,content_0_1686:()=>oq,content_0_1688:()=>sq,content_0_1690:()=>aq,content_0_1692:()=>mq,content_0_1694:()=>kq,content_0_1696:()=>Mq,content_0_1698:()=>_q,content_0_170:()=>Ho,content_0_1700:()=>Cq,content_0_1702:()=>vq,content_0_1704:()=>bq,content_0_1706:()=>zq,content_0_1708:()=>Rq,content_0_1710:()=>Eq,content_0_1712:()=>Fq,content_0_1714:()=>Vq,content_0_1716:()=>Yq,content_0_1718:()=>$q,content_0_172:()=>Jo,content_0_1720:()=>tj,content_0_1722:()=>oj,content_0_1724:()=>sj,content_0_1726:()=>aj,content_0_1728:()=>mj,content_0_1730:()=>kj,content_0_1732:()=>Mj,content_0_1734:()=>_j,content_0_1736:()=>Cj,content_0_1738:()=>vj,content_0_174:()=>ep,content_0_1740:()=>bj,content_0_1742:()=>zj,content_0_1744:()=>Rj,content_0_1746:()=>Ej,content_0_1748:()=>Fj,content_0_1750:()=>Vj,content_0_1752:()=>Yj,content_0_1754:()=>$j,content_0_1756:()=>tY,content_0_1758:()=>oY,content_0_176:()=>rp,content_0_1760:()=>sY,content_0_1762:()=>aY,content_0_1764:()=>mY,content_0_1766:()=>kY,content_0_1768:()=>MY,content_0_1770:()=>_Y,content_0_1772:()=>CY,content_0_1774:()=>vY,content_0_1776:()=>bY,content_0_1778:()=>zY,content_0_178:()=>ip,content_0_1780:()=>RY,content_0_1782:()=>EY,content_0_1784:()=>FY,content_0_1786:()=>VY,content_0_1788:()=>YY,content_0_1790:()=>$Y,content_0_1792:()=>tQ,content_0_1794:()=>oQ,content_0_1796:()=>sQ,content_0_1798:()=>aQ,content_0_18:()=>R,content_0_180:()=>up,content_0_1800:()=>mQ,content_0_1802:()=>kQ,content_0_1804:()=>MQ,content_0_1806:()=>_Q,content_0_1808:()=>CQ,content_0_1810:()=>vQ,content_0_1812:()=>bQ,content_0_1814:()=>zQ,content_0_1816:()=>RQ,content_0_1818:()=>EQ,content_0_182:()=>hp,content_0_1820:()=>FQ,content_0_1822:()=>VQ,content_0_1824:()=>YQ,content_0_1826:()=>$Q,content_0_1828:()=>tH,content_0_1830:()=>oH,content_0_1832:()=>sH,content_0_1834:()=>aH,content_0_184:()=>yp,content_0_186:()=>Xp,content_0_188:()=>Tp,content_0_190:()=>xp,content_0_192:()=>Zp,content_0_194:()=>Ap,content_0_196:()=>Ip,content_0_198:()=>Sp,content_0_2:()=>m,content_0_20:()=>E,content_0_200:()=>Op,content_0_202:()=>Up,content_0_204:()=>jp,content_0_206:()=>Hp,content_0_208:()=>Jp,content_0_210:()=>er,content_0_212:()=>rr,content_0_214:()=>ir,content_0_216:()=>ur,content_0_218:()=>hr,content_0_22:()=>F,content_0_220:()=>yr,content_0_222:()=>Xr,content_0_224:()=>Tr,content_0_226:()=>xr,content_0_228:()=>Zr,content_0_230:()=>Ar,content_0_232:()=>Ir,content_0_234:()=>Sr,content_0_236:()=>Or,content_0_238:()=>Ur,content_0_24:()=>V,content_0_240:()=>jr,content_0_242:()=>Hr,content_0_244:()=>Jr,content_0_246:()=>es,content_0_248:()=>rs,content_0_250:()=>is,content_0_252:()=>us,content_0_254:()=>hs,content_0_256:()=>ys,content_0_258:()=>Xs,content_0_26:()=>Y,content_0_260:()=>Ts,content_0_262:()=>xs,content_0_264:()=>Zs,content_0_266:()=>As,content_0_268:()=>Is,content_0_270:()=>Ss,content_0_272:()=>Os,content_0_274:()=>Us,content_0_276:()=>js,content_0_278:()=>Hs,content_0_28:()=>$,content_0_280:()=>Js,content_0_282:()=>ec,content_0_284:()=>rc,content_0_286:()=>ic,content_0_288:()=>uc,content_0_290:()=>hc,content_0_292:()=>yc,content_0_294:()=>Xc,content_0_296:()=>Tc,content_0_298:()=>xc,content_0_30:()=>tt,content_0_300:()=>Zc,content_0_302:()=>Ac,content_0_304:()=>Ic,content_0_306:()=>Sc,content_0_308:()=>Oc,content_0_310:()=>Uc,content_0_312:()=>jc,content_0_314:()=>Hc,content_0_316:()=>Jc,content_0_318:()=>ei,content_0_32:()=>ot,content_0_320:()=>ri,content_0_322:()=>ii,content_0_324:()=>ui,content_0_326:()=>hi,content_0_328:()=>yi,content_0_330:()=>Xi,content_0_332:()=>Ti,content_0_334:()=>xi,content_0_336:()=>Zi,content_0_338:()=>Ai,content_0_34:()=>st,content_0_340:()=>Ii,content_0_342:()=>Si,content_0_344:()=>Oi,content_0_346:()=>Ui,content_0_348:()=>ji,content_0_350:()=>Hi,content_0_352:()=>Ji,content_0_354:()=>ea,content_0_356:()=>ra,content_0_358:()=>ia,content_0_36:()=>at,content_0_360:()=>ua,content_0_362:()=>ha,content_0_364:()=>ya,content_0_366:()=>Xa,content_0_368:()=>Ta,content_0_370:()=>xa,content_0_372:()=>Za,content_0_374:()=>Aa,content_0_376:()=>Ia,content_0_378:()=>Sa,content_0_38:()=>mt,content_0_380:()=>Oa,content_0_382:()=>Ua,content_0_384:()=>ja,content_0_386:()=>Ha,content_0_388:()=>Ja,content_0_390:()=>el,content_0_392:()=>rl,content_0_394:()=>il,content_0_396:()=>ul,content_0_398:()=>hl,content_0_4:()=>k,content_0_40:()=>kt,content_0_400:()=>yl,content_0_402:()=>Xl,content_0_404:()=>Tl,content_0_406:()=>xl,content_0_408:()=>Zl,content_0_410:()=>Al,content_0_412:()=>Il,content_0_414:()=>Sl,content_0_416:()=>Ol,content_0_418:()=>Ul,content_0_42:()=>Mt,content_0_420:()=>jl,content_0_422:()=>Hl,content_0_424:()=>Jl,content_0_426:()=>eu,content_0_428:()=>ru,content_0_430:()=>iu,content_0_432:()=>uu,content_0_434:()=>hu,content_0_436:()=>yu,content_0_438:()=>Xu,content_0_44:()=>_t,content_0_440:()=>Tu,content_0_442:()=>xu,content_0_444:()=>Zu,content_0_446:()=>Au,content_0_448:()=>Iu,content_0_450:()=>Su,content_0_452:()=>Ou,content_0_454:()=>Uu,content_0_456:()=>ju,content_0_458:()=>Hu,content_0_46:()=>Ct,content_0_460:()=>Ju,content_0_462:()=>em,content_0_464:()=>rm,content_0_466:()=>im,content_0_468:()=>um,content_0_470:()=>hm,content_0_472:()=>ym,content_0_474:()=>Xm,content_0_476:()=>Tm,content_0_478:()=>xm,content_0_48:()=>vt,content_0_480:()=>Zm,content_0_482:()=>Am,content_0_484:()=>Im,content_0_486:()=>Sm,content_0_488:()=>Om,content_0_490:()=>Um,content_0_492:()=>jm,content_0_494:()=>Hm,content_0_496:()=>Jm,content_0_498:()=>ed,content_0_50:()=>bt,content_0_500:()=>rd,content_0_502:()=>id,content_0_504:()=>ud,content_0_506:()=>hd,content_0_508:()=>yd,content_0_510:()=>Xd,content_0_512:()=>Td,content_0_514:()=>xd,content_0_516:()=>Zd,content_0_518:()=>Ad,content_0_52:()=>zt,content_0_520:()=>Id,content_0_522:()=>Sd,content_0_524:()=>Od,content_0_526:()=>Ud,content_0_528:()=>jd,content_0_530:()=>Hd,content_0_532:()=>Jd,content_0_534:()=>eh,content_0_536:()=>rh,content_0_538:()=>ih,content_0_54:()=>Rt,content_0_540:()=>uh,content_0_542:()=>hh,content_0_544:()=>yh,content_0_546:()=>Xh,content_0_548:()=>Th,content_0_550:()=>xh,content_0_552:()=>Zh,content_0_554:()=>Ah,content_0_556:()=>Ih,content_0_558:()=>Sh,content_0_56:()=>Et,content_0_560:()=>Oh,content_0_562:()=>Uh,content_0_564:()=>jh,content_0_566:()=>Hh,content_0_568:()=>Jh,content_0_570:()=>ek,content_0_572:()=>rk,content_0_574:()=>ik,content_0_576:()=>uk,content_0_578:()=>hk,content_0_58:()=>Ft,content_0_580:()=>yk,content_0_582:()=>Xk,content_0_584:()=>Tk,content_0_586:()=>xk,content_0_588:()=>Zk,content_0_590:()=>Ak,content_0_592:()=>Ik,content_0_594:()=>Sk,content_0_596:()=>Ok,content_0_598:()=>Uk,content_0_6:()=>M,content_0_60:()=>Vt,content_0_600:()=>jk,content_0_602:()=>Hk,content_0_604:()=>Jk,content_0_606:()=>ef,content_0_608:()=>rf,content_0_610:()=>af,content_0_612:()=>mf,content_0_614:()=>kf,content_0_616:()=>Mf,content_0_618:()=>_f,content_0_62:()=>Yt,content_0_620:()=>Cf,content_0_622:()=>vf,content_0_624:()=>bf,content_0_626:()=>zf,content_0_628:()=>Rf,content_0_630:()=>Ef,content_0_632:()=>Ff,content_0_634:()=>Vf,content_0_636:()=>Yf,content_0_638:()=>$f,content_0_64:()=>$t,content_0_640:()=>ty,content_0_642:()=>oy,content_0_644:()=>sy,content_0_646:()=>ay,content_0_648:()=>my,content_0_650:()=>ky,content_0_652:()=>My,content_0_654:()=>_y,content_0_656:()=>Cy,content_0_658:()=>vy,content_0_66:()=>tn,content_0_660:()=>by,content_0_662:()=>zy,content_0_664:()=>Ry,content_0_666:()=>Ey,content_0_668:()=>Fy,content_0_670:()=>Vy,content_0_672:()=>Yy,content_0_674:()=>$y,content_0_676:()=>tM,content_0_678:()=>oM,content_0_68:()=>on,content_0_680:()=>sM,content_0_682:()=>aM,content_0_684:()=>mM,content_0_686:()=>kM,content_0_688:()=>MM,content_0_690:()=>_M,content_0_692:()=>CM,content_0_694:()=>vM,content_0_696:()=>bM,content_0_698:()=>zM,content_0_70:()=>sn,content_0_700:()=>RM,content_0_702:()=>EM,content_0_704:()=>FM,content_0_706:()=>VM,content_0_708:()=>YM,content_0_710:()=>$M,content_0_712:()=>tD,content_0_714:()=>oD,content_0_716:()=>sD,content_0_718:()=>aD,content_0_72:()=>ln,content_0_720:()=>mD,content_0_722:()=>kD,content_0_724:()=>MD,content_0_726:()=>_D,content_0_728:()=>CD,content_0_730:()=>vD,content_0_732:()=>bD,content_0_734:()=>zD,content_0_736:()=>RD,content_0_738:()=>ED,content_0_74:()=>dn,content_0_740:()=>FD,content_0_742:()=>VD,content_0_744:()=>YD,content_0_746:()=>$D,content_0_748:()=>tX,content_0_750:()=>oX,content_0_752:()=>sX,content_0_754:()=>aX,content_0_756:()=>mX,content_0_758:()=>kX,content_0_76:()=>fn,content_0_760:()=>MX,content_0_762:()=>_X,content_0_764:()=>CX,content_0_766:()=>vX,content_0_768:()=>bX,content_0_770:()=>zX,content_0_772:()=>RX,content_0_774:()=>EX,content_0_776:()=>FX,content_0_778:()=>VX,content_0_78:()=>Dn,content_0_780:()=>YX,content_0_782:()=>$X,content_0_784:()=>t_,content_0_786:()=>o_,content_0_788:()=>s_,content_0_790:()=>a_,content_0_792:()=>m_,content_0_794:()=>k_,content_0_796:()=>M_,content_0_798:()=>__,content_0_8:()=>_,content_0_80:()=>wn,content_0_800:()=>C_,content_0_802:()=>v_,content_0_804:()=>b_,content_0_806:()=>z_,content_0_808:()=>R_,content_0_810:()=>E_,content_0_812:()=>F_,content_0_814:()=>V_,content_0_816:()=>Y_,content_0_818:()=>$_,content_0_82:()=>gn,content_0_820:()=>tw,content_0_822:()=>ow,content_0_824:()=>sw,content_0_826:()=>aw,content_0_828:()=>mw,content_0_830:()=>kw,content_0_832:()=>Mw,content_0_834:()=>_w,content_0_836:()=>Cw,content_0_838:()=>vw,content_0_84:()=>Ln,content_0_840:()=>bw,content_0_842:()=>zw,content_0_844:()=>Rw,content_0_846:()=>Ew,content_0_848:()=>Fw,content_0_850:()=>Vw,content_0_852:()=>Yw,content_0_854:()=>$w,content_0_856:()=>tT,content_0_858:()=>oT,content_0_86:()=>Nn,content_0_860:()=>sT,content_0_862:()=>aT,content_0_864:()=>mT,content_0_866:()=>kT,content_0_868:()=>MT,content_0_870:()=>_T,content_0_872:()=>CT,content_0_874:()=>vT,content_0_876:()=>bT,content_0_878:()=>zT,content_0_88:()=>Wn,content_0_880:()=>RT,content_0_882:()=>ET,content_0_884:()=>FT,content_0_886:()=>VT,content_0_888:()=>YT,content_0_890:()=>$T,content_0_892:()=>tC,content_0_894:()=>oC,content_0_896:()=>sC,content_0_898:()=>aC,content_0_90:()=>Pn,content_0_900:()=>mC,content_0_902:()=>kC,content_0_904:()=>MC,content_0_906:()=>_C,content_0_908:()=>CC,content_0_910:()=>vC,content_0_912:()=>bC,content_0_914:()=>zC,content_0_916:()=>RC,content_0_918:()=>EC,content_0_92:()=>Gn,content_0_920:()=>FC,content_0_922:()=>VC,content_0_924:()=>YC,content_0_926:()=>$C,content_0_928:()=>tg,content_0_930:()=>og,content_0_932:()=>sg,content_0_934:()=>ag,content_0_936:()=>mg,content_0_938:()=>kg,content_0_94:()=>Bn,content_0_940:()=>Mg,content_0_942:()=>_g,content_0_944:()=>Cg,content_0_946:()=>vg,content_0_948:()=>bg,content_0_950:()=>zg,content_0_952:()=>Rg,content_0_954:()=>Eg,content_0_956:()=>Fg,content_0_958:()=>Vg,content_0_96:()=>qn,content_0_960:()=>Yg,content_0_962:()=>$g,content_0_964:()=>tx,content_0_966:()=>ox,content_0_968:()=>sx,content_0_970:()=>ax,content_0_972:()=>mx,content_0_974:()=>kx,content_0_976:()=>Mx,content_0_978:()=>_x,content_0_98:()=>Qn,content_0_980:()=>Cx,content_0_982:()=>vx,content_0_984:()=>bx,content_0_986:()=>zx,content_0_988:()=>Rx,content_0_990:()=>Ex,content_0_992:()=>Fx,content_0_994:()=>Vx,content_0_996:()=>Yx,content_0_998:()=>$x,content_3652_0:()=>mH,content_3652_10:()=>vH,content_3652_100:()=>tJ,content_3652_1000:()=>nht,content_3652_10000:()=>nip,content_3652_10002:()=>pip,content_3652_10004:()=>cip,content_3652_10006:()=>lip,content_3652_10008:()=>dip,content_3652_10010:()=>fip,content_3652_10012:()=>Dip,content_3652_10014:()=>wip,content_3652_10016:()=>gip,content_3652_10018:()=>Lip,content_3652_1002:()=>pht,content_3652_10020:()=>Nip,content_3652_10022:()=>Wip,content_3652_10024:()=>Pip,content_3652_10026:()=>Gip,content_3652_10028:()=>Bip,content_3652_10030:()=>qip,content_3652_10032:()=>Qip,content_3652_10034:()=>Kip,content_3652_10036:()=>nap,content_3652_10038:()=>pap,content_3652_1004:()=>cht,content_3652_10040:()=>cap,content_3652_10042:()=>lap,content_3652_10044:()=>dap,content_3652_10046:()=>fap,content_3652_10048:()=>Dap,content_3652_10050:()=>wap,content_3652_10052:()=>gap,content_3652_10054:()=>Lap,content_3652_10056:()=>Nap,content_3652_10058:()=>Wap,content_3652_1006:()=>lht,content_3652_10060:()=>Pap,content_3652_10062:()=>Gap,content_3652_10064:()=>Bap,content_3652_10066:()=>qap,content_3652_10068:()=>Qap,content_3652_10070:()=>Kap,content_3652_10072:()=>nlp,content_3652_10074:()=>plp,content_3652_10076:()=>clp,content_3652_10078:()=>llp,content_3652_1008:()=>dht,content_3652_10080:()=>dlp,content_3652_10082:()=>flp,content_3652_10084:()=>Dlp,content_3652_10086:()=>wlp,content_3652_10088:()=>glp,content_3652_10090:()=>Llp,content_3652_10092:()=>Nlp,content_3652_10094:()=>Wlp,content_3652_10096:()=>Plp,content_3652_10098:()=>Glp,content_3652_1010:()=>fht,content_3652_10100:()=>Blp,content_3652_10102:()=>qlp,content_3652_10104:()=>Qlp,content_3652_10106:()=>Klp,content_3652_10108:()=>nup,content_3652_10110:()=>pup,content_3652_10112:()=>cup,content_3652_10114:()=>lup,content_3652_10116:()=>dup,content_3652_10118:()=>fup,content_3652_1012:()=>Dht,content_3652_10120:()=>Dup,content_3652_10122:()=>wup,content_3652_10124:()=>gup,content_3652_10126:()=>Lup,content_3652_10128:()=>Nup,content_3652_10130:()=>Wup,content_3652_10132:()=>Pup,content_3652_10134:()=>Gup,content_3652_10136:()=>Bup,content_3652_10138:()=>qup,content_3652_1014:()=>wht,content_3652_10140:()=>Qup,content_3652_10142:()=>Kup,content_3652_10144:()=>nmp,content_3652_10146:()=>pmp,content_3652_10148:()=>cmp,content_3652_10150:()=>lmp,content_3652_10152:()=>dmp,content_3652_10154:()=>fmp,content_3652_10156:()=>Dmp,content_3652_10158:()=>wmp,content_3652_1016:()=>ght,content_3652_10160:()=>gmp,content_3652_10162:()=>Lmp,content_3652_10164:()=>Nmp,content_3652_10166:()=>Wmp,content_3652_10168:()=>Pmp,content_3652_10170:()=>Gmp,content_3652_10172:()=>Bmp,content_3652_10174:()=>qmp,content_3652_10176:()=>Qmp,content_3652_10178:()=>Kmp,content_3652_1018:()=>Lht,content_3652_10180:()=>ndp,content_3652_10182:()=>pdp,content_3652_10184:()=>cdp,content_3652_10186:()=>ldp,content_3652_10188:()=>ddp,content_3652_10190:()=>fdp,content_3652_10192:()=>Ddp,content_3652_10194:()=>wdp,content_3652_10196:()=>gdp,content_3652_10198:()=>Ldp,content_3652_102:()=>oJ,content_3652_1020:()=>Nht,content_3652_10200:()=>Ndp,content_3652_10202:()=>Wdp,content_3652_10204:()=>Pdp,content_3652_10206:()=>Gdp,content_3652_10208:()=>Bdp,content_3652_10210:()=>qdp,content_3652_10212:()=>Qdp,content_3652_10214:()=>Kdp,content_3652_10216:()=>nhp,content_3652_10218:()=>php,content_3652_1022:()=>Wht,content_3652_10220:()=>chp,content_3652_10222:()=>lhp,content_3652_10224:()=>dhp,content_3652_10226:()=>fhp,content_3652_10228:()=>Dhp,content_3652_10230:()=>whp,content_3652_10232:()=>ghp,content_3652_10234:()=>Lhp,content_3652_10236:()=>Nhp,content_3652_10238:()=>Whp,content_3652_1024:()=>Pht,content_3652_10240:()=>Php,content_3652_10242:()=>Ghp,content_3652_10244:()=>Bhp,content_3652_10246:()=>qhp,content_3652_10248:()=>Qhp,content_3652_10250:()=>Khp,content_3652_10252:()=>nkp,content_3652_10254:()=>pkp,content_3652_10256:()=>ckp,content_3652_10258:()=>lkp,content_3652_1026:()=>Ght,content_3652_10260:()=>dkp,content_3652_10262:()=>fkp,content_3652_10264:()=>Dkp,content_3652_10266:()=>wkp,content_3652_10268:()=>gkp,content_3652_10270:()=>Lkp,content_3652_10272:()=>Nkp,content_3652_10274:()=>Wkp,content_3652_10276:()=>Pkp,content_3652_10278:()=>Gkp,content_3652_1028:()=>Bht,content_3652_10280:()=>Bkp,content_3652_10282:()=>qkp,content_3652_10284:()=>Qkp,content_3652_10286:()=>Kkp,content_3652_10288:()=>nfp,content_3652_10290:()=>pfp,content_3652_10292:()=>cfp,content_3652_10294:()=>lfp,content_3652_10296:()=>dfp,content_3652_10298:()=>ffp,content_3652_1030:()=>qht,content_3652_10300:()=>Dfp,content_3652_10302:()=>wfp,content_3652_10304:()=>gfp,content_3652_10306:()=>Lfp,content_3652_10308:()=>Nfp,content_3652_10310:()=>Wfp,content_3652_10312:()=>Pfp,content_3652_10314:()=>Gfp,content_3652_10316:()=>Bfp,content_3652_10318:()=>qfp,content_3652_1032:()=>Qht,content_3652_10320:()=>Qfp,content_3652_10322:()=>Kfp,content_3652_10324:()=>nyp,content_3652_10326:()=>pyp,content_3652_10328:()=>cyp,content_3652_10330:()=>lyp,content_3652_10332:()=>dyp,content_3652_10334:()=>fyp,content_3652_10336:()=>Dyp,content_3652_10338:()=>wyp,content_3652_1034:()=>Kht,content_3652_10340:()=>gyp,content_3652_10342:()=>Lyp,content_3652_10344:()=>Nyp,content_3652_10346:()=>Wyp,content_3652_10348:()=>Pyp,content_3652_10350:()=>Gyp,content_3652_10352:()=>Byp,content_3652_10354:()=>qyp,content_3652_10356:()=>Qyp,content_3652_10358:()=>Kyp,content_3652_1036:()=>nkt,content_3652_10360:()=>nMp,content_3652_10362:()=>pMp,content_3652_10364:()=>cMp,content_3652_10366:()=>lMp,content_3652_10368:()=>dMp,content_3652_10370:()=>fMp,content_3652_10372:()=>DMp,content_3652_10374:()=>wMp,content_3652_10376:()=>gMp,content_3652_10378:()=>LMp,content_3652_1038:()=>pkt,content_3652_10380:()=>NMp,content_3652_10382:()=>WMp,content_3652_10384:()=>PMp,content_3652_10386:()=>GMp,content_3652_10388:()=>BMp,content_3652_10390:()=>qMp,content_3652_10392:()=>QMp,content_3652_10394:()=>KMp,content_3652_10396:()=>nDp,content_3652_10398:()=>pDp,content_3652_104:()=>sJ,content_3652_1040:()=>ckt,content_3652_10400:()=>cDp,content_3652_10402:()=>lDp,content_3652_10404:()=>dDp,content_3652_10406:()=>fDp,content_3652_10408:()=>DDp,content_3652_10410:()=>wDp,content_3652_10412:()=>gDp,content_3652_10414:()=>LDp,content_3652_10416:()=>NDp,content_3652_10418:()=>WDp,content_3652_1042:()=>lkt,content_3652_10420:()=>PDp,content_3652_10422:()=>GDp,content_3652_10424:()=>BDp,content_3652_10426:()=>qDp,content_3652_10428:()=>QDp,content_3652_10430:()=>KDp,content_3652_10432:()=>nXp,content_3652_10434:()=>pXp,content_3652_10436:()=>cXp,content_3652_10438:()=>lXp,content_3652_1044:()=>dkt,content_3652_10440:()=>dXp,content_3652_10442:()=>fXp,content_3652_10444:()=>DXp,content_3652_10446:()=>wXp,content_3652_10448:()=>gXp,content_3652_10450:()=>LXp,content_3652_10452:()=>NXp,content_3652_10454:()=>WXp,content_3652_10456:()=>PXp,content_3652_10458:()=>GXp,content_3652_1046:()=>fkt,content_3652_10460:()=>BXp,content_3652_10462:()=>qXp,content_3652_10464:()=>QXp,content_3652_10466:()=>KXp,content_3652_10468:()=>n_p,content_3652_10470:()=>p_p,content_3652_10472:()=>c_p,content_3652_10474:()=>l_p,content_3652_10476:()=>d_p,content_3652_10478:()=>f_p,content_3652_1048:()=>Dkt,content_3652_10480:()=>D_p,content_3652_10482:()=>w_p,content_3652_10484:()=>g_p,content_3652_10486:()=>L_p,content_3652_10488:()=>N_p,content_3652_10490:()=>W_p,content_3652_10492:()=>P_p,content_3652_10494:()=>G_p,content_3652_10496:()=>B_p,content_3652_10498:()=>q_p,content_3652_1050:()=>wkt,content_3652_10500:()=>Q_p,content_3652_10502:()=>K_p,content_3652_10504:()=>nwp,content_3652_10506:()=>pwp,content_3652_10508:()=>cwp,content_3652_10510:()=>lwp,content_3652_10512:()=>dwp,content_3652_10514:()=>fwp,content_3652_10516:()=>Dwp,content_3652_10518:()=>wwp,content_3652_1052:()=>gkt,content_3652_10520:()=>gwp,content_3652_10522:()=>Lwp,content_3652_10524:()=>Nwp,content_3652_10526:()=>Wwp,content_3652_10528:()=>Pwp,content_3652_10530:()=>Gwp,content_3652_10532:()=>Bwp,content_3652_10534:()=>qwp,content_3652_10536:()=>Qwp,content_3652_10538:()=>Kwp,content_3652_1054:()=>Lkt,content_3652_10540:()=>nTp,content_3652_10542:()=>pTp,content_3652_10544:()=>cTp,content_3652_10546:()=>lTp,content_3652_10548:()=>dTp,content_3652_10550:()=>fTp,content_3652_10552:()=>DTp,content_3652_10554:()=>wTp,content_3652_10556:()=>gTp,content_3652_10558:()=>LTp,content_3652_1056:()=>Nkt,content_3652_10560:()=>NTp,content_3652_10562:()=>WTp,content_3652_10564:()=>PTp,content_3652_10566:()=>GTp,content_3652_10568:()=>BTp,content_3652_10570:()=>qTp,content_3652_10572:()=>QTp,content_3652_10574:()=>KTp,content_3652_10576:()=>nCp,content_3652_10578:()=>pCp,content_3652_1058:()=>Wkt,content_3652_10580:()=>cCp,content_3652_10582:()=>lCp,content_3652_10584:()=>dCp,content_3652_10586:()=>fCp,content_3652_10588:()=>DCp,content_3652_10590:()=>wCp,content_3652_10592:()=>gCp,content_3652_10594:()=>LCp,content_3652_10596:()=>NCp,content_3652_10598:()=>WCp,content_3652_106:()=>aJ,content_3652_1060:()=>Pkt,content_3652_10600:()=>PCp,content_3652_10602:()=>GCp,content_3652_10604:()=>BCp,content_3652_10606:()=>qCp,content_3652_10608:()=>QCp,content_3652_10610:()=>KCp,content_3652_10612:()=>ngp,content_3652_10614:()=>pgp,content_3652_10616:()=>cgp,content_3652_10618:()=>lgp,content_3652_1062:()=>Gkt,content_3652_10620:()=>dgp,content_3652_10622:()=>fgp,content_3652_10624:()=>Dgp,content_3652_10626:()=>wgp,content_3652_10628:()=>ggp,content_3652_10630:()=>Lgp,content_3652_10632:()=>Ngp,content_3652_10634:()=>Wgp,content_3652_10636:()=>Pgp,content_3652_10638:()=>Ggp,content_3652_1064:()=>Bkt,content_3652_10640:()=>Bgp,content_3652_10642:()=>qgp,content_3652_10644:()=>Qgp,content_3652_10646:()=>Kgp,content_3652_10648:()=>nxp,content_3652_10650:()=>pxp,content_3652_10652:()=>cxp,content_3652_10654:()=>lxp,content_3652_10656:()=>dxp,content_3652_10658:()=>fxp,content_3652_1066:()=>qkt,content_3652_10660:()=>Dxp,content_3652_10662:()=>wxp,content_3652_10664:()=>gxp,content_3652_10666:()=>Lxp,content_3652_10668:()=>Nxp,content_3652_10670:()=>Wxp,content_3652_10672:()=>Pxp,content_3652_10674:()=>Gxp,content_3652_10676:()=>Bxp,content_3652_10678:()=>qxp,content_3652_1068:()=>Qkt,content_3652_10680:()=>Qxp,content_3652_10682:()=>Kxp,content_3652_10684:()=>nvp,content_3652_10686:()=>pvp,content_3652_10688:()=>cvp,content_3652_10690:()=>lvp,content_3652_10692:()=>dvp,content_3652_10694:()=>fvp,content_3652_10696:()=>Dvp,content_3652_10698:()=>wvp,content_3652_1070:()=>Kkt,content_3652_10700:()=>gvp,content_3652_10702:()=>Lvp,content_3652_10704:()=>Nvp,content_3652_10706:()=>Wvp,content_3652_10708:()=>Pvp,content_3652_10710:()=>Gvp,content_3652_10712:()=>Bvp,content_3652_10714:()=>qvp,content_3652_10716:()=>Qvp,content_3652_10718:()=>Kvp,content_3652_1072:()=>nft,content_3652_10720:()=>nLp,content_3652_10722:()=>pLp,content_3652_10724:()=>cLp,content_3652_10726:()=>lLp,content_3652_10728:()=>dLp,content_3652_10730:()=>fLp,content_3652_10732:()=>DLp,content_3652_10734:()=>wLp,content_3652_10736:()=>gLp,content_3652_10738:()=>LLp,content_3652_1074:()=>pft,content_3652_10740:()=>NLp,content_3652_10742:()=>WLp,content_3652_10744:()=>PLp,content_3652_10746:()=>GLp,content_3652_10748:()=>BLp,content_3652_10750:()=>qLp,content_3652_10752:()=>QLp,content_3652_10754:()=>KLp,content_3652_10756:()=>nZp,content_3652_10758:()=>pZp,content_3652_1076:()=>cft,content_3652_10760:()=>cZp,content_3652_10762:()=>lZp,content_3652_10764:()=>dZp,content_3652_10766:()=>fZp,content_3652_10768:()=>DZp,content_3652_10770:()=>wZp,content_3652_10772:()=>gZp,content_3652_10774:()=>LZp,content_3652_10776:()=>NZp,content_3652_10778:()=>WZp,content_3652_1078:()=>lft,content_3652_10780:()=>PZp,content_3652_10782:()=>GZp,content_3652_10784:()=>BZp,content_3652_10786:()=>qZp,content_3652_10788:()=>QZp,content_3652_10790:()=>KZp,content_3652_10792:()=>nbp,content_3652_10794:()=>pbp,content_3652_10796:()=>cbp,content_3652_10798:()=>lbp,content_3652_108:()=>mJ,content_3652_1080:()=>dft,content_3652_10800:()=>dbp,content_3652_10802:()=>fbp,content_3652_10804:()=>Dbp,content_3652_10806:()=>wbp,content_3652_10808:()=>gbp,content_3652_10810:()=>Lbp,content_3652_10812:()=>Nbp,content_3652_10814:()=>Wbp,content_3652_10816:()=>Pbp,content_3652_10818:()=>Gbp,content_3652_1082:()=>fft,content_3652_10820:()=>Bbp,content_3652_10822:()=>qbp,content_3652_10824:()=>Qbp,content_3652_10826:()=>Kbp,content_3652_10828:()=>nNp,content_3652_10830:()=>pNp,content_3652_10832:()=>cNp,content_3652_10834:()=>lNp,content_3652_10836:()=>dNp,content_3652_10838:()=>fNp,content_3652_1084:()=>Dft,content_3652_10840:()=>DNp,content_3652_10842:()=>wNp,content_3652_10844:()=>gNp,content_3652_10846:()=>LNp,content_3652_10848:()=>NNp,content_3652_10850:()=>WNp,content_3652_10852:()=>PNp,content_3652_10854:()=>GNp,content_3652_10856:()=>BNp,content_3652_10858:()=>qNp,content_3652_1086:()=>wft,content_3652_10860:()=>QNp,content_3652_10862:()=>KNp,content_3652_10864:()=>nAp,content_3652_10866:()=>pAp,content_3652_10868:()=>cAp,content_3652_10870:()=>lAp,content_3652_10872:()=>dAp,content_3652_10874:()=>fAp,content_3652_10876:()=>DAp,content_3652_10878:()=>wAp,content_3652_1088:()=>gft,content_3652_10880:()=>gAp,content_3652_10882:()=>LAp,content_3652_10884:()=>NAp,content_3652_10886:()=>WAp,content_3652_10888:()=>PAp,content_3652_10890:()=>GAp,content_3652_10892:()=>BAp,content_3652_10894:()=>qAp,content_3652_10896:()=>QAp,content_3652_10898:()=>KAp,content_3652_1090:()=>Lft,content_3652_10900:()=>nzp,content_3652_10902:()=>pzp,content_3652_10904:()=>czp,content_3652_10906:()=>lzp,content_3652_10908:()=>dzp,content_3652_10910:()=>fzp,content_3652_10912:()=>Dzp,content_3652_10914:()=>wzp,content_3652_10916:()=>gzp,content_3652_10918:()=>Lzp,content_3652_1092:()=>Nft,content_3652_10920:()=>Nzp,content_3652_10922:()=>Wzp,content_3652_10924:()=>Pzp,content_3652_10926:()=>Gzp,content_3652_10928:()=>Bzp,content_3652_10930:()=>qzp,content_3652_10932:()=>Qzp,content_3652_10934:()=>Kzp,content_3652_10936:()=>nWp,content_3652_10938:()=>pWp,content_3652_1094:()=>Wft,content_3652_10940:()=>cWp,content_3652_10942:()=>lWp,content_3652_10944:()=>dWp,content_3652_10946:()=>fWp,content_3652_10948:()=>DWp,content_3652_10950:()=>wWp,content_3652_10952:()=>gWp,content_3652_10954:()=>LWp,content_3652_10956:()=>NWp,content_3652_10958:()=>WWp,content_3652_1096:()=>Pft,content_3652_10960:()=>PWp,content_3652_10962:()=>GWp,content_3652_10964:()=>BWp,content_3652_10966:()=>qWp,content_3652_10968:()=>QWp,content_3652_10970:()=>KWp,content_3652_10972:()=>nIp,content_3652_10974:()=>pIp,content_3652_10976:()=>cIp,content_3652_10978:()=>lIp,content_3652_1098:()=>Gft,content_3652_10980:()=>dIp,content_3652_10982:()=>fIp,content_3652_10984:()=>DIp,content_3652_10986:()=>wIp,content_3652_10988:()=>gIp,content_3652_10990:()=>LIp,content_3652_10992:()=>NIp,content_3652_10994:()=>WIp,content_3652_10996:()=>PIp,content_3652_10998:()=>GIp,content_3652_110:()=>kJ,content_3652_1100:()=>Bft,content_3652_11000:()=>BIp,content_3652_11002:()=>qIp,content_3652_11004:()=>QIp,content_3652_11006:()=>KIp,content_3652_11008:()=>nRp,content_3652_11010:()=>pRp,content_3652_11012:()=>cRp,content_3652_11014:()=>lRp,content_3652_11016:()=>dRp,content_3652_11018:()=>fRp,content_3652_1102:()=>qft,content_3652_11020:()=>DRp,content_3652_11022:()=>wRp,content_3652_11024:()=>gRp,content_3652_11026:()=>LRp,content_3652_11028:()=>NRp,content_3652_11030:()=>WRp,content_3652_11032:()=>PRp,content_3652_11034:()=>GRp,content_3652_11036:()=>BRp,content_3652_11038:()=>qRp,content_3652_1104:()=>Qft,content_3652_11040:()=>QRp,content_3652_11042:()=>KRp,content_3652_11044:()=>nPp,content_3652_11046:()=>pPp,content_3652_11048:()=>cPp,content_3652_11050:()=>lPp,content_3652_11052:()=>dPp,content_3652_11054:()=>fPp,content_3652_11056:()=>DPp,content_3652_11058:()=>wPp,content_3652_1106:()=>Kft,content_3652_11060:()=>gPp,content_3652_11062:()=>LPp,content_3652_11064:()=>NPp,content_3652_11066:()=>WPp,content_3652_11068:()=>PPp,content_3652_11070:()=>GPp,content_3652_11072:()=>BPp,content_3652_11074:()=>qPp,content_3652_11076:()=>QPp,content_3652_11078:()=>KPp,content_3652_1108:()=>nyt,content_3652_11080:()=>nSp,content_3652_11082:()=>pSp,content_3652_11084:()=>cSp,content_3652_11086:()=>lSp,content_3652_11088:()=>dSp,content_3652_11090:()=>fSp,content_3652_11092:()=>DSp,content_3652_11094:()=>wSp,content_3652_11096:()=>gSp,content_3652_11098:()=>LSp,content_3652_1110:()=>pyt,content_3652_11100:()=>NSp,content_3652_11102:()=>WSp,content_3652_11104:()=>PSp,content_3652_11106:()=>GSp,content_3652_11108:()=>BSp,content_3652_11110:()=>qSp,content_3652_11112:()=>QSp,content_3652_11114:()=>KSp,content_3652_11116:()=>nEp,content_3652_11118:()=>pEp,content_3652_1112:()=>cyt,content_3652_11120:()=>cEp,content_3652_11122:()=>lEp,content_3652_11124:()=>dEp,content_3652_11126:()=>fEp,content_3652_11128:()=>DEp,content_3652_11130:()=>wEp,content_3652_11132:()=>gEp,content_3652_11134:()=>LEp,content_3652_11136:()=>NEp,content_3652_11138:()=>WEp,content_3652_1114:()=>lyt,content_3652_11140:()=>PEp,content_3652_11142:()=>GEp,content_3652_11144:()=>BEp,content_3652_11146:()=>qEp,content_3652_11148:()=>QEp,content_3652_11150:()=>KEp,content_3652_11152:()=>nGp,content_3652_11154:()=>pGp,content_3652_11156:()=>cGp,content_3652_1116:()=>dyt,content_3652_1118:()=>fyt,content_3652_112:()=>MJ,content_3652_1120:()=>Dyt,content_3652_1122:()=>wyt,content_3652_1124:()=>gyt,content_3652_1126:()=>Lyt,content_3652_1128:()=>Nyt,content_3652_1130:()=>Wyt,content_3652_1132:()=>Pyt,content_3652_1134:()=>Gyt,content_3652_1136:()=>Byt,content_3652_1138:()=>qyt,content_3652_114:()=>_J,content_3652_1140:()=>Qyt,content_3652_1142:()=>Kyt,content_3652_1144:()=>nMt,content_3652_1146:()=>pMt,content_3652_1148:()=>cMt,content_3652_1150:()=>lMt,content_3652_1152:()=>dMt,content_3652_1154:()=>fMt,content_3652_1156:()=>DMt,content_3652_1158:()=>wMt,content_3652_116:()=>CJ,content_3652_1160:()=>gMt,content_3652_1162:()=>LMt,content_3652_1164:()=>NMt,content_3652_1166:()=>WMt,content_3652_1168:()=>PMt,content_3652_1170:()=>GMt,content_3652_1172:()=>BMt,content_3652_1174:()=>qMt,content_3652_1176:()=>QMt,content_3652_1178:()=>KMt,content_3652_118:()=>vJ,content_3652_1180:()=>nDt,content_3652_1182:()=>pDt,content_3652_1184:()=>cDt,content_3652_1186:()=>lDt,content_3652_1188:()=>dDt,content_3652_1190:()=>fDt,content_3652_1192:()=>DDt,content_3652_1194:()=>wDt,content_3652_1196:()=>gDt,content_3652_1198:()=>LDt,content_3652_12:()=>bH,content_3652_120:()=>bJ,content_3652_1200:()=>NDt,content_3652_1202:()=>WDt,content_3652_1204:()=>PDt,content_3652_1206:()=>GDt,content_3652_1208:()=>BDt,content_3652_1210:()=>qDt,content_3652_1212:()=>QDt,content_3652_1214:()=>KDt,content_3652_1216:()=>nXt,content_3652_1218:()=>pXt,content_3652_122:()=>zJ,content_3652_1220:()=>cXt,content_3652_1222:()=>lXt,content_3652_1224:()=>dXt,content_3652_1226:()=>fXt,content_3652_1228:()=>DXt,content_3652_1230:()=>wXt,content_3652_1232:()=>gXt,content_3652_1234:()=>LXt,content_3652_1236:()=>NXt,content_3652_1238:()=>WXt,content_3652_124:()=>RJ,content_3652_1240:()=>PXt,content_3652_1242:()=>GXt,content_3652_1244:()=>BXt,content_3652_1246:()=>qXt,content_3652_1248:()=>QXt,content_3652_1250:()=>KXt,content_3652_1252:()=>n_t,content_3652_1254:()=>p_t,content_3652_1256:()=>c_t,content_3652_1258:()=>l_t,content_3652_126:()=>EJ,content_3652_1260:()=>d_t,content_3652_1262:()=>f_t,content_3652_1264:()=>D_t,content_3652_1266:()=>w_t,content_3652_1268:()=>g_t,content_3652_1270:()=>L_t,content_3652_1272:()=>N_t,content_3652_1274:()=>W_t,content_3652_1276:()=>P_t,content_3652_1278:()=>G_t,content_3652_128:()=>FJ,content_3652_1280:()=>B_t,content_3652_1282:()=>q_t,content_3652_1284:()=>Q_t,content_3652_1286:()=>K_t,content_3652_1288:()=>nwt,content_3652_1290:()=>pwt,content_3652_1292:()=>cwt,content_3652_1294:()=>lwt,content_3652_1296:()=>dwt,content_3652_1298:()=>fwt,content_3652_130:()=>VJ,content_3652_1300:()=>Dwt,content_3652_1302:()=>wwt,content_3652_1304:()=>gwt,content_3652_1306:()=>Lwt,content_3652_1308:()=>Nwt,content_3652_1310:()=>Wwt,content_3652_1312:()=>Pwt,content_3652_1314:()=>Gwt,content_3652_1316:()=>Bwt,content_3652_1318:()=>qwt,content_3652_132:()=>YJ,content_3652_1320:()=>Qwt,content_3652_1322:()=>Kwt,content_3652_1324:()=>nTt,content_3652_1326:()=>pTt,content_3652_1328:()=>cTt,content_3652_1330:()=>lTt,content_3652_1332:()=>dTt,content_3652_1334:()=>fTt,content_3652_1336:()=>DTt,content_3652_1338:()=>wTt,content_3652_134:()=>$J,content_3652_1340:()=>gTt,content_3652_1342:()=>LTt,content_3652_1344:()=>NTt,content_3652_1346:()=>WTt,content_3652_1348:()=>PTt,content_3652_1350:()=>GTt,content_3652_1352:()=>BTt,content_3652_1354:()=>qTt,content_3652_1356:()=>QTt,content_3652_1358:()=>KTt,content_3652_136:()=>t0,content_3652_1360:()=>nCt,content_3652_1362:()=>pCt,content_3652_1364:()=>cCt,content_3652_1366:()=>lCt,content_3652_1368:()=>dCt,content_3652_1370:()=>fCt,content_3652_1372:()=>DCt,content_3652_1374:()=>wCt,content_3652_1376:()=>gCt,content_3652_1378:()=>LCt,content_3652_138:()=>o0,content_3652_1380:()=>NCt,content_3652_1382:()=>WCt,content_3652_1384:()=>PCt,content_3652_1386:()=>GCt,content_3652_1388:()=>BCt,content_3652_1390:()=>qCt,content_3652_1392:()=>QCt,content_3652_1394:()=>KCt,content_3652_1396:()=>ngt,content_3652_1398:()=>pgt,content_3652_14:()=>zH,content_3652_140:()=>s0,content_3652_1400:()=>cgt,content_3652_1402:()=>lgt,content_3652_1404:()=>dgt,content_3652_1406:()=>fgt,content_3652_1408:()=>Dgt,content_3652_1410:()=>wgt,content_3652_1412:()=>ggt,content_3652_1414:()=>Lgt,content_3652_1416:()=>Ngt,content_3652_1418:()=>Wgt,content_3652_142:()=>a0,content_3652_1420:()=>Pgt,content_3652_1422:()=>Ggt,content_3652_1424:()=>Bgt,content_3652_1426:()=>qgt,content_3652_1428:()=>Qgt,content_3652_1430:()=>Kgt,content_3652_1432:()=>nxt,content_3652_1434:()=>pxt,content_3652_1436:()=>cxt,content_3652_1438:()=>lxt,content_3652_144:()=>m0,content_3652_1440:()=>dxt,content_3652_1442:()=>fxt,content_3652_1444:()=>Dxt,content_3652_1446:()=>wxt,content_3652_1448:()=>gxt,content_3652_1450:()=>Lxt,content_3652_1452:()=>Nxt,content_3652_1454:()=>Wxt,content_3652_1456:()=>Pxt,content_3652_1458:()=>Gxt,content_3652_146:()=>k0,content_3652_1460:()=>Bxt,content_3652_1462:()=>qxt,content_3652_1464:()=>Qxt,content_3652_1466:()=>Kxt,content_3652_1468:()=>nvt,content_3652_1470:()=>pvt,content_3652_1472:()=>cvt,content_3652_1474:()=>lvt,content_3652_1476:()=>dvt,content_3652_1478:()=>fvt,content_3652_148:()=>M0,content_3652_1480:()=>Dvt,content_3652_1482:()=>wvt,content_3652_1484:()=>gvt,content_3652_1486:()=>Lvt,content_3652_1488:()=>Nvt,content_3652_1490:()=>Wvt,content_3652_1492:()=>Pvt,content_3652_1494:()=>Gvt,content_3652_1496:()=>Bvt,content_3652_1498:()=>qvt,content_3652_150:()=>_0,content_3652_1500:()=>Qvt,content_3652_1502:()=>Kvt,content_3652_1504:()=>nLt,content_3652_1506:()=>pLt,content_3652_1508:()=>cLt,content_3652_1510:()=>lLt,content_3652_1512:()=>dLt,content_3652_1514:()=>fLt,content_3652_1516:()=>DLt,content_3652_1518:()=>wLt,content_3652_152:()=>C0,content_3652_1520:()=>gLt,content_3652_1522:()=>LLt,content_3652_1524:()=>NLt,content_3652_1526:()=>WLt,content_3652_1528:()=>PLt,content_3652_1530:()=>GLt,content_3652_1532:()=>BLt,content_3652_1534:()=>qLt,content_3652_1536:()=>QLt,content_3652_1538:()=>KLt,content_3652_154:()=>v0,content_3652_1540:()=>nZt,content_3652_1542:()=>pZt,content_3652_1544:()=>cZt,content_3652_1546:()=>lZt,content_3652_1548:()=>dZt,content_3652_1550:()=>fZt,content_3652_1552:()=>DZt,content_3652_1554:()=>wZt,content_3652_1556:()=>gZt,content_3652_1558:()=>LZt,content_3652_156:()=>b0,content_3652_1560:()=>NZt,content_3652_1562:()=>WZt,content_3652_1564:()=>PZt,content_3652_1566:()=>GZt,content_3652_1568:()=>BZt,content_3652_1570:()=>qZt,content_3652_1572:()=>QZt,content_3652_1574:()=>KZt,content_3652_1576:()=>nbt,content_3652_1578:()=>pbt,content_3652_158:()=>z0,content_3652_1580:()=>cbt,content_3652_1582:()=>lbt,content_3652_1584:()=>dbt,content_3652_1586:()=>fbt,content_3652_1588:()=>Dbt,content_3652_1590:()=>wbt,content_3652_1592:()=>gbt,content_3652_1594:()=>Lbt,content_3652_1596:()=>Nbt,content_3652_1598:()=>Wbt,content_3652_16:()=>RH,content_3652_160:()=>R0,content_3652_1600:()=>Pbt,content_3652_1602:()=>Gbt,content_3652_1604:()=>Bbt,content_3652_1606:()=>qbt,content_3652_1608:()=>Qbt,content_3652_1610:()=>Kbt,content_3652_1612:()=>nNt,content_3652_1614:()=>pNt,content_3652_1616:()=>cNt,content_3652_1618:()=>lNt,content_3652_162:()=>E0,content_3652_1620:()=>dNt,content_3652_1622:()=>fNt,content_3652_1624:()=>DNt,content_3652_1626:()=>wNt,content_3652_1628:()=>gNt,content_3652_1630:()=>LNt,content_3652_1632:()=>NNt,content_3652_1634:()=>WNt,content_3652_1636:()=>PNt,content_3652_1638:()=>GNt,content_3652_164:()=>F0,content_3652_1640:()=>BNt,content_3652_1642:()=>qNt,content_3652_1644:()=>QNt,content_3652_1646:()=>KNt,content_3652_1648:()=>nAt,content_3652_1650:()=>pAt,content_3652_1652:()=>cAt,content_3652_1654:()=>lAt,content_3652_1656:()=>dAt,content_3652_1658:()=>fAt,content_3652_166:()=>V0,content_3652_1660:()=>DAt,content_3652_1662:()=>wAt,content_3652_1664:()=>gAt,content_3652_1666:()=>LAt,content_3652_1668:()=>NAt,content_3652_1670:()=>WAt,content_3652_1672:()=>PAt,content_3652_1674:()=>GAt,content_3652_1676:()=>BAt,content_3652_1678:()=>qAt,content_3652_168:()=>Y0,content_3652_1680:()=>QAt,content_3652_1682:()=>KAt,content_3652_1684:()=>nzt,content_3652_1686:()=>pzt,content_3652_1688:()=>czt,content_3652_1690:()=>lzt,content_3652_1692:()=>dzt,content_3652_1694:()=>fzt,content_3652_1696:()=>Dzt,content_3652_1698:()=>wzt,content_3652_170:()=>$0,content_3652_1700:()=>gzt,content_3652_1702:()=>Lzt,content_3652_1704:()=>Nzt,content_3652_1706:()=>Wzt,content_3652_1708:()=>Pzt,content_3652_1710:()=>Gzt,content_3652_1712:()=>Bzt,content_3652_1714:()=>qzt,content_3652_1716:()=>Qzt,content_3652_1718:()=>Kzt,content_3652_172:()=>t2,content_3652_1720:()=>nWt,content_3652_1722:()=>pWt,content_3652_1724:()=>cWt,content_3652_1726:()=>lWt,content_3652_1728:()=>dWt,content_3652_1730:()=>fWt,content_3652_1732:()=>DWt,content_3652_1734:()=>wWt,content_3652_1736:()=>gWt,content_3652_1738:()=>LWt,content_3652_174:()=>o2,content_3652_1740:()=>NWt,content_3652_1742:()=>WWt,content_3652_1744:()=>PWt,content_3652_1746:()=>GWt,content_3652_1748:()=>BWt,content_3652_1750:()=>qWt,content_3652_1752:()=>QWt,content_3652_1754:()=>KWt,content_3652_1756:()=>nIt,content_3652_1758:()=>pIt,content_3652_176:()=>s2,content_3652_1760:()=>cIt,content_3652_1762:()=>lIt,content_3652_1764:()=>dIt,content_3652_1766:()=>fIt,content_3652_1768:()=>DIt,content_3652_1770:()=>wIt,content_3652_1772:()=>gIt,content_3652_1774:()=>LIt,content_3652_1776:()=>NIt,content_3652_1778:()=>WIt,content_3652_178:()=>a2,content_3652_1780:()=>PIt,content_3652_1782:()=>GIt,content_3652_1784:()=>BIt,content_3652_1786:()=>qIt,content_3652_1788:()=>QIt,content_3652_1790:()=>KIt,content_3652_1792:()=>nRt,content_3652_1794:()=>pRt,content_3652_1796:()=>cRt,content_3652_1798:()=>lRt,content_3652_18:()=>EH,content_3652_180:()=>m2,content_3652_1800:()=>dRt,content_3652_1802:()=>fRt,content_3652_1804:()=>DRt,content_3652_1806:()=>wRt,content_3652_1808:()=>gRt,content_3652_1810:()=>LRt,content_3652_1812:()=>NRt,content_3652_1814:()=>WRt,content_3652_1816:()=>PRt,content_3652_1818:()=>GRt,content_3652_182:()=>k2,content_3652_1820:()=>BRt,content_3652_1822:()=>qRt,content_3652_1824:()=>QRt,content_3652_1826:()=>KRt,content_3652_1828:()=>nPt,content_3652_1830:()=>pPt,content_3652_1832:()=>cPt,content_3652_1834:()=>lPt,content_3652_1836:()=>dPt,content_3652_1838:()=>fPt,content_3652_184:()=>M2,content_3652_1840:()=>DPt,content_3652_1842:()=>wPt,content_3652_1844:()=>gPt,content_3652_1846:()=>LPt,content_3652_1848:()=>NPt,content_3652_1850:()=>WPt,content_3652_1852:()=>PPt,content_3652_1854:()=>GPt,content_3652_1856:()=>BPt,content_3652_1858:()=>qPt,content_3652_186:()=>_2,content_3652_1860:()=>QPt,content_3652_1862:()=>KPt,content_3652_1864:()=>nSt,content_3652_1866:()=>pSt,content_3652_1868:()=>cSt,content_3652_1870:()=>lSt,content_3652_1872:()=>dSt,content_3652_1874:()=>fSt,content_3652_1876:()=>DSt,content_3652_1878:()=>wSt,content_3652_188:()=>C2,content_3652_1880:()=>gSt,content_3652_1882:()=>LSt,content_3652_1884:()=>NSt,content_3652_1886:()=>WSt,content_3652_1888:()=>PSt,content_3652_1890:()=>GSt,content_3652_1892:()=>BSt,content_3652_1894:()=>qSt,content_3652_1896:()=>QSt,content_3652_1898:()=>KSt,content_3652_190:()=>v2,content_3652_1900:()=>nEt,content_3652_1902:()=>pEt,content_3652_1904:()=>cEt,content_3652_1906:()=>lEt,content_3652_1908:()=>dEt,content_3652_1910:()=>fEt,content_3652_1912:()=>DEt,content_3652_1914:()=>wEt,content_3652_1916:()=>gEt,content_3652_1918:()=>LEt,content_3652_192:()=>b2,content_3652_1920:()=>NEt,content_3652_1922:()=>WEt,content_3652_1924:()=>PEt,content_3652_1926:()=>GEt,content_3652_1928:()=>BEt,content_3652_1930:()=>qEt,content_3652_1932:()=>QEt,content_3652_1934:()=>KEt,content_3652_1936:()=>nGt,content_3652_1938:()=>pGt,content_3652_194:()=>z2,content_3652_1940:()=>cGt,content_3652_1942:()=>lGt,content_3652_1944:()=>dGt,content_3652_1946:()=>fGt,content_3652_1948:()=>DGt,content_3652_1950:()=>wGt,content_3652_1952:()=>gGt,content_3652_1954:()=>LGt,content_3652_1956:()=>NGt,content_3652_1958:()=>WGt,content_3652_196:()=>R2,content_3652_1960:()=>PGt,content_3652_1962:()=>GGt,content_3652_1964:()=>BGt,content_3652_1966:()=>qGt,content_3652_1968:()=>QGt,content_3652_1970:()=>KGt,content_3652_1972:()=>nOt,content_3652_1974:()=>pOt,content_3652_1976:()=>cOt,content_3652_1978:()=>lOt,content_3652_198:()=>E2,content_3652_1980:()=>dOt,content_3652_1982:()=>fOt,content_3652_1984:()=>DOt,content_3652_1986:()=>wOt,content_3652_1988:()=>gOt,content_3652_1990:()=>LOt,content_3652_1992:()=>NOt,content_3652_1994:()=>WOt,content_3652_1996:()=>POt,content_3652_1998:()=>GOt,content_3652_2:()=>kH,content_3652_20:()=>FH,content_3652_200:()=>F2,content_3652_2000:()=>BOt,content_3652_2002:()=>qOt,content_3652_2004:()=>QOt,content_3652_2006:()=>KOt,content_3652_2008:()=>nFt,content_3652_2010:()=>pFt,content_3652_2012:()=>cFt,content_3652_2014:()=>lFt,content_3652_2016:()=>dFt,content_3652_2018:()=>fFt,content_3652_202:()=>V2,content_3652_2020:()=>DFt,content_3652_2022:()=>wFt,content_3652_2024:()=>gFt,content_3652_2026:()=>LFt,content_3652_2028:()=>NFt,content_3652_2030:()=>WFt,content_3652_2032:()=>PFt,content_3652_2034:()=>GFt,content_3652_2036:()=>BFt,content_3652_2038:()=>qFt,content_3652_204:()=>Y2,content_3652_2040:()=>QFt,content_3652_2042:()=>KFt,content_3652_2044:()=>nBt,content_3652_2046:()=>pBt,content_3652_2048:()=>cBt,content_3652_2050:()=>lBt,content_3652_2052:()=>dBt,content_3652_2054:()=>fBt,content_3652_2056:()=>DBt,content_3652_2058:()=>wBt,content_3652_206:()=>$2,content_3652_2060:()=>gBt,content_3652_2062:()=>LBt,content_3652_2064:()=>NBt,content_3652_2066:()=>WBt,content_3652_2068:()=>PBt,content_3652_2070:()=>GBt,content_3652_2072:()=>BBt,content_3652_2074:()=>qBt,content_3652_2076:()=>QBt,content_3652_2078:()=>KBt,content_3652_208:()=>t6,content_3652_2080:()=>nUt,content_3652_2082:()=>pUt,content_3652_2084:()=>cUt,content_3652_2086:()=>lUt,content_3652_2088:()=>dUt,content_3652_2090:()=>fUt,content_3652_2092:()=>DUt,content_3652_2094:()=>wUt,content_3652_2096:()=>gUt,content_3652_2098:()=>LUt,content_3652_210:()=>o6,content_3652_2100:()=>NUt,content_3652_2102:()=>WUt,content_3652_2104:()=>PUt,content_3652_2106:()=>GUt,content_3652_2108:()=>BUt,content_3652_2110:()=>qUt,content_3652_2112:()=>QUt,content_3652_2114:()=>KUt,content_3652_2116:()=>nVt,content_3652_2118:()=>pVt,content_3652_212:()=>s6,content_3652_2120:()=>cVt,content_3652_2122:()=>lVt,content_3652_2124:()=>dVt,content_3652_2126:()=>fVt,content_3652_2128:()=>DVt,content_3652_2130:()=>wVt,content_3652_2132:()=>gVt,content_3652_2134:()=>LVt,content_3652_2136:()=>NVt,content_3652_2138:()=>WVt,content_3652_214:()=>a6,content_3652_2140:()=>PVt,content_3652_2142:()=>GVt,content_3652_2144:()=>BVt,content_3652_2146:()=>qVt,content_3652_2148:()=>QVt,content_3652_2150:()=>KVt,content_3652_2152:()=>nqt,content_3652_2154:()=>pqt,content_3652_2156:()=>cqt,content_3652_2158:()=>lqt,content_3652_216:()=>m6,content_3652_2160:()=>dqt,content_3652_2162:()=>fqt,content_3652_2164:()=>Dqt,content_3652_2166:()=>wqt,content_3652_2168:()=>gqt,content_3652_2170:()=>Lqt,content_3652_2172:()=>Nqt,content_3652_2174:()=>Wqt,content_3652_2176:()=>Pqt,content_3652_2178:()=>Gqt,content_3652_218:()=>k6,content_3652_2180:()=>Bqt,content_3652_2182:()=>qqt,content_3652_2184:()=>Qqt,content_3652_2186:()=>Kqt,content_3652_2188:()=>njt,content_3652_2190:()=>pjt,content_3652_2192:()=>cjt,content_3652_2194:()=>ljt,content_3652_2196:()=>djt,content_3652_2198:()=>fjt,content_3652_22:()=>VH,content_3652_220:()=>M6,content_3652_2200:()=>Djt,content_3652_2202:()=>wjt,content_3652_2204:()=>gjt,content_3652_2206:()=>Ljt,content_3652_2208:()=>Njt,content_3652_2210:()=>Wjt,content_3652_2212:()=>Pjt,content_3652_2214:()=>Gjt,content_3652_2216:()=>Bjt,content_3652_2218:()=>qjt,content_3652_222:()=>_6,content_3652_2220:()=>Qjt,content_3652_2222:()=>Kjt,content_3652_2224:()=>nYt,content_3652_2226:()=>pYt,content_3652_2228:()=>cYt,content_3652_2230:()=>lYt,content_3652_2232:()=>dYt,content_3652_2234:()=>fYt,content_3652_2236:()=>DYt,content_3652_2238:()=>wYt,content_3652_224:()=>C6,content_3652_2240:()=>gYt,content_3652_2242:()=>LYt,content_3652_2244:()=>NYt,content_3652_2246:()=>WYt,content_3652_2248:()=>PYt,content_3652_2250:()=>GYt,content_3652_2252:()=>BYt,content_3652_2254:()=>qYt,content_3652_2256:()=>QYt,content_3652_2258:()=>KYt,content_3652_226:()=>v6,content_3652_2260:()=>nQt,content_3652_2262:()=>pQt,content_3652_2264:()=>cQt,content_3652_2266:()=>lQt,content_3652_2268:()=>dQt,content_3652_2270:()=>fQt,content_3652_2272:()=>DQt,content_3652_2274:()=>wQt,content_3652_2276:()=>gQt,content_3652_2278:()=>LQt,content_3652_228:()=>b6,content_3652_2280:()=>NQt,content_3652_2282:()=>WQt,content_3652_2284:()=>PQt,content_3652_2286:()=>GQt,content_3652_2288:()=>BQt,content_3652_2290:()=>qQt,content_3652_2292:()=>QQt,content_3652_2294:()=>KQt,content_3652_2296:()=>nHt,content_3652_2298:()=>pHt,content_3652_230:()=>z6,content_3652_2300:()=>cHt,content_3652_2302:()=>lHt,content_3652_2304:()=>dHt,content_3652_2306:()=>fHt,content_3652_2308:()=>DHt,content_3652_2310:()=>wHt,content_3652_2312:()=>gHt,content_3652_2314:()=>LHt,content_3652_2316:()=>NHt,content_3652_2318:()=>WHt,content_3652_232:()=>R6,content_3652_2320:()=>PHt,content_3652_2322:()=>GHt,content_3652_2324:()=>BHt,content_3652_2326:()=>qHt,content_3652_2328:()=>QHt,content_3652_2330:()=>KHt,content_3652_2332:()=>n$t,content_3652_2334:()=>p$t,content_3652_2336:()=>c$t,content_3652_2338:()=>l$t,content_3652_234:()=>E6,content_3652_2340:()=>d$t,content_3652_2342:()=>f$t,content_3652_2344:()=>D$t,content_3652_2346:()=>w$t,content_3652_2348:()=>g$t,content_3652_2350:()=>L$t,content_3652_2352:()=>N$t,content_3652_2354:()=>W$t,content_3652_2356:()=>P$t,content_3652_2358:()=>G$t,content_3652_236:()=>F6,content_3652_2360:()=>B$t,content_3652_2362:()=>q$t,content_3652_2364:()=>Q$t,content_3652_2366:()=>K$t,content_3652_2368:()=>nKt,content_3652_2370:()=>pKt,content_3652_2372:()=>cKt,content_3652_2374:()=>lKt,content_3652_2376:()=>dKt,content_3652_2378:()=>fKt,content_3652_238:()=>V6,content_3652_2380:()=>DKt,content_3652_2382:()=>wKt,content_3652_2384:()=>gKt,content_3652_2386:()=>LKt,content_3652_2388:()=>NKt,content_3652_2390:()=>WKt,content_3652_2392:()=>PKt,content_3652_2394:()=>GKt,content_3652_2396:()=>BKt,content_3652_2398:()=>qKt,content_3652_24:()=>YH,content_3652_240:()=>Y6,content_3652_2400:()=>QKt,content_3652_2402:()=>KKt,content_3652_2404:()=>nJt,content_3652_2406:()=>pJt,content_3652_2408:()=>cJt,content_3652_2410:()=>lJt,content_3652_2412:()=>dJt,content_3652_2414:()=>fJt,content_3652_2416:()=>DJt,content_3652_2418:()=>wJt,content_3652_242:()=>$6,content_3652_2420:()=>gJt,content_3652_2422:()=>LJt,content_3652_2424:()=>NJt,content_3652_2426:()=>WJt,content_3652_2428:()=>PJt,content_3652_2430:()=>GJt,content_3652_2432:()=>BJt,content_3652_2434:()=>qJt,content_3652_2436:()=>QJt,content_3652_2438:()=>KJt,content_3652_244:()=>t3,content_3652_2440:()=>n0t,content_3652_2442:()=>p0t,content_3652_2444:()=>c0t,content_3652_2446:()=>l0t,content_3652_2448:()=>d0t,content_3652_2450:()=>f0t,content_3652_2452:()=>D0t,content_3652_2454:()=>w0t,content_3652_2456:()=>g0t,content_3652_2458:()=>L0t,content_3652_246:()=>o3,content_3652_2460:()=>N0t,content_3652_2462:()=>W0t,content_3652_2464:()=>P0t,content_3652_2466:()=>G0t,content_3652_2468:()=>B0t,content_3652_2470:()=>q0t,content_3652_2472:()=>Q0t,content_3652_2474:()=>K0t,content_3652_2476:()=>n2t,content_3652_2478:()=>p2t,content_3652_248:()=>s3,content_3652_2480:()=>c2t,content_3652_2482:()=>l2t,content_3652_2484:()=>d2t,content_3652_2486:()=>f2t,content_3652_2488:()=>D2t,content_3652_2490:()=>w2t,content_3652_2492:()=>g2t,content_3652_2494:()=>L2t,content_3652_2496:()=>N2t,content_3652_2498:()=>W2t,content_3652_250:()=>a3,content_3652_2500:()=>P2t,content_3652_2502:()=>G2t,content_3652_2504:()=>B2t,content_3652_2506:()=>q2t,content_3652_2508:()=>Q2t,content_3652_2510:()=>K2t,content_3652_2512:()=>n6t,content_3652_2514:()=>p6t,content_3652_2516:()=>c6t,content_3652_2518:()=>l6t,content_3652_252:()=>m3,content_3652_2520:()=>d6t,content_3652_2522:()=>f6t,content_3652_2524:()=>D6t,content_3652_2526:()=>w6t,content_3652_2528:()=>g6t,content_3652_2530:()=>L6t,content_3652_2532:()=>N6t,content_3652_2534:()=>W6t,content_3652_2536:()=>P6t,content_3652_2538:()=>G6t,content_3652_254:()=>k3,content_3652_2540:()=>B6t,content_3652_2542:()=>q6t,content_3652_2544:()=>Q6t,content_3652_2546:()=>K6t,content_3652_2548:()=>n3t,content_3652_2550:()=>p3t,content_3652_2552:()=>c3t,content_3652_2554:()=>l3t,content_3652_2556:()=>d3t,content_3652_2558:()=>f3t,content_3652_256:()=>M3,content_3652_2560:()=>D3t,content_3652_2562:()=>w3t,content_3652_2564:()=>g3t,content_3652_2566:()=>L3t,content_3652_2568:()=>N3t,content_3652_2570:()=>W3t,content_3652_2572:()=>P3t,content_3652_2574:()=>G3t,content_3652_2576:()=>B3t,content_3652_2578:()=>q3t,content_3652_258:()=>_3,content_3652_2580:()=>Q3t,content_3652_2582:()=>K3t,content_3652_2584:()=>n5t,content_3652_2586:()=>p5t,content_3652_2588:()=>c5t,content_3652_2590:()=>l5t,content_3652_2592:()=>d5t,content_3652_2594:()=>f5t,content_3652_2596:()=>D5t,content_3652_2598:()=>w5t,content_3652_26:()=>$H,content_3652_260:()=>C3,content_3652_2600:()=>g5t,content_3652_2602:()=>L5t,content_3652_2604:()=>N5t,content_3652_2606:()=>W5t,content_3652_2608:()=>P5t,content_3652_2610:()=>G5t,content_3652_2612:()=>B5t,content_3652_2614:()=>q5t,content_3652_2616:()=>Q5t,content_3652_2618:()=>K5t,content_3652_262:()=>v3,content_3652_2620:()=>n1t,content_3652_2622:()=>p1t,content_3652_2624:()=>c1t,content_3652_2626:()=>l1t,content_3652_2628:()=>d1t,content_3652_2630:()=>f1t,content_3652_2632:()=>D1t,content_3652_2634:()=>w1t,content_3652_2636:()=>g1t,content_3652_2638:()=>L1t,content_3652_264:()=>b3,content_3652_2640:()=>N1t,content_3652_2642:()=>W1t,content_3652_2644:()=>P1t,content_3652_2646:()=>G1t,content_3652_2648:()=>B1t,content_3652_2650:()=>q1t,content_3652_2652:()=>Q1t,content_3652_2654:()=>K1t,content_3652_2656:()=>n4t,content_3652_2658:()=>p4t,content_3652_266:()=>z3,content_3652_2660:()=>c4t,content_3652_2662:()=>l4t,content_3652_2664:()=>d4t,content_3652_2666:()=>f4t,content_3652_2668:()=>D4t,content_3652_2670:()=>w4t,content_3652_2672:()=>g4t,content_3652_2674:()=>L4t,content_3652_2676:()=>N4t,content_3652_2678:()=>W4t,content_3652_268:()=>R3,content_3652_2680:()=>P4t,content_3652_2682:()=>G4t,content_3652_2684:()=>B4t,content_3652_2686:()=>q4t,content_3652_2688:()=>Q4t,content_3652_2690:()=>K4t,content_3652_2692:()=>n8t,content_3652_2694:()=>p8t,content_3652_2696:()=>c8t,content_3652_2698:()=>l8t,content_3652_270:()=>E3,content_3652_2700:()=>d8t,content_3652_2702:()=>f8t,content_3652_2704:()=>D8t,content_3652_2706:()=>w8t,content_3652_2708:()=>g8t,content_3652_2710:()=>L8t,content_3652_2712:()=>N8t,content_3652_2714:()=>W8t,content_3652_2716:()=>P8t,content_3652_2718:()=>G8t,content_3652_272:()=>F3,content_3652_2720:()=>B8t,content_3652_2722:()=>q8t,content_3652_2724:()=>Q8t,content_3652_2726:()=>K8t,content_3652_2728:()=>n7t,content_3652_2730:()=>p7t,content_3652_2732:()=>c7t,content_3652_2734:()=>l7t,content_3652_2736:()=>d7t,content_3652_2738:()=>f7t,content_3652_274:()=>V3,content_3652_2740:()=>D7t,content_3652_2742:()=>w7t,content_3652_2744:()=>g7t,content_3652_2746:()=>L7t,content_3652_2748:()=>N7t,content_3652_2750:()=>W7t,content_3652_2752:()=>P7t,content_3652_2754:()=>G7t,content_3652_2756:()=>B7t,content_3652_2758:()=>q7t,content_3652_276:()=>Y3,content_3652_2760:()=>Q7t,content_3652_2762:()=>K7t,content_3652_2764:()=>n9t,content_3652_2766:()=>p9t,content_3652_2768:()=>c9t,content_3652_2770:()=>l9t,content_3652_2772:()=>d9t,content_3652_2774:()=>f9t,content_3652_2776:()=>D9t,content_3652_2778:()=>w9t,content_3652_278:()=>$3,content_3652_2780:()=>g9t,content_3652_2782:()=>L9t,content_3652_2784:()=>N9t,content_3652_2786:()=>W9t,content_3652_2788:()=>P9t,content_3652_2790:()=>G9t,content_3652_2792:()=>B9t,content_3652_2794:()=>q9t,content_3652_2796:()=>Q9t,content_3652_2798:()=>K9t,content_3652_28:()=>t$,content_3652_280:()=>t5,content_3652_2800:()=>ntn,content_3652_2802:()=>ptn,content_3652_2804:()=>ctn,content_3652_2806:()=>ltn,content_3652_2808:()=>dtn,content_3652_2810:()=>ftn,content_3652_2812:()=>Dtn,content_3652_2814:()=>wtn,content_3652_2816:()=>gtn,content_3652_2818:()=>Ltn,content_3652_282:()=>o5,content_3652_2820:()=>Ntn,content_3652_2822:()=>Wtn,content_3652_2824:()=>Ptn,content_3652_2826:()=>Gtn,content_3652_2828:()=>Btn,content_3652_2830:()=>qtn,content_3652_2832:()=>Qtn,content_3652_2834:()=>Ktn,content_3652_2836:()=>nnn,content_3652_2838:()=>pnn,content_3652_284:()=>s5,content_3652_2840:()=>cnn,content_3652_2842:()=>lnn,content_3652_2844:()=>dnn,content_3652_2846:()=>fnn,content_3652_2848:()=>Dnn,content_3652_2850:()=>wnn,content_3652_2852:()=>gnn,content_3652_2854:()=>Lnn,content_3652_2856:()=>Nnn,content_3652_2858:()=>Wnn,content_3652_286:()=>a5,content_3652_2860:()=>Pnn,content_3652_2862:()=>Gnn,content_3652_2864:()=>Bnn,content_3652_2866:()=>qnn,content_3652_2868:()=>Qnn,content_3652_2870:()=>Knn,content_3652_2872:()=>nen,content_3652_2874:()=>pen,content_3652_2876:()=>cen,content_3652_2878:()=>len,content_3652_288:()=>m5,content_3652_2880:()=>den,content_3652_2882:()=>fen,content_3652_2884:()=>Den,content_3652_2886:()=>wen,content_3652_2888:()=>gen,content_3652_2890:()=>Len,content_3652_2892:()=>Nen,content_3652_2894:()=>Wen,content_3652_2896:()=>Pen,content_3652_2898:()=>Gen,content_3652_290:()=>k5,content_3652_2900:()=>Ben,content_3652_2902:()=>qen,content_3652_2904:()=>Qen,content_3652_2906:()=>Ken,content_3652_2908:()=>non,content_3652_2910:()=>pon,content_3652_2912:()=>con,content_3652_2914:()=>lon,content_3652_2916:()=>don,content_3652_2918:()=>fon,content_3652_292:()=>M5,content_3652_2920:()=>Don,content_3652_2922:()=>won,content_3652_2924:()=>gon,content_3652_2926:()=>Lon,content_3652_2928:()=>Non,content_3652_2930:()=>Won,content_3652_2932:()=>Pon,content_3652_2934:()=>Gon,content_3652_2936:()=>Bon,content_3652_2938:()=>qon,content_3652_294:()=>_5,content_3652_2940:()=>Qon,content_3652_2942:()=>Kon,content_3652_2944:()=>npn,content_3652_2946:()=>ppn,content_3652_2948:()=>cpn,content_3652_2950:()=>lpn,content_3652_2952:()=>dpn,content_3652_2954:()=>fpn,content_3652_2956:()=>Dpn,content_3652_2958:()=>wpn,content_3652_296:()=>C5,content_3652_2960:()=>gpn,content_3652_2962:()=>Lpn,content_3652_2964:()=>Npn,content_3652_2966:()=>Wpn,content_3652_2968:()=>Ppn,content_3652_2970:()=>Gpn,content_3652_2972:()=>Bpn,content_3652_2974:()=>qpn,content_3652_2976:()=>Qpn,content_3652_2978:()=>Kpn,content_3652_298:()=>v5,content_3652_2980:()=>nrn,content_3652_2982:()=>prn,content_3652_2984:()=>crn,content_3652_2986:()=>lrn,content_3652_2988:()=>drn,content_3652_2990:()=>frn,content_3652_2992:()=>Drn,content_3652_2994:()=>wrn,content_3652_2996:()=>grn,content_3652_2998:()=>Lrn,content_3652_30:()=>o$,content_3652_300:()=>b5,content_3652_3000:()=>Nrn,content_3652_3002:()=>Wrn,content_3652_3004:()=>Prn,content_3652_3006:()=>Grn,content_3652_3008:()=>Brn,content_3652_3010:()=>qrn,content_3652_3012:()=>Qrn,content_3652_3014:()=>Krn,content_3652_3016:()=>nsn,content_3652_3018:()=>psn,content_3652_302:()=>z5,content_3652_3020:()=>csn,content_3652_3022:()=>lsn,content_3652_3024:()=>dsn,content_3652_3026:()=>fsn,content_3652_3028:()=>Dsn,content_3652_3030:()=>wsn,content_3652_3032:()=>gsn,content_3652_3034:()=>Lsn,content_3652_3036:()=>Nsn,content_3652_3038:()=>Wsn,content_3652_304:()=>R5,content_3652_3040:()=>Psn,content_3652_3042:()=>Gsn,content_3652_3044:()=>Bsn,content_3652_3046:()=>qsn,content_3652_3048:()=>Qsn,content_3652_3050:()=>Ksn,content_3652_3052:()=>ncn,content_3652_3054:()=>pcn,content_3652_3056:()=>ccn,content_3652_3058:()=>lcn,content_3652_306:()=>E5,content_3652_3060:()=>dcn,content_3652_3062:()=>fcn,content_3652_3064:()=>Dcn,content_3652_3066:()=>wcn,content_3652_3068:()=>gcn,content_3652_3070:()=>Lcn,content_3652_3072:()=>Ncn,content_3652_3074:()=>Wcn,content_3652_3076:()=>Pcn,content_3652_3078:()=>Gcn,content_3652_308:()=>F5,content_3652_3080:()=>Bcn,content_3652_3082:()=>qcn,content_3652_3084:()=>Qcn,content_3652_3086:()=>Kcn,content_3652_3088:()=>nin,content_3652_3090:()=>pin,content_3652_3092:()=>cin,content_3652_3094:()=>lin,content_3652_3096:()=>din,content_3652_3098:()=>fin,content_3652_310:()=>V5,content_3652_3100:()=>Din,content_3652_3102:()=>win,content_3652_3104:()=>gin,content_3652_3106:()=>Lin,content_3652_3108:()=>Nin,content_3652_3110:()=>Win,content_3652_3112:()=>Pin,content_3652_3114:()=>Gin,content_3652_3116:()=>Bin,content_3652_3118:()=>qin,content_3652_312:()=>Y5,content_3652_3120:()=>Qin,content_3652_3122:()=>Kin,content_3652_3124:()=>nan,content_3652_3126:()=>pan,content_3652_3128:()=>can,content_3652_3130:()=>lan,content_3652_3132:()=>dan,content_3652_3134:()=>fan,content_3652_3136:()=>Dan,content_3652_3138:()=>wan,content_3652_314:()=>$5,content_3652_3140:()=>gan,content_3652_3142:()=>Lan,content_3652_3144:()=>Nan,content_3652_3146:()=>Wan,content_3652_3148:()=>Pan,content_3652_3150:()=>Gan,content_3652_3152:()=>Ban,content_3652_3154:()=>qan,content_3652_3156:()=>Qan,content_3652_3158:()=>Kan,content_3652_316:()=>t1,content_3652_3160:()=>nln,content_3652_3162:()=>pln,content_3652_3164:()=>cln,content_3652_3166:()=>lln,content_3652_3168:()=>dln,content_3652_3170:()=>fln,content_3652_3172:()=>Dln,content_3652_3174:()=>wln,content_3652_3176:()=>gln,content_3652_3178:()=>Lln,content_3652_318:()=>o1,content_3652_3180:()=>Nln,content_3652_3182:()=>Wln,content_3652_3184:()=>Pln,content_3652_3186:()=>Gln,content_3652_3188:()=>Bln,content_3652_3190:()=>qln,content_3652_3192:()=>Qln,content_3652_3194:()=>Kln,content_3652_3196:()=>nun,content_3652_3198:()=>pun,content_3652_32:()=>s$,content_3652_320:()=>s1,content_3652_3200:()=>cun,content_3652_3202:()=>lun,content_3652_3204:()=>dun,content_3652_3206:()=>fun,content_3652_3208:()=>Dun,content_3652_3210:()=>wun,content_3652_3212:()=>gun,content_3652_3214:()=>Lun,content_3652_3216:()=>Nun,content_3652_3218:()=>Wun,content_3652_322:()=>a1,content_3652_3220:()=>Pun,content_3652_3222:()=>Gun,content_3652_3224:()=>Bun,content_3652_3226:()=>qun,content_3652_3228:()=>Qun,content_3652_3230:()=>Kun,content_3652_3232:()=>nmn,content_3652_3234:()=>pmn,content_3652_3236:()=>cmn,content_3652_3238:()=>lmn,content_3652_324:()=>m1,content_3652_3240:()=>dmn,content_3652_3242:()=>fmn,content_3652_3244:()=>Dmn,content_3652_3246:()=>wmn,content_3652_3248:()=>gmn,content_3652_3250:()=>Lmn,content_3652_3252:()=>Nmn,content_3652_3254:()=>Wmn,content_3652_3256:()=>Pmn,content_3652_3258:()=>Gmn,content_3652_326:()=>k1,content_3652_3260:()=>Bmn,content_3652_3262:()=>qmn,content_3652_3264:()=>Qmn,content_3652_3266:()=>Kmn,content_3652_3268:()=>ndn,content_3652_3270:()=>pdn,content_3652_3272:()=>cdn,content_3652_3274:()=>ldn,content_3652_3276:()=>ddn,content_3652_3278:()=>fdn,content_3652_328:()=>M1,content_3652_3280:()=>Ddn,content_3652_3282:()=>wdn,content_3652_3284:()=>gdn,content_3652_3286:()=>Ldn,content_3652_3288:()=>Ndn,content_3652_3290:()=>Wdn,content_3652_3292:()=>Pdn,content_3652_3294:()=>Gdn,content_3652_3296:()=>Bdn,content_3652_3298:()=>qdn,content_3652_330:()=>_1,content_3652_3300:()=>Qdn,content_3652_3302:()=>Kdn,content_3652_3304:()=>nhn,content_3652_3306:()=>phn,content_3652_3308:()=>chn,content_3652_3310:()=>lhn,content_3652_3312:()=>dhn,content_3652_3314:()=>fhn,content_3652_3316:()=>Dhn,content_3652_3318:()=>whn,content_3652_332:()=>C1,content_3652_3320:()=>ghn,content_3652_3322:()=>Lhn,content_3652_3324:()=>Nhn,content_3652_3326:()=>Whn,content_3652_3328:()=>Phn,content_3652_3330:()=>Ghn,content_3652_3332:()=>Bhn,content_3652_3334:()=>qhn,content_3652_3336:()=>Qhn,content_3652_3338:()=>Khn,content_3652_334:()=>v1,content_3652_3340:()=>nkn,content_3652_3342:()=>pkn,content_3652_3344:()=>ckn,content_3652_3346:()=>lkn,content_3652_3348:()=>dkn,content_3652_3350:()=>fkn,content_3652_3352:()=>Dkn,content_3652_3354:()=>wkn,content_3652_3356:()=>gkn,content_3652_3358:()=>Lkn,content_3652_336:()=>b1,content_3652_3360:()=>Nkn,content_3652_3362:()=>Wkn,content_3652_3364:()=>Pkn,content_3652_3366:()=>Gkn,content_3652_3368:()=>Bkn,content_3652_3370:()=>qkn,content_3652_3372:()=>Qkn,content_3652_3374:()=>Kkn,content_3652_3376:()=>nfn,content_3652_3378:()=>pfn,content_3652_338:()=>z1,content_3652_3380:()=>cfn,content_3652_3382:()=>lfn,content_3652_3384:()=>dfn,content_3652_3386:()=>ffn,content_3652_3388:()=>Dfn,content_3652_3390:()=>wfn,content_3652_3392:()=>gfn,content_3652_3394:()=>Lfn,content_3652_3396:()=>Nfn,content_3652_3398:()=>Wfn,content_3652_34:()=>a$,content_3652_340:()=>R1,content_3652_3400:()=>Pfn,content_3652_3402:()=>Gfn,content_3652_3404:()=>Bfn,content_3652_3406:()=>qfn,content_3652_3408:()=>Qfn,content_3652_3410:()=>Kfn,content_3652_3412:()=>nyn,content_3652_3414:()=>pyn,content_3652_3416:()=>cyn,content_3652_3418:()=>lyn,content_3652_342:()=>E1,content_3652_3420:()=>dyn,content_3652_3422:()=>fyn,content_3652_3424:()=>Dyn,content_3652_3426:()=>wyn,content_3652_3428:()=>gyn,content_3652_3430:()=>Lyn,content_3652_3432:()=>Nyn,content_3652_3434:()=>Wyn,content_3652_3436:()=>Pyn,content_3652_3438:()=>Gyn,content_3652_344:()=>F1,content_3652_3440:()=>Byn,content_3652_3442:()=>qyn,content_3652_3444:()=>Qyn,content_3652_3446:()=>Kyn,content_3652_3448:()=>nMn,content_3652_3450:()=>pMn,content_3652_3452:()=>cMn,content_3652_3454:()=>lMn,content_3652_3456:()=>dMn,content_3652_3458:()=>fMn,content_3652_346:()=>V1,content_3652_3460:()=>DMn,content_3652_3462:()=>wMn,content_3652_3464:()=>gMn,content_3652_3466:()=>LMn,content_3652_3468:()=>NMn,content_3652_3470:()=>WMn,content_3652_3472:()=>PMn,content_3652_3474:()=>GMn,content_3652_3476:()=>BMn,content_3652_3478:()=>qMn,content_3652_348:()=>Y1,content_3652_3480:()=>QMn,content_3652_3482:()=>KMn,content_3652_3484:()=>nDn,content_3652_3486:()=>pDn,content_3652_3488:()=>cDn,content_3652_3490:()=>lDn,content_3652_3492:()=>dDn,content_3652_3494:()=>fDn,content_3652_3496:()=>DDn,content_3652_3498:()=>wDn,content_3652_350:()=>$1,content_3652_3500:()=>gDn,content_3652_3502:()=>LDn,content_3652_3504:()=>NDn,content_3652_3506:()=>WDn,content_3652_3508:()=>PDn,content_3652_3510:()=>GDn,content_3652_3512:()=>BDn,content_3652_3514:()=>qDn,content_3652_3516:()=>QDn,content_3652_3518:()=>KDn,content_3652_352:()=>t4,content_3652_3520:()=>nXn,content_3652_3522:()=>pXn,content_3652_3524:()=>cXn,content_3652_3526:()=>lXn,content_3652_3528:()=>dXn,content_3652_3530:()=>fXn,content_3652_3532:()=>DXn,content_3652_3534:()=>wXn,content_3652_3536:()=>gXn,content_3652_3538:()=>LXn,content_3652_354:()=>o4,content_3652_3540:()=>NXn,content_3652_3542:()=>WXn,content_3652_3544:()=>PXn,content_3652_3546:()=>GXn,content_3652_3548:()=>BXn,content_3652_3550:()=>qXn,content_3652_3552:()=>QXn,content_3652_3554:()=>KXn,content_3652_3556:()=>n_n,content_3652_3558:()=>p_n,content_3652_356:()=>s4,content_3652_3560:()=>c_n,content_3652_3562:()=>l_n,content_3652_3564:()=>d_n,content_3652_3566:()=>f_n,content_3652_3568:()=>D_n,content_3652_3570:()=>w_n,content_3652_3572:()=>g_n,content_3652_3574:()=>L_n,content_3652_3576:()=>N_n,content_3652_3578:()=>W_n,content_3652_358:()=>a4,content_3652_3580:()=>P_n,content_3652_3582:()=>G_n,content_3652_3584:()=>B_n,content_3652_3586:()=>q_n,content_3652_3588:()=>Q_n,content_3652_3590:()=>K_n,content_3652_3592:()=>nwn,content_3652_3594:()=>pwn,content_3652_3596:()=>cwn,content_3652_3598:()=>lwn,content_3652_36:()=>m$,content_3652_360:()=>m4,content_3652_3600:()=>dwn,content_3652_3602:()=>fwn,content_3652_3604:()=>Dwn,content_3652_3606:()=>wwn,content_3652_3608:()=>gwn,content_3652_3610:()=>Lwn,content_3652_3612:()=>Nwn,content_3652_3614:()=>Wwn,content_3652_3616:()=>Pwn,content_3652_3618:()=>Gwn,content_3652_362:()=>k4,content_3652_3620:()=>Bwn,content_3652_3622:()=>qwn,content_3652_3624:()=>Qwn,content_3652_3626:()=>Kwn,content_3652_3628:()=>nTn,content_3652_3630:()=>pTn,content_3652_3632:()=>cTn,content_3652_3634:()=>lTn,content_3652_3636:()=>dTn,content_3652_3638:()=>fTn,content_3652_364:()=>M4,content_3652_3640:()=>DTn,content_3652_3642:()=>wTn,content_3652_3644:()=>gTn,content_3652_3646:()=>LTn,content_3652_3648:()=>NTn,content_3652_3650:()=>WTn,content_3652_3652:()=>PTn,content_3652_3654:()=>GTn,content_3652_3656:()=>BTn,content_3652_3658:()=>qTn,content_3652_366:()=>_4,content_3652_3660:()=>QTn,content_3652_3662:()=>KTn,content_3652_3664:()=>nCn,content_3652_3666:()=>pCn,content_3652_3668:()=>cCn,content_3652_3670:()=>lCn,content_3652_3672:()=>dCn,content_3652_3674:()=>fCn,content_3652_3676:()=>DCn,content_3652_3678:()=>wCn,content_3652_368:()=>C4,content_3652_3680:()=>gCn,content_3652_3682:()=>LCn,content_3652_3684:()=>NCn,content_3652_3686:()=>WCn,content_3652_3688:()=>PCn,content_3652_3690:()=>GCn,content_3652_3692:()=>BCn,content_3652_3694:()=>qCn,content_3652_3696:()=>QCn,content_3652_3698:()=>KCn,content_3652_370:()=>v4,content_3652_3700:()=>ngn,content_3652_3702:()=>pgn,content_3652_3704:()=>cgn,content_3652_3706:()=>lgn,content_3652_3708:()=>dgn,content_3652_3710:()=>fgn,content_3652_3712:()=>Dgn,content_3652_3714:()=>wgn,content_3652_3716:()=>ggn,content_3652_3718:()=>Lgn,content_3652_372:()=>b4,content_3652_3720:()=>Ngn,content_3652_3722:()=>Wgn,content_3652_3724:()=>Pgn,content_3652_3726:()=>Ggn,content_3652_3728:()=>Bgn,content_3652_3730:()=>qgn,content_3652_3732:()=>Qgn,content_3652_3734:()=>Kgn,content_3652_3736:()=>nxn,content_3652_3738:()=>pxn,content_3652_374:()=>z4,content_3652_3740:()=>cxn,content_3652_3742:()=>lxn,content_3652_3744:()=>dxn,content_3652_3746:()=>fxn,content_3652_3748:()=>Dxn,content_3652_3750:()=>wxn,content_3652_3752:()=>gxn,content_3652_3754:()=>Lxn,content_3652_3756:()=>Nxn,content_3652_3758:()=>Wxn,content_3652_376:()=>R4,content_3652_3760:()=>Pxn,content_3652_3762:()=>Gxn,content_3652_3764:()=>Bxn,content_3652_3766:()=>qxn,content_3652_3768:()=>Qxn,content_3652_3770:()=>Kxn,content_3652_3772:()=>nvn,content_3652_3774:()=>pvn,content_3652_3776:()=>cvn,content_3652_3778:()=>lvn,content_3652_378:()=>E4,content_3652_3780:()=>dvn,content_3652_3782:()=>fvn,content_3652_3784:()=>Dvn,content_3652_3786:()=>wvn,content_3652_3788:()=>gvn,content_3652_3790:()=>Lvn,content_3652_3792:()=>Nvn,content_3652_3794:()=>Wvn,content_3652_3796:()=>Pvn,content_3652_3798:()=>Gvn,content_3652_38:()=>k$,content_3652_380:()=>F4,content_3652_3800:()=>Bvn,content_3652_3802:()=>qvn,content_3652_3804:()=>Qvn,content_3652_3806:()=>Kvn,content_3652_3808:()=>nLn,content_3652_3810:()=>pLn,content_3652_3812:()=>cLn,content_3652_3814:()=>lLn,content_3652_3816:()=>dLn,content_3652_3818:()=>fLn,content_3652_382:()=>V4,content_3652_3820:()=>DLn,content_3652_3822:()=>wLn,content_3652_3824:()=>gLn,content_3652_3826:()=>LLn,content_3652_3828:()=>NLn,content_3652_3830:()=>WLn,content_3652_3832:()=>PLn,content_3652_3834:()=>GLn,content_3652_3836:()=>BLn,content_3652_3838:()=>qLn,content_3652_384:()=>Y4,content_3652_3840:()=>QLn,content_3652_3842:()=>KLn,content_3652_3844:()=>nZn,content_3652_3846:()=>pZn,content_3652_3848:()=>cZn,content_3652_3850:()=>lZn,content_3652_3852:()=>dZn,content_3652_3854:()=>fZn,content_3652_3856:()=>DZn,content_3652_3858:()=>wZn,content_3652_386:()=>$4,content_3652_3860:()=>gZn,content_3652_3862:()=>LZn,content_3652_3864:()=>NZn,content_3652_3866:()=>WZn,content_3652_3868:()=>PZn,content_3652_3870:()=>GZn,content_3652_3872:()=>BZn,content_3652_3874:()=>qZn,content_3652_3876:()=>QZn,content_3652_3878:()=>KZn,content_3652_388:()=>t8,content_3652_3880:()=>nbn,content_3652_3882:()=>pbn,content_3652_3884:()=>cbn,content_3652_3886:()=>lbn,content_3652_3888:()=>dbn,content_3652_3890:()=>fbn,content_3652_3892:()=>Dbn,content_3652_3894:()=>wbn,content_3652_3896:()=>gbn,content_3652_3898:()=>Lbn,content_3652_390:()=>o8,content_3652_3900:()=>Nbn,content_3652_3902:()=>Wbn,content_3652_3904:()=>Pbn,content_3652_3906:()=>Gbn,content_3652_3908:()=>Bbn,content_3652_3910:()=>qbn,content_3652_3912:()=>Qbn,content_3652_3914:()=>Kbn,content_3652_3916:()=>nNn,content_3652_3918:()=>pNn,content_3652_392:()=>s8,content_3652_3920:()=>cNn,content_3652_3922:()=>lNn,content_3652_3924:()=>dNn,content_3652_3926:()=>fNn,content_3652_3928:()=>DNn,content_3652_3930:()=>wNn,content_3652_3932:()=>gNn,content_3652_3934:()=>LNn,content_3652_3936:()=>NNn,content_3652_3938:()=>WNn,content_3652_394:()=>a8,content_3652_3940:()=>PNn,content_3652_3942:()=>GNn,content_3652_3944:()=>BNn,content_3652_3946:()=>qNn,content_3652_3948:()=>QNn,content_3652_3950:()=>KNn,content_3652_3952:()=>nAn,content_3652_3954:()=>pAn,content_3652_3956:()=>cAn,content_3652_3958:()=>lAn,content_3652_396:()=>m8,content_3652_3960:()=>dAn,content_3652_3962:()=>fAn,content_3652_3964:()=>DAn,content_3652_3966:()=>wAn,content_3652_3968:()=>gAn,content_3652_3970:()=>LAn,content_3652_3972:()=>NAn,content_3652_3974:()=>WAn,content_3652_3976:()=>PAn,content_3652_3978:()=>GAn,content_3652_398:()=>k8,content_3652_3980:()=>BAn,content_3652_3982:()=>qAn,content_3652_3984:()=>QAn,content_3652_3986:()=>KAn,content_3652_3988:()=>nzn,content_3652_3990:()=>pzn,content_3652_3992:()=>czn,content_3652_3994:()=>lzn,content_3652_3996:()=>dzn,content_3652_3998:()=>fzn,content_3652_4:()=>MH,content_3652_40:()=>M$,content_3652_400:()=>M8,content_3652_4000:()=>Dzn,content_3652_4002:()=>wzn,content_3652_4004:()=>gzn,content_3652_4006:()=>Lzn,content_3652_4008:()=>Nzn,content_3652_4010:()=>Wzn,content_3652_4012:()=>Pzn,content_3652_4014:()=>Gzn,content_3652_4016:()=>Bzn,content_3652_4018:()=>qzn,content_3652_402:()=>_8,content_3652_4020:()=>Qzn,content_3652_4022:()=>Kzn,content_3652_4024:()=>nWn,content_3652_4026:()=>pWn,content_3652_4028:()=>cWn,content_3652_4030:()=>lWn,content_3652_4032:()=>dWn,content_3652_4034:()=>fWn,content_3652_4036:()=>DWn,content_3652_4038:()=>wWn,content_3652_404:()=>C8,content_3652_4040:()=>gWn,content_3652_4042:()=>LWn,content_3652_4044:()=>NWn,content_3652_4046:()=>WWn,content_3652_4048:()=>PWn,content_3652_4050:()=>GWn,content_3652_4052:()=>BWn,content_3652_4054:()=>qWn,content_3652_4056:()=>QWn,content_3652_4058:()=>KWn,content_3652_406:()=>v8,content_3652_4060:()=>nIn,content_3652_4062:()=>pIn,content_3652_4064:()=>cIn,content_3652_4066:()=>lIn,content_3652_4068:()=>dIn,content_3652_4070:()=>fIn,content_3652_4072:()=>DIn,content_3652_4074:()=>wIn,content_3652_4076:()=>gIn,content_3652_4078:()=>LIn,content_3652_408:()=>b8,content_3652_4080:()=>NIn,content_3652_4082:()=>WIn,content_3652_4084:()=>PIn,content_3652_4086:()=>GIn,content_3652_4088:()=>BIn,content_3652_4090:()=>qIn,content_3652_4092:()=>QIn,content_3652_4094:()=>KIn,content_3652_4096:()=>nRn,content_3652_4098:()=>pRn,content_3652_410:()=>z8,content_3652_4100:()=>cRn,content_3652_4102:()=>lRn,content_3652_4104:()=>dRn,content_3652_4106:()=>fRn,content_3652_4108:()=>DRn,content_3652_4110:()=>wRn,content_3652_4112:()=>gRn,content_3652_4114:()=>LRn,content_3652_4116:()=>NRn,content_3652_4118:()=>WRn,content_3652_412:()=>R8,content_3652_4120:()=>PRn,content_3652_4122:()=>GRn,content_3652_4124:()=>BRn,content_3652_4126:()=>qRn,content_3652_4128:()=>QRn,content_3652_4130:()=>KRn,content_3652_4132:()=>nPn,content_3652_4134:()=>pPn,content_3652_4136:()=>cPn,content_3652_4138:()=>lPn,content_3652_414:()=>E8,content_3652_4140:()=>dPn,content_3652_4142:()=>fPn,content_3652_4144:()=>DPn,content_3652_4146:()=>wPn,content_3652_4148:()=>gPn,content_3652_4150:()=>LPn,content_3652_4152:()=>NPn,content_3652_4154:()=>WPn,content_3652_4156:()=>PPn,content_3652_4158:()=>GPn,content_3652_416:()=>F8,content_3652_4160:()=>BPn,content_3652_4162:()=>qPn,content_3652_4164:()=>QPn,content_3652_4166:()=>KPn,content_3652_4168:()=>nSn,content_3652_4170:()=>pSn,content_3652_4172:()=>cSn,content_3652_4174:()=>lSn,content_3652_4176:()=>dSn,content_3652_4178:()=>fSn,content_3652_418:()=>V8,content_3652_4180:()=>DSn,content_3652_4182:()=>wSn,content_3652_4184:()=>gSn,content_3652_4186:()=>LSn,content_3652_4188:()=>NSn,content_3652_4190:()=>WSn,content_3652_4192:()=>PSn,content_3652_4194:()=>GSn,content_3652_4196:()=>BSn,content_3652_4198:()=>qSn,content_3652_42:()=>_$,content_3652_420:()=>Y8,content_3652_4200:()=>QSn,content_3652_4202:()=>KSn,content_3652_4204:()=>nEn,content_3652_4206:()=>pEn,content_3652_4208:()=>cEn,content_3652_4210:()=>lEn,content_3652_4212:()=>dEn,content_3652_4214:()=>fEn,content_3652_4216:()=>DEn,content_3652_4218:()=>wEn,content_3652_422:()=>$8,content_3652_4220:()=>gEn,content_3652_4222:()=>LEn,content_3652_4224:()=>NEn,content_3652_4226:()=>WEn,content_3652_4228:()=>PEn,content_3652_4230:()=>GEn,content_3652_4232:()=>BEn,content_3652_4234:()=>qEn,content_3652_4236:()=>QEn,content_3652_4238:()=>KEn,content_3652_424:()=>t7,content_3652_4240:()=>nGn,content_3652_4242:()=>pGn,content_3652_4244:()=>cGn,content_3652_4246:()=>lGn,content_3652_4248:()=>dGn,content_3652_4250:()=>fGn,content_3652_4252:()=>DGn,content_3652_4254:()=>wGn,content_3652_4256:()=>gGn,content_3652_4258:()=>LGn,content_3652_426:()=>o7,content_3652_4260:()=>NGn,content_3652_4262:()=>WGn,content_3652_4264:()=>PGn,content_3652_4266:()=>GGn,content_3652_4268:()=>BGn,content_3652_4270:()=>qGn,content_3652_4272:()=>QGn,content_3652_4274:()=>KGn,content_3652_4276:()=>nOn,content_3652_4278:()=>pOn,content_3652_428:()=>s7,content_3652_4280:()=>cOn,content_3652_4282:()=>lOn,content_3652_4284:()=>dOn,content_3652_4286:()=>fOn,content_3652_4288:()=>DOn,content_3652_4290:()=>wOn,content_3652_4292:()=>gOn,content_3652_4294:()=>LOn,content_3652_4296:()=>NOn,content_3652_4298:()=>WOn,content_3652_430:()=>a7,content_3652_4300:()=>POn,content_3652_4302:()=>GOn,content_3652_4304:()=>BOn,content_3652_4306:()=>qOn,content_3652_4308:()=>QOn,content_3652_4310:()=>KOn,content_3652_4312:()=>nFn,content_3652_4314:()=>pFn,content_3652_4316:()=>cFn,content_3652_4318:()=>lFn,content_3652_432:()=>m7,content_3652_4320:()=>dFn,content_3652_4322:()=>fFn,content_3652_4324:()=>DFn,content_3652_4326:()=>wFn,content_3652_4328:()=>gFn,content_3652_4330:()=>LFn,content_3652_4332:()=>NFn,content_3652_4334:()=>WFn,content_3652_4336:()=>PFn,content_3652_4338:()=>GFn,content_3652_434:()=>k7,content_3652_4340:()=>BFn,content_3652_4342:()=>qFn,content_3652_4344:()=>QFn,content_3652_4346:()=>KFn,content_3652_4348:()=>nBn,content_3652_4350:()=>pBn,content_3652_4352:()=>cBn,content_3652_4354:()=>lBn,content_3652_4356:()=>dBn,content_3652_4358:()=>fBn,content_3652_436:()=>M7,content_3652_4360:()=>DBn,content_3652_4362:()=>wBn,content_3652_4364:()=>gBn,content_3652_4366:()=>LBn,content_3652_4368:()=>NBn,content_3652_4370:()=>WBn,content_3652_4372:()=>PBn,content_3652_4374:()=>GBn,content_3652_4376:()=>BBn,content_3652_4378:()=>qBn,content_3652_438:()=>_7,content_3652_4380:()=>QBn,content_3652_4382:()=>KBn,content_3652_4384:()=>nUn,content_3652_4386:()=>pUn,content_3652_4388:()=>cUn,content_3652_4390:()=>lUn,content_3652_4392:()=>dUn,content_3652_4394:()=>fUn,content_3652_4396:()=>DUn,content_3652_4398:()=>wUn,content_3652_44:()=>C$,content_3652_440:()=>C7,content_3652_4400:()=>gUn,content_3652_4402:()=>LUn,content_3652_4404:()=>NUn,content_3652_4406:()=>WUn,content_3652_4408:()=>PUn,content_3652_4410:()=>GUn,content_3652_4412:()=>BUn,content_3652_4414:()=>qUn,content_3652_4416:()=>QUn,content_3652_4418:()=>KUn,content_3652_442:()=>v7,content_3652_4420:()=>nVn,content_3652_4422:()=>pVn,content_3652_4424:()=>cVn,content_3652_4426:()=>lVn,content_3652_4428:()=>dVn,content_3652_4430:()=>fVn,content_3652_4432:()=>DVn,content_3652_4434:()=>wVn,content_3652_4436:()=>gVn,content_3652_4438:()=>LVn,content_3652_444:()=>b7,content_3652_4440:()=>NVn,content_3652_4442:()=>WVn,content_3652_4444:()=>PVn,content_3652_4446:()=>GVn,content_3652_4448:()=>BVn,content_3652_4450:()=>qVn,content_3652_4452:()=>QVn,content_3652_4454:()=>KVn,content_3652_4456:()=>nqn,content_3652_4458:()=>pqn,content_3652_446:()=>z7,content_3652_4460:()=>cqn,content_3652_4462:()=>lqn,content_3652_4464:()=>dqn,content_3652_4466:()=>fqn,content_3652_4468:()=>Dqn,content_3652_4470:()=>wqn,content_3652_4472:()=>gqn,content_3652_4474:()=>Lqn,content_3652_4476:()=>Nqn,content_3652_4478:()=>Wqn,content_3652_448:()=>R7,content_3652_4480:()=>Pqn,content_3652_4482:()=>Gqn,content_3652_4484:()=>Bqn,content_3652_4486:()=>qqn,content_3652_4488:()=>Qqn,content_3652_4490:()=>Kqn,content_3652_4492:()=>njn,content_3652_4494:()=>pjn,content_3652_4496:()=>cjn,content_3652_4498:()=>ljn,content_3652_450:()=>E7,content_3652_4500:()=>djn,content_3652_4502:()=>fjn,content_3652_4504:()=>Djn,content_3652_4506:()=>wjn,content_3652_4508:()=>gjn,content_3652_4510:()=>Ljn,content_3652_4512:()=>Njn,content_3652_4514:()=>Wjn,content_3652_4516:()=>Pjn,content_3652_4518:()=>Gjn,content_3652_452:()=>F7,content_3652_4520:()=>Bjn,content_3652_4522:()=>qjn,content_3652_4524:()=>Qjn,content_3652_4526:()=>Kjn,content_3652_4528:()=>nYn,content_3652_4530:()=>pYn,content_3652_4532:()=>cYn,content_3652_4534:()=>lYn,content_3652_4536:()=>dYn,content_3652_4538:()=>fYn,content_3652_454:()=>V7,content_3652_4540:()=>DYn,content_3652_4542:()=>wYn,content_3652_4544:()=>gYn,content_3652_4546:()=>LYn,content_3652_4548:()=>NYn,content_3652_4550:()=>WYn,content_3652_4552:()=>PYn,content_3652_4554:()=>GYn,content_3652_4556:()=>BYn,content_3652_4558:()=>qYn,content_3652_456:()=>Y7,content_3652_4560:()=>QYn,content_3652_4562:()=>KYn,content_3652_4564:()=>nQn,content_3652_4566:()=>pQn,content_3652_4568:()=>cQn,content_3652_4570:()=>lQn,content_3652_4572:()=>dQn,content_3652_4574:()=>fQn,content_3652_4576:()=>DQn,content_3652_4578:()=>wQn,content_3652_458:()=>$7,content_3652_4580:()=>gQn,content_3652_4582:()=>LQn,content_3652_4584:()=>NQn,content_3652_4586:()=>WQn,content_3652_4588:()=>PQn,content_3652_4590:()=>GQn,content_3652_4592:()=>BQn,content_3652_4594:()=>qQn,content_3652_4596:()=>QQn,content_3652_4598:()=>KQn,content_3652_46:()=>v$,content_3652_460:()=>t9,content_3652_4600:()=>nHn,content_3652_4602:()=>pHn,content_3652_4604:()=>cHn,content_3652_4606:()=>lHn,content_3652_4608:()=>dHn,content_3652_4610:()=>fHn,content_3652_4612:()=>DHn,content_3652_4614:()=>wHn,content_3652_4616:()=>gHn,content_3652_4618:()=>LHn,content_3652_462:()=>o9,content_3652_4620:()=>NHn,content_3652_4622:()=>WHn,content_3652_4624:()=>PHn,content_3652_4626:()=>GHn,content_3652_4628:()=>BHn,content_3652_4630:()=>qHn,content_3652_4632:()=>QHn,content_3652_4634:()=>KHn,content_3652_4636:()=>n$n,content_3652_4638:()=>p$n,content_3652_464:()=>s9,content_3652_4640:()=>c$n,content_3652_4642:()=>l$n,content_3652_4644:()=>d$n,content_3652_4646:()=>f$n,content_3652_4648:()=>D$n,content_3652_4650:()=>w$n,content_3652_4652:()=>g$n,content_3652_4654:()=>L$n,content_3652_4656:()=>N$n,content_3652_4658:()=>W$n,content_3652_466:()=>a9,content_3652_4660:()=>P$n,content_3652_4662:()=>G$n,content_3652_4664:()=>B$n,content_3652_4666:()=>q$n,content_3652_4668:()=>Q$n,content_3652_4670:()=>K$n,content_3652_4672:()=>nKn,content_3652_4674:()=>pKn,content_3652_4676:()=>cKn,content_3652_4678:()=>lKn,content_3652_468:()=>m9,content_3652_4680:()=>dKn,content_3652_4682:()=>fKn,content_3652_4684:()=>DKn,content_3652_4686:()=>wKn,content_3652_4688:()=>gKn,content_3652_4690:()=>LKn,content_3652_4692:()=>NKn,content_3652_4694:()=>WKn,content_3652_4696:()=>PKn,content_3652_4698:()=>GKn,content_3652_470:()=>k9,content_3652_4700:()=>BKn,content_3652_4702:()=>qKn,content_3652_4704:()=>QKn,content_3652_4706:()=>KKn,content_3652_4708:()=>nJn,content_3652_4710:()=>pJn,content_3652_4712:()=>cJn,content_3652_4714:()=>lJn,content_3652_4716:()=>dJn,content_3652_4718:()=>fJn,content_3652_472:()=>M9,content_3652_4720:()=>DJn,content_3652_4722:()=>wJn,content_3652_4724:()=>gJn,content_3652_4726:()=>LJn,content_3652_4728:()=>NJn,content_3652_4730:()=>WJn,content_3652_4732:()=>PJn,content_3652_4734:()=>GJn,content_3652_4736:()=>BJn,content_3652_4738:()=>qJn,content_3652_474:()=>_9,content_3652_4740:()=>QJn,content_3652_4742:()=>KJn,content_3652_4744:()=>n0n,content_3652_4746:()=>p0n,content_3652_4748:()=>c0n,content_3652_4750:()=>l0n,content_3652_4752:()=>d0n,content_3652_4754:()=>f0n,content_3652_4756:()=>D0n,content_3652_4758:()=>w0n,content_3652_476:()=>C9,content_3652_4760:()=>g0n,content_3652_4762:()=>L0n,content_3652_4764:()=>N0n,content_3652_4766:()=>W0n,content_3652_4768:()=>P0n,content_3652_4770:()=>G0n,content_3652_4772:()=>B0n,content_3652_4774:()=>q0n,content_3652_4776:()=>Q0n,content_3652_4778:()=>K0n,content_3652_478:()=>v9,content_3652_4780:()=>n2n,content_3652_4782:()=>p2n,content_3652_4784:()=>c2n,content_3652_4786:()=>l2n,content_3652_4788:()=>d2n,content_3652_4790:()=>f2n,content_3652_4792:()=>D2n,content_3652_4794:()=>w2n,content_3652_4796:()=>g2n,content_3652_4798:()=>L2n,content_3652_48:()=>b$,content_3652_480:()=>b9,content_3652_4800:()=>N2n,content_3652_4802:()=>W2n,content_3652_4804:()=>P2n,content_3652_4806:()=>G2n,content_3652_4808:()=>B2n,content_3652_4810:()=>q2n,content_3652_4812:()=>Q2n,content_3652_4814:()=>K2n,content_3652_4816:()=>n6n,content_3652_4818:()=>p6n,content_3652_482:()=>z9,content_3652_4820:()=>c6n,content_3652_4822:()=>l6n,content_3652_4824:()=>d6n,content_3652_4826:()=>f6n,content_3652_4828:()=>D6n,content_3652_4830:()=>w6n,content_3652_4832:()=>g6n,content_3652_4834:()=>L6n,content_3652_4836:()=>N6n,content_3652_4838:()=>W6n,content_3652_484:()=>R9,content_3652_4840:()=>P6n,content_3652_4842:()=>G6n,content_3652_4844:()=>B6n,content_3652_4846:()=>q6n,content_3652_4848:()=>Q6n,content_3652_4850:()=>K6n,content_3652_4852:()=>n3n,content_3652_4854:()=>p3n,content_3652_4856:()=>c3n,content_3652_4858:()=>l3n,content_3652_486:()=>E9,content_3652_4860:()=>d3n,content_3652_4862:()=>f3n,content_3652_4864:()=>D3n,content_3652_4866:()=>w3n,content_3652_4868:()=>g3n,content_3652_4870:()=>L3n,content_3652_4872:()=>N3n,content_3652_4874:()=>W3n,content_3652_4876:()=>P3n,content_3652_4878:()=>G3n,content_3652_488:()=>F9,content_3652_4880:()=>B3n,content_3652_4882:()=>q3n,content_3652_4884:()=>Q3n,content_3652_4886:()=>K3n,content_3652_4888:()=>n5n,content_3652_4890:()=>p5n,content_3652_4892:()=>c5n,content_3652_4894:()=>l5n,content_3652_4896:()=>d5n,content_3652_4898:()=>f5n,content_3652_490:()=>V9,content_3652_4900:()=>D5n,content_3652_4902:()=>w5n,content_3652_4904:()=>g5n,content_3652_4906:()=>L5n,content_3652_4908:()=>N5n,content_3652_4910:()=>W5n,content_3652_4912:()=>P5n,content_3652_4914:()=>G5n,content_3652_4916:()=>B5n,content_3652_4918:()=>q5n,content_3652_492:()=>Y9,content_3652_4920:()=>Q5n,content_3652_4922:()=>K5n,content_3652_4924:()=>n1n,content_3652_4926:()=>p1n,content_3652_4928:()=>c1n,content_3652_4930:()=>l1n,content_3652_4932:()=>d1n,content_3652_4934:()=>f1n,content_3652_4936:()=>D1n,content_3652_4938:()=>w1n,content_3652_494:()=>$9,content_3652_4940:()=>g1n,content_3652_4942:()=>L1n,content_3652_4944:()=>N1n,content_3652_4946:()=>W1n,content_3652_4948:()=>P1n,content_3652_4950:()=>G1n,content_3652_4952:()=>B1n,content_3652_4954:()=>q1n,content_3652_4956:()=>Q1n,content_3652_4958:()=>K1n,content_3652_496:()=>ttt,content_3652_4960:()=>n4n,content_3652_4962:()=>p4n,content_3652_4964:()=>c4n,content_3652_4966:()=>l4n,content_3652_4968:()=>d4n,content_3652_4970:()=>f4n,content_3652_4972:()=>D4n,content_3652_4974:()=>w4n,content_3652_4976:()=>g4n,content_3652_4978:()=>L4n,content_3652_498:()=>ott,content_3652_4980:()=>N4n,content_3652_4982:()=>W4n,content_3652_4984:()=>P4n,content_3652_4986:()=>G4n,content_3652_4988:()=>B4n,content_3652_4990:()=>q4n,content_3652_4992:()=>Q4n,content_3652_4994:()=>K4n,content_3652_4996:()=>n8n,content_3652_4998:()=>p8n,content_3652_50:()=>z$,content_3652_500:()=>stt,content_3652_5000:()=>c8n,content_3652_5002:()=>l8n,content_3652_5004:()=>d8n,content_3652_5006:()=>f8n,content_3652_5008:()=>D8n,content_3652_5010:()=>w8n,content_3652_5012:()=>g8n,content_3652_5014:()=>L8n,content_3652_5016:()=>N8n,content_3652_5018:()=>W8n,content_3652_502:()=>att,content_3652_5020:()=>P8n,content_3652_5022:()=>G8n,content_3652_5024:()=>B8n,content_3652_5026:()=>q8n,content_3652_5028:()=>Q8n,content_3652_5030:()=>K8n,content_3652_5032:()=>n7n,content_3652_5034:()=>p7n,content_3652_5036:()=>c7n,content_3652_5038:()=>l7n,content_3652_504:()=>mtt,content_3652_5040:()=>d7n,content_3652_5042:()=>f7n,content_3652_5044:()=>D7n,content_3652_5046:()=>w7n,content_3652_5048:()=>g7n,content_3652_5050:()=>L7n,content_3652_5052:()=>N7n,content_3652_5054:()=>W7n,content_3652_5056:()=>P7n,content_3652_5058:()=>G7n,content_3652_506:()=>ktt,content_3652_5060:()=>B7n,content_3652_5062:()=>q7n,content_3652_5064:()=>Q7n,content_3652_5066:()=>K7n,content_3652_5068:()=>n9n,content_3652_5070:()=>p9n,content_3652_5072:()=>c9n,content_3652_5074:()=>l9n,content_3652_5076:()=>d9n,content_3652_5078:()=>f9n,content_3652_508:()=>Mtt,content_3652_5080:()=>D9n,content_3652_5082:()=>w9n,content_3652_5084:()=>g9n,content_3652_5086:()=>L9n,content_3652_5088:()=>N9n,content_3652_5090:()=>W9n,content_3652_5092:()=>P9n,content_3652_5094:()=>G9n,content_3652_5096:()=>B9n,content_3652_5098:()=>q9n,content_3652_510:()=>_tt,content_3652_5100:()=>Q9n,content_3652_5102:()=>K9n,content_3652_5104:()=>nte,content_3652_5106:()=>pte,content_3652_5108:()=>cte,content_3652_5110:()=>lte,content_3652_5112:()=>dte,content_3652_5114:()=>fte,content_3652_5116:()=>Dte,content_3652_5118:()=>wte,content_3652_512:()=>Ctt,content_3652_5120:()=>gte,content_3652_5122:()=>Lte,content_3652_5124:()=>Nte,content_3652_5126:()=>Wte,content_3652_5128:()=>Pte,content_3652_5130:()=>Gte,content_3652_5132:()=>Bte,content_3652_5134:()=>qte,content_3652_5136:()=>Qte,content_3652_5138:()=>Kte,content_3652_514:()=>vtt,content_3652_5140:()=>nne,content_3652_5142:()=>pne,content_3652_5144:()=>cne,content_3652_5146:()=>lne,content_3652_5148:()=>dne,content_3652_5150:()=>fne,content_3652_5152:()=>Dne,content_3652_5154:()=>wne,content_3652_5156:()=>gne,content_3652_5158:()=>Lne,content_3652_516:()=>btt,content_3652_5160:()=>Nne,content_3652_5162:()=>Wne,content_3652_5164:()=>Pne,content_3652_5166:()=>Gne,content_3652_5168:()=>Bne,content_3652_5170:()=>qne,content_3652_5172:()=>Qne,content_3652_5174:()=>Kne,content_3652_5176:()=>nee,content_3652_5178:()=>pee,content_3652_518:()=>ztt,content_3652_5180:()=>cee,content_3652_5182:()=>lee,content_3652_5184:()=>dee,content_3652_5186:()=>fee,content_3652_5188:()=>Dee,content_3652_5190:()=>wee,content_3652_5192:()=>gee,content_3652_5194:()=>Lee,content_3652_5196:()=>Nee,content_3652_5198:()=>Wee,content_3652_52:()=>R$,content_3652_520:()=>Rtt,content_3652_5200:()=>Pee,content_3652_5202:()=>Gee,content_3652_5204:()=>Bee,content_3652_5206:()=>qee,content_3652_5208:()=>Qee,content_3652_5210:()=>Kee,content_3652_5212:()=>noe,content_3652_5214:()=>poe,content_3652_5216:()=>coe,content_3652_5218:()=>loe,content_3652_522:()=>Ett,content_3652_5220:()=>doe,content_3652_5222:()=>foe,content_3652_5224:()=>Doe,content_3652_5226:()=>woe,content_3652_5228:()=>goe,content_3652_5230:()=>Loe,content_3652_5232:()=>Noe,content_3652_5234:()=>Woe,content_3652_5236:()=>Poe,content_3652_5238:()=>Goe,content_3652_524:()=>Ftt,content_3652_5240:()=>Boe,content_3652_5242:()=>qoe,content_3652_5244:()=>Qoe,content_3652_5246:()=>Koe,content_3652_5248:()=>npe,content_3652_5250:()=>ppe,content_3652_5252:()=>cpe,content_3652_5254:()=>lpe,content_3652_5256:()=>dpe,content_3652_5258:()=>fpe,content_3652_526:()=>Vtt,content_3652_5260:()=>Dpe,content_3652_5262:()=>wpe,content_3652_5264:()=>gpe,content_3652_5266:()=>Lpe,content_3652_5268:()=>Npe,content_3652_5270:()=>Wpe,content_3652_5272:()=>Ppe,content_3652_5274:()=>Gpe,content_3652_5276:()=>Bpe,content_3652_5278:()=>qpe,content_3652_528:()=>Ytt,content_3652_5280:()=>Qpe,content_3652_5282:()=>Kpe,content_3652_5284:()=>nre,content_3652_5286:()=>pre,content_3652_5288:()=>cre,content_3652_5290:()=>lre,content_3652_5292:()=>dre,content_3652_5294:()=>fre,content_3652_5296:()=>Dre,content_3652_5298:()=>wre,content_3652_530:()=>$tt,content_3652_5300:()=>gre,content_3652_5302:()=>Lre,content_3652_5304:()=>Nre,content_3652_5306:()=>Wre,content_3652_5308:()=>Pre,content_3652_5310:()=>Gre,content_3652_5312:()=>Bre,content_3652_5314:()=>qre,content_3652_5316:()=>Qre,content_3652_5318:()=>Kre,content_3652_532:()=>tnt,content_3652_5320:()=>nse,content_3652_5322:()=>pse,content_3652_5324:()=>cse,content_3652_5326:()=>lse,content_3652_5328:()=>dse,content_3652_5330:()=>fse,content_3652_5332:()=>Dse,content_3652_5334:()=>wse,content_3652_5336:()=>gse,content_3652_5338:()=>Lse,content_3652_534:()=>ont,content_3652_5340:()=>Nse,content_3652_5342:()=>Wse,content_3652_5344:()=>Pse,content_3652_5346:()=>Gse,content_3652_5348:()=>Bse,content_3652_5350:()=>qse,content_3652_5352:()=>Qse,content_3652_5354:()=>Kse,content_3652_5356:()=>nce,content_3652_5358:()=>pce,content_3652_536:()=>snt,content_3652_5360:()=>cce,content_3652_5362:()=>lce,content_3652_5364:()=>dce,content_3652_5366:()=>fce,content_3652_5368:()=>Dce,content_3652_5370:()=>wce,content_3652_5372:()=>gce,content_3652_5374:()=>Lce,content_3652_5376:()=>Nce,content_3652_5378:()=>Wce,content_3652_538:()=>ant,content_3652_5380:()=>Pce,content_3652_5382:()=>Gce,content_3652_5384:()=>Bce,content_3652_5386:()=>qce,content_3652_5388:()=>Qce,content_3652_5390:()=>Kce,content_3652_5392:()=>nie,content_3652_5394:()=>pie,content_3652_5396:()=>cie,content_3652_5398:()=>lie,content_3652_54:()=>E$,content_3652_540:()=>mnt,content_3652_5400:()=>die,content_3652_5402:()=>fie,content_3652_5404:()=>Die,content_3652_5406:()=>wie,content_3652_5408:()=>gie,content_3652_5410:()=>Lie,content_3652_5412:()=>Nie,content_3652_5414:()=>Wie,content_3652_5416:()=>Pie,content_3652_5418:()=>Gie,content_3652_542:()=>knt,content_3652_5420:()=>Bie,content_3652_5422:()=>qie,content_3652_5424:()=>Qie,content_3652_5426:()=>Kie,content_3652_5428:()=>nae,content_3652_5430:()=>pae,content_3652_5432:()=>cae,content_3652_5434:()=>lae,content_3652_5436:()=>dae,content_3652_5438:()=>fae,content_3652_544:()=>Mnt,content_3652_5440:()=>Dae,content_3652_5442:()=>wae,content_3652_5444:()=>gae,content_3652_5446:()=>Lae,content_3652_5448:()=>Nae,content_3652_5450:()=>Wae,content_3652_5452:()=>Pae,content_3652_5454:()=>Gae,content_3652_5456:()=>Bae,content_3652_5458:()=>qae,content_3652_546:()=>_nt,content_3652_5460:()=>Qae,content_3652_5462:()=>Kae,content_3652_5464:()=>nle,content_3652_5466:()=>ple,content_3652_5468:()=>cle,content_3652_5470:()=>lle,content_3652_5472:()=>dle,content_3652_5474:()=>fle,content_3652_5476:()=>Dle,content_3652_5478:()=>wle,content_3652_548:()=>Cnt,content_3652_5480:()=>gle,content_3652_5482:()=>Lle,content_3652_5484:()=>Nle,content_3652_5486:()=>Wle,content_3652_5488:()=>Ple,content_3652_5490:()=>Gle,content_3652_5492:()=>Ble,content_3652_5494:()=>qle,content_3652_5496:()=>Qle,content_3652_5498:()=>Kle,content_3652_550:()=>vnt,content_3652_5500:()=>nue,content_3652_5502:()=>pue,content_3652_5504:()=>cue,content_3652_5506:()=>lue,content_3652_5508:()=>due,content_3652_5510:()=>fue,content_3652_5512:()=>Due,content_3652_5514:()=>wue,content_3652_5516:()=>gue,content_3652_5518:()=>Lue,content_3652_552:()=>bnt,content_3652_5520:()=>Nue,content_3652_5522:()=>Wue,content_3652_5524:()=>Pue,content_3652_5526:()=>Gue,content_3652_5528:()=>Bue,content_3652_5530:()=>que,content_3652_5532:()=>Que,content_3652_5534:()=>Kue,content_3652_5536:()=>nme,content_3652_5538:()=>pme,content_3652_554:()=>znt,content_3652_5540:()=>cme,content_3652_5542:()=>lme,content_3652_5544:()=>dme,content_3652_5546:()=>fme,content_3652_5548:()=>Dme,content_3652_5550:()=>wme,content_3652_5552:()=>gme,content_3652_5554:()=>Lme,content_3652_5556:()=>Nme,content_3652_5558:()=>Wme,content_3652_556:()=>Rnt,content_3652_5560:()=>Pme,content_3652_5562:()=>Gme,content_3652_5564:()=>Bme,content_3652_5566:()=>qme,content_3652_5568:()=>Qme,content_3652_5570:()=>Kme,content_3652_5572:()=>nde,content_3652_5574:()=>pde,content_3652_5576:()=>cde,content_3652_5578:()=>lde,content_3652_558:()=>Ent,content_3652_5580:()=>dde,content_3652_5582:()=>fde,content_3652_5584:()=>Dde,content_3652_5586:()=>wde,content_3652_5588:()=>gde,content_3652_5590:()=>Lde,content_3652_5592:()=>Nde,content_3652_5594:()=>Wde,content_3652_5596:()=>Pde,content_3652_5598:()=>Gde,content_3652_56:()=>F$,content_3652_560:()=>Fnt,content_3652_5600:()=>Bde,content_3652_5602:()=>qde,content_3652_5604:()=>Qde,content_3652_5606:()=>Kde,content_3652_5608:()=>nhe,content_3652_5610:()=>phe,content_3652_5612:()=>che,content_3652_5614:()=>lhe,content_3652_5616:()=>dhe,content_3652_5618:()=>fhe,content_3652_562:()=>Vnt,content_3652_5620:()=>Dhe,content_3652_5622:()=>whe,content_3652_5624:()=>ghe,content_3652_5626:()=>Lhe,content_3652_5628:()=>Nhe,content_3652_5630:()=>Whe,content_3652_5632:()=>Phe,content_3652_5634:()=>Ghe,content_3652_5636:()=>Bhe,content_3652_5638:()=>qhe,content_3652_564:()=>Ynt,content_3652_5640:()=>Qhe,content_3652_5642:()=>Khe,content_3652_5644:()=>nke,content_3652_5646:()=>pke,content_3652_5648:()=>cke,content_3652_5650:()=>lke,content_3652_5652:()=>dke,content_3652_5654:()=>fke,content_3652_5656:()=>Dke,content_3652_5658:()=>wke,content_3652_566:()=>$nt,content_3652_5660:()=>gke,content_3652_5662:()=>Lke,content_3652_5664:()=>Nke,content_3652_5666:()=>Wke,content_3652_5668:()=>Pke,content_3652_5670:()=>Gke,content_3652_5672:()=>Bke,content_3652_5674:()=>qke,content_3652_5676:()=>Qke,content_3652_5678:()=>Kke,content_3652_568:()=>tet,content_3652_5680:()=>nfe,content_3652_5682:()=>pfe,content_3652_5684:()=>cfe,content_3652_5686:()=>lfe,content_3652_5688:()=>dfe,content_3652_5690:()=>ffe,content_3652_5692:()=>Dfe,content_3652_5694:()=>wfe,content_3652_5696:()=>gfe,content_3652_5698:()=>Lfe,content_3652_570:()=>oet,content_3652_5700:()=>Nfe,content_3652_5702:()=>Wfe,content_3652_5704:()=>Pfe,content_3652_5706:()=>Gfe,content_3652_5708:()=>Bfe,content_3652_5710:()=>qfe,content_3652_5712:()=>Qfe,content_3652_5714:()=>Kfe,content_3652_5716:()=>nye,content_3652_5718:()=>pye,content_3652_572:()=>set,content_3652_5720:()=>cye,content_3652_5722:()=>lye,content_3652_5724:()=>dye,content_3652_5726:()=>fye,content_3652_5728:()=>Dye,content_3652_5730:()=>wye,content_3652_5732:()=>gye,content_3652_5734:()=>Lye,content_3652_5736:()=>Nye,content_3652_5738:()=>Wye,content_3652_574:()=>aet,content_3652_5740:()=>Pye,content_3652_5742:()=>Gye,content_3652_5744:()=>Bye,content_3652_5746:()=>qye,content_3652_5748:()=>Qye,content_3652_5750:()=>Kye,content_3652_5752:()=>nMe,content_3652_5754:()=>pMe,content_3652_5756:()=>cMe,content_3652_5758:()=>lMe,content_3652_576:()=>det,content_3652_5760:()=>dMe,content_3652_5762:()=>fMe,content_3652_5764:()=>DMe,content_3652_5766:()=>wMe,content_3652_5768:()=>gMe,content_3652_5770:()=>LMe,content_3652_5772:()=>NMe,content_3652_5774:()=>WMe,content_3652_5776:()=>PMe,content_3652_5778:()=>GMe,content_3652_578:()=>fet,content_3652_5780:()=>BMe,content_3652_5782:()=>qMe,content_3652_5784:()=>QMe,content_3652_5786:()=>KMe,content_3652_5788:()=>nDe,content_3652_5790:()=>pDe,content_3652_5792:()=>cDe,content_3652_5794:()=>lDe,content_3652_5796:()=>dDe,content_3652_5798:()=>fDe,content_3652_58:()=>V$,content_3652_580:()=>Det,content_3652_5800:()=>DDe,content_3652_5802:()=>wDe,content_3652_5804:()=>gDe,content_3652_5806:()=>LDe,content_3652_5808:()=>NDe,content_3652_5810:()=>WDe,content_3652_5812:()=>PDe,content_3652_5814:()=>GDe,content_3652_5816:()=>BDe,content_3652_5818:()=>qDe,content_3652_582:()=>wet,content_3652_5820:()=>QDe,content_3652_5822:()=>KDe,content_3652_5824:()=>nXe,content_3652_5826:()=>pXe,content_3652_5828:()=>cXe,content_3652_5830:()=>lXe,content_3652_5832:()=>dXe,content_3652_5834:()=>fXe,content_3652_5836:()=>DXe,content_3652_5838:()=>wXe,content_3652_584:()=>get,content_3652_5840:()=>gXe,content_3652_5842:()=>LXe,content_3652_5844:()=>NXe,content_3652_5846:()=>WXe,content_3652_5848:()=>PXe,content_3652_5850:()=>GXe,content_3652_5852:()=>BXe,content_3652_5854:()=>qXe,content_3652_5856:()=>QXe,content_3652_5858:()=>KXe,content_3652_586:()=>Let,content_3652_5860:()=>n_e,content_3652_5862:()=>p_e,content_3652_5864:()=>c_e,content_3652_5866:()=>l_e,content_3652_5868:()=>d_e,content_3652_5870:()=>f_e,content_3652_5872:()=>D_e,content_3652_5874:()=>w_e,content_3652_5876:()=>g_e,content_3652_5878:()=>L_e,content_3652_588:()=>Net,content_3652_5880:()=>N_e,content_3652_5882:()=>W_e,content_3652_5884:()=>P_e,content_3652_5886:()=>G_e,content_3652_5888:()=>B_e,content_3652_5890:()=>q_e,content_3652_5892:()=>Q_e,content_3652_5894:()=>K_e,content_3652_5896:()=>nwe,content_3652_5898:()=>pwe,content_3652_590:()=>Wet,content_3652_5900:()=>cwe,content_3652_5902:()=>lwe,content_3652_5904:()=>dwe,content_3652_5906:()=>fwe,content_3652_5908:()=>Dwe,content_3652_5910:()=>wwe,content_3652_5912:()=>gwe,content_3652_5914:()=>Lwe,content_3652_5916:()=>Nwe,content_3652_5918:()=>Wwe,content_3652_592:()=>Pet,content_3652_5920:()=>Pwe,content_3652_5922:()=>Gwe,content_3652_5924:()=>Bwe,content_3652_5926:()=>qwe,content_3652_5928:()=>Qwe,content_3652_5930:()=>Kwe,content_3652_5932:()=>nTe,content_3652_5934:()=>pTe,content_3652_5936:()=>cTe,content_3652_5938:()=>lTe,content_3652_594:()=>Get,content_3652_5940:()=>dTe,content_3652_5942:()=>fTe,content_3652_5944:()=>DTe,content_3652_5946:()=>wTe,content_3652_5948:()=>gTe,content_3652_5950:()=>LTe,content_3652_5952:()=>NTe,content_3652_5954:()=>WTe,content_3652_5956:()=>PTe,content_3652_5958:()=>GTe,content_3652_596:()=>Bet,content_3652_5960:()=>BTe,content_3652_5962:()=>qTe,content_3652_5964:()=>QTe,content_3652_5966:()=>KTe,content_3652_5968:()=>nCe,content_3652_5970:()=>pCe,content_3652_5972:()=>cCe,content_3652_5974:()=>lCe,content_3652_5976:()=>dCe,content_3652_5978:()=>fCe,content_3652_598:()=>qet,content_3652_5980:()=>DCe,content_3652_5982:()=>wCe,content_3652_5984:()=>gCe,content_3652_5986:()=>LCe,content_3652_5988:()=>NCe,content_3652_5990:()=>WCe,content_3652_5992:()=>PCe,content_3652_5994:()=>GCe,content_3652_5996:()=>BCe,content_3652_5998:()=>qCe,content_3652_6:()=>_H,content_3652_60:()=>Y$,content_3652_600:()=>Qet,content_3652_6000:()=>QCe,content_3652_6002:()=>KCe,content_3652_6004:()=>nge,content_3652_6006:()=>pge,content_3652_6008:()=>cge,content_3652_6010:()=>lge,content_3652_6012:()=>dge,content_3652_6014:()=>fge,content_3652_6016:()=>Dge,content_3652_6018:()=>wge,content_3652_602:()=>Ket,content_3652_6020:()=>gge,content_3652_6022:()=>Lge,content_3652_6024:()=>Nge,content_3652_6026:()=>Wge,content_3652_6028:()=>Pge,content_3652_6030:()=>Gge,content_3652_6032:()=>Bge,content_3652_6034:()=>qge,content_3652_6036:()=>Qge,content_3652_6038:()=>Kge,content_3652_604:()=>not,content_3652_6040:()=>nxe,content_3652_6042:()=>pxe,content_3652_6044:()=>cxe,content_3652_6046:()=>lxe,content_3652_6048:()=>dxe,content_3652_6050:()=>fxe,content_3652_6052:()=>Dxe,content_3652_6054:()=>wxe,content_3652_6056:()=>gxe,content_3652_6058:()=>Lxe,content_3652_606:()=>pot,content_3652_6060:()=>Nxe,content_3652_6062:()=>Wxe,content_3652_6064:()=>Pxe,content_3652_6066:()=>Gxe,content_3652_6068:()=>Bxe,content_3652_6070:()=>qxe,content_3652_6072:()=>Qxe,content_3652_6074:()=>Kxe,content_3652_6076:()=>nve,content_3652_6078:()=>pve,content_3652_608:()=>cot,content_3652_6080:()=>cve,content_3652_6082:()=>lve,content_3652_6084:()=>dve,content_3652_6086:()=>fve,content_3652_6088:()=>Dve,content_3652_6090:()=>wve,content_3652_6092:()=>gve,content_3652_6094:()=>Lve,content_3652_6096:()=>Nve,content_3652_6098:()=>Wve,content_3652_610:()=>lot,content_3652_6100:()=>Pve,content_3652_6102:()=>Gve,content_3652_6104:()=>Bve,content_3652_6106:()=>qve,content_3652_6108:()=>Qve,content_3652_6110:()=>Kve,content_3652_6112:()=>nLe,content_3652_6114:()=>pLe,content_3652_6116:()=>cLe,content_3652_6118:()=>lLe,content_3652_612:()=>dot,content_3652_6120:()=>dLe,content_3652_6122:()=>fLe,content_3652_6124:()=>DLe,content_3652_6126:()=>wLe,content_3652_6128:()=>gLe,content_3652_6130:()=>LLe,content_3652_6132:()=>NLe,content_3652_6134:()=>WLe,content_3652_6136:()=>PLe,content_3652_6138:()=>GLe,content_3652_614:()=>fot,content_3652_6140:()=>BLe,content_3652_6142:()=>qLe,content_3652_6144:()=>QLe,content_3652_6146:()=>KLe,content_3652_6148:()=>nZe,content_3652_6150:()=>pZe,content_3652_6152:()=>cZe,content_3652_6154:()=>lZe,content_3652_6156:()=>dZe,content_3652_6158:()=>fZe,content_3652_616:()=>Dot,content_3652_6160:()=>DZe,content_3652_6162:()=>wZe,content_3652_6164:()=>gZe,content_3652_6166:()=>LZe,content_3652_6168:()=>NZe,content_3652_6170:()=>WZe,content_3652_6172:()=>PZe,content_3652_6174:()=>GZe,content_3652_6176:()=>BZe,content_3652_6178:()=>qZe,content_3652_618:()=>wot,content_3652_6180:()=>QZe,content_3652_6182:()=>KZe,content_3652_6184:()=>nbe,content_3652_6186:()=>pbe,content_3652_6188:()=>cbe,content_3652_6190:()=>lbe,content_3652_6192:()=>dbe,content_3652_6194:()=>fbe,content_3652_6196:()=>Dbe,content_3652_6198:()=>wbe,content_3652_62:()=>$$,content_3652_620:()=>got,content_3652_6200:()=>gbe,content_3652_6202:()=>Lbe,content_3652_6204:()=>Nbe,content_3652_6206:()=>Wbe,content_3652_6208:()=>Pbe,content_3652_6210:()=>Gbe,content_3652_6212:()=>Bbe,content_3652_6214:()=>qbe,content_3652_6216:()=>Qbe,content_3652_6218:()=>Kbe,content_3652_622:()=>Lot,content_3652_6220:()=>nNe,content_3652_6222:()=>pNe,content_3652_6224:()=>cNe,content_3652_6226:()=>lNe,content_3652_6228:()=>dNe,content_3652_6230:()=>fNe,content_3652_6232:()=>DNe,content_3652_6234:()=>wNe,content_3652_6236:()=>gNe,content_3652_6238:()=>LNe,content_3652_624:()=>Not,content_3652_6240:()=>NNe,content_3652_6242:()=>WNe,content_3652_6244:()=>PNe,content_3652_6246:()=>GNe,content_3652_6248:()=>BNe,content_3652_6250:()=>qNe,content_3652_6252:()=>QNe,content_3652_6254:()=>KNe,content_3652_6256:()=>nAe,content_3652_6258:()=>pAe,content_3652_626:()=>Wot,content_3652_6260:()=>cAe,content_3652_6262:()=>lAe,content_3652_6264:()=>dAe,content_3652_6266:()=>fAe,content_3652_6268:()=>DAe,content_3652_6270:()=>wAe,content_3652_6272:()=>gAe,content_3652_6274:()=>LAe,content_3652_6276:()=>NAe,content_3652_6278:()=>WAe,content_3652_628:()=>Pot,content_3652_6280:()=>PAe,content_3652_6282:()=>GAe,content_3652_6284:()=>BAe,content_3652_6286:()=>qAe,content_3652_6288:()=>QAe,content_3652_6290:()=>KAe,content_3652_6292:()=>nze,content_3652_6294:()=>pze,content_3652_6296:()=>cze,content_3652_6298:()=>lze,content_3652_630:()=>Got,content_3652_6300:()=>dze,content_3652_6302:()=>fze,content_3652_6304:()=>Dze,content_3652_6306:()=>wze,content_3652_6308:()=>gze,content_3652_6310:()=>Lze,content_3652_6312:()=>Nze,content_3652_6314:()=>Wze,content_3652_6316:()=>Pze,content_3652_6318:()=>Gze,content_3652_632:()=>Bot,content_3652_6320:()=>Bze,content_3652_6322:()=>qze,content_3652_6324:()=>Qze,content_3652_6326:()=>Kze,content_3652_6328:()=>nWe,content_3652_6330:()=>pWe,content_3652_6332:()=>cWe,content_3652_6334:()=>lWe,content_3652_6336:()=>dWe,content_3652_6338:()=>fWe,content_3652_634:()=>qot,content_3652_6340:()=>DWe,content_3652_6342:()=>wWe,content_3652_6344:()=>gWe,content_3652_6346:()=>LWe,content_3652_6348:()=>NWe,content_3652_6350:()=>WWe,content_3652_6352:()=>PWe,content_3652_6354:()=>GWe,content_3652_6356:()=>BWe,content_3652_6358:()=>qWe,content_3652_636:()=>Qot,content_3652_6360:()=>QWe,content_3652_6362:()=>KWe,content_3652_6364:()=>nIe,content_3652_6366:()=>pIe,content_3652_6368:()=>cIe,content_3652_6370:()=>lIe,content_3652_6372:()=>dIe,content_3652_6374:()=>fIe,content_3652_6376:()=>DIe,content_3652_6378:()=>wIe,content_3652_638:()=>Kot,content_3652_6380:()=>gIe,content_3652_6382:()=>LIe,content_3652_6384:()=>NIe,content_3652_6386:()=>WIe,content_3652_6388:()=>PIe,content_3652_6390:()=>GIe,content_3652_6392:()=>BIe,content_3652_6394:()=>qIe,content_3652_6396:()=>QIe,content_3652_6398:()=>KIe,content_3652_64:()=>tK,content_3652_640:()=>npt,content_3652_6400:()=>nRe,content_3652_6402:()=>pRe,content_3652_6404:()=>cRe,content_3652_6406:()=>lRe,content_3652_6408:()=>dRe,content_3652_6410:()=>fRe,content_3652_6412:()=>DRe,content_3652_6414:()=>wRe,content_3652_6416:()=>gRe,content_3652_6418:()=>LRe,content_3652_642:()=>ppt,content_3652_6420:()=>NRe,content_3652_6422:()=>WRe,content_3652_6424:()=>PRe,content_3652_6426:()=>GRe,content_3652_6428:()=>BRe,content_3652_6430:()=>qRe,content_3652_6432:()=>QRe,content_3652_6434:()=>KRe,content_3652_6436:()=>nPe,content_3652_6438:()=>pPe,content_3652_644:()=>cpt,content_3652_6440:()=>cPe,content_3652_6442:()=>lPe,content_3652_6444:()=>dPe,content_3652_6446:()=>fPe,content_3652_6448:()=>DPe,content_3652_6450:()=>wPe,content_3652_6452:()=>gPe,content_3652_6454:()=>LPe,content_3652_6456:()=>NPe,content_3652_6458:()=>WPe,content_3652_646:()=>lpt,content_3652_6460:()=>PPe,content_3652_6462:()=>GPe,content_3652_6464:()=>BPe,content_3652_6466:()=>qPe,content_3652_6468:()=>QPe,content_3652_6470:()=>KPe,content_3652_6472:()=>nSe,content_3652_6474:()=>pSe,content_3652_6476:()=>cSe,content_3652_6478:()=>lSe,content_3652_648:()=>dpt,content_3652_6480:()=>dSe,content_3652_6482:()=>fSe,content_3652_6484:()=>DSe,content_3652_6486:()=>wSe,content_3652_6488:()=>gSe,content_3652_6490:()=>LSe,content_3652_6492:()=>NSe,content_3652_6494:()=>WSe,content_3652_6496:()=>PSe,content_3652_6498:()=>GSe,content_3652_650:()=>fpt,content_3652_6500:()=>BSe,content_3652_6502:()=>qSe,content_3652_6504:()=>QSe,content_3652_6506:()=>KSe,content_3652_6508:()=>nEe,content_3652_6510:()=>pEe,content_3652_6512:()=>cEe,content_3652_6514:()=>lEe,content_3652_6516:()=>dEe,content_3652_6518:()=>fEe,content_3652_652:()=>Dpt,content_3652_6520:()=>DEe,content_3652_6522:()=>wEe,content_3652_6524:()=>gEe,content_3652_6526:()=>LEe,content_3652_6528:()=>NEe,content_3652_6530:()=>WEe,content_3652_6532:()=>PEe,content_3652_6534:()=>GEe,content_3652_6536:()=>BEe,content_3652_6538:()=>qEe,content_3652_654:()=>wpt,content_3652_6540:()=>QEe,content_3652_6542:()=>KEe,content_3652_6544:()=>nGe,content_3652_6546:()=>pGe,content_3652_6548:()=>cGe,content_3652_6550:()=>lGe,content_3652_6552:()=>dGe,content_3652_6554:()=>fGe,content_3652_6556:()=>DGe,content_3652_6558:()=>wGe,content_3652_656:()=>gpt,content_3652_6560:()=>gGe,content_3652_6562:()=>LGe,content_3652_6564:()=>NGe,content_3652_6566:()=>WGe,content_3652_6568:()=>PGe,content_3652_6570:()=>GGe,content_3652_6572:()=>BGe,content_3652_6574:()=>qGe,content_3652_6576:()=>QGe,content_3652_6578:()=>KGe,content_3652_658:()=>Lpt,content_3652_6580:()=>nOe,content_3652_6582:()=>pOe,content_3652_6584:()=>cOe,content_3652_6586:()=>lOe,content_3652_6588:()=>dOe,content_3652_6590:()=>fOe,content_3652_6592:()=>DOe,content_3652_6594:()=>wOe,content_3652_6596:()=>gOe,content_3652_6598:()=>LOe,content_3652_66:()=>oK,content_3652_660:()=>Npt,content_3652_6600:()=>NOe,content_3652_6602:()=>WOe,content_3652_6604:()=>POe,content_3652_6606:()=>GOe,content_3652_6608:()=>BOe,content_3652_6610:()=>qOe,content_3652_6612:()=>QOe,content_3652_6614:()=>KOe,content_3652_6616:()=>nFe,content_3652_6618:()=>pFe,content_3652_662:()=>Wpt,content_3652_6620:()=>cFe,content_3652_6622:()=>lFe,content_3652_6624:()=>dFe,content_3652_6626:()=>fFe,content_3652_6628:()=>DFe,content_3652_6630:()=>wFe,content_3652_6632:()=>gFe,content_3652_6634:()=>LFe,content_3652_6636:()=>NFe,content_3652_6638:()=>WFe,content_3652_664:()=>Ppt,content_3652_6640:()=>PFe,content_3652_6642:()=>GFe,content_3652_6644:()=>BFe,content_3652_6646:()=>qFe,content_3652_6648:()=>QFe,content_3652_6650:()=>KFe,content_3652_6652:()=>nBe,content_3652_6654:()=>pBe,content_3652_6656:()=>cBe,content_3652_6658:()=>lBe,content_3652_666:()=>Gpt,content_3652_6660:()=>dBe,content_3652_6662:()=>fBe,content_3652_6664:()=>DBe,content_3652_6666:()=>wBe,content_3652_6668:()=>gBe,content_3652_6670:()=>LBe,content_3652_6672:()=>NBe,content_3652_6674:()=>WBe,content_3652_6676:()=>PBe,content_3652_6678:()=>GBe,content_3652_668:()=>Bpt,content_3652_6680:()=>BBe,content_3652_6682:()=>qBe,content_3652_6684:()=>QBe,content_3652_6686:()=>KBe,content_3652_6688:()=>nUe,content_3652_6690:()=>pUe,content_3652_6692:()=>cUe,content_3652_6694:()=>lUe,content_3652_6696:()=>dUe,content_3652_6698:()=>fUe,content_3652_670:()=>qpt,content_3652_6700:()=>DUe,content_3652_6702:()=>wUe,content_3652_6704:()=>gUe,content_3652_6706:()=>LUe,content_3652_6708:()=>NUe,content_3652_6710:()=>WUe,content_3652_6712:()=>PUe,content_3652_6714:()=>GUe,content_3652_6716:()=>BUe,content_3652_6718:()=>qUe,content_3652_672:()=>Qpt,content_3652_6720:()=>QUe,content_3652_6722:()=>KUe,content_3652_6724:()=>nVe,content_3652_6726:()=>pVe,content_3652_6728:()=>cVe,content_3652_6730:()=>lVe,content_3652_6732:()=>dVe,content_3652_6734:()=>fVe,content_3652_6736:()=>DVe,content_3652_6738:()=>wVe,content_3652_674:()=>Kpt,content_3652_6740:()=>gVe,content_3652_6742:()=>LVe,content_3652_6744:()=>NVe,content_3652_6746:()=>WVe,content_3652_6748:()=>PVe,content_3652_6750:()=>GVe,content_3652_6752:()=>BVe,content_3652_6754:()=>qVe,content_3652_6756:()=>QVe,content_3652_6758:()=>KVe,content_3652_676:()=>nrt,content_3652_6760:()=>nqe,content_3652_6762:()=>pqe,content_3652_6764:()=>cqe,content_3652_6766:()=>lqe,content_3652_6768:()=>dqe,content_3652_6770:()=>fqe,content_3652_6772:()=>Dqe,content_3652_6774:()=>wqe,content_3652_6776:()=>gqe,content_3652_6778:()=>Lqe,content_3652_678:()=>prt,content_3652_6780:()=>Nqe,content_3652_6782:()=>Wqe,content_3652_6784:()=>Pqe,content_3652_6786:()=>Gqe,content_3652_6788:()=>Bqe,content_3652_6790:()=>qqe,content_3652_6792:()=>Qqe,content_3652_6794:()=>Kqe,content_3652_6796:()=>nje,content_3652_6798:()=>pje,content_3652_68:()=>sK,content_3652_680:()=>crt,content_3652_6800:()=>cje,content_3652_6802:()=>lje,content_3652_6804:()=>dje,content_3652_6806:()=>fje,content_3652_6808:()=>Dje,content_3652_6810:()=>wje,content_3652_6812:()=>gje,content_3652_6814:()=>Lje,content_3652_6816:()=>Nje,content_3652_6818:()=>Wje,content_3652_682:()=>lrt,content_3652_6820:()=>Pje,content_3652_6822:()=>Gje,content_3652_6824:()=>Bje,content_3652_6826:()=>qje,content_3652_6828:()=>Qje,content_3652_6830:()=>Kje,content_3652_6832:()=>nYe,content_3652_6834:()=>pYe,content_3652_6836:()=>cYe,content_3652_6838:()=>lYe,content_3652_684:()=>drt,content_3652_6840:()=>dYe,content_3652_6842:()=>fYe,content_3652_6844:()=>DYe,content_3652_6846:()=>wYe,content_3652_6848:()=>gYe,content_3652_6850:()=>LYe,content_3652_6852:()=>NYe,content_3652_6854:()=>WYe,content_3652_6856:()=>PYe,content_3652_6858:()=>GYe,content_3652_686:()=>frt,content_3652_6860:()=>BYe,content_3652_6862:()=>qYe,content_3652_6864:()=>QYe,content_3652_6866:()=>KYe,content_3652_6868:()=>nQe,content_3652_6870:()=>pQe,content_3652_6872:()=>cQe,content_3652_6874:()=>lQe,content_3652_6876:()=>dQe,content_3652_6878:()=>fQe,content_3652_688:()=>Drt,content_3652_6880:()=>DQe,content_3652_6882:()=>wQe,content_3652_6884:()=>gQe,content_3652_6886:()=>LQe,content_3652_6888:()=>NQe,content_3652_6890:()=>WQe,content_3652_6892:()=>PQe,content_3652_6894:()=>GQe,content_3652_6896:()=>BQe,content_3652_6898:()=>qQe,content_3652_690:()=>wrt,content_3652_6900:()=>QQe,content_3652_6902:()=>KQe,content_3652_6904:()=>nHe,content_3652_6906:()=>pHe,content_3652_6908:()=>cHe,content_3652_6910:()=>lHe,content_3652_6912:()=>dHe,content_3652_6914:()=>fHe,content_3652_6916:()=>DHe,content_3652_6918:()=>wHe,content_3652_692:()=>grt,content_3652_6920:()=>gHe,content_3652_6922:()=>LHe,content_3652_6924:()=>NHe,content_3652_6926:()=>WHe,content_3652_6928:()=>PHe,content_3652_6930:()=>GHe,content_3652_6932:()=>BHe,content_3652_6934:()=>qHe,content_3652_6936:()=>QHe,content_3652_6938:()=>KHe,content_3652_694:()=>Lrt,content_3652_6940:()=>n$e,content_3652_6942:()=>p$e,content_3652_6944:()=>c$e,content_3652_6946:()=>l$e,content_3652_6948:()=>d$e,content_3652_6950:()=>f$e,content_3652_6952:()=>D$e,content_3652_6954:()=>w$e,content_3652_6956:()=>g$e,content_3652_6958:()=>L$e,content_3652_696:()=>Nrt,content_3652_6960:()=>N$e,content_3652_6962:()=>W$e,content_3652_6964:()=>P$e,content_3652_6966:()=>G$e,content_3652_6968:()=>B$e,content_3652_6970:()=>q$e,content_3652_6972:()=>Q$e,content_3652_6974:()=>K$e,content_3652_6976:()=>nKe,content_3652_6978:()=>pKe,content_3652_698:()=>Wrt,content_3652_6980:()=>cKe,content_3652_6982:()=>lKe,content_3652_6984:()=>dKe,content_3652_6986:()=>fKe,content_3652_6988:()=>DKe,content_3652_6990:()=>wKe,content_3652_6992:()=>gKe,content_3652_6994:()=>LKe,content_3652_6996:()=>NKe,content_3652_6998:()=>WKe,content_3652_70:()=>aK,content_3652_700:()=>Prt,content_3652_7000:()=>PKe,content_3652_7002:()=>GKe,content_3652_7004:()=>BKe,content_3652_7006:()=>qKe,content_3652_7008:()=>QKe,content_3652_7010:()=>KKe,content_3652_7012:()=>nJe,content_3652_7014:()=>pJe,content_3652_7016:()=>cJe,content_3652_7018:()=>lJe,content_3652_702:()=>Grt,content_3652_7020:()=>dJe,content_3652_7022:()=>fJe,content_3652_7024:()=>DJe,content_3652_7026:()=>wJe,content_3652_7028:()=>gJe,content_3652_7030:()=>LJe,content_3652_7032:()=>NJe,content_3652_7034:()=>WJe,content_3652_7036:()=>PJe,content_3652_7038:()=>GJe,content_3652_704:()=>Brt,content_3652_7040:()=>BJe,content_3652_7042:()=>qJe,content_3652_7044:()=>QJe,content_3652_7046:()=>KJe,content_3652_7048:()=>n0e,content_3652_7050:()=>p0e,content_3652_7052:()=>c0e,content_3652_7054:()=>l0e,content_3652_7056:()=>d0e,content_3652_7058:()=>f0e,content_3652_706:()=>qrt,content_3652_7060:()=>D0e,content_3652_7062:()=>w0e,content_3652_7064:()=>g0e,content_3652_7066:()=>L0e,content_3652_7068:()=>N0e,content_3652_7070:()=>W0e,content_3652_7072:()=>P0e,content_3652_7074:()=>G0e,content_3652_7076:()=>B0e,content_3652_7078:()=>q0e,content_3652_708:()=>Qrt,content_3652_7080:()=>Q0e,content_3652_7082:()=>K0e,content_3652_7084:()=>n2e,content_3652_7086:()=>p2e,content_3652_7088:()=>c2e,content_3652_7090:()=>l2e,content_3652_7092:()=>d2e,content_3652_7094:()=>f2e,content_3652_7096:()=>D2e,content_3652_7098:()=>w2e,content_3652_710:()=>Krt,content_3652_7100:()=>g2e,content_3652_7102:()=>L2e,content_3652_7104:()=>N2e,content_3652_7106:()=>W2e,content_3652_7108:()=>P2e,content_3652_7110:()=>G2e,content_3652_7112:()=>B2e,content_3652_7114:()=>q2e,content_3652_7116:()=>Q2e,content_3652_7118:()=>K2e,content_3652_712:()=>nst,content_3652_7120:()=>n6e,content_3652_7122:()=>p6e,content_3652_7124:()=>c6e,content_3652_7126:()=>l6e,content_3652_7128:()=>d6e,content_3652_7130:()=>f6e,content_3652_7132:()=>D6e,content_3652_7134:()=>w6e,content_3652_7136:()=>g6e,content_3652_7138:()=>L6e,content_3652_714:()=>pst,content_3652_7140:()=>N6e,content_3652_7142:()=>W6e,content_3652_7144:()=>P6e,content_3652_7146:()=>G6e,content_3652_7148:()=>B6e,content_3652_7150:()=>q6e,content_3652_7152:()=>Q6e,content_3652_7154:()=>K6e,content_3652_7156:()=>n3e,content_3652_7158:()=>p3e,content_3652_716:()=>cst,content_3652_7160:()=>c3e,content_3652_7162:()=>l3e,content_3652_7164:()=>d3e,content_3652_7166:()=>f3e,content_3652_7168:()=>D3e,content_3652_7170:()=>w3e,content_3652_7172:()=>g3e,content_3652_7174:()=>L3e,content_3652_7176:()=>N3e,content_3652_7178:()=>W3e,content_3652_718:()=>lst,content_3652_7180:()=>P3e,content_3652_7182:()=>G3e,content_3652_7184:()=>B3e,content_3652_7186:()=>q3e,content_3652_7188:()=>Q3e,content_3652_7190:()=>K3e,content_3652_7192:()=>n5e,content_3652_7194:()=>p5e,content_3652_7196:()=>c5e,content_3652_7198:()=>l5e,content_3652_72:()=>mK,content_3652_720:()=>dst,content_3652_7200:()=>d5e,content_3652_7202:()=>f5e,content_3652_7204:()=>D5e,content_3652_7206:()=>w5e,content_3652_7208:()=>g5e,content_3652_7210:()=>L5e,content_3652_7212:()=>N5e,content_3652_7214:()=>W5e,content_3652_7216:()=>P5e,content_3652_7218:()=>G5e,content_3652_722:()=>fst,content_3652_7220:()=>B5e,content_3652_7222:()=>q5e,content_3652_7224:()=>Q5e,content_3652_7226:()=>K5e,content_3652_7228:()=>n1e,content_3652_7230:()=>p1e,content_3652_7232:()=>c1e,content_3652_7234:()=>l1e,content_3652_7236:()=>d1e,content_3652_7238:()=>f1e,content_3652_724:()=>Dst,content_3652_7240:()=>D1e,content_3652_7242:()=>w1e,content_3652_7244:()=>g1e,content_3652_7246:()=>L1e,content_3652_7248:()=>N1e,content_3652_7250:()=>W1e,content_3652_7252:()=>P1e,content_3652_7254:()=>G1e,content_3652_7256:()=>B1e,content_3652_7258:()=>q1e,content_3652_726:()=>wst,content_3652_7260:()=>Q1e,content_3652_7262:()=>K1e,content_3652_7264:()=>n4e,content_3652_7266:()=>p4e,content_3652_7268:()=>c4e,content_3652_7270:()=>l4e,content_3652_7272:()=>d4e,content_3652_7274:()=>f4e,content_3652_7276:()=>D4e,content_3652_7278:()=>w4e,content_3652_728:()=>gst,content_3652_7280:()=>g4e,content_3652_7282:()=>L4e,content_3652_7284:()=>N4e,content_3652_7286:()=>W4e,content_3652_7288:()=>P4e,content_3652_7290:()=>G4e,content_3652_7292:()=>B4e,content_3652_7294:()=>q4e,content_3652_7296:()=>Q4e,content_3652_7298:()=>K4e,content_3652_730:()=>Lst,content_3652_7300:()=>n8e,content_3652_7302:()=>p8e,content_3652_7304:()=>c8e,content_3652_7306:()=>l8e,content_3652_7308:()=>d8e,content_3652_7310:()=>f8e,content_3652_7312:()=>D8e,content_3652_7314:()=>w8e,content_3652_7316:()=>g8e,content_3652_7318:()=>L8e,content_3652_732:()=>Nst,content_3652_7320:()=>N8e,content_3652_7322:()=>W8e,content_3652_7324:()=>P8e,content_3652_7326:()=>G8e,content_3652_7328:()=>B8e,content_3652_7330:()=>q8e,content_3652_7332:()=>Q8e,content_3652_7334:()=>K8e,content_3652_7336:()=>n7e,content_3652_7338:()=>p7e,content_3652_734:()=>Wst,content_3652_7340:()=>c7e,content_3652_7342:()=>l7e,content_3652_7344:()=>d7e,content_3652_7346:()=>f7e,content_3652_7348:()=>D7e,content_3652_7350:()=>w7e,content_3652_7352:()=>g7e,content_3652_7354:()=>L7e,content_3652_7356:()=>N7e,content_3652_7358:()=>W7e,content_3652_736:()=>Pst,content_3652_7360:()=>P7e,content_3652_7362:()=>G7e,content_3652_7364:()=>B7e,content_3652_7366:()=>q7e,content_3652_7368:()=>Q7e,content_3652_7370:()=>K7e,content_3652_7372:()=>n9e,content_3652_7374:()=>p9e,content_3652_7376:()=>c9e,content_3652_7378:()=>l9e,content_3652_738:()=>Gst,content_3652_7380:()=>d9e,content_3652_7382:()=>f9e,content_3652_7384:()=>D9e,content_3652_7386:()=>w9e,content_3652_7388:()=>g9e,content_3652_7390:()=>L9e,content_3652_7392:()=>N9e,content_3652_7394:()=>W9e,content_3652_7396:()=>P9e,content_3652_7398:()=>G9e,content_3652_74:()=>kK,content_3652_740:()=>Bst,content_3652_7400:()=>B9e,content_3652_7402:()=>q9e,content_3652_7404:()=>Q9e,content_3652_7406:()=>K9e,content_3652_7408:()=>nto,content_3652_7410:()=>pto,content_3652_7412:()=>cto,content_3652_7414:()=>lto,content_3652_7416:()=>dto,content_3652_7418:()=>fto,content_3652_742:()=>qst,content_3652_7420:()=>Dto,content_3652_7422:()=>wto,content_3652_7424:()=>gto,content_3652_7426:()=>Lto,content_3652_7428:()=>Nto,content_3652_7430:()=>Wto,content_3652_7432:()=>Pto,content_3652_7434:()=>Gto,content_3652_7436:()=>Bto,content_3652_7438:()=>qto,content_3652_744:()=>Qst,content_3652_7440:()=>Qto,content_3652_7442:()=>Kto,content_3652_7444:()=>nno,content_3652_7446:()=>pno,content_3652_7448:()=>cno,content_3652_7450:()=>lno,content_3652_7452:()=>dno,content_3652_7454:()=>fno,content_3652_7456:()=>Dno,content_3652_7458:()=>wno,content_3652_746:()=>Kst,content_3652_7460:()=>gno,content_3652_7462:()=>Lno,content_3652_7464:()=>Nno,content_3652_7466:()=>Wno,content_3652_7468:()=>Pno,content_3652_7470:()=>Gno,content_3652_7472:()=>Bno,content_3652_7474:()=>qno,content_3652_7476:()=>Qno,content_3652_7478:()=>Kno,content_3652_748:()=>nct,content_3652_7480:()=>neo,content_3652_7482:()=>peo,content_3652_7484:()=>ceo,content_3652_7486:()=>leo,content_3652_7488:()=>deo,content_3652_7490:()=>feo,content_3652_7492:()=>Deo,content_3652_7494:()=>weo,content_3652_7496:()=>geo,content_3652_7498:()=>Leo,content_3652_750:()=>pct,content_3652_7500:()=>Neo,content_3652_7502:()=>Weo,content_3652_7504:()=>Peo,content_3652_7506:()=>Geo,content_3652_7508:()=>Beo,content_3652_7510:()=>qeo,content_3652_7512:()=>Qeo,content_3652_7514:()=>Keo,content_3652_7516:()=>noo,content_3652_7518:()=>poo,content_3652_752:()=>cct,content_3652_7520:()=>coo,content_3652_7522:()=>loo,content_3652_7524:()=>doo,content_3652_7526:()=>foo,content_3652_7528:()=>Doo,content_3652_7530:()=>woo,content_3652_7532:()=>goo,content_3652_7534:()=>Loo,content_3652_7536:()=>Noo,content_3652_7538:()=>Woo,content_3652_754:()=>lct,content_3652_7540:()=>Poo,content_3652_7542:()=>Goo,content_3652_7544:()=>Boo,content_3652_7546:()=>qoo,content_3652_7548:()=>Qoo,content_3652_7550:()=>Koo,content_3652_7552:()=>npo,content_3652_7554:()=>ppo,content_3652_7556:()=>cpo,content_3652_7558:()=>lpo,content_3652_756:()=>dct,content_3652_7560:()=>dpo,content_3652_7562:()=>fpo,content_3652_7564:()=>Dpo,content_3652_7566:()=>wpo,content_3652_7568:()=>gpo,content_3652_7570:()=>Lpo,content_3652_7572:()=>Npo,content_3652_7574:()=>Wpo,content_3652_7576:()=>Ppo,content_3652_7578:()=>Gpo,content_3652_758:()=>fct,content_3652_7580:()=>Bpo,content_3652_7582:()=>qpo,content_3652_7584:()=>Qpo,content_3652_7586:()=>Kpo,content_3652_7588:()=>nro,content_3652_7590:()=>pro,content_3652_7592:()=>cro,content_3652_7594:()=>lro,content_3652_7596:()=>dro,content_3652_7598:()=>fro,content_3652_76:()=>MK,content_3652_760:()=>Dct,content_3652_7600:()=>Dro,content_3652_7602:()=>wro,content_3652_7604:()=>gro,content_3652_7606:()=>Lro,content_3652_7608:()=>Nro,content_3652_7610:()=>Wro,content_3652_7612:()=>Pro,content_3652_7614:()=>Gro,content_3652_7616:()=>Bro,content_3652_7618:()=>qro,content_3652_762:()=>wct,content_3652_7620:()=>Qro,content_3652_7622:()=>Kro,content_3652_7624:()=>nso,content_3652_7626:()=>pso,content_3652_7628:()=>cso,content_3652_7630:()=>lso,content_3652_7632:()=>dso,content_3652_7634:()=>fso,content_3652_7636:()=>Dso,content_3652_7638:()=>wso,content_3652_764:()=>gct,content_3652_7640:()=>gso,content_3652_7642:()=>Lso,content_3652_7644:()=>Nso,content_3652_7646:()=>Wso,content_3652_7648:()=>Pso,content_3652_7650:()=>Gso,content_3652_7652:()=>Bso,content_3652_7654:()=>qso,content_3652_7656:()=>Qso,content_3652_7658:()=>Kso,content_3652_766:()=>Lct,content_3652_7660:()=>nco,content_3652_7662:()=>pco,content_3652_7664:()=>cco,content_3652_7666:()=>lco,content_3652_7668:()=>dco,content_3652_7670:()=>fco,content_3652_7672:()=>Dco,content_3652_7674:()=>wco,content_3652_7676:()=>gco,content_3652_7678:()=>Lco,content_3652_768:()=>Nct,content_3652_7680:()=>Nco,content_3652_7682:()=>Wco,content_3652_7684:()=>Pco,content_3652_7686:()=>Gco,content_3652_7688:()=>Bco,content_3652_7690:()=>qco,content_3652_7692:()=>Qco,content_3652_7694:()=>Kco,content_3652_7696:()=>nio,content_3652_7698:()=>pio,content_3652_770:()=>Wct,content_3652_7700:()=>cio,content_3652_7702:()=>lio,content_3652_7704:()=>dio,content_3652_7706:()=>fio,content_3652_7708:()=>Dio,content_3652_7710:()=>wio,content_3652_7712:()=>gio,content_3652_7714:()=>Lio,content_3652_7716:()=>Nio,content_3652_7718:()=>Wio,content_3652_772:()=>Pct,content_3652_7720:()=>Pio,content_3652_7722:()=>Gio,content_3652_7724:()=>Bio,content_3652_7726:()=>qio,content_3652_7728:()=>Qio,content_3652_7730:()=>Kio,content_3652_7732:()=>nao,content_3652_7734:()=>pao,content_3652_7736:()=>cao,content_3652_7738:()=>lao,content_3652_774:()=>Gct,content_3652_7740:()=>dao,content_3652_7742:()=>fao,content_3652_7744:()=>Dao,content_3652_7746:()=>wao,content_3652_7748:()=>gao,content_3652_7750:()=>Lao,content_3652_7752:()=>Nao,content_3652_7754:()=>Wao,content_3652_7756:()=>Pao,content_3652_7758:()=>Gao,content_3652_776:()=>Bct,content_3652_7760:()=>Bao,content_3652_7762:()=>qao,content_3652_7764:()=>Qao,content_3652_7766:()=>Kao,content_3652_7768:()=>nlo,content_3652_7770:()=>plo,content_3652_7772:()=>clo,content_3652_7774:()=>llo,content_3652_7776:()=>dlo,content_3652_7778:()=>flo,content_3652_778:()=>qct,content_3652_7780:()=>Dlo,content_3652_7782:()=>wlo,content_3652_7784:()=>glo,content_3652_7786:()=>Llo,content_3652_7788:()=>Nlo,content_3652_7790:()=>Wlo,content_3652_7792:()=>Plo,content_3652_7794:()=>Glo,content_3652_7796:()=>Blo,content_3652_7798:()=>qlo,content_3652_78:()=>_K,content_3652_780:()=>Qct,content_3652_7800:()=>Qlo,content_3652_7802:()=>Klo,content_3652_7804:()=>nuo,content_3652_7806:()=>puo,content_3652_7808:()=>cuo,content_3652_7810:()=>luo,content_3652_7812:()=>duo,content_3652_7814:()=>fuo,content_3652_7816:()=>Duo,content_3652_7818:()=>wuo,content_3652_782:()=>Kct,content_3652_7820:()=>guo,content_3652_7822:()=>Luo,content_3652_7824:()=>Nuo,content_3652_7826:()=>Wuo,content_3652_7828:()=>Puo,content_3652_7830:()=>Guo,content_3652_7832:()=>Buo,content_3652_7834:()=>quo,content_3652_7836:()=>Quo,content_3652_7838:()=>Kuo,content_3652_784:()=>nit,content_3652_7840:()=>nmo,content_3652_7842:()=>pmo,content_3652_7844:()=>cmo,content_3652_7846:()=>lmo,content_3652_7848:()=>dmo,content_3652_7850:()=>fmo,content_3652_7852:()=>Dmo,content_3652_7854:()=>wmo,content_3652_7856:()=>gmo,content_3652_7858:()=>Lmo,content_3652_786:()=>pit,content_3652_7860:()=>Nmo,content_3652_7862:()=>Wmo,content_3652_7864:()=>Pmo,content_3652_7866:()=>Gmo,content_3652_7868:()=>Bmo,content_3652_7870:()=>qmo,content_3652_7872:()=>Qmo,content_3652_7874:()=>Kmo,content_3652_7876:()=>ndo,content_3652_7878:()=>pdo,content_3652_788:()=>cit,content_3652_7880:()=>cdo,content_3652_7882:()=>ldo,content_3652_7884:()=>ddo,content_3652_7886:()=>fdo,content_3652_7888:()=>Ddo,content_3652_7890:()=>wdo,content_3652_7892:()=>gdo,content_3652_7894:()=>Ldo,content_3652_7896:()=>Ndo,content_3652_7898:()=>Wdo,content_3652_790:()=>lit,content_3652_7900:()=>Pdo,content_3652_7902:()=>Gdo,content_3652_7904:()=>Bdo,content_3652_7906:()=>qdo,content_3652_7908:()=>Qdo,content_3652_7910:()=>Kdo,content_3652_7912:()=>nho,content_3652_7914:()=>pho,content_3652_7916:()=>cho,content_3652_7918:()=>lho,content_3652_792:()=>dit,content_3652_7920:()=>dho,content_3652_7922:()=>fho,content_3652_7924:()=>Dho,content_3652_7926:()=>who,content_3652_7928:()=>gho,content_3652_7930:()=>Lho,content_3652_7932:()=>Nho,content_3652_7934:()=>Who,content_3652_7936:()=>Pho,content_3652_7938:()=>Gho,content_3652_794:()=>fit,content_3652_7940:()=>Bho,content_3652_7942:()=>qho,content_3652_7944:()=>Qho,content_3652_7946:()=>Kho,content_3652_7948:()=>nko,content_3652_7950:()=>pko,content_3652_7952:()=>cko,content_3652_7954:()=>lko,content_3652_7956:()=>dko,content_3652_7958:()=>fko,content_3652_796:()=>Dit,content_3652_7960:()=>Dko,content_3652_7962:()=>wko,content_3652_7964:()=>gko,content_3652_7966:()=>Lko,content_3652_7968:()=>Nko,content_3652_7970:()=>Wko,content_3652_7972:()=>Pko,content_3652_7974:()=>Gko,content_3652_7976:()=>Bko,content_3652_7978:()=>qko,content_3652_798:()=>wit,content_3652_7980:()=>Qko,content_3652_7982:()=>Kko,content_3652_7984:()=>nfo,content_3652_7986:()=>pfo,content_3652_7988:()=>cfo,content_3652_7990:()=>lfo,content_3652_7992:()=>dfo,content_3652_7994:()=>ffo,content_3652_7996:()=>Dfo,content_3652_7998:()=>wfo,content_3652_8:()=>CH,content_3652_80:()=>CK,content_3652_800:()=>git,content_3652_8000:()=>gfo,content_3652_8002:()=>Lfo,content_3652_8004:()=>Nfo,content_3652_8006:()=>Wfo,content_3652_8008:()=>Pfo,content_3652_8010:()=>Gfo,content_3652_8012:()=>Bfo,content_3652_8014:()=>qfo,content_3652_8016:()=>Qfo,content_3652_8018:()=>Kfo,content_3652_802:()=>Lit,content_3652_8020:()=>nyo,content_3652_8022:()=>pyo,content_3652_8024:()=>cyo,content_3652_8026:()=>lyo,content_3652_8028:()=>dyo,content_3652_8030:()=>fyo,content_3652_8032:()=>Dyo,content_3652_8034:()=>wyo,content_3652_8036:()=>gyo,content_3652_8038:()=>Lyo,content_3652_804:()=>Nit,content_3652_8040:()=>Nyo,content_3652_8042:()=>Wyo,content_3652_8044:()=>Pyo,content_3652_8046:()=>Gyo,content_3652_8048:()=>Byo,content_3652_8050:()=>qyo,content_3652_8052:()=>Qyo,content_3652_8054:()=>Kyo,content_3652_8056:()=>nMo,content_3652_8058:()=>pMo,content_3652_806:()=>Wit,content_3652_8060:()=>cMo,content_3652_8062:()=>lMo,content_3652_8064:()=>dMo,content_3652_8066:()=>fMo,content_3652_8068:()=>DMo,content_3652_8070:()=>wMo,content_3652_8072:()=>gMo,content_3652_8074:()=>LMo,content_3652_8076:()=>NMo,content_3652_8078:()=>WMo,content_3652_808:()=>Pit,content_3652_8080:()=>PMo,content_3652_8082:()=>GMo,content_3652_8084:()=>BMo,content_3652_8086:()=>qMo,content_3652_8088:()=>QMo,content_3652_8090:()=>KMo,content_3652_8092:()=>nDo,content_3652_8094:()=>pDo,content_3652_8096:()=>cDo,content_3652_8098:()=>lDo,content_3652_810:()=>Git,content_3652_8100:()=>dDo,content_3652_8102:()=>fDo,content_3652_8104:()=>DDo,content_3652_8106:()=>wDo,content_3652_8108:()=>gDo,content_3652_8110:()=>LDo,content_3652_8112:()=>NDo,content_3652_8114:()=>WDo,content_3652_8116:()=>PDo,content_3652_8118:()=>GDo,content_3652_812:()=>Bit,content_3652_8120:()=>BDo,content_3652_8122:()=>qDo,content_3652_8124:()=>QDo,content_3652_8126:()=>KDo,content_3652_8128:()=>nXo,content_3652_8130:()=>pXo,content_3652_8132:()=>cXo,content_3652_8134:()=>lXo,content_3652_8136:()=>dXo,content_3652_8138:()=>fXo,content_3652_814:()=>qit,content_3652_8140:()=>DXo,content_3652_8142:()=>wXo,content_3652_8144:()=>gXo,content_3652_8146:()=>LXo,content_3652_8148:()=>NXo,content_3652_8150:()=>WXo,content_3652_8152:()=>PXo,content_3652_8154:()=>GXo,content_3652_8156:()=>BXo,content_3652_8158:()=>qXo,content_3652_816:()=>Qit,content_3652_8160:()=>QXo,content_3652_8162:()=>KXo,content_3652_8164:()=>n_o,content_3652_8166:()=>p_o,content_3652_8168:()=>c_o,content_3652_8170:()=>l_o,content_3652_8172:()=>d_o,content_3652_8174:()=>f_o,content_3652_8176:()=>D_o,content_3652_8178:()=>w_o,content_3652_818:()=>Kit,content_3652_8180:()=>g_o,content_3652_8182:()=>L_o,content_3652_8184:()=>N_o,content_3652_8186:()=>W_o,content_3652_8188:()=>P_o,content_3652_8190:()=>G_o,content_3652_8192:()=>B_o,content_3652_8194:()=>q_o,content_3652_8196:()=>Q_o,content_3652_8198:()=>K_o,content_3652_82:()=>vK,content_3652_820:()=>nat,content_3652_8200:()=>nwo,content_3652_8202:()=>pwo,content_3652_8204:()=>cwo,content_3652_8206:()=>lwo,content_3652_8208:()=>dwo,content_3652_8210:()=>fwo,content_3652_8212:()=>Dwo,content_3652_8214:()=>wwo,content_3652_8216:()=>gwo,content_3652_8218:()=>Lwo,content_3652_822:()=>pat,content_3652_8220:()=>Nwo,content_3652_8222:()=>Wwo,content_3652_8224:()=>Pwo,content_3652_8226:()=>Gwo,content_3652_8228:()=>Bwo,content_3652_8230:()=>qwo,content_3652_8232:()=>Qwo,content_3652_8234:()=>Kwo,content_3652_8236:()=>nTo,content_3652_8238:()=>pTo,content_3652_824:()=>cat,content_3652_8240:()=>cTo,content_3652_8242:()=>lTo,content_3652_8244:()=>dTo,content_3652_8246:()=>fTo,content_3652_8248:()=>DTo,content_3652_8250:()=>wTo,content_3652_8252:()=>gTo,content_3652_8254:()=>LTo,content_3652_8256:()=>NTo,content_3652_8258:()=>WTo,content_3652_826:()=>lat,content_3652_8260:()=>PTo,content_3652_8262:()=>GTo,content_3652_8264:()=>BTo,content_3652_8266:()=>qTo,content_3652_8268:()=>QTo,content_3652_8270:()=>KTo,content_3652_8272:()=>nCo,content_3652_8274:()=>pCo,content_3652_8276:()=>cCo,content_3652_8278:()=>lCo,content_3652_828:()=>dat,content_3652_8280:()=>dCo,content_3652_8282:()=>fCo,content_3652_8284:()=>DCo,content_3652_8286:()=>wCo,content_3652_8288:()=>gCo,content_3652_8290:()=>LCo,content_3652_8292:()=>NCo,content_3652_8294:()=>WCo,content_3652_8296:()=>PCo,content_3652_8298:()=>GCo,content_3652_830:()=>fat,content_3652_8300:()=>BCo,content_3652_8302:()=>qCo,content_3652_8304:()=>QCo,content_3652_8306:()=>KCo,content_3652_8308:()=>ngo,content_3652_8310:()=>pgo,content_3652_8312:()=>cgo,content_3652_8314:()=>lgo,content_3652_8316:()=>dgo,content_3652_8318:()=>fgo,content_3652_832:()=>Dat,content_3652_8320:()=>Dgo,content_3652_8322:()=>wgo,content_3652_8324:()=>ggo,content_3652_8326:()=>Lgo,content_3652_8328:()=>Ngo,content_3652_8330:()=>Wgo,content_3652_8332:()=>Pgo,content_3652_8334:()=>Ggo,content_3652_8336:()=>Bgo,content_3652_8338:()=>qgo,content_3652_834:()=>wat,content_3652_8340:()=>Qgo,content_3652_8342:()=>Kgo,content_3652_8344:()=>nxo,content_3652_8346:()=>pxo,content_3652_8348:()=>cxo,content_3652_8350:()=>lxo,content_3652_8352:()=>dxo,content_3652_8354:()=>fxo,content_3652_8356:()=>Dxo,content_3652_8358:()=>wxo,content_3652_836:()=>gat,content_3652_8360:()=>gxo,content_3652_8362:()=>Lxo,content_3652_8364:()=>Nxo,content_3652_8366:()=>Wxo,content_3652_8368:()=>Pxo,content_3652_8370:()=>Gxo,content_3652_8372:()=>Bxo,content_3652_8374:()=>qxo,content_3652_8376:()=>Qxo,content_3652_8378:()=>Kxo,content_3652_838:()=>Lat,content_3652_8380:()=>nvo,content_3652_8382:()=>pvo,content_3652_8384:()=>cvo,content_3652_8386:()=>lvo,content_3652_8388:()=>dvo,content_3652_8390:()=>fvo,content_3652_8392:()=>Dvo,content_3652_8394:()=>wvo,content_3652_8396:()=>gvo,content_3652_8398:()=>Lvo,content_3652_84:()=>bK,content_3652_840:()=>Nat,content_3652_8400:()=>Nvo,content_3652_8402:()=>Wvo,content_3652_8404:()=>Pvo,content_3652_8406:()=>Gvo,content_3652_8408:()=>Bvo,content_3652_8410:()=>qvo,content_3652_8412:()=>Qvo,content_3652_8414:()=>Kvo,content_3652_8416:()=>nLo,content_3652_8418:()=>pLo,content_3652_842:()=>Wat,content_3652_8420:()=>cLo,content_3652_8422:()=>lLo,content_3652_8424:()=>dLo,content_3652_8426:()=>fLo,content_3652_8428:()=>DLo,content_3652_8430:()=>wLo,content_3652_8432:()=>gLo,content_3652_8434:()=>LLo,content_3652_8436:()=>NLo,content_3652_8438:()=>WLo,content_3652_844:()=>Pat,content_3652_8440:()=>PLo,content_3652_8442:()=>GLo,content_3652_8444:()=>BLo,content_3652_8446:()=>qLo,content_3652_8448:()=>QLo,content_3652_8450:()=>KLo,content_3652_8452:()=>nZo,content_3652_8454:()=>pZo,content_3652_8456:()=>cZo,content_3652_8458:()=>lZo,content_3652_846:()=>Gat,content_3652_8460:()=>dZo,content_3652_8462:()=>fZo,content_3652_8464:()=>DZo,content_3652_8466:()=>wZo,content_3652_8468:()=>gZo,content_3652_8470:()=>LZo,content_3652_8472:()=>NZo,content_3652_8474:()=>WZo,content_3652_8476:()=>PZo,content_3652_8478:()=>GZo,content_3652_848:()=>Bat,content_3652_8480:()=>BZo,content_3652_8482:()=>qZo,content_3652_8484:()=>QZo,content_3652_8486:()=>KZo,content_3652_8488:()=>nbo,content_3652_8490:()=>pbo,content_3652_8492:()=>cbo,content_3652_8494:()=>lbo,content_3652_8496:()=>dbo,content_3652_8498:()=>fbo,content_3652_850:()=>qat,content_3652_8500:()=>Dbo,content_3652_8502:()=>wbo,content_3652_8504:()=>gbo,content_3652_8506:()=>Lbo,content_3652_8508:()=>Nbo,content_3652_8510:()=>Wbo,content_3652_8512:()=>Pbo,content_3652_8514:()=>Gbo,content_3652_8516:()=>Bbo,content_3652_8518:()=>qbo,content_3652_852:()=>Qat,content_3652_8520:()=>Qbo,content_3652_8522:()=>Kbo,content_3652_8524:()=>nNo,content_3652_8526:()=>pNo,content_3652_8528:()=>cNo,content_3652_8530:()=>lNo,content_3652_8532:()=>dNo,content_3652_8534:()=>fNo,content_3652_8536:()=>DNo,content_3652_8538:()=>wNo,content_3652_854:()=>Kat,content_3652_8540:()=>gNo,content_3652_8542:()=>LNo,content_3652_8544:()=>NNo,content_3652_8546:()=>WNo,content_3652_8548:()=>PNo,content_3652_8550:()=>GNo,content_3652_8552:()=>BNo,content_3652_8554:()=>qNo,content_3652_8556:()=>QNo,content_3652_8558:()=>KNo,content_3652_856:()=>nlt,content_3652_8560:()=>nAo,content_3652_8562:()=>pAo,content_3652_8564:()=>cAo,content_3652_8566:()=>lAo,content_3652_8568:()=>dAo,content_3652_8570:()=>fAo,content_3652_8572:()=>DAo,content_3652_8574:()=>wAo,content_3652_8576:()=>gAo,content_3652_8578:()=>LAo,content_3652_858:()=>plt,content_3652_8580:()=>NAo,content_3652_8582:()=>WAo,content_3652_8584:()=>PAo,content_3652_8586:()=>GAo,content_3652_8588:()=>BAo,content_3652_8590:()=>qAo,content_3652_8592:()=>QAo,content_3652_8594:()=>KAo,content_3652_8596:()=>nzo,content_3652_8598:()=>pzo,content_3652_86:()=>zK,content_3652_860:()=>clt,content_3652_8600:()=>czo,content_3652_8602:()=>lzo,content_3652_8604:()=>dzo,content_3652_8606:()=>fzo,content_3652_8608:()=>Dzo,content_3652_8610:()=>wzo,content_3652_8612:()=>gzo,content_3652_8614:()=>Lzo,content_3652_8616:()=>Nzo,content_3652_8618:()=>Wzo,content_3652_862:()=>llt,content_3652_8620:()=>Pzo,content_3652_8622:()=>Gzo,content_3652_8624:()=>Bzo,content_3652_8626:()=>qzo,content_3652_8628:()=>Qzo,content_3652_8630:()=>Kzo,content_3652_8632:()=>nWo,content_3652_8634:()=>pWo,content_3652_8636:()=>cWo,content_3652_8638:()=>lWo,content_3652_864:()=>dlt,content_3652_8640:()=>dWo,content_3652_8642:()=>fWo,content_3652_8644:()=>DWo,content_3652_8646:()=>wWo,content_3652_8648:()=>gWo,content_3652_8650:()=>LWo,content_3652_8652:()=>NWo,content_3652_8654:()=>WWo,content_3652_8656:()=>PWo,content_3652_8658:()=>GWo,content_3652_866:()=>flt,content_3652_8660:()=>BWo,content_3652_8662:()=>qWo,content_3652_8664:()=>QWo,content_3652_8666:()=>KWo,content_3652_8668:()=>nIo,content_3652_8670:()=>pIo,content_3652_8672:()=>cIo,content_3652_8674:()=>lIo,content_3652_8676:()=>dIo,content_3652_8678:()=>fIo,content_3652_868:()=>Dlt,content_3652_8680:()=>DIo,content_3652_8682:()=>wIo,content_3652_8684:()=>gIo,content_3652_8686:()=>LIo,content_3652_8688:()=>NIo,content_3652_8690:()=>WIo,content_3652_8692:()=>PIo,content_3652_8694:()=>GIo,content_3652_8696:()=>BIo,content_3652_8698:()=>qIo,content_3652_870:()=>wlt,content_3652_8700:()=>QIo,content_3652_8702:()=>KIo,content_3652_8704:()=>nRo,content_3652_8706:()=>pRo,content_3652_8708:()=>cRo,content_3652_8710:()=>lRo,content_3652_8712:()=>dRo,content_3652_8714:()=>fRo,content_3652_8716:()=>DRo,content_3652_8718:()=>wRo,content_3652_872:()=>glt,content_3652_8720:()=>gRo,content_3652_8722:()=>LRo,content_3652_8724:()=>NRo,content_3652_8726:()=>WRo,content_3652_8728:()=>PRo,content_3652_8730:()=>GRo,content_3652_8732:()=>BRo,content_3652_8734:()=>qRo,content_3652_8736:()=>QRo,content_3652_8738:()=>KRo,content_3652_874:()=>Llt,content_3652_8740:()=>nPo,content_3652_8742:()=>pPo,content_3652_8744:()=>cPo,content_3652_8746:()=>lPo,content_3652_8748:()=>dPo,content_3652_8750:()=>fPo,content_3652_8752:()=>DPo,content_3652_8754:()=>wPo,content_3652_8756:()=>gPo,content_3652_8758:()=>LPo,content_3652_876:()=>Nlt,content_3652_8760:()=>NPo,content_3652_8762:()=>WPo,content_3652_8764:()=>PPo,content_3652_8766:()=>GPo,content_3652_8768:()=>BPo,content_3652_8770:()=>qPo,content_3652_8772:()=>QPo,content_3652_8774:()=>KPo,content_3652_8776:()=>nSo,content_3652_8778:()=>pSo,content_3652_878:()=>Wlt,content_3652_8780:()=>cSo,content_3652_8782:()=>lSo,content_3652_8784:()=>dSo,content_3652_8786:()=>fSo,content_3652_8788:()=>DSo,content_3652_8790:()=>wSo,content_3652_8792:()=>gSo,content_3652_8794:()=>LSo,content_3652_8796:()=>NSo,content_3652_8798:()=>WSo,content_3652_88:()=>RK,content_3652_880:()=>Plt,content_3652_8800:()=>PSo,content_3652_8802:()=>GSo,content_3652_8804:()=>BSo,content_3652_8806:()=>qSo,content_3652_8808:()=>QSo,content_3652_8810:()=>KSo,content_3652_8812:()=>nEo,content_3652_8814:()=>pEo,content_3652_8816:()=>cEo,content_3652_8818:()=>lEo,content_3652_882:()=>Glt,content_3652_8820:()=>dEo,content_3652_8822:()=>fEo,content_3652_8824:()=>DEo,content_3652_8826:()=>wEo,content_3652_8828:()=>gEo,content_3652_8830:()=>LEo,content_3652_8832:()=>NEo,content_3652_8834:()=>WEo,content_3652_8836:()=>PEo,content_3652_8838:()=>GEo,content_3652_884:()=>Blt,content_3652_8840:()=>BEo,content_3652_8842:()=>qEo,content_3652_8844:()=>QEo,content_3652_8846:()=>KEo,content_3652_8848:()=>nGo,content_3652_8850:()=>pGo,content_3652_8852:()=>cGo,content_3652_8854:()=>lGo,content_3652_8856:()=>dGo,content_3652_8858:()=>fGo,content_3652_886:()=>qlt,content_3652_8860:()=>DGo,content_3652_8862:()=>wGo,content_3652_8864:()=>gGo,content_3652_8866:()=>LGo,content_3652_8868:()=>NGo,content_3652_8870:()=>WGo,content_3652_8872:()=>PGo,content_3652_8874:()=>GGo,content_3652_8876:()=>BGo,content_3652_8878:()=>qGo,content_3652_888:()=>Qlt,content_3652_8880:()=>QGo,content_3652_8882:()=>KGo,content_3652_8884:()=>nOo,content_3652_8886:()=>pOo,content_3652_8888:()=>cOo,content_3652_8890:()=>lOo,content_3652_8892:()=>dOo,content_3652_8894:()=>fOo,content_3652_8896:()=>DOo,content_3652_8898:()=>wOo,content_3652_890:()=>Klt,content_3652_8900:()=>gOo,content_3652_8902:()=>LOo,content_3652_8904:()=>NOo,content_3652_8906:()=>WOo,content_3652_8908:()=>POo,content_3652_8910:()=>GOo,content_3652_8912:()=>BOo,content_3652_8914:()=>qOo,content_3652_8916:()=>QOo,content_3652_8918:()=>KOo,content_3652_892:()=>nut,content_3652_8920:()=>nFo,content_3652_8922:()=>pFo,content_3652_8924:()=>cFo,content_3652_8926:()=>lFo,content_3652_8928:()=>dFo,content_3652_8930:()=>fFo,content_3652_8932:()=>DFo,content_3652_8934:()=>wFo,content_3652_8936:()=>gFo,content_3652_8938:()=>LFo,content_3652_894:()=>put,content_3652_8940:()=>NFo,content_3652_8942:()=>WFo,content_3652_8944:()=>PFo,content_3652_8946:()=>GFo,content_3652_8948:()=>BFo,content_3652_8950:()=>qFo,content_3652_8952:()=>QFo,content_3652_8954:()=>KFo,content_3652_8956:()=>nBo,content_3652_8958:()=>pBo,content_3652_896:()=>cut,content_3652_8960:()=>cBo,content_3652_8962:()=>lBo,content_3652_8964:()=>dBo,content_3652_8966:()=>fBo,content_3652_8968:()=>DBo,content_3652_8970:()=>wBo,content_3652_8972:()=>gBo,content_3652_8974:()=>LBo,content_3652_8976:()=>NBo,content_3652_8978:()=>WBo,content_3652_898:()=>lut,content_3652_8980:()=>PBo,content_3652_8982:()=>GBo,content_3652_8984:()=>BBo,content_3652_8986:()=>qBo,content_3652_8988:()=>QBo,content_3652_8990:()=>KBo,content_3652_8992:()=>nUo,content_3652_8994:()=>pUo,content_3652_8996:()=>cUo,content_3652_8998:()=>lUo,content_3652_90:()=>EK,content_3652_900:()=>dut,content_3652_9000:()=>dUo,content_3652_9002:()=>fUo,content_3652_9004:()=>DUo,content_3652_9006:()=>wUo,content_3652_9008:()=>gUo,content_3652_9010:()=>LUo,content_3652_9012:()=>NUo,content_3652_9014:()=>WUo,content_3652_9016:()=>PUo,content_3652_9018:()=>GUo,content_3652_902:()=>fut,content_3652_9020:()=>BUo,content_3652_9022:()=>qUo,content_3652_9024:()=>QUo,content_3652_9026:()=>KUo,content_3652_9028:()=>nVo,content_3652_9030:()=>pVo,content_3652_9032:()=>cVo,content_3652_9034:()=>lVo,content_3652_9036:()=>dVo,content_3652_9038:()=>fVo,content_3652_904:()=>Dut,content_3652_9040:()=>DVo,content_3652_9042:()=>wVo,content_3652_9044:()=>gVo,content_3652_9046:()=>LVo,content_3652_9048:()=>NVo,content_3652_9050:()=>WVo,content_3652_9052:()=>PVo,content_3652_9054:()=>GVo,content_3652_9056:()=>BVo,content_3652_9058:()=>qVo,content_3652_906:()=>wut,content_3652_9060:()=>QVo,content_3652_9062:()=>KVo,content_3652_9064:()=>nqo,content_3652_9066:()=>pqo,content_3652_9068:()=>cqo,content_3652_9070:()=>lqo,content_3652_9072:()=>dqo,content_3652_9074:()=>fqo,content_3652_9076:()=>Dqo,content_3652_9078:()=>wqo,content_3652_908:()=>gut,content_3652_9080:()=>gqo,content_3652_9082:()=>Lqo,content_3652_9084:()=>Nqo,content_3652_9086:()=>Wqo,content_3652_9088:()=>Pqo,content_3652_9090:()=>Gqo,content_3652_9092:()=>Bqo,content_3652_9094:()=>qqo,content_3652_9096:()=>Qqo,content_3652_9098:()=>Kqo,content_3652_910:()=>Lut,content_3652_9100:()=>njo,content_3652_9102:()=>pjo,content_3652_9104:()=>cjo,content_3652_9106:()=>ljo,content_3652_9108:()=>djo,content_3652_9110:()=>fjo,content_3652_9112:()=>Djo,content_3652_9114:()=>wjo,content_3652_9116:()=>gjo,content_3652_9118:()=>Ljo,content_3652_912:()=>Nut,content_3652_9120:()=>Njo,content_3652_9122:()=>Wjo,content_3652_9124:()=>Pjo,content_3652_9126:()=>Gjo,content_3652_9128:()=>Bjo,content_3652_9130:()=>qjo,content_3652_9132:()=>Qjo,content_3652_9134:()=>Kjo,content_3652_9136:()=>nYo,content_3652_9138:()=>pYo,content_3652_914:()=>Wut,content_3652_9140:()=>cYo,content_3652_9142:()=>lYo,content_3652_9144:()=>dYo,content_3652_9146:()=>fYo,content_3652_9148:()=>DYo,content_3652_9150:()=>wYo,content_3652_9152:()=>gYo,content_3652_9154:()=>LYo,content_3652_9156:()=>NYo,content_3652_9158:()=>WYo,content_3652_916:()=>Put,content_3652_9160:()=>PYo,content_3652_9162:()=>GYo,content_3652_9164:()=>BYo,content_3652_9166:()=>qYo,content_3652_9168:()=>QYo,content_3652_9170:()=>KYo,content_3652_9172:()=>nQo,content_3652_9174:()=>pQo,content_3652_9176:()=>cQo,content_3652_9178:()=>lQo,content_3652_918:()=>Gut,content_3652_9180:()=>dQo,content_3652_9182:()=>fQo,content_3652_9184:()=>DQo,content_3652_9186:()=>wQo,content_3652_9188:()=>gQo,content_3652_9190:()=>LQo,content_3652_9192:()=>NQo,content_3652_9194:()=>WQo,content_3652_9196:()=>PQo,content_3652_9198:()=>GQo,content_3652_92:()=>FK,content_3652_920:()=>But,content_3652_9200:()=>BQo,content_3652_9202:()=>qQo,content_3652_9204:()=>QQo,content_3652_9206:()=>KQo,content_3652_9208:()=>nHo,content_3652_9210:()=>pHo,content_3652_9212:()=>cHo,content_3652_9214:()=>lHo,content_3652_9216:()=>dHo,content_3652_9218:()=>fHo,content_3652_922:()=>qut,content_3652_9220:()=>DHo,content_3652_9222:()=>wHo,content_3652_9224:()=>gHo,content_3652_9226:()=>LHo,content_3652_9228:()=>NHo,content_3652_9230:()=>WHo,content_3652_9232:()=>PHo,content_3652_9234:()=>GHo,content_3652_9236:()=>BHo,content_3652_9238:()=>qHo,content_3652_924:()=>Qut,content_3652_9240:()=>QHo,content_3652_9242:()=>KHo,content_3652_9244:()=>n$o,content_3652_9246:()=>p$o,content_3652_9248:()=>c$o,content_3652_9250:()=>l$o,content_3652_9252:()=>d$o,content_3652_9254:()=>f$o,content_3652_9256:()=>D$o,content_3652_9258:()=>w$o,content_3652_926:()=>Kut,content_3652_9260:()=>g$o,content_3652_9262:()=>L$o,content_3652_9264:()=>N$o,content_3652_9266:()=>W$o,content_3652_9268:()=>P$o,content_3652_9270:()=>G$o,content_3652_9272:()=>B$o,content_3652_9274:()=>q$o,content_3652_9276:()=>Q$o,content_3652_9278:()=>K$o,content_3652_928:()=>nmt,content_3652_9280:()=>nKo,content_3652_9282:()=>pKo,content_3652_9284:()=>cKo,content_3652_9286:()=>lKo,content_3652_9288:()=>dKo,content_3652_9290:()=>fKo,content_3652_9292:()=>DKo,content_3652_9294:()=>wKo,content_3652_9296:()=>gKo,content_3652_9298:()=>LKo,content_3652_930:()=>pmt,content_3652_9300:()=>NKo,content_3652_9302:()=>WKo,content_3652_9304:()=>PKo,content_3652_9306:()=>GKo,content_3652_9308:()=>BKo,content_3652_9310:()=>qKo,content_3652_9312:()=>QKo,content_3652_9314:()=>KKo,content_3652_9316:()=>nJo,content_3652_9318:()=>pJo,content_3652_932:()=>cmt,content_3652_9320:()=>cJo,content_3652_9322:()=>lJo,content_3652_9324:()=>dJo,content_3652_9326:()=>fJo,content_3652_9328:()=>DJo,content_3652_9330:()=>wJo,content_3652_9332:()=>gJo,content_3652_9334:()=>LJo,content_3652_9336:()=>NJo,content_3652_9338:()=>WJo,content_3652_934:()=>lmt,content_3652_9340:()=>PJo,content_3652_9342:()=>GJo,content_3652_9344:()=>BJo,content_3652_9346:()=>qJo,content_3652_9348:()=>QJo,content_3652_9350:()=>KJo,content_3652_9352:()=>n0o,content_3652_9354:()=>p0o,content_3652_9356:()=>c0o,content_3652_9358:()=>l0o,content_3652_936:()=>dmt,content_3652_9360:()=>d0o,content_3652_9362:()=>f0o,content_3652_9364:()=>D0o,content_3652_9366:()=>w0o,content_3652_9368:()=>g0o,content_3652_9370:()=>L0o,content_3652_9372:()=>N0o,content_3652_9374:()=>W0o,content_3652_9376:()=>P0o,content_3652_9378:()=>G0o,content_3652_938:()=>fmt,content_3652_9380:()=>B0o,content_3652_9382:()=>q0o,content_3652_9384:()=>Q0o,content_3652_9386:()=>K0o,content_3652_9388:()=>n2o,content_3652_9390:()=>p2o,content_3652_9392:()=>c2o,content_3652_9394:()=>l2o,content_3652_9396:()=>d2o,content_3652_9398:()=>f2o,content_3652_94:()=>VK,content_3652_940:()=>Dmt,content_3652_9400:()=>D2o,content_3652_9402:()=>w2o,content_3652_9404:()=>g2o,content_3652_9406:()=>L2o,content_3652_9408:()=>N2o,content_3652_9410:()=>W2o,content_3652_9412:()=>P2o,content_3652_9414:()=>G2o,content_3652_9416:()=>B2o,content_3652_9418:()=>q2o,content_3652_942:()=>wmt,content_3652_9420:()=>Q2o,content_3652_9422:()=>K2o,content_3652_9424:()=>n6o,content_3652_9426:()=>p6o,content_3652_9428:()=>c6o,content_3652_9430:()=>l6o,content_3652_9432:()=>d6o,content_3652_9434:()=>f6o,content_3652_9436:()=>D6o,content_3652_9438:()=>w6o,content_3652_944:()=>gmt,content_3652_9440:()=>g6o,content_3652_9442:()=>L6o,content_3652_9444:()=>N6o,content_3652_9446:()=>W6o,content_3652_9448:()=>P6o,content_3652_9450:()=>G6o,content_3652_9452:()=>B6o,content_3652_9454:()=>q6o,content_3652_9456:()=>Q6o,content_3652_9458:()=>K6o,content_3652_946:()=>Lmt,content_3652_9460:()=>n3o,content_3652_9462:()=>p3o,content_3652_9464:()=>c3o,content_3652_9466:()=>l3o,content_3652_9468:()=>d3o,content_3652_9470:()=>f3o,content_3652_9472:()=>D3o,content_3652_9474:()=>w3o,content_3652_9476:()=>g3o,content_3652_9478:()=>L3o,content_3652_948:()=>Nmt,content_3652_9480:()=>N3o,content_3652_9482:()=>W3o,content_3652_9484:()=>P3o,content_3652_9486:()=>G3o,content_3652_9488:()=>B3o,content_3652_9490:()=>q3o,content_3652_9492:()=>Q3o,content_3652_9494:()=>K3o,content_3652_9496:()=>n5o,content_3652_9498:()=>p5o,content_3652_950:()=>Wmt,content_3652_9500:()=>c5o,content_3652_9502:()=>l5o,content_3652_9504:()=>d5o,content_3652_9506:()=>f5o,content_3652_9508:()=>D5o,content_3652_9510:()=>w5o,content_3652_9512:()=>g5o,content_3652_9514:()=>L5o,content_3652_9516:()=>N5o,content_3652_9518:()=>W5o,content_3652_952:()=>Pmt,content_3652_9520:()=>P5o,content_3652_9522:()=>G5o,content_3652_9524:()=>B5o,content_3652_9526:()=>q5o,content_3652_9528:()=>Q5o,content_3652_9530:()=>K5o,content_3652_9532:()=>n1o,content_3652_9534:()=>p1o,content_3652_9536:()=>c1o,content_3652_9538:()=>l1o,content_3652_954:()=>Gmt,content_3652_9540:()=>d1o,content_3652_9542:()=>f1o,content_3652_9544:()=>D1o,content_3652_9546:()=>w1o,content_3652_9548:()=>g1o,content_3652_9550:()=>L1o,content_3652_9552:()=>N1o,content_3652_9554:()=>W1o,content_3652_9556:()=>P1o,content_3652_9558:()=>G1o,content_3652_956:()=>Bmt,content_3652_9560:()=>B1o,content_3652_9562:()=>q1o,content_3652_9564:()=>Q1o,content_3652_9566:()=>K1o,content_3652_9568:()=>n4o,content_3652_9570:()=>p4o,content_3652_9572:()=>c4o,content_3652_9574:()=>l4o,content_3652_9576:()=>d4o,content_3652_9578:()=>f4o,content_3652_958:()=>qmt,content_3652_9580:()=>D4o,content_3652_9582:()=>w4o,content_3652_9584:()=>g4o,content_3652_9586:()=>L4o,content_3652_9588:()=>N4o,content_3652_9590:()=>W4o,content_3652_9592:()=>P4o,content_3652_9594:()=>G4o,content_3652_9596:()=>B4o,content_3652_9598:()=>q4o,content_3652_96:()=>YK,content_3652_960:()=>Qmt,content_3652_9600:()=>Q4o,content_3652_9602:()=>K4o,content_3652_9604:()=>n8o,content_3652_9606:()=>p8o,content_3652_9608:()=>c8o,content_3652_9610:()=>l8o,content_3652_9612:()=>d8o,content_3652_9614:()=>f8o,content_3652_9616:()=>D8o,content_3652_9618:()=>w8o,content_3652_962:()=>Kmt,content_3652_9620:()=>g8o,content_3652_9622:()=>L8o,content_3652_9624:()=>N8o,content_3652_9626:()=>W8o,content_3652_9628:()=>P8o,content_3652_9630:()=>G8o,content_3652_9632:()=>B8o,content_3652_9634:()=>q8o,content_3652_9636:()=>Q8o,content_3652_9638:()=>K8o,content_3652_964:()=>ndt,content_3652_9640:()=>n7o,content_3652_9642:()=>p7o,content_3652_9644:()=>c7o,content_3652_9646:()=>l7o,content_3652_9648:()=>d7o,content_3652_9650:()=>f7o,content_3652_9652:()=>D7o,content_3652_9654:()=>w7o,content_3652_9656:()=>g7o,content_3652_9658:()=>L7o,content_3652_966:()=>pdt,content_3652_9660:()=>N7o,content_3652_9662:()=>W7o,content_3652_9664:()=>P7o,content_3652_9666:()=>G7o,content_3652_9668:()=>B7o,content_3652_9670:()=>q7o,content_3652_9672:()=>Q7o,content_3652_9674:()=>K7o,content_3652_9676:()=>n9o,content_3652_9678:()=>p9o,content_3652_968:()=>cdt,content_3652_9680:()=>c9o,content_3652_9682:()=>l9o,content_3652_9684:()=>d9o,content_3652_9686:()=>f9o,content_3652_9688:()=>D9o,content_3652_9690:()=>w9o,content_3652_9692:()=>g9o,content_3652_9694:()=>L9o,content_3652_9696:()=>N9o,content_3652_9698:()=>W9o,content_3652_970:()=>ldt,content_3652_9700:()=>P9o,content_3652_9702:()=>G9o,content_3652_9704:()=>B9o,content_3652_9706:()=>q9o,content_3652_9708:()=>Q9o,content_3652_9710:()=>K9o,content_3652_9712:()=>ntp,content_3652_9714:()=>ptp,content_3652_9716:()=>ctp,content_3652_9718:()=>ltp,content_3652_972:()=>ddt,content_3652_9720:()=>dtp,content_3652_9722:()=>ftp,content_3652_9724:()=>Dtp,content_3652_9726:()=>wtp,content_3652_9728:()=>gtp,content_3652_9730:()=>Ltp,content_3652_9732:()=>Ntp,content_3652_9734:()=>Wtp,content_3652_9736:()=>Ptp,content_3652_9738:()=>Gtp,content_3652_974:()=>fdt,content_3652_9740:()=>Btp,content_3652_9742:()=>qtp,content_3652_9744:()=>Qtp,content_3652_9746:()=>Ktp,content_3652_9748:()=>nnp,content_3652_9750:()=>pnp,content_3652_9752:()=>cnp,content_3652_9754:()=>lnp,content_3652_9756:()=>dnp,content_3652_9758:()=>fnp,content_3652_976:()=>Ddt,content_3652_9760:()=>Dnp,content_3652_9762:()=>wnp,content_3652_9764:()=>gnp,content_3652_9766:()=>Lnp,content_3652_9768:()=>Nnp,content_3652_9770:()=>Wnp,content_3652_9772:()=>Pnp,content_3652_9774:()=>Gnp,content_3652_9776:()=>Bnp,content_3652_9778:()=>qnp,content_3652_978:()=>wdt,content_3652_9780:()=>Qnp,content_3652_9782:()=>Knp,content_3652_9784:()=>nep,content_3652_9786:()=>pep,content_3652_9788:()=>cep,content_3652_9790:()=>lep,content_3652_9792:()=>dep,content_3652_9794:()=>fep,content_3652_9796:()=>Dep,content_3652_9798:()=>wep,content_3652_98:()=>$K,content_3652_980:()=>gdt,content_3652_9800:()=>gep,content_3652_9802:()=>Lep,content_3652_9804:()=>Nep,content_3652_9806:()=>Wep,content_3652_9808:()=>Pep,content_3652_9810:()=>Gep,content_3652_9812:()=>Bep,content_3652_9814:()=>qep,content_3652_9816:()=>Qep,content_3652_9818:()=>Kep,content_3652_982:()=>Ldt,content_3652_9820:()=>nop,content_3652_9822:()=>pop,content_3652_9824:()=>cop,content_3652_9826:()=>lop,content_3652_9828:()=>dop,content_3652_9830:()=>fop,content_3652_9832:()=>Dop,content_3652_9834:()=>wop,content_3652_9836:()=>gop,content_3652_9838:()=>Lop,content_3652_984:()=>Ndt,content_3652_9840:()=>Nop,content_3652_9842:()=>Wop,content_3652_9844:()=>Pop,content_3652_9846:()=>Gop,content_3652_9848:()=>Bop,content_3652_9850:()=>qop,content_3652_9852:()=>Qop,content_3652_9854:()=>Kop,content_3652_9856:()=>npp,content_3652_9858:()=>ppp,content_3652_986:()=>Wdt,content_3652_9860:()=>cpp,content_3652_9862:()=>lpp,content_3652_9864:()=>dpp,content_3652_9866:()=>fpp,content_3652_9868:()=>Dpp,content_3652_9870:()=>wpp,content_3652_9872:()=>gpp,content_3652_9874:()=>Lpp,content_3652_9876:()=>Npp,content_3652_9878:()=>Wpp,content_3652_988:()=>Pdt,content_3652_9880:()=>Ppp,content_3652_9882:()=>Gpp,content_3652_9884:()=>Bpp,content_3652_9886:()=>qpp,content_3652_9888:()=>Qpp,content_3652_9890:()=>Kpp,content_3652_9892:()=>nrp,content_3652_9894:()=>prp,content_3652_9896:()=>crp,content_3652_9898:()=>lrp,content_3652_990:()=>Gdt,content_3652_9900:()=>drp,content_3652_9902:()=>frp,content_3652_9904:()=>Drp,content_3652_9906:()=>wrp,content_3652_9908:()=>grp,content_3652_9910:()=>Lrp,content_3652_9912:()=>Nrp,content_3652_9914:()=>Wrp,content_3652_9916:()=>Prp,content_3652_9918:()=>Grp,content_3652_992:()=>Bdt,content_3652_9920:()=>Brp,content_3652_9922:()=>qrp,content_3652_9924:()=>Qrp,content_3652_9926:()=>Krp,content_3652_9928:()=>nsp,content_3652_9930:()=>psp,content_3652_9932:()=>csp,content_3652_9934:()=>lsp,content_3652_9936:()=>dsp,content_3652_9938:()=>fsp,content_3652_994:()=>qdt,content_3652_9940:()=>Dsp,content_3652_9942:()=>wsp,content_3652_9944:()=>gsp,content_3652_9946:()=>Lsp,content_3652_9948:()=>Nsp,content_3652_9950:()=>Wsp,content_3652_9952:()=>Psp,content_3652_9954:()=>Gsp,content_3652_9956:()=>Bsp,content_3652_9958:()=>qsp,content_3652_996:()=>Qdt,content_3652_9960:()=>Qsp,content_3652_9962:()=>Ksp,content_3652_9964:()=>ncp,content_3652_9966:()=>pcp,content_3652_9968:()=>ccp,content_3652_9970:()=>lcp,content_3652_9972:()=>dcp,content_3652_9974:()=>fcp,content_3652_9976:()=>Dcp,content_3652_9978:()=>wcp,content_3652_998:()=>Kdt,content_3652_9980:()=>gcp,content_3652_9982:()=>Lcp,content_3652_9984:()=>Ncp,content_3652_9986:()=>Wcp,content_3652_9988:()=>Pcp,content_3652_9990:()=>Gcp,content_3652_9992:()=>Bcp,content_3652_9994:()=>qcp,content_3652_9996:()=>Qcp,content_3652_9998:()=>Kcp});var p=e(7896),r=e(2784),s=e(876);const c={toc:[]},i="wrapper";function a(t){let{components:n,...e}=t;return(0,s.kt)(i,(0,p.Z)({},c,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Main Motion Canvas classes."))}a.isMDXComponent=!0;const l={toc:[]},u="wrapper";function m(t){let{components:n,...e}=t;return(0,s.kt)(u,(0,p.Z)({},l,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when a new message is logged."))}m.isMDXComponent=!0;const d={toc:[]},h="wrapper";function k(t){let{components:n,...e}=t;return(0,s.kt)(h,(0,p.Z)({},d,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A read-only representation of the playback."))}k.isMDXComponent=!0;const f={toc:[]},y="wrapper";function M(t){let{components:n,...e}=t;return(0,s.kt)(y,(0,p.Z)({},f,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert frames to seconds using the current framerate."))}M.isMDXComponent=!0;const D={toc:[]},X="wrapper";function _(t){let{components:n,...e}=t;return(0,s.kt)(X,(0,p.Z)({},D,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frames to convert."))}_.isMDXComponent=!0;const w={toc:[]},T="wrapper";function C(t){let{components:n,...e}=t;return(0,s.kt)(T,(0,p.Z)({},w,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert seconds to frames using the current framerate."))}C.isMDXComponent=!0;const g={toc:[]},x="wrapper";function v(t){let{components:n,...e}=t;return(0,s.kt)(x,(0,p.Z)({},g,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seconds to convert."))}v.isMDXComponent=!0;const L={toc:[]},Z="wrapper";function b(t){let{components:n,...e}=t;return(0,s.kt)(Z,(0,p.Z)({},L,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class builds on top of the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to provide a simple\ninterface similar to other media players. It plays through the animation\nusing a real-time update loop and optionally synchronises it with audio."))}b.isMDXComponent=!0;const N={toc:[]},A="wrapper";function z(t){let{components:n,...e}=t;return(0,s.kt)(A,(0,p.Z)({},N,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player logic used by the editor and embeddable player."))}z.isMDXComponent=!0;const W={toc:[]},I="wrapper";function R(t){let{components:n,...e}=t;return(0,s.kt)(I,(0,p.Z)({},W,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to provide visual feedback."))}R.isMDXComponent=!0;const P={toc:[]},S="wrapper";function E(t){let{components:n,...e}=t;return(0,s.kt)(S,(0,p.Z)({},P,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered right after recalculation finishes."))}E.isMDXComponent=!0;const G={toc:[]},O="wrapper";function F(t){let{components:n,...e}=t;return(0,s.kt)(O,(0,p.Z)({},G,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Player does not perform any rendering on its own. For the animation to be\nvisible, another class must subscribe to this event and perform the\nrendering itself. ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Stage"},(0,s.kt)("inlineCode",{parentName:"a"},"Stage"))," can be used to display the animation."))}F.isMDXComponent=!0;const B={toc:[]},U="wrapper";function V(t){let{components:n,...e}=t;return(0,s.kt)(U,(0,p.Z)({},B,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered during each iteration of the update loop when the frame is ready\nto be rendered."))}V.isMDXComponent=!0;const q={toc:[]},j="wrapper";function Y(t){let{components:n,...e}=t;return(0,s.kt)(j,(0,p.Z)({},q,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A player needs to be active in order for the update loop to run. Each\nplayer is active by default."))}Y.isMDXComponent=!0;const Q={toc:[]},H="wrapper";function $(t){let{components:n,...e}=t;return(0,s.kt)(H,(0,p.Z)({},Q,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Activate the player."))}$.isMDXComponent=!0;const K={toc:[]},J="wrapper";function tt(t){let{components:n,...e}=t;return(0,s.kt)(J,(0,p.Z)({},K,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivating the player prevents its update loop from running. This should\nbe done before disposing the player, to prevent it from running in the\nbackground."),(0,s.kt)("p",null,"Just pausing the player does not stop the loop."))}tt.isMDXComponent=!0;const nt={toc:[]},et="wrapper";function ot(t){let{components:n,...e}=t;return(0,s.kt)(et,(0,p.Z)({},nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivate the player."))}ot.isMDXComponent=!0;const pt={toc:[]},rt="wrapper";function st(t){let{components:n,...e}=t;return(0,s.kt)(rt,(0,p.Z)({},pt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the given frame is inside the animation range."))}st.isMDXComponent=!0;const ct={toc:[]},it="wrapper";function at(t){let{components:n,...e}=t;return(0,s.kt)(it,(0,p.Z)({},ct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame to check."))}at.isMDXComponent=!0;const lt={toc:[]},ut="wrapper";function mt(t){let{components:n,...e}=t;return(0,s.kt)(ut,(0,p.Z)({},lt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the given frame is inside the user-defined range."))}mt.isMDXComponent=!0;const dt={toc:[]},ht="wrapper";function kt(t){let{components:n,...e}=t;return(0,s.kt)(ht,(0,p.Z)({},dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame to check."))}kt.isMDXComponent=!0;const ft={toc:[]},yt="wrapper";function Mt(t){let{components:n,...e}=t;return(0,s.kt)(yt,(0,p.Z)({},ft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing presentation process."))}Mt.isMDXComponent=!0;const Dt={toc:[]},Xt="wrapper";function _t(t){let{components:n,...e}=t;return(0,s.kt)(Xt,(0,p.Z)({},Dt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Present the animation."))}_t.isMDXComponent=!0;const wt={toc:[]},Tt="wrapper";function Ct(t){let{components:n,...e}=t;return(0,s.kt)(Tt,(0,p.Z)({},wt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presentation settings."))}Ct.isMDXComponent=!0;const gt={toc:[]},xt="wrapper";function vt(t){let{components:n,...e}=t;return(0,s.kt)(xt,(0,p.Z)({},gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Resume the presentation if waiting for the next slide."))}vt.isMDXComponent=!0;const Lt={toc:[]},Zt="wrapper";function bt(t){let{components:n,...e}=t;return(0,s.kt)(Zt,(0,p.Z)({},Lt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bt.isMDXComponent=!0;const Nt={toc:[]},At="wrapper";function zt(t){let{components:n,...e}=t;return(0,s.kt)(At,(0,p.Z)({},Nt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zt.isMDXComponent=!0;const Wt={toc:[]},It="wrapper";function Rt(t){let{components:n,...e}=t;return(0,s.kt)(It,(0,p.Z)({},Wt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Rt.isMDXComponent=!0;const Pt={toc:[]},St="wrapper";function Et(t){let{components:n,...e}=t;return(0,s.kt)(St,(0,p.Z)({},Pt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Et.isMDXComponent=!0;const Gt={toc:[]},Ot="wrapper";function Ft(t){let{components:n,...e}=t;return(0,s.kt)(Ot,(0,p.Z)({},Gt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}Ft.isMDXComponent=!0;const Bt={toc:[]},Ut="wrapper";function Vt(t){let{components:n,...e}=t;return(0,s.kt)(Ut,(0,p.Z)({},Bt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Vt.isMDXComponent=!0;const qt={toc:[]},jt="wrapper";function Yt(t){let{components:n,...e}=t;return(0,s.kt)(jt,(0,p.Z)({},qt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Yt.isMDXComponent=!0;const Qt={toc:[]},Ht="wrapper";function $t(t){let{components:n,...e}=t;return(0,s.kt)(Ht,(0,p.Z)({},Qt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}$t.isMDXComponent=!0;const Kt={toc:[]},Jt="wrapper";function tn(t){let{components:n,...e}=t;return(0,s.kt)(Jt,(0,p.Z)({},Kt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}tn.isMDXComponent=!0;const nn={toc:[]},en="wrapper";function on(t){let{components:n,...e}=t;return(0,s.kt)(en,(0,p.Z)({},nn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}on.isMDXComponent=!0;const pn={toc:[]},rn="wrapper";function sn(t){let{components:n,...e}=t;return(0,s.kt)(rn,(0,p.Z)({},pn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}sn.isMDXComponent=!0;const cn={toc:[]},an="wrapper";function ln(t){let{components:n,...e}=t;return(0,s.kt)(an,(0,p.Z)({},cn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}ln.isMDXComponent=!0;const un={toc:[]},mn="wrapper";function dn(t){let{components:n,...e}=t;return(0,s.kt)(mn,(0,p.Z)({},un,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}dn.isMDXComponent=!0;const hn={toc:[]},kn="wrapper";function fn(t){let{components:n,...e}=t;return(0,s.kt)(kn,(0,p.Z)({},hn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}fn.isMDXComponent=!0;const yn={toc:[]},Mn="wrapper";function Dn(t){let{components:n,...e}=t;return(0,s.kt)(Mn,(0,p.Z)({},yn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class uses the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to render animations. In contrast to a\nplayer, a renderer does not use an update loop. It plays through the\nanimation as fast as it can, occasionally pausing to keep the UI responsive."),(0,s.kt)("p",null,"The actual exporting is outsourced to an ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Exporter"},(0,s.kt)("inlineCode",{parentName:"a"},"Exporter")),"."))}Dn.isMDXComponent=!0;const Xn={toc:[]},_n="wrapper";function wn(t){let{components:n,...e}=t;return(0,s.kt)(_n,(0,p.Z)({},Xn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering logic used by the editor to export animations."))}wn.isMDXComponent=!0;const Tn={toc:[]},Cn="wrapper";function gn(t){let{components:n,...e}=t;return(0,s.kt)(Cn,(0,p.Z)({},Tn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing render process."))}gn.isMDXComponent=!0;const xn={toc:[]},vn="wrapper";function Ln(t){let{components:n,...e}=t;return(0,s.kt)(vn,(0,p.Z)({},xn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the animation using the provided settings."))}Ln.isMDXComponent=!0;const Zn={toc:[]},bn="wrapper";function Nn(t){let{components:n,...e}=t;return(0,s.kt)(bn,(0,p.Z)({},Zn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}Nn.isMDXComponent=!0;const An={toc:[]},zn="wrapper";function Wn(t){let{components:n,...e}=t;return(0,s.kt)(zn,(0,p.Z)({},An,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method always uses the default ",(0,s.kt)("inlineCode",{parentName:"p"},"ImageExporter"),"."))}Wn.isMDXComponent=!0;const In={toc:[]},Rn="wrapper";function Pn(t){let{components:n,...e}=t;return(0,s.kt)(Rn,(0,p.Z)({},In,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export an individual frame."))}Pn.isMDXComponent=!0;const Sn={toc:[]},En="wrapper";function Gn(t){let{components:n,...e}=t;return(0,s.kt)(En,(0,p.Z)({},Sn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}Gn.isMDXComponent=!0;const On={toc:[]},Fn="wrapper";function Bn(t){let{components:n,...e}=t;return(0,s.kt)(Fn,(0,p.Z)({},On,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timestamp to export."))}Bn.isMDXComponent=!0;const Un={toc:[]},Vn="wrapper";function qn(t){let{components:n,...e}=t;return(0,s.kt)(Vn,(0,p.Z)({},Un,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Manages canvases on which an animation can be displayed."))}qn.isMDXComponent=!0;const jn={toc:[]},Yn="wrapper";function Qn(t){let{components:n,...e}=t;return(0,s.kt)(Yn,(0,p.Z)({},jn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for implementing custom exporters."))}Qn.isMDXComponent=!0;const Hn={toc:[]},$n="wrapper";function Kn(t){let{components:n,...e}=t;return(0,s.kt)($n,(0,p.Z)({},Hn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called at the beginning of the rendering process, before anything else has\nbeen set up. The returned value can be used to override the rendering\nsettings provided by the user."))}Kn.isMDXComponent=!0;const Jn={toc:[]},te="wrapper";function ne(t){let{components:n,...e}=t;return(0,s.kt)(te,(0,p.Z)({},Jn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the rendering configuration."))}ne.isMDXComponent=!0;const ee={toc:[]},oe="wrapper";function pe(t){let{components:n,...e}=t;return(0,s.kt)(oe,(0,p.Z)({},ee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called each time after a frame is rendered."))}pe.isMDXComponent=!0;const re={toc:[]},se="wrapper";function ce(t){let{components:n,...e}=t;return(0,s.kt)(se,(0,p.Z)({},re,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export a frame."))}ce.isMDXComponent=!0;const ie={toc:[]},ae="wrapper";function le(t){let{components:n,...e}=t;return(0,s.kt)(ae,(0,p.Z)({},ie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A canvas containing the rendered frame."))}le.isMDXComponent=!0;const ue={toc:[]},me="wrapper";function de(t){let{components:n,...e}=t;return(0,s.kt)(me,(0,p.Z)({},ue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number."))}de.isMDXComponent=!0;const he={toc:[]},ke="wrapper";function fe(t){let{components:n,...e}=t;return(0,s.kt)(ke,(0,p.Z)({},he,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number within the scene."))}fe.isMDXComponent=!0;const ye={toc:[]},Me="wrapper";function De(t){let{components:n,...e}=t;return(0,s.kt)(Me,(0,p.Z)({},ye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the scene with which the frame is associated."))}De.isMDXComponent=!0;const Xe={toc:[]},_e="wrapper";function we(t){let{components:n,...e}=t;return(0,s.kt)(_e,(0,p.Z)({},Xe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An abort signal triggered if the user aborts the rendering."))}we.isMDXComponent=!0;const Te={toc:[]},Ce="wrapper";function ge(t){let{components:n,...e}=t;return(0,s.kt)(Ce,(0,p.Z)({},Te,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.kt)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.kt)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}ge.isMDXComponent=!0;const xe={toc:[]},ve="wrapper";function Le(t){let{components:n,...e}=t;return(0,s.kt)(ve,(0,p.Z)({},xe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Begin the rendering process."))}Le.isMDXComponent=!0;const Ze={toc:[]},be="wrapper";function Ne(t){let{components:n,...e}=t;return(0,s.kt)(be,(0,p.Z)({},Ze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Can be used to finalize the exporting and perform any necessary\nclean-up."))}Ne.isMDXComponent=!0;const Ae={toc:[]},ze="wrapper";function We(t){let{components:n,...e}=t;return(0,s.kt)(ze,(0,p.Z)({},Ae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Finish the rendering process."))}We.isMDXComponent=!0;const Ie={toc:[]},Re="wrapper";function Pe(t){let{components:n,...e}=t;return(0,s.kt)(Re,(0,p.Z)({},Ie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The result of the rendering."))}Pe.isMDXComponent=!0;const Se={toc:[]},Ee="wrapper";function Ge(t){let{components:n,...e}=t;return(0,s.kt)(Ee,(0,p.Z)({},Se,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The static interface for exporters."))}Ge.isMDXComponent=!0;const Oe={toc:[]},Fe="wrapper";function Be(t){let{components:n,...e}=t;return(0,s.kt)(Fe,(0,p.Z)({},Oe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This name will be displayed in the editor."))}Be.isMDXComponent=!0;const Ue={toc:[]},Ve="wrapper";function qe(t){let{components:n,...e}=t;return(0,s.kt)(Ve,(0,p.Z)({},Ue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this exporter."))}qe.isMDXComponent=!0;const je={toc:[]},Ye="wrapper";function Qe(t){let{components:n,...e}=t;return(0,s.kt)(Ye,(0,p.Z)({},je,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This identifier will be used to store the settings of this exporter.\nIt's recommended to prepend it with the name of the package to avoid\ncollisions."))}Qe.isMDXComponent=!0;const He={toc:[]},$e="wrapper";function Ke(t){let{components:n,...e}=t;return(0,s.kt)($e,(0,p.Z)({},He,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The unique identifier of this exporter."))}Ke.isMDXComponent=!0;const Je={toc:[]},to="wrapper";function no(t){let{components:n,...e}=t;return(0,s.kt)(to,(0,p.Z)({},Je,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A new exporter is created whenever the user starts a new rendering process."))}no.isMDXComponent=!0;const eo={toc:[]},oo="wrapper";function po(t){let{components:n,...e}=t;return(0,s.kt)(oo,(0,p.Z)({},eo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this exporter."))}po.isMDXComponent=!0;const ro={toc:[]},so="wrapper";function co(t){let{components:n,...e}=t;return(0,s.kt)(so,(0,p.Z)({},ro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current project."))}co.isMDXComponent=!0;const io={toc:[]},ao="wrapper";function lo(t){let{components:n,...e}=t;return(0,s.kt)(ao,(0,p.Z)({},io,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}lo.isMDXComponent=!0;const uo={toc:[]},mo="wrapper";function ho(t){let{components:n,...e}=t;return(0,s.kt)(mo,(0,p.Z)({},uo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a meta field representing the options of this exporter."))}ho.isMDXComponent=!0;const ko={toc:[]},fo="wrapper";function yo(t){let{components:n,...e}=t;return(0,s.kt)(fo,(0,p.Z)({},ko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When displayed in the editor, the log entry will have the following format:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"                             inspect node \u2510\n  \u250c expand more          duration \u2510       \u2502\n  \u25bc                               \u25bc       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u25b6 message                       300 ms (+) \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 remarks                                    \u2502\n\u2502 object                                     \u2502\n\u2502 stacktrace                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")))}yo.isMDXComponent=!0;const Mo={toc:[]},Do="wrapper";function Xo(t){let{components:n,...e}=t;return(0,s.kt)(Do,(0,p.Z)({},Mo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an individual log entry."))}Xo.isMDXComponent=!0;const _o={toc:[]},wo="wrapper";function To(t){let{components:n,...e}=t;return(0,s.kt)(wo,(0,p.Z)({},_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}To.isMDXComponent=!0;const Co={toc:[]},go="wrapper";function xo(t){let{components:n,...e}=t;return(0,s.kt)(go,(0,p.Z)({},Co,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional duration in milliseconds."))}xo.isMDXComponent=!0;const vo={toc:[]},Lo="wrapper";function Zo(t){let{components:n,...e}=t;return(0,s.kt)(Lo,(0,p.Z)({},vo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This will be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.kt)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}Zo.isMDXComponent=!0;const bo={toc:[]},No="wrapper";function Ao(t){let{components:n,...e}=t;return(0,s.kt)(No,(0,p.Z)({},bo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional key used to inspect a related object."))}Ao.isMDXComponent=!0;const zo={toc:[]},Wo="wrapper";function Io(t){let{components:n,...e}=t;return(0,s.kt)(Wo,(0,p.Z)({},zo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log level."))}Io.isMDXComponent=!0;const Ro={toc:[]},Po="wrapper";function So(t){let{components:n,...e}=t;return(0,s.kt)(Po,(0,p.Z)({},Ro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Always visible."))}So.isMDXComponent=!0;const Eo={toc:[]},Go="wrapper";function Oo(t){let{components:n,...e}=t;return(0,s.kt)(Go,(0,p.Z)({},Eo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main message of the log."))}Oo.isMDXComponent=!0;const Fo={toc:[]},Bo="wrapper";function Uo(t){let{components:n,...e}=t;return(0,s.kt)(Bo,(0,p.Z)({},Fo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded."))}Uo.isMDXComponent=!0;const Vo={toc:[]},qo="wrapper";function jo(t){let{components:n,...e}=t;return(0,s.kt)(qo,(0,p.Z)({},Vo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An object that will be serialized as JSON and displayed under the message."))}jo.isMDXComponent=!0;const Yo={toc:[]},Qo="wrapper";function Ho(t){let{components:n,...e}=t;return(0,s.kt)(Qo,(0,p.Z)({},Yo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded."))}Ho.isMDXComponent=!0;const $o={toc:[]},Ko="wrapper";function Jo(t){let{components:n,...e}=t;return(0,s.kt)(Ko,(0,p.Z)({},$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Additional information about the log."))}Jo.isMDXComponent=!0;const tp={toc:[]},np="wrapper";function ep(t){let{components:n,...e}=t;return(0,s.kt)(np,(0,p.Z)({},tp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded.\nThe current stack trace can be obtained using ",(0,s.kt)("inlineCode",{parentName:"p"},"new Error().stack"),".\nBoth Chromium and Firefox stack traces are supported."))}ep.isMDXComponent=!0;const op={toc:[]},pp="wrapper";function rp(t){let{components:n,...e}=t;return(0,s.kt)(pp,(0,p.Z)({},op,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace of the log."))}rp.isMDXComponent=!0;const sp={toc:[]},cp="wrapper";function ip(t){let{components:n,...e}=t;return(0,s.kt)(cp,(0,p.Z)({},sp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://motioncanvas.io/docs/media#audio"},"https://motioncanvas.io/docs/media#audio")))}ip.isMDXComponent=!0;const ap={toc:[]},lp="wrapper";function up(t){let{components:n,...e}=t;return(0,s.kt)(lp,(0,p.Z)({},ap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An url for the audio track to play alongside the animation."))}up.isMDXComponent=!0;const mp={toc:[]},dp="wrapper";function hp(t){let{components:n,...e}=t;return(0,s.kt)(dp,(0,p.Z)({},mp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configure the offset in the Video Settings tab of th editor."))}hp.isMDXComponent=!0;const kp={toc:[]},fp="wrapper";function yp(t){let{components:n,...e}=t;return(0,s.kt)(fp,(0,p.Z)({},kp,e,{components:n,mdxType:"MDXLayout"}))}yp.isMDXComponent=!0;const Mp={toc:[]},Dp="wrapper";function Xp(t){let{components:n,...e}=t;return(0,s.kt)(Dp,(0,p.Z)({},Mp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://motioncanvas.io/docs/experimental"},"https://motioncanvas.io/docs/experimental")))}Xp.isMDXComponent=!0;const _p={toc:[]},wp="wrapper";function Tp(t){let{components:n,...e}=t;return(0,s.kt)(wp,(0,p.Z)({},_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enable experimental features."))}Tp.isMDXComponent=!0;const Cp={toc:[]},gp="wrapper";function xp(t){let{components:n,...e}=t;return(0,s.kt)(gp,(0,p.Z)({},Cp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A custom logger instance to use."))}xp.isMDXComponent=!0;const vp={toc:[]},Lp="wrapper";function Zp(t){let{components:n,...e}=t;return(0,s.kt)(Lp,(0,p.Z)({},vp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the project."))}Zp.isMDXComponent=!0;const bp={toc:[]},Np="wrapper";function Ap(t){let{components:n,...e}=t;return(0,s.kt)(Np,(0,p.Z)({},bp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When a string is provided, the plugin will be imported dynamically using\nthe string as the module specifier. This is the preferred way to include\neditor plugins because it makes sure that the plugin's source code gets\nexcluded from the production build."))}Ap.isMDXComponent=!0;const zp={toc:[]},Wp="wrapper";function Ip(t){let{components:n,...e}=t;return(0,s.kt)(Wp,(0,p.Z)({},zp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of plugins to include in the project."))}Ip.isMDXComponent=!0;const Rp={toc:[]},Pp="wrapper";function Sp(t){let{components:n,...e}=t;return(0,s.kt)(Pp,(0,p.Z)({},Rp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A full scene description can be obtained by loading a scene module with a\n",(0,s.kt)("inlineCode",{parentName:"p"},"?scene")," query parameter."))}Sp.isMDXComponent=!0;const Ep={toc:[]},Gp="wrapper";function Op(t){let{components:n,...e}=t;return(0,s.kt)(Gp,(0,p.Z)({},Ep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import exampleScene from './example?scene';\n\nexport default makeProject({\n  scenes: [exampleScene],\n});\n")))}Op.isMDXComponent=!0;const Fp={toc:[]},Bp="wrapper";function Up(t){let{components:n,...e}=t;return(0,s.kt)(Bp,(0,p.Z)({},Fp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of scene descriptions that make up the project."))}Up.isMDXComponent=!0;const Vp={toc:[]},qp="wrapper";function jp(t){let{components:n,...e}=t;return(0,s.kt)(qp,(0,p.Z)({},Vp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://motioncanvas.io/docs/project-variables"},"https://motioncanvas.io/docs/project-variables")))}jp.isMDXComponent=!0;const Yp={toc:[]},Qp="wrapper";function Hp(t){let{components:n,...e}=t;return(0,s.kt)(Qp,(0,p.Z)({},Yp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Default values for project variables."))}Hp.isMDXComponent=!0;const $p={toc:[]},Kp="wrapper";function Jp(t){let{components:n,...e}=t;return(0,s.kt)(Kp,(0,p.Z)({},$p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the settings metadata."))}Jp.isMDXComponent=!0;const tr={toc:[]},nr="wrapper";function er(t){let{components:n,...e}=t;return(0,s.kt)(nr,(0,p.Z)({},tr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the settings metadata."))}er.isMDXComponent=!0;const or={toc:[]},pr="wrapper";function rr(t){let{components:n,...e}=t;return(0,s.kt)(pr,(0,p.Z)({},or,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Property decorators."))}rr.isMDXComponent=!0;const sr={toc:[]},cr="wrapper";function ir(t){let{components:n,...e}=t;return(0,s.kt)(cr,(0,p.Z)({},sr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}ir.isMDXComponent=!0;const ar={toc:[]},lr="wrapper";function ur(t){let{components:n,...e}=t;return(0,s.kt)(lr,(0,p.Z)({},ar,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a lazy decorator."))}ur.isMDXComponent=!0;const mr={toc:[]},dr="wrapper";function hr(t){let{components:n,...e}=t;return(0,s.kt)(dr,(0,p.Z)({},mr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the value of this property."))}hr.isMDXComponent=!0;const kr={toc:[]},fr="wrapper";function yr(t){let{components:n,...e}=t;return(0,s.kt)(fr,(0,p.Z)({},kr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscriptions and triggering of events."))}yr.isMDXComponent=!0;const Mr={toc:[]},Dr="wrapper";function Xr(t){let{components:n,...e}=t;return(0,s.kt)(Dr,(0,p.Z)({},Mr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}Xr.isMDXComponent=!0;const _r={toc:[]},wr="wrapper";function Tr(t){let{components:n,...e}=t;return(0,s.kt)(wr,(0,p.Z)({},_r,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}Tr.isMDXComponent=!0;const Cr={toc:[]},gr="wrapper";function xr(t){let{components:n,...e}=t;return(0,s.kt)(gr,(0,p.Z)({},Cr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches an asynchronous ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}xr.isMDXComponent=!0;const vr={toc:[]},Lr="wrapper";function Zr(t){let{components:n,...e}=t;return(0,s.kt)(Lr,(0,p.Z)({},vr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Zr.isMDXComponent=!0;const br={toc:[]},Nr="wrapper";function Ar(t){let{components:n,...e}=t;return(0,s.kt)(Nr,(0,p.Z)({},br,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Ar.isMDXComponent=!0;const zr={toc:[]},Wr="wrapper";function Ir(t){let{components:n,...e}=t;return(0,s.kt)(Wr,(0,p.Z)({},zr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Ir.isMDXComponent=!0;const Rr={toc:[]},Pr="wrapper";function Sr(t){let{components:n,...e}=t;return(0,s.kt)(Pr,(0,p.Z)({},Rr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Sr.isMDXComponent=!0;const Er={toc:[]},Gr="wrapper";function Or(t){let{components:n,...e}=t;return(0,s.kt)(Gr,(0,p.Z)({},Er,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Or.isMDXComponent=!0;const Fr={toc:[]},Br="wrapper";function Ur(t){let{components:n,...e}=t;return(0,s.kt)(Br,(0,p.Z)({},Fr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Ur.isMDXComponent=!0;const Vr={toc:[]},qr="wrapper";function jr(t){let{components:n,...e}=t;return(0,s.kt)(qr,(0,p.Z)({},Vr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}jr.isMDXComponent=!0;const Yr={toc:[]},Qr="wrapper";function Hr(t){let{components:n,...e}=t;return(0,s.kt)(Qr,(0,p.Z)({},Yr,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}Hr.isMDXComponent=!0;const $r={toc:[]},Kr="wrapper";function Jr(t){let{components:n,...e}=t;return(0,s.kt)(Kr,(0,p.Z)({},$r,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}Jr.isMDXComponent=!0;const ts={toc:[]},ns="wrapper";function es(t){let{components:n,...e}=t;return(0,s.kt)(ns,(0,p.Z)({},ts,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}es.isMDXComponent=!0;const os={toc:[]},ps="wrapper";function rs(t){let{components:n,...e}=t;return(0,s.kt)(ps,(0,p.Z)({},os,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}rs.isMDXComponent=!0;const ss={toc:[]},cs="wrapper";function is(t){let{components:n,...e}=t;return(0,s.kt)(cs,(0,p.Z)({},ss,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}is.isMDXComponent=!0;const as={toc:[]},ls="wrapper";function us(t){let{components:n,...e}=t;return(0,s.kt)(ls,(0,p.Z)({},as,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}us.isMDXComponent=!0;const ms={toc:[]},ds="wrapper";function hs(t){let{components:n,...e}=t;return(0,s.kt)(ds,(0,p.Z)({},ms,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}hs.isMDXComponent=!0;const ks={toc:[]},fs="wrapper";function ys(t){let{components:n,...e}=t;return(0,s.kt)(fs,(0,p.Z)({},ks,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}ys.isMDXComponent=!0;const Ms={toc:[]},Ds="wrapper";function Xs(t){let{components:n,...e}=t;return(0,s.kt)(Ds,(0,p.Z)({},Ms,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value argument to subscribers."))}Xs.isMDXComponent=!0;const _s={toc:[]},ws="wrapper";function Ts(t){let{components:n,...e}=t;return(0,s.kt)(ws,(0,p.Z)({},_s,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A base for dispatching ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Ts.isMDXComponent=!0;const Cs={toc:[]},gs="wrapper";function xs(t){let{components:n,...e}=t;return(0,s.kt)(gs,(0,p.Z)({},Cs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}xs.isMDXComponent=!0;const vs={toc:[]},Ls="wrapper";function Zs(t){let{components:n,...e}=t;return(0,s.kt)(Ls,(0,p.Z)({},vs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Zs.isMDXComponent=!0;const bs={toc:[]},Ns="wrapper";function As(t){let{components:n,...e}=t;return(0,s.kt)(Ns,(0,p.Z)({},bs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}As.isMDXComponent=!0;const zs={toc:[]},Ws="wrapper";function Is(t){let{components:n,...e}=t;return(0,s.kt)(Ws,(0,p.Z)({},zs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Is.isMDXComponent=!0;const Rs={toc:[]},Ps="wrapper";function Ss(t){let{components:n,...e}=t;return(0,s.kt)(Ps,(0,p.Z)({},Rs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Ss.isMDXComponent=!0;const Es={toc:[]},Gs="wrapper";function Os(t){let{components:n,...e}=t;return(0,s.kt)(Gs,(0,p.Z)({},Es,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Os.isMDXComponent=!0;const Fs={toc:[]},Bs="wrapper";function Us(t){let{components:n,...e}=t;return(0,s.kt)(Bs,(0,p.Z)({},Fs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Us.isMDXComponent=!0;const Vs={toc:[]},qs="wrapper";function js(t){let{components:n,...e}=t;return(0,s.kt)(qs,(0,p.Z)({},Vs,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}js.isMDXComponent=!0;const Ys={toc:[]},Qs="wrapper";function Hs(t){let{components:n,...e}=t;return(0,s.kt)(Qs,(0,p.Z)({},Ys,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}Hs.isMDXComponent=!0;const $s={toc:[]},Ks="wrapper";function Js(t){let{components:n,...e}=t;return(0,s.kt)(Ks,(0,p.Z)({},$s,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}Js.isMDXComponent=!0;const tc={toc:[]},nc="wrapper";function ec(t){let{components:n,...e}=t;return(0,s.kt)(nc,(0,p.Z)({},tc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}ec.isMDXComponent=!0;const oc={toc:[]},pc="wrapper";function rc(t){let{components:n,...e}=t;return(0,s.kt)(pc,(0,p.Z)({},oc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}rc.isMDXComponent=!0;const sc={toc:[]},cc="wrapper";function ic(t){let{components:n,...e}=t;return(0,s.kt)(cc,(0,p.Z)({},sc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Are subscribers being notified?"))}ic.isMDXComponent=!0;const ac={toc:[]},lc="wrapper";function uc(t){let{components:n,...e}=t;return(0,s.kt)(lc,(0,p.Z)({},ac,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Notify all current and future subscribers."))}uc.isMDXComponent=!0;const mc={toc:[]},dc="wrapper";function hc(t){let{components:n,...e}=t;return(0,s.kt)(dc,(0,p.Z)({},mc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Stop notifying future subscribers."))}hc.isMDXComponent=!0;const kc={toc:[]},fc="wrapper";function yc(t){let{components:n,...e}=t;return(0,s.kt)(fc,(0,p.Z)({},kc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}yc.isMDXComponent=!0;const Mc={toc:[]},Dc="wrapper";function Xc(t){let{components:n,...e}=t;return(0,s.kt)(Dc,(0,p.Z)({},Mc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Xc.isMDXComponent=!0;const _c={toc:[]},wc="wrapper";function Tc(t){let{components:n,...e}=t;return(0,s.kt)(wc,(0,p.Z)({},_c,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Tc.isMDXComponent=!0;const Cc={toc:[]},gc="wrapper";function xc(t){let{components:n,...e}=t;return(0,s.kt)(gc,(0,p.Z)({},Cc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}xc.isMDXComponent=!0;const vc={toc:[]},Lc="wrapper";function Zc(t){let{components:n,...e}=t;return(0,s.kt)(Lc,(0,p.Z)({},vc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Zc.isMDXComponent=!0;const bc={toc:[]},Nc="wrapper";function Ac(t){let{components:n,...e}=t;return(0,s.kt)(Nc,(0,p.Z)({},bc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Ac.isMDXComponent=!0;const zc={toc:[]},Wc="wrapper";function Ic(t){let{components:n,...e}=t;return(0,s.kt)(Wc,(0,p.Z)({},zc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Ic.isMDXComponent=!0;const Rc={toc:[]},Pc="wrapper";function Sc(t){let{components:n,...e}=t;return(0,s.kt)(Pc,(0,p.Z)({},Rc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Sc.isMDXComponent=!0;const Ec={toc:[]},Gc="wrapper";function Oc(t){let{components:n,...e}=t;return(0,s.kt)(Gc,(0,p.Z)({},Ec,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Oc.isMDXComponent=!0;const Fc={toc:[]},Bc="wrapper";function Uc(t){let{components:n,...e}=t;return(0,s.kt)(Bc,(0,p.Z)({},Fc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Uc.isMDXComponent=!0;const Vc={toc:[]},qc="wrapper";function jc(t){let{components:n,...e}=t;return(0,s.kt)(qc,(0,p.Z)({},Vc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}jc.isMDXComponent=!0;const Yc={toc:[]},Qc="wrapper";function Hc(t){let{components:n,...e}=t;return(0,s.kt)(Qc,(0,p.Z)({},Yc,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Hc.isMDXComponent=!0;const $c={toc:[]},Kc="wrapper";function Jc(t){let{components:n,...e}=t;return(0,s.kt)(Kc,(0,p.Z)({},$c,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Jc.isMDXComponent=!0;const ti={toc:[]},ni="wrapper";function ei(t){let{components:n,...e}=t;return(0,s.kt)(ni,(0,p.Z)({},ti,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}ei.isMDXComponent=!0;const oi={toc:[]},pi="wrapper";function ri(t){let{components:n,...e}=t;return(0,s.kt)(pi,(0,p.Z)({},oi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ri.isMDXComponent=!0;const si={toc:[]},ci="wrapper";function ii(t){let{components:n,...e}=t;return(0,s.kt)(ci,(0,p.Z)({},si,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}ii.isMDXComponent=!0;const ai={toc:[]},li="wrapper";function ui(t){let{components:n,...e}=t;return(0,s.kt)(li,(0,p.Z)({},ai,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}ui.isMDXComponent=!0;const mi={toc:[]},di="wrapper";function hi(t){let{components:n,...e}=t;return(0,s.kt)(di,(0,p.Z)({},mi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}hi.isMDXComponent=!0;const ki={toc:[]},fi="wrapper";function yi(t){let{components:n,...e}=t;return(0,s.kt)(fi,(0,p.Z)({},ki,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}yi.isMDXComponent=!0;const Mi={toc:[]},Di="wrapper";function Xi(t){let{components:n,...e}=t;return(0,s.kt)(Di,(0,p.Z)({},Mi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Xi.isMDXComponent=!0;const _i={toc:[]},wi="wrapper";function Ti(t){let{components:n,...e}=t;return(0,s.kt)(wi,(0,p.Z)({},_i,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Ti.isMDXComponent=!0;const Ci={toc:[]},gi="wrapper";function xi(t){let{components:n,...e}=t;return(0,s.kt)(gi,(0,p.Z)({},Ci,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}xi.isMDXComponent=!0;const vi={toc:[]},Li="wrapper";function Zi(t){let{components:n,...e}=t;return(0,s.kt)(Li,(0,p.Z)({},vi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Zi.isMDXComponent=!0;const bi={toc:[]},Ni="wrapper";function Ai(t){let{components:n,...e}=t;return(0,s.kt)(Ni,(0,p.Z)({},bi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Ai.isMDXComponent=!0;const zi={toc:[]},Wi="wrapper";function Ii(t){let{components:n,...e}=t;return(0,s.kt)(Wi,(0,p.Z)({},zi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Ii.isMDXComponent=!0;const Ri={toc:[]},Pi="wrapper";function Si(t){let{components:n,...e}=t;return(0,s.kt)(Pi,(0,p.Z)({},Ri,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Si.isMDXComponent=!0;const Ei={toc:[]},Gi="wrapper";function Oi(t){let{components:n,...e}=t;return(0,s.kt)(Gi,(0,p.Z)({},Ei,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}Oi.isMDXComponent=!0;const Fi={toc:[]},Bi="wrapper";function Ui(t){let{components:n,...e}=t;return(0,s.kt)(Bi,(0,p.Z)({},Fi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Ui.isMDXComponent=!0;const Vi={toc:[]},qi="wrapper";function ji(t){let{components:n,...e}=t;return(0,s.kt)(qi,(0,p.Z)({},Vi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}ji.isMDXComponent=!0;const Yi={toc:[]},Qi="wrapper";function Hi(t){let{components:n,...e}=t;return(0,s.kt)(Qi,(0,p.Z)({},Yi,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value."))}Hi.isMDXComponent=!0;const $i={toc:[]},Ki="wrapper";function Ji(t){let{components:n,...e}=t;return(0,s.kt)(Ki,(0,p.Z)({},$i,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}Ji.isMDXComponent=!0;const ta={toc:[]},na="wrapper";function ea(t){let{components:n,...e}=t;return(0,s.kt)(na,(0,p.Z)({},ta,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Setting the value will immediately notify all subscribers."))}ea.isMDXComponent=!0;const oa={toc:[]},pa="wrapper";function ra(t){let{components:n,...e}=t;return(0,s.kt)(pa,(0,p.Z)({},oa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value of this dispatcher."))}ra.isMDXComponent=!0;const sa={toc:[]},ca="wrapper";function ia(t){let{components:n,...e}=t;return(0,s.kt)(ca,(0,p.Z)({},sa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}ia.isMDXComponent=!0;const aa={toc:[]},la="wrapper";function ua(t){let{components:n,...e}=t;return(0,s.kt)(la,(0,p.Z)({},aa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}ua.isMDXComponent=!0;const ma={toc:[]},da="wrapper";function ha(t){let{components:n,...e}=t;return(0,s.kt)(da,(0,p.Z)({},ma,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}ha.isMDXComponent=!0;const ka={toc:[]},fa="wrapper";function ya(t){let{components:n,...e}=t;return(0,s.kt)(fa,(0,p.Z)({},ka,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}ya.isMDXComponent=!0;const Ma={toc:[]},Da="wrapper";function Xa(t){let{components:n,...e}=t;return(0,s.kt)(Da,(0,p.Z)({},Ma,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Xa.isMDXComponent=!0;const _a={toc:[]},wa="wrapper";function Ta(t){let{components:n,...e}=t;return(0,s.kt)(wa,(0,p.Z)({},_a,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Ta.isMDXComponent=!0;const Ca={toc:[]},ga="wrapper";function xa(t){let{components:n,...e}=t;return(0,s.kt)(ga,(0,p.Z)({},Ca,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}xa.isMDXComponent=!0;const va={toc:[]},La="wrapper";function Za(t){let{components:n,...e}=t;return(0,s.kt)(La,(0,p.Z)({},va,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Za.isMDXComponent=!0;const ba={toc:[]},Na="wrapper";function Aa(t){let{components:n,...e}=t;return(0,s.kt)(Na,(0,p.Z)({},ba,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Aa.isMDXComponent=!0;const za={toc:[]},Wa="wrapper";function Ia(t){let{components:n,...e}=t;return(0,s.kt)(Wa,(0,p.Z)({},za,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Ia.isMDXComponent=!0;const Ra={toc:[]},Pa="wrapper";function Sa(t){let{components:n,...e}=t;return(0,s.kt)(Pa,(0,p.Z)({},Ra,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}Sa.isMDXComponent=!0;const Ea={toc:[]},Ga="wrapper";function Oa(t){let{components:n,...e}=t;return(0,s.kt)(Ga,(0,p.Z)({},Ea,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Oa.isMDXComponent=!0;const Fa={toc:[]},Ba="wrapper";function Ua(t){let{components:n,...e}=t;return(0,s.kt)(Ba,(0,p.Z)({},Fa,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Ua.isMDXComponent=!0;const Va={toc:[]},qa="wrapper";function ja(t){let{components:n,...e}=t;return(0,s.kt)(qa,(0,p.Z)({},Va,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}ja.isMDXComponent=!0;const Ya={toc:[]},Qa="wrapper";function Ha(t){let{components:n,...e}=t;return(0,s.kt)(Qa,(0,p.Z)({},Ya,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Ha.isMDXComponent=!0;const $a={toc:[]},Ka="wrapper";function Ja(t){let{components:n,...e}=t;return(0,s.kt)(Ka,(0,p.Z)({},$a,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Ja.isMDXComponent=!0;const tl={toc:[]},nl="wrapper";function el(t){let{components:n,...e}=t;return(0,s.kt)(nl,(0,p.Z)({},tl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}el.isMDXComponent=!0;const ol={toc:[]},pl="wrapper";function rl(t){let{components:n,...e}=t;return(0,s.kt)(pl,(0,p.Z)({},ol,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}rl.isMDXComponent=!0;const sl={toc:[]},cl="wrapper";function il(t){let{components:n,...e}=t;return(0,s.kt)(cl,(0,p.Z)({},sl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of times the timer has ticked."))}il.isMDXComponent=!0;const al={toc:[]},ll="wrapper";function ul(t){let{components:n,...e}=t;return(0,s.kt)(ll,(0,p.Z)({},al,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator responsible for running this timer."))}ul.isMDXComponent=!0;const ml={toc:[]},dl="wrapper";function hl(t){let{components:n,...e}=t;return(0,s.kt)(dl,(0,p.Z)({},ml,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the timer ticks."))}hl.isMDXComponent=!0;const kl={toc:[]},fl="wrapper";function yl(t){let{components:n,...e}=t;return(0,s.kt)(fl,(0,p.Z)({},kl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current iteration index."))}yl.isMDXComponent=!0;const Ml={toc:[]},Dl="wrapper";function Xl(t){let{components:n,...e}=t;return(0,s.kt)(Dl,(0,p.Z)({},Ml,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Xl.isMDXComponent=!0;const _l={toc:[]},wl="wrapper";function Tl(t){let{components:n,...e}=t;return(0,s.kt)(wl,(0,p.Z)({},_l,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Tl.isMDXComponent=!0;const Cl={toc:[]},gl="wrapper";function xl(t){let{components:n,...e}=t;return(0,s.kt)(gl,(0,p.Z)({},Cl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}xl.isMDXComponent=!0;const vl={toc:[]},Ll="wrapper";function Zl(t){let{components:n,...e}=t;return(0,s.kt)(Ll,(0,p.Z)({},vl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Zl.isMDXComponent=!0;const bl={toc:[]},Nl="wrapper";function Al(t){let{components:n,...e}=t;return(0,s.kt)(Nl,(0,p.Z)({},bl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Al.isMDXComponent=!0;const zl={toc:[]},Wl="wrapper";function Il(t){let{components:n,...e}=t;return(0,s.kt)(Wl,(0,p.Z)({},zl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Il.isMDXComponent=!0;const Rl={toc:[]},Pl="wrapper";function Sl(t){let{components:n,...e}=t;return(0,s.kt)(Pl,(0,p.Z)({},Rl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Sl.isMDXComponent=!0;const El={toc:[]},Gl="wrapper";function Ol(t){let{components:n,...e}=t;return(0,s.kt)(Gl,(0,p.Z)({},El,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run tasks one after another."))}Ol.isMDXComponent=!0;const Fl={toc:[]},Bl="wrapper";function Ul(t){let{components:n,...e}=t;return(0,s.kt)(Bl,(0,p.Z)({},Fl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Ul.isMDXComponent=!0;const Vl={toc:[]},ql="wrapper";function jl(t){let{components:n,...e}=t;return(0,s.kt)(ql,(0,p.Z)({},Vl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}jl.isMDXComponent=!0;const Yl={toc:[]},Ql="wrapper";function Hl(t){let{components:n,...e}=t;return(0,s.kt)(Ql,(0,p.Z)({},Yl,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Hl.isMDXComponent=!0;const $l={toc:[]},Kl="wrapper";function Jl(t){let{components:n,...e}=t;return(0,s.kt)(Kl,(0,p.Z)({},$l,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay in seconds"))}Jl.isMDXComponent=!0;const tu={toc:[]},nu="wrapper";function eu(t){let{components:n,...e}=t;return(0,s.kt)(nu,(0,p.Z)({},tu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task or callback to run after the delay."))}eu.isMDXComponent=!0;const ou={toc:[]},pu="wrapper";function ru(t){let{components:n,...e}=t;return(0,s.kt)(pu,(0,p.Z)({},ou,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}ru.isMDXComponent=!0;const su={toc:[]},cu="wrapper";function iu(t){let{components:n,...e}=t;return(0,s.kt)(cu,(0,p.Z)({},su,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Call the given callback every N seconds."))}iu.isMDXComponent=!0;const au={toc:[]},lu="wrapper";function uu(t){let{components:n,...e}=t;return(0,s.kt)(lu,(0,p.Z)({},au,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interval between subsequent calls."))}uu.isMDXComponent=!0;const mu={toc:[]},du="wrapper";function hu(t){let{components:n,...e}=t;return(0,s.kt)(du,(0,p.Z)({},mu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to be called."))}hu.isMDXComponent=!0;const ku={toc:[]},fu="wrapper";function yu(t){let{components:n,...e}=t;return(0,s.kt)(fu,(0,p.Z)({},ku,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each iteration waits until the previous one is completed."))}yu.isMDXComponent=!0;const Mu={toc:[]},Du="wrapper";function Xu(t){let{components:n,...e}=t;return(0,s.kt)(Du,(0,p.Z)({},Mu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}Xu.isMDXComponent=!0;const _u={toc:[]},wu="wrapper";function Tu(t){let{components:n,...e}=t;return(0,s.kt)(wu,(0,p.Z)({},_u,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator N times."))}Tu.isMDXComponent=!0;const Cu={toc:[]},gu="wrapper";function xu(t){let{components:n,...e}=t;return(0,s.kt)(gu,(0,p.Z)({},Cu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of iterations."))}xu.isMDXComponent=!0;const vu={toc:[]},Lu="wrapper";function Zu(t){let{components:n,...e}=t;return(0,s.kt)(Lu,(0,p.Z)({},vu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Zu.isMDXComponent=!0;const bu={toc:[]},Nu="wrapper";function Au(t){let{components:n,...e}=t;return(0,s.kt)(Nu,(0,p.Z)({},bu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Au.isMDXComponent=!0;const zu={toc:[]},Wu="wrapper";function Iu(t){let{components:n,...e}=t;return(0,s.kt)(Wu,(0,p.Z)({},zu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Iu.isMDXComponent=!0;const Ru={toc:[]},Pu="wrapper";function Su(t){let{components:n,...e}=t;return(0,s.kt)(Pu,(0,p.Z)({},Ru,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop for the given amount of time."))}Su.isMDXComponent=!0;const Eu={toc:[]},Gu="wrapper";function Ou(t){let{components:n,...e}=t;return(0,s.kt)(Gu,(0,p.Z)({},Eu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration in seconds."))}Ou.isMDXComponent=!0;const Fu={toc:[]},Bu="wrapper";function Uu(t){let{components:n,...e}=t;return(0,s.kt)(Bu,(0,p.Z)({},Fu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Uu.isMDXComponent=!0;const Vu={toc:[]},qu="wrapper";function ju(t){let{components:n,...e}=t;return(0,s.kt)(qu,(0,p.Z)({},Vu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}ju.isMDXComponent=!0;const Yu={toc:[]},Qu="wrapper";function Hu(t){let{components:n,...e}=t;return(0,s.kt)(Qu,(0,p.Z)({},Yu,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Hu.isMDXComponent=!0;const $u={toc:[]},Ku="wrapper";function Ju(t){let{components:n,...e}=t;return(0,s.kt)(Ku,(0,p.Z)({},$u,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop until the given time event."))}Ju.isMDXComponent=!0;const tm={toc:[]},nm="wrapper";function em(t){let{components:n,...e}=t;return(0,s.kt)(nm,(0,p.Z)({},tm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The event."))}em.isMDXComponent=!0;const om={toc:[]},pm="wrapper";function rm(t){let{components:n,...e}=t;return(0,s.kt)(pm,(0,p.Z)({},om,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}rm.isMDXComponent=!0;const sm={toc:[]},cm="wrapper";function im(t){let{components:n,...e}=t;return(0,s.kt)(cm,(0,p.Z)({},sm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Do nothing."))}im.isMDXComponent=!0;const am={toc:[]},lm="wrapper";function um(t){let{components:n,...e}=t;return(0,s.kt)(lm,(0,p.Z)({},am,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}um.isMDXComponent=!0;const mm={toc:[]},dm="wrapper";function hm(t){let{components:n,...e}=t;return(0,s.kt)(dm,(0,p.Z)({},mm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}hm.isMDXComponent=!0;const km={toc:[]},fm="wrapper";function ym(t){let{components:n,...e}=t;return(0,s.kt)(fm,(0,p.Z)({},km,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}ym.isMDXComponent=!0;const Mm={toc:[]},Dm="wrapper";function Xm(t){let{components:n,...e}=t;return(0,s.kt)(Dm,(0,p.Z)({},Mm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Xm.isMDXComponent=!0;const _m={toc:[]},wm="wrapper";function Tm(t){let{components:n,...e}=t;return(0,s.kt)(wm,(0,p.Z)({},_m,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Tm.isMDXComponent=!0;const Cm={toc:[]},gm="wrapper";function xm(t){let{components:n,...e}=t;return(0,s.kt)(gm,(0,p.Z)({},Cm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional name used when displaying this generator in the UI."))}xm.isMDXComponent=!0;const vm={toc:[]},Lm="wrapper";function Zm(t){let{components:n,...e}=t;return(0,s.kt)(Lm,(0,p.Z)({},vm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Zm.isMDXComponent=!0;const bm={toc:[]},Nm="wrapper";function Am(t){let{components:n,...e}=t;return(0,s.kt)(Nm,(0,p.Z)({},bm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Am.isMDXComponent=!0;const zm={toc:[]},Wm="wrapper";function Im(t){let{components:n,...e}=t;return(0,s.kt)(Wm,(0,p.Z)({},zm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Im.isMDXComponent=!0;const Rm={toc:[]},Pm="wrapper";function Sm(t){let{components:n,...e}=t;return(0,s.kt)(Pm,(0,p.Z)({},Rm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Start all tasks one after another with a constant delay between."))}Sm.isMDXComponent=!0;const Em={toc:[]},Gm="wrapper";function Om(t){let{components:n,...e}=t;return(0,s.kt)(Gm,(0,p.Z)({},Em,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay between each of the tasks."))}Om.isMDXComponent=!0;const Fm={toc:[]},Bm="wrapper";function Um(t){let{components:n,...e}=t;return(0,s.kt)(Bm,(0,p.Z)({},Fm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to be run in a sequence."))}Um.isMDXComponent=!0;const Vm={toc:[]},qm="wrapper";function jm(t){let{components:n,...e}=t;return(0,s.kt)(qm,(0,p.Z)({},Vm,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}jm.isMDXComponent=!0;const Ym={toc:[]},Qm="wrapper";function Hm(t){let{components:n,...e}=t;return(0,s.kt)(Qm,(0,p.Z)({},Ym,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the given amount of time."))}Hm.isMDXComponent=!0;const $m={toc:[]},Km="wrapper";function Jm(t){let{components:n,...e}=t;return(0,s.kt)(Km,(0,p.Z)({},$m,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The relative time in seconds."))}Jm.isMDXComponent=!0;const td={toc:[]},nd="wrapper";function ed(t){let{components:n,...e}=t;return(0,s.kt)(nd,(0,p.Z)({},td,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}ed.isMDXComponent=!0;const od={toc:[]},pd="wrapper";function rd(t){let{components:n,...e}=t;return(0,s.kt)(pd,(0,p.Z)({},od,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}rd.isMDXComponent=!0;const sd={toc:[]},cd="wrapper";function id(t){let{components:n,...e}=t;return(0,s.kt)(cd,(0,p.Z)({},sd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}id.isMDXComponent=!0;const ad={toc:[]},ld="wrapper";function ud(t){let{components:n,...e}=t;return(0,s.kt)(ld,(0,p.Z)({},ad,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the given time event."))}ud.isMDXComponent=!0;const md={toc:[]},dd="wrapper";function hd(t){let{components:n,...e}=t;return(0,s.kt)(dd,(0,p.Z)({},md,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the time event."))}hd.isMDXComponent=!0;const kd={toc:[]},fd="wrapper";function yd(t){let{components:n,...e}=t;return(0,s.kt)(fd,(0,p.Z)({},kd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}yd.isMDXComponent=!0;const Md={toc:[]},Dd="wrapper";function Xd(t){let{components:n,...e}=t;return(0,s.kt)(Dd,(0,p.Z)({},Md,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multi-media management."))}Xd.isMDXComponent=!0;const _d={toc:[]},wd="wrapper";function Td(t){let{components:n,...e}=t;return(0,s.kt)(wd,(0,p.Z)({},_d,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Td.isMDXComponent=!0;const Cd={toc:[]},gd="wrapper";function xd(t){let{components:n,...e}=t;return(0,s.kt)(gd,(0,p.Z)({},Cd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause/resume the audio."))}xd.isMDXComponent=!0;const vd={toc:[]},Ld="wrapper";function Zd(t){let{components:n,...e}=t;return(0,s.kt)(Ld,(0,p.Z)({},vd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the audio should be paused or resumed."))}Zd.isMDXComponent=!0;const bd={toc:[]},Nd="wrapper";function Ad(t){let{components:n,...e}=t;return(0,s.kt)(Nd,(0,p.Z)({},bd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The absolute biggest value from the peaks array."))}Ad.isMDXComponent=!0;const zd={toc:[]},Wd="wrapper";function Id(t){let{components:n,...e}=t;return(0,s.kt)(Wd,(0,p.Z)({},zd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of samples taken."))}Id.isMDXComponent=!0;const Rd={toc:[]},Pd="wrapper";function Sd(t){let{components:n,...e}=t;return(0,s.kt)(Pd,(0,p.Z)({},Rd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Sd.isMDXComponent=!0;const Ed={toc:[]},Gd="wrapper";function Od(t){let{components:n,...e}=t;return(0,s.kt)(Gd,(0,p.Z)({},Ed,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Samples per seconds."))}Od.isMDXComponent=!0;const Fd={toc:[]},Bd="wrapper";function Ud(t){let{components:n,...e}=t;return(0,s.kt)(Bd,(0,p.Z)({},Fd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime representation of meta files."))}Ud.isMDXComponent=!0;const Vd={toc:[]},qd="wrapper";function jd(t){let{components:n,...e}=t;return(0,s.kt)(qd,(0,p.Z)({},Vd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a boolean value stored in a meta file."))}jd.isMDXComponent=!0;const Yd={toc:[]},Qd="wrapper";function Hd(t){let{components:n,...e}=t;return(0,s.kt)(Qd,(0,p.Z)({},Yd,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Hd.isMDXComponent=!0;const $d={toc:[]},Kd="wrapper";function Jd(t){let{components:n,...e}=t;return(0,s.kt)(Kd,(0,p.Z)({},$d,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Jd.isMDXComponent=!0;const th={toc:[]},nh="wrapper";function eh(t){let{components:n,...e}=t;return(0,s.kt)(nh,(0,p.Z)({},th,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}eh.isMDXComponent=!0;const oh={toc:[]},ph="wrapper";function rh(t){let{components:n,...e}=t;return(0,s.kt)(ph,(0,p.Z)({},oh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}rh.isMDXComponent=!0;const sh={toc:[]},ch="wrapper";function ih(t){let{components:n,...e}=t;return(0,s.kt)(ch,(0,p.Z)({},sh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}ih.isMDXComponent=!0;const ah={toc:[]},lh="wrapper";function uh(t){let{components:n,...e}=t;return(0,s.kt)(lh,(0,p.Z)({},ah,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}uh.isMDXComponent=!0;const mh={toc:[]},dh="wrapper";function hh(t){let{components:n,...e}=t;return(0,s.kt)(dh,(0,p.Z)({},mh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}hh.isMDXComponent=!0;const kh={toc:[]},fh="wrapper";function yh(t){let{components:n,...e}=t;return(0,s.kt)(fh,(0,p.Z)({},kh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}yh.isMDXComponent=!0;const Mh={toc:[]},Dh="wrapper";function Xh(t){let{components:n,...e}=t;return(0,s.kt)(Dh,(0,p.Z)({},Mh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Xh.isMDXComponent=!0;const _h={toc:[]},wh="wrapper";function Th(t){let{components:n,...e}=t;return(0,s.kt)(wh,(0,p.Z)({},_h,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Th.isMDXComponent=!0;const Ch={toc:[]},gh="wrapper";function xh(t){let{components:n,...e}=t;return(0,s.kt)(gh,(0,p.Z)({},Ch,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}xh.isMDXComponent=!0;const vh={toc:[]},Lh="wrapper";function Zh(t){let{components:n,...e}=t;return(0,s.kt)(Lh,(0,p.Z)({},vh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Zh.isMDXComponent=!0;const bh={toc:[]},Nh="wrapper";function Ah(t){let{components:n,...e}=t;return(0,s.kt)(Nh,(0,p.Z)({},bh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ah.isMDXComponent=!0;const zh={toc:[]},Wh="wrapper";function Ih(t){let{components:n,...e}=t;return(0,s.kt)(Wh,(0,p.Z)({},zh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Ih.isMDXComponent=!0;const Rh={toc:[]},Ph="wrapper";function Sh(t){let{components:n,...e}=t;return(0,s.kt)(Ph,(0,p.Z)({},Rh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Sh.isMDXComponent=!0;const Eh={toc:[]},Gh="wrapper";function Oh(t){let{components:n,...e}=t;return(0,s.kt)(Gh,(0,p.Z)({},Eh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Oh.isMDXComponent=!0;const Fh={toc:[]},Bh="wrapper";function Uh(t){let{components:n,...e}=t;return(0,s.kt)(Bh,(0,p.Z)({},Fh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Uh.isMDXComponent=!0;const Vh={toc:[]},qh="wrapper";function jh(t){let{components:n,...e}=t;return(0,s.kt)(qh,(0,p.Z)({},Vh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}jh.isMDXComponent=!0;const Yh={toc:[]},Qh="wrapper";function Hh(t){let{components:n,...e}=t;return(0,s.kt)(Qh,(0,p.Z)({},Yh,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Hh.isMDXComponent=!0;const $h={toc:[]},Kh="wrapper";function Jh(t){let{components:n,...e}=t;return(0,s.kt)(Kh,(0,p.Z)({},$h,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Jh.isMDXComponent=!0;const tk={toc:[]},nk="wrapper";function ek(t){let{components:n,...e}=t;return(0,s.kt)(nk,(0,p.Z)({},tk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color stored in a meta file."))}ek.isMDXComponent=!0;const ok={toc:[]},pk="wrapper";function rk(t){let{components:n,...e}=t;return(0,s.kt)(pk,(0,p.Z)({},ok,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}rk.isMDXComponent=!0;const sk={toc:[]},ck="wrapper";function ik(t){let{components:n,...e}=t;return(0,s.kt)(ck,(0,p.Z)({},sk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}ik.isMDXComponent=!0;const ak={toc:[]},lk="wrapper";function uk(t){let{components:n,...e}=t;return(0,s.kt)(lk,(0,p.Z)({},ak,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}uk.isMDXComponent=!0;const mk={toc:[]},dk="wrapper";function hk(t){let{components:n,...e}=t;return(0,s.kt)(dk,(0,p.Z)({},mk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}hk.isMDXComponent=!0;const kk={toc:[]},fk="wrapper";function yk(t){let{components:n,...e}=t;return(0,s.kt)(fk,(0,p.Z)({},kk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}yk.isMDXComponent=!0;const Mk={toc:[]},Dk="wrapper";function Xk(t){let{components:n,...e}=t;return(0,s.kt)(Dk,(0,p.Z)({},Mk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Xk.isMDXComponent=!0;const _k={toc:[]},wk="wrapper";function Tk(t){let{components:n,...e}=t;return(0,s.kt)(wk,(0,p.Z)({},_k,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Tk.isMDXComponent=!0;const Ck={toc:[]},gk="wrapper";function xk(t){let{components:n,...e}=t;return(0,s.kt)(gk,(0,p.Z)({},Ck,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}xk.isMDXComponent=!0;const vk={toc:[]},Lk="wrapper";function Zk(t){let{components:n,...e}=t;return(0,s.kt)(Lk,(0,p.Z)({},vk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Zk.isMDXComponent=!0;const bk={toc:[]},Nk="wrapper";function Ak(t){let{components:n,...e}=t;return(0,s.kt)(Nk,(0,p.Z)({},bk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Ak.isMDXComponent=!0;const zk={toc:[]},Wk="wrapper";function Ik(t){let{components:n,...e}=t;return(0,s.kt)(Wk,(0,p.Z)({},zk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ik.isMDXComponent=!0;const Rk={toc:[]},Pk="wrapper";function Sk(t){let{components:n,...e}=t;return(0,s.kt)(Pk,(0,p.Z)({},Rk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Sk.isMDXComponent=!0;const Ek={toc:[]},Gk="wrapper";function Ok(t){let{components:n,...e}=t;return(0,s.kt)(Gk,(0,p.Z)({},Ek,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ok.isMDXComponent=!0;const Fk={toc:[]},Bk="wrapper";function Uk(t){let{components:n,...e}=t;return(0,s.kt)(Bk,(0,p.Z)({},Fk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Uk.isMDXComponent=!0;const Vk={toc:[]},qk="wrapper";function jk(t){let{components:n,...e}=t;return(0,s.kt)(qk,(0,p.Z)({},Vk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}jk.isMDXComponent=!0;const Yk={toc:[]},Qk="wrapper";function Hk(t){let{components:n,...e}=t;return(0,s.kt)(Qk,(0,p.Z)({},Yk,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Hk.isMDXComponent=!0;const $k={toc:[]},Kk="wrapper";function Jk(t){let{components:n,...e}=t;return(0,s.kt)(Kk,(0,p.Z)({},$k,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Jk.isMDXComponent=!0;const tf={toc:[]},nf="wrapper";function ef(t){let{components:n,...e}=t;return(0,s.kt)(nf,(0,p.Z)({},tf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}ef.isMDXComponent=!0;const of={toc:[]},pf="wrapper";function rf(t){let{components:n,...e}=t;return(0,s.kt)(pf,(0,p.Z)({},of,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}rf.isMDXComponent=!0;const sf={toc:[]},cf="wrapper";function af(t){let{components:n,...e}=t;return(0,s.kt)(cf,(0,p.Z)({},sf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}af.isMDXComponent=!0;const lf={toc:[]},uf="wrapper";function mf(t){let{components:n,...e}=t;return(0,s.kt)(uf,(0,p.Z)({},lf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an enum value stored in a meta file."))}mf.isMDXComponent=!0;const df={toc:[]},hf="wrapper";function kf(t){let{components:n,...e}=t;return(0,s.kt)(hf,(0,p.Z)({},df,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}kf.isMDXComponent=!0;const ff={toc:[]},yf="wrapper";function Mf(t){let{components:n,...e}=t;return(0,s.kt)(yf,(0,p.Z)({},ff,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Mf.isMDXComponent=!0;const Df={toc:[]},Xf="wrapper";function _f(t){let{components:n,...e}=t;return(0,s.kt)(Xf,(0,p.Z)({},Df,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}_f.isMDXComponent=!0;const wf={toc:[]},Tf="wrapper";function Cf(t){let{components:n,...e}=t;return(0,s.kt)(Tf,(0,p.Z)({},wf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Cf.isMDXComponent=!0;const gf={toc:[]},xf="wrapper";function vf(t){let{components:n,...e}=t;return(0,s.kt)(xf,(0,p.Z)({},gf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}vf.isMDXComponent=!0;const Lf={toc:[]},Zf="wrapper";function bf(t){let{components:n,...e}=t;return(0,s.kt)(Zf,(0,p.Z)({},Lf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}bf.isMDXComponent=!0;const Nf={toc:[]},Af="wrapper";function zf(t){let{components:n,...e}=t;return(0,s.kt)(Af,(0,p.Z)({},Nf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}zf.isMDXComponent=!0;const Wf={toc:[]},If="wrapper";function Rf(t){let{components:n,...e}=t;return(0,s.kt)(If,(0,p.Z)({},Wf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Rf.isMDXComponent=!0;const Pf={toc:[]},Sf="wrapper";function Ef(t){let{components:n,...e}=t;return(0,s.kt)(Sf,(0,p.Z)({},Pf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ef.isMDXComponent=!0;const Gf={toc:[]},Of="wrapper";function Ff(t){let{components:n,...e}=t;return(0,s.kt)(Of,(0,p.Z)({},Gf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Ff.isMDXComponent=!0;const Bf={toc:[]},Uf="wrapper";function Vf(t){let{components:n,...e}=t;return(0,s.kt)(Uf,(0,p.Z)({},Bf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Vf.isMDXComponent=!0;const qf={toc:[]},jf="wrapper";function Yf(t){let{components:n,...e}=t;return(0,s.kt)(jf,(0,p.Z)({},qf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Yf.isMDXComponent=!0;const Qf={toc:[]},Hf="wrapper";function $f(t){let{components:n,...e}=t;return(0,s.kt)(Hf,(0,p.Z)({},Qf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}$f.isMDXComponent=!0;const Kf={toc:[]},Jf="wrapper";function ty(t){let{components:n,...e}=t;return(0,s.kt)(Jf,(0,p.Z)({},Kf,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}ty.isMDXComponent=!0;const ny={toc:[]},ey="wrapper";function oy(t){let{components:n,...e}=t;return(0,s.kt)(ey,(0,p.Z)({},ny,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}oy.isMDXComponent=!0;const py={toc:[]},ry="wrapper";function sy(t){let{components:n,...e}=t;return(0,s.kt)(ry,(0,p.Z)({},py,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sy.isMDXComponent=!0;const cy={toc:[]},iy="wrapper";function ay(t){let{components:n,...e}=t;return(0,s.kt)(iy,(0,p.Z)({},cy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ay.isMDXComponent=!0;const ly={toc:[]},uy="wrapper";function my(t){let{components:n,...e}=t;return(0,s.kt)(uy,(0,p.Z)({},ly,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}my.isMDXComponent=!0;const dy={toc:[]},hy="wrapper";function ky(t){let{components:n,...e}=t;return(0,s.kt)(hy,(0,p.Z)({},dy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the exporter configuration."))}ky.isMDXComponent=!0;const fy={toc:[]},yy="wrapper";function My(t){let{components:n,...e}=t;return(0,s.kt)(yy,(0,p.Z)({},fy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}My.isMDXComponent=!0;const Dy={toc:[]},Xy="wrapper";function _y(t){let{components:n,...e}=t;return(0,s.kt)(Xy,(0,p.Z)({},Dy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}_y.isMDXComponent=!0;const wy={toc:[]},Ty="wrapper";function Cy(t){let{components:n,...e}=t;return(0,s.kt)(Ty,(0,p.Z)({},wy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Cy.isMDXComponent=!0;const gy={toc:[]},xy="wrapper";function vy(t){let{components:n,...e}=t;return(0,s.kt)(xy,(0,p.Z)({},gy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}vy.isMDXComponent=!0;const Ly={toc:[]},Zy="wrapper";function by(t){let{components:n,...e}=t;return(0,s.kt)(Zy,(0,p.Z)({},Ly,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}by.isMDXComponent=!0;const Ny={toc:[]},Ay="wrapper";function zy(t){let{components:n,...e}=t;return(0,s.kt)(Ay,(0,p.Z)({},Ny,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}zy.isMDXComponent=!0;const Wy={toc:[]},Iy="wrapper";function Ry(t){let{components:n,...e}=t;return(0,s.kt)(Iy,(0,p.Z)({},Wy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Ry.isMDXComponent=!0;const Py={toc:[]},Sy="wrapper";function Ey(t){let{components:n,...e}=t;return(0,s.kt)(Sy,(0,p.Z)({},Py,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Ey.isMDXComponent=!0;const Gy={toc:[]},Oy="wrapper";function Fy(t){let{components:n,...e}=t;return(0,s.kt)(Oy,(0,p.Z)({},Gy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Fy.isMDXComponent=!0;const By={toc:[]},Uy="wrapper";function Vy(t){let{components:n,...e}=t;return(0,s.kt)(Uy,(0,p.Z)({},By,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Vy.isMDXComponent=!0;const qy={toc:[]},jy="wrapper";function Yy(t){let{components:n,...e}=t;return(0,s.kt)(jy,(0,p.Z)({},qy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Yy.isMDXComponent=!0;const Qy={toc:[]},Hy="wrapper";function $y(t){let{components:n,...e}=t;return(0,s.kt)(Hy,(0,p.Z)({},Qy,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}$y.isMDXComponent=!0;const Ky={toc:[]},Jy="wrapper";function tM(t){let{components:n,...e}=t;return(0,s.kt)(Jy,(0,p.Z)({},Ky,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}tM.isMDXComponent=!0;const nM={toc:[]},eM="wrapper";function oM(t){let{components:n,...e}=t;return(0,s.kt)(eM,(0,p.Z)({},nM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}oM.isMDXComponent=!0;const pM={toc:[]},rM="wrapper";function sM(t){let{components:n,...e}=t;return(0,s.kt)(rM,(0,p.Z)({},pM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}sM.isMDXComponent=!0;const cM={toc:[]},iM="wrapper";function aM(t){let{components:n,...e}=t;return(0,s.kt)(iM,(0,p.Z)({},cM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}aM.isMDXComponent=!0;const lM={toc:[]},uM="wrapper";function mM(t){let{components:n,...e}=t;return(0,s.kt)(uM,(0,p.Z)({},lM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}mM.isMDXComponent=!0;const dM={toc:[]},hM="wrapper";function kM(t){let{components:n,...e}=t;return(0,s.kt)(hM,(0,p.Z)({},dM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}kM.isMDXComponent=!0;const fM={toc:[]},yM="wrapper";function MM(t){let{components:n,...e}=t;return(0,s.kt)(yM,(0,p.Z)({},fM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}MM.isMDXComponent=!0;const DM={toc:[]},XM="wrapper";function _M(t){let{components:n,...e}=t;return(0,s.kt)(XM,(0,p.Z)({},DM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an entry in the meta file."))}_M.isMDXComponent=!0;const wM={toc:[]},TM="wrapper";function CM(t){let{components:n,...e}=t;return(0,s.kt)(TM,(0,p.Z)({},wM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}CM.isMDXComponent=!0;const gM={toc:[]},xM="wrapper";function vM(t){let{components:n,...e}=t;return(0,s.kt)(xM,(0,p.Z)({},gM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}vM.isMDXComponent=!0;const LM={toc:[]},ZM="wrapper";function bM(t){let{components:n,...e}=t;return(0,s.kt)(ZM,(0,p.Z)({},LM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bM.isMDXComponent=!0;const NM={toc:[]},AM="wrapper";function zM(t){let{components:n,...e}=t;return(0,s.kt)(AM,(0,p.Z)({},NM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zM.isMDXComponent=!0;const WM={toc:[]},IM="wrapper";function RM(t){let{components:n,...e}=t;return(0,s.kt)(IM,(0,p.Z)({},WM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}RM.isMDXComponent=!0;const PM={toc:[]},SM="wrapper";function EM(t){let{components:n,...e}=t;return(0,s.kt)(SM,(0,p.Z)({},PM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}EM.isMDXComponent=!0;const GM={toc:[]},OM="wrapper";function FM(t){let{components:n,...e}=t;return(0,s.kt)(OM,(0,p.Z)({},GM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}FM.isMDXComponent=!0;const BM={toc:[]},UM="wrapper";function VM(t){let{components:n,...e}=t;return(0,s.kt)(UM,(0,p.Z)({},BM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}VM.isMDXComponent=!0;const qM={toc:[]},jM="wrapper";function YM(t){let{components:n,...e}=t;return(0,s.kt)(jM,(0,p.Z)({},qM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}YM.isMDXComponent=!0;const QM={toc:[]},HM="wrapper";function $M(t){let{components:n,...e}=t;return(0,s.kt)(HM,(0,p.Z)({},QM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}$M.isMDXComponent=!0;const KM={toc:[]},JM="wrapper";function tD(t){let{components:n,...e}=t;return(0,s.kt)(JM,(0,p.Z)({},KM,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}tD.isMDXComponent=!0;const nD={toc:[]},eD="wrapper";function oD(t){let{components:n,...e}=t;return(0,s.kt)(eD,(0,p.Z)({},nD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}oD.isMDXComponent=!0;const pD={toc:[]},rD="wrapper";function sD(t){let{components:n,...e}=t;return(0,s.kt)(rD,(0,p.Z)({},pD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}sD.isMDXComponent=!0;const cD={toc:[]},iD="wrapper";function aD(t){let{components:n,...e}=t;return(0,s.kt)(iD,(0,p.Z)({},cD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}aD.isMDXComponent=!0;const lD={toc:[]},uD="wrapper";function mD(t){let{components:n,...e}=t;return(0,s.kt)(uD,(0,p.Z)({},lD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}mD.isMDXComponent=!0;const dD={toc:[]},hD="wrapper";function kD(t){let{components:n,...e}=t;return(0,s.kt)(hD,(0,p.Z)({},dD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}kD.isMDXComponent=!0;const fD={toc:[]},yD="wrapper";function MD(t){let{components:n,...e}=t;return(0,s.kt)(yD,(0,p.Z)({},fD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}MD.isMDXComponent=!0;const DD={toc:[]},XD="wrapper";function _D(t){let{components:n,...e}=t;return(0,s.kt)(XD,(0,p.Z)({},DD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}_D.isMDXComponent=!0;const wD={toc:[]},TD="wrapper";function CD(t){let{components:n,...e}=t;return(0,s.kt)(TD,(0,p.Z)({},wD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}CD.isMDXComponent=!0;const gD={toc:[]},xD="wrapper";function vD(t){let{components:n,...e}=t;return(0,s.kt)(xD,(0,p.Z)({},gD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}vD.isMDXComponent=!0;const LD={toc:[]},ZD="wrapper";function bD(t){let{components:n,...e}=t;return(0,s.kt)(ZD,(0,p.Z)({},LD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type used to store this field in the meta\nfile."))}bD.isMDXComponent=!0;const ND={toc:[]},AD="wrapper";function zD(t){let{components:n,...e}=t;return(0,s.kt)(AD,(0,p.Z)({},ND,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime type of this field."))}zD.isMDXComponent=!0;const WD={toc:[]},ID="wrapper";function RD(t){let{components:n,...e}=t;return(0,s.kt)(ID,(0,p.Z)({},WD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a number stored in a meta file."))}RD.isMDXComponent=!0;const PD={toc:[]},SD="wrapper";function ED(t){let{components:n,...e}=t;return(0,s.kt)(SD,(0,p.Z)({},PD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}ED.isMDXComponent=!0;const GD={toc:[]},OD="wrapper";function FD(t){let{components:n,...e}=t;return(0,s.kt)(OD,(0,p.Z)({},GD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}FD.isMDXComponent=!0;const BD={toc:[]},UD="wrapper";function VD(t){let{components:n,...e}=t;return(0,s.kt)(UD,(0,p.Z)({},BD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}VD.isMDXComponent=!0;const qD={toc:[]},jD="wrapper";function YD(t){let{components:n,...e}=t;return(0,s.kt)(jD,(0,p.Z)({},qD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}YD.isMDXComponent=!0;const QD={toc:[]},HD="wrapper";function $D(t){let{components:n,...e}=t;return(0,s.kt)(HD,(0,p.Z)({},QD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}$D.isMDXComponent=!0;const KD={toc:[]},JD="wrapper";function tX(t){let{components:n,...e}=t;return(0,s.kt)(JD,(0,p.Z)({},KD,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tX.isMDXComponent=!0;const nX={toc:[]},eX="wrapper";function oX(t){let{components:n,...e}=t;return(0,s.kt)(eX,(0,p.Z)({},nX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}oX.isMDXComponent=!0;const pX={toc:[]},rX="wrapper";function sX(t){let{components:n,...e}=t;return(0,s.kt)(rX,(0,p.Z)({},pX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}sX.isMDXComponent=!0;const cX={toc:[]},iX="wrapper";function aX(t){let{components:n,...e}=t;return(0,s.kt)(iX,(0,p.Z)({},cX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}aX.isMDXComponent=!0;const lX={toc:[]},uX="wrapper";function mX(t){let{components:n,...e}=t;return(0,s.kt)(uX,(0,p.Z)({},lX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}mX.isMDXComponent=!0;const dX={toc:[]},hX="wrapper";function kX(t){let{components:n,...e}=t;return(0,s.kt)(hX,(0,p.Z)({},dX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}kX.isMDXComponent=!0;const fX={toc:[]},yX="wrapper";function MX(t){let{components:n,...e}=t;return(0,s.kt)(yX,(0,p.Z)({},fX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}MX.isMDXComponent=!0;const DX={toc:[]},XX="wrapper";function _X(t){let{components:n,...e}=t;return(0,s.kt)(XX,(0,p.Z)({},DX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}_X.isMDXComponent=!0;const wX={toc:[]},TX="wrapper";function CX(t){let{components:n,...e}=t;return(0,s.kt)(TX,(0,p.Z)({},wX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}CX.isMDXComponent=!0;const gX={toc:[]},xX="wrapper";function vX(t){let{components:n,...e}=t;return(0,s.kt)(xX,(0,p.Z)({},gX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}vX.isMDXComponent=!0;const LX={toc:[]},ZX="wrapper";function bX(t){let{components:n,...e}=t;return(0,s.kt)(ZX,(0,p.Z)({},LX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}bX.isMDXComponent=!0;const NX={toc:[]},AX="wrapper";function zX(t){let{components:n,...e}=t;return(0,s.kt)(AX,(0,p.Z)({},NX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}zX.isMDXComponent=!0;const WX={toc:[]},IX="wrapper";function RX(t){let{components:n,...e}=t;return(0,s.kt)(IX,(0,p.Z)({},WX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}RX.isMDXComponent=!0;const PX={toc:[]},SX="wrapper";function EX(t){let{components:n,...e}=t;return(0,s.kt)(SX,(0,p.Z)({},PX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}EX.isMDXComponent=!0;const GX={toc:[]},OX="wrapper";function FX(t){let{components:n,...e}=t;return(0,s.kt)(OX,(0,p.Z)({},GX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}FX.isMDXComponent=!0;const BX={toc:[]},UX="wrapper";function VX(t){let{components:n,...e}=t;return(0,s.kt)(UX,(0,p.Z)({},BX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Range is an array with two elements denoting the beginning and end of a\nrange, respectively."))}VX.isMDXComponent=!0;const qX={toc:[]},jX="wrapper";function YX(t){let{components:n,...e}=t;return(0,s.kt)(jX,(0,p.Z)({},qX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a range stored in a meta file."))}YX.isMDXComponent=!0;const QX={toc:[]},HX="wrapper";function $X(t){let{components:n,...e}=t;return(0,s.kt)(HX,(0,p.Z)({},QX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}$X.isMDXComponent=!0;const KX={toc:[]},JX="wrapper";function t_(t){let{components:n,...e}=t;return(0,s.kt)(JX,(0,p.Z)({},KX,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}t_.isMDXComponent=!0;const n_={toc:[]},e_="wrapper";function o_(t){let{components:n,...e}=t;return(0,s.kt)(e_,(0,p.Z)({},n_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}o_.isMDXComponent=!0;const p_={toc:[]},r_="wrapper";function s_(t){let{components:n,...e}=t;return(0,s.kt)(r_,(0,p.Z)({},p_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}s_.isMDXComponent=!0;const c_={toc:[]},i_="wrapper";function a_(t){let{components:n,...e}=t;return(0,s.kt)(i_,(0,p.Z)({},c_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}a_.isMDXComponent=!0;const l_={toc:[]},u_="wrapper";function m_(t){let{components:n,...e}=t;return(0,s.kt)(u_,(0,p.Z)({},l_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}m_.isMDXComponent=!0;const d_={toc:[]},h_="wrapper";function k_(t){let{components:n,...e}=t;return(0,s.kt)(h_,(0,p.Z)({},d_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}k_.isMDXComponent=!0;const f_={toc:[]},y_="wrapper";function M_(t){let{components:n,...e}=t;return(0,s.kt)(y_,(0,p.Z)({},f_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}M_.isMDXComponent=!0;const D_={toc:[]},X_="wrapper";function __(t){let{components:n,...e}=t;return(0,s.kt)(X_,(0,p.Z)({},D_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}__.isMDXComponent=!0;const w_={toc:[]},T_="wrapper";function C_(t){let{components:n,...e}=t;return(0,s.kt)(T_,(0,p.Z)({},w_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}C_.isMDXComponent=!0;const g_={toc:[]},x_="wrapper";function v_(t){let{components:n,...e}=t;return(0,s.kt)(x_,(0,p.Z)({},g_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}v_.isMDXComponent=!0;const L_={toc:[]},Z_="wrapper";function b_(t){let{components:n,...e}=t;return(0,s.kt)(Z_,(0,p.Z)({},L_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}b_.isMDXComponent=!0;const N_={toc:[]},A_="wrapper";function z_(t){let{components:n,...e}=t;return(0,s.kt)(A_,(0,p.Z)({},N_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}z_.isMDXComponent=!0;const W_={toc:[]},I_="wrapper";function R_(t){let{components:n,...e}=t;return(0,s.kt)(I_,(0,p.Z)({},W_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}R_.isMDXComponent=!0;const P_={toc:[]},S_="wrapper";function E_(t){let{components:n,...e}=t;return(0,s.kt)(S_,(0,p.Z)({},P_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}E_.isMDXComponent=!0;const G_={toc:[]},O_="wrapper";function F_(t){let{components:n,...e}=t;return(0,s.kt)(O_,(0,p.Z)({},G_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}F_.isMDXComponent=!0;const B_={toc:[]},U_="wrapper";function V_(t){let{components:n,...e}=t;return(0,s.kt)(U_,(0,p.Z)({},B_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}V_.isMDXComponent=!0;const q_={toc:[]},j_="wrapper";function Y_(t){let{components:n,...e}=t;return(0,s.kt)(j_,(0,p.Z)({},q_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Y_.isMDXComponent=!0;const Q_={toc:[]},H_="wrapper";function $_(t){let{components:n,...e}=t;return(0,s.kt)(H_,(0,p.Z)({},Q_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}$_.isMDXComponent=!0;const K_={toc:[]},J_="wrapper";function tw(t){let{components:n,...e}=t;return(0,s.kt)(J_,(0,p.Z)({},K_,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}tw.isMDXComponent=!0;const nw={toc:[]},ew="wrapper";function ow(t){let{components:n,...e}=t;return(0,s.kt)(ew,(0,p.Z)({},nw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This helper method applies additional validation to the range, preventing\nit from overflowing the timeline."))}ow.isMDXComponent=!0;const pw={toc:[]},rw="wrapper";function sw(t){let{components:n,...e}=t;return(0,s.kt)(rw,(0,p.Z)({},pw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given range from frames to seconds and update this field."))}sw.isMDXComponent=!0;const cw={toc:[]},iw="wrapper";function aw(t){let{components:n,...e}=t;return(0,s.kt)(iw,(0,p.Z)({},cw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The beginning of the range."))}aw.isMDXComponent=!0;const lw={toc:[]},uw="wrapper";function mw(t){let{components:n,...e}=t;return(0,s.kt)(uw,(0,p.Z)({},lw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}mw.isMDXComponent=!0;const dw={toc:[]},hw="wrapper";function kw(t){let{components:n,...e}=t;return(0,s.kt)(hw,(0,p.Z)({},dw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current duration in frames."))}kw.isMDXComponent=!0;const fw={toc:[]},yw="wrapper";function Mw(t){let{components:n,...e}=t;return(0,s.kt)(yw,(0,p.Z)({},fw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current framerate."))}Mw.isMDXComponent=!0;const Dw={toc:[]},Xw="wrapper";function _w(t){let{components:n,...e}=t;return(0,s.kt)(Xw,(0,p.Z)({},Dw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a string stored in a meta file."))}_w.isMDXComponent=!0;const ww={toc:[]},Tw="wrapper";function Cw(t){let{components:n,...e}=t;return(0,s.kt)(Tw,(0,p.Z)({},ww,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Cw.isMDXComponent=!0;const gw={toc:[]},xw="wrapper";function vw(t){let{components:n,...e}=t;return(0,s.kt)(xw,(0,p.Z)({},gw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}vw.isMDXComponent=!0;const Lw={toc:[]},Zw="wrapper";function bw(t){let{components:n,...e}=t;return(0,s.kt)(Zw,(0,p.Z)({},Lw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bw.isMDXComponent=!0;const Nw={toc:[]},Aw="wrapper";function zw(t){let{components:n,...e}=t;return(0,s.kt)(Aw,(0,p.Z)({},Nw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zw.isMDXComponent=!0;const Ww={toc:[]},Iw="wrapper";function Rw(t){let{components:n,...e}=t;return(0,s.kt)(Iw,(0,p.Z)({},Ww,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Rw.isMDXComponent=!0;const Pw={toc:[]},Sw="wrapper";function Ew(t){let{components:n,...e}=t;return(0,s.kt)(Sw,(0,p.Z)({},Pw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Ew.isMDXComponent=!0;const Gw={toc:[]},Ow="wrapper";function Fw(t){let{components:n,...e}=t;return(0,s.kt)(Ow,(0,p.Z)({},Gw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Fw.isMDXComponent=!0;const Bw={toc:[]},Uw="wrapper";function Vw(t){let{components:n,...e}=t;return(0,s.kt)(Uw,(0,p.Z)({},Bw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Vw.isMDXComponent=!0;const qw={toc:[]},jw="wrapper";function Yw(t){let{components:n,...e}=t;return(0,s.kt)(jw,(0,p.Z)({},qw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Yw.isMDXComponent=!0;const Qw={toc:[]},Hw="wrapper";function $w(t){let{components:n,...e}=t;return(0,s.kt)(Hw,(0,p.Z)({},Qw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}$w.isMDXComponent=!0;const Kw={toc:[]},Jw="wrapper";function tT(t){let{components:n,...e}=t;return(0,s.kt)(Jw,(0,p.Z)({},Kw,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}tT.isMDXComponent=!0;const nT={toc:[]},eT="wrapper";function oT(t){let{components:n,...e}=t;return(0,s.kt)(eT,(0,p.Z)({},nT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}oT.isMDXComponent=!0;const pT={toc:[]},rT="wrapper";function sT(t){let{components:n,...e}=t;return(0,s.kt)(rT,(0,p.Z)({},pT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}sT.isMDXComponent=!0;const cT={toc:[]},iT="wrapper";function aT(t){let{components:n,...e}=t;return(0,s.kt)(iT,(0,p.Z)({},cT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}aT.isMDXComponent=!0;const lT={toc:[]},uT="wrapper";function mT(t){let{components:n,...e}=t;return(0,s.kt)(uT,(0,p.Z)({},lT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}mT.isMDXComponent=!0;const dT={toc:[]},hT="wrapper";function kT(t){let{components:n,...e}=t;return(0,s.kt)(hT,(0,p.Z)({},dT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}kT.isMDXComponent=!0;const fT={toc:[]},yT="wrapper";function MT(t){let{components:n,...e}=t;return(0,s.kt)(yT,(0,p.Z)({},fT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}MT.isMDXComponent=!0;const DT={toc:[]},XT="wrapper";function _T(t){let{components:n,...e}=t;return(0,s.kt)(XT,(0,p.Z)({},DT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}_T.isMDXComponent=!0;const wT={toc:[]},TT="wrapper";function CT(t){let{components:n,...e}=t;return(0,s.kt)(TT,(0,p.Z)({},wT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}CT.isMDXComponent=!0;const gT={toc:[]},xT="wrapper";function vT(t){let{components:n,...e}=t;return(0,s.kt)(xT,(0,p.Z)({},gT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}vT.isMDXComponent=!0;const LT={toc:[]},ZT="wrapper";function bT(t){let{components:n,...e}=t;return(0,s.kt)(ZT,(0,p.Z)({},LT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector stored in a meta file."))}bT.isMDXComponent=!0;const NT={toc:[]},AT="wrapper";function zT(t){let{components:n,...e}=t;return(0,s.kt)(AT,(0,p.Z)({},NT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zT.isMDXComponent=!0;const WT={toc:[]},IT="wrapper";function RT(t){let{components:n,...e}=t;return(0,s.kt)(IT,(0,p.Z)({},WT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}RT.isMDXComponent=!0;const PT={toc:[]},ST="wrapper";function ET(t){let{components:n,...e}=t;return(0,s.kt)(ST,(0,p.Z)({},PT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}ET.isMDXComponent=!0;const GT={toc:[]},OT="wrapper";function FT(t){let{components:n,...e}=t;return(0,s.kt)(OT,(0,p.Z)({},GT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}FT.isMDXComponent=!0;const BT={toc:[]},UT="wrapper";function VT(t){let{components:n,...e}=t;return(0,s.kt)(UT,(0,p.Z)({},BT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}VT.isMDXComponent=!0;const qT={toc:[]},jT="wrapper";function YT(t){let{components:n,...e}=t;return(0,s.kt)(jT,(0,p.Z)({},qT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}YT.isMDXComponent=!0;const QT={toc:[]},HT="wrapper";function $T(t){let{components:n,...e}=t;return(0,s.kt)(HT,(0,p.Z)({},QT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}$T.isMDXComponent=!0;const KT={toc:[]},JT="wrapper";function tC(t){let{components:n,...e}=t;return(0,s.kt)(JT,(0,p.Z)({},KT,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}tC.isMDXComponent=!0;const nC={toc:[]},eC="wrapper";function oC(t){let{components:n,...e}=t;return(0,s.kt)(eC,(0,p.Z)({},nC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}oC.isMDXComponent=!0;const pC={toc:[]},rC="wrapper";function sC(t){let{components:n,...e}=t;return(0,s.kt)(rC,(0,p.Z)({},pC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}sC.isMDXComponent=!0;const cC={toc:[]},iC="wrapper";function aC(t){let{components:n,...e}=t;return(0,s.kt)(iC,(0,p.Z)({},cC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}aC.isMDXComponent=!0;const lC={toc:[]},uC="wrapper";function mC(t){let{components:n,...e}=t;return(0,s.kt)(uC,(0,p.Z)({},lC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mC.isMDXComponent=!0;const dC={toc:[]},hC="wrapper";function kC(t){let{components:n,...e}=t;return(0,s.kt)(hC,(0,p.Z)({},dC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}kC.isMDXComponent=!0;const fC={toc:[]},yC="wrapper";function MC(t){let{components:n,...e}=t;return(0,s.kt)(yC,(0,p.Z)({},fC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}MC.isMDXComponent=!0;const DC={toc:[]},XC="wrapper";function _C(t){let{components:n,...e}=t;return(0,s.kt)(XC,(0,p.Z)({},DC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}_C.isMDXComponent=!0;const wC={toc:[]},TC="wrapper";function CC(t){let{components:n,...e}=t;return(0,s.kt)(TC,(0,p.Z)({},wC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}CC.isMDXComponent=!0;const gC={toc:[]},xC="wrapper";function vC(t){let{components:n,...e}=t;return(0,s.kt)(xC,(0,p.Z)({},gC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}vC.isMDXComponent=!0;const LC={toc:[]},ZC="wrapper";function bC(t){let{components:n,...e}=t;return(0,s.kt)(ZC,(0,p.Z)({},LC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}bC.isMDXComponent=!0;const NC={toc:[]},AC="wrapper";function zC(t){let{components:n,...e}=t;return(0,s.kt)(AC,(0,p.Z)({},NC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}zC.isMDXComponent=!0;const WC={toc:[]},IC="wrapper";function RC(t){let{components:n,...e}=t;return(0,s.kt)(IC,(0,p.Z)({},WC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}RC.isMDXComponent=!0;const PC={toc:[]},SC="wrapper";function EC(t){let{components:n,...e}=t;return(0,s.kt)(SC,(0,p.Z)({},PC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}EC.isMDXComponent=!0;const GC={toc:[]},OC="wrapper";function FC(t){let{components:n,...e}=t;return(0,s.kt)(OC,(0,p.Z)({},GC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}FC.isMDXComponent=!0;const BC={toc:[]},UC="wrapper";function VC(t){let{components:n,...e}=t;return(0,s.kt)(UC,(0,p.Z)({},BC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a runtime Motion Canvas plugin."))}VC.isMDXComponent=!0;const qC={toc:[]},jC="wrapper";function YC(t){let{components:n,...e}=t;return(0,s.kt)(jC,(0,p.Z)({},qC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name should be unique across the entire ecosystem of Motion Canvas.\nIf a plugin with the same name has already been registered, this plugin\nwill be ignored."),(0,s.kt)("p",null,"If you intend to publish your plugin to npm, it is recommended to prefix\nthis name with the name of your npm package."),(0,s.kt)("p",null,"Other identifiers defined by the plugin, such as a tab id, will be\nautomatically prefixed with this name and as such don't have to be unique."))}YC.isMDXComponent=!0;const QC={toc:[]},HC="wrapper";function $C(t){let{components:n,...e}=t;return(0,s.kt)(HC,(0,p.Z)({},QC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unique name of the plugin."))}$C.isMDXComponent=!0;const KC={toc:[]},JC="wrapper";function tg(t){let{components:n,...e}=t;return(0,s.kt)(JC,(0,p.Z)({},KC,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide custom exporters for the project."))}tg.isMDXComponent=!0;const ng={toc:[]},eg="wrapper";function og(t){let{components:n,...e}=t;return(0,s.kt)(eg,(0,p.Z)({},ng,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}og.isMDXComponent=!0;const pg={toc:[]},rg="wrapper";function sg(t){let{components:n,...e}=t;return(0,s.kt)(rg,(0,p.Z)({},pg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the player instance right after it is initialized."))}sg.isMDXComponent=!0;const cg={toc:[]},ig="wrapper";function ag(t){let{components:n,...e}=t;return(0,s.kt)(ig,(0,p.Z)({},cg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player instance."))}ag.isMDXComponent=!0;const lg={toc:[]},ug="wrapper";function mg(t){let{components:n,...e}=t;return(0,s.kt)(ug,(0,p.Z)({},lg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the presenter instance right after it is initialized."))}mg.isMDXComponent=!0;const dg={toc:[]},hg="wrapper";function kg(t){let{components:n,...e}=t;return(0,s.kt)(hg,(0,p.Z)({},dg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presenter instance."))}kg.isMDXComponent=!0;const fg={toc:[]},yg="wrapper";function Mg(t){let{components:n,...e}=t;return(0,s.kt)(yg,(0,p.Z)({},fg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the project instance right after it is initialized."))}Mg.isMDXComponent=!0;const Dg={toc:[]},Xg="wrapper";function _g(t){let{components:n,...e}=t;return(0,s.kt)(Xg,(0,p.Z)({},Dg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}_g.isMDXComponent=!0;const wg={toc:[]},Tg="wrapper";function Cg(t){let{components:n,...e}=t;return(0,s.kt)(Tg,(0,p.Z)({},wg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the renderer instance right after it is initialized."))}Cg.isMDXComponent=!0;const gg={toc:[]},xg="wrapper";function vg(t){let{components:n,...e}=t;return(0,s.kt)(xg,(0,p.Z)({},gg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The renderer instance."))}vg.isMDXComponent=!0;const Lg={toc:[]},Zg="wrapper";function bg(t){let{components:n,...e}=t;return(0,s.kt)(Zg,(0,p.Z)({},Lg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Modify the project settings before the project is initialized."))}bg.isMDXComponent=!0;const Ng={toc:[]},Ag="wrapper";function zg(t){let{components:n,...e}=t;return(0,s.kt)(Ag,(0,p.Z)({},Ng,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project settings."))}zg.isMDXComponent=!0;const Wg={toc:[]},Ig="wrapper";function Rg(t){let{components:n,...e}=t;return(0,s.kt)(Ig,(0,p.Z)({},Wg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makePlugin({\n  name: 'my-custom-plugin',\n});\n")))}Rg.isMDXComponent=!0;const Pg={toc:[]},Sg="wrapper";function Eg(t){let{components:n,...e}=t;return(0,s.kt)(Sg,(0,p.Z)({},Pg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper function for exporting Motion Canvas plugins."))}Eg.isMDXComponent=!0;const Gg={toc:[]},Og="wrapper";function Fg(t){let{components:n,...e}=t;return(0,s.kt)(Og,(0,p.Z)({},Gg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The plugin configuration."))}Fg.isMDXComponent=!0;const Bg={toc:[]},Ug="wrapper";function Vg(t){let{components:n,...e}=t;return(0,s.kt)(Ug,(0,p.Z)({},Bg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abstract scene representations and related utilities."))}Vg.isMDXComponent=!0;const qg={toc:[]},jg="wrapper";function Yg(t){let{components:n,...e}=t;return(0,s.kt)(jg,(0,p.Z)({},qg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Signifies the various stages of a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}Yg.isMDXComponent=!0;const Qg={toc:[]},Hg="wrapper";function $g(t){let{components:n,...e}=t;return(0,s.kt)(Hg,(0,p.Z)({},Qg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs after a render ends."))}$g.isMDXComponent=!0;const Kg={toc:[]},Jg="wrapper";function tx(t){let{components:n,...e}=t;return(0,s.kt)(Jg,(0,p.Z)({},Kg,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}tx.isMDXComponent=!0;const nx={toc:[]},ex="wrapper";function ox(t){let{components:n,...e}=t;return(0,s.kt)(ex,(0,p.Z)({},nx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}ox.isMDXComponent=!0;const px={toc:[]},rx="wrapper";function sx(t){let{components:n,...e}=t;return(0,s.kt)(rx,(0,p.Z)({},px,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}sx.isMDXComponent=!0;const cx={toc:[]},ix="wrapper";function ax(t){let{components:n,...e}=t;return(0,s.kt)(ix,(0,p.Z)({},cx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes the state of a scene."))}ax.isMDXComponent=!0;const lx={toc:[]},ux="wrapper";function mx(t){let{components:n,...e}=t;return(0,s.kt)(ux,(0,p.Z)({},lx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}mx.isMDXComponent=!0;const dx={toc:[]},hx="wrapper";function kx(t){let{components:n,...e}=t;return(0,s.kt)(hx,(0,p.Z)({},dx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished transitioning in."))}kx.isMDXComponent=!0;const fx={toc:[]},yx="wrapper";function Mx(t){let{components:n,...e}=t;return(0,s.kt)(yx,(0,p.Z)({},fx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Mx.isMDXComponent=!0;const Dx={toc:[]},Xx="wrapper";function _x(t){let{components:n,...e}=t;return(0,s.kt)(Xx,(0,p.Z)({},Dx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene is ready to transition out."))}_x.isMDXComponent=!0;const wx={toc:[]},Tx="wrapper";function Cx(t){let{components:n,...e}=t;return(0,s.kt)(Tx,(0,p.Z)({},wx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoking ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}Cx.isMDXComponent=!0;const gx={toc:[]},xx="wrapper";function vx(t){let{components:n,...e}=t;return(0,s.kt)(xx,(0,p.Z)({},gx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished."))}vx.isMDXComponent=!0;const Lx={toc:[]},Zx="wrapper";function bx(t){let{components:n,...e}=t;return(0,s.kt)(Zx,(0,p.Z)({},Lx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has just been created/reset."))}bx.isMDXComponent=!0;const Nx={toc:[]},Ax="wrapper";function zx(t){let{components:n,...e}=t;return(0,s.kt)(Ax,(0,p.Z)({},Nx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The default implementation of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.kt)("p",null,"Uses generators to control the animation."))}zx.isMDXComponent=!0;const Wx={toc:[]},Ix="wrapper";function Rx(t){let{components:n,...e}=t;return(0,s.kt)(Ix,(0,p.Z)({},Wx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}Rx.isMDXComponent=!0;const Px={toc:[]},Sx="wrapper";function Ex(t){let{components:n,...e}=t;return(0,s.kt)(Sx,(0,p.Z)({},Px,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}Ex.isMDXComponent=!0;const Gx={toc:[]},Ox="wrapper";function Fx(t){let{components:n,...e}=t;return(0,s.kt)(Ox,(0,p.Z)({},Gx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}Fx.isMDXComponent=!0;const Bx={toc:[]},Ux="wrapper";function Vx(t){let{components:n,...e}=t;return(0,s.kt)(Ux,(0,p.Z)({},Bx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Should this scene be rendered below the previous scene during a transition?"))}Vx.isMDXComponent=!0;const qx={toc:[]},jx="wrapper";function Yx(t){let{components:n,...e}=t;return(0,s.kt)(jx,(0,p.Z)({},qx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Yx.isMDXComponent=!0;const Qx={toc:[]},Hx="wrapper";function $x(t){let{components:n,...e}=t;return(0,s.kt)(Hx,(0,p.Z)({},Qx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}$x.isMDXComponent=!0;const Kx={toc:[]},Jx="wrapper";function tv(t){let{components:n,...e}=t;return(0,s.kt)(Jx,(0,p.Z)({},Kx,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}tv.isMDXComponent=!0;const nv={toc:[]},ev="wrapper";function ov(t){let{components:n,...e}=t;return(0,s.kt)(ev,(0,p.Z)({},nv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}ov.isMDXComponent=!0;const pv={toc:[]},rv="wrapper";function sv(t){let{components:n,...e}=t;return(0,s.kt)(rv,(0,p.Z)({},pv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}sv.isMDXComponent=!0;const cv={toc:[]},iv="wrapper";function av(t){let{components:n,...e}=t;return(0,s.kt)(iv,(0,p.Z)({},cv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}av.isMDXComponent=!0;const lv={toc:[]},uv="wrapper";function mv(t){let{components:n,...e}=t;return(0,s.kt)(uv,(0,p.Z)({},lv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}mv.isMDXComponent=!0;const dv={toc:[]},hv="wrapper";function kv(t){let{components:n,...e}=t;return(0,s.kt)(hv,(0,p.Z)({},dv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}kv.isMDXComponent=!0;const fv={toc:[]},yv="wrapper";function Mv(t){let{components:n,...e}=t;return(0,s.kt)(yv,(0,p.Z)({},fv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}Mv.isMDXComponent=!0;const Dv={toc:[]},Xv="wrapper";function _v(t){let{components:n,...e}=t;return(0,s.kt)(Xv,(0,p.Z)({},Dv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}_v.isMDXComponent=!0;const wv={toc:[]},Tv="wrapper";function Cv(t){let{components:n,...e}=t;return(0,s.kt)(Tv,(0,p.Z)({},wv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Cv.isMDXComponent=!0;const gv={toc:[]},xv="wrapper";function vv(t){let{components:n,...e}=t;return(0,s.kt)(xv,(0,p.Z)({},gv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}vv.isMDXComponent=!0;const Lv={toc:[]},Zv="wrapper";function bv(t){let{components:n,...e}=t;return(0,s.kt)(Zv,(0,p.Z)({},Lv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}bv.isMDXComponent=!0;const Nv={toc:[]},Av="wrapper";function zv(t){let{components:n,...e}=t;return(0,s.kt)(Av,(0,p.Z)({},Nv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}zv.isMDXComponent=!0;const Wv={toc:[]},Iv="wrapper";function Rv(t){let{components:n,...e}=t;return(0,s.kt)(Iv,(0,p.Z)({},Wv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}Rv.isMDXComponent=!0;const Pv={toc:[]},Sv="wrapper";function Ev(t){let{components:n,...e}=t;return(0,s.kt)(Sv,(0,p.Z)({},Pv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}Ev.isMDXComponent=!0;const Gv={toc:[]},Ov="wrapper";function Fv(t){let{components:n,...e}=t;return(0,s.kt)(Ov,(0,p.Z)({},Gv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}Fv.isMDXComponent=!0;const Bv={toc:[]},Uv="wrapper";function Vv(t){let{components:n,...e}=t;return(0,s.kt)(Uv,(0,p.Z)({},Bv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}Vv.isMDXComponent=!0;const qv={toc:[]},jv="wrapper";function Yv(t){let{components:n,...e}=t;return(0,s.kt)(jv,(0,p.Z)({},qv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the size of the scene multiplied by the resolution scale.\nThis is the actual size of the canvas onto which the scene is rendered."))}Yv.isMDXComponent=!0;const Qv={toc:[]},Hv="wrapper";function $v(t){let{components:n,...e}=t;return(0,s.kt)(Hv,(0,p.Z)({},Qv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real size of this scene."))}$v.isMDXComponent=!0;const Kv={toc:[]},Jv="wrapper";function tL(t){let{components:n,...e}=t;return(0,s.kt)(Jv,(0,p.Z)({},Kv,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually returns ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}tL.isMDXComponent=!0;const nL={toc:[]},eL="wrapper";function oL(t){let{components:n,...e}=t;return(0,s.kt)(eL,(0,p.Z)({},nL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."))}oL.isMDXComponent=!0;const pL={toc:[]},rL="wrapper";function sL(t){let{components:n,...e}=t;return(0,s.kt)(rL,(0,p.Z)({},pL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}sL.isMDXComponent=!0;const cL={toc:[]},iL="wrapper";function aL(t){let{components:n,...e}=t;return(0,s.kt)(iL,(0,p.Z)({},cL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}aL.isMDXComponent=!0;const lL={toc:[]},uL="wrapper";function mL(t){let{components:n,...e}=t;return(0,s.kt)(uL,(0,p.Z)({},lL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"))}mL.isMDXComponent=!0;const dL={toc:[]},hL="wrapper";function kL(t){let{components:n,...e}=t;return(0,s.kt)(hL,(0,p.Z)({},dL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}kL.isMDXComponent=!0;const fL={toc:[]},yL="wrapper";function ML(t){let{components:n,...e}=t;return(0,s.kt)(yL,(0,p.Z)({},fL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}ML.isMDXComponent=!0;const DL={toc:[]},XL="wrapper";function _L(t){let{components:n,...e}=t;return(0,s.kt)(XL,(0,p.Z)({},DL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}_L.isMDXComponent=!0;const wL={toc:[]},TL="wrapper";function CL(t){let{components:n,...e}=t;return(0,s.kt)(TL,(0,p.Z)({},wL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}CL.isMDXComponent=!0;const gL={toc:[]},xL="wrapper";function vL(t){let{components:n,...e}=t;return(0,s.kt)(xL,(0,p.Z)({},gL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}vL.isMDXComponent=!0;const LL={toc:[]},ZL="wrapper";function bL(t){let{components:n,...e}=t;return(0,s.kt)(ZL,(0,p.Z)({},LL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}bL.isMDXComponent=!0;const NL={toc:[]},AL="wrapper";function zL(t){let{components:n,...e}=t;return(0,s.kt)(AL,(0,p.Z)({},NL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}zL.isMDXComponent=!0;const WL={toc:[]},IL="wrapper";function RL(t){let{components:n,...e}=t;return(0,s.kt)(IL,(0,p.Z)({},WL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}RL.isMDXComponent=!0;const PL={toc:[]},SL="wrapper";function EL(t){let{components:n,...e}=t;return(0,s.kt)(SL,(0,p.Z)({},PL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}EL.isMDXComponent=!0;const GL={toc:[]},OL="wrapper";function FL(t){let{components:n,...e}=t;return(0,s.kt)(OL,(0,p.Z)({},GL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}FL.isMDXComponent=!0;const BL={toc:[]},UL="wrapper";function VL(t){let{components:n,...e}=t;return(0,s.kt)(UL,(0,p.Z)({},BL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}VL.isMDXComponent=!0;const qL={toc:[]},jL="wrapper";function YL(t){let{components:n,...e}=t;return(0,s.kt)(jL,(0,p.Z)({},qL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}YL.isMDXComponent=!0;const QL={toc:[]},HL="wrapper";function $L(t){let{components:n,...e}=t;return(0,s.kt)(HL,(0,p.Z)({},QL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Lifecycle events for ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}$L.isMDXComponent=!0;const KL={toc:[]},JL="wrapper";function tZ(t){let{components:n,...e}=t;return(0,s.kt)(JL,(0,p.Z)({},KL,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A random number generator based on\n",(0,s.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}tZ.isMDXComponent=!0;const nZ={toc:[]},eZ="wrapper";function oZ(t){let{components:n,...e}=t;return(0,s.kt)(eZ,(0,p.Z)({},nZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random floats in the given range."))}oZ.isMDXComponent=!0;const pZ={toc:[]},rZ="wrapper";function sZ(t){let{components:n,...e}=t;return(0,s.kt)(rZ,(0,p.Z)({},pZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."))}sZ.isMDXComponent=!0;const cZ={toc:[]},iZ="wrapper";function aZ(t){let{components:n,...e}=t;return(0,s.kt)(iZ,(0,p.Z)({},cZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}aZ.isMDXComponent=!0;const lZ={toc:[]},uZ="wrapper";function mZ(t){let{components:n,...e}=t;return(0,s.kt)(uZ,(0,p.Z)({},lZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}mZ.isMDXComponent=!0;const dZ={toc:[]},hZ="wrapper";function kZ(t){let{components:n,...e}=t;return(0,s.kt)(hZ,(0,p.Z)({},dZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a random float from a gaussian distribution."))}kZ.isMDXComponent=!0;const fZ={toc:[]},yZ="wrapper";function MZ(t){let{components:n,...e}=t;return(0,s.kt)(yZ,(0,p.Z)({},fZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The mean of the distribution."))}MZ.isMDXComponent=!0;const DZ={toc:[]},XZ="wrapper";function _Z(t){let{components:n,...e}=t;return(0,s.kt)(XZ,(0,p.Z)({},DZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The standard deviation of the distribution."))}_Z.isMDXComponent=!0;const wZ={toc:[]},TZ="wrapper";function CZ(t){let{components:n,...e}=t;return(0,s.kt)(TZ,(0,p.Z)({},wZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random integers in the given range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"}),(0,s.kt)("li",{parentName:"ul"})))}CZ.isMDXComponent=!0;const gZ={toc:[]},xZ="wrapper";function vZ(t){let{components:n,...e}=t;return(0,s.kt)(xZ,(0,p.Z)({},gZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}vZ.isMDXComponent=!0;const LZ={toc:[]},ZZ="wrapper";function bZ(t){let{components:n,...e}=t;return(0,s.kt)(ZZ,(0,p.Z)({},LZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}bZ.isMDXComponent=!0;const NZ={toc:[]},AZ="wrapper";function zZ(t){let{components:n,...e}=t;return(0,s.kt)(AZ,(0,p.Z)({},NZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}zZ.isMDXComponent=!0;const WZ={toc:[]},IZ="wrapper";function RZ(t){let{components:n,...e}=t;return(0,s.kt)(IZ,(0,p.Z)({},WZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random float in the given range."))}RZ.isMDXComponent=!0;const PZ={toc:[]},SZ="wrapper";function EZ(t){let{components:n,...e}=t;return(0,s.kt)(SZ,(0,p.Z)({},PZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}EZ.isMDXComponent=!0;const GZ={toc:[]},OZ="wrapper";function FZ(t){let{components:n,...e}=t;return(0,s.kt)(OZ,(0,p.Z)({},GZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}FZ.isMDXComponent=!0;const BZ={toc:[]},UZ="wrapper";function VZ(t){let{components:n,...e}=t;return(0,s.kt)(UZ,(0,p.Z)({},BZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random integer in the given range."))}VZ.isMDXComponent=!0;const qZ={toc:[]},jZ="wrapper";function YZ(t){let{components:n,...e}=t;return(0,s.kt)(jZ,(0,p.Z)({},qZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}YZ.isMDXComponent=!0;const QZ={toc:[]},HZ="wrapper";function $Z(t){let{components:n,...e}=t;return(0,s.kt)(HZ,(0,p.Z)({},QZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}$Z.isMDXComponent=!0;const KZ={toc:[]},JZ="wrapper";function tb(t){let{components:n,...e}=t;return(0,s.kt)(JZ,(0,p.Z)({},KZ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a new independent generator."))}tb.isMDXComponent=!0;const nb={toc:[]},eb="wrapper";function ob(t){let{components:n,...e}=t;return(0,s.kt)(eb,(0,p.Z)({},nb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}ob.isMDXComponent=!0;const pb={toc:[]},rb="wrapper";function sb(t){let{components:n,...e}=t;return(0,s.kt)(rb,(0,p.Z)({},pb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the variable."))}sb.isMDXComponent=!0;const cb={toc:[]},ib="wrapper";function ab(t){let{components:n,...e}=t;return(0,s.kt)(ib,(0,p.Z)({},cb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}ab.isMDXComponent=!0;const lb={toc:[]},ub="wrapper";function mb(t){let{components:n,...e}=t;return(0,s.kt)(ub,(0,p.Z)({},lb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}mb.isMDXComponent=!0;const db={toc:[]},hb="wrapper";function kb(t){let{components:n,...e}=t;return(0,s.kt)(hb,(0,p.Z)({},db,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset all stored signals."))}kb.isMDXComponent=!0;const fb={toc:[]},yb="wrapper";function Mb(t){let{components:n,...e}=t;return(0,s.kt)(yb,(0,p.Z)({},fb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update all signals with new project variable values."))}Mb.isMDXComponent=!0;const Db={toc:[]},Xb="wrapper";function _b(t){let{components:n,...e}=t;return(0,s.kt)(Xb,(0,p.Z)({},Db,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes cached information about the timing of a scene."))}_b.isMDXComponent=!0;const wb={toc:[]},Tb="wrapper";function Cb(t){let{components:n,...e}=t;return(0,s.kt)(Tb,(0,p.Z)({},wb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a complete scene together with the meta file."))}Cb.isMDXComponent=!0;const gb={toc:[]},xb="wrapper";function vb(t){let{components:n,...e}=t;return(0,s.kt)(xb,(0,p.Z)({},gb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}vb.isMDXComponent=!0;const Lb={toc:[]},Zb="wrapper";function bb(t){let{components:n,...e}=t;return(0,s.kt)(Zb,(0,p.Z)({},Lb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}bb.isMDXComponent=!0;const Nb={toc:[]},Ab="wrapper";function zb(t){let{components:n,...e}=t;return(0,s.kt)(Ab,(0,p.Z)({},Nb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of plugins to include in the project."))}zb.isMDXComponent=!0;const Wb={toc:[]},Ib="wrapper";function Rb(t){let{components:n,...e}=t;return(0,s.kt)(Ib,(0,p.Z)({},Wb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}Rb.isMDXComponent=!0;const Pb={toc:[]},Sb="wrapper";function Eb(t){let{components:n,...e}=t;return(0,s.kt)(Sb,(0,p.Z)({},Pb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}Eb.isMDXComponent=!0;const Gb={toc:[]},Ob="wrapper";function Fb(t){let{components:n,...e}=t;return(0,s.kt)(Ob,(0,p.Z)({},Gb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Fb.isMDXComponent=!0;const Bb={toc:[]},Ub="wrapper";function Vb(t){let{components:n,...e}=t;return(0,s.kt)(Ub,(0,p.Z)({},Bb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Vb.isMDXComponent=!0;const qb={toc:[]},jb="wrapper";function Yb(t){let{components:n,...e}=t;return(0,s.kt)(jb,(0,p.Z)({},qb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for the inspected element."))}Yb.isMDXComponent=!0;const Qb={toc:[]},Hb="wrapper";function $b(t){let{components:n,...e}=t;return(0,s.kt)(Hb,(0,p.Z)({},Qb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element for which to draw an overlay."))}$b.isMDXComponent=!0;const Kb={toc:[]},Jb="wrapper";function tN(t){let{components:n,...e}=t;return(0,s.kt)(Jb,(0,p.Z)({},Kb,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}tN.isMDXComponent=!0;const nN={toc:[]},eN="wrapper";function oN(t){let{components:n,...e}=t;return(0,s.kt)(eN,(0,p.Z)({},nN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}oN.isMDXComponent=!0;const pN={toc:[]},rN="wrapper";function sN(t){let{components:n,...e}=t;return(0,s.kt)(rN,(0,p.Z)({},pN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}sN.isMDXComponent=!0;const cN={toc:[]},iN="wrapper";function aN(t){let{components:n,...e}=t;return(0,s.kt)(iN,(0,p.Z)({},cN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the attributes of the inspected element."))}aN.isMDXComponent=!0;const lN={toc:[]},uN="wrapper";function mN(t){let{components:n,...e}=t;return(0,s.kt)(uN,(0,p.Z)({},lN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to inspect."))}mN.isMDXComponent=!0;const dN={toc:[]},hN="wrapper";function kN(t){let{components:n,...e}=t;return(0,s.kt)(hN,(0,p.Z)({},dN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a possible element to inspect at a given position."))}kN.isMDXComponent=!0;const fN={toc:[]},yN="wrapper";function MN(t){let{components:n,...e}=t;return(0,s.kt)(yN,(0,p.Z)({},fN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}MN.isMDXComponent=!0;const DN={toc:[]},XN="wrapper";function _N(t){let{components:n,...e}=t;return(0,s.kt)(XN,(0,p.Z)({},DN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}_N.isMDXComponent=!0;const wN={toc:[]},TN="wrapper";function CN(t){let{components:n,...e}=t;return(0,s.kt)(TN,(0,p.Z)({},wN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transform the absolute mouse coordinates into the scene's coordinate system."))}CN.isMDXComponent=!0;const gN={toc:[]},xN="wrapper";function vN(t){let{components:n,...e}=t;return(0,s.kt)(xN,(0,p.Z)({},gN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}vN.isMDXComponent=!0;const LN={toc:[]},ZN="wrapper";function bN(t){let{components:n,...e}=t;return(0,s.kt)(ZN,(0,p.Z)({},LN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}bN.isMDXComponent=!0;const NN={toc:[]},AN="wrapper";function zN(t){let{components:n,...e}=t;return(0,s.kt)(AN,(0,p.Z)({},NN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}zN.isMDXComponent=!0;const WN={toc:[]},IN="wrapper";function RN(t){let{components:n,...e}=t;return(0,s.kt)(IN,(0,p.Z)({},WN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the inspected element is still valid."))}RN.isMDXComponent=!0;const PN={toc:[]},SN="wrapper";function EN(t){let{components:n,...e}=t;return(0,s.kt)(SN,(0,p.Z)({},PN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to validate."))}EN.isMDXComponent=!0;const GN={toc:[]},ON="wrapper";function FN(t){let{components:n,...e}=t;return(0,s.kt)(ON,(0,p.Z)({},GN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}FN.isMDXComponent=!0;const BN={toc:[]},UN="wrapper";function VN(t){let{components:n,...e}=t;return(0,s.kt)(UN,(0,p.Z)({},BN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for scenes."))}VN.isMDXComponent=!0;const qN={toc:[]},jN="wrapper";function YN(t){let{components:n,...e}=t;return(0,s.kt)(jN,(0,p.Z)({},qN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}YN.isMDXComponent=!0;const QN={toc:[]},HN="wrapper";function $N(t){let{components:n,...e}=t;return(0,s.kt)(HN,(0,p.Z)({},QN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}$N.isMDXComponent=!0;const KN={toc:[]},JN="wrapper";function tA(t){let{components:n,...e}=t;return(0,s.kt)(JN,(0,p.Z)({},KN,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}tA.isMDXComponent=!0;const nA={toc:[]},eA="wrapper";function oA(t){let{components:n,...e}=t;return(0,s.kt)(eA,(0,p.Z)({},nA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Should this scene be rendered below the previous scene during a transition?"))}oA.isMDXComponent=!0;const pA={toc:[]},rA="wrapper";function sA(t){let{components:n,...e}=t;return(0,s.kt)(rA,(0,p.Z)({},pA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}sA.isMDXComponent=!0;const cA={toc:[]},iA="wrapper";function aA(t){let{components:n,...e}=t;return(0,s.kt)(iA,(0,p.Z)({},cA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}aA.isMDXComponent=!0;const lA={toc:[]},uA="wrapper";function mA(t){let{components:n,...e}=t;return(0,s.kt)(uA,(0,p.Z)({},lA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether experimental features are enabled."))}mA.isMDXComponent=!0;const dA={toc:[]},hA="wrapper";function kA(t){let{components:n,...e}=t;return(0,s.kt)(hA,(0,p.Z)({},dA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}kA.isMDXComponent=!0;const fA={toc:[]},yA="wrapper";function MA(t){let{components:n,...e}=t;return(0,s.kt)(yA,(0,p.Z)({},fA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}MA.isMDXComponent=!0;const DA={toc:[]},XA="wrapper";function _A(t){let{components:n,...e}=t;return(0,s.kt)(XA,(0,p.Z)({},DA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}_A.isMDXComponent=!0;const wA={toc:[]},TA="wrapper";function CA(t){let{components:n,...e}=t;return(0,s.kt)(TA,(0,p.Z)({},wA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}CA.isMDXComponent=!0;const gA={toc:[]},xA="wrapper";function vA(t){let{components:n,...e}=t;return(0,s.kt)(xA,(0,p.Z)({},gA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}vA.isMDXComponent=!0;const LA={toc:[]},ZA="wrapper";function bA(t){let{components:n,...e}=t;return(0,s.kt)(ZA,(0,p.Z)({},LA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}bA.isMDXComponent=!0;const NA={toc:[]},AA="wrapper";function zA(t){let{components:n,...e}=t;return(0,s.kt)(AA,(0,p.Z)({},NA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}zA.isMDXComponent=!0;const WA={toc:[]},IA="wrapper";function RA(t){let{components:n,...e}=t;return(0,s.kt)(IA,(0,p.Z)({},WA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}RA.isMDXComponent=!0;const PA={toc:[]},SA="wrapper";function EA(t){let{components:n,...e}=t;return(0,s.kt)(SA,(0,p.Z)({},PA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}EA.isMDXComponent=!0;const GA={toc:[]},OA="wrapper";function FA(t){let{components:n,...e}=t;return(0,s.kt)(OA,(0,p.Z)({},GA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}FA.isMDXComponent=!0;const BA={toc:[]},UA="wrapper";function VA(t){let{components:n,...e}=t;return(0,s.kt)(UA,(0,p.Z)({},BA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}VA.isMDXComponent=!0;const qA={toc:[]},jA="wrapper";function YA(t){let{components:n,...e}=t;return(0,s.kt)(jA,(0,p.Z)({},qA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}YA.isMDXComponent=!0;const QA={toc:[]},HA="wrapper";function $A(t){let{components:n,...e}=t;return(0,s.kt)(HA,(0,p.Z)({},QA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}$A.isMDXComponent=!0;const KA={toc:[]},JA="wrapper";function tz(t){let{components:n,...e}=t;return(0,s.kt)(JA,(0,p.Z)({},KA,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the size of the scene multiplied by the resolution scale.\nThis is the actual size of the canvas onto which the scene is rendered."))}tz.isMDXComponent=!0;const nz={toc:[]},ez="wrapper";function oz(t){let{components:n,...e}=t;return(0,s.kt)(ez,(0,p.Z)({},nz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real size of this scene."))}oz.isMDXComponent=!0;const pz={toc:[]},rz="wrapper";function sz(t){let{components:n,...e}=t;return(0,s.kt)(rz,(0,p.Z)({},pz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually returns ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}sz.isMDXComponent=!0;const cz={toc:[]},iz="wrapper";function az(t){let{components:n,...e}=t;return(0,s.kt)(iz,(0,p.Z)({},cz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."))}az.isMDXComponent=!0;const lz={toc:[]},uz="wrapper";function mz(t){let{components:n,...e}=t;return(0,s.kt)(uz,(0,p.Z)({},lz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}mz.isMDXComponent=!0;const dz={toc:[]},hz="wrapper";function kz(t){let{components:n,...e}=t;return(0,s.kt)(hz,(0,p.Z)({},dz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}kz.isMDXComponent=!0;const fz={toc:[]},yz="wrapper";function Mz(t){let{components:n,...e}=t;return(0,s.kt)(yz,(0,p.Z)({},fz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"))}Mz.isMDXComponent=!0;const Dz={toc:[]},Xz="wrapper";function _z(t){let{components:n,...e}=t;return(0,s.kt)(Xz,(0,p.Z)({},Dz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}_z.isMDXComponent=!0;const wz={toc:[]},Tz="wrapper";function Cz(t){let{components:n,...e}=t;return(0,s.kt)(Tz,(0,p.Z)({},wz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}Cz.isMDXComponent=!0;const gz={toc:[]},xz="wrapper";function vz(t){let{components:n,...e}=t;return(0,s.kt)(xz,(0,p.Z)({},gz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}vz.isMDXComponent=!0;const Lz={toc:[]},Zz="wrapper";function bz(t){let{components:n,...e}=t;return(0,s.kt)(Zz,(0,p.Z)({},Lz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}bz.isMDXComponent=!0;const Nz={toc:[]},Az="wrapper";function zz(t){let{components:n,...e}=t;return(0,s.kt)(Az,(0,p.Z)({},Nz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}zz.isMDXComponent=!0;const Wz={toc:[]},Iz="wrapper";function Rz(t){let{components:n,...e}=t;return(0,s.kt)(Iz,(0,p.Z)({},Wz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}Rz.isMDXComponent=!0;const Pz={toc:[]},Sz="wrapper";function Ez(t){let{components:n,...e}=t;return(0,s.kt)(Sz,(0,p.Z)({},Pz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}Ez.isMDXComponent=!0;const Gz={toc:[]},Oz="wrapper";function Fz(t){let{components:n,...e}=t;return(0,s.kt)(Oz,(0,p.Z)({},Gz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}Fz.isMDXComponent=!0;const Bz={toc:[]},Uz="wrapper";function Vz(t){let{components:n,...e}=t;return(0,s.kt)(Uz,(0,p.Z)({},Bz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}Vz.isMDXComponent=!0;const qz={toc:[]},jz="wrapper";function Yz(t){let{components:n,...e}=t;return(0,s.kt)(jz,(0,p.Z)({},qz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}Yz.isMDXComponent=!0;const Qz={toc:[]},Hz="wrapper";function $z(t){let{components:n,...e}=t;return(0,s.kt)(Hz,(0,p.Z)({},Qz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}$z.isMDXComponent=!0;const Kz={toc:[]},Jz="wrapper";function tW(t){let{components:n,...e}=t;return(0,s.kt)(Jz,(0,p.Z)({},Kz,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}tW.isMDXComponent=!0;const nW={toc:[]},eW="wrapper";function oW(t){let{components:n,...e}=t;return(0,s.kt)(eW,(0,p.Z)({},nW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each class implementing the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}oW.isMDXComponent=!0;const pW={toc:[]},rW="wrapper";function sW(t){let{components:n,...e}=t;return(0,s.kt)(rW,(0,p.Z)({},pW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constructor used when creating new scenes."))}sW.isMDXComponent=!0;const cW={toc:[]},iW="wrapper";function aW(t){let{components:n,...e}=t;return(0,s.kt)(iW,(0,p.Z)({},cW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.kt)("inlineCode",{parentName:"a"},"config")),"."))}aW.isMDXComponent=!0;const lW={toc:[]},uW="wrapper";function mW(t){let{components:n,...e}=t;return(0,s.kt)(uW,(0,p.Z)({},lW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a scene exposed by scene files."))}mW.isMDXComponent=!0;const dW={toc:[]},hW="wrapper";function kW(t){let{components:n,...e}=t;return(0,s.kt)(hW,(0,p.Z)({},dW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}kW.isMDXComponent=!0;const fW={toc:[]},yW="wrapper";function MW(t){let{components:n,...e}=t;return(0,s.kt)(yW,(0,p.Z)({},fW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}MW.isMDXComponent=!0;const DW={toc:[]},XW="wrapper";function _W(t){let{components:n,...e}=t;return(0,s.kt)(XW,(0,p.Z)({},DW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of plugins to include in the project."))}_W.isMDXComponent=!0;const wW={toc:[]},TW="wrapper";function CW(t){let{components:n,...e}=t;return(0,s.kt)(TW,(0,p.Z)({},wW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}CW.isMDXComponent=!0;const gW={toc:[]},xW="wrapper";function vW(t){let{components:n,...e}=t;return(0,s.kt)(xW,(0,p.Z)({},gW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}vW.isMDXComponent=!0;const LW={toc:[]},ZW="wrapper";function bW(t){let{components:n,...e}=t;return(0,s.kt)(ZW,(0,p.Z)({},LW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A part of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}bW.isMDXComponent=!0;const NW={toc:[]},AW="wrapper";function zW(t){let{components:n,...e}=t;return(0,s.kt)(AW,(0,p.Z)({},NW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}zW.isMDXComponent=!0;const WW={toc:[]},IW="wrapper";function RW(t){let{components:n,...e}=t;return(0,s.kt)(IW,(0,p.Z)({},WW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}RW.isMDXComponent=!0;const PW={toc:[]},SW="wrapper";function EW(t){let{components:n,...e}=t;return(0,s.kt)(SW,(0,p.Z)({},PW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}EW.isMDXComponent=!0;const GW={toc:[]},OW="wrapper";function FW(t){let{components:n,...e}=t;return(0,s.kt)(OW,(0,p.Z)({},GW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}FW.isMDXComponent=!0;const BW={toc:[]},UW="wrapper";function VW(t){let{components:n,...e}=t;return(0,s.kt)(UW,(0,p.Z)({},BW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents attributes of an inspected element."))}VW.isMDXComponent=!0;const qW={toc:[]},jW="wrapper";function YW(t){let{components:n,...e}=t;return(0,s.kt)(jW,(0,p.Z)({},qW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}YW.isMDXComponent=!0;const QW={toc:[]},HW="wrapper";function $W(t){let{components:n,...e}=t;return(0,s.kt)(HW,(0,p.Z)({},QW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an element to inspect."))}$W.isMDXComponent=!0;const KW={toc:[]},JW="wrapper";function tI(t){let{components:n,...e}=t;return(0,s.kt)(JW,(0,p.Z)({},KW,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the scene metadata."))}tI.isMDXComponent=!0;const nI={toc:[]},eI="wrapper";function oI(t){let{components:n,...e}=t;return(0,s.kt)(eI,(0,p.Z)({},nI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the scene metadata."))}oI.isMDXComponent=!0;const pI={toc:[]},rI="wrapper";function sI(t){let{components:n,...e}=t;return(0,s.kt)(rI,(0,p.Z)({},pI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}sI.isMDXComponent=!0;const cI={toc:[]},iI="wrapper";function aI(t){let{components:n,...e}=t;return(0,s.kt)(iI,(0,p.Z)({},cI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the initial value of this signal."))}aI.isMDXComponent=!0;const lI={toc:[]},uI="wrapper";function mI(t){let{components:n,...e}=t;return(0,s.kt)(uI,(0,p.Z)({},lI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}mI.isMDXComponent=!0;const dI={toc:[]},hI="wrapper";function kI(t){let{components:n,...e}=t;return(0,s.kt)(hI,(0,p.Z)({},dI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}kI.isMDXComponent=!0;const fI={toc:[]},yI="wrapper";function MI(t){let{components:n,...e}=t;return(0,s.kt)(yI,(0,p.Z)({},fI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is the signal undergoing a tween?"))}MI.isMDXComponent=!0;const DI={toc:[]},XI="wrapper";function _I(t){let{components:n,...e}=t;return(0,s.kt)(XI,(0,p.Z)({},DI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}_I.isMDXComponent=!0;const wI={toc:[]},TI="wrapper";function CI(t){let{components:n,...e}=t;return(0,s.kt)(TI,(0,p.Z)({},wI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}CI.isMDXComponent=!0;const gI={toc:[]},xI="wrapper";function vI(t){let{components:n,...e}=t;return(0,s.kt)(xI,(0,p.Z)({},gI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}vI.isMDXComponent=!0;const LI={toc:[]},ZI="wrapper";function bI(t){let{components:n,...e}=t;return(0,s.kt)(ZI,(0,p.Z)({},LI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}bI.isMDXComponent=!0;const NI={toc:[]},AI="wrapper";function zI(t){let{components:n,...e}=t;return(0,s.kt)(AI,(0,p.Z)({},NI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}zI.isMDXComponent=!0;const WI={toc:[]},II="wrapper";function RI(t){let{components:n,...e}=t;return(0,s.kt)(II,(0,p.Z)({},WI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}RI.isMDXComponent=!0;const PI={toc:[]},SI="wrapper";function EI(t){let{components:n,...e}=t;return(0,s.kt)(SI,(0,p.Z)({},PI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}EI.isMDXComponent=!0;const GI={toc:[]},OI="wrapper";function FI(t){let{components:n,...e}=t;return(0,s.kt)(OI,(0,p.Z)({},GI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}FI.isMDXComponent=!0;const BI={toc:[]},UI="wrapper";function VI(t){let{components:n,...e}=t;return(0,s.kt)(UI,(0,p.Z)({},BI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the initial value of this signal."))}VI.isMDXComponent=!0;const qI={toc:[]},jI="wrapper";function YI(t){let{components:n,...e}=t;return(0,s.kt)(jI,(0,p.Z)({},qI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}YI.isMDXComponent=!0;const QI={toc:[]},HI="wrapper";function $I(t){let{components:n,...e}=t;return(0,s.kt)(HI,(0,p.Z)({},QI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}$I.isMDXComponent=!0;const KI={toc:[]},JI="wrapper";function tR(t){let{components:n,...e}=t;return(0,s.kt)(JI,(0,p.Z)({},KI,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is the signal undergoing a tween?"))}tR.isMDXComponent=!0;const nR={toc:[]},eR="wrapper";function oR(t){let{components:n,...e}=t;return(0,s.kt)(eR,(0,p.Z)({},nR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}oR.isMDXComponent=!0;const pR={toc:[]},rR="wrapper";function sR(t){let{components:n,...e}=t;return(0,s.kt)(rR,(0,p.Z)({},pR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}sR.isMDXComponent=!0;const cR={toc:[]},iR="wrapper";function aR(t){let{components:n,...e}=t;return(0,s.kt)(iR,(0,p.Z)({},cR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}aR.isMDXComponent=!0;const lR={toc:[]},uR="wrapper";function mR(t){let{components:n,...e}=t;return(0,s.kt)(uR,(0,p.Z)({},lR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}mR.isMDXComponent=!0;const dR={toc:[]},hR="wrapper";function kR(t){let{components:n,...e}=t;return(0,s.kt)(hR,(0,p.Z)({},dR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}kR.isMDXComponent=!0;const fR={toc:[]},yR="wrapper";function MR(t){let{components:n,...e}=t;return(0,s.kt)(yR,(0,p.Z)({},fR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}MR.isMDXComponent=!0;const DR={toc:[]},XR="wrapper";function _R(t){let{components:n,...e}=t;return(0,s.kt)(XR,(0,p.Z)({},DR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}_R.isMDXComponent=!0;const wR={toc:[]},TR="wrapper";function CR(t){let{components:n,...e}=t;return(0,s.kt)(TR,(0,p.Z)({},wR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}CR.isMDXComponent=!0;const gR={toc:[]},xR="wrapper";function vR(t){let{components:n,...e}=t;return(0,s.kt)(xR,(0,p.Z)({},gR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}vR.isMDXComponent=!0;const LR={toc:[]},ZR="wrapper";function bR(t){let{components:n,...e}=t;return(0,s.kt)(ZR,(0,p.Z)({},LR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}bR.isMDXComponent=!0;const NR={toc:[]},AR="wrapper";function zR(t){let{components:n,...e}=t;return(0,s.kt)(AR,(0,p.Z)({},NR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}zR.isMDXComponent=!0;const WR={toc:[]},IR="wrapper";function RR(t){let{components:n,...e}=t;return(0,s.kt)(IR,(0,p.Z)({},WR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}RR.isMDXComponent=!0;const PR={toc:[]},SR="wrapper";function ER(t){let{components:n,...e}=t;return(0,s.kt)(SR,(0,p.Z)({},PR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween back to the original value."))}ER.isMDXComponent=!0;const GR={toc:[]},OR="wrapper";function FR(t){let{components:n,...e}=t;return(0,s.kt)(OR,(0,p.Z)({},GR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}FR.isMDXComponent=!0;const BR={toc:[]},UR="wrapper";function VR(t){let{components:n,...e}=t;return(0,s.kt)(UR,(0,p.Z)({},BR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function of the tween."))}VR.isMDXComponent=!0;const qR={toc:[]},jR="wrapper";function YR(t){let{components:n,...e}=t;return(0,s.kt)(jR,(0,p.Z)({},qR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function of the tween."))}YR.isMDXComponent=!0;const QR={toc:[]},HR="wrapper";function $R(t){let{components:n,...e}=t;return(0,s.kt)(HR,(0,p.Z)({},QR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback."))}$R.isMDXComponent=!0;const KR={toc:[]},JR="wrapper";function tP(t){let{components:n,...e}=t;return(0,s.kt)(JR,(0,p.Z)({},KR,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}tP.isMDXComponent=!0;const nP={toc:[]},eP="wrapper";function oP(t){let{components:n,...e}=t;return(0,s.kt)(eP,(0,p.Z)({},nP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given task."))}oP.isMDXComponent=!0;const pP={toc:[]},rP="wrapper";function sP(t){let{components:n,...e}=t;return(0,s.kt)(rP,(0,p.Z)({},pP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator to run."))}sP.isMDXComponent=!0;const cP={toc:[]},iP="wrapper";function aP(t){let{components:n,...e}=t;return(0,s.kt)(iP,(0,p.Z)({},cP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween to the specified value."))}aP.isMDXComponent=!0;const lP={toc:[]},uP="wrapper";function mP(t){let{components:n,...e}=t;return(0,s.kt)(uP,(0,p.Z)({},lP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the specified duration."))}mP.isMDXComponent=!0;const dP={toc:[]},hP="wrapper";function kP(t){let{components:n,...e}=t;return(0,s.kt)(hP,(0,p.Z)({},dP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration to wait."))}kP.isMDXComponent=!0;const fP={toc:[]},yP="wrapper";function MP(t){let{components:n,...e}=t;return(0,s.kt)(yP,(0,p.Z)({},fP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread management."))}MP.isMDXComponent=!0;const DP={toc:[]},XP="wrapper";function _P(t){let{components:n,...e}=t;return(0,s.kt)(XP,(0,p.Z)({},DP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}_P.isMDXComponent=!0;const wP={toc:[]},TP="wrapper";function CP(t){let{components:n,...e}=t;return(0,s.kt)(TP,(0,p.Z)({},wP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A class representing an individual thread."))}CP.isMDXComponent=!0;const gP={toc:[]},xP="wrapper";function vP(t){let{components:n,...e}=t;return(0,s.kt)(xP,(0,p.Z)({},gP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}vP.isMDXComponent=!0;const LP={toc:[]},ZP="wrapper";function bP(t){let{components:n,...e}=t;return(0,s.kt)(ZP,(0,p.Z)({},LP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}bP.isMDXComponent=!0;const NP={toc:[]},AP="wrapper";function zP(t){let{components:n,...e}=t;return(0,s.kt)(AP,(0,p.Z)({},NP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}zP.isMDXComponent=!0;const WP={toc:[]},IP="wrapper";function RP(t){let{components:n,...e}=t;return(0,s.kt)(IP,(0,p.Z)({},WP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current time of this thread."))}RP.isMDXComponent=!0;const PP={toc:[]},SP="wrapper";function EP(t){let{components:n,...e}=t;return(0,s.kt)(SP,(0,p.Z)({},PP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The next value to be passed to the wrapped generator."))}EP.isMDXComponent=!0;const GP={toc:[]},OP="wrapper";function FP(t){let{components:n,...e}=t;return(0,s.kt)(OP,(0,p.Z)({},GP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}FP.isMDXComponent=!0;const BP={toc:[]},UP="wrapper";function VP(t){let{components:n,...e}=t;return(0,s.kt)(UP,(0,p.Z)({},BP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}VP.isMDXComponent=!0;const qP={toc:[]},jP="wrapper";function YP(t){let{components:n,...e}=t;return(0,s.kt)(jP,(0,p.Z)({},qP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The fixed time of this thread."))}YP.isMDXComponent=!0;const QP={toc:[]},HP="wrapper";function $P(t){let{components:n,...e}=t;return(0,s.kt)(HP,(0,p.Z)({},QP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress the wrapped generator once."))}$P.isMDXComponent=!0;const KP={toc:[]},JP="wrapper";function tS(t){let{components:n,...e}=t;return(0,s.kt)(JP,(0,p.Z)({},KP,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the thread for the next update cycle."))}tS.isMDXComponent=!0;const nS={toc:[]},eS="wrapper";function oS(t){let{components:n,...e}=t;return(0,s.kt)(eS,(0,p.Z)({},nS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delta time of the next cycle."))}oS.isMDXComponent=!0;const pS={toc:[]},rS="wrapper";function sS(t){let{components:n,...e}=t;return(0,s.kt)(rS,(0,p.Z)({},pS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a normal function that returns a generator."))}sS.isMDXComponent=!0;const cS={toc:[]},iS="wrapper";function aS(t){let{components:n,...e}=t;return(0,s.kt)(iS,(0,p.Z)({},cS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.kt)("p",null,"Progress to the next frame:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.kt)("p",null,"Run another generator synchronously:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.kt)("p",null,"Run another generator concurrently:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.kt)("p",null,"Await a Promise:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}aS.isMDXComponent=!0;const lS={toc:[]},uS="wrapper";function mS(t){let{components:n,...e}=t;return(0,s.kt)(uS,(0,p.Z)({},lS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}mS.isMDXComponent=!0;const dS={toc:[]},hS="wrapper";function kS(t){let{components:n,...e}=t;return(0,s.kt)(hS,(0,p.Z)({},dS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Cancel all listed tasks."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}kS.isMDXComponent=!0;const fS={toc:[]},yS="wrapper";function MS(t){let{components:n,...e}=t;return(0,s.kt)(yS,(0,p.Z)({},fS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to cancel."))}MS.isMDXComponent=!0;const DS={toc:[]},XS="wrapper";function _S(t){let{components:n,...e}=t;return(0,s.kt)(XS,(0,p.Z)({},DS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}_S.isMDXComponent=!0;const wS={toc:[]},TS="wrapper";function CS(t){let{components:n,...e}=t;return(0,s.kt)(TS,(0,p.Z)({},wS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}CS.isMDXComponent=!0;const gS={toc:[]},xS="wrapper";function vS(t){let{components:n,...e}=t;return(0,s.kt)(xS,(0,p.Z)({},gS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}vS.isMDXComponent=!0;const LS={toc:[]},ZS="wrapper";function bS(t){let{components:n,...e}=t;return(0,s.kt)(ZS,(0,p.Z)({},LS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible thread ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}bS.isMDXComponent=!0;const NS={toc:[]},AS="wrapper";function zS(t){let{components:n,...e}=t;return(0,s.kt)(AS,(0,p.Z)({},NS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}zS.isMDXComponent=!0;const WS={toc:[]},IS="wrapper";function RS(t){let{components:n,...e}=t;return(0,s.kt)(IS,(0,p.Z)({},WS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}RS.isMDXComponent=!0;const PS={toc:[]},SS="wrapper";function ES(t){let{components:n,...e}=t;return(0,s.kt)(SS,(0,p.Z)({},PS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}ES.isMDXComponent=!0;const GS={toc:[]},OS="wrapper";function FS(t){let{components:n,...e}=t;return(0,s.kt)(OS,(0,p.Z)({},GS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}FS.isMDXComponent=!0;const BS={toc:[]},US="wrapper";function VS(t){let{components:n,...e}=t;return(0,s.kt)(US,(0,p.Z)({},BS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until listed tasks are finished."))}VS.isMDXComponent=!0;const qS={toc:[]},jS="wrapper";function YS(t){let{components:n,...e}=t;return(0,s.kt)(jS,(0,p.Z)({},qS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}YS.isMDXComponent=!0;const QS={toc:[]},HS="wrapper";function $S(t){let{components:n,...e}=t;return(0,s.kt)(HS,(0,p.Z)({},QS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}$S.isMDXComponent=!0;const KS={toc:[]},JS="wrapper";function tE(t){let{components:n,...e}=t;return(0,s.kt)(JS,(0,p.Z)({},KS,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"From the perspective of the external generator, ",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}tE.isMDXComponent=!0;const nE={toc:[]},eE="wrapper";function oE(t){let{components:n,...e}=t;return(0,s.kt)(eE,(0,p.Z)({},nE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}oE.isMDXComponent=!0;const pE={toc:[]},rE="wrapper";function sE(t){let{components:n,...e}=t;return(0,s.kt)(rE,(0,p.Z)({},pE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a context in which generators can be run concurrently."))}sE.isMDXComponent=!0;const cE={toc:[]},iE="wrapper";function aE(t){let{components:n,...e}=t;return(0,s.kt)(iE,(0,p.Z)({},cE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the generator to run."))}aE.isMDXComponent=!0;const lE={toc:[]},uE="wrapper";function mE(t){let{components:n,...e}=t;return(0,s.kt)(uE,(0,p.Z)({},lE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}mE.isMDXComponent=!0;const dE={toc:[]},hE="wrapper";function kE(t){let{components:n,...e}=t;return(0,s.kt)(hE,(0,p.Z)({},dE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transitions between scenes."))}kE.isMDXComponent=!0;const fE={toc:[]},yE="wrapper";function ME(t){let{components:n,...e}=t;return(0,s.kt)(yE,(0,p.Z)({},fE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that fades between the scenes."))}ME.isMDXComponent=!0;const DE={toc:[]},XE="wrapper";function _E(t){let{components:n,...e}=t;return(0,s.kt)(XE,(0,p.Z)({},DE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}_E.isMDXComponent=!0;const wE={toc:[]},TE="wrapper";function CE(t){let{components:n,...e}=t;return(0,s.kt)(TE,(0,p.Z)({},wE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene in the given direction."))}CE.isMDXComponent=!0;const gE={toc:[]},xE="wrapper";function vE(t){let{components:n,...e}=t;return(0,s.kt)(xE,(0,p.Z)({},gE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The direction in which to slide."))}vE.isMDXComponent=!0;const LE={toc:[]},ZE="wrapper";function bE(t){let{components:n,...e}=t;return(0,s.kt)(ZE,(0,p.Z)({},LE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}bE.isMDXComponent=!0;const NE={toc:[]},AE="wrapper";function zE(t){let{components:n,...e}=t;return(0,s.kt)(AE,(0,p.Z)({},NE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene towards the given origin."))}zE.isMDXComponent=!0;const WE={toc:[]},IE="wrapper";function RE(t){let{components:n,...e}=t;return(0,s.kt)(IE,(0,p.Z)({},WE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin towards which to slide."))}RE.isMDXComponent=!0;const PE={toc:[]},SE="wrapper";function EE(t){let{components:n,...e}=t;return(0,s.kt)(SE,(0,p.Z)({},PE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}EE.isMDXComponent=!0;const GE={toc:[]},OE="wrapper";function FE(t){let{components:n,...e}=t;return(0,s.kt)(OE,(0,p.Z)({},GE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}FE.isMDXComponent=!0;const BE={toc:[]},UE="wrapper";function VE(t){let{components:n,...e}=t;return(0,s.kt)(UE,(0,p.Z)({},BE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the current scene is rendered."))}VE.isMDXComponent=!0;const qE={toc:[]},jE="wrapper";function YE(t){let{components:n,...e}=t;return(0,s.kt)(jE,(0,p.Z)({},qE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the previous scene is rendered."))}YE.isMDXComponent=!0;const QE={toc:[]},HE="wrapper";function $E(t){let{components:n,...e}=t;return(0,s.kt)(HE,(0,p.Z)({},QE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the previous scene should be rendered on top."))}$E.isMDXComponent=!0;const KE={toc:[]},JE="wrapper";function tG(t){let{components:n,...e}=t;return(0,s.kt)(JE,(0,p.Z)({},KE,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}tG.isMDXComponent=!0;const nG={toc:[]},eG="wrapper";function oG(t){let{components:n,...e}=t;return(0,s.kt)(eG,(0,p.Z)({},nG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area on which to zoom in."))}oG.isMDXComponent=!0;const pG={toc:[]},rG="wrapper";function sG(t){let{components:n,...e}=t;return(0,s.kt)(rG,(0,p.Z)({},pG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}sG.isMDXComponent=!0;const cG={toc:[]},iG="wrapper";function aG(t){let{components:n,...e}=t;return(0,s.kt)(iG,(0,p.Z)({},cG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}aG.isMDXComponent=!0;const lG={toc:[]},uG="wrapper";function mG(t){let{components:n,...e}=t;return(0,s.kt)(uG,(0,p.Z)({},lG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area from which to zoom out."))}mG.isMDXComponent=!0;const dG={toc:[]},hG="wrapper";function kG(t){let{components:n,...e}=t;return(0,s.kt)(hG,(0,p.Z)({},dG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}kG.isMDXComponent=!0;const fG={toc:[]},yG="wrapper";function MG(t){let{components:n,...e}=t;return(0,s.kt)(yG,(0,p.Z)({},fG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolation and timing of tweens."))}MG.isMDXComponent=!0;const DG={toc:[]},XG="wrapper";function _G(t){let{components:n,...e}=t;return(0,s.kt)(XG,(0,p.Z)({},DG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any old key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"})))}_G.isMDXComponent=!0;const wG={toc:[]},TG="wrapper";function CG(t){let{components:n,...e}=t;return(0,s.kt)(TG,(0,p.Z)({},wG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}CG.isMDXComponent=!0;const gG={toc:[]},xG="wrapper";function vG(t){let{components:n,...e}=t;return(0,s.kt)(xG,(0,p.Z)({},gG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}vG.isMDXComponent=!0;const LG={toc:[]},ZG="wrapper";function bG(t){let{components:n,...e}=t;return(0,s.kt)(ZG,(0,p.Z)({},LG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}bG.isMDXComponent=!0;const NG={toc:[]},AG="wrapper";function zG(t){let{components:n,...e}=t;return(0,s.kt)(AG,(0,p.Z)({},NG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}zG.isMDXComponent=!0;const WG={toc:[]},IG="wrapper";function RG(t){let{components:n,...e}=t;return(0,s.kt)(IG,(0,p.Z)({},WG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}RG.isMDXComponent=!0;const PG={toc:[]},SG="wrapper";function EG(t){let{components:n,...e}=t;return(0,s.kt)(SG,(0,p.Z)({},PG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}EG.isMDXComponent=!0;const GG={toc:[]},OG="wrapper";function FG(t){let{components:n,...e}=t;return(0,s.kt)(OG,(0,p.Z)({},GG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}FG.isMDXComponent=!0;const BG={toc:[]},UG="wrapper";function VG(t){let{components:n,...e}=t;return(0,s.kt)(UG,(0,p.Z)({},BG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}VG.isMDXComponent=!0;const qG={toc:[]},jG="wrapper";function YG(t){let{components:n,...e}=t;return(0,s.kt)(jG,(0,p.Z)({},qG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}YG.isMDXComponent=!0;const QG={toc:[]},HG="wrapper";function $G(t){let{components:n,...e}=t;return(0,s.kt)(HG,(0,p.Z)({},QG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}$G.isMDXComponent=!0;const KG={toc:[]},JG="wrapper";function tO(t){let{components:n,...e}=t;return(0,s.kt)(JG,(0,p.Z)({},KG,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Complex types used in animations."))}tO.isMDXComponent=!0;const nO={toc:[]},eO="wrapper";function oO(t){let{components:n,...e}=t;return(0,s.kt)(eO,(0,p.Z)({},nO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}oO.isMDXComponent=!0;const pO={toc:[]},rO="wrapper";function sO(t){let{components:n,...e}=t;return(0,s.kt)(rO,(0,p.Z)({},pO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the determinant of the matrix."))}sO.isMDXComponent=!0;const cO={toc:[]},iO="wrapper";function aO(t){let{components:n,...e}=t;return(0,s.kt)(iO,(0,p.Z)({},cO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}aO.isMDXComponent=!0;const lO={toc:[]},uO="wrapper";function mO(t){let{components:n,...e}=t;return(0,s.kt)(uO,(0,p.Z)({},lO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}mO.isMDXComponent=!0;const dO={toc:[]},hO="wrapper";function kO(t){let{components:n,...e}=t;return(0,s.kt)(hO,(0,p.Z)({},dO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the inverse of the matrix."))}kO.isMDXComponent=!0;const fO={toc:[]},yO="wrapper";function MO(t){let{components:n,...e}=t;return(0,s.kt)(yO,(0,p.Z)({},fO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}MO.isMDXComponent=!0;const DO={toc:[]},XO="wrapper";function _O(t){let{components:n,...e}=t;return(0,s.kt)(XO,(0,p.Z)({},DO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}_O.isMDXComponent=!0;const wO={toc:[]},TO="wrapper";function CO(t){let{components:n,...e}=t;return(0,s.kt)(TO,(0,p.Z)({},wO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the provided matrix to this matrix."))}CO.isMDXComponent=!0;const gO={toc:[]},xO="wrapper";function vO(t){let{components:n,...e}=t;return(0,s.kt)(xO,(0,p.Z)({},gO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to add"))}vO.isMDXComponent=!0;const LO={toc:[]},ZO="wrapper";function bO(t){let{components:n,...e}=t;return(0,s.kt)(ZO,(0,p.Z)({},LO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}bO.isMDXComponent=!0;const NO={toc:[]},AO="wrapper";function zO(t){let{components:n,...e}=t;return(0,s.kt)(AO,(0,p.Z)({},NO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}zO.isMDXComponent=!0;const WO={toc:[]},IO="wrapper";function RO(t){let{components:n,...e}=t;return(0,s.kt)(IO,(0,p.Z)({},WO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the component vector to retrieve."))}RO.isMDXComponent=!0;const PO={toc:[]},SO="wrapper";function EO(t){let{components:n,...e}=t;return(0,s.kt)(SO,(0,p.Z)({},PO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}EO.isMDXComponent=!0;const GO={toc:[]},OO="wrapper";function FO(t){let{components:n,...e}=t;return(0,s.kt)(OO,(0,p.Z)({},GO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}FO.isMDXComponent=!0;const BO={toc:[]},UO="wrapper";function VO(t){let{components:n,...e}=t;return(0,s.kt)(UO,(0,p.Z)({},BO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}VO.isMDXComponent=!0;const qO={toc:[]},jO="wrapper";function YO(t){let{components:n,...e}=t;return(0,s.kt)(jO,(0,p.Z)({},qO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to multiply with"))}YO.isMDXComponent=!0;const QO={toc:[]},HO="wrapper";function $O(t){let{components:n,...e}=t;return(0,s.kt)(HO,(0,p.Z)({},QO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}$O.isMDXComponent=!0;const KO={toc:[]},JO="wrapper";function tF(t){let{components:n,...e}=t;return(0,s.kt)(JO,(0,p.Z)({},KO,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}tF.isMDXComponent=!0;const nF={toc:[]},eF="wrapper";function oF(t){let{components:n,...e}=t;return(0,s.kt)(eF,(0,p.Z)({},nF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to scale each term"))}oF.isMDXComponent=!0;const pF={toc:[]},rF="wrapper";function sF(t){let{components:n,...e}=t;return(0,s.kt)(rF,(0,p.Z)({},pF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}sF.isMDXComponent=!0;const cF={toc:[]},iF="wrapper";function aF(t){let{components:n,...e}=t;return(0,s.kt)(iF,(0,p.Z)({},cF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}aF.isMDXComponent=!0;const lF={toc:[]},uF="wrapper";function mF(t){let{components:n,...e}=t;return(0,s.kt)(uF,(0,p.Z)({},lF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}mF.isMDXComponent=!0;const dF={toc:[]},hF="wrapper";function kF(t){let{components:n,...e}=t;return(0,s.kt)(hF,(0,p.Z)({},dF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate the matrix."))}kF.isMDXComponent=!0;const fF={toc:[]},yF="wrapper";function MF(t){let{components:n,...e}=t;return(0,s.kt)(yF,(0,p.Z)({},fF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the angle is provided in degrees."))}MF.isMDXComponent=!0;const DF={toc:[]},XF="wrapper";function _F(t){let{components:n,...e}=t;return(0,s.kt)(XF,(0,p.Z)({},DF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}_F.isMDXComponent=!0;const wF={toc:[]},TF="wrapper";function CF(t){let{components:n,...e}=t;return(0,s.kt)(TF,(0,p.Z)({},wF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}CF.isMDXComponent=!0;const gF={toc:[]},xF="wrapper";function vF(t){let{components:n,...e}=t;return(0,s.kt)(xF,(0,p.Z)({},gF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the row to retrieve."))}vF.isMDXComponent=!0;const LF={toc:[]},ZF="wrapper";function bF(t){let{components:n,...e}=t;return(0,s.kt)(ZF,(0,p.Z)({},LF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}bF.isMDXComponent=!0;const NF={toc:[]},AF="wrapper";function zF(t){let{components:n,...e}=t;return(0,s.kt)(AF,(0,p.Z)({},NF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}zF.isMDXComponent=!0;const WF={toc:[]},IF="wrapper";function RF(t){let{components:n,...e}=t;return(0,s.kt)(IF,(0,p.Z)({},WF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scale the x and y component vectors of the matrix."))}RF.isMDXComponent=!0;const PF={toc:[]},SF="wrapper";function EF(t){let{components:n,...e}=t;return(0,s.kt)(SF,(0,p.Z)({},PF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The factor by which to scale the matrix"))}EF.isMDXComponent=!0;const GF={toc:[]},OF="wrapper";function FF(t){let{components:n,...e}=t;return(0,s.kt)(OF,(0,p.Z)({},GF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}FF.isMDXComponent=!0;const BF={toc:[]},UF="wrapper";function VF(t){let{components:n,...e}=t;return(0,s.kt)(UF,(0,p.Z)({},BF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}VF.isMDXComponent=!0;const qF={toc:[]},jF="wrapper";function YF(t){let{components:n,...e}=t;return(0,s.kt)(jF,(0,p.Z)({},qF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subtract the provided matrix from this matrix."))}YF.isMDXComponent=!0;const QF={toc:[]},HF="wrapper";function $F(t){let{components:n,...e}=t;return(0,s.kt)(HF,(0,p.Z)({},QF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to subract"))}$F.isMDXComponent=!0;const KF={toc:[]},JF="wrapper";function tB(t){let{components:n,...e}=t;return(0,s.kt)(JF,(0,p.Z)({},KF,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}tB.isMDXComponent=!0;const nB={toc:[]},eB="wrapper";function oB(t){let{components:n,...e}=t;return(0,s.kt)(eB,(0,p.Z)({},nB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}oB.isMDXComponent=!0;const pB={toc:[]},rB="wrapper";function sB(t){let{components:n,...e}=t;return(0,s.kt)(rB,(0,p.Z)({},pB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}sB.isMDXComponent=!0;const cB={toc:[]},iB="wrapper";function aB(t){let{components:n,...e}=t;return(0,s.kt)(iB,(0,p.Z)({},cB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector by which to translate the matrix"))}aB.isMDXComponent=!0;const lB={toc:[]},uB="wrapper";function mB(t){let{components:n,...e}=t;return(0,s.kt)(uB,(0,p.Z)({},lB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector."))}mB.isMDXComponent=!0;const dB={toc:[]},hB="wrapper";function kB(t){let{components:n,...e}=t;return(0,s.kt)(hB,(0,p.Z)({},dB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(0, 1)")))}kB.isMDXComponent=!0;const fB={toc:[]},yB="wrapper";function MB(t){let{components:n,...e}=t;return(0,s.kt)(yB,(0,p.Z)({},fB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(-1, 1)")))}MB.isMDXComponent=!0;const DB={toc:[]},XB="wrapper";function _B(t){let{components:n,...e}=t;return(0,s.kt)(XB,(0,p.Z)({},DB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(1, 1)")))}_B.isMDXComponent=!0;const wB={toc:[]},TB="wrapper";function CB(t){let{components:n,...e}=t;return(0,s.kt)(TB,(0,p.Z)({},wB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(0, -1)")))}CB.isMDXComponent=!0;const gB={toc:[]},xB="wrapper";function vB(t){let{components:n,...e}=t;return(0,s.kt)(xB,(0,p.Z)({},gB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(-1, -1)")))}vB.isMDXComponent=!0;const LB={toc:[]},ZB="wrapper";function bB(t){let{components:n,...e}=t;return(0,s.kt)(ZB,(0,p.Z)({},LB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(1, -1)")))}bB.isMDXComponent=!0;const NB={toc:[]},AB="wrapper";function zB(t){let{components:n,...e}=t;return(0,s.kt)(AB,(0,p.Z)({},NB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}zB.isMDXComponent=!0;const WB={toc:[]},IB="wrapper";function RB(t){let{components:n,...e}=t;return(0,s.kt)(IB,(0,p.Z)({},WB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}RB.isMDXComponent=!0;const PB={toc:[]},SB="wrapper";function EB(t){let{components:n,...e}=t;return(0,s.kt)(SB,(0,p.Z)({},PB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}EB.isMDXComponent=!0;const GB={toc:[]},OB="wrapper";function FB(t){let{components:n,...e}=t;return(0,s.kt)(OB,(0,p.Z)({},GB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}FB.isMDXComponent=!0;const BB={toc:[]},UB="wrapper";function VB(t){let{components:n,...e}=t;return(0,s.kt)(UB,(0,p.Z)({},BB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are equal to each other."))}VB.isMDXComponent=!0;const qB={toc:[]},jB="wrapper";function YB(t){let{components:n,...e}=t;return(0,s.kt)(jB,(0,p.Z)({},qB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}YB.isMDXComponent=!0;const QB={toc:[]},HB="wrapper";function $B(t){let{components:n,...e}=t;return(0,s.kt)(HB,(0,p.Z)({},QB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The allowed error threshold when comparing the vectors."))}$B.isMDXComponent=!0;const KB={toc:[]},JB="wrapper";function tU(t){let{components:n,...e}=t;return(0,s.kt)(JB,(0,p.Z)({},KB,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}tU.isMDXComponent=!0;const nU={toc:[]},eU="wrapper";function oU(t){let{components:n,...e}=t;return(0,s.kt)(eU,(0,p.Z)({},nU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are exactly equal to each other."))}oU.isMDXComponent=!0;const pU={toc:[]},rU="wrapper";function sU(t){let{components:n,...e}=t;return(0,s.kt)(rU,(0,p.Z)({},pU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}sU.isMDXComponent=!0;const cU={toc:[]},iU="wrapper";function aU(t){let{components:n,...e}=t;return(0,s.kt)(iU,(0,p.Z)({},cU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotates the vector around a point by the provided angle."))}aU.isMDXComponent=!0;const lU={toc:[]},uU="wrapper";function mU(t){let{components:n,...e}=t;return(0,s.kt)(uU,(0,p.Z)({},lU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate in degrees."))}mU.isMDXComponent=!0;const dU={toc:[]},hU="wrapper";function kU(t){let{components:n,...e}=t;return(0,s.kt)(hU,(0,p.Z)({},dU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}kU.isMDXComponent=!0;const fU={toc:[]},yU="wrapper";function MU(t){let{components:n,...e}=t;return(0,s.kt)(yU,(0,p.Z)({},fU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Helper function to create a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#static-polarLerp"},(0,s.kt)("inlineCode",{parentName:"a"},"polarLerp"))," interpolation\nfunction with additional parameters."))}MU.isMDXComponent=!0;const DU={toc:[]},XU="wrapper";function _U(t){let{components:n,...e}=t;return(0,s.kt)(XU,(0,p.Z)({},DU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the point should get rotated\ncounterclockwise."))}_U.isMDXComponent=!0;const wU={toc:[]},TU="wrapper";function CU(t){let{components:n,...e}=t;return(0,s.kt)(TU,(0,p.Z)({},wU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}CU.isMDXComponent=!0;const gU={toc:[]},xU="wrapper";function vU(t){let{components:n,...e}=t;return(0,s.kt)(xU,(0,p.Z)({},gU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}vU.isMDXComponent=!0;const LU={toc:[]},ZU="wrapper";function bU(t){let{components:n,...e}=t;return(0,s.kt)(ZU,(0,p.Z)({},LU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}bU.isMDXComponent=!0;const NU={toc:[]},AU="wrapper";function zU(t){let{components:n,...e}=t;return(0,s.kt)(AU,(0,p.Z)({},NU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}zU.isMDXComponent=!0;const WU={toc:[]},IU="wrapper";function RU(t){let{components:n,...e}=t;return(0,s.kt)(IU,(0,p.Z)({},WU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}RU.isMDXComponent=!0;const PU={toc:[]},SU="wrapper";function EU(t){let{components:n,...e}=t;return(0,s.kt)(SU,(0,p.Z)({},PU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This function is useful when used in conjunction with ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"rotate"))," to\nanimate an object's position on a circular arc (see examples)."))}EU.isMDXComponent=!0;const GU={toc:[]},OU="wrapper";function FU(t){let{components:n,...e}=t;return(0,s.kt)(OU,(0,p.Z)({},GU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Animating an object in a circle around the origin"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.polarLerp\n);\n")))}FU.isMDXComponent=!0;const BU={toc:[]},UU="wrapper";function VU(t){let{components:n,...e}=t;return(0,s.kt)(UU,(0,p.Z)({},BU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotating an object around the point ",(0,s.kt)("inlineCode",{parentName:"p"},"[-200, 100]")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180, [-200, 100]),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(false, [-200, 100]),\n);\n")))}VU.isMDXComponent=!0;const qU={toc:[]},jU="wrapper";function YU(t){let{components:n,...e}=t;return(0,s.kt)(jU,(0,p.Z)({},qU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotating an object counterclockwise around the origin"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(true),\n);\n")))}YU.isMDXComponent=!0;const QU={toc:[]},HU="wrapper";function $U(t){let{components:n,...e}=t;return(0,s.kt)(HU,(0,p.Z)({},QU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolates between two vectors on the polar plane by interpolating\nthe angles and magnitudes of the vectors individually."))}$U.isMDXComponent=!0;const KU={toc:[]},JU="wrapper";function tV(t){let{components:n,...e}=t;return(0,s.kt)(JU,(0,p.Z)({},KU,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting vector."))}tV.isMDXComponent=!0;const nV={toc:[]},eV="wrapper";function oV(t){let{components:n,...e}=t;return(0,s.kt)(eV,(0,p.Z)({},nV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The target vector."))}oV.isMDXComponent=!0;const pV={toc:[]},rV="wrapper";function sV(t){let{components:n,...e}=t;return(0,s.kt)(rV,(0,p.Z)({},pV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t-value of the interpolation."))}sV.isMDXComponent=!0;const cV={toc:[]},iV="wrapper";function aV(t){let{components:n,...e}=t;return(0,s.kt)(iV,(0,p.Z)({},cV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the vector should get rotated\ncounterclockwise. Defaults to ",(0,s.kt)("inlineCode",{parentName:"p"},"false"),"."))}aV.isMDXComponent=!0;const lV={toc:[]},uV="wrapper";function mV(t){let{components:n,...e}=t;return(0,s.kt)(uV,(0,p.Z)({},lV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}mV.isMDXComponent=!0;const dV={toc:[]},hV="wrapper";function kV(t){let{components:n,...e}=t;return(0,s.kt)(hV,(0,p.Z)({},dV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}kV.isMDXComponent=!0;const fV={toc:[]},yV="wrapper";function MV(t){let{components:n,...e}=t;return(0,s.kt)(yV,(0,p.Z)({},fV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}MV.isMDXComponent=!0;const DV={toc:[]},XV="wrapper";function _V(t){let{components:n,...e}=t;return(0,s.kt)(XV,(0,p.Z)({},DV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}_V.isMDXComponent=!0;const wV={toc:[]},TV="wrapper";function CV(t){let{components:n,...e}=t;return(0,s.kt)(TV,(0,p.Z)({},wV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same class as the one created by\n",(0,s.kt)("a",{parentName:"p",href:"https://gka.github.io/chroma.js/"},(0,s.kt)("inlineCode",{parentName:"a"},"chroma.js")),". Check out their\ndocumentation for more information on how to use it."))}CV.isMDXComponent=!0;const gV={toc:[]},xV="wrapper";function vV(t){let{components:n,...e}=t;return(0,s.kt)(xV,(0,p.Z)({},gV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color."))}vV.isMDXComponent=!0;const LV={toc:[]},ZV="wrapper";function bV(t){let{components:n,...e}=t;return(0,s.kt)(ZV,(0,p.Z)({},LV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}bV.isMDXComponent=!0;const NV={toc:[]},AV="wrapper";function zV(t){let{components:n,...e}=t;return(0,s.kt)(AV,(0,p.Z)({},NV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given origin to a vector representing its offset."))}zV.isMDXComponent=!0;const WV={toc:[]},IV="wrapper";function RV(t){let{components:n,...e}=t;return(0,s.kt)(IV,(0,p.Z)({},WV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin to convert."))}RV.isMDXComponent=!0;const PV={toc:[]},SV="wrapper";function EV(t){let{components:n,...e}=t;return(0,s.kt)(SV,(0,p.Z)({},PV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"General utilities and helper functions."))}EV.isMDXComponent=!0;const GV={toc:[]},OV="wrapper";function FV(t){let{components:n,...e}=t;return(0,s.kt)(OV,(0,p.Z)({},GV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}FV.isMDXComponent=!0;const BV={toc:[]},UV="wrapper";function VV(t){let{components:n,...e}=t;return(0,s.kt)(UV,(0,p.Z)({},BV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional duration in milliseconds."))}VV.isMDXComponent=!0;const qV={toc:[]},jV="wrapper";function YV(t){let{components:n,...e}=t;return(0,s.kt)(jV,(0,p.Z)({},qV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This will be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.kt)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}YV.isMDXComponent=!0;const QV={toc:[]},HV="wrapper";function $V(t){let{components:n,...e}=t;return(0,s.kt)(HV,(0,p.Z)({},QV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional key used to inspect a related object."))}$V.isMDXComponent=!0;const KV={toc:[]},JV="wrapper";function tq(t){let{components:n,...e}=t;return(0,s.kt)(JV,(0,p.Z)({},KV,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded."))}tq.isMDXComponent=!0;const nq={toc:[]},eq="wrapper";function oq(t){let{components:n,...e}=t;return(0,s.kt)(eq,(0,p.Z)({},nq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An object that will be serialized as JSON and displayed under the message."))}oq.isMDXComponent=!0;const pq={toc:[]},rq="wrapper";function sq(t){let{components:n,...e}=t;return(0,s.kt)(rq,(0,p.Z)({},pq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Always visible."))}sq.isMDXComponent=!0;const cq={toc:[]},iq="wrapper";function aq(t){let{components:n,...e}=t;return(0,s.kt)(iq,(0,p.Z)({},cq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main message of the log."))}aq.isMDXComponent=!0;const lq={toc:[]},uq="wrapper";function mq(t){let{components:n,...e}=t;return(0,s.kt)(uq,(0,p.Z)({},lq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}mq.isMDXComponent=!0;const dq={toc:[]},hq="wrapper";function kq(t){let{components:n,...e}=t;return(0,s.kt)(hq,(0,p.Z)({},dq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}kq.isMDXComponent=!0;const fq={toc:[]},yq="wrapper";function Mq(t){let{components:n,...e}=t;return(0,s.kt)(yq,(0,p.Z)({},fq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}Mq.isMDXComponent=!0;const Dq={toc:[]},Xq="wrapper";function _q(t){let{components:n,...e}=t;return(0,s.kt)(Xq,(0,p.Z)({},Dq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}_q.isMDXComponent=!0;const wq={toc:[]},Tq="wrapper";function Cq(t){let{components:n,...e}=t;return(0,s.kt)(Tq,(0,p.Z)({},wq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional duration in milliseconds."))}Cq.isMDXComponent=!0;const gq={toc:[]},xq="wrapper";function vq(t){let{components:n,...e}=t;return(0,s.kt)(xq,(0,p.Z)({},gq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This will be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.kt)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}vq.isMDXComponent=!0;const Lq={toc:[]},Zq="wrapper";function bq(t){let{components:n,...e}=t;return(0,s.kt)(Zq,(0,p.Z)({},Lq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional key used to inspect a related object."))}bq.isMDXComponent=!0;const Nq={toc:[]},Aq="wrapper";function zq(t){let{components:n,...e}=t;return(0,s.kt)(Aq,(0,p.Z)({},Nq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded."))}zq.isMDXComponent=!0;const Wq={toc:[]},Iq="wrapper";function Rq(t){let{components:n,...e}=t;return(0,s.kt)(Iq,(0,p.Z)({},Wq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An object that will be serialized as JSON and displayed under the message."))}Rq.isMDXComponent=!0;const Pq={toc:[]},Sq="wrapper";function Eq(t){let{components:n,...e}=t;return(0,s.kt)(Sq,(0,p.Z)({},Pq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Always visible."))}Eq.isMDXComponent=!0;const Gq={toc:[]},Oq="wrapper";function Fq(t){let{components:n,...e}=t;return(0,s.kt)(Oq,(0,p.Z)({},Gq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main message of the log."))}Fq.isMDXComponent=!0;const Bq={toc:[]},Uq="wrapper";function Vq(t){let{components:n,...e}=t;return(0,s.kt)(Uq,(0,p.Z)({},Bq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}Vq.isMDXComponent=!0;const qq={toc:[]},jq="wrapper";function Yq(t){let{components:n,...e}=t;return(0,s.kt)(jq,(0,p.Z)({},qq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}Yq.isMDXComponent=!0;const Qq={toc:[]},Hq="wrapper";function $q(t){let{components:n,...e}=t;return(0,s.kt)(Hq,(0,p.Z)({},Qq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}$q.isMDXComponent=!0;const Kq={toc:[]},Jq="wrapper";function tj(t){let{components:n,...e}=t;return(0,s.kt)(Jq,(0,p.Z)({},Kq,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of the transformed references."))}tj.isMDXComponent=!0;const nj={toc:[]},ej="wrapper";function oj(t){let{components:n,...e}=t;return(0,s.kt)(ej,(0,p.Z)({},nj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Maps the references in this group to a new array."))}oj.isMDXComponent=!0;const pj={toc:[]},rj="wrapper";function sj(t){let{components:n,...e}=t;return(0,s.kt)(rj,(0,p.Z)({},pj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to transform each reference."))}sj.isMDXComponent=!0;const cj={toc:[]},ij="wrapper";function aj(t){let{components:n,...e}=t;return(0,s.kt)(ij,(0,p.Z)({},cj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}aj.isMDXComponent=!0;const lj={toc:[]},uj="wrapper";function mj(t){let{components:n,...e}=t;return(0,s.kt)(uj,(0,p.Z)({},lj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting degrees to radians"))}mj.isMDXComponent=!0;const dj={toc:[]},hj="wrapper";function kj(t){let{components:n,...e}=t;return(0,s.kt)(hj,(0,p.Z)({},dj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}kj.isMDXComponent=!0;const fj={toc:[]},yj="wrapper";function Mj(t){let{components:n,...e}=t;return(0,s.kt)(yj,(0,p.Z)({},fj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting radians to degrees"))}Mj.isMDXComponent=!0;const Dj={toc:[]},Xj="wrapper";function _j(t){let{components:n,...e}=t;return(0,s.kt)(Xj,(0,p.Z)({},Dj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned object is both an array and a reference that can be passed\ndirectly to the ",(0,s.kt)("inlineCode",{parentName:"p"},"ref")," property of a node."))}_j.isMDXComponent=!0;const wj={toc:[]},Tj="wrapper";function Cj(t){let{components:n,...e}=t;return(0,s.kt)(Tj,(0,p.Z)({},wj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefArray<Txt>();\n\nview.add(['A', 'B'].map(text => <Txt ref={labels}>{text}</Txt>));\nview.add(<Txt ref={labels}>C</Txt>);\n\n// accessing the references individually:\nyield* labels[0].text('A changes', 0.3);\nyield* labels[1].text('B changes', 0.3);\nyield* labels[2].text('C changes', 0.3);\n\n// accessing all references at once:\nyield* all(...labels.map(label => label.fill('white', 0.3)));\n")))}Cj.isMDXComponent=!0;const gj={toc:[]},xj="wrapper";function vj(t){let{components:n,...e}=t;return(0,s.kt)(xj,(0,p.Z)({},gj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array of references."))}vj.isMDXComponent=!0;const Lj={toc:[]},Zj="wrapper";function bj(t){let{components:n,...e}=t;return(0,s.kt)(Zj,(0,p.Z)({},Lj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned object lets you easily create multiple references to the same\ntype without initializing them individually."),(0,s.kt)("p",null,"You can retrieve references by accessing the object's properties. If the\nreference for a given property does not exist, it will be created\nautomatically."))}bj.isMDXComponent=!0;const Nj={toc:[]},Aj="wrapper";function zj(t){let{components:n,...e}=t;return(0,s.kt)(Aj,(0,p.Z)({},Nj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefMap<Txt>();\n\nview.add(\n  <>\n    <Txt ref={labels.a}>A</Txt>\n    <Txt ref={labels.b}>B</Txt>\n    <Txt ref={labels.c}>C</Txt>\n  </>,\n);\n\n// accessing the references individually:\nyield* labels.a().text('A changes', 0.3);\nyield* labels.b().text('B changes', 0.3);\nyield* labels.c().text('C changes', 0.3);\n\n// checking if the given reference exists:\nif ('d' in labels) {\n  yield* labels.d().text('D changes', 0.3);\n}\n\n// accessing all references at once:\nyield* all(...labels.mapRefs(label => label.fill('white', 0.3)));\n")))}zj.isMDXComponent=!0;const Wj={toc:[]},Ij="wrapper";function Rj(t){let{components:n,...e}=t;return(0,s.kt)(Ij,(0,p.Z)({},Wj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a group of references."))}Rj.isMDXComponent=!0;const Pj={toc:[]},Sj="wrapper";function Ej(t){let{components:n,...e}=t;return(0,s.kt)(Sj,(0,p.Z)({},Pj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is a shortcut for calling ",(0,s.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}Ej.isMDXComponent=!0;const Gj={toc:[]},Oj="wrapper";function Fj(t){let{components:n,...e}=t;return(0,s.kt)(Oj,(0,p.Z)({},Gj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}Fj.isMDXComponent=!0;const Bj={toc:[]},Uj="wrapper";function Vj(t){let{components:n,...e}=t;return(0,s.kt)(Uj,(0,p.Z)({},Bj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Logs a debug message with an arbitrary payload."))}Vj.isMDXComponent=!0;const qj={toc:[]},jj="wrapper";function Yj(t){let{components:n,...e}=t;return(0,s.kt)(jj,(0,p.Z)({},qj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The payload to log"))}Yj.isMDXComponent=!0;const Qj={toc:[]},Hj="wrapper";function $j(t){let{components:n,...e}=t;return(0,s.kt)(Hj,(0,p.Z)({},Qj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the given function as deprecated."))}$j.isMDXComponent=!0;const Kj={toc:[]},Jj="wrapper";function tY(t){let{components:n,...e}=t;return(0,s.kt)(Jj,(0,p.Z)({},Kj,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to deprecate."))}tY.isMDXComponent=!0;const nY={toc:[]},eY="wrapper";function oY(t){let{components:n,...e}=t;return(0,s.kt)(eY,(0,p.Z)({},nY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log message."))}oY.isMDXComponent=!0;const pY={toc:[]},rY="wrapper";function sY(t){let{components:n,...e}=t;return(0,s.kt)(rY,(0,p.Z)({},pY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The optional log remarks."))}sY.isMDXComponent=!0;const cY={toc:[]},iY="wrapper";function aY(t){let{components:n,...e}=t;return(0,s.kt)(iY,(0,p.Z)({},cY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}aY.isMDXComponent=!0;const lY={toc:[]},uY="wrapper";function mY(t){let{components:n,...e}=t;return(0,s.kt)(uY,(0,p.Z)({},lY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the current scene as ready to transition out."))}mY.isMDXComponent=!0;const dY={toc:[]},hY="wrapper";function kY(t){let{components:n,...e}=t;return(0,s.kt)(hY,(0,p.Z)({},dY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}kY.isMDXComponent=!0;const fY={toc:[]},yY="wrapper";function MY(t){let{components:n,...e}=t;return(0,s.kt)(yY,(0,p.Z)({},fY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}MY.isMDXComponent=!0;const DY={toc:[]},XY="wrapper";function _Y(t){let{components:n,...e}=t;return(0,s.kt)(XY,(0,p.Z)({},DY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}_Y.isMDXComponent=!0;const wY={toc:[]},TY="wrapper";function CY(t){let{components:n,...e}=t;return(0,s.kt)(TY,(0,p.Z)({},wY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}CY.isMDXComponent=!0;const gY={toc:[]},xY="wrapper";function vY(t){let{components:n,...e}=t;return(0,s.kt)(xY,(0,p.Z)({},gY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The length of the array."))}vY.isMDXComponent=!0;const LY={toc:[]},ZY="wrapper";function bY(t){let{components:n,...e}=t;return(0,s.kt)(ZY,(0,p.Z)({},LY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}bY.isMDXComponent=!0;const NY={toc:[]},AY="wrapper";function zY(t){let{components:n,...e}=t;return(0,s.kt)(AY,(0,p.Z)({},NY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}zY.isMDXComponent=!0;const WY={toc:[]},IY="wrapper";function RY(t){let{components:n,...e}=t;return(0,s.kt)(IY,(0,p.Z)({},WY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}RY.isMDXComponent=!0;const PY={toc:[]},SY="wrapper";function EY(t){let{components:n,...e}=t;return(0,s.kt)(SY,(0,p.Z)({},PY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}EY.isMDXComponent=!0;const GY={toc:[]},OY="wrapper";function FY(t){let{components:n,...e}=t;return(0,s.kt)(OY,(0,p.Z)({},GY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}FY.isMDXComponent=!0;const BY={toc:[]},UY="wrapper";function VY(t){let{components:n,...e}=t;return(0,s.kt)(UY,(0,p.Z)({},BY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}VY.isMDXComponent=!0;const qY={toc:[]},jY="wrapper";function YY(t){let{components:n,...e}=t;return(0,s.kt)(jY,(0,p.Z)({},qY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}YY.isMDXComponent=!0;const QY={toc:[]},HY="wrapper";function $Y(t){let{components:n,...e}=t;return(0,s.kt)(HY,(0,p.Z)({},QY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}$Y.isMDXComponent=!0;const KY={toc:[]},JY="wrapper";function tQ(t){let{components:n,...e}=t;return(0,s.kt)(JY,(0,p.Z)({},KY,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to increment or decrement."))}tQ.isMDXComponent=!0;const nQ={toc:[]},eQ="wrapper";function oQ(t){let{components:n,...e}=t;return(0,s.kt)(eQ,(0,p.Z)({},nQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}oQ.isMDXComponent=!0;const pQ={toc:[]},rQ="wrapper";function sQ(t){let{components:n,...e}=t;return(0,s.kt)(rQ,(0,p.Z)({},pQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context before render."))}sQ.isMDXComponent=!0;const cQ={toc:[]},iQ="wrapper";function aQ(t){let{components:n,...e}=t;return(0,s.kt)(iQ,(0,p.Z)({},cQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}aQ.isMDXComponent=!0;const lQ={toc:[]},uQ="wrapper";function mQ(t){let{components:n,...e}=t;return(0,s.kt)(uQ,(0,p.Z)({},lQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context after render."))}mQ.isMDXComponent=!0;const dQ={toc:[]},hQ="wrapper";function kQ(t){let{components:n,...e}=t;return(0,s.kt)(hQ,(0,p.Z)({},dQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}kQ.isMDXComponent=!0;const fQ={toc:[]},yQ="wrapper";function MQ(t){let{components:n,...e}=t;return(0,s.kt)(yQ,(0,p.Z)({},fQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}MQ.isMDXComponent=!0;const DQ={toc:[]},XQ="wrapper";function _Q(t){let{components:n,...e}=t;return(0,s.kt)(XQ,(0,p.Z)({},DQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the event in seconds."))}_Q.isMDXComponent=!0;const wQ={toc:[]},TQ="wrapper";function CQ(t){let{components:n,...e}=t;return(0,s.kt)(TQ,(0,p.Z)({},wQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Register a time event and get its duration in seconds."))}CQ.isMDXComponent=!0;const gQ={toc:[]},xQ="wrapper";function vQ(t){let{components:n,...e}=t;return(0,s.kt)(xQ,(0,p.Z)({},gQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the event."))}vQ.isMDXComponent=!0;const LQ={toc:[]},ZQ="wrapper";function bQ(t){let{components:n,...e}=t;return(0,s.kt)(ZQ,(0,p.Z)({},LQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the playback status."))}bQ.isMDXComponent=!0;const NQ={toc:[]},AQ="wrapper";function zQ(t){let{components:n,...e}=t;return(0,s.kt)(AQ,(0,p.Z)({},NQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the current scene."))}zQ.isMDXComponent=!0;const WQ={toc:[]},IQ="wrapper";function RQ(t){let{components:n,...e}=t;return(0,s.kt)(IQ,(0,p.Z)({},WQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the given seed."))}RQ.isMDXComponent=!0;const PQ={toc:[]},SQ="wrapper";function EQ(t){let{components:n,...e}=t;return(0,s.kt)(SQ,(0,p.Z)({},PQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seed for the generator."))}EQ.isMDXComponent=!0;const GQ={toc:[]},OQ="wrapper";function FQ(t){let{components:n,...e}=t;return(0,s.kt)(OQ,(0,p.Z)({},GQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}FQ.isMDXComponent=!0;const BQ={toc:[]},UQ="wrapper";function VQ(t){let{components:n,...e}=t;return(0,s.kt)(UQ,(0,p.Z)({},BQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current scene."))}VQ.isMDXComponent=!0;const qQ={toc:[]},jQ="wrapper";function YQ(t){let{components:n,...e}=t;return(0,s.kt)(jQ,(0,p.Z)({},qQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current thread."))}YQ.isMDXComponent=!0;const QQ={toc:[]},HQ="wrapper";function $Q(t){let{components:n,...e}=t;return(0,s.kt)(HQ,(0,p.Z)({},QQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}$Q.isMDXComponent=!0;const KQ={toc:[]},JQ="wrapper";function tH(t){let{components:n,...e}=t;return(0,s.kt)(JQ,(0,p.Z)({},KQ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}tH.isMDXComponent=!0;const nH={toc:[]},eH="wrapper";function oH(t){let{components:n,...e}=t;return(0,s.kt)(eH,(0,p.Z)({},nH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real time since the start of the animation."))}oH.isMDXComponent=!0;const pH={toc:[]},rH="wrapper";function sH(t){let{components:n,...e}=t;return(0,s.kt)(rH,(0,p.Z)({},pH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This rewrites a remote url like ",(0,s.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}sH.isMDXComponent=!0;const cH={toc:[]},iH="wrapper";function aH(t){let{components:n,...e}=t;return(0,s.kt)(iH,(0,p.Z)({},cH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Route the given url through a local proxy."))}aH.isMDXComponent=!0;const lH={toc:[]},uH="wrapper";function mH(t){let{components:n,...e}=t;return(0,s.kt)(uH,(0,p.Z)({},lH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}mH.isMDXComponent=!0;const dH={toc:[]},hH="wrapper";function kH(t){let{components:n,...e}=t;return(0,s.kt)(hH,(0,p.Z)({},dH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}kH.isMDXComponent=!0;const fH={toc:[]},yH="wrapper";function MH(t){let{components:n,...e}=t;return(0,s.kt)(yH,(0,p.Z)({},fH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}MH.isMDXComponent=!0;const DH={toc:[]},XH="wrapper";function _H(t){let{components:n,...e}=t;return(0,s.kt)(XH,(0,p.Z)({},DH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}_H.isMDXComponent=!0;const wH={toc:[]},TH="wrapper";function CH(t){let{components:n,...e}=t;return(0,s.kt)(TH,(0,p.Z)({},wH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}CH.isMDXComponent=!0;const gH={toc:[]},xH="wrapper";function vH(t){let{components:n,...e}=t;return(0,s.kt)(xH,(0,p.Z)({},gH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}vH.isMDXComponent=!0;const LH={toc:[]},ZH="wrapper";function bH(t){let{components:n,...e}=t;return(0,s.kt)(ZH,(0,p.Z)({},LH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}bH.isMDXComponent=!0;const NH={toc:[]},AH="wrapper";function zH(t){let{components:n,...e}=t;return(0,s.kt)(AH,(0,p.Z)({},NH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}zH.isMDXComponent=!0;const WH={toc:[]},IH="wrapper";function RH(t){let{components:n,...e}=t;return(0,s.kt)(IH,(0,p.Z)({},WH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}RH.isMDXComponent=!0;const PH={toc:[]},SH="wrapper";function EH(t){let{components:n,...e}=t;return(0,s.kt)(SH,(0,p.Z)({},PH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}EH.isMDXComponent=!0;const GH={toc:[]},OH="wrapper";function FH(t){let{components:n,...e}=t;return(0,s.kt)(OH,(0,p.Z)({},GH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}FH.isMDXComponent=!0;const BH={toc:[]},UH="wrapper";function VH(t){let{components:n,...e}=t;return(0,s.kt)(UH,(0,p.Z)({},BH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}VH.isMDXComponent=!0;const qH={toc:[]},jH="wrapper";function YH(t){let{components:n,...e}=t;return(0,s.kt)(jH,(0,p.Z)({},qH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}YH.isMDXComponent=!0;const QH={toc:[]},HH="wrapper";function $H(t){let{components:n,...e}=t;return(0,s.kt)(HH,(0,p.Z)({},QH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}$H.isMDXComponent=!0;const KH={toc:[]},JH="wrapper";function t$(t){let{components:n,...e}=t;return(0,s.kt)(JH,(0,p.Z)({},KH,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}t$.isMDXComponent=!0;const n$={toc:[]},e$="wrapper";function o$(t){let{components:n,...e}=t;return(0,s.kt)(e$,(0,p.Z)({},n$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}o$.isMDXComponent=!0;const p$={toc:[]},r$="wrapper";function s$(t){let{components:n,...e}=t;return(0,s.kt)(r$,(0,p.Z)({},p$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}s$.isMDXComponent=!0;const c$={toc:[]},i$="wrapper";function a$(t){let{components:n,...e}=t;return(0,s.kt)(i$,(0,p.Z)({},c$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}a$.isMDXComponent=!0;const l$={toc:[]},u$="wrapper";function m$(t){let{components:n,...e}=t;return(0,s.kt)(u$,(0,p.Z)({},l$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}m$.isMDXComponent=!0;const d$={toc:[]},h$="wrapper";function k$(t){let{components:n,...e}=t;return(0,s.kt)(h$,(0,p.Z)({},d$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}k$.isMDXComponent=!0;const f$={toc:[]},y$="wrapper";function M$(t){let{components:n,...e}=t;return(0,s.kt)(y$,(0,p.Z)({},f$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}M$.isMDXComponent=!0;const D$={toc:[]},X$="wrapper";function _$(t){let{components:n,...e}=t;return(0,s.kt)(X$,(0,p.Z)({},D$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}_$.isMDXComponent=!0;const w$={toc:[]},T$="wrapper";function C$(t){let{components:n,...e}=t;return(0,s.kt)(T$,(0,p.Z)({},w$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}C$.isMDXComponent=!0;const g$={toc:[]},x$="wrapper";function v$(t){let{components:n,...e}=t;return(0,s.kt)(x$,(0,p.Z)({},g$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}v$.isMDXComponent=!0;const L$={toc:[]},Z$="wrapper";function b$(t){let{components:n,...e}=t;return(0,s.kt)(Z$,(0,p.Z)({},L$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}b$.isMDXComponent=!0;const N$={toc:[]},A$="wrapper";function z$(t){let{components:n,...e}=t;return(0,s.kt)(A$,(0,p.Z)({},N$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}z$.isMDXComponent=!0;const W$={toc:[]},I$="wrapper";function R$(t){let{components:n,...e}=t;return(0,s.kt)(I$,(0,p.Z)({},W$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}R$.isMDXComponent=!0;const P$={toc:[]},S$="wrapper";function E$(t){let{components:n,...e}=t;return(0,s.kt)(S$,(0,p.Z)({},P$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}E$.isMDXComponent=!0;const G$={toc:[]},O$="wrapper";function F$(t){let{components:n,...e}=t;return(0,s.kt)(O$,(0,p.Z)({},G$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}F$.isMDXComponent=!0;const B$={toc:[]},U$="wrapper";function V$(t){let{components:n,...e}=t;return(0,s.kt)(U$,(0,p.Z)({},B$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}V$.isMDXComponent=!0;const q$={toc:[]},j$="wrapper";function Y$(t){let{components:n,...e}=t;return(0,s.kt)(j$,(0,p.Z)({},q$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Y$.isMDXComponent=!0;const Q$={toc:[]},H$="wrapper";function $$(t){let{components:n,...e}=t;return(0,s.kt)(H$,(0,p.Z)({},Q$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}$$.isMDXComponent=!0;const K$={toc:[]},J$="wrapper";function tK(t){let{components:n,...e}=t;return(0,s.kt)(J$,(0,p.Z)({},K$,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}tK.isMDXComponent=!0;const nK={toc:[]},eK="wrapper";function oK(t){let{components:n,...e}=t;return(0,s.kt)(eK,(0,p.Z)({},nK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}oK.isMDXComponent=!0;const pK={toc:[]},rK="wrapper";function sK(t){let{components:n,...e}=t;return(0,s.kt)(rK,(0,p.Z)({},pK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}sK.isMDXComponent=!0;const cK={toc:[]},iK="wrapper";function aK(t){let{components:n,...e}=t;return(0,s.kt)(iK,(0,p.Z)({},cK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}aK.isMDXComponent=!0;const lK={toc:[]},uK="wrapper";function mK(t){let{components:n,...e}=t;return(0,s.kt)(uK,(0,p.Z)({},lK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}mK.isMDXComponent=!0;const dK={toc:[]},hK="wrapper";function kK(t){let{components:n,...e}=t;return(0,s.kt)(hK,(0,p.Z)({},dK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}kK.isMDXComponent=!0;const fK={toc:[]},yK="wrapper";function MK(t){let{components:n,...e}=t;return(0,s.kt)(yK,(0,p.Z)({},fK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}MK.isMDXComponent=!0;const DK={toc:[]},XK="wrapper";function _K(t){let{components:n,...e}=t;return(0,s.kt)(XK,(0,p.Z)({},DK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}_K.isMDXComponent=!0;const wK={toc:[]},TK="wrapper";function CK(t){let{components:n,...e}=t;return(0,s.kt)(TK,(0,p.Z)({},wK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}CK.isMDXComponent=!0;const gK={toc:[]},xK="wrapper";function vK(t){let{components:n,...e}=t;return(0,s.kt)(xK,(0,p.Z)({},gK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}vK.isMDXComponent=!0;const LK={toc:[]},ZK="wrapper";function bK(t){let{components:n,...e}=t;return(0,s.kt)(ZK,(0,p.Z)({},LK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}bK.isMDXComponent=!0;const NK={toc:[]},AK="wrapper";function zK(t){let{components:n,...e}=t;return(0,s.kt)(AK,(0,p.Z)({},NK,e,{components:n,mdxType:"MDXLayout"}))}zK.isMDXComponent=!0;const WK={toc:[]},IK="wrapper";function RK(t){let{components:n,...e}=t;return(0,s.kt)(IK,(0,p.Z)({},WK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}RK.isMDXComponent=!0;const PK={toc:[]},SK="wrapper";function EK(t){let{components:n,...e}=t;return(0,s.kt)(SK,(0,p.Z)({},PK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}EK.isMDXComponent=!0;const GK={toc:[]},OK="wrapper";function FK(t){let{components:n,...e}=t;return(0,s.kt)(OK,(0,p.Z)({},GK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}FK.isMDXComponent=!0;const BK={toc:[]},UK="wrapper";function VK(t){let{components:n,...e}=t;return(0,s.kt)(UK,(0,p.Z)({},BK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}VK.isMDXComponent=!0;const qK={toc:[]},jK="wrapper";function YK(t){let{components:n,...e}=t;return(0,s.kt)(jK,(0,p.Z)({},qK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}YK.isMDXComponent=!0;const QK={toc:[]},HK="wrapper";function $K(t){let{components:n,...e}=t;return(0,s.kt)(HK,(0,p.Z)({},QK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}$K.isMDXComponent=!0;const KK={toc:[]},JK="wrapper";function tJ(t){let{components:n,...e}=t;return(0,s.kt)(JK,(0,p.Z)({},KK,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}tJ.isMDXComponent=!0;const nJ={toc:[]},eJ="wrapper";function oJ(t){let{components:n,...e}=t;return(0,s.kt)(eJ,(0,p.Z)({},nJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}oJ.isMDXComponent=!0;const pJ={toc:[]},rJ="wrapper";function sJ(t){let{components:n,...e}=t;return(0,s.kt)(rJ,(0,p.Z)({},pJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}sJ.isMDXComponent=!0;const cJ={toc:[]},iJ="wrapper";function aJ(t){let{components:n,...e}=t;return(0,s.kt)(iJ,(0,p.Z)({},cJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}aJ.isMDXComponent=!0;const lJ={toc:[]},uJ="wrapper";function mJ(t){let{components:n,...e}=t;return(0,s.kt)(uJ,(0,p.Z)({},lJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}mJ.isMDXComponent=!0;const dJ={toc:[]},hJ="wrapper";function kJ(t){let{components:n,...e}=t;return(0,s.kt)(hJ,(0,p.Z)({},dJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}kJ.isMDXComponent=!0;const fJ={toc:[]},yJ="wrapper";function MJ(t){let{components:n,...e}=t;return(0,s.kt)(yJ,(0,p.Z)({},fJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}MJ.isMDXComponent=!0;const DJ={toc:[]},XJ="wrapper";function _J(t){let{components:n,...e}=t;return(0,s.kt)(XJ,(0,p.Z)({},DJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}_J.isMDXComponent=!0;const wJ={toc:[]},TJ="wrapper";function CJ(t){let{components:n,...e}=t;return(0,s.kt)(TJ,(0,p.Z)({},wJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}CJ.isMDXComponent=!0;const gJ={toc:[]},xJ="wrapper";function vJ(t){let{components:n,...e}=t;return(0,s.kt)(xJ,(0,p.Z)({},gJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}vJ.isMDXComponent=!0;const LJ={toc:[]},ZJ="wrapper";function bJ(t){let{components:n,...e}=t;return(0,s.kt)(ZJ,(0,p.Z)({},LJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}bJ.isMDXComponent=!0;const NJ={toc:[]},AJ="wrapper";function zJ(t){let{components:n,...e}=t;return(0,s.kt)(AJ,(0,p.Z)({},NJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}zJ.isMDXComponent=!0;const WJ={toc:[]},IJ="wrapper";function RJ(t){let{components:n,...e}=t;return(0,s.kt)(IJ,(0,p.Z)({},WJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}RJ.isMDXComponent=!0;const PJ={toc:[]},SJ="wrapper";function EJ(t){let{components:n,...e}=t;return(0,s.kt)(SJ,(0,p.Z)({},PJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}EJ.isMDXComponent=!0;const GJ={toc:[]},OJ="wrapper";function FJ(t){let{components:n,...e}=t;return(0,s.kt)(OJ,(0,p.Z)({},GJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}FJ.isMDXComponent=!0;const BJ={toc:[]},UJ="wrapper";function VJ(t){let{components:n,...e}=t;return(0,s.kt)(UJ,(0,p.Z)({},BJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}VJ.isMDXComponent=!0;const qJ={toc:[]},jJ="wrapper";function YJ(t){let{components:n,...e}=t;return(0,s.kt)(jJ,(0,p.Z)({},qJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}YJ.isMDXComponent=!0;const QJ={toc:[]},HJ="wrapper";function $J(t){let{components:n,...e}=t;return(0,s.kt)(HJ,(0,p.Z)({},QJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}$J.isMDXComponent=!0;const KJ={toc:[]},JJ="wrapper";function t0(t){let{components:n,...e}=t;return(0,s.kt)(JJ,(0,p.Z)({},KJ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}t0.isMDXComponent=!0;const n0={toc:[]},e0="wrapper";function o0(t){let{components:n,...e}=t;return(0,s.kt)(e0,(0,p.Z)({},n0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}o0.isMDXComponent=!0;const p0={toc:[]},r0="wrapper";function s0(t){let{components:n,...e}=t;return(0,s.kt)(r0,(0,p.Z)({},p0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}s0.isMDXComponent=!0;const c0={toc:[]},i0="wrapper";function a0(t){let{components:n,...e}=t;return(0,s.kt)(i0,(0,p.Z)({},c0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}a0.isMDXComponent=!0;const l0={toc:[]},u0="wrapper";function m0(t){let{components:n,...e}=t;return(0,s.kt)(u0,(0,p.Z)({},l0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}m0.isMDXComponent=!0;const d0={toc:[]},h0="wrapper";function k0(t){let{components:n,...e}=t;return(0,s.kt)(h0,(0,p.Z)({},d0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}k0.isMDXComponent=!0;const f0={toc:[]},y0="wrapper";function M0(t){let{components:n,...e}=t;return(0,s.kt)(y0,(0,p.Z)({},f0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}M0.isMDXComponent=!0;const D0={toc:[]},X0="wrapper";function _0(t){let{components:n,...e}=t;return(0,s.kt)(X0,(0,p.Z)({},D0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}_0.isMDXComponent=!0;const w0={toc:[]},T0="wrapper";function C0(t){let{components:n,...e}=t;return(0,s.kt)(T0,(0,p.Z)({},w0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}C0.isMDXComponent=!0;const g0={toc:[]},x0="wrapper";function v0(t){let{components:n,...e}=t;return(0,s.kt)(x0,(0,p.Z)({},g0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}v0.isMDXComponent=!0;const L0={toc:[]},Z0="wrapper";function b0(t){let{components:n,...e}=t;return(0,s.kt)(Z0,(0,p.Z)({},L0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}b0.isMDXComponent=!0;const N0={toc:[]},A0="wrapper";function z0(t){let{components:n,...e}=t;return(0,s.kt)(A0,(0,p.Z)({},N0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}z0.isMDXComponent=!0;const W0={toc:[]},I0="wrapper";function R0(t){let{components:n,...e}=t;return(0,s.kt)(I0,(0,p.Z)({},W0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}R0.isMDXComponent=!0;const P0={toc:[]},S0="wrapper";function E0(t){let{components:n,...e}=t;return(0,s.kt)(S0,(0,p.Z)({},P0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}E0.isMDXComponent=!0;const G0={toc:[]},O0="wrapper";function F0(t){let{components:n,...e}=t;return(0,s.kt)(O0,(0,p.Z)({},G0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}F0.isMDXComponent=!0;const B0={toc:[]},U0="wrapper";function V0(t){let{components:n,...e}=t;return(0,s.kt)(U0,(0,p.Z)({},B0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}V0.isMDXComponent=!0;const q0={toc:[]},j0="wrapper";function Y0(t){let{components:n,...e}=t;return(0,s.kt)(j0,(0,p.Z)({},q0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Y0.isMDXComponent=!0;const Q0={toc:[]},H0="wrapper";function $0(t){let{components:n,...e}=t;return(0,s.kt)(H0,(0,p.Z)({},Q0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}$0.isMDXComponent=!0;const K0={toc:[]},J0="wrapper";function t2(t){let{components:n,...e}=t;return(0,s.kt)(J0,(0,p.Z)({},K0,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}t2.isMDXComponent=!0;const n2={toc:[]},e2="wrapper";function o2(t){let{components:n,...e}=t;return(0,s.kt)(e2,(0,p.Z)({},n2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}o2.isMDXComponent=!0;const p2={toc:[]},r2="wrapper";function s2(t){let{components:n,...e}=t;return(0,s.kt)(r2,(0,p.Z)({},p2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}s2.isMDXComponent=!0;const c2={toc:[]},i2="wrapper";function a2(t){let{components:n,...e}=t;return(0,s.kt)(i2,(0,p.Z)({},c2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}a2.isMDXComponent=!0;const l2={toc:[]},u2="wrapper";function m2(t){let{components:n,...e}=t;return(0,s.kt)(u2,(0,p.Z)({},l2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}m2.isMDXComponent=!0;const d2={toc:[]},h2="wrapper";function k2(t){let{components:n,...e}=t;return(0,s.kt)(h2,(0,p.Z)({},d2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}k2.isMDXComponent=!0;const f2={toc:[]},y2="wrapper";function M2(t){let{components:n,...e}=t;return(0,s.kt)(y2,(0,p.Z)({},f2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}M2.isMDXComponent=!0;const D2={toc:[]},X2="wrapper";function _2(t){let{components:n,...e}=t;return(0,s.kt)(X2,(0,p.Z)({},D2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}_2.isMDXComponent=!0;const w2={toc:[]},T2="wrapper";function C2(t){let{components:n,...e}=t;return(0,s.kt)(T2,(0,p.Z)({},w2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}C2.isMDXComponent=!0;const g2={toc:[]},x2="wrapper";function v2(t){let{components:n,...e}=t;return(0,s.kt)(x2,(0,p.Z)({},g2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}v2.isMDXComponent=!0;const L2={toc:[]},Z2="wrapper";function b2(t){let{components:n,...e}=t;return(0,s.kt)(Z2,(0,p.Z)({},L2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}b2.isMDXComponent=!0;const N2={toc:[]},A2="wrapper";function z2(t){let{components:n,...e}=t;return(0,s.kt)(A2,(0,p.Z)({},N2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}z2.isMDXComponent=!0;const W2={toc:[]},I2="wrapper";function R2(t){let{components:n,...e}=t;return(0,s.kt)(I2,(0,p.Z)({},W2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}R2.isMDXComponent=!0;const P2={toc:[]},S2="wrapper";function E2(t){let{components:n,...e}=t;return(0,s.kt)(S2,(0,p.Z)({},P2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}E2.isMDXComponent=!0;const G2={toc:[]},O2="wrapper";function F2(t){let{components:n,...e}=t;return(0,s.kt)(O2,(0,p.Z)({},G2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}F2.isMDXComponent=!0;const B2={toc:[]},U2="wrapper";function V2(t){let{components:n,...e}=t;return(0,s.kt)(U2,(0,p.Z)({},B2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}V2.isMDXComponent=!0;const q2={toc:[]},j2="wrapper";function Y2(t){let{components:n,...e}=t;return(0,s.kt)(j2,(0,p.Z)({},q2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Y2.isMDXComponent=!0;const Q2={toc:[]},H2="wrapper";function $2(t){let{components:n,...e}=t;return(0,s.kt)(H2,(0,p.Z)({},Q2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}$2.isMDXComponent=!0;const K2={toc:[]},J2="wrapper";function t6(t){let{components:n,...e}=t;return(0,s.kt)(J2,(0,p.Z)({},K2,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}t6.isMDXComponent=!0;const n6={toc:[]},e6="wrapper";function o6(t){let{components:n,...e}=t;return(0,s.kt)(e6,(0,p.Z)({},n6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}o6.isMDXComponent=!0;const p6={toc:[]},r6="wrapper";function s6(t){let{components:n,...e}=t;return(0,s.kt)(r6,(0,p.Z)({},p6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}s6.isMDXComponent=!0;const c6={toc:[]},i6="wrapper";function a6(t){let{components:n,...e}=t;return(0,s.kt)(i6,(0,p.Z)({},c6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}a6.isMDXComponent=!0;const l6={toc:[]},u6="wrapper";function m6(t){let{components:n,...e}=t;return(0,s.kt)(u6,(0,p.Z)({},l6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}m6.isMDXComponent=!0;const d6={toc:[]},h6="wrapper";function k6(t){let{components:n,...e}=t;return(0,s.kt)(h6,(0,p.Z)({},d6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}k6.isMDXComponent=!0;const f6={toc:[]},y6="wrapper";function M6(t){let{components:n,...e}=t;return(0,s.kt)(y6,(0,p.Z)({},f6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}M6.isMDXComponent=!0;const D6={toc:[]},X6="wrapper";function _6(t){let{components:n,...e}=t;return(0,s.kt)(X6,(0,p.Z)({},D6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}_6.isMDXComponent=!0;const w6={toc:[]},T6="wrapper";function C6(t){let{components:n,...e}=t;return(0,s.kt)(T6,(0,p.Z)({},w6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}C6.isMDXComponent=!0;const g6={toc:[]},x6="wrapper";function v6(t){let{components:n,...e}=t;return(0,s.kt)(x6,(0,p.Z)({},g6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}v6.isMDXComponent=!0;const L6={toc:[]},Z6="wrapper";function b6(t){let{components:n,...e}=t;return(0,s.kt)(Z6,(0,p.Z)({},L6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}b6.isMDXComponent=!0;const N6={toc:[]},A6="wrapper";function z6(t){let{components:n,...e}=t;return(0,s.kt)(A6,(0,p.Z)({},N6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}z6.isMDXComponent=!0;const W6={toc:[]},I6="wrapper";function R6(t){let{components:n,...e}=t;return(0,s.kt)(I6,(0,p.Z)({},W6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}R6.isMDXComponent=!0;const P6={toc:[]},S6="wrapper";function E6(t){let{components:n,...e}=t;return(0,s.kt)(S6,(0,p.Z)({},P6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}E6.isMDXComponent=!0;const G6={toc:[]},O6="wrapper";function F6(t){let{components:n,...e}=t;return(0,s.kt)(O6,(0,p.Z)({},G6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}F6.isMDXComponent=!0;const B6={toc:[]},U6="wrapper";function V6(t){let{components:n,...e}=t;return(0,s.kt)(U6,(0,p.Z)({},B6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}V6.isMDXComponent=!0;const q6={toc:[]},j6="wrapper";function Y6(t){let{components:n,...e}=t;return(0,s.kt)(j6,(0,p.Z)({},q6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Y6.isMDXComponent=!0;const Q6={toc:[]},H6="wrapper";function $6(t){let{components:n,...e}=t;return(0,s.kt)(H6,(0,p.Z)({},Q6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}$6.isMDXComponent=!0;const K6={toc:[]},J6="wrapper";function t3(t){let{components:n,...e}=t;return(0,s.kt)(J6,(0,p.Z)({},K6,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}t3.isMDXComponent=!0;const n3={toc:[]},e3="wrapper";function o3(t){let{components:n,...e}=t;return(0,s.kt)(e3,(0,p.Z)({},n3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}o3.isMDXComponent=!0;const p3={toc:[]},r3="wrapper";function s3(t){let{components:n,...e}=t;return(0,s.kt)(r3,(0,p.Z)({},p3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}s3.isMDXComponent=!0;const c3={toc:[]},i3="wrapper";function a3(t){let{components:n,...e}=t;return(0,s.kt)(i3,(0,p.Z)({},c3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}a3.isMDXComponent=!0;const l3={toc:[]},u3="wrapper";function m3(t){let{components:n,...e}=t;return(0,s.kt)(u3,(0,p.Z)({},l3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}m3.isMDXComponent=!0;const d3={toc:[]},h3="wrapper";function k3(t){let{components:n,...e}=t;return(0,s.kt)(h3,(0,p.Z)({},d3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}k3.isMDXComponent=!0;const f3={toc:[]},y3="wrapper";function M3(t){let{components:n,...e}=t;return(0,s.kt)(y3,(0,p.Z)({},f3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}M3.isMDXComponent=!0;const D3={toc:[]},X3="wrapper";function _3(t){let{components:n,...e}=t;return(0,s.kt)(X3,(0,p.Z)({},D3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}_3.isMDXComponent=!0;const w3={toc:[]},T3="wrapper";function C3(t){let{components:n,...e}=t;return(0,s.kt)(T3,(0,p.Z)({},w3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}C3.isMDXComponent=!0;const g3={toc:[]},x3="wrapper";function v3(t){let{components:n,...e}=t;return(0,s.kt)(x3,(0,p.Z)({},g3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}v3.isMDXComponent=!0;const L3={toc:[]},Z3="wrapper";function b3(t){let{components:n,...e}=t;return(0,s.kt)(Z3,(0,p.Z)({},L3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}b3.isMDXComponent=!0;const N3={toc:[]},A3="wrapper";function z3(t){let{components:n,...e}=t;return(0,s.kt)(A3,(0,p.Z)({},N3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}z3.isMDXComponent=!0;const W3={toc:[]},I3="wrapper";function R3(t){let{components:n,...e}=t;return(0,s.kt)(I3,(0,p.Z)({},W3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}R3.isMDXComponent=!0;const P3={toc:[]},S3="wrapper";function E3(t){let{components:n,...e}=t;return(0,s.kt)(S3,(0,p.Z)({},P3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}E3.isMDXComponent=!0;const G3={toc:[]},O3="wrapper";function F3(t){let{components:n,...e}=t;return(0,s.kt)(O3,(0,p.Z)({},G3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}F3.isMDXComponent=!0;const B3={toc:[]},U3="wrapper";function V3(t){let{components:n,...e}=t;return(0,s.kt)(U3,(0,p.Z)({},B3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}V3.isMDXComponent=!0;const q3={toc:[]},j3="wrapper";function Y3(t){let{components:n,...e}=t;return(0,s.kt)(j3,(0,p.Z)({},q3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Y3.isMDXComponent=!0;const Q3={toc:[]},H3="wrapper";function $3(t){let{components:n,...e}=t;return(0,s.kt)(H3,(0,p.Z)({},Q3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}$3.isMDXComponent=!0;const K3={toc:[]},J3="wrapper";function t5(t){let{components:n,...e}=t;return(0,s.kt)(J3,(0,p.Z)({},K3,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}t5.isMDXComponent=!0;const n5={toc:[]},e5="wrapper";function o5(t){let{components:n,...e}=t;return(0,s.kt)(e5,(0,p.Z)({},n5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}o5.isMDXComponent=!0;const p5={toc:[]},r5="wrapper";function s5(t){let{components:n,...e}=t;return(0,s.kt)(r5,(0,p.Z)({},p5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}s5.isMDXComponent=!0;const c5={toc:[]},i5="wrapper";function a5(t){let{components:n,...e}=t;return(0,s.kt)(i5,(0,p.Z)({},c5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}a5.isMDXComponent=!0;const l5={toc:[]},u5="wrapper";function m5(t){let{components:n,...e}=t;return(0,s.kt)(u5,(0,p.Z)({},l5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}m5.isMDXComponent=!0;const d5={toc:[]},h5="wrapper";function k5(t){let{components:n,...e}=t;return(0,s.kt)(h5,(0,p.Z)({},d5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}k5.isMDXComponent=!0;const f5={toc:[]},y5="wrapper";function M5(t){let{components:n,...e}=t;return(0,s.kt)(y5,(0,p.Z)({},f5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}M5.isMDXComponent=!0;const D5={toc:[]},X5="wrapper";function _5(t){let{components:n,...e}=t;return(0,s.kt)(X5,(0,p.Z)({},D5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}_5.isMDXComponent=!0;const w5={toc:[]},T5="wrapper";function C5(t){let{components:n,...e}=t;return(0,s.kt)(T5,(0,p.Z)({},w5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}C5.isMDXComponent=!0;const g5={toc:[]},x5="wrapper";function v5(t){let{components:n,...e}=t;return(0,s.kt)(x5,(0,p.Z)({},g5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}v5.isMDXComponent=!0;const L5={toc:[]},Z5="wrapper";function b5(t){let{components:n,...e}=t;return(0,s.kt)(Z5,(0,p.Z)({},L5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}b5.isMDXComponent=!0;const N5={toc:[]},A5="wrapper";function z5(t){let{components:n,...e}=t;return(0,s.kt)(A5,(0,p.Z)({},N5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}z5.isMDXComponent=!0;const W5={toc:[]},I5="wrapper";function R5(t){let{components:n,...e}=t;return(0,s.kt)(I5,(0,p.Z)({},W5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}R5.isMDXComponent=!0;const P5={toc:[]},S5="wrapper";function E5(t){let{components:n,...e}=t;return(0,s.kt)(S5,(0,p.Z)({},P5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}E5.isMDXComponent=!0;const G5={toc:[]},O5="wrapper";function F5(t){let{components:n,...e}=t;return(0,s.kt)(O5,(0,p.Z)({},G5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}F5.isMDXComponent=!0;const B5={toc:[]},U5="wrapper";function V5(t){let{components:n,...e}=t;return(0,s.kt)(U5,(0,p.Z)({},B5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}V5.isMDXComponent=!0;const q5={toc:[]},j5="wrapper";function Y5(t){let{components:n,...e}=t;return(0,s.kt)(j5,(0,p.Z)({},q5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Y5.isMDXComponent=!0;const Q5={toc:[]},H5="wrapper";function $5(t){let{components:n,...e}=t;return(0,s.kt)(H5,(0,p.Z)({},Q5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}$5.isMDXComponent=!0;const K5={toc:[]},J5="wrapper";function t1(t){let{components:n,...e}=t;return(0,s.kt)(J5,(0,p.Z)({},K5,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}t1.isMDXComponent=!0;const n1={toc:[]},e1="wrapper";function o1(t){let{components:n,...e}=t;return(0,s.kt)(e1,(0,p.Z)({},n1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}o1.isMDXComponent=!0;const p1={toc:[]},r1="wrapper";function s1(t){let{components:n,...e}=t;return(0,s.kt)(r1,(0,p.Z)({},p1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}s1.isMDXComponent=!0;const c1={toc:[]},i1="wrapper";function a1(t){let{components:n,...e}=t;return(0,s.kt)(i1,(0,p.Z)({},c1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}a1.isMDXComponent=!0;const l1={toc:[]},u1="wrapper";function m1(t){let{components:n,...e}=t;return(0,s.kt)(u1,(0,p.Z)({},l1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}m1.isMDXComponent=!0;const d1={toc:[]},h1="wrapper";function k1(t){let{components:n,...e}=t;return(0,s.kt)(h1,(0,p.Z)({},d1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}k1.isMDXComponent=!0;const f1={toc:[]},y1="wrapper";function M1(t){let{components:n,...e}=t;return(0,s.kt)(y1,(0,p.Z)({},f1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}M1.isMDXComponent=!0;const D1={toc:[]},X1="wrapper";function _1(t){let{components:n,...e}=t;return(0,s.kt)(X1,(0,p.Z)({},D1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}_1.isMDXComponent=!0;const w1={toc:[]},T1="wrapper";function C1(t){let{components:n,...e}=t;return(0,s.kt)(T1,(0,p.Z)({},w1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}C1.isMDXComponent=!0;const g1={toc:[]},x1="wrapper";function v1(t){let{components:n,...e}=t;return(0,s.kt)(x1,(0,p.Z)({},g1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}v1.isMDXComponent=!0;const L1={toc:[]},Z1="wrapper";function b1(t){let{components:n,...e}=t;return(0,s.kt)(Z1,(0,p.Z)({},L1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}b1.isMDXComponent=!0;const N1={toc:[]},A1="wrapper";function z1(t){let{components:n,...e}=t;return(0,s.kt)(A1,(0,p.Z)({},N1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}z1.isMDXComponent=!0;const W1={toc:[]},I1="wrapper";function R1(t){let{components:n,...e}=t;return(0,s.kt)(I1,(0,p.Z)({},W1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}R1.isMDXComponent=!0;const P1={toc:[]},S1="wrapper";function E1(t){let{components:n,...e}=t;return(0,s.kt)(S1,(0,p.Z)({},P1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}E1.isMDXComponent=!0;const G1={toc:[]},O1="wrapper";function F1(t){let{components:n,...e}=t;return(0,s.kt)(O1,(0,p.Z)({},G1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}F1.isMDXComponent=!0;const B1={toc:[]},U1="wrapper";function V1(t){let{components:n,...e}=t;return(0,s.kt)(U1,(0,p.Z)({},B1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}V1.isMDXComponent=!0;const q1={toc:[]},j1="wrapper";function Y1(t){let{components:n,...e}=t;return(0,s.kt)(j1,(0,p.Z)({},q1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Y1.isMDXComponent=!0;const Q1={toc:[]},H1="wrapper";function $1(t){let{components:n,...e}=t;return(0,s.kt)(H1,(0,p.Z)({},Q1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}$1.isMDXComponent=!0;const K1={toc:[]},J1="wrapper";function t4(t){let{components:n,...e}=t;return(0,s.kt)(J1,(0,p.Z)({},K1,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}t4.isMDXComponent=!0;const n4={toc:[]},e4="wrapper";function o4(t){let{components:n,...e}=t;return(0,s.kt)(e4,(0,p.Z)({},n4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}o4.isMDXComponent=!0;const p4={toc:[]},r4="wrapper";function s4(t){let{components:n,...e}=t;return(0,s.kt)(r4,(0,p.Z)({},p4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}s4.isMDXComponent=!0;const c4={toc:[]},i4="wrapper";function a4(t){let{components:n,...e}=t;return(0,s.kt)(i4,(0,p.Z)({},c4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}a4.isMDXComponent=!0;const l4={toc:[]},u4="wrapper";function m4(t){let{components:n,...e}=t;return(0,s.kt)(u4,(0,p.Z)({},l4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}m4.isMDXComponent=!0;const d4={toc:[]},h4="wrapper";function k4(t){let{components:n,...e}=t;return(0,s.kt)(h4,(0,p.Z)({},d4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}k4.isMDXComponent=!0;const f4={toc:[]},y4="wrapper";function M4(t){let{components:n,...e}=t;return(0,s.kt)(y4,(0,p.Z)({},f4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}M4.isMDXComponent=!0;const D4={toc:[]},X4="wrapper";function _4(t){let{components:n,...e}=t;return(0,s.kt)(X4,(0,p.Z)({},D4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}_4.isMDXComponent=!0;const w4={toc:[]},T4="wrapper";function C4(t){let{components:n,...e}=t;return(0,s.kt)(T4,(0,p.Z)({},w4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}C4.isMDXComponent=!0;const g4={toc:[]},x4="wrapper";function v4(t){let{components:n,...e}=t;return(0,s.kt)(x4,(0,p.Z)({},g4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}v4.isMDXComponent=!0;const L4={toc:[]},Z4="wrapper";function b4(t){let{components:n,...e}=t;return(0,s.kt)(Z4,(0,p.Z)({},L4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}b4.isMDXComponent=!0;const N4={toc:[]},A4="wrapper";function z4(t){let{components:n,...e}=t;return(0,s.kt)(A4,(0,p.Z)({},N4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}z4.isMDXComponent=!0;const W4={toc:[]},I4="wrapper";function R4(t){let{components:n,...e}=t;return(0,s.kt)(I4,(0,p.Z)({},W4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}R4.isMDXComponent=!0;const P4={toc:[]},S4="wrapper";function E4(t){let{components:n,...e}=t;return(0,s.kt)(S4,(0,p.Z)({},P4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}E4.isMDXComponent=!0;const G4={toc:[]},O4="wrapper";function F4(t){let{components:n,...e}=t;return(0,s.kt)(O4,(0,p.Z)({},G4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}F4.isMDXComponent=!0;const B4={toc:[]},U4="wrapper";function V4(t){let{components:n,...e}=t;return(0,s.kt)(U4,(0,p.Z)({},B4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}V4.isMDXComponent=!0;const q4={toc:[]},j4="wrapper";function Y4(t){let{components:n,...e}=t;return(0,s.kt)(j4,(0,p.Z)({},q4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Y4.isMDXComponent=!0;const Q4={toc:[]},H4="wrapper";function $4(t){let{components:n,...e}=t;return(0,s.kt)(H4,(0,p.Z)({},Q4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}$4.isMDXComponent=!0;const K4={toc:[]},J4="wrapper";function t8(t){let{components:n,...e}=t;return(0,s.kt)(J4,(0,p.Z)({},K4,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}t8.isMDXComponent=!0;const n8={toc:[]},e8="wrapper";function o8(t){let{components:n,...e}=t;return(0,s.kt)(e8,(0,p.Z)({},n8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}o8.isMDXComponent=!0;const p8={toc:[]},r8="wrapper";function s8(t){let{components:n,...e}=t;return(0,s.kt)(r8,(0,p.Z)({},p8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}s8.isMDXComponent=!0;const c8={toc:[]},i8="wrapper";function a8(t){let{components:n,...e}=t;return(0,s.kt)(i8,(0,p.Z)({},c8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}a8.isMDXComponent=!0;const l8={toc:[]},u8="wrapper";function m8(t){let{components:n,...e}=t;return(0,s.kt)(u8,(0,p.Z)({},l8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}m8.isMDXComponent=!0;const d8={toc:[]},h8="wrapper";function k8(t){let{components:n,...e}=t;return(0,s.kt)(h8,(0,p.Z)({},d8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}k8.isMDXComponent=!0;const f8={toc:[]},y8="wrapper";function M8(t){let{components:n,...e}=t;return(0,s.kt)(y8,(0,p.Z)({},f8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}M8.isMDXComponent=!0;const D8={toc:[]},X8="wrapper";function _8(t){let{components:n,...e}=t;return(0,s.kt)(X8,(0,p.Z)({},D8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}_8.isMDXComponent=!0;const w8={toc:[]},T8="wrapper";function C8(t){let{components:n,...e}=t;return(0,s.kt)(T8,(0,p.Z)({},w8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}C8.isMDXComponent=!0;const g8={toc:[]},x8="wrapper";function v8(t){let{components:n,...e}=t;return(0,s.kt)(x8,(0,p.Z)({},g8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}v8.isMDXComponent=!0;const L8={toc:[]},Z8="wrapper";function b8(t){let{components:n,...e}=t;return(0,s.kt)(Z8,(0,p.Z)({},L8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}b8.isMDXComponent=!0;const N8={toc:[]},A8="wrapper";function z8(t){let{components:n,...e}=t;return(0,s.kt)(A8,(0,p.Z)({},N8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}z8.isMDXComponent=!0;const W8={toc:[]},I8="wrapper";function R8(t){let{components:n,...e}=t;return(0,s.kt)(I8,(0,p.Z)({},W8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}R8.isMDXComponent=!0;const P8={toc:[]},S8="wrapper";function E8(t){let{components:n,...e}=t;return(0,s.kt)(S8,(0,p.Z)({},P8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}E8.isMDXComponent=!0;const G8={toc:[]},O8="wrapper";function F8(t){let{components:n,...e}=t;return(0,s.kt)(O8,(0,p.Z)({},G8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}F8.isMDXComponent=!0;const B8={toc:[]},U8="wrapper";function V8(t){let{components:n,...e}=t;return(0,s.kt)(U8,(0,p.Z)({},B8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}V8.isMDXComponent=!0;const q8={toc:[]},j8="wrapper";function Y8(t){let{components:n,...e}=t;return(0,s.kt)(j8,(0,p.Z)({},q8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}Y8.isMDXComponent=!0;const Q8={toc:[]},H8="wrapper";function $8(t){let{components:n,...e}=t;return(0,s.kt)(H8,(0,p.Z)({},Q8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n\n// snippet Curve properties:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {all, createRef, easeInCubic, easeOutCubic} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      endAngle={270}\n      endArrow\n    />,\n  );\n\n  yield* all(ref().start(1, 1), ref().rotation(180, 1, easeInCubic));\n  ref().start(0).end(0);\n  yield* all(ref().end(1, 1), ref().rotation(360, 1, easeOutCubic));\n});\n")))}$8.isMDXComponent=!0;const K8={toc:[]},J8="wrapper";function t7(t){let{components:n,...e}=t;return(0,s.kt)(J8,(0,p.Z)({},K8,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing circular shapes."))}t7.isMDXComponent=!0;const n7={toc:[]},e7="wrapper";function o7(t){let{components:n,...e}=t;return(0,s.kt)(e7,(0,p.Z)({},n7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}o7.isMDXComponent=!0;const p7={toc:[]},r7="wrapper";function s7(t){let{components:n,...e}=t;return(0,s.kt)(r7,(0,p.Z)({},p7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}s7.isMDXComponent=!0;const c7={toc:[]},i7="wrapper";function a7(t){let{components:n,...e}=t;return(0,s.kt)(i7,(0,p.Z)({},c7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}a7.isMDXComponent=!0;const l7={toc:[]},u7="wrapper";function m7(t){let{components:n,...e}=t;return(0,s.kt)(u7,(0,p.Z)({},l7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}m7.isMDXComponent=!0;const d7={toc:[]},h7="wrapper";function k7(t){let{components:n,...e}=t;return(0,s.kt)(h7,(0,p.Z)({},d7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}k7.isMDXComponent=!0;const f7={toc:[]},y7="wrapper";function M7(t){let{components:n,...e}=t;return(0,s.kt)(y7,(0,p.Z)({},f7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}M7.isMDXComponent=!0;const D7={toc:[]},X7="wrapper";function _7(t){let{components:n,...e}=t;return(0,s.kt)(X7,(0,p.Z)({},D7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}_7.isMDXComponent=!0;const w7={toc:[]},T7="wrapper";function C7(t){let{components:n,...e}=t;return(0,s.kt)(T7,(0,p.Z)({},w7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}C7.isMDXComponent=!0;const g7={toc:[]},x7="wrapper";function v7(t){let{components:n,...e}=t;return(0,s.kt)(x7,(0,p.Z)({},g7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}v7.isMDXComponent=!0;const L7={toc:[]},Z7="wrapper";function b7(t){let{components:n,...e}=t;return(0,s.kt)(Z7,(0,p.Z)({},L7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}b7.isMDXComponent=!0;const N7={toc:[]},A7="wrapper";function z7(t){let{components:n,...e}=t;return(0,s.kt)(A7,(0,p.Z)({},N7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}z7.isMDXComponent=!0;const W7={toc:[]},I7="wrapper";function R7(t){let{components:n,...e}=t;return(0,s.kt)(I7,(0,p.Z)({},W7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}R7.isMDXComponent=!0;const P7={toc:[]},S7="wrapper";function E7(t){let{components:n,...e}=t;return(0,s.kt)(S7,(0,p.Z)({},P7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}E7.isMDXComponent=!0;const G7={toc:[]},O7="wrapper";function F7(t){let{components:n,...e}=t;return(0,s.kt)(O7,(0,p.Z)({},G7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}F7.isMDXComponent=!0;const B7={toc:[]},U7="wrapper";function V7(t){let{components:n,...e}=t;return(0,s.kt)(U7,(0,p.Z)({},B7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}V7.isMDXComponent=!0;const q7={toc:[]},j7="wrapper";function Y7(t){let{components:n,...e}=t;return(0,s.kt)(j7,(0,p.Z)({},q7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A closed circle will look like a pie chart:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.kt)("p",null,"An open one will look like an arc:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}Y7.isMDXComponent=!0;const Q7={toc:[]},H7="wrapper";function $7(t){let{components:n,...e}=t;return(0,s.kt)(H7,(0,p.Z)({},Q7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"false"))}$7.isMDXComponent=!0;const K7={toc:[]},J7="wrapper";function t9(t){let{components:n,...e}=t;return(0,s.kt)(J7,(0,p.Z)({},K7,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}t9.isMDXComponent=!0;const n9={toc:[]},e9="wrapper";function o9(t){let{components:n,...e}=t;return(0,s.kt)(e9,(0,p.Z)({},n9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the circle begins at ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}o9.isMDXComponent=!0;const p9={toc:[]},r9="wrapper";function s9(t){let{components:n,...e}=t;return(0,s.kt)(r9,(0,p.Z)({},p9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the circle sector should be drawn counterclockwise."))}s9.isMDXComponent=!0;const c9={toc:[]},i9="wrapper";function a9(t){let{components:n,...e}=t;return(0,s.kt)(i9,(0,p.Z)({},c9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}a9.isMDXComponent=!0;const l9={toc:[]},u9="wrapper";function m9(t){let{components:n,...e}=t;return(0,s.kt)(u9,(0,p.Z)({},l9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}m9.isMDXComponent=!0;const d9={toc:[]},h9="wrapper";function k9(t){let{components:n,...e}=t;return(0,s.kt)(h9,(0,p.Z)({},d9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}k9.isMDXComponent=!0;const f9={toc:[]},y9="wrapper";function M9(t){let{components:n,...e}=t;return(0,s.kt)(y9,(0,p.Z)({},f9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"360"))}M9.isMDXComponent=!0;const D9={toc:[]},X9="wrapper";function _9(t){let{components:n,...e}=t;return(0,s.kt)(X9,(0,p.Z)({},D9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}_9.isMDXComponent=!0;const w9={toc:[]},T9="wrapper";function C9(t){let{components:n,...e}=t;return(0,s.kt)(T9,(0,p.Z)({},w9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}C9.isMDXComponent=!0;const g9={toc:[]},x9="wrapper";function v9(t){let{components:n,...e}=t;return(0,s.kt)(x9,(0,p.Z)({},g9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}v9.isMDXComponent=!0;const L9={toc:[]},Z9="wrapper";function b9(t){let{components:n,...e}=t;return(0,s.kt)(Z9,(0,p.Z)({},L9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}b9.isMDXComponent=!0;const N9={toc:[]},A9="wrapper";function z9(t){let{components:n,...e}=t;return(0,s.kt)(A9,(0,p.Z)({},N9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}z9.isMDXComponent=!0;const W9={toc:[]},I9="wrapper";function R9(t){let{components:n,...e}=t;return(0,s.kt)(I9,(0,p.Z)({},W9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}R9.isMDXComponent=!0;const P9={toc:[]},S9="wrapper";function E9(t){let{components:n,...e}=t;return(0,s.kt)(S9,(0,p.Z)({},P9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}E9.isMDXComponent=!0;const G9={toc:[]},O9="wrapper";function F9(t){let{components:n,...e}=t;return(0,s.kt)(O9,(0,p.Z)({},G9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}F9.isMDXComponent=!0;const B9={toc:[]},U9="wrapper";function V9(t){let{components:n,...e}=t;return(0,s.kt)(U9,(0,p.Z)({},B9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}V9.isMDXComponent=!0;const q9={toc:[]},j9="wrapper";function Y9(t){let{components:n,...e}=t;return(0,s.kt)(j9,(0,p.Z)({},q9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Y9.isMDXComponent=!0;const Q9={toc:[]},H9="wrapper";function $9(t){let{components:n,...e}=t;return(0,s.kt)(H9,(0,p.Z)({},Q9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}$9.isMDXComponent=!0;const K9={toc:[]},J9="wrapper";function ttt(t){let{components:n,...e}=t;return(0,s.kt)(J9,(0,p.Z)({},K9,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}ttt.isMDXComponent=!0;const ntt={toc:[]},ett="wrapper";function ott(t){let{components:n,...e}=t;return(0,s.kt)(ett,(0,p.Z)({},ntt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}ott.isMDXComponent=!0;const ptt={toc:[]},rtt="wrapper";function stt(t){let{components:n,...e}=t;return(0,s.kt)(rtt,(0,p.Z)({},ptt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}stt.isMDXComponent=!0;const ctt={toc:[]},itt="wrapper";function att(t){let{components:n,...e}=t;return(0,s.kt)(itt,(0,p.Z)({},ctt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}att.isMDXComponent=!0;const ltt={toc:[]},utt="wrapper";function mtt(t){let{components:n,...e}=t;return(0,s.kt)(utt,(0,p.Z)({},ltt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}mtt.isMDXComponent=!0;const dtt={toc:[]},htt="wrapper";function ktt(t){let{components:n,...e}=t;return(0,s.kt)(htt,(0,p.Z)({},dtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}ktt.isMDXComponent=!0;const ftt={toc:[]},ytt="wrapper";function Mtt(t){let{components:n,...e}=t;return(0,s.kt)(ytt,(0,p.Z)({},ftt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Mtt.isMDXComponent=!0;const Dtt={toc:[]},Xtt="wrapper";function _tt(t){let{components:n,...e}=t;return(0,s.kt)(Xtt,(0,p.Z)({},Dtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}_tt.isMDXComponent=!0;const wtt={toc:[]},Ttt="wrapper";function Ctt(t){let{components:n,...e}=t;return(0,s.kt)(Ttt,(0,p.Z)({},wtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Ctt.isMDXComponent=!0;const gtt={toc:[]},xtt="wrapper";function vtt(t){let{components:n,...e}=t;return(0,s.kt)(xtt,(0,p.Z)({},gtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}vtt.isMDXComponent=!0;const Ltt={toc:[]},Ztt="wrapper";function btt(t){let{components:n,...e}=t;return(0,s.kt)(Ztt,(0,p.Z)({},Ltt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}btt.isMDXComponent=!0;const Ntt={toc:[]},Att="wrapper";function ztt(t){let{components:n,...e}=t;return(0,s.kt)(Att,(0,p.Z)({},Ntt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}ztt.isMDXComponent=!0;const Wtt={toc:[]},Itt="wrapper";function Rtt(t){let{components:n,...e}=t;return(0,s.kt)(Itt,(0,p.Z)({},Wtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Rtt.isMDXComponent=!0;const Ptt={toc:[]},Stt="wrapper";function Ett(t){let{components:n,...e}=t;return(0,s.kt)(Stt,(0,p.Z)({},Ptt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Ett.isMDXComponent=!0;const Gtt={toc:[]},Ott="wrapper";function Ftt(t){let{components:n,...e}=t;return(0,s.kt)(Ott,(0,p.Z)({},Gtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Ftt.isMDXComponent=!0;const Btt={toc:[]},Utt="wrapper";function Vtt(t){let{components:n,...e}=t;return(0,s.kt)(Utt,(0,p.Z)({},Btt,e,{components:n,mdxType:"MDXLayout"}))}Vtt.isMDXComponent=!0;const qtt={toc:[]},jtt="wrapper";function Ytt(t){let{components:n,...e}=t;return(0,s.kt)(jtt,(0,p.Z)({},qtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ytt.isMDXComponent=!0;const Qtt={toc:[]},Htt="wrapper";function $tt(t){let{components:n,...e}=t;return(0,s.kt)(Htt,(0,p.Z)({},Qtt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}$tt.isMDXComponent=!0;const Ktt={toc:[]},Jtt="wrapper";function tnt(t){let{components:n,...e}=t;return(0,s.kt)(Jtt,(0,p.Z)({},Ktt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}tnt.isMDXComponent=!0;const nnt={toc:[]},ent="wrapper";function ont(t){let{components:n,...e}=t;return(0,s.kt)(ent,(0,p.Z)({},nnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}ont.isMDXComponent=!0;const pnt={toc:[]},rnt="wrapper";function snt(t){let{components:n,...e}=t;return(0,s.kt)(rnt,(0,p.Z)({},pnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}snt.isMDXComponent=!0;const cnt={toc:[]},int="wrapper";function ant(t){let{components:n,...e}=t;return(0,s.kt)(int,(0,p.Z)({},cnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ant.isMDXComponent=!0;const lnt={toc:[]},unt="wrapper";function mnt(t){let{components:n,...e}=t;return(0,s.kt)(unt,(0,p.Z)({},lnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}mnt.isMDXComponent=!0;const dnt={toc:[]},hnt="wrapper";function knt(t){let{components:n,...e}=t;return(0,s.kt)(hnt,(0,p.Z)({},dnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}knt.isMDXComponent=!0;const fnt={toc:[]},ynt="wrapper";function Mnt(t){let{components:n,...e}=t;return(0,s.kt)(ynt,(0,p.Z)({},fnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Mnt.isMDXComponent=!0;const Dnt={toc:[]},Xnt="wrapper";function _nt(t){let{components:n,...e}=t;return(0,s.kt)(Xnt,(0,p.Z)({},Dnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}_nt.isMDXComponent=!0;const wnt={toc:[]},Tnt="wrapper";function Cnt(t){let{components:n,...e}=t;return(0,s.kt)(Tnt,(0,p.Z)({},wnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Cnt.isMDXComponent=!0;const gnt={toc:[]},xnt="wrapper";function vnt(t){let{components:n,...e}=t;return(0,s.kt)(xnt,(0,p.Z)({},gnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}vnt.isMDXComponent=!0;const Lnt={toc:[]},Znt="wrapper";function bnt(t){let{components:n,...e}=t;return(0,s.kt)(Znt,(0,p.Z)({},Lnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}bnt.isMDXComponent=!0;const Nnt={toc:[]},Ant="wrapper";function znt(t){let{components:n,...e}=t;return(0,s.kt)(Ant,(0,p.Z)({},Nnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}znt.isMDXComponent=!0;const Wnt={toc:[]},Int="wrapper";function Rnt(t){let{components:n,...e}=t;return(0,s.kt)(Int,(0,p.Z)({},Wnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Rnt.isMDXComponent=!0;const Pnt={toc:[]},Snt="wrapper";function Ent(t){let{components:n,...e}=t;return(0,s.kt)(Snt,(0,p.Z)({},Pnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Ent.isMDXComponent=!0;const Gnt={toc:[]},Ont="wrapper";function Fnt(t){let{components:n,...e}=t;return(0,s.kt)(Ont,(0,p.Z)({},Gnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Fnt.isMDXComponent=!0;const Bnt={toc:[]},Unt="wrapper";function Vnt(t){let{components:n,...e}=t;return(0,s.kt)(Unt,(0,p.Z)({},Bnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Vnt.isMDXComponent=!0;const qnt={toc:[]},jnt="wrapper";function Ynt(t){let{components:n,...e}=t;return(0,s.kt)(jnt,(0,p.Z)({},qnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Ynt.isMDXComponent=!0;const Qnt={toc:[]},Hnt="wrapper";function $nt(t){let{components:n,...e}=t;return(0,s.kt)(Hnt,(0,p.Z)({},Qnt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}$nt.isMDXComponent=!0;const Knt={toc:[]},Jnt="wrapper";function tet(t){let{components:n,...e}=t;return(0,s.kt)(Jnt,(0,p.Z)({},Knt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}tet.isMDXComponent=!0;const net={toc:[]},eet="wrapper";function oet(t){let{components:n,...e}=t;return(0,s.kt)(eet,(0,p.Z)({},net,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}oet.isMDXComponent=!0;const pet={toc:[]},ret="wrapper";function set(t){let{components:n,...e}=t;return(0,s.kt)(ret,(0,p.Z)({},pet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}set.isMDXComponent=!0;const cet={toc:[]},iet="wrapper";function aet(t){let{components:n,...e}=t;return(0,s.kt)(iet,(0,p.Z)({},cet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}aet.isMDXComponent=!0;const uet={toc:[]},met="wrapper";function det(t){let{components:n,...e}=t;return(0,s.kt)(met,(0,p.Z)({},uet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}det.isMDXComponent=!0;const het={toc:[]},ket="wrapper";function fet(t){let{components:n,...e}=t;return(0,s.kt)(ket,(0,p.Z)({},het,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}fet.isMDXComponent=!0;const yet={toc:[]},Met="wrapper";function Det(t){let{components:n,...e}=t;return(0,s.kt)(Met,(0,p.Z)({},yet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Det.isMDXComponent=!0;const Xet={toc:[]},_et="wrapper";function wet(t){let{components:n,...e}=t;return(0,s.kt)(_et,(0,p.Z)({},Xet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}wet.isMDXComponent=!0;const Tet={toc:[]},Cet="wrapper";function get(t){let{components:n,...e}=t;return(0,s.kt)(Cet,(0,p.Z)({},Tet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}get.isMDXComponent=!0;const xet={toc:[]},vet="wrapper";function Let(t){let{components:n,...e}=t;return(0,s.kt)(vet,(0,p.Z)({},xet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Let.isMDXComponent=!0;const Zet={toc:[]},bet="wrapper";function Net(t){let{components:n,...e}=t;return(0,s.kt)(bet,(0,p.Z)({},Zet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Net.isMDXComponent=!0;const Aet={toc:[]},zet="wrapper";function Wet(t){let{components:n,...e}=t;return(0,s.kt)(zet,(0,p.Z)({},Aet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Wet.isMDXComponent=!0;const Iet={toc:[]},Ret="wrapper";function Pet(t){let{components:n,...e}=t;return(0,s.kt)(Ret,(0,p.Z)({},Iet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Pet.isMDXComponent=!0;const Set={toc:[]},Eet="wrapper";function Get(t){let{components:n,...e}=t;return(0,s.kt)(Eet,(0,p.Z)({},Set,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Get.isMDXComponent=!0;const Oet={toc:[]},Fet="wrapper";function Bet(t){let{components:n,...e}=t;return(0,s.kt)(Fet,(0,p.Z)({},Oet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Bet.isMDXComponent=!0;const Uet={toc:[]},Vet="wrapper";function qet(t){let{components:n,...e}=t;return(0,s.kt)(Vet,(0,p.Z)({},Uet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qet.isMDXComponent=!0;const jet={toc:[]},Yet="wrapper";function Qet(t){let{components:n,...e}=t;return(0,s.kt)(Yet,(0,p.Z)({},jet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Qet.isMDXComponent=!0;const Het={toc:[]},$et="wrapper";function Ket(t){let{components:n,...e}=t;return(0,s.kt)($et,(0,p.Z)({},Het,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Ket.isMDXComponent=!0;const Jet={toc:[]},tot="wrapper";function not(t){let{components:n,...e}=t;return(0,s.kt)(tot,(0,p.Z)({},Jet,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}not.isMDXComponent=!0;const eot={toc:[]},oot="wrapper";function pot(t){let{components:n,...e}=t;return(0,s.kt)(oot,(0,p.Z)({},eot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}pot.isMDXComponent=!0;const rot={toc:[]},sot="wrapper";function cot(t){let{components:n,...e}=t;return(0,s.kt)(sot,(0,p.Z)({},rot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}cot.isMDXComponent=!0;const iot={toc:[]},aot="wrapper";function lot(t){let{components:n,...e}=t;return(0,s.kt)(aot,(0,p.Z)({},iot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}lot.isMDXComponent=!0;const uot={toc:[]},mot="wrapper";function dot(t){let{components:n,...e}=t;return(0,s.kt)(mot,(0,p.Z)({},uot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}dot.isMDXComponent=!0;const hot={toc:[]},kot="wrapper";function fot(t){let{components:n,...e}=t;return(0,s.kt)(kot,(0,p.Z)({},hot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}fot.isMDXComponent=!0;const yot={toc:[]},Mot="wrapper";function Dot(t){let{components:n,...e}=t;return(0,s.kt)(Mot,(0,p.Z)({},yot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Dot.isMDXComponent=!0;const Xot={toc:[]},_ot="wrapper";function wot(t){let{components:n,...e}=t;return(0,s.kt)(_ot,(0,p.Z)({},Xot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}wot.isMDXComponent=!0;const Tot={toc:[]},Cot="wrapper";function got(t){let{components:n,...e}=t;return(0,s.kt)(Cot,(0,p.Z)({},Tot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}got.isMDXComponent=!0;const xot={toc:[]},vot="wrapper";function Lot(t){let{components:n,...e}=t;return(0,s.kt)(vot,(0,p.Z)({},xot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Lot.isMDXComponent=!0;const Zot={toc:[]},bot="wrapper";function Not(t){let{components:n,...e}=t;return(0,s.kt)(bot,(0,p.Z)({},Zot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Not.isMDXComponent=!0;const Aot={toc:[]},zot="wrapper";function Wot(t){let{components:n,...e}=t;return(0,s.kt)(zot,(0,p.Z)({},Aot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Wot.isMDXComponent=!0;const Iot={toc:[]},Rot="wrapper";function Pot(t){let{components:n,...e}=t;return(0,s.kt)(Rot,(0,p.Z)({},Iot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Pot.isMDXComponent=!0;const Sot={toc:[]},Eot="wrapper";function Got(t){let{components:n,...e}=t;return(0,s.kt)(Eot,(0,p.Z)({},Sot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Got.isMDXComponent=!0;const Oot={toc:[]},Fot="wrapper";function Bot(t){let{components:n,...e}=t;return(0,s.kt)(Fot,(0,p.Z)({},Oot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Bot.isMDXComponent=!0;const Uot={toc:[]},Vot="wrapper";function qot(t){let{components:n,...e}=t;return(0,s.kt)(Vot,(0,p.Z)({},Uot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qot.isMDXComponent=!0;const jot={toc:[]},Yot="wrapper";function Qot(t){let{components:n,...e}=t;return(0,s.kt)(Yot,(0,p.Z)({},jot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Qot.isMDXComponent=!0;const Hot={toc:[]},$ot="wrapper";function Kot(t){let{components:n,...e}=t;return(0,s.kt)($ot,(0,p.Z)({},Hot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Kot.isMDXComponent=!0;const Jot={toc:[]},tpt="wrapper";function npt(t){let{components:n,...e}=t;return(0,s.kt)(tpt,(0,p.Z)({},Jot,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}npt.isMDXComponent=!0;const ept={toc:[]},opt="wrapper";function ppt(t){let{components:n,...e}=t;return(0,s.kt)(opt,(0,p.Z)({},ept,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}ppt.isMDXComponent=!0;const rpt={toc:[]},spt="wrapper";function cpt(t){let{components:n,...e}=t;return(0,s.kt)(spt,(0,p.Z)({},rpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cpt.isMDXComponent=!0;const ipt={toc:[]},apt="wrapper";function lpt(t){let{components:n,...e}=t;return(0,s.kt)(apt,(0,p.Z)({},ipt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}lpt.isMDXComponent=!0;const upt={toc:[]},mpt="wrapper";function dpt(t){let{components:n,...e}=t;return(0,s.kt)(mpt,(0,p.Z)({},upt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dpt.isMDXComponent=!0;const hpt={toc:[]},kpt="wrapper";function fpt(t){let{components:n,...e}=t;return(0,s.kt)(kpt,(0,p.Z)({},hpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}fpt.isMDXComponent=!0;const ypt={toc:[]},Mpt="wrapper";function Dpt(t){let{components:n,...e}=t;return(0,s.kt)(Mpt,(0,p.Z)({},ypt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Dpt.isMDXComponent=!0;const Xpt={toc:[]},_pt="wrapper";function wpt(t){let{components:n,...e}=t;return(0,s.kt)(_pt,(0,p.Z)({},Xpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}wpt.isMDXComponent=!0;const Tpt={toc:[]},Cpt="wrapper";function gpt(t){let{components:n,...e}=t;return(0,s.kt)(Cpt,(0,p.Z)({},Tpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}gpt.isMDXComponent=!0;const xpt={toc:[]},vpt="wrapper";function Lpt(t){let{components:n,...e}=t;return(0,s.kt)(vpt,(0,p.Z)({},xpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Lpt.isMDXComponent=!0;const Zpt={toc:[]},bpt="wrapper";function Npt(t){let{components:n,...e}=t;return(0,s.kt)(bpt,(0,p.Z)({},Zpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Npt.isMDXComponent=!0;const Apt={toc:[]},zpt="wrapper";function Wpt(t){let{components:n,...e}=t;return(0,s.kt)(zpt,(0,p.Z)({},Apt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Wpt.isMDXComponent=!0;const Ipt={toc:[]},Rpt="wrapper";function Ppt(t){let{components:n,...e}=t;return(0,s.kt)(Rpt,(0,p.Z)({},Ipt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ppt.isMDXComponent=!0;const Spt={toc:[]},Ept="wrapper";function Gpt(t){let{components:n,...e}=t;return(0,s.kt)(Ept,(0,p.Z)({},Spt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Gpt.isMDXComponent=!0;const Opt={toc:[]},Fpt="wrapper";function Bpt(t){let{components:n,...e}=t;return(0,s.kt)(Fpt,(0,p.Z)({},Opt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Bpt.isMDXComponent=!0;const Upt={toc:[]},Vpt="wrapper";function qpt(t){let{components:n,...e}=t;return(0,s.kt)(Vpt,(0,p.Z)({},Upt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}qpt.isMDXComponent=!0;const jpt={toc:[]},Ypt="wrapper";function Qpt(t){let{components:n,...e}=t;return(0,s.kt)(Ypt,(0,p.Z)({},jpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Qpt.isMDXComponent=!0;const Hpt={toc:[]},$pt="wrapper";function Kpt(t){let{components:n,...e}=t;return(0,s.kt)($pt,(0,p.Z)({},Hpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Kpt.isMDXComponent=!0;const Jpt={toc:[]},trt="wrapper";function nrt(t){let{components:n,...e}=t;return(0,s.kt)(trt,(0,p.Z)({},Jpt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}nrt.isMDXComponent=!0;const ert={toc:[]},ort="wrapper";function prt(t){let{components:n,...e}=t;return(0,s.kt)(ort,(0,p.Z)({},ert,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}prt.isMDXComponent=!0;const rrt={toc:[]},srt="wrapper";function crt(t){let{components:n,...e}=t;return(0,s.kt)(srt,(0,p.Z)({},rrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}crt.isMDXComponent=!0;const irt={toc:[]},art="wrapper";function lrt(t){let{components:n,...e}=t;return(0,s.kt)(art,(0,p.Z)({},irt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}lrt.isMDXComponent=!0;const urt={toc:[]},mrt="wrapper";function drt(t){let{components:n,...e}=t;return(0,s.kt)(mrt,(0,p.Z)({},urt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}drt.isMDXComponent=!0;const hrt={toc:[]},krt="wrapper";function frt(t){let{components:n,...e}=t;return(0,s.kt)(krt,(0,p.Z)({},hrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}frt.isMDXComponent=!0;const yrt={toc:[]},Mrt="wrapper";function Drt(t){let{components:n,...e}=t;return(0,s.kt)(Mrt,(0,p.Z)({},yrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Drt.isMDXComponent=!0;const Xrt={toc:[]},_rt="wrapper";function wrt(t){let{components:n,...e}=t;return(0,s.kt)(_rt,(0,p.Z)({},Xrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}wrt.isMDXComponent=!0;const Trt={toc:[]},Crt="wrapper";function grt(t){let{components:n,...e}=t;return(0,s.kt)(Crt,(0,p.Z)({},Trt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}grt.isMDXComponent=!0;const xrt={toc:[]},vrt="wrapper";function Lrt(t){let{components:n,...e}=t;return(0,s.kt)(vrt,(0,p.Z)({},xrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Lrt.isMDXComponent=!0;const Zrt={toc:[]},brt="wrapper";function Nrt(t){let{components:n,...e}=t;return(0,s.kt)(brt,(0,p.Z)({},Zrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Nrt.isMDXComponent=!0;const Art={toc:[]},zrt="wrapper";function Wrt(t){let{components:n,...e}=t;return(0,s.kt)(zrt,(0,p.Z)({},Art,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Wrt.isMDXComponent=!0;const Irt={toc:[]},Rrt="wrapper";function Prt(t){let{components:n,...e}=t;return(0,s.kt)(Rrt,(0,p.Z)({},Irt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Prt.isMDXComponent=!0;const Srt={toc:[]},Ert="wrapper";function Grt(t){let{components:n,...e}=t;return(0,s.kt)(Ert,(0,p.Z)({},Srt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Grt.isMDXComponent=!0;const Ort={toc:[]},Frt="wrapper";function Brt(t){let{components:n,...e}=t;return(0,s.kt)(Frt,(0,p.Z)({},Ort,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Brt.isMDXComponent=!0;const Urt={toc:[]},Vrt="wrapper";function qrt(t){let{components:n,...e}=t;return(0,s.kt)(Vrt,(0,p.Z)({},Urt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}qrt.isMDXComponent=!0;const jrt={toc:[]},Yrt="wrapper";function Qrt(t){let{components:n,...e}=t;return(0,s.kt)(Yrt,(0,p.Z)({},jrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Qrt.isMDXComponent=!0;const Hrt={toc:[]},$rt="wrapper";function Krt(t){let{components:n,...e}=t;return(0,s.kt)($rt,(0,p.Z)({},Hrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Krt.isMDXComponent=!0;const Jrt={toc:[]},tst="wrapper";function nst(t){let{components:n,...e}=t;return(0,s.kt)(tst,(0,p.Z)({},Jrt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}nst.isMDXComponent=!0;const est={toc:[]},ost="wrapper";function pst(t){let{components:n,...e}=t;return(0,s.kt)(ost,(0,p.Z)({},est,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}pst.isMDXComponent=!0;const rst={toc:[]},sst="wrapper";function cst(t){let{components:n,...e}=t;return(0,s.kt)(sst,(0,p.Z)({},rst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}cst.isMDXComponent=!0;const ist={toc:[]},ast="wrapper";function lst(t){let{components:n,...e}=t;return(0,s.kt)(ast,(0,p.Z)({},ist,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}lst.isMDXComponent=!0;const ust={toc:[]},mst="wrapper";function dst(t){let{components:n,...e}=t;return(0,s.kt)(mst,(0,p.Z)({},ust,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}dst.isMDXComponent=!0;const hst={toc:[]},kst="wrapper";function fst(t){let{components:n,...e}=t;return(0,s.kt)(kst,(0,p.Z)({},hst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}fst.isMDXComponent=!0;const yst={toc:[]},Mst="wrapper";function Dst(t){let{components:n,...e}=t;return(0,s.kt)(Mst,(0,p.Z)({},yst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Dst.isMDXComponent=!0;const Xst={toc:[]},_st="wrapper";function wst(t){let{components:n,...e}=t;return(0,s.kt)(_st,(0,p.Z)({},Xst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}wst.isMDXComponent=!0;const Tst={toc:[]},Cst="wrapper";function gst(t){let{components:n,...e}=t;return(0,s.kt)(Cst,(0,p.Z)({},Tst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}gst.isMDXComponent=!0;const xst={toc:[]},vst="wrapper";function Lst(t){let{components:n,...e}=t;return(0,s.kt)(vst,(0,p.Z)({},xst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Lst.isMDXComponent=!0;const Zst={toc:[]},bst="wrapper";function Nst(t){let{components:n,...e}=t;return(0,s.kt)(bst,(0,p.Z)({},Zst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Nst.isMDXComponent=!0;const Ast={toc:[]},zst="wrapper";function Wst(t){let{components:n,...e}=t;return(0,s.kt)(zst,(0,p.Z)({},Ast,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Wst.isMDXComponent=!0;const Ist={toc:[]},Rst="wrapper";function Pst(t){let{components:n,...e}=t;return(0,s.kt)(Rst,(0,p.Z)({},Ist,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Pst.isMDXComponent=!0;const Sst={toc:[]},Est="wrapper";function Gst(t){let{components:n,...e}=t;return(0,s.kt)(Est,(0,p.Z)({},Sst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Gst.isMDXComponent=!0;const Ost={toc:[]},Fst="wrapper";function Bst(t){let{components:n,...e}=t;return(0,s.kt)(Fst,(0,p.Z)({},Ost,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Bst.isMDXComponent=!0;const Ust={toc:[]},Vst="wrapper";function qst(t){let{components:n,...e}=t;return(0,s.kt)(Vst,(0,p.Z)({},Ust,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}qst.isMDXComponent=!0;const jst={toc:[]},Yst="wrapper";function Qst(t){let{components:n,...e}=t;return(0,s.kt)(Yst,(0,p.Z)({},jst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Qst.isMDXComponent=!0;const Hst={toc:[]},$st="wrapper";function Kst(t){let{components:n,...e}=t;return(0,s.kt)($st,(0,p.Z)({},Hst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Kst.isMDXComponent=!0;const Jst={toc:[]},tct="wrapper";function nct(t){let{components:n,...e}=t;return(0,s.kt)(tct,(0,p.Z)({},Jst,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}nct.isMDXComponent=!0;const ect={toc:[]},oct="wrapper";function pct(t){let{components:n,...e}=t;return(0,s.kt)(oct,(0,p.Z)({},ect,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}pct.isMDXComponent=!0;const rct={toc:[]},sct="wrapper";function cct(t){let{components:n,...e}=t;return(0,s.kt)(sct,(0,p.Z)({},rct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}cct.isMDXComponent=!0;const ict={toc:[]},act="wrapper";function lct(t){let{components:n,...e}=t;return(0,s.kt)(act,(0,p.Z)({},ict,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}lct.isMDXComponent=!0;const uct={toc:[]},mct="wrapper";function dct(t){let{components:n,...e}=t;return(0,s.kt)(mct,(0,p.Z)({},uct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}dct.isMDXComponent=!0;const hct={toc:[]},kct="wrapper";function fct(t){let{components:n,...e}=t;return(0,s.kt)(kct,(0,p.Z)({},hct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}fct.isMDXComponent=!0;const yct={toc:[]},Mct="wrapper";function Dct(t){let{components:n,...e}=t;return(0,s.kt)(Mct,(0,p.Z)({},yct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Dct.isMDXComponent=!0;const Xct={toc:[]},_ct="wrapper";function wct(t){let{components:n,...e}=t;return(0,s.kt)(_ct,(0,p.Z)({},Xct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}wct.isMDXComponent=!0;const Tct={toc:[]},Cct="wrapper";function gct(t){let{components:n,...e}=t;return(0,s.kt)(Cct,(0,p.Z)({},Tct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}gct.isMDXComponent=!0;const xct={toc:[]},vct="wrapper";function Lct(t){let{components:n,...e}=t;return(0,s.kt)(vct,(0,p.Z)({},xct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Lct.isMDXComponent=!0;const Zct={toc:[]},bct="wrapper";function Nct(t){let{components:n,...e}=t;return(0,s.kt)(bct,(0,p.Z)({},Zct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Nct.isMDXComponent=!0;const Act={toc:[]},zct="wrapper";function Wct(t){let{components:n,...e}=t;return(0,s.kt)(zct,(0,p.Z)({},Act,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Wct.isMDXComponent=!0;const Ict={toc:[]},Rct="wrapper";function Pct(t){let{components:n,...e}=t;return(0,s.kt)(Rct,(0,p.Z)({},Ict,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Pct.isMDXComponent=!0;const Sct={toc:[]},Ect="wrapper";function Gct(t){let{components:n,...e}=t;return(0,s.kt)(Ect,(0,p.Z)({},Sct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Gct.isMDXComponent=!0;const Oct={toc:[]},Fct="wrapper";function Bct(t){let{components:n,...e}=t;return(0,s.kt)(Fct,(0,p.Z)({},Oct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Bct.isMDXComponent=!0;const Uct={toc:[]},Vct="wrapper";function qct(t){let{components:n,...e}=t;return(0,s.kt)(Vct,(0,p.Z)({},Uct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}qct.isMDXComponent=!0;const jct={toc:[]},Yct="wrapper";function Qct(t){let{components:n,...e}=t;return(0,s.kt)(Yct,(0,p.Z)({},jct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Qct.isMDXComponent=!0;const Hct={toc:[]},$ct="wrapper";function Kct(t){let{components:n,...e}=t;return(0,s.kt)($ct,(0,p.Z)({},Hct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Kct.isMDXComponent=!0;const Jct={toc:[]},tit="wrapper";function nit(t){let{components:n,...e}=t;return(0,s.kt)(tit,(0,p.Z)({},Jct,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}nit.isMDXComponent=!0;const eit={toc:[]},oit="wrapper";function pit(t){let{components:n,...e}=t;return(0,s.kt)(oit,(0,p.Z)({},eit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}pit.isMDXComponent=!0;const rit={toc:[]},sit="wrapper";function cit(t){let{components:n,...e}=t;return(0,s.kt)(sit,(0,p.Z)({},rit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}cit.isMDXComponent=!0;const iit={toc:[]},ait="wrapper";function lit(t){let{components:n,...e}=t;return(0,s.kt)(ait,(0,p.Z)({},iit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lit.isMDXComponent=!0;const uit={toc:[]},mit="wrapper";function dit(t){let{components:n,...e}=t;return(0,s.kt)(mit,(0,p.Z)({},uit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}dit.isMDXComponent=!0;const hit={toc:[]},kit="wrapper";function fit(t){let{components:n,...e}=t;return(0,s.kt)(kit,(0,p.Z)({},hit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}fit.isMDXComponent=!0;const yit={toc:[]},Mit="wrapper";function Dit(t){let{components:n,...e}=t;return(0,s.kt)(Mit,(0,p.Z)({},yit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Dit.isMDXComponent=!0;const Xit={toc:[]},_it="wrapper";function wit(t){let{components:n,...e}=t;return(0,s.kt)(_it,(0,p.Z)({},Xit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}wit.isMDXComponent=!0;const Tit={toc:[]},Cit="wrapper";function git(t){let{components:n,...e}=t;return(0,s.kt)(Cit,(0,p.Z)({},Tit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}git.isMDXComponent=!0;const xit={toc:[]},vit="wrapper";function Lit(t){let{components:n,...e}=t;return(0,s.kt)(vit,(0,p.Z)({},xit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Lit.isMDXComponent=!0;const Zit={toc:[]},bit="wrapper";function Nit(t){let{components:n,...e}=t;return(0,s.kt)(bit,(0,p.Z)({},Zit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Nit.isMDXComponent=!0;const Ait={toc:[]},zit="wrapper";function Wit(t){let{components:n,...e}=t;return(0,s.kt)(zit,(0,p.Z)({},Ait,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Wit.isMDXComponent=!0;const Iit={toc:[]},Rit="wrapper";function Pit(t){let{components:n,...e}=t;return(0,s.kt)(Rit,(0,p.Z)({},Iit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Pit.isMDXComponent=!0;const Sit={toc:[]},Eit="wrapper";function Git(t){let{components:n,...e}=t;return(0,s.kt)(Eit,(0,p.Z)({},Sit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Git.isMDXComponent=!0;const Oit={toc:[]},Fit="wrapper";function Bit(t){let{components:n,...e}=t;return(0,s.kt)(Fit,(0,p.Z)({},Oit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Bit.isMDXComponent=!0;const Uit={toc:[]},Vit="wrapper";function qit(t){let{components:n,...e}=t;return(0,s.kt)(Vit,(0,p.Z)({},Uit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qit.isMDXComponent=!0;const jit={toc:[]},Yit="wrapper";function Qit(t){let{components:n,...e}=t;return(0,s.kt)(Yit,(0,p.Z)({},jit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Qit.isMDXComponent=!0;const Hit={toc:[]},$it="wrapper";function Kit(t){let{components:n,...e}=t;return(0,s.kt)($it,(0,p.Z)({},Hit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}Kit.isMDXComponent=!0;const Jit={toc:[]},tat="wrapper";function nat(t){let{components:n,...e}=t;return(0,s.kt)(tat,(0,p.Z)({},Jit,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}nat.isMDXComponent=!0;const eat={toc:[]},oat="wrapper";function pat(t){let{components:n,...e}=t;return(0,s.kt)(oat,(0,p.Z)({},eat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}pat.isMDXComponent=!0;const rat={toc:[]},sat="wrapper";function cat(t){let{components:n,...e}=t;return(0,s.kt)(sat,(0,p.Z)({},rat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}cat.isMDXComponent=!0;const iat={toc:[]},aat="wrapper";function lat(t){let{components:n,...e}=t;return(0,s.kt)(aat,(0,p.Z)({},iat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}lat.isMDXComponent=!0;const uat={toc:[]},mat="wrapper";function dat(t){let{components:n,...e}=t;return(0,s.kt)(mat,(0,p.Z)({},uat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}dat.isMDXComponent=!0;const hat={toc:[]},kat="wrapper";function fat(t){let{components:n,...e}=t;return(0,s.kt)(kat,(0,p.Z)({},hat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}fat.isMDXComponent=!0;const yat={toc:[]},Mat="wrapper";function Dat(t){let{components:n,...e}=t;return(0,s.kt)(Mat,(0,p.Z)({},yat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Dat.isMDXComponent=!0;const Xat={toc:[]},_at="wrapper";function wat(t){let{components:n,...e}=t;return(0,s.kt)(_at,(0,p.Z)({},Xat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wat.isMDXComponent=!0;const Tat={toc:[]},Cat="wrapper";function gat(t){let{components:n,...e}=t;return(0,s.kt)(Cat,(0,p.Z)({},Tat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}gat.isMDXComponent=!0;const xat={toc:[]},vat="wrapper";function Lat(t){let{components:n,...e}=t;return(0,s.kt)(vat,(0,p.Z)({},xat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Lat.isMDXComponent=!0;const Zat={toc:[]},bat="wrapper";function Nat(t){let{components:n,...e}=t;return(0,s.kt)(bat,(0,p.Z)({},Zat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Nat.isMDXComponent=!0;const Aat={toc:[]},zat="wrapper";function Wat(t){let{components:n,...e}=t;return(0,s.kt)(zat,(0,p.Z)({},Aat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Wat.isMDXComponent=!0;const Iat={toc:[]},Rat="wrapper";function Pat(t){let{components:n,...e}=t;return(0,s.kt)(Rat,(0,p.Z)({},Iat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Pat.isMDXComponent=!0;const Sat={toc:[]},Eat="wrapper";function Gat(t){let{components:n,...e}=t;return(0,s.kt)(Eat,(0,p.Z)({},Sat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Gat.isMDXComponent=!0;const Oat={toc:[]},Fat="wrapper";function Bat(t){let{components:n,...e}=t;return(0,s.kt)(Fat,(0,p.Z)({},Oat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Bat.isMDXComponent=!0;const Uat={toc:[]},Vat="wrapper";function qat(t){let{components:n,...e}=t;return(0,s.kt)(Vat,(0,p.Z)({},Uat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}qat.isMDXComponent=!0;const jat={toc:[]},Yat="wrapper";function Qat(t){let{components:n,...e}=t;return(0,s.kt)(Yat,(0,p.Z)({},jat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Qat.isMDXComponent=!0;const Hat={toc:[]},$at="wrapper";function Kat(t){let{components:n,...e}=t;return(0,s.kt)($at,(0,p.Z)({},Hat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Kat.isMDXComponent=!0;const Jat={toc:[]},tlt="wrapper";function nlt(t){let{components:n,...e}=t;return(0,s.kt)(tlt,(0,p.Z)({},Jat,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}nlt.isMDXComponent=!0;const elt={toc:[]},olt="wrapper";function plt(t){let{components:n,...e}=t;return(0,s.kt)(olt,(0,p.Z)({},elt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}plt.isMDXComponent=!0;const rlt={toc:[]},slt="wrapper";function clt(t){let{components:n,...e}=t;return(0,s.kt)(slt,(0,p.Z)({},rlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}clt.isMDXComponent=!0;const ilt={toc:[]},alt="wrapper";function llt(t){let{components:n,...e}=t;return(0,s.kt)(alt,(0,p.Z)({},ilt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}llt.isMDXComponent=!0;const ult={toc:[]},mlt="wrapper";function dlt(t){let{components:n,...e}=t;return(0,s.kt)(mlt,(0,p.Z)({},ult,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}dlt.isMDXComponent=!0;const hlt={toc:[]},klt="wrapper";function flt(t){let{components:n,...e}=t;return(0,s.kt)(klt,(0,p.Z)({},hlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, CubicBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  view.add(\n    <CubicBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, -100]}\n      p1={[100, -100]}\n      p2={[-100, 100]}\n      p3={[200, 100]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}flt.isMDXComponent=!0;const ylt={toc:[]},Mlt="wrapper";function Dlt(t){let{components:n,...e}=t;return(0,s.kt)(Mlt,(0,p.Z)({},ylt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a cubic B\xe9zier curve."))}Dlt.isMDXComponent=!0;const Xlt={toc:[]},_lt="wrapper";function wlt(t){let{components:n,...e}=t;return(0,s.kt)(_lt,(0,p.Z)({},Xlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wlt.isMDXComponent=!0;const Tlt={toc:[]},Clt="wrapper";function glt(t){let{components:n,...e}=t;return(0,s.kt)(Clt,(0,p.Z)({},Tlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}glt.isMDXComponent=!0;const xlt={toc:[]},vlt="wrapper";function Llt(t){let{components:n,...e}=t;return(0,s.kt)(vlt,(0,p.Z)({},xlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Llt.isMDXComponent=!0;const Zlt={toc:[]},blt="wrapper";function Nlt(t){let{components:n,...e}=t;return(0,s.kt)(blt,(0,p.Z)({},Zlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Nlt.isMDXComponent=!0;const Alt={toc:[]},zlt="wrapper";function Wlt(t){let{components:n,...e}=t;return(0,s.kt)(zlt,(0,p.Z)({},Alt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Wlt.isMDXComponent=!0;const Ilt={toc:[]},Rlt="wrapper";function Plt(t){let{components:n,...e}=t;return(0,s.kt)(Rlt,(0,p.Z)({},Ilt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Plt.isMDXComponent=!0;const Slt={toc:[]},Elt="wrapper";function Glt(t){let{components:n,...e}=t;return(0,s.kt)(Elt,(0,p.Z)({},Slt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Glt.isMDXComponent=!0;const Olt={toc:[]},Flt="wrapper";function Blt(t){let{components:n,...e}=t;return(0,s.kt)(Flt,(0,p.Z)({},Olt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Blt.isMDXComponent=!0;const Ult={toc:[]},Vlt="wrapper";function qlt(t){let{components:n,...e}=t;return(0,s.kt)(Vlt,(0,p.Z)({},Ult,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qlt.isMDXComponent=!0;const jlt={toc:[]},Ylt="wrapper";function Qlt(t){let{components:n,...e}=t;return(0,s.kt)(Ylt,(0,p.Z)({},jlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Qlt.isMDXComponent=!0;const Hlt={toc:[]},$lt="wrapper";function Klt(t){let{components:n,...e}=t;return(0,s.kt)($lt,(0,p.Z)({},Hlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Klt.isMDXComponent=!0;const Jlt={toc:[]},tut="wrapper";function nut(t){let{components:n,...e}=t;return(0,s.kt)(tut,(0,p.Z)({},Jlt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}nut.isMDXComponent=!0;const eut={toc:[]},out="wrapper";function put(t){let{components:n,...e}=t;return(0,s.kt)(out,(0,p.Z)({},eut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}put.isMDXComponent=!0;const rut={toc:[]},sut="wrapper";function cut(t){let{components:n,...e}=t;return(0,s.kt)(sut,(0,p.Z)({},rut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}cut.isMDXComponent=!0;const iut={toc:[]},aut="wrapper";function lut(t){let{components:n,...e}=t;return(0,s.kt)(aut,(0,p.Z)({},iut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}lut.isMDXComponent=!0;const uut={toc:[]},mut="wrapper";function dut(t){let{components:n,...e}=t;return(0,s.kt)(mut,(0,p.Z)({},uut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}dut.isMDXComponent=!0;const hut={toc:[]},kut="wrapper";function fut(t){let{components:n,...e}=t;return(0,s.kt)(kut,(0,p.Z)({},hut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}fut.isMDXComponent=!0;const yut={toc:[]},Mut="wrapper";function Dut(t){let{components:n,...e}=t;return(0,s.kt)(Mut,(0,p.Z)({},yut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Dut.isMDXComponent=!0;const Xut={toc:[]},_ut="wrapper";function wut(t){let{components:n,...e}=t;return(0,s.kt)(_ut,(0,p.Z)({},Xut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wut.isMDXComponent=!0;const Tut={toc:[]},Cut="wrapper";function gut(t){let{components:n,...e}=t;return(0,s.kt)(Cut,(0,p.Z)({},Tut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}gut.isMDXComponent=!0;const xut={toc:[]},vut="wrapper";function Lut(t){let{components:n,...e}=t;return(0,s.kt)(vut,(0,p.Z)({},xut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Lut.isMDXComponent=!0;const Zut={toc:[]},but="wrapper";function Nut(t){let{components:n,...e}=t;return(0,s.kt)(but,(0,p.Z)({},Zut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Nut.isMDXComponent=!0;const Aut={toc:[]},zut="wrapper";function Wut(t){let{components:n,...e}=t;return(0,s.kt)(zut,(0,p.Z)({},Aut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Wut.isMDXComponent=!0;const Iut={toc:[]},Rut="wrapper";function Put(t){let{components:n,...e}=t;return(0,s.kt)(Rut,(0,p.Z)({},Iut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Put.isMDXComponent=!0;const Sut={toc:[]},Eut="wrapper";function Gut(t){let{components:n,...e}=t;return(0,s.kt)(Eut,(0,p.Z)({},Sut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Gut.isMDXComponent=!0;const Out={toc:[]},Fut="wrapper";function But(t){let{components:n,...e}=t;return(0,s.kt)(Fut,(0,p.Z)({},Out,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}But.isMDXComponent=!0;const Uut={toc:[]},Vut="wrapper";function qut(t){let{components:n,...e}=t;return(0,s.kt)(Vut,(0,p.Z)({},Uut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qut.isMDXComponent=!0;const jut={toc:[]},Yut="wrapper";function Qut(t){let{components:n,...e}=t;return(0,s.kt)(Yut,(0,p.Z)({},jut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Qut.isMDXComponent=!0;const Hut={toc:[]},$ut="wrapper";function Kut(t){let{components:n,...e}=t;return(0,s.kt)($ut,(0,p.Z)({},Hut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Kut.isMDXComponent=!0;const Jut={toc:[]},tmt="wrapper";function nmt(t){let{components:n,...e}=t;return(0,s.kt)(tmt,(0,p.Z)({},Jut,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}nmt.isMDXComponent=!0;const emt={toc:[]},omt="wrapper";function pmt(t){let{components:n,...e}=t;return(0,s.kt)(omt,(0,p.Z)({},emt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}pmt.isMDXComponent=!0;const rmt={toc:[]},smt="wrapper";function cmt(t){let{components:n,...e}=t;return(0,s.kt)(smt,(0,p.Z)({},rmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The first control point of the B\xe9zier curve."))}cmt.isMDXComponent=!0;const imt={toc:[]},amt="wrapper";function lmt(t){let{components:n,...e}=t;return(0,s.kt)(amt,(0,p.Z)({},imt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The second control point of the B\xe9zier curve."))}lmt.isMDXComponent=!0;const umt={toc:[]},mmt="wrapper";function dmt(t){let{components:n,...e}=t;return(0,s.kt)(mmt,(0,p.Z)({},umt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}dmt.isMDXComponent=!0;const hmt={toc:[]},kmt="wrapper";function fmt(t){let{components:n,...e}=t;return(0,s.kt)(kmt,(0,p.Z)({},hmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}fmt.isMDXComponent=!0;const ymt={toc:[]},Mmt="wrapper";function Dmt(t){let{components:n,...e}=t;return(0,s.kt)(Mmt,(0,p.Z)({},ymt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Dmt.isMDXComponent=!0;const Xmt={toc:[]},_mt="wrapper";function wmt(t){let{components:n,...e}=t;return(0,s.kt)(_mt,(0,p.Z)({},Xmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}wmt.isMDXComponent=!0;const Tmt={toc:[]},Cmt="wrapper";function gmt(t){let{components:n,...e}=t;return(0,s.kt)(Cmt,(0,p.Z)({},Tmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}gmt.isMDXComponent=!0;const xmt={toc:[]},vmt="wrapper";function Lmt(t){let{components:n,...e}=t;return(0,s.kt)(vmt,(0,p.Z)({},xmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Lmt.isMDXComponent=!0;const Zmt={toc:[]},bmt="wrapper";function Nmt(t){let{components:n,...e}=t;return(0,s.kt)(bmt,(0,p.Z)({},Zmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Nmt.isMDXComponent=!0;const Amt={toc:[]},zmt="wrapper";function Wmt(t){let{components:n,...e}=t;return(0,s.kt)(zmt,(0,p.Z)({},Amt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Wmt.isMDXComponent=!0;const Imt={toc:[]},Rmt="wrapper";function Pmt(t){let{components:n,...e}=t;return(0,s.kt)(Rmt,(0,p.Z)({},Imt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Pmt.isMDXComponent=!0;const Smt={toc:[]},Emt="wrapper";function Gmt(t){let{components:n,...e}=t;return(0,s.kt)(Emt,(0,p.Z)({},Smt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Gmt.isMDXComponent=!0;const Omt={toc:[]},Fmt="wrapper";function Bmt(t){let{components:n,...e}=t;return(0,s.kt)(Fmt,(0,p.Z)({},Omt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Bmt.isMDXComponent=!0;const Umt={toc:[]},Vmt="wrapper";function qmt(t){let{components:n,...e}=t;return(0,s.kt)(Vmt,(0,p.Z)({},Umt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}qmt.isMDXComponent=!0;const jmt={toc:[]},Ymt="wrapper";function Qmt(t){let{components:n,...e}=t;return(0,s.kt)(Ymt,(0,p.Z)({},jmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Qmt.isMDXComponent=!0;const Hmt={toc:[]},$mt="wrapper";function Kmt(t){let{components:n,...e}=t;return(0,s.kt)($mt,(0,p.Z)({},Hmt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Kmt.isMDXComponent=!0;const Jmt={toc:[]},tdt="wrapper";function ndt(t){let{components:n,...e}=t;return(0,s.kt)(tdt,(0,p.Z)({},Jmt,e,{components:n,mdxType:"MDXLayout"}))}ndt.isMDXComponent=!0;const edt={toc:[]},odt="wrapper";function pdt(t){let{components:n,...e}=t;return(0,s.kt)(odt,(0,p.Z)({},edt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pdt.isMDXComponent=!0;const rdt={toc:[]},sdt="wrapper";function cdt(t){let{components:n,...e}=t;return(0,s.kt)(sdt,(0,p.Z)({},rdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}cdt.isMDXComponent=!0;const idt={toc:[]},adt="wrapper";function ldt(t){let{components:n,...e}=t;return(0,s.kt)(adt,(0,p.Z)({},idt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ldt.isMDXComponent=!0;const udt={toc:[]},mdt="wrapper";function ddt(t){let{components:n,...e}=t;return(0,s.kt)(mdt,(0,p.Z)({},udt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}ddt.isMDXComponent=!0;const hdt={toc:[]},kdt="wrapper";function fdt(t){let{components:n,...e}=t;return(0,s.kt)(kdt,(0,p.Z)({},hdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}fdt.isMDXComponent=!0;const ydt={toc:[]},Mdt="wrapper";function Ddt(t){let{components:n,...e}=t;return(0,s.kt)(Mdt,(0,p.Z)({},ydt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Ddt.isMDXComponent=!0;const Xdt={toc:[]},_dt="wrapper";function wdt(t){let{components:n,...e}=t;return(0,s.kt)(_dt,(0,p.Z)({},Xdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}wdt.isMDXComponent=!0;const Tdt={toc:[]},Cdt="wrapper";function gdt(t){let{components:n,...e}=t;return(0,s.kt)(Cdt,(0,p.Z)({},Tdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}gdt.isMDXComponent=!0;const xdt={toc:[]},vdt="wrapper";function Ldt(t){let{components:n,...e}=t;return(0,s.kt)(vdt,(0,p.Z)({},xdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Ldt.isMDXComponent=!0;const Zdt={toc:[]},bdt="wrapper";function Ndt(t){let{components:n,...e}=t;return(0,s.kt)(bdt,(0,p.Z)({},Zdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Ndt.isMDXComponent=!0;const Adt={toc:[]},zdt="wrapper";function Wdt(t){let{components:n,...e}=t;return(0,s.kt)(zdt,(0,p.Z)({},Adt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Wdt.isMDXComponent=!0;const Idt={toc:[]},Rdt="wrapper";function Pdt(t){let{components:n,...e}=t;return(0,s.kt)(Rdt,(0,p.Z)({},Idt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Pdt.isMDXComponent=!0;const Sdt={toc:[]},Edt="wrapper";function Gdt(t){let{components:n,...e}=t;return(0,s.kt)(Edt,(0,p.Z)({},Sdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Gdt.isMDXComponent=!0;const Odt={toc:[]},Fdt="wrapper";function Bdt(t){let{components:n,...e}=t;return(0,s.kt)(Fdt,(0,p.Z)({},Odt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Bdt.isMDXComponent=!0;const Udt={toc:[]},Vdt="wrapper";function qdt(t){let{components:n,...e}=t;return(0,s.kt)(Vdt,(0,p.Z)({},Udt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}qdt.isMDXComponent=!0;const jdt={toc:[]},Ydt="wrapper";function Qdt(t){let{components:n,...e}=t;return(0,s.kt)(Ydt,(0,p.Z)({},jdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Qdt.isMDXComponent=!0;const Hdt={toc:[]},$dt="wrapper";function Kdt(t){let{components:n,...e}=t;return(0,s.kt)($dt,(0,p.Z)({},Hdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Kdt.isMDXComponent=!0;const Jdt={toc:[]},tht="wrapper";function nht(t){let{components:n,...e}=t;return(0,s.kt)(tht,(0,p.Z)({},Jdt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}nht.isMDXComponent=!0;const eht={toc:[]},oht="wrapper";function pht(t){let{components:n,...e}=t;return(0,s.kt)(oht,(0,p.Z)({},eht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}pht.isMDXComponent=!0;const rht={toc:[]},sht="wrapper";function cht(t){let{components:n,...e}=t;return(0,s.kt)(sht,(0,p.Z)({},rht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}cht.isMDXComponent=!0;const iht={toc:[]},aht="wrapper";function lht(t){let{components:n,...e}=t;return(0,s.kt)(aht,(0,p.Z)({},iht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}lht.isMDXComponent=!0;const uht={toc:[]},mht="wrapper";function dht(t){let{components:n,...e}=t;return(0,s.kt)(mht,(0,p.Z)({},uht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}dht.isMDXComponent=!0;const hht={toc:[]},kht="wrapper";function fht(t){let{components:n,...e}=t;return(0,s.kt)(kht,(0,p.Z)({},hht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}fht.isMDXComponent=!0;const yht={toc:[]},Mht="wrapper";function Dht(t){let{components:n,...e}=t;return(0,s.kt)(Mht,(0,p.Z)({},yht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Dht.isMDXComponent=!0;const Xht={toc:[]},_ht="wrapper";function wht(t){let{components:n,...e}=t;return(0,s.kt)(_ht,(0,p.Z)({},Xht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}wht.isMDXComponent=!0;const Tht={toc:[]},Cht="wrapper";function ght(t){let{components:n,...e}=t;return(0,s.kt)(Cht,(0,p.Z)({},Tht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}ght.isMDXComponent=!0;const xht={toc:[]},vht="wrapper";function Lht(t){let{components:n,...e}=t;return(0,s.kt)(vht,(0,p.Z)({},xht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Lht.isMDXComponent=!0;const Zht={toc:[]},bht="wrapper";function Nht(t){let{components:n,...e}=t;return(0,s.kt)(bht,(0,p.Z)({},Zht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Nht.isMDXComponent=!0;const Aht={toc:[]},zht="wrapper";function Wht(t){let{components:n,...e}=t;return(0,s.kt)(zht,(0,p.Z)({},Aht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Wht.isMDXComponent=!0;const Iht={toc:[]},Rht="wrapper";function Pht(t){let{components:n,...e}=t;return(0,s.kt)(Rht,(0,p.Z)({},Iht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Pht.isMDXComponent=!0;const Sht={toc:[]},Eht="wrapper";function Ght(t){let{components:n,...e}=t;return(0,s.kt)(Eht,(0,p.Z)({},Sht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Ght.isMDXComponent=!0;const Oht={toc:[]},Fht="wrapper";function Bht(t){let{components:n,...e}=t;return(0,s.kt)(Fht,(0,p.Z)({},Oht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Bht.isMDXComponent=!0;const Uht={toc:[]},Vht="wrapper";function qht(t){let{components:n,...e}=t;return(0,s.kt)(Vht,(0,p.Z)({},Uht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qht.isMDXComponent=!0;const jht={toc:[]},Yht="wrapper";function Qht(t){let{components:n,...e}=t;return(0,s.kt)(Yht,(0,p.Z)({},jht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Qht.isMDXComponent=!0;const Hht={toc:[]},$ht="wrapper";function Kht(t){let{components:n,...e}=t;return(0,s.kt)($ht,(0,p.Z)({},Hht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Kht.isMDXComponent=!0;const Jht={toc:[]},tkt="wrapper";function nkt(t){let{components:n,...e}=t;return(0,s.kt)(tkt,(0,p.Z)({},Jht,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}nkt.isMDXComponent=!0;const ekt={toc:[]},okt="wrapper";function pkt(t){let{components:n,...e}=t;return(0,s.kt)(okt,(0,p.Z)({},ekt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}pkt.isMDXComponent=!0;const rkt={toc:[]},skt="wrapper";function ckt(t){let{components:n,...e}=t;return(0,s.kt)(skt,(0,p.Z)({},rkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}ckt.isMDXComponent=!0;const ikt={toc:[]},akt="wrapper";function lkt(t){let{components:n,...e}=t;return(0,s.kt)(akt,(0,p.Z)({},ikt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}lkt.isMDXComponent=!0;const ukt={toc:[]},mkt="wrapper";function dkt(t){let{components:n,...e}=t;return(0,s.kt)(mkt,(0,p.Z)({},ukt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}dkt.isMDXComponent=!0;const hkt={toc:[]},kkt="wrapper";function fkt(t){let{components:n,...e}=t;return(0,s.kt)(kkt,(0,p.Z)({},hkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}fkt.isMDXComponent=!0;const ykt={toc:[]},Mkt="wrapper";function Dkt(t){let{components:n,...e}=t;return(0,s.kt)(Mkt,(0,p.Z)({},ykt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Dkt.isMDXComponent=!0;const Xkt={toc:[]},_kt="wrapper";function wkt(t){let{components:n,...e}=t;return(0,s.kt)(_kt,(0,p.Z)({},Xkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}wkt.isMDXComponent=!0;const Tkt={toc:[]},Ckt="wrapper";function gkt(t){let{components:n,...e}=t;return(0,s.kt)(Ckt,(0,p.Z)({},Tkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}gkt.isMDXComponent=!0;const xkt={toc:[]},vkt="wrapper";function Lkt(t){let{components:n,...e}=t;return(0,s.kt)(vkt,(0,p.Z)({},xkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Lkt.isMDXComponent=!0;const Zkt={toc:[]},bkt="wrapper";function Nkt(t){let{components:n,...e}=t;return(0,s.kt)(bkt,(0,p.Z)({},Zkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Nkt.isMDXComponent=!0;const Akt={toc:[]},zkt="wrapper";function Wkt(t){let{components:n,...e}=t;return(0,s.kt)(zkt,(0,p.Z)({},Akt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Wkt.isMDXComponent=!0;const Ikt={toc:[]},Rkt="wrapper";function Pkt(t){let{components:n,...e}=t;return(0,s.kt)(Rkt,(0,p.Z)({},Ikt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Pkt.isMDXComponent=!0;const Skt={toc:[]},Ekt="wrapper";function Gkt(t){let{components:n,...e}=t;return(0,s.kt)(Ekt,(0,p.Z)({},Skt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Gkt.isMDXComponent=!0;const Okt={toc:[]},Fkt="wrapper";function Bkt(t){let{components:n,...e}=t;return(0,s.kt)(Fkt,(0,p.Z)({},Okt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Bkt.isMDXComponent=!0;const Ukt={toc:[]},Vkt="wrapper";function qkt(t){let{components:n,...e}=t;return(0,s.kt)(Vkt,(0,p.Z)({},Ukt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qkt.isMDXComponent=!0;const jkt={toc:[]},Ykt="wrapper";function Qkt(t){let{components:n,...e}=t;return(0,s.kt)(Ykt,(0,p.Z)({},jkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Qkt.isMDXComponent=!0;const Hkt={toc:[]},$kt="wrapper";function Kkt(t){let{components:n,...e}=t;return(0,s.kt)($kt,(0,p.Z)({},Hkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Kkt.isMDXComponent=!0;const Jkt={toc:[]},tft="wrapper";function nft(t){let{components:n,...e}=t;return(0,s.kt)(tft,(0,p.Z)({},Jkt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}nft.isMDXComponent=!0;const eft={toc:[]},oft="wrapper";function pft(t){let{components:n,...e}=t;return(0,s.kt)(oft,(0,p.Z)({},eft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}pft.isMDXComponent=!0;const rft={toc:[]},sft="wrapper";function cft(t){let{components:n,...e}=t;return(0,s.kt)(sft,(0,p.Z)({},rft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cft.isMDXComponent=!0;const ift={toc:[]},aft="wrapper";function lft(t){let{components:n,...e}=t;return(0,s.kt)(aft,(0,p.Z)({},ift,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}lft.isMDXComponent=!0;const uft={toc:[]},mft="wrapper";function dft(t){let{components:n,...e}=t;return(0,s.kt)(mft,(0,p.Z)({},uft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dft.isMDXComponent=!0;const hft={toc:[]},kft="wrapper";function fft(t){let{components:n,...e}=t;return(0,s.kt)(kft,(0,p.Z)({},hft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}fft.isMDXComponent=!0;const yft={toc:[]},Mft="wrapper";function Dft(t){let{components:n,...e}=t;return(0,s.kt)(Mft,(0,p.Z)({},yft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Dft.isMDXComponent=!0;const Xft={toc:[]},_ft="wrapper";function wft(t){let{components:n,...e}=t;return(0,s.kt)(_ft,(0,p.Z)({},Xft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}wft.isMDXComponent=!0;const Tft={toc:[]},Cft="wrapper";function gft(t){let{components:n,...e}=t;return(0,s.kt)(Cft,(0,p.Z)({},Tft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}gft.isMDXComponent=!0;const xft={toc:[]},vft="wrapper";function Lft(t){let{components:n,...e}=t;return(0,s.kt)(vft,(0,p.Z)({},xft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Lft.isMDXComponent=!0;const Zft={toc:[]},bft="wrapper";function Nft(t){let{components:n,...e}=t;return(0,s.kt)(bft,(0,p.Z)({},Zft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Nft.isMDXComponent=!0;const Aft={toc:[]},zft="wrapper";function Wft(t){let{components:n,...e}=t;return(0,s.kt)(zft,(0,p.Z)({},Aft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Wft.isMDXComponent=!0;const Ift={toc:[]},Rft="wrapper";function Pft(t){let{components:n,...e}=t;return(0,s.kt)(Rft,(0,p.Z)({},Ift,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Pft.isMDXComponent=!0;const Sft={toc:[]},Eft="wrapper";function Gft(t){let{components:n,...e}=t;return(0,s.kt)(Eft,(0,p.Z)({},Sft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Gft.isMDXComponent=!0;const Oft={toc:[]},Fft="wrapper";function Bft(t){let{components:n,...e}=t;return(0,s.kt)(Fft,(0,p.Z)({},Oft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Bft.isMDXComponent=!0;const Uft={toc:[]},Vft="wrapper";function qft(t){let{components:n,...e}=t;return(0,s.kt)(Vft,(0,p.Z)({},Uft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}qft.isMDXComponent=!0;const jft={toc:[]},Yft="wrapper";function Qft(t){let{components:n,...e}=t;return(0,s.kt)(Yft,(0,p.Z)({},jft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Qft.isMDXComponent=!0;const Hft={toc:[]},$ft="wrapper";function Kft(t){let{components:n,...e}=t;return(0,s.kt)($ft,(0,p.Z)({},Hft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Kft.isMDXComponent=!0;const Jft={toc:[]},tyt="wrapper";function nyt(t){let{components:n,...e}=t;return(0,s.kt)(tyt,(0,p.Z)({},Jft,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}nyt.isMDXComponent=!0;const eyt={toc:[]},oyt="wrapper";function pyt(t){let{components:n,...e}=t;return(0,s.kt)(oyt,(0,p.Z)({},eyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}pyt.isMDXComponent=!0;const ryt={toc:[]},syt="wrapper";function cyt(t){let{components:n,...e}=t;return(0,s.kt)(syt,(0,p.Z)({},ryt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}cyt.isMDXComponent=!0;const iyt={toc:[]},ayt="wrapper";function lyt(t){let{components:n,...e}=t;return(0,s.kt)(ayt,(0,p.Z)({},iyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}lyt.isMDXComponent=!0;const uyt={toc:[]},myt="wrapper";function dyt(t){let{components:n,...e}=t;return(0,s.kt)(myt,(0,p.Z)({},uyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}dyt.isMDXComponent=!0;const hyt={toc:[]},kyt="wrapper";function fyt(t){let{components:n,...e}=t;return(0,s.kt)(kyt,(0,p.Z)({},hyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}fyt.isMDXComponent=!0;const yyt={toc:[]},Myt="wrapper";function Dyt(t){let{components:n,...e}=t;return(0,s.kt)(Myt,(0,p.Z)({},yyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Dyt.isMDXComponent=!0;const Xyt={toc:[]},_yt="wrapper";function wyt(t){let{components:n,...e}=t;return(0,s.kt)(_yt,(0,p.Z)({},Xyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}wyt.isMDXComponent=!0;const Tyt={toc:[]},Cyt="wrapper";function gyt(t){let{components:n,...e}=t;return(0,s.kt)(Cyt,(0,p.Z)({},Tyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}gyt.isMDXComponent=!0;const xyt={toc:[]},vyt="wrapper";function Lyt(t){let{components:n,...e}=t;return(0,s.kt)(vyt,(0,p.Z)({},xyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Lyt.isMDXComponent=!0;const Zyt={toc:[]},byt="wrapper";function Nyt(t){let{components:n,...e}=t;return(0,s.kt)(byt,(0,p.Z)({},Zyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Nyt.isMDXComponent=!0;const Ayt={toc:[]},zyt="wrapper";function Wyt(t){let{components:n,...e}=t;return(0,s.kt)(zyt,(0,p.Z)({},Ayt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Wyt.isMDXComponent=!0;const Iyt={toc:[]},Ryt="wrapper";function Pyt(t){let{components:n,...e}=t;return(0,s.kt)(Ryt,(0,p.Z)({},Iyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Pyt.isMDXComponent=!0;const Syt={toc:[]},Eyt="wrapper";function Gyt(t){let{components:n,...e}=t;return(0,s.kt)(Eyt,(0,p.Z)({},Syt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Gyt.isMDXComponent=!0;const Oyt={toc:[]},Fyt="wrapper";function Byt(t){let{components:n,...e}=t;return(0,s.kt)(Fyt,(0,p.Z)({},Oyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Byt.isMDXComponent=!0;const Uyt={toc:[]},Vyt="wrapper";function qyt(t){let{components:n,...e}=t;return(0,s.kt)(Vyt,(0,p.Z)({},Uyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}qyt.isMDXComponent=!0;const jyt={toc:[]},Yyt="wrapper";function Qyt(t){let{components:n,...e}=t;return(0,s.kt)(Yyt,(0,p.Z)({},jyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Qyt.isMDXComponent=!0;const Hyt={toc:[]},$yt="wrapper";function Kyt(t){let{components:n,...e}=t;return(0,s.kt)($yt,(0,p.Z)({},Hyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Kyt.isMDXComponent=!0;const Jyt={toc:[]},tMt="wrapper";function nMt(t){let{components:n,...e}=t;return(0,s.kt)(tMt,(0,p.Z)({},Jyt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}nMt.isMDXComponent=!0;const eMt={toc:[]},oMt="wrapper";function pMt(t){let{components:n,...e}=t;return(0,s.kt)(oMt,(0,p.Z)({},eMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}pMt.isMDXComponent=!0;const rMt={toc:[]},sMt="wrapper";function cMt(t){let{components:n,...e}=t;return(0,s.kt)(sMt,(0,p.Z)({},rMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}cMt.isMDXComponent=!0;const iMt={toc:[]},aMt="wrapper";function lMt(t){let{components:n,...e}=t;return(0,s.kt)(aMt,(0,p.Z)({},iMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}lMt.isMDXComponent=!0;const uMt={toc:[]},mMt="wrapper";function dMt(t){let{components:n,...e}=t;return(0,s.kt)(mMt,(0,p.Z)({},uMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}dMt.isMDXComponent=!0;const hMt={toc:[]},kMt="wrapper";function fMt(t){let{components:n,...e}=t;return(0,s.kt)(kMt,(0,p.Z)({},hMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}fMt.isMDXComponent=!0;const yMt={toc:[]},MMt="wrapper";function DMt(t){let{components:n,...e}=t;return(0,s.kt)(MMt,(0,p.Z)({},yMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}DMt.isMDXComponent=!0;const XMt={toc:[]},_Mt="wrapper";function wMt(t){let{components:n,...e}=t;return(0,s.kt)(_Mt,(0,p.Z)({},XMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}wMt.isMDXComponent=!0;const TMt={toc:[]},CMt="wrapper";function gMt(t){let{components:n,...e}=t;return(0,s.kt)(CMt,(0,p.Z)({},TMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}gMt.isMDXComponent=!0;const xMt={toc:[]},vMt="wrapper";function LMt(t){let{components:n,...e}=t;return(0,s.kt)(vMt,(0,p.Z)({},xMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}LMt.isMDXComponent=!0;const ZMt={toc:[]},bMt="wrapper";function NMt(t){let{components:n,...e}=t;return(0,s.kt)(bMt,(0,p.Z)({},ZMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}NMt.isMDXComponent=!0;const AMt={toc:[]},zMt="wrapper";function WMt(t){let{components:n,...e}=t;return(0,s.kt)(zMt,(0,p.Z)({},AMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}WMt.isMDXComponent=!0;const IMt={toc:[]},RMt="wrapper";function PMt(t){let{components:n,...e}=t;return(0,s.kt)(RMt,(0,p.Z)({},IMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}PMt.isMDXComponent=!0;const SMt={toc:[]},EMt="wrapper";function GMt(t){let{components:n,...e}=t;return(0,s.kt)(EMt,(0,p.Z)({},SMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}GMt.isMDXComponent=!0;const OMt={toc:[]},FMt="wrapper";function BMt(t){let{components:n,...e}=t;return(0,s.kt)(FMt,(0,p.Z)({},OMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}BMt.isMDXComponent=!0;const UMt={toc:[]},VMt="wrapper";function qMt(t){let{components:n,...e}=t;return(0,s.kt)(VMt,(0,p.Z)({},UMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}qMt.isMDXComponent=!0;const jMt={toc:[]},YMt="wrapper";function QMt(t){let{components:n,...e}=t;return(0,s.kt)(YMt,(0,p.Z)({},jMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}QMt.isMDXComponent=!0;const HMt={toc:[]},$Mt="wrapper";function KMt(t){let{components:n,...e}=t;return(0,s.kt)($Mt,(0,p.Z)({},HMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}KMt.isMDXComponent=!0;const JMt={toc:[]},tDt="wrapper";function nDt(t){let{components:n,...e}=t;return(0,s.kt)(tDt,(0,p.Z)({},JMt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}nDt.isMDXComponent=!0;const eDt={toc:[]},oDt="wrapper";function pDt(t){let{components:n,...e}=t;return(0,s.kt)(oDt,(0,p.Z)({},eDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}pDt.isMDXComponent=!0;const rDt={toc:[]},sDt="wrapper";function cDt(t){let{components:n,...e}=t;return(0,s.kt)(sDt,(0,p.Z)({},rDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}cDt.isMDXComponent=!0;const iDt={toc:[]},aDt="wrapper";function lDt(t){let{components:n,...e}=t;return(0,s.kt)(aDt,(0,p.Z)({},iDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}lDt.isMDXComponent=!0;const uDt={toc:[]},mDt="wrapper";function dDt(t){let{components:n,...e}=t;return(0,s.kt)(mDt,(0,p.Z)({},uDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}dDt.isMDXComponent=!0;const hDt={toc:[]},kDt="wrapper";function fDt(t){let{components:n,...e}=t;return(0,s.kt)(kDt,(0,p.Z)({},hDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}fDt.isMDXComponent=!0;const yDt={toc:[]},MDt="wrapper";function DDt(t){let{components:n,...e}=t;return(0,s.kt)(MDt,(0,p.Z)({},yDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}DDt.isMDXComponent=!0;const XDt={toc:[]},_Dt="wrapper";function wDt(t){let{components:n,...e}=t;return(0,s.kt)(_Dt,(0,p.Z)({},XDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}wDt.isMDXComponent=!0;const TDt={toc:[]},CDt="wrapper";function gDt(t){let{components:n,...e}=t;return(0,s.kt)(CDt,(0,p.Z)({},TDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}gDt.isMDXComponent=!0;const xDt={toc:[]},vDt="wrapper";function LDt(t){let{components:n,...e}=t;return(0,s.kt)(vDt,(0,p.Z)({},xDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}LDt.isMDXComponent=!0;const ZDt={toc:[]},bDt="wrapper";function NDt(t){let{components:n,...e}=t;return(0,s.kt)(bDt,(0,p.Z)({},ZDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}NDt.isMDXComponent=!0;const ADt={toc:[]},zDt="wrapper";function WDt(t){let{components:n,...e}=t;return(0,s.kt)(zDt,(0,p.Z)({},ADt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}WDt.isMDXComponent=!0;const IDt={toc:[]},RDt="wrapper";function PDt(t){let{components:n,...e}=t;return(0,s.kt)(RDt,(0,p.Z)({},IDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}PDt.isMDXComponent=!0;const SDt={toc:[]},EDt="wrapper";function GDt(t){let{components:n,...e}=t;return(0,s.kt)(EDt,(0,p.Z)({},SDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}GDt.isMDXComponent=!0;const ODt={toc:[]},FDt="wrapper";function BDt(t){let{components:n,...e}=t;return(0,s.kt)(FDt,(0,p.Z)({},ODt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}BDt.isMDXComponent=!0;const UDt={toc:[]},VDt="wrapper";function qDt(t){let{components:n,...e}=t;return(0,s.kt)(VDt,(0,p.Z)({},UDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}qDt.isMDXComponent=!0;const jDt={toc:[]},YDt="wrapper";function QDt(t){let{components:n,...e}=t;return(0,s.kt)(YDt,(0,p.Z)({},jDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}QDt.isMDXComponent=!0;const HDt={toc:[]},$Dt="wrapper";function KDt(t){let{components:n,...e}=t;return(0,s.kt)($Dt,(0,p.Z)({},HDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}KDt.isMDXComponent=!0;const JDt={toc:[]},tXt="wrapper";function nXt(t){let{components:n,...e}=t;return(0,s.kt)(tXt,(0,p.Z)({},JDt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}nXt.isMDXComponent=!0;const eXt={toc:[]},oXt="wrapper";function pXt(t){let{components:n,...e}=t;return(0,s.kt)(oXt,(0,p.Z)({},eXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}pXt.isMDXComponent=!0;const rXt={toc:[]},sXt="wrapper";function cXt(t){let{components:n,...e}=t;return(0,s.kt)(sXt,(0,p.Z)({},rXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}cXt.isMDXComponent=!0;const iXt={toc:[]},aXt="wrapper";function lXt(t){let{components:n,...e}=t;return(0,s.kt)(aXt,(0,p.Z)({},iXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lXt.isMDXComponent=!0;const uXt={toc:[]},mXt="wrapper";function dXt(t){let{components:n,...e}=t;return(0,s.kt)(mXt,(0,p.Z)({},uXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}dXt.isMDXComponent=!0;const hXt={toc:[]},kXt="wrapper";function fXt(t){let{components:n,...e}=t;return(0,s.kt)(kXt,(0,p.Z)({},hXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}fXt.isMDXComponent=!0;const yXt={toc:[]},MXt="wrapper";function DXt(t){let{components:n,...e}=t;return(0,s.kt)(MXt,(0,p.Z)({},yXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}DXt.isMDXComponent=!0;const XXt={toc:[]},_Xt="wrapper";function wXt(t){let{components:n,...e}=t;return(0,s.kt)(_Xt,(0,p.Z)({},XXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}wXt.isMDXComponent=!0;const TXt={toc:[]},CXt="wrapper";function gXt(t){let{components:n,...e}=t;return(0,s.kt)(CXt,(0,p.Z)({},TXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}gXt.isMDXComponent=!0;const xXt={toc:[]},vXt="wrapper";function LXt(t){let{components:n,...e}=t;return(0,s.kt)(vXt,(0,p.Z)({},xXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}LXt.isMDXComponent=!0;const ZXt={toc:[]},bXt="wrapper";function NXt(t){let{components:n,...e}=t;return(0,s.kt)(bXt,(0,p.Z)({},ZXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}NXt.isMDXComponent=!0;const AXt={toc:[]},zXt="wrapper";function WXt(t){let{components:n,...e}=t;return(0,s.kt)(zXt,(0,p.Z)({},AXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}WXt.isMDXComponent=!0;const IXt={toc:[]},RXt="wrapper";function PXt(t){let{components:n,...e}=t;return(0,s.kt)(RXt,(0,p.Z)({},IXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}PXt.isMDXComponent=!0;const SXt={toc:[]},EXt="wrapper";function GXt(t){let{components:n,...e}=t;return(0,s.kt)(EXt,(0,p.Z)({},SXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}GXt.isMDXComponent=!0;const OXt={toc:[]},FXt="wrapper";function BXt(t){let{components:n,...e}=t;return(0,s.kt)(FXt,(0,p.Z)({},OXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}BXt.isMDXComponent=!0;const UXt={toc:[]},VXt="wrapper";function qXt(t){let{components:n,...e}=t;return(0,s.kt)(VXt,(0,p.Z)({},UXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qXt.isMDXComponent=!0;const jXt={toc:[]},YXt="wrapper";function QXt(t){let{components:n,...e}=t;return(0,s.kt)(YXt,(0,p.Z)({},jXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}QXt.isMDXComponent=!0;const HXt={toc:[]},$Xt="wrapper";function KXt(t){let{components:n,...e}=t;return(0,s.kt)($Xt,(0,p.Z)({},HXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}KXt.isMDXComponent=!0;const JXt={toc:[]},t_t="wrapper";function n_t(t){let{components:n,...e}=t;return(0,s.kt)(t_t,(0,p.Z)({},JXt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}n_t.isMDXComponent=!0;const e_t={toc:[]},o_t="wrapper";function p_t(t){let{components:n,...e}=t;return(0,s.kt)(o_t,(0,p.Z)({},e_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}p_t.isMDXComponent=!0;const r_t={toc:[]},s_t="wrapper";function c_t(t){let{components:n,...e}=t;return(0,s.kt)(s_t,(0,p.Z)({},r_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}c_t.isMDXComponent=!0;const i_t={toc:[]},a_t="wrapper";function l_t(t){let{components:n,...e}=t;return(0,s.kt)(a_t,(0,p.Z)({},i_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}l_t.isMDXComponent=!0;const u_t={toc:[]},m_t="wrapper";function d_t(t){let{components:n,...e}=t;return(0,s.kt)(m_t,(0,p.Z)({},u_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}d_t.isMDXComponent=!0;const h_t={toc:[]},k_t="wrapper";function f_t(t){let{components:n,...e}=t;return(0,s.kt)(k_t,(0,p.Z)({},h_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}f_t.isMDXComponent=!0;const y_t={toc:[]},M_t="wrapper";function D_t(t){let{components:n,...e}=t;return(0,s.kt)(M_t,(0,p.Z)({},y_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}D_t.isMDXComponent=!0;const X_t={toc:[]},__t="wrapper";function w_t(t){let{components:n,...e}=t;return(0,s.kt)(__t,(0,p.Z)({},X_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}w_t.isMDXComponent=!0;const T_t={toc:[]},C_t="wrapper";function g_t(t){let{components:n,...e}=t;return(0,s.kt)(C_t,(0,p.Z)({},T_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}g_t.isMDXComponent=!0;const x_t={toc:[]},v_t="wrapper";function L_t(t){let{components:n,...e}=t;return(0,s.kt)(v_t,(0,p.Z)({},x_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}L_t.isMDXComponent=!0;const Z_t={toc:[]},b_t="wrapper";function N_t(t){let{components:n,...e}=t;return(0,s.kt)(b_t,(0,p.Z)({},Z_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}N_t.isMDXComponent=!0;const A_t={toc:[]},z_t="wrapper";function W_t(t){let{components:n,...e}=t;return(0,s.kt)(z_t,(0,p.Z)({},A_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}W_t.isMDXComponent=!0;const I_t={toc:[]},R_t="wrapper";function P_t(t){let{components:n,...e}=t;return(0,s.kt)(R_t,(0,p.Z)({},I_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}P_t.isMDXComponent=!0;const S_t={toc:[]},E_t="wrapper";function G_t(t){let{components:n,...e}=t;return(0,s.kt)(E_t,(0,p.Z)({},S_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}G_t.isMDXComponent=!0;const O_t={toc:[]},F_t="wrapper";function B_t(t){let{components:n,...e}=t;return(0,s.kt)(F_t,(0,p.Z)({},O_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}B_t.isMDXComponent=!0;const U_t={toc:[]},V_t="wrapper";function q_t(t){let{components:n,...e}=t;return(0,s.kt)(V_t,(0,p.Z)({},U_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}q_t.isMDXComponent=!0;const j_t={toc:[]},Y_t="wrapper";function Q_t(t){let{components:n,...e}=t;return(0,s.kt)(Y_t,(0,p.Z)({},j_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Q_t.isMDXComponent=!0;const H_t={toc:[]},$_t="wrapper";function K_t(t){let{components:n,...e}=t;return(0,s.kt)($_t,(0,p.Z)({},H_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}K_t.isMDXComponent=!0;const J_t={toc:[]},twt="wrapper";function nwt(t){let{components:n,...e}=t;return(0,s.kt)(twt,(0,p.Z)({},J_t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}nwt.isMDXComponent=!0;const ewt={toc:[]},owt="wrapper";function pwt(t){let{components:n,...e}=t;return(0,s.kt)(owt,(0,p.Z)({},ewt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}pwt.isMDXComponent=!0;const rwt={toc:[]},swt="wrapper";function cwt(t){let{components:n,...e}=t;return(0,s.kt)(swt,(0,p.Z)({},rwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}cwt.isMDXComponent=!0;const iwt={toc:[]},awt="wrapper";function lwt(t){let{components:n,...e}=t;return(0,s.kt)(awt,(0,p.Z)({},iwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lwt.isMDXComponent=!0;const uwt={toc:[]},mwt="wrapper";function dwt(t){let{components:n,...e}=t;return(0,s.kt)(mwt,(0,p.Z)({},uwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}dwt.isMDXComponent=!0;const hwt={toc:[]},kwt="wrapper";function fwt(t){let{components:n,...e}=t;return(0,s.kt)(kwt,(0,p.Z)({},hwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}fwt.isMDXComponent=!0;const ywt={toc:[]},Mwt="wrapper";function Dwt(t){let{components:n,...e}=t;return(0,s.kt)(Mwt,(0,p.Z)({},ywt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Dwt.isMDXComponent=!0;const Xwt={toc:[]},_wt="wrapper";function wwt(t){let{components:n,...e}=t;return(0,s.kt)(_wt,(0,p.Z)({},Xwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}wwt.isMDXComponent=!0;const Twt={toc:[]},Cwt="wrapper";function gwt(t){let{components:n,...e}=t;return(0,s.kt)(Cwt,(0,p.Z)({},Twt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}gwt.isMDXComponent=!0;const xwt={toc:[]},vwt="wrapper";function Lwt(t){let{components:n,...e}=t;return(0,s.kt)(vwt,(0,p.Z)({},xwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Lwt.isMDXComponent=!0;const Zwt={toc:[]},bwt="wrapper";function Nwt(t){let{components:n,...e}=t;return(0,s.kt)(bwt,(0,p.Z)({},Zwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Nwt.isMDXComponent=!0;const Awt={toc:[]},zwt="wrapper";function Wwt(t){let{components:n,...e}=t;return(0,s.kt)(zwt,(0,p.Z)({},Awt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Wwt.isMDXComponent=!0;const Iwt={toc:[]},Rwt="wrapper";function Pwt(t){let{components:n,...e}=t;return(0,s.kt)(Rwt,(0,p.Z)({},Iwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Pwt.isMDXComponent=!0;const Swt={toc:[]},Ewt="wrapper";function Gwt(t){let{components:n,...e}=t;return(0,s.kt)(Ewt,(0,p.Z)({},Swt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Gwt.isMDXComponent=!0;const Owt={toc:[]},Fwt="wrapper";function Bwt(t){let{components:n,...e}=t;return(0,s.kt)(Fwt,(0,p.Z)({},Owt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Bwt.isMDXComponent=!0;const Uwt={toc:[]},Vwt="wrapper";function qwt(t){let{components:n,...e}=t;return(0,s.kt)(Vwt,(0,p.Z)({},Uwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}qwt.isMDXComponent=!0;const jwt={toc:[]},Ywt="wrapper";function Qwt(t){let{components:n,...e}=t;return(0,s.kt)(Ywt,(0,p.Z)({},jwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Qwt.isMDXComponent=!0;const Hwt={toc:[]},$wt="wrapper";function Kwt(t){let{components:n,...e}=t;return(0,s.kt)($wt,(0,p.Z)({},Hwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Kwt.isMDXComponent=!0;const Jwt={toc:[]},tTt="wrapper";function nTt(t){let{components:n,...e}=t;return(0,s.kt)(tTt,(0,p.Z)({},Jwt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}nTt.isMDXComponent=!0;const eTt={toc:[]},oTt="wrapper";function pTt(t){let{components:n,...e}=t;return(0,s.kt)(oTt,(0,p.Z)({},eTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}pTt.isMDXComponent=!0;const rTt={toc:[]},sTt="wrapper";function cTt(t){let{components:n,...e}=t;return(0,s.kt)(sTt,(0,p.Z)({},rTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}cTt.isMDXComponent=!0;const iTt={toc:[]},aTt="wrapper";function lTt(t){let{components:n,...e}=t;return(0,s.kt)(aTt,(0,p.Z)({},iTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}lTt.isMDXComponent=!0;const uTt={toc:[]},mTt="wrapper";function dTt(t){let{components:n,...e}=t;return(0,s.kt)(mTt,(0,p.Z)({},uTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}dTt.isMDXComponent=!0;const hTt={toc:[]},kTt="wrapper";function fTt(t){let{components:n,...e}=t;return(0,s.kt)(kTt,(0,p.Z)({},hTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}fTt.isMDXComponent=!0;const yTt={toc:[]},MTt="wrapper";function DTt(t){let{components:n,...e}=t;return(0,s.kt)(MTt,(0,p.Z)({},yTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}DTt.isMDXComponent=!0;const XTt={toc:[]},_Tt="wrapper";function wTt(t){let{components:n,...e}=t;return(0,s.kt)(_Tt,(0,p.Z)({},XTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}wTt.isMDXComponent=!0;const TTt={toc:[]},CTt="wrapper";function gTt(t){let{components:n,...e}=t;return(0,s.kt)(CTt,(0,p.Z)({},TTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}gTt.isMDXComponent=!0;const xTt={toc:[]},vTt="wrapper";function LTt(t){let{components:n,...e}=t;return(0,s.kt)(vTt,(0,p.Z)({},xTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}LTt.isMDXComponent=!0;const ZTt={toc:[]},bTt="wrapper";function NTt(t){let{components:n,...e}=t;return(0,s.kt)(bTt,(0,p.Z)({},ZTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}NTt.isMDXComponent=!0;const ATt={toc:[]},zTt="wrapper";function WTt(t){let{components:n,...e}=t;return(0,s.kt)(zTt,(0,p.Z)({},ATt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}WTt.isMDXComponent=!0;const ITt={toc:[]},RTt="wrapper";function PTt(t){let{components:n,...e}=t;return(0,s.kt)(RTt,(0,p.Z)({},ITt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}PTt.isMDXComponent=!0;const STt={toc:[]},ETt="wrapper";function GTt(t){let{components:n,...e}=t;return(0,s.kt)(ETt,(0,p.Z)({},STt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}GTt.isMDXComponent=!0;const OTt={toc:[]},FTt="wrapper";function BTt(t){let{components:n,...e}=t;return(0,s.kt)(FTt,(0,p.Z)({},OTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}BTt.isMDXComponent=!0;const UTt={toc:[]},VTt="wrapper";function qTt(t){let{components:n,...e}=t;return(0,s.kt)(VTt,(0,p.Z)({},UTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}qTt.isMDXComponent=!0;const jTt={toc:[]},YTt="wrapper";function QTt(t){let{components:n,...e}=t;return(0,s.kt)(YTt,(0,p.Z)({},jTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}QTt.isMDXComponent=!0;const HTt={toc:[]},$Tt="wrapper";function KTt(t){let{components:n,...e}=t;return(0,s.kt)($Tt,(0,p.Z)({},HTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}KTt.isMDXComponent=!0;const JTt={toc:[]},tCt="wrapper";function nCt(t){let{components:n,...e}=t;return(0,s.kt)(tCt,(0,p.Z)({},JTt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}nCt.isMDXComponent=!0;const eCt={toc:[]},oCt="wrapper";function pCt(t){let{components:n,...e}=t;return(0,s.kt)(oCt,(0,p.Z)({},eCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}pCt.isMDXComponent=!0;const rCt={toc:[]},sCt="wrapper";function cCt(t){let{components:n,...e}=t;return(0,s.kt)(sCt,(0,p.Z)({},rCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}cCt.isMDXComponent=!0;const iCt={toc:[]},aCt="wrapper";function lCt(t){let{components:n,...e}=t;return(0,s.kt)(aCt,(0,p.Z)({},iCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}lCt.isMDXComponent=!0;const uCt={toc:[]},mCt="wrapper";function dCt(t){let{components:n,...e}=t;return(0,s.kt)(mCt,(0,p.Z)({},uCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}dCt.isMDXComponent=!0;const hCt={toc:[]},kCt="wrapper";function fCt(t){let{components:n,...e}=t;return(0,s.kt)(kCt,(0,p.Z)({},hCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}fCt.isMDXComponent=!0;const yCt={toc:[]},MCt="wrapper";function DCt(t){let{components:n,...e}=t;return(0,s.kt)(MCt,(0,p.Z)({},yCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}DCt.isMDXComponent=!0;const XCt={toc:[]},_Ct="wrapper";function wCt(t){let{components:n,...e}=t;return(0,s.kt)(_Ct,(0,p.Z)({},XCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}wCt.isMDXComponent=!0;const TCt={toc:[]},CCt="wrapper";function gCt(t){let{components:n,...e}=t;return(0,s.kt)(CCt,(0,p.Z)({},TCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}gCt.isMDXComponent=!0;const xCt={toc:[]},vCt="wrapper";function LCt(t){let{components:n,...e}=t;return(0,s.kt)(vCt,(0,p.Z)({},xCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}LCt.isMDXComponent=!0;const ZCt={toc:[]},bCt="wrapper";function NCt(t){let{components:n,...e}=t;return(0,s.kt)(bCt,(0,p.Z)({},ZCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}NCt.isMDXComponent=!0;const ACt={toc:[]},zCt="wrapper";function WCt(t){let{components:n,...e}=t;return(0,s.kt)(zCt,(0,p.Z)({},ACt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}WCt.isMDXComponent=!0;const ICt={toc:[]},RCt="wrapper";function PCt(t){let{components:n,...e}=t;return(0,s.kt)(RCt,(0,p.Z)({},ICt,e,{components:n,mdxType:"MDXLayout"}))}PCt.isMDXComponent=!0;const SCt={toc:[]},ECt="wrapper";function GCt(t){let{components:n,...e}=t;return(0,s.kt)(ECt,(0,p.Z)({},SCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}GCt.isMDXComponent=!0;const OCt={toc:[]},FCt="wrapper";function BCt(t){let{components:n,...e}=t;return(0,s.kt)(FCt,(0,p.Z)({},OCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}BCt.isMDXComponent=!0;const UCt={toc:[]},VCt="wrapper";function qCt(t){let{components:n,...e}=t;return(0,s.kt)(VCt,(0,p.Z)({},UCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qCt.isMDXComponent=!0;const jCt={toc:[]},YCt="wrapper";function QCt(t){let{components:n,...e}=t;return(0,s.kt)(YCt,(0,p.Z)({},jCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}QCt.isMDXComponent=!0;const HCt={toc:[]},$Ct="wrapper";function KCt(t){let{components:n,...e}=t;return(0,s.kt)($Ct,(0,p.Z)({},HCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}KCt.isMDXComponent=!0;const JCt={toc:[]},tgt="wrapper";function ngt(t){let{components:n,...e}=t;return(0,s.kt)(tgt,(0,p.Z)({},JCt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}ngt.isMDXComponent=!0;const egt={toc:[]},ogt="wrapper";function pgt(t){let{components:n,...e}=t;return(0,s.kt)(ogt,(0,p.Z)({},egt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}pgt.isMDXComponent=!0;const rgt={toc:[]},sgt="wrapper";function cgt(t){let{components:n,...e}=t;return(0,s.kt)(sgt,(0,p.Z)({},rgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}cgt.isMDXComponent=!0;const igt={toc:[]},agt="wrapper";function lgt(t){let{components:n,...e}=t;return(0,s.kt)(agt,(0,p.Z)({},igt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}lgt.isMDXComponent=!0;const ugt={toc:[]},mgt="wrapper";function dgt(t){let{components:n,...e}=t;return(0,s.kt)(mgt,(0,p.Z)({},ugt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}dgt.isMDXComponent=!0;const hgt={toc:[]},kgt="wrapper";function fgt(t){let{components:n,...e}=t;return(0,s.kt)(kgt,(0,p.Z)({},hgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}fgt.isMDXComponent=!0;const ygt={toc:[]},Mgt="wrapper";function Dgt(t){let{components:n,...e}=t;return(0,s.kt)(Mgt,(0,p.Z)({},ygt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Dgt.isMDXComponent=!0;const Xgt={toc:[]},_gt="wrapper";function wgt(t){let{components:n,...e}=t;return(0,s.kt)(_gt,(0,p.Z)({},Xgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}wgt.isMDXComponent=!0;const Tgt={toc:[]},Cgt="wrapper";function ggt(t){let{components:n,...e}=t;return(0,s.kt)(Cgt,(0,p.Z)({},Tgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}ggt.isMDXComponent=!0;const xgt={toc:[]},vgt="wrapper";function Lgt(t){let{components:n,...e}=t;return(0,s.kt)(vgt,(0,p.Z)({},xgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Lgt.isMDXComponent=!0;const Zgt={toc:[]},bgt="wrapper";function Ngt(t){let{components:n,...e}=t;return(0,s.kt)(bgt,(0,p.Z)({},Zgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Ngt.isMDXComponent=!0;const Agt={toc:[]},zgt="wrapper";function Wgt(t){let{components:n,...e}=t;return(0,s.kt)(zgt,(0,p.Z)({},Agt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Wgt.isMDXComponent=!0;const Igt={toc:[]},Rgt="wrapper";function Pgt(t){let{components:n,...e}=t;return(0,s.kt)(Rgt,(0,p.Z)({},Igt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Pgt.isMDXComponent=!0;const Sgt={toc:[]},Egt="wrapper";function Ggt(t){let{components:n,...e}=t;return(0,s.kt)(Egt,(0,p.Z)({},Sgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Ggt.isMDXComponent=!0;const Ogt={toc:[]},Fgt="wrapper";function Bgt(t){let{components:n,...e}=t;return(0,s.kt)(Fgt,(0,p.Z)({},Ogt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Bgt.isMDXComponent=!0;const Ugt={toc:[]},Vgt="wrapper";function qgt(t){let{components:n,...e}=t;return(0,s.kt)(Vgt,(0,p.Z)({},Ugt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}qgt.isMDXComponent=!0;const jgt={toc:[]},Ygt="wrapper";function Qgt(t){let{components:n,...e}=t;return(0,s.kt)(Ygt,(0,p.Z)({},jgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Qgt.isMDXComponent=!0;const Hgt={toc:[]},$gt="wrapper";function Kgt(t){let{components:n,...e}=t;return(0,s.kt)($gt,(0,p.Z)({},Hgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Kgt.isMDXComponent=!0;const Jgt={toc:[]},txt="wrapper";function nxt(t){let{components:n,...e}=t;return(0,s.kt)(txt,(0,p.Z)({},Jgt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}nxt.isMDXComponent=!0;const ext={toc:[]},oxt="wrapper";function pxt(t){let{components:n,...e}=t;return(0,s.kt)(oxt,(0,p.Z)({},ext,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}pxt.isMDXComponent=!0;const rxt={toc:[]},sxt="wrapper";function cxt(t){let{components:n,...e}=t;return(0,s.kt)(sxt,(0,p.Z)({},rxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}cxt.isMDXComponent=!0;const ixt={toc:[]},axt="wrapper";function lxt(t){let{components:n,...e}=t;return(0,s.kt)(axt,(0,p.Z)({},ixt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}lxt.isMDXComponent=!0;const uxt={toc:[]},mxt="wrapper";function dxt(t){let{components:n,...e}=t;return(0,s.kt)(mxt,(0,p.Z)({},uxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}dxt.isMDXComponent=!0;const hxt={toc:[]},kxt="wrapper";function fxt(t){let{components:n,...e}=t;return(0,s.kt)(kxt,(0,p.Z)({},hxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}fxt.isMDXComponent=!0;const yxt={toc:[]},Mxt="wrapper";function Dxt(t){let{components:n,...e}=t;return(0,s.kt)(Mxt,(0,p.Z)({},yxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Dxt.isMDXComponent=!0;const Xxt={toc:[]},_xt="wrapper";function wxt(t){let{components:n,...e}=t;return(0,s.kt)(_xt,(0,p.Z)({},Xxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}wxt.isMDXComponent=!0;const Txt={toc:[]},Cxt="wrapper";function gxt(t){let{components:n,...e}=t;return(0,s.kt)(Cxt,(0,p.Z)({},Txt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}gxt.isMDXComponent=!0;const xxt={toc:[]},vxt="wrapper";function Lxt(t){let{components:n,...e}=t;return(0,s.kt)(vxt,(0,p.Z)({},xxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Lxt.isMDXComponent=!0;const Zxt={toc:[]},bxt="wrapper";function Nxt(t){let{components:n,...e}=t;return(0,s.kt)(bxt,(0,p.Z)({},Zxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Nxt.isMDXComponent=!0;const Axt={toc:[]},zxt="wrapper";function Wxt(t){let{components:n,...e}=t;return(0,s.kt)(zxt,(0,p.Z)({},Axt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Wxt.isMDXComponent=!0;const Ixt={toc:[]},Rxt="wrapper";function Pxt(t){let{components:n,...e}=t;return(0,s.kt)(Rxt,(0,p.Z)({},Ixt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Pxt.isMDXComponent=!0;const Sxt={toc:[]},Ext="wrapper";function Gxt(t){let{components:n,...e}=t;return(0,s.kt)(Ext,(0,p.Z)({},Sxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Gxt.isMDXComponent=!0;const Oxt={toc:[]},Fxt="wrapper";function Bxt(t){let{components:n,...e}=t;return(0,s.kt)(Fxt,(0,p.Z)({},Oxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Bxt.isMDXComponent=!0;const Uxt={toc:[]},Vxt="wrapper";function qxt(t){let{components:n,...e}=t;return(0,s.kt)(Vxt,(0,p.Z)({},Uxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}qxt.isMDXComponent=!0;const jxt={toc:[]},Yxt="wrapper";function Qxt(t){let{components:n,...e}=t;return(0,s.kt)(Yxt,(0,p.Z)({},jxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Qxt.isMDXComponent=!0;const Hxt={toc:[]},$xt="wrapper";function Kxt(t){let{components:n,...e}=t;return(0,s.kt)($xt,(0,p.Z)({},Hxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Kxt.isMDXComponent=!0;const Jxt={toc:[]},tvt="wrapper";function nvt(t){let{components:n,...e}=t;return(0,s.kt)(tvt,(0,p.Z)({},Jxt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}nvt.isMDXComponent=!0;const evt={toc:[]},ovt="wrapper";function pvt(t){let{components:n,...e}=t;return(0,s.kt)(ovt,(0,p.Z)({},evt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}pvt.isMDXComponent=!0;const rvt={toc:[]},svt="wrapper";function cvt(t){let{components:n,...e}=t;return(0,s.kt)(svt,(0,p.Z)({},rvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}cvt.isMDXComponent=!0;const ivt={toc:[]},avt="wrapper";function lvt(t){let{components:n,...e}=t;return(0,s.kt)(avt,(0,p.Z)({},ivt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}lvt.isMDXComponent=!0;const uvt={toc:[]},mvt="wrapper";function dvt(t){let{components:n,...e}=t;return(0,s.kt)(mvt,(0,p.Z)({},uvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}dvt.isMDXComponent=!0;const hvt={toc:[]},kvt="wrapper";function fvt(t){let{components:n,...e}=t;return(0,s.kt)(kvt,(0,p.Z)({},hvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}fvt.isMDXComponent=!0;const yvt={toc:[]},Mvt="wrapper";function Dvt(t){let{components:n,...e}=t;return(0,s.kt)(Mvt,(0,p.Z)({},yvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Dvt.isMDXComponent=!0;const Xvt={toc:[]},_vt="wrapper";function wvt(t){let{components:n,...e}=t;return(0,s.kt)(_vt,(0,p.Z)({},Xvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}wvt.isMDXComponent=!0;const Tvt={toc:[]},Cvt="wrapper";function gvt(t){let{components:n,...e}=t;return(0,s.kt)(Cvt,(0,p.Z)({},Tvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}gvt.isMDXComponent=!0;const xvt={toc:[]},vvt="wrapper";function Lvt(t){let{components:n,...e}=t;return(0,s.kt)(vvt,(0,p.Z)({},xvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Lvt.isMDXComponent=!0;const Zvt={toc:[]},bvt="wrapper";function Nvt(t){let{components:n,...e}=t;return(0,s.kt)(bvt,(0,p.Z)({},Zvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Nvt.isMDXComponent=!0;const Avt={toc:[]},zvt="wrapper";function Wvt(t){let{components:n,...e}=t;return(0,s.kt)(zvt,(0,p.Z)({},Avt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Wvt.isMDXComponent=!0;const Ivt={toc:[]},Rvt="wrapper";function Pvt(t){let{components:n,...e}=t;return(0,s.kt)(Rvt,(0,p.Z)({},Ivt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Pvt.isMDXComponent=!0;const Svt={toc:[]},Evt="wrapper";function Gvt(t){let{components:n,...e}=t;return(0,s.kt)(Evt,(0,p.Z)({},Svt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Gvt.isMDXComponent=!0;const Ovt={toc:[]},Fvt="wrapper";function Bvt(t){let{components:n,...e}=t;return(0,s.kt)(Fvt,(0,p.Z)({},Ovt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Bvt.isMDXComponent=!0;const Uvt={toc:[]},Vvt="wrapper";function qvt(t){let{components:n,...e}=t;return(0,s.kt)(Vvt,(0,p.Z)({},Uvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}qvt.isMDXComponent=!0;const jvt={toc:[]},Yvt="wrapper";function Qvt(t){let{components:n,...e}=t;return(0,s.kt)(Yvt,(0,p.Z)({},jvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Qvt.isMDXComponent=!0;const Hvt={toc:[]},$vt="wrapper";function Kvt(t){let{components:n,...e}=t;return(0,s.kt)($vt,(0,p.Z)({},Hvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Kvt.isMDXComponent=!0;const Jvt={toc:[]},tLt="wrapper";function nLt(t){let{components:n,...e}=t;return(0,s.kt)(tLt,(0,p.Z)({},Jvt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}nLt.isMDXComponent=!0;const eLt={toc:[]},oLt="wrapper";function pLt(t){let{components:n,...e}=t;return(0,s.kt)(oLt,(0,p.Z)({},eLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}pLt.isMDXComponent=!0;const rLt={toc:[]},sLt="wrapper";function cLt(t){let{components:n,...e}=t;return(0,s.kt)(sLt,(0,p.Z)({},rLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cLt.isMDXComponent=!0;const iLt={toc:[]},aLt="wrapper";function lLt(t){let{components:n,...e}=t;return(0,s.kt)(aLt,(0,p.Z)({},iLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}lLt.isMDXComponent=!0;const uLt={toc:[]},mLt="wrapper";function dLt(t){let{components:n,...e}=t;return(0,s.kt)(mLt,(0,p.Z)({},uLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dLt.isMDXComponent=!0;const hLt={toc:[]},kLt="wrapper";function fLt(t){let{components:n,...e}=t;return(0,s.kt)(kLt,(0,p.Z)({},hLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}fLt.isMDXComponent=!0;const yLt={toc:[]},MLt="wrapper";function DLt(t){let{components:n,...e}=t;return(0,s.kt)(MLt,(0,p.Z)({},yLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}DLt.isMDXComponent=!0;const XLt={toc:[]},_Lt="wrapper";function wLt(t){let{components:n,...e}=t;return(0,s.kt)(_Lt,(0,p.Z)({},XLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}wLt.isMDXComponent=!0;const TLt={toc:[]},CLt="wrapper";function gLt(t){let{components:n,...e}=t;return(0,s.kt)(CLt,(0,p.Z)({},TLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}gLt.isMDXComponent=!0;const xLt={toc:[]},vLt="wrapper";function LLt(t){let{components:n,...e}=t;return(0,s.kt)(vLt,(0,p.Z)({},xLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}LLt.isMDXComponent=!0;const ZLt={toc:[]},bLt="wrapper";function NLt(t){let{components:n,...e}=t;return(0,s.kt)(bLt,(0,p.Z)({},ZLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}NLt.isMDXComponent=!0;const ALt={toc:[]},zLt="wrapper";function WLt(t){let{components:n,...e}=t;return(0,s.kt)(zLt,(0,p.Z)({},ALt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}WLt.isMDXComponent=!0;const ILt={toc:[]},RLt="wrapper";function PLt(t){let{components:n,...e}=t;return(0,s.kt)(RLt,(0,p.Z)({},ILt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}PLt.isMDXComponent=!0;const SLt={toc:[]},ELt="wrapper";function GLt(t){let{components:n,...e}=t;return(0,s.kt)(ELt,(0,p.Z)({},SLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}GLt.isMDXComponent=!0;const OLt={toc:[]},FLt="wrapper";function BLt(t){let{components:n,...e}=t;return(0,s.kt)(FLt,(0,p.Z)({},OLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}BLt.isMDXComponent=!0;const ULt={toc:[]},VLt="wrapper";function qLt(t){let{components:n,...e}=t;return(0,s.kt)(VLt,(0,p.Z)({},ULt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}qLt.isMDXComponent=!0;const jLt={toc:[]},YLt="wrapper";function QLt(t){let{components:n,...e}=t;return(0,s.kt)(YLt,(0,p.Z)({},jLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}QLt.isMDXComponent=!0;const HLt={toc:[]},$Lt="wrapper";function KLt(t){let{components:n,...e}=t;return(0,s.kt)($Lt,(0,p.Z)({},HLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}KLt.isMDXComponent=!0;const JLt={toc:[]},tZt="wrapper";function nZt(t){let{components:n,...e}=t;return(0,s.kt)(tZt,(0,p.Z)({},JLt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}nZt.isMDXComponent=!0;const eZt={toc:[]},oZt="wrapper";function pZt(t){let{components:n,...e}=t;return(0,s.kt)(oZt,(0,p.Z)({},eZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}pZt.isMDXComponent=!0;const rZt={toc:[]},sZt="wrapper";function cZt(t){let{components:n,...e}=t;return(0,s.kt)(sZt,(0,p.Z)({},rZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}cZt.isMDXComponent=!0;const iZt={toc:[]},aZt="wrapper";function lZt(t){let{components:n,...e}=t;return(0,s.kt)(aZt,(0,p.Z)({},iZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}lZt.isMDXComponent=!0;const uZt={toc:[]},mZt="wrapper";function dZt(t){let{components:n,...e}=t;return(0,s.kt)(mZt,(0,p.Z)({},uZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}dZt.isMDXComponent=!0;const hZt={toc:[]},kZt="wrapper";function fZt(t){let{components:n,...e}=t;return(0,s.kt)(kZt,(0,p.Z)({},hZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}fZt.isMDXComponent=!0;const yZt={toc:[]},MZt="wrapper";function DZt(t){let{components:n,...e}=t;return(0,s.kt)(MZt,(0,p.Z)({},yZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}DZt.isMDXComponent=!0;const XZt={toc:[]},_Zt="wrapper";function wZt(t){let{components:n,...e}=t;return(0,s.kt)(_Zt,(0,p.Z)({},XZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}wZt.isMDXComponent=!0;const TZt={toc:[]},CZt="wrapper";function gZt(t){let{components:n,...e}=t;return(0,s.kt)(CZt,(0,p.Z)({},TZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}gZt.isMDXComponent=!0;const xZt={toc:[]},vZt="wrapper";function LZt(t){let{components:n,...e}=t;return(0,s.kt)(vZt,(0,p.Z)({},xZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}LZt.isMDXComponent=!0;const ZZt={toc:[]},bZt="wrapper";function NZt(t){let{components:n,...e}=t;return(0,s.kt)(bZt,(0,p.Z)({},ZZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}NZt.isMDXComponent=!0;const AZt={toc:[]},zZt="wrapper";function WZt(t){let{components:n,...e}=t;return(0,s.kt)(zZt,(0,p.Z)({},AZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}WZt.isMDXComponent=!0;const IZt={toc:[]},RZt="wrapper";function PZt(t){let{components:n,...e}=t;return(0,s.kt)(RZt,(0,p.Z)({},IZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}PZt.isMDXComponent=!0;const SZt={toc:[]},EZt="wrapper";function GZt(t){let{components:n,...e}=t;return(0,s.kt)(EZt,(0,p.Z)({},SZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}GZt.isMDXComponent=!0;const OZt={toc:[]},FZt="wrapper";function BZt(t){let{components:n,...e}=t;return(0,s.kt)(FZt,(0,p.Z)({},OZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}BZt.isMDXComponent=!0;const UZt={toc:[]},VZt="wrapper";function qZt(t){let{components:n,...e}=t;return(0,s.kt)(VZt,(0,p.Z)({},UZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}qZt.isMDXComponent=!0;const jZt={toc:[]},YZt="wrapper";function QZt(t){let{components:n,...e}=t;return(0,s.kt)(YZt,(0,p.Z)({},jZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}QZt.isMDXComponent=!0;const HZt={toc:[]},$Zt="wrapper";function KZt(t){let{components:n,...e}=t;return(0,s.kt)($Zt,(0,p.Z)({},HZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}KZt.isMDXComponent=!0;const JZt={toc:[]},tbt="wrapper";function nbt(t){let{components:n,...e}=t;return(0,s.kt)(tbt,(0,p.Z)({},JZt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}nbt.isMDXComponent=!0;const ebt={toc:[]},obt="wrapper";function pbt(t){let{components:n,...e}=t;return(0,s.kt)(obt,(0,p.Z)({},ebt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}pbt.isMDXComponent=!0;const rbt={toc:[]},sbt="wrapper";function cbt(t){let{components:n,...e}=t;return(0,s.kt)(sbt,(0,p.Z)({},rbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}cbt.isMDXComponent=!0;const ibt={toc:[]},abt="wrapper";function lbt(t){let{components:n,...e}=t;return(0,s.kt)(abt,(0,p.Z)({},ibt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}lbt.isMDXComponent=!0;const ubt={toc:[]},mbt="wrapper";function dbt(t){let{components:n,...e}=t;return(0,s.kt)(mbt,(0,p.Z)({},ubt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}dbt.isMDXComponent=!0;const hbt={toc:[]},kbt="wrapper";function fbt(t){let{components:n,...e}=t;return(0,s.kt)(kbt,(0,p.Z)({},hbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}fbt.isMDXComponent=!0;const ybt={toc:[]},Mbt="wrapper";function Dbt(t){let{components:n,...e}=t;return(0,s.kt)(Mbt,(0,p.Z)({},ybt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Dbt.isMDXComponent=!0;const Xbt={toc:[]},_bt="wrapper";function wbt(t){let{components:n,...e}=t;return(0,s.kt)(_bt,(0,p.Z)({},Xbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}wbt.isMDXComponent=!0;const Tbt={toc:[]},Cbt="wrapper";function gbt(t){let{components:n,...e}=t;return(0,s.kt)(Cbt,(0,p.Z)({},Tbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}gbt.isMDXComponent=!0;const xbt={toc:[]},vbt="wrapper";function Lbt(t){let{components:n,...e}=t;return(0,s.kt)(vbt,(0,p.Z)({},xbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Lbt.isMDXComponent=!0;const Zbt={toc:[]},bbt="wrapper";function Nbt(t){let{components:n,...e}=t;return(0,s.kt)(bbt,(0,p.Z)({},Zbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Nbt.isMDXComponent=!0;const Abt={toc:[]},zbt="wrapper";function Wbt(t){let{components:n,...e}=t;return(0,s.kt)(zbt,(0,p.Z)({},Abt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Wbt.isMDXComponent=!0;const Ibt={toc:[]},Rbt="wrapper";function Pbt(t){let{components:n,...e}=t;return(0,s.kt)(Rbt,(0,p.Z)({},Ibt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Pbt.isMDXComponent=!0;const Sbt={toc:[]},Ebt="wrapper";function Gbt(t){let{components:n,...e}=t;return(0,s.kt)(Ebt,(0,p.Z)({},Sbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Gbt.isMDXComponent=!0;const Obt={toc:[]},Fbt="wrapper";function Bbt(t){let{components:n,...e}=t;return(0,s.kt)(Fbt,(0,p.Z)({},Obt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Bbt.isMDXComponent=!0;const Ubt={toc:[]},Vbt="wrapper";function qbt(t){let{components:n,...e}=t;return(0,s.kt)(Vbt,(0,p.Z)({},Ubt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}qbt.isMDXComponent=!0;const jbt={toc:[]},Ybt="wrapper";function Qbt(t){let{components:n,...e}=t;return(0,s.kt)(Ybt,(0,p.Z)({},jbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Qbt.isMDXComponent=!0;const Hbt={toc:[]},$bt="wrapper";function Kbt(t){let{components:n,...e}=t;return(0,s.kt)($bt,(0,p.Z)({},Hbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Kbt.isMDXComponent=!0;const Jbt={toc:[]},tNt="wrapper";function nNt(t){let{components:n,...e}=t;return(0,s.kt)(tNt,(0,p.Z)({},Jbt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}nNt.isMDXComponent=!0;const eNt={toc:[]},oNt="wrapper";function pNt(t){let{components:n,...e}=t;return(0,s.kt)(oNt,(0,p.Z)({},eNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}pNt.isMDXComponent=!0;const rNt={toc:[]},sNt="wrapper";function cNt(t){let{components:n,...e}=t;return(0,s.kt)(sNt,(0,p.Z)({},rNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}cNt.isMDXComponent=!0;const iNt={toc:[]},aNt="wrapper";function lNt(t){let{components:n,...e}=t;return(0,s.kt)(aNt,(0,p.Z)({},iNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}lNt.isMDXComponent=!0;const uNt={toc:[]},mNt="wrapper";function dNt(t){let{components:n,...e}=t;return(0,s.kt)(mNt,(0,p.Z)({},uNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}dNt.isMDXComponent=!0;const hNt={toc:[]},kNt="wrapper";function fNt(t){let{components:n,...e}=t;return(0,s.kt)(kNt,(0,p.Z)({},hNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}fNt.isMDXComponent=!0;const yNt={toc:[]},MNt="wrapper";function DNt(t){let{components:n,...e}=t;return(0,s.kt)(MNt,(0,p.Z)({},yNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}DNt.isMDXComponent=!0;const XNt={toc:[]},_Nt="wrapper";function wNt(t){let{components:n,...e}=t;return(0,s.kt)(_Nt,(0,p.Z)({},XNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}wNt.isMDXComponent=!0;const TNt={toc:[]},CNt="wrapper";function gNt(t){let{components:n,...e}=t;return(0,s.kt)(CNt,(0,p.Z)({},TNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}gNt.isMDXComponent=!0;const xNt={toc:[]},vNt="wrapper";function LNt(t){let{components:n,...e}=t;return(0,s.kt)(vNt,(0,p.Z)({},xNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}LNt.isMDXComponent=!0;const ZNt={toc:[]},bNt="wrapper";function NNt(t){let{components:n,...e}=t;return(0,s.kt)(bNt,(0,p.Z)({},ZNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}NNt.isMDXComponent=!0;const ANt={toc:[]},zNt="wrapper";function WNt(t){let{components:n,...e}=t;return(0,s.kt)(zNt,(0,p.Z)({},ANt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}WNt.isMDXComponent=!0;const INt={toc:[]},RNt="wrapper";function PNt(t){let{components:n,...e}=t;return(0,s.kt)(RNt,(0,p.Z)({},INt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}PNt.isMDXComponent=!0;const SNt={toc:[]},ENt="wrapper";function GNt(t){let{components:n,...e}=t;return(0,s.kt)(ENt,(0,p.Z)({},SNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}GNt.isMDXComponent=!0;const ONt={toc:[]},FNt="wrapper";function BNt(t){let{components:n,...e}=t;return(0,s.kt)(FNt,(0,p.Z)({},ONt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}BNt.isMDXComponent=!0;const UNt={toc:[]},VNt="wrapper";function qNt(t){let{components:n,...e}=t;return(0,s.kt)(VNt,(0,p.Z)({},UNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qNt.isMDXComponent=!0;const jNt={toc:[]},YNt="wrapper";function QNt(t){let{components:n,...e}=t;return(0,s.kt)(YNt,(0,p.Z)({},jNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}QNt.isMDXComponent=!0;const HNt={toc:[]},$Nt="wrapper";function KNt(t){let{components:n,...e}=t;return(0,s.kt)($Nt,(0,p.Z)({},HNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}KNt.isMDXComponent=!0;const JNt={toc:[]},tAt="wrapper";function nAt(t){let{components:n,...e}=t;return(0,s.kt)(tAt,(0,p.Z)({},JNt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}nAt.isMDXComponent=!0;const eAt={toc:[]},oAt="wrapper";function pAt(t){let{components:n,...e}=t;return(0,s.kt)(oAt,(0,p.Z)({},eAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}pAt.isMDXComponent=!0;const rAt={toc:[]},sAt="wrapper";function cAt(t){let{components:n,...e}=t;return(0,s.kt)(sAt,(0,p.Z)({},rAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}cAt.isMDXComponent=!0;const iAt={toc:[]},aAt="wrapper";function lAt(t){let{components:n,...e}=t;return(0,s.kt)(aAt,(0,p.Z)({},iAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}lAt.isMDXComponent=!0;const uAt={toc:[]},mAt="wrapper";function dAt(t){let{components:n,...e}=t;return(0,s.kt)(mAt,(0,p.Z)({},uAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}dAt.isMDXComponent=!0;const hAt={toc:[]},kAt="wrapper";function fAt(t){let{components:n,...e}=t;return(0,s.kt)(kAt,(0,p.Z)({},hAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}fAt.isMDXComponent=!0;const yAt={toc:[]},MAt="wrapper";function DAt(t){let{components:n,...e}=t;return(0,s.kt)(MAt,(0,p.Z)({},yAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}DAt.isMDXComponent=!0;const XAt={toc:[]},_At="wrapper";function wAt(t){let{components:n,...e}=t;return(0,s.kt)(_At,(0,p.Z)({},XAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}wAt.isMDXComponent=!0;const TAt={toc:[]},CAt="wrapper";function gAt(t){let{components:n,...e}=t;return(0,s.kt)(CAt,(0,p.Z)({},TAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}gAt.isMDXComponent=!0;const xAt={toc:[]},vAt="wrapper";function LAt(t){let{components:n,...e}=t;return(0,s.kt)(vAt,(0,p.Z)({},xAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}LAt.isMDXComponent=!0;const ZAt={toc:[]},bAt="wrapper";function NAt(t){let{components:n,...e}=t;return(0,s.kt)(bAt,(0,p.Z)({},ZAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}NAt.isMDXComponent=!0;const AAt={toc:[]},zAt="wrapper";function WAt(t){let{components:n,...e}=t;return(0,s.kt)(zAt,(0,p.Z)({},AAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}WAt.isMDXComponent=!0;const IAt={toc:[]},RAt="wrapper";function PAt(t){let{components:n,...e}=t;return(0,s.kt)(RAt,(0,p.Z)({},IAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}PAt.isMDXComponent=!0;const SAt={toc:[]},EAt="wrapper";function GAt(t){let{components:n,...e}=t;return(0,s.kt)(EAt,(0,p.Z)({},SAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}GAt.isMDXComponent=!0;const OAt={toc:[]},FAt="wrapper";function BAt(t){let{components:n,...e}=t;return(0,s.kt)(FAt,(0,p.Z)({},OAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}BAt.isMDXComponent=!0;const UAt={toc:[]},VAt="wrapper";function qAt(t){let{components:n,...e}=t;return(0,s.kt)(VAt,(0,p.Z)({},UAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}qAt.isMDXComponent=!0;const jAt={toc:[]},YAt="wrapper";function QAt(t){let{components:n,...e}=t;return(0,s.kt)(YAt,(0,p.Z)({},jAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}QAt.isMDXComponent=!0;const HAt={toc:[]},$At="wrapper";function KAt(t){let{components:n,...e}=t;return(0,s.kt)($At,(0,p.Z)({},HAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}KAt.isMDXComponent=!0;const JAt={toc:[]},tzt="wrapper";function nzt(t){let{components:n,...e}=t;return(0,s.kt)(tzt,(0,p.Z)({},JAt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}nzt.isMDXComponent=!0;const ezt={toc:[]},ozt="wrapper";function pzt(t){let{components:n,...e}=t;return(0,s.kt)(ozt,(0,p.Z)({},ezt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}pzt.isMDXComponent=!0;const rzt={toc:[]},szt="wrapper";function czt(t){let{components:n,...e}=t;return(0,s.kt)(szt,(0,p.Z)({},rzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}czt.isMDXComponent=!0;const izt={toc:[]},azt="wrapper";function lzt(t){let{components:n,...e}=t;return(0,s.kt)(azt,(0,p.Z)({},izt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}lzt.isMDXComponent=!0;const uzt={toc:[]},mzt="wrapper";function dzt(t){let{components:n,...e}=t;return(0,s.kt)(mzt,(0,p.Z)({},uzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}dzt.isMDXComponent=!0;const hzt={toc:[]},kzt="wrapper";function fzt(t){let{components:n,...e}=t;return(0,s.kt)(kzt,(0,p.Z)({},hzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}fzt.isMDXComponent=!0;const yzt={toc:[]},Mzt="wrapper";function Dzt(t){let{components:n,...e}=t;return(0,s.kt)(Mzt,(0,p.Z)({},yzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Dzt.isMDXComponent=!0;const Xzt={toc:[]},_zt="wrapper";function wzt(t){let{components:n,...e}=t;return(0,s.kt)(_zt,(0,p.Z)({},Xzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}wzt.isMDXComponent=!0;const Tzt={toc:[]},Czt="wrapper";function gzt(t){let{components:n,...e}=t;return(0,s.kt)(Czt,(0,p.Z)({},Tzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}gzt.isMDXComponent=!0;const xzt={toc:[]},vzt="wrapper";function Lzt(t){let{components:n,...e}=t;return(0,s.kt)(vzt,(0,p.Z)({},xzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Lzt.isMDXComponent=!0;const Zzt={toc:[]},bzt="wrapper";function Nzt(t){let{components:n,...e}=t;return(0,s.kt)(bzt,(0,p.Z)({},Zzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Nzt.isMDXComponent=!0;const Azt={toc:[]},zzt="wrapper";function Wzt(t){let{components:n,...e}=t;return(0,s.kt)(zzt,(0,p.Z)({},Azt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Wzt.isMDXComponent=!0;const Izt={toc:[]},Rzt="wrapper";function Pzt(t){let{components:n,...e}=t;return(0,s.kt)(Rzt,(0,p.Z)({},Izt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Pzt.isMDXComponent=!0;const Szt={toc:[]},Ezt="wrapper";function Gzt(t){let{components:n,...e}=t;return(0,s.kt)(Ezt,(0,p.Z)({},Szt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Gzt.isMDXComponent=!0;const Ozt={toc:[]},Fzt="wrapper";function Bzt(t){let{components:n,...e}=t;return(0,s.kt)(Fzt,(0,p.Z)({},Ozt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Bzt.isMDXComponent=!0;const Uzt={toc:[]},Vzt="wrapper";function qzt(t){let{components:n,...e}=t;return(0,s.kt)(Vzt,(0,p.Z)({},Uzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}qzt.isMDXComponent=!0;const jzt={toc:[]},Yzt="wrapper";function Qzt(t){let{components:n,...e}=t;return(0,s.kt)(Yzt,(0,p.Z)({},jzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Qzt.isMDXComponent=!0;const Hzt={toc:[]},$zt="wrapper";function Kzt(t){let{components:n,...e}=t;return(0,s.kt)($zt,(0,p.Z)({},Hzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Grid, makeScene2D} from '@motion-canvas/2d';\nimport {all, createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const grid = createRef<Grid>();\n\n  view.add(\n    <Grid\n      ref={grid}\n      width={'100%'}\n      height={'100%'}\n      stroke={'#666'}\n      start={0}\n      end={1}\n    />,\n  );\n\n  yield* all(\n    grid().end(0.5, 1).to(1, 1).wait(1),\n    grid().start(0.5, 1).to(0, 1).wait(1),\n  );\n});\n")))}Kzt.isMDXComponent=!0;const Jzt={toc:[]},tWt="wrapper";function nWt(t){let{components:n,...e}=t;return(0,s.kt)(tWt,(0,p.Z)({},Jzt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a two-dimensional grid."))}nWt.isMDXComponent=!0;const eWt={toc:[]},oWt="wrapper";function pWt(t){let{components:n,...e}=t;return(0,s.kt)(oWt,(0,p.Z)({},eWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}pWt.isMDXComponent=!0;const rWt={toc:[]},sWt="wrapper";function cWt(t){let{components:n,...e}=t;return(0,s.kt)(sWt,(0,p.Z)({},rWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}cWt.isMDXComponent=!0;const iWt={toc:[]},aWt="wrapper";function lWt(t){let{components:n,...e}=t;return(0,s.kt)(aWt,(0,p.Z)({},iWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}lWt.isMDXComponent=!0;const uWt={toc:[]},mWt="wrapper";function dWt(t){let{components:n,...e}=t;return(0,s.kt)(mWt,(0,p.Z)({},uWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}dWt.isMDXComponent=!0;const hWt={toc:[]},kWt="wrapper";function fWt(t){let{components:n,...e}=t;return(0,s.kt)(kWt,(0,p.Z)({},hWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}fWt.isMDXComponent=!0;const yWt={toc:[]},MWt="wrapper";function DWt(t){let{components:n,...e}=t;return(0,s.kt)(MWt,(0,p.Z)({},yWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}DWt.isMDXComponent=!0;const XWt={toc:[]},_Wt="wrapper";function wWt(t){let{components:n,...e}=t;return(0,s.kt)(_Wt,(0,p.Z)({},XWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}wWt.isMDXComponent=!0;const TWt={toc:[]},CWt="wrapper";function gWt(t){let{components:n,...e}=t;return(0,s.kt)(CWt,(0,p.Z)({},TWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}gWt.isMDXComponent=!0;const xWt={toc:[]},vWt="wrapper";function LWt(t){let{components:n,...e}=t;return(0,s.kt)(vWt,(0,p.Z)({},xWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}LWt.isMDXComponent=!0;const ZWt={toc:[]},bWt="wrapper";function NWt(t){let{components:n,...e}=t;return(0,s.kt)(bWt,(0,p.Z)({},ZWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}NWt.isMDXComponent=!0;const AWt={toc:[]},zWt="wrapper";function WWt(t){let{components:n,...e}=t;return(0,s.kt)(zWt,(0,p.Z)({},AWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}WWt.isMDXComponent=!0;const IWt={toc:[]},RWt="wrapper";function PWt(t){let{components:n,...e}=t;return(0,s.kt)(RWt,(0,p.Z)({},IWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}PWt.isMDXComponent=!0;const SWt={toc:[]},EWt="wrapper";function GWt(t){let{components:n,...e}=t;return(0,s.kt)(EWt,(0,p.Z)({},SWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}GWt.isMDXComponent=!0;const OWt={toc:[]},FWt="wrapper";function BWt(t){let{components:n,...e}=t;return(0,s.kt)(FWt,(0,p.Z)({},OWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the end of each grid line."))}BWt.isMDXComponent=!0;const UWt={toc:[]},VWt="wrapper";function qWt(t){let{components:n,...e}=t;return(0,s.kt)(VWt,(0,p.Z)({},UWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}qWt.isMDXComponent=!0;const jWt={toc:[]},YWt="wrapper";function QWt(t){let{components:n,...e}=t;return(0,s.kt)(YWt,(0,p.Z)({},jWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}QWt.isMDXComponent=!0;const HWt={toc:[]},$Wt="wrapper";function KWt(t){let{components:n,...e}=t;return(0,s.kt)($Wt,(0,p.Z)({},HWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}KWt.isMDXComponent=!0;const JWt={toc:[]},tIt="wrapper";function nIt(t){let{components:n,...e}=t;return(0,s.kt)(tIt,(0,p.Z)({},JWt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}nIt.isMDXComponent=!0;const eIt={toc:[]},oIt="wrapper";function pIt(t){let{components:n,...e}=t;return(0,s.kt)(oIt,(0,p.Z)({},eIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}pIt.isMDXComponent=!0;const rIt={toc:[]},sIt="wrapper";function cIt(t){let{components:n,...e}=t;return(0,s.kt)(sIt,(0,p.Z)({},rIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}cIt.isMDXComponent=!0;const iIt={toc:[]},aIt="wrapper";function lIt(t){let{components:n,...e}=t;return(0,s.kt)(aIt,(0,p.Z)({},iIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}lIt.isMDXComponent=!0;const uIt={toc:[]},mIt="wrapper";function dIt(t){let{components:n,...e}=t;return(0,s.kt)(mIt,(0,p.Z)({},uIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}dIt.isMDXComponent=!0;const hIt={toc:[]},kIt="wrapper";function fIt(t){let{components:n,...e}=t;return(0,s.kt)(kIt,(0,p.Z)({},hIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}fIt.isMDXComponent=!0;const yIt={toc:[]},MIt="wrapper";function DIt(t){let{components:n,...e}=t;return(0,s.kt)(MIt,(0,p.Z)({},yIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}DIt.isMDXComponent=!0;const XIt={toc:[]},_It="wrapper";function wIt(t){let{components:n,...e}=t;return(0,s.kt)(_It,(0,p.Z)({},XIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}wIt.isMDXComponent=!0;const TIt={toc:[]},CIt="wrapper";function gIt(t){let{components:n,...e}=t;return(0,s.kt)(CIt,(0,p.Z)({},TIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}gIt.isMDXComponent=!0;const xIt={toc:[]},vIt="wrapper";function LIt(t){let{components:n,...e}=t;return(0,s.kt)(vIt,(0,p.Z)({},xIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}LIt.isMDXComponent=!0;const ZIt={toc:[]},bIt="wrapper";function NIt(t){let{components:n,...e}=t;return(0,s.kt)(bIt,(0,p.Z)({},ZIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}NIt.isMDXComponent=!0;const AIt={toc:[]},zIt="wrapper";function WIt(t){let{components:n,...e}=t;return(0,s.kt)(zIt,(0,p.Z)({},AIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}WIt.isMDXComponent=!0;const IIt={toc:[]},RIt="wrapper";function PIt(t){let{components:n,...e}=t;return(0,s.kt)(RIt,(0,p.Z)({},IIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}PIt.isMDXComponent=!0;const SIt={toc:[]},EIt="wrapper";function GIt(t){let{components:n,...e}=t;return(0,s.kt)(EIt,(0,p.Z)({},SIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}GIt.isMDXComponent=!0;const OIt={toc:[]},FIt="wrapper";function BIt(t){let{components:n,...e}=t;return(0,s.kt)(FIt,(0,p.Z)({},OIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}BIt.isMDXComponent=!0;const UIt={toc:[]},VIt="wrapper";function qIt(t){let{components:n,...e}=t;return(0,s.kt)(VIt,(0,p.Z)({},UIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}qIt.isMDXComponent=!0;const jIt={toc:[]},YIt="wrapper";function QIt(t){let{components:n,...e}=t;return(0,s.kt)(YIt,(0,p.Z)({},jIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}QIt.isMDXComponent=!0;const HIt={toc:[]},$It="wrapper";function KIt(t){let{components:n,...e}=t;return(0,s.kt)($It,(0,p.Z)({},HIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The spacing between the grid lines."))}KIt.isMDXComponent=!0;const JIt={toc:[]},tRt="wrapper";function nRt(t){let{components:n,...e}=t;return(0,s.kt)(tRt,(0,p.Z)({},JIt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}nRt.isMDXComponent=!0;const eRt={toc:[]},oRt="wrapper";function pRt(t){let{components:n,...e}=t;return(0,s.kt)(oRt,(0,p.Z)({},eRt,e,{components:n,mdxType:"MDXLayout"}))}pRt.isMDXComponent=!0;const rRt={toc:[]},sRt="wrapper";function cRt(t){let{components:n,...e}=t;return(0,s.kt)(sRt,(0,p.Z)({},rRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}cRt.isMDXComponent=!0;const iRt={toc:[]},aRt="wrapper";function lRt(t){let{components:n,...e}=t;return(0,s.kt)(aRt,(0,p.Z)({},iRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}lRt.isMDXComponent=!0;const uRt={toc:[]},mRt="wrapper";function dRt(t){let{components:n,...e}=t;return(0,s.kt)(mRt,(0,p.Z)({},uRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}dRt.isMDXComponent=!0;const hRt={toc:[]},kRt="wrapper";function fRt(t){let{components:n,...e}=t;return(0,s.kt)(kRt,(0,p.Z)({},hRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}fRt.isMDXComponent=!0;const yRt={toc:[]},MRt="wrapper";function DRt(t){let{components:n,...e}=t;return(0,s.kt)(MRt,(0,p.Z)({},yRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}DRt.isMDXComponent=!0;const XRt={toc:[]},_Rt="wrapper";function wRt(t){let{components:n,...e}=t;return(0,s.kt)(_Rt,(0,p.Z)({},XRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wRt.isMDXComponent=!0;const TRt={toc:[]},CRt="wrapper";function gRt(t){let{components:n,...e}=t;return(0,s.kt)(CRt,(0,p.Z)({},TRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}gRt.isMDXComponent=!0;const xRt={toc:[]},vRt="wrapper";function LRt(t){let{components:n,...e}=t;return(0,s.kt)(vRt,(0,p.Z)({},xRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}LRt.isMDXComponent=!0;const ZRt={toc:[]},bRt="wrapper";function NRt(t){let{components:n,...e}=t;return(0,s.kt)(bRt,(0,p.Z)({},ZRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}NRt.isMDXComponent=!0;const ARt={toc:[]},zRt="wrapper";function WRt(t){let{components:n,...e}=t;return(0,s.kt)(zRt,(0,p.Z)({},ARt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}WRt.isMDXComponent=!0;const IRt={toc:[]},RRt="wrapper";function PRt(t){let{components:n,...e}=t;return(0,s.kt)(RRt,(0,p.Z)({},IRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}PRt.isMDXComponent=!0;const SRt={toc:[]},ERt="wrapper";function GRt(t){let{components:n,...e}=t;return(0,s.kt)(ERt,(0,p.Z)({},SRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}GRt.isMDXComponent=!0;const ORt={toc:[]},FRt="wrapper";function BRt(t){let{components:n,...e}=t;return(0,s.kt)(FRt,(0,p.Z)({},ORt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}BRt.isMDXComponent=!0;const URt={toc:[]},VRt="wrapper";function qRt(t){let{components:n,...e}=t;return(0,s.kt)(VRt,(0,p.Z)({},URt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}qRt.isMDXComponent=!0;const jRt={toc:[]},YRt="wrapper";function QRt(t){let{components:n,...e}=t;return(0,s.kt)(YRt,(0,p.Z)({},jRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}QRt.isMDXComponent=!0;const HRt={toc:[]},$Rt="wrapper";function KRt(t){let{components:n,...e}=t;return(0,s.kt)($Rt,(0,p.Z)({},HRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}KRt.isMDXComponent=!0;const JRt={toc:[]},tPt="wrapper";function nPt(t){let{components:n,...e}=t;return(0,s.kt)(tPt,(0,p.Z)({},JRt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}nPt.isMDXComponent=!0;const ePt={toc:[]},oPt="wrapper";function pPt(t){let{components:n,...e}=t;return(0,s.kt)(oPt,(0,p.Z)({},ePt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}pPt.isMDXComponent=!0;const rPt={toc:[]},sPt="wrapper";function cPt(t){let{components:n,...e}=t;return(0,s.kt)(sPt,(0,p.Z)({},rPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}cPt.isMDXComponent=!0;const iPt={toc:[]},aPt="wrapper";function lPt(t){let{components:n,...e}=t;return(0,s.kt)(aPt,(0,p.Z)({},iPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lPt.isMDXComponent=!0;const uPt={toc:[]},mPt="wrapper";function dPt(t){let{components:n,...e}=t;return(0,s.kt)(mPt,(0,p.Z)({},uPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}dPt.isMDXComponent=!0;const hPt={toc:[]},kPt="wrapper";function fPt(t){let{components:n,...e}=t;return(0,s.kt)(kPt,(0,p.Z)({},hPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}fPt.isMDXComponent=!0;const yPt={toc:[]},MPt="wrapper";function DPt(t){let{components:n,...e}=t;return(0,s.kt)(MPt,(0,p.Z)({},yPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}DPt.isMDXComponent=!0;const XPt={toc:[]},_Pt="wrapper";function wPt(t){let{components:n,...e}=t;return(0,s.kt)(_Pt,(0,p.Z)({},XPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wPt.isMDXComponent=!0;const TPt={toc:[]},CPt="wrapper";function gPt(t){let{components:n,...e}=t;return(0,s.kt)(CPt,(0,p.Z)({},TPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}gPt.isMDXComponent=!0;const xPt={toc:[]},vPt="wrapper";function LPt(t){let{components:n,...e}=t;return(0,s.kt)(vPt,(0,p.Z)({},xPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}LPt.isMDXComponent=!0;const ZPt={toc:[]},bPt="wrapper";function NPt(t){let{components:n,...e}=t;return(0,s.kt)(bPt,(0,p.Z)({},ZPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}NPt.isMDXComponent=!0;const APt={toc:[]},zPt="wrapper";function WPt(t){let{components:n,...e}=t;return(0,s.kt)(zPt,(0,p.Z)({},APt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}WPt.isMDXComponent=!0;const IPt={toc:[]},RPt="wrapper";function PPt(t){let{components:n,...e}=t;return(0,s.kt)(RPt,(0,p.Z)({},IPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}PPt.isMDXComponent=!0;const SPt={toc:[]},EPt="wrapper";function GPt(t){let{components:n,...e}=t;return(0,s.kt)(EPt,(0,p.Z)({},SPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}GPt.isMDXComponent=!0;const OPt={toc:[]},FPt="wrapper";function BPt(t){let{components:n,...e}=t;return(0,s.kt)(FPt,(0,p.Z)({},OPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}BPt.isMDXComponent=!0;const UPt={toc:[]},VPt="wrapper";function qPt(t){let{components:n,...e}=t;return(0,s.kt)(VPt,(0,p.Z)({},UPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}qPt.isMDXComponent=!0;const jPt={toc:[]},YPt="wrapper";function QPt(t){let{components:n,...e}=t;return(0,s.kt)(YPt,(0,p.Z)({},jPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}QPt.isMDXComponent=!0;const HPt={toc:[]},$Pt="wrapper";function KPt(t){let{components:n,...e}=t;return(0,s.kt)($Pt,(0,p.Z)({},HPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}KPt.isMDXComponent=!0;const JPt={toc:[]},tSt="wrapper";function nSt(t){let{components:n,...e}=t;return(0,s.kt)(tSt,(0,p.Z)({},JPt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}nSt.isMDXComponent=!0;const eSt={toc:[]},oSt="wrapper";function pSt(t){let{components:n,...e}=t;return(0,s.kt)(oSt,(0,p.Z)({},eSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}pSt.isMDXComponent=!0;const rSt={toc:[]},sSt="wrapper";function cSt(t){let{components:n,...e}=t;return(0,s.kt)(sSt,(0,p.Z)({},rSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}cSt.isMDXComponent=!0;const iSt={toc:[]},aSt="wrapper";function lSt(t){let{components:n,...e}=t;return(0,s.kt)(aSt,(0,p.Z)({},iSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lSt.isMDXComponent=!0;const uSt={toc:[]},mSt="wrapper";function dSt(t){let{components:n,...e}=t;return(0,s.kt)(mSt,(0,p.Z)({},uSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}dSt.isMDXComponent=!0;const hSt={toc:[]},kSt="wrapper";function fSt(t){let{components:n,...e}=t;return(0,s.kt)(kSt,(0,p.Z)({},hSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}fSt.isMDXComponent=!0;const ySt={toc:[]},MSt="wrapper";function DSt(t){let{components:n,...e}=t;return(0,s.kt)(MSt,(0,p.Z)({},ySt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}DSt.isMDXComponent=!0;const XSt={toc:[]},_St="wrapper";function wSt(t){let{components:n,...e}=t;return(0,s.kt)(_St,(0,p.Z)({},XSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}wSt.isMDXComponent=!0;const TSt={toc:[]},CSt="wrapper";function gSt(t){let{components:n,...e}=t;return(0,s.kt)(CSt,(0,p.Z)({},TSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}gSt.isMDXComponent=!0;const xSt={toc:[]},vSt="wrapper";function LSt(t){let{components:n,...e}=t;return(0,s.kt)(vSt,(0,p.Z)({},xSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}LSt.isMDXComponent=!0;const ZSt={toc:[]},bSt="wrapper";function NSt(t){let{components:n,...e}=t;return(0,s.kt)(bSt,(0,p.Z)({},ZSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NSt.isMDXComponent=!0;const ASt={toc:[]},zSt="wrapper";function WSt(t){let{components:n,...e}=t;return(0,s.kt)(zSt,(0,p.Z)({},ASt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}WSt.isMDXComponent=!0;const ISt={toc:[]},RSt="wrapper";function PSt(t){let{components:n,...e}=t;return(0,s.kt)(RSt,(0,p.Z)({},ISt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}PSt.isMDXComponent=!0;const SSt={toc:[]},ESt="wrapper";function GSt(t){let{components:n,...e}=t;return(0,s.kt)(ESt,(0,p.Z)({},SSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}GSt.isMDXComponent=!0;const OSt={toc:[]},FSt="wrapper";function BSt(t){let{components:n,...e}=t;return(0,s.kt)(FSt,(0,p.Z)({},OSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}BSt.isMDXComponent=!0;const USt={toc:[]},VSt="wrapper";function qSt(t){let{components:n,...e}=t;return(0,s.kt)(VSt,(0,p.Z)({},USt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}qSt.isMDXComponent=!0;const jSt={toc:[]},YSt="wrapper";function QSt(t){let{components:n,...e}=t;return(0,s.kt)(YSt,(0,p.Z)({},jSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}QSt.isMDXComponent=!0;const HSt={toc:[]},$St="wrapper";function KSt(t){let{components:n,...e}=t;return(0,s.kt)($St,(0,p.Z)({},HSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}KSt.isMDXComponent=!0;const JSt={toc:[]},tEt="wrapper";function nEt(t){let{components:n,...e}=t;return(0,s.kt)(tEt,(0,p.Z)({},JSt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}nEt.isMDXComponent=!0;const eEt={toc:[]},oEt="wrapper";function pEt(t){let{components:n,...e}=t;return(0,s.kt)(oEt,(0,p.Z)({},eEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}pEt.isMDXComponent=!0;const rEt={toc:[]},sEt="wrapper";function cEt(t){let{components:n,...e}=t;return(0,s.kt)(sEt,(0,p.Z)({},rEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cEt.isMDXComponent=!0;const iEt={toc:[]},aEt="wrapper";function lEt(t){let{components:n,...e}=t;return(0,s.kt)(aEt,(0,p.Z)({},iEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lEt.isMDXComponent=!0;const uEt={toc:[]},mEt="wrapper";function dEt(t){let{components:n,...e}=t;return(0,s.kt)(mEt,(0,p.Z)({},uEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}dEt.isMDXComponent=!0;const hEt={toc:[]},kEt="wrapper";function fEt(t){let{components:n,...e}=t;return(0,s.kt)(kEt,(0,p.Z)({},hEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}fEt.isMDXComponent=!0;const yEt={toc:[]},MEt="wrapper";function DEt(t){let{components:n,...e}=t;return(0,s.kt)(MEt,(0,p.Z)({},yEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}DEt.isMDXComponent=!0;const XEt={toc:[]},_Et="wrapper";function wEt(t){let{components:n,...e}=t;return(0,s.kt)(_Et,(0,p.Z)({},XEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}wEt.isMDXComponent=!0;const TEt={toc:[]},CEt="wrapper";function gEt(t){let{components:n,...e}=t;return(0,s.kt)(CEt,(0,p.Z)({},TEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}gEt.isMDXComponent=!0;const xEt={toc:[]},vEt="wrapper";function LEt(t){let{components:n,...e}=t;return(0,s.kt)(vEt,(0,p.Z)({},xEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}LEt.isMDXComponent=!0;const ZEt={toc:[]},bEt="wrapper";function NEt(t){let{components:n,...e}=t;return(0,s.kt)(bEt,(0,p.Z)({},ZEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}NEt.isMDXComponent=!0;const AEt={toc:[]},zEt="wrapper";function WEt(t){let{components:n,...e}=t;return(0,s.kt)(zEt,(0,p.Z)({},AEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}WEt.isMDXComponent=!0;const IEt={toc:[]},REt="wrapper";function PEt(t){let{components:n,...e}=t;return(0,s.kt)(REt,(0,p.Z)({},IEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}PEt.isMDXComponent=!0;const SEt={toc:[]},EEt="wrapper";function GEt(t){let{components:n,...e}=t;return(0,s.kt)(EEt,(0,p.Z)({},SEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}GEt.isMDXComponent=!0;const OEt={toc:[]},FEt="wrapper";function BEt(t){let{components:n,...e}=t;return(0,s.kt)(FEt,(0,p.Z)({},OEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}BEt.isMDXComponent=!0;const UEt={toc:[]},VEt="wrapper";function qEt(t){let{components:n,...e}=t;return(0,s.kt)(VEt,(0,p.Z)({},UEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}qEt.isMDXComponent=!0;const jEt={toc:[]},YEt="wrapper";function QEt(t){let{components:n,...e}=t;return(0,s.kt)(YEt,(0,p.Z)({},jEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}QEt.isMDXComponent=!0;const HEt={toc:[]},$Et="wrapper";function KEt(t){let{components:n,...e}=t;return(0,s.kt)($Et,(0,p.Z)({},HEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}KEt.isMDXComponent=!0;const JEt={toc:[]},tGt="wrapper";function nGt(t){let{components:n,...e}=t;return(0,s.kt)(tGt,(0,p.Z)({},JEt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}nGt.isMDXComponent=!0;const eGt={toc:[]},oGt="wrapper";function pGt(t){let{components:n,...e}=t;return(0,s.kt)(oGt,(0,p.Z)({},eGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}pGt.isMDXComponent=!0;const rGt={toc:[]},sGt="wrapper";function cGt(t){let{components:n,...e}=t;return(0,s.kt)(sGt,(0,p.Z)({},rGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}cGt.isMDXComponent=!0;const iGt={toc:[]},aGt="wrapper";function lGt(t){let{components:n,...e}=t;return(0,s.kt)(aGt,(0,p.Z)({},iGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}lGt.isMDXComponent=!0;const uGt={toc:[]},mGt="wrapper";function dGt(t){let{components:n,...e}=t;return(0,s.kt)(mGt,(0,p.Z)({},uGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}dGt.isMDXComponent=!0;const hGt={toc:[]},kGt="wrapper";function fGt(t){let{components:n,...e}=t;return(0,s.kt)(kGt,(0,p.Z)({},hGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}fGt.isMDXComponent=!0;const yGt={toc:[]},MGt="wrapper";function DGt(t){let{components:n,...e}=t;return(0,s.kt)(MGt,(0,p.Z)({},yGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}DGt.isMDXComponent=!0;const XGt={toc:[]},_Gt="wrapper";function wGt(t){let{components:n,...e}=t;return(0,s.kt)(_Gt,(0,p.Z)({},XGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}wGt.isMDXComponent=!0;const TGt={toc:[]},CGt="wrapper";function gGt(t){let{components:n,...e}=t;return(0,s.kt)(CGt,(0,p.Z)({},TGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}gGt.isMDXComponent=!0;const xGt={toc:[]},vGt="wrapper";function LGt(t){let{components:n,...e}=t;return(0,s.kt)(vGt,(0,p.Z)({},xGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}LGt.isMDXComponent=!0;const ZGt={toc:[]},bGt="wrapper";function NGt(t){let{components:n,...e}=t;return(0,s.kt)(bGt,(0,p.Z)({},ZGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}NGt.isMDXComponent=!0;const AGt={toc:[]},zGt="wrapper";function WGt(t){let{components:n,...e}=t;return(0,s.kt)(zGt,(0,p.Z)({},AGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}WGt.isMDXComponent=!0;const IGt={toc:[]},RGt="wrapper";function PGt(t){let{components:n,...e}=t;return(0,s.kt)(RGt,(0,p.Z)({},IGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}PGt.isMDXComponent=!0;const SGt={toc:[]},EGt="wrapper";function GGt(t){let{components:n,...e}=t;return(0,s.kt)(EGt,(0,p.Z)({},SGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}GGt.isMDXComponent=!0;const OGt={toc:[]},FGt="wrapper";function BGt(t){let{components:n,...e}=t;return(0,s.kt)(FGt,(0,p.Z)({},OGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}BGt.isMDXComponent=!0;const UGt={toc:[]},VGt="wrapper";function qGt(t){let{components:n,...e}=t;return(0,s.kt)(VGt,(0,p.Z)({},UGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}qGt.isMDXComponent=!0;const jGt={toc:[]},YGt="wrapper";function QGt(t){let{components:n,...e}=t;return(0,s.kt)(YGt,(0,p.Z)({},jGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}QGt.isMDXComponent=!0;const HGt={toc:[]},$Gt="wrapper";function KGt(t){let{components:n,...e}=t;return(0,s.kt)($Gt,(0,p.Z)({},HGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}KGt.isMDXComponent=!0;const JGt={toc:[]},tOt="wrapper";function nOt(t){let{components:n,...e}=t;return(0,s.kt)(tOt,(0,p.Z)({},JGt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}nOt.isMDXComponent=!0;const eOt={toc:[]},oOt="wrapper";function pOt(t){let{components:n,...e}=t;return(0,s.kt)(oOt,(0,p.Z)({},eOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}pOt.isMDXComponent=!0;const rOt={toc:[]},sOt="wrapper";function cOt(t){let{components:n,...e}=t;return(0,s.kt)(sOt,(0,p.Z)({},rOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}cOt.isMDXComponent=!0;const iOt={toc:[]},aOt="wrapper";function lOt(t){let{components:n,...e}=t;return(0,s.kt)(aOt,(0,p.Z)({},iOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}lOt.isMDXComponent=!0;const uOt={toc:[]},mOt="wrapper";function dOt(t){let{components:n,...e}=t;return(0,s.kt)(mOt,(0,p.Z)({},uOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}dOt.isMDXComponent=!0;const hOt={toc:[]},kOt="wrapper";function fOt(t){let{components:n,...e}=t;return(0,s.kt)(kOt,(0,p.Z)({},hOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}fOt.isMDXComponent=!0;const yOt={toc:[]},MOt="wrapper";function DOt(t){let{components:n,...e}=t;return(0,s.kt)(MOt,(0,p.Z)({},yOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}DOt.isMDXComponent=!0;const XOt={toc:[]},_Ot="wrapper";function wOt(t){let{components:n,...e}=t;return(0,s.kt)(_Ot,(0,p.Z)({},XOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}wOt.isMDXComponent=!0;const TOt={toc:[]},COt="wrapper";function gOt(t){let{components:n,...e}=t;return(0,s.kt)(COt,(0,p.Z)({},TOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gOt.isMDXComponent=!0;const xOt={toc:[]},vOt="wrapper";function LOt(t){let{components:n,...e}=t;return(0,s.kt)(vOt,(0,p.Z)({},xOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}LOt.isMDXComponent=!0;const ZOt={toc:[]},bOt="wrapper";function NOt(t){let{components:n,...e}=t;return(0,s.kt)(bOt,(0,p.Z)({},ZOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}NOt.isMDXComponent=!0;const AOt={toc:[]},zOt="wrapper";function WOt(t){let{components:n,...e}=t;return(0,s.kt)(zOt,(0,p.Z)({},AOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}WOt.isMDXComponent=!0;const IOt={toc:[]},ROt="wrapper";function POt(t){let{components:n,...e}=t;return(0,s.kt)(ROt,(0,p.Z)({},IOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}POt.isMDXComponent=!0;const SOt={toc:[]},EOt="wrapper";function GOt(t){let{components:n,...e}=t;return(0,s.kt)(EOt,(0,p.Z)({},SOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}GOt.isMDXComponent=!0;const OOt={toc:[]},FOt="wrapper";function BOt(t){let{components:n,...e}=t;return(0,s.kt)(FOt,(0,p.Z)({},OOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}BOt.isMDXComponent=!0;const UOt={toc:[]},VOt="wrapper";function qOt(t){let{components:n,...e}=t;return(0,s.kt)(VOt,(0,p.Z)({},UOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}qOt.isMDXComponent=!0;const jOt={toc:[]},YOt="wrapper";function QOt(t){let{components:n,...e}=t;return(0,s.kt)(YOt,(0,p.Z)({},jOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}QOt.isMDXComponent=!0;const HOt={toc:[]},$Ot="wrapper";function KOt(t){let{components:n,...e}=t;return(0,s.kt)($Ot,(0,p.Z)({},HOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}KOt.isMDXComponent=!0;const JOt={toc:[]},tFt="wrapper";function nFt(t){let{components:n,...e}=t;return(0,s.kt)(tFt,(0,p.Z)({},JOt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}nFt.isMDXComponent=!0;const eFt={toc:[]},oFt="wrapper";function pFt(t){let{components:n,...e}=t;return(0,s.kt)(oFt,(0,p.Z)({},eFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}pFt.isMDXComponent=!0;const rFt={toc:[]},sFt="wrapper";function cFt(t){let{components:n,...e}=t;return(0,s.kt)(sFt,(0,p.Z)({},rFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}cFt.isMDXComponent=!0;const iFt={toc:[]},aFt="wrapper";function lFt(t){let{components:n,...e}=t;return(0,s.kt)(aFt,(0,p.Z)({},iFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}lFt.isMDXComponent=!0;const uFt={toc:[]},mFt="wrapper";function dFt(t){let{components:n,...e}=t;return(0,s.kt)(mFt,(0,p.Z)({},uFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}dFt.isMDXComponent=!0;const hFt={toc:[]},kFt="wrapper";function fFt(t){let{components:n,...e}=t;return(0,s.kt)(kFt,(0,p.Z)({},hFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}fFt.isMDXComponent=!0;const yFt={toc:[]},MFt="wrapper";function DFt(t){let{components:n,...e}=t;return(0,s.kt)(MFt,(0,p.Z)({},yFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}DFt.isMDXComponent=!0;const XFt={toc:[]},_Ft="wrapper";function wFt(t){let{components:n,...e}=t;return(0,s.kt)(_Ft,(0,p.Z)({},XFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}wFt.isMDXComponent=!0;const TFt={toc:[]},CFt="wrapper";function gFt(t){let{components:n,...e}=t;return(0,s.kt)(CFt,(0,p.Z)({},TFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}gFt.isMDXComponent=!0;const xFt={toc:[]},vFt="wrapper";function LFt(t){let{components:n,...e}=t;return(0,s.kt)(vFt,(0,p.Z)({},xFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}LFt.isMDXComponent=!0;const ZFt={toc:[]},bFt="wrapper";function NFt(t){let{components:n,...e}=t;return(0,s.kt)(bFt,(0,p.Z)({},ZFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}NFt.isMDXComponent=!0;const AFt={toc:[]},zFt="wrapper";function WFt(t){let{components:n,...e}=t;return(0,s.kt)(zFt,(0,p.Z)({},AFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}WFt.isMDXComponent=!0;const IFt={toc:[]},RFt="wrapper";function PFt(t){let{components:n,...e}=t;return(0,s.kt)(RFt,(0,p.Z)({},IFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}PFt.isMDXComponent=!0;const SFt={toc:[]},EFt="wrapper";function GFt(t){let{components:n,...e}=t;return(0,s.kt)(EFt,(0,p.Z)({},SFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}GFt.isMDXComponent=!0;const OFt={toc:[]},FFt="wrapper";function BFt(t){let{components:n,...e}=t;return(0,s.kt)(FFt,(0,p.Z)({},OFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}BFt.isMDXComponent=!0;const UFt={toc:[]},VFt="wrapper";function qFt(t){let{components:n,...e}=t;return(0,s.kt)(VFt,(0,p.Z)({},UFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qFt.isMDXComponent=!0;const jFt={toc:[]},YFt="wrapper";function QFt(t){let{components:n,...e}=t;return(0,s.kt)(YFt,(0,p.Z)({},jFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}QFt.isMDXComponent=!0;const HFt={toc:[]},$Ft="wrapper";function KFt(t){let{components:n,...e}=t;return(0,s.kt)($Ft,(0,p.Z)({},HFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}KFt.isMDXComponent=!0;const JFt={toc:[]},tBt="wrapper";function nBt(t){let{components:n,...e}=t;return(0,s.kt)(tBt,(0,p.Z)({},JFt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}nBt.isMDXComponent=!0;const eBt={toc:[]},oBt="wrapper";function pBt(t){let{components:n,...e}=t;return(0,s.kt)(oBt,(0,p.Z)({},eBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}pBt.isMDXComponent=!0;const rBt={toc:[]},sBt="wrapper";function cBt(t){let{components:n,...e}=t;return(0,s.kt)(sBt,(0,p.Z)({},rBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}cBt.isMDXComponent=!0;const iBt={toc:[]},aBt="wrapper";function lBt(t){let{components:n,...e}=t;return(0,s.kt)(aBt,(0,p.Z)({},iBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}lBt.isMDXComponent=!0;const uBt={toc:[]},mBt="wrapper";function dBt(t){let{components:n,...e}=t;return(0,s.kt)(mBt,(0,p.Z)({},uBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}dBt.isMDXComponent=!0;const hBt={toc:[]},kBt="wrapper";function fBt(t){let{components:n,...e}=t;return(0,s.kt)(kBt,(0,p.Z)({},hBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}fBt.isMDXComponent=!0;const yBt={toc:[]},MBt="wrapper";function DBt(t){let{components:n,...e}=t;return(0,s.kt)(MBt,(0,p.Z)({},yBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}DBt.isMDXComponent=!0;const XBt={toc:[]},_Bt="wrapper";function wBt(t){let{components:n,...e}=t;return(0,s.kt)(_Bt,(0,p.Z)({},XBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}wBt.isMDXComponent=!0;const TBt={toc:[]},CBt="wrapper";function gBt(t){let{components:n,...e}=t;return(0,s.kt)(CBt,(0,p.Z)({},TBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}gBt.isMDXComponent=!0;const xBt={toc:[]},vBt="wrapper";function LBt(t){let{components:n,...e}=t;return(0,s.kt)(vBt,(0,p.Z)({},xBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}LBt.isMDXComponent=!0;const ZBt={toc:[]},bBt="wrapper";function NBt(t){let{components:n,...e}=t;return(0,s.kt)(bBt,(0,p.Z)({},ZBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}NBt.isMDXComponent=!0;const ABt={toc:[]},zBt="wrapper";function WBt(t){let{components:n,...e}=t;return(0,s.kt)(zBt,(0,p.Z)({},ABt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}WBt.isMDXComponent=!0;const IBt={toc:[]},RBt="wrapper";function PBt(t){let{components:n,...e}=t;return(0,s.kt)(RBt,(0,p.Z)({},IBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}PBt.isMDXComponent=!0;const SBt={toc:[]},EBt="wrapper";function GBt(t){let{components:n,...e}=t;return(0,s.kt)(EBt,(0,p.Z)({},SBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}GBt.isMDXComponent=!0;const OBt={toc:[]},FBt="wrapper";function BBt(t){let{components:n,...e}=t;return(0,s.kt)(FBt,(0,p.Z)({},OBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}BBt.isMDXComponent=!0;const UBt={toc:[]},VBt="wrapper";function qBt(t){let{components:n,...e}=t;return(0,s.kt)(VBt,(0,p.Z)({},UBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qBt.isMDXComponent=!0;const jBt={toc:[]},YBt="wrapper";function QBt(t){let{components:n,...e}=t;return(0,s.kt)(YBt,(0,p.Z)({},jBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}QBt.isMDXComponent=!0;const HBt={toc:[]},$Bt="wrapper";function KBt(t){let{components:n,...e}=t;return(0,s.kt)($Bt,(0,p.Z)({},HBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}KBt.isMDXComponent=!0;const JBt={toc:[]},tUt="wrapper";function nUt(t){let{components:n,...e}=t;return(0,s.kt)(tUt,(0,p.Z)({},JBt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}nUt.isMDXComponent=!0;const eUt={toc:[]},oUt="wrapper";function pUt(t){let{components:n,...e}=t;return(0,s.kt)(oUt,(0,p.Z)({},eUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}pUt.isMDXComponent=!0;const rUt={toc:[]},sUt="wrapper";function cUt(t){let{components:n,...e}=t;return(0,s.kt)(sUt,(0,p.Z)({},rUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}cUt.isMDXComponent=!0;const iUt={toc:[]},aUt="wrapper";function lUt(t){let{components:n,...e}=t;return(0,s.kt)(aUt,(0,p.Z)({},iUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}lUt.isMDXComponent=!0;const uUt={toc:[]},mUt="wrapper";function dUt(t){let{components:n,...e}=t;return(0,s.kt)(mUt,(0,p.Z)({},uUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An Icon Component that provides easy access to over 150k icons.\nSee ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}dUt.isMDXComponent=!0;const hUt={toc:[]},kUt="wrapper";function fUt(t){let{components:n,...e}=t;return(0,s.kt)(kUt,(0,p.Z)({},hUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}fUt.isMDXComponent=!0;const yUt={toc:[]},MUt="wrapper";function DUt(t){let{components:n,...e}=t;return(0,s.kt)(MUt,(0,p.Z)({},yUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}DUt.isMDXComponent=!0;const XUt={toc:[]},_Ut="wrapper";function wUt(t){let{components:n,...e}=t;return(0,s.kt)(_Ut,(0,p.Z)({},XUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}wUt.isMDXComponent=!0;const TUt={toc:[]},CUt="wrapper";function gUt(t){let{components:n,...e}=t;return(0,s.kt)(CUt,(0,p.Z)({},TUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}gUt.isMDXComponent=!0;const xUt={toc:[]},vUt="wrapper";function LUt(t){let{components:n,...e}=t;return(0,s.kt)(vUt,(0,p.Z)({},xUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}LUt.isMDXComponent=!0;const ZUt={toc:[]},bUt="wrapper";function NUt(t){let{components:n,...e}=t;return(0,s.kt)(bUt,(0,p.Z)({},ZUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}NUt.isMDXComponent=!0;const AUt={toc:[]},zUt="wrapper";function WUt(t){let{components:n,...e}=t;return(0,s.kt)(zUt,(0,p.Z)({},AUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}WUt.isMDXComponent=!0;const IUt={toc:[]},RUt="wrapper";function PUt(t){let{components:n,...e}=t;return(0,s.kt)(RUt,(0,p.Z)({},IUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}PUt.isMDXComponent=!0;const SUt={toc:[]},EUt="wrapper";function GUt(t){let{components:n,...e}=t;return(0,s.kt)(EUt,(0,p.Z)({},SUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}GUt.isMDXComponent=!0;const OUt={toc:[]},FUt="wrapper";function BUt(t){let{components:n,...e}=t;return(0,s.kt)(FUt,(0,p.Z)({},OUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}BUt.isMDXComponent=!0;const UUt={toc:[]},VUt="wrapper";function qUt(t){let{components:n,...e}=t;return(0,s.kt)(VUt,(0,p.Z)({},UUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qUt.isMDXComponent=!0;const jUt={toc:[]},YUt="wrapper";function QUt(t){let{components:n,...e}=t;return(0,s.kt)(YUt,(0,p.Z)({},jUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}QUt.isMDXComponent=!0;const HUt={toc:[]},$Ut="wrapper";function KUt(t){let{components:n,...e}=t;return(0,s.kt)($Ut,(0,p.Z)({},HUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}KUt.isMDXComponent=!0;const JUt={toc:[]},tVt="wrapper";function nVt(t){let{components:n,...e}=t;return(0,s.kt)(tVt,(0,p.Z)({},JUt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}nVt.isMDXComponent=!0;const eVt={toc:[]},oVt="wrapper";function pVt(t){let{components:n,...e}=t;return(0,s.kt)(oVt,(0,p.Z)({},eVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}pVt.isMDXComponent=!0;const rVt={toc:[]},sVt="wrapper";function cVt(t){let{components:n,...e}=t;return(0,s.kt)(sVt,(0,p.Z)({},rVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}cVt.isMDXComponent=!0;const iVt={toc:[]},aVt="wrapper";function lVt(t){let{components:n,...e}=t;return(0,s.kt)(aVt,(0,p.Z)({},iVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}lVt.isMDXComponent=!0;const uVt={toc:[]},mVt="wrapper";function dVt(t){let{components:n,...e}=t;return(0,s.kt)(mVt,(0,p.Z)({},uVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}dVt.isMDXComponent=!0;const hVt={toc:[]},kVt="wrapper";function fVt(t){let{components:n,...e}=t;return(0,s.kt)(kVt,(0,p.Z)({},hVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}fVt.isMDXComponent=!0;const yVt={toc:[]},MVt="wrapper";function DVt(t){let{components:n,...e}=t;return(0,s.kt)(MVt,(0,p.Z)({},yVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"'white'"))}DVt.isMDXComponent=!0;const XVt={toc:[]},_Vt="wrapper";function wVt(t){let{components:n,...e}=t;return(0,s.kt)(_Vt,(0,p.Z)({},XVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}wVt.isMDXComponent=!0;const TVt={toc:[]},CVt="wrapper";function gVt(t){let{components:n,...e}=t;return(0,s.kt)(CVt,(0,p.Z)({},TVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}gVt.isMDXComponent=!0;const xVt={toc:[]},vVt="wrapper";function LVt(t){let{components:n,...e}=t;return(0,s.kt)(vVt,(0,p.Z)({},xVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}LVt.isMDXComponent=!0;const ZVt={toc:[]},bVt="wrapper";function NVt(t){let{components:n,...e}=t;return(0,s.kt)(bVt,(0,p.Z)({},ZVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}NVt.isMDXComponent=!0;const AVt={toc:[]},zVt="wrapper";function WVt(t){let{components:n,...e}=t;return(0,s.kt)(zVt,(0,p.Z)({},AVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}WVt.isMDXComponent=!0;const IVt={toc:[]},RVt="wrapper";function PVt(t){let{components:n,...e}=t;return(0,s.kt)(RVt,(0,p.Z)({},IVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}PVt.isMDXComponent=!0;const SVt={toc:[]},EVt="wrapper";function GVt(t){let{components:n,...e}=t;return(0,s.kt)(EVt,(0,p.Z)({},SVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}GVt.isMDXComponent=!0;const OVt={toc:[]},FVt="wrapper";function BVt(t){let{components:n,...e}=t;return(0,s.kt)(FVt,(0,p.Z)({},OVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}BVt.isMDXComponent=!0;const UVt={toc:[]},VVt="wrapper";function qVt(t){let{components:n,...e}=t;return(0,s.kt)(VVt,(0,p.Z)({},UVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}qVt.isMDXComponent=!0;const jVt={toc:[]},YVt="wrapper";function QVt(t){let{components:n,...e}=t;return(0,s.kt)(YVt,(0,p.Z)({},jVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}QVt.isMDXComponent=!0;const HVt={toc:[]},$Vt="wrapper";function KVt(t){let{components:n,...e}=t;return(0,s.kt)($Vt,(0,p.Z)({},HVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}KVt.isMDXComponent=!0;const JVt={toc:[]},tqt="wrapper";function nqt(t){let{components:n,...e}=t;return(0,s.kt)(tqt,(0,p.Z)({},JVt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}nqt.isMDXComponent=!0;const eqt={toc:[]},oqt="wrapper";function pqt(t){let{components:n,...e}=t;return(0,s.kt)(oqt,(0,p.Z)({},eqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}pqt.isMDXComponent=!0;const rqt={toc:[]},sqt="wrapper";function cqt(t){let{components:n,...e}=t;return(0,s.kt)(sqt,(0,p.Z)({},rqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}cqt.isMDXComponent=!0;const iqt={toc:[]},aqt="wrapper";function lqt(t){let{components:n,...e}=t;return(0,s.kt)(aqt,(0,p.Z)({},iqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}lqt.isMDXComponent=!0;const uqt={toc:[]},mqt="wrapper";function dqt(t){let{components:n,...e}=t;return(0,s.kt)(mqt,(0,p.Z)({},uqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}dqt.isMDXComponent=!0;const hqt={toc:[]},kqt="wrapper";function fqt(t){let{components:n,...e}=t;return(0,s.kt)(kqt,(0,p.Z)({},hqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}fqt.isMDXComponent=!0;const yqt={toc:[]},Mqt="wrapper";function Dqt(t){let{components:n,...e}=t;return(0,s.kt)(Mqt,(0,p.Z)({},yqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Dqt.isMDXComponent=!0;const Xqt={toc:[]},_qt="wrapper";function wqt(t){let{components:n,...e}=t;return(0,s.kt)(_qt,(0,p.Z)({},Xqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}wqt.isMDXComponent=!0;const Tqt={toc:[]},Cqt="wrapper";function gqt(t){let{components:n,...e}=t;return(0,s.kt)(Cqt,(0,p.Z)({},Tqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}gqt.isMDXComponent=!0;const xqt={toc:[]},vqt="wrapper";function Lqt(t){let{components:n,...e}=t;return(0,s.kt)(vqt,(0,p.Z)({},xqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Lqt.isMDXComponent=!0;const Zqt={toc:[]},bqt="wrapper";function Nqt(t){let{components:n,...e}=t;return(0,s.kt)(bqt,(0,p.Z)({},Zqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Nqt.isMDXComponent=!0;const Aqt={toc:[]},zqt="wrapper";function Wqt(t){let{components:n,...e}=t;return(0,s.kt)(zqt,(0,p.Z)({},Aqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Wqt.isMDXComponent=!0;const Iqt={toc:[]},Rqt="wrapper";function Pqt(t){let{components:n,...e}=t;return(0,s.kt)(Rqt,(0,p.Z)({},Iqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Pqt.isMDXComponent=!0;const Sqt={toc:[]},Eqt="wrapper";function Gqt(t){let{components:n,...e}=t;return(0,s.kt)(Eqt,(0,p.Z)({},Sqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Gqt.isMDXComponent=!0;const Oqt={toc:[]},Fqt="wrapper";function Bqt(t){let{components:n,...e}=t;return(0,s.kt)(Fqt,(0,p.Z)({},Oqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Bqt.isMDXComponent=!0;const Uqt={toc:[]},Vqt="wrapper";function qqt(t){let{components:n,...e}=t;return(0,s.kt)(Vqt,(0,p.Z)({},Uqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}qqt.isMDXComponent=!0;const jqt={toc:[]},Yqt="wrapper";function Qqt(t){let{components:n,...e}=t;return(0,s.kt)(Yqt,(0,p.Z)({},jqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Qqt.isMDXComponent=!0;const Hqt={toc:[]},$qt="wrapper";function Kqt(t){let{components:n,...e}=t;return(0,s.kt)($qt,(0,p.Z)({},Hqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Kqt.isMDXComponent=!0;const Jqt={toc:[]},tjt="wrapper";function njt(t){let{components:n,...e}=t;return(0,s.kt)(tjt,(0,p.Z)({},Jqt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}njt.isMDXComponent=!0;const ejt={toc:[]},ojt="wrapper";function pjt(t){let{components:n,...e}=t;return(0,s.kt)(ojt,(0,p.Z)({},ejt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}pjt.isMDXComponent=!0;const rjt={toc:[]},sjt="wrapper";function cjt(t){let{components:n,...e}=t;return(0,s.kt)(sjt,(0,p.Z)({},rjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}cjt.isMDXComponent=!0;const ijt={toc:[]},ajt="wrapper";function ljt(t){let{components:n,...e}=t;return(0,s.kt)(ajt,(0,p.Z)({},ijt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ljt.isMDXComponent=!0;const ujt={toc:[]},mjt="wrapper";function djt(t){let{components:n,...e}=t;return(0,s.kt)(mjt,(0,p.Z)({},ujt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}djt.isMDXComponent=!0;const hjt={toc:[]},kjt="wrapper";function fjt(t){let{components:n,...e}=t;return(0,s.kt)(kjt,(0,p.Z)({},hjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}fjt.isMDXComponent=!0;const yjt={toc:[]},Mjt="wrapper";function Djt(t){let{components:n,...e}=t;return(0,s.kt)(Mjt,(0,p.Z)({},yjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Djt.isMDXComponent=!0;const Xjt={toc:[]},_jt="wrapper";function wjt(t){let{components:n,...e}=t;return(0,s.kt)(_jt,(0,p.Z)({},Xjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}wjt.isMDXComponent=!0;const Tjt={toc:[]},Cjt="wrapper";function gjt(t){let{components:n,...e}=t;return(0,s.kt)(Cjt,(0,p.Z)({},Tjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}gjt.isMDXComponent=!0;const xjt={toc:[]},vjt="wrapper";function Ljt(t){let{components:n,...e}=t;return(0,s.kt)(vjt,(0,p.Z)({},xjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Ljt.isMDXComponent=!0;const Zjt={toc:[]},bjt="wrapper";function Njt(t){let{components:n,...e}=t;return(0,s.kt)(bjt,(0,p.Z)({},Zjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Njt.isMDXComponent=!0;const Ajt={toc:[]},zjt="wrapper";function Wjt(t){let{components:n,...e}=t;return(0,s.kt)(zjt,(0,p.Z)({},Ajt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Wjt.isMDXComponent=!0;const Ijt={toc:[]},Rjt="wrapper";function Pjt(t){let{components:n,...e}=t;return(0,s.kt)(Rjt,(0,p.Z)({},Ijt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Pjt.isMDXComponent=!0;const Sjt={toc:[]},Ejt="wrapper";function Gjt(t){let{components:n,...e}=t;return(0,s.kt)(Ejt,(0,p.Z)({},Sjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Gjt.isMDXComponent=!0;const Ojt={toc:[]},Fjt="wrapper";function Bjt(t){let{components:n,...e}=t;return(0,s.kt)(Fjt,(0,p.Z)({},Ojt,e,{components:n,mdxType:"MDXLayout"}))}Bjt.isMDXComponent=!0;const Ujt={toc:[]},Vjt="wrapper";function qjt(t){let{components:n,...e}=t;return(0,s.kt)(Vjt,(0,p.Z)({},Ujt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}qjt.isMDXComponent=!0;const jjt={toc:[]},Yjt="wrapper";function Qjt(t){let{components:n,...e}=t;return(0,s.kt)(Yjt,(0,p.Z)({},jjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Qjt.isMDXComponent=!0;const Hjt={toc:[]},$jt="wrapper";function Kjt(t){let{components:n,...e}=t;return(0,s.kt)($jt,(0,p.Z)({},Hjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Kjt.isMDXComponent=!0;const Jjt={toc:[]},tYt="wrapper";function nYt(t){let{components:n,...e}=t;return(0,s.kt)(tYt,(0,p.Z)({},Jjt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}nYt.isMDXComponent=!0;const eYt={toc:[]},oYt="wrapper";function pYt(t){let{components:n,...e}=t;return(0,s.kt)(oYt,(0,p.Z)({},eYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pYt.isMDXComponent=!0;const rYt={toc:[]},sYt="wrapper";function cYt(t){let{components:n,...e}=t;return(0,s.kt)(sYt,(0,p.Z)({},rYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}cYt.isMDXComponent=!0;const iYt={toc:[]},aYt="wrapper";function lYt(t){let{components:n,...e}=t;return(0,s.kt)(aYt,(0,p.Z)({},iYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lYt.isMDXComponent=!0;const uYt={toc:[]},mYt="wrapper";function dYt(t){let{components:n,...e}=t;return(0,s.kt)(mYt,(0,p.Z)({},uYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}dYt.isMDXComponent=!0;const hYt={toc:[]},kYt="wrapper";function fYt(t){let{components:n,...e}=t;return(0,s.kt)(kYt,(0,p.Z)({},hYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}fYt.isMDXComponent=!0;const yYt={toc:[]},MYt="wrapper";function DYt(t){let{components:n,...e}=t;return(0,s.kt)(MYt,(0,p.Z)({},yYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}DYt.isMDXComponent=!0;const XYt={toc:[]},_Yt="wrapper";function wYt(t){let{components:n,...e}=t;return(0,s.kt)(_Yt,(0,p.Z)({},XYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}wYt.isMDXComponent=!0;const TYt={toc:[]},CYt="wrapper";function gYt(t){let{components:n,...e}=t;return(0,s.kt)(CYt,(0,p.Z)({},TYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}gYt.isMDXComponent=!0;const xYt={toc:[]},vYt="wrapper";function LYt(t){let{components:n,...e}=t;return(0,s.kt)(vYt,(0,p.Z)({},xYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}LYt.isMDXComponent=!0;const ZYt={toc:[]},bYt="wrapper";function NYt(t){let{components:n,...e}=t;return(0,s.kt)(bYt,(0,p.Z)({},ZYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}NYt.isMDXComponent=!0;const AYt={toc:[]},zYt="wrapper";function WYt(t){let{components:n,...e}=t;return(0,s.kt)(zYt,(0,p.Z)({},AYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}WYt.isMDXComponent=!0;const IYt={toc:[]},RYt="wrapper";function PYt(t){let{components:n,...e}=t;return(0,s.kt)(RYt,(0,p.Z)({},IYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}PYt.isMDXComponent=!0;const SYt={toc:[]},EYt="wrapper";function GYt(t){let{components:n,...e}=t;return(0,s.kt)(EYt,(0,p.Z)({},SYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}GYt.isMDXComponent=!0;const OYt={toc:[]},FYt="wrapper";function BYt(t){let{components:n,...e}=t;return(0,s.kt)(FYt,(0,p.Z)({},OYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}BYt.isMDXComponent=!0;const UYt={toc:[]},VYt="wrapper";function qYt(t){let{components:n,...e}=t;return(0,s.kt)(VYt,(0,p.Z)({},UYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}qYt.isMDXComponent=!0;const jYt={toc:[]},YYt="wrapper";function QYt(t){let{components:n,...e}=t;return(0,s.kt)(YYt,(0,p.Z)({},jYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}QYt.isMDXComponent=!0;const HYt={toc:[]},$Yt="wrapper";function KYt(t){let{components:n,...e}=t;return(0,s.kt)($Yt,(0,p.Z)({},HYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}KYt.isMDXComponent=!0;const JYt={toc:[]},tQt="wrapper";function nQt(t){let{components:n,...e}=t;return(0,s.kt)(tQt,(0,p.Z)({},JYt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}nQt.isMDXComponent=!0;const eQt={toc:[]},oQt="wrapper";function pQt(t){let{components:n,...e}=t;return(0,s.kt)(oQt,(0,p.Z)({},eQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}pQt.isMDXComponent=!0;const rQt={toc:[]},sQt="wrapper";function cQt(t){let{components:n,...e}=t;return(0,s.kt)(sQt,(0,p.Z)({},rQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}cQt.isMDXComponent=!0;const iQt={toc:[]},aQt="wrapper";function lQt(t){let{components:n,...e}=t;return(0,s.kt)(aQt,(0,p.Z)({},iQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}lQt.isMDXComponent=!0;const uQt={toc:[]},mQt="wrapper";function dQt(t){let{components:n,...e}=t;return(0,s.kt)(mQt,(0,p.Z)({},uQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}dQt.isMDXComponent=!0;const hQt={toc:[]},kQt="wrapper";function fQt(t){let{components:n,...e}=t;return(0,s.kt)(kQt,(0,p.Z)({},hQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}fQt.isMDXComponent=!0;const yQt={toc:[]},MQt="wrapper";function DQt(t){let{components:n,...e}=t;return(0,s.kt)(MQt,(0,p.Z)({},yQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}DQt.isMDXComponent=!0;const XQt={toc:[]},_Qt="wrapper";function wQt(t){let{components:n,...e}=t;return(0,s.kt)(_Qt,(0,p.Z)({},XQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}wQt.isMDXComponent=!0;const TQt={toc:[]},CQt="wrapper";function gQt(t){let{components:n,...e}=t;return(0,s.kt)(CQt,(0,p.Z)({},TQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}gQt.isMDXComponent=!0;const xQt={toc:[]},vQt="wrapper";function LQt(t){let{components:n,...e}=t;return(0,s.kt)(vQt,(0,p.Z)({},xQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}LQt.isMDXComponent=!0;const ZQt={toc:[]},bQt="wrapper";function NQt(t){let{components:n,...e}=t;return(0,s.kt)(bQt,(0,p.Z)({},ZQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}NQt.isMDXComponent=!0;const AQt={toc:[]},zQt="wrapper";function WQt(t){let{components:n,...e}=t;return(0,s.kt)(zQt,(0,p.Z)({},AQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}WQt.isMDXComponent=!0;const IQt={toc:[]},RQt="wrapper";function PQt(t){let{components:n,...e}=t;return(0,s.kt)(RQt,(0,p.Z)({},IQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}PQt.isMDXComponent=!0;const SQt={toc:[]},EQt="wrapper";function GQt(t){let{components:n,...e}=t;return(0,s.kt)(EQt,(0,p.Z)({},SQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}GQt.isMDXComponent=!0;const OQt={toc:[]},FQt="wrapper";function BQt(t){let{components:n,...e}=t;return(0,s.kt)(FQt,(0,p.Z)({},OQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}BQt.isMDXComponent=!0;const UQt={toc:[]},VQt="wrapper";function qQt(t){let{components:n,...e}=t;return(0,s.kt)(VQt,(0,p.Z)({},UQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}qQt.isMDXComponent=!0;const jQt={toc:[]},YQt="wrapper";function QQt(t){let{components:n,...e}=t;return(0,s.kt)(YQt,(0,p.Z)({},jQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}QQt.isMDXComponent=!0;const HQt={toc:[]},$Qt="wrapper";function KQt(t){let{components:n,...e}=t;return(0,s.kt)($Qt,(0,p.Z)({},HQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}KQt.isMDXComponent=!0;const JQt={toc:[]},tHt="wrapper";function nHt(t){let{components:n,...e}=t;return(0,s.kt)(tHt,(0,p.Z)({},JQt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}nHt.isMDXComponent=!0;const eHt={toc:[]},oHt="wrapper";function pHt(t){let{components:n,...e}=t;return(0,s.kt)(oHt,(0,p.Z)({},eHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}pHt.isMDXComponent=!0;const rHt={toc:[]},sHt="wrapper";function cHt(t){let{components:n,...e}=t;return(0,s.kt)(sHt,(0,p.Z)({},rHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}cHt.isMDXComponent=!0;const iHt={toc:[]},aHt="wrapper";function lHt(t){let{components:n,...e}=t;return(0,s.kt)(aHt,(0,p.Z)({},iHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}lHt.isMDXComponent=!0;const uHt={toc:[]},mHt="wrapper";function dHt(t){let{components:n,...e}=t;return(0,s.kt)(mHt,(0,p.Z)({},uHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}dHt.isMDXComponent=!0;const hHt={toc:[]},kHt="wrapper";function fHt(t){let{components:n,...e}=t;return(0,s.kt)(kHt,(0,p.Z)({},hHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}fHt.isMDXComponent=!0;const yHt={toc:[]},MHt="wrapper";function DHt(t){let{components:n,...e}=t;return(0,s.kt)(MHt,(0,p.Z)({},yHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}DHt.isMDXComponent=!0;const XHt={toc:[]},_Ht="wrapper";function wHt(t){let{components:n,...e}=t;return(0,s.kt)(_Ht,(0,p.Z)({},XHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}wHt.isMDXComponent=!0;const THt={toc:[]},CHt="wrapper";function gHt(t){let{components:n,...e}=t;return(0,s.kt)(CHt,(0,p.Z)({},THt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}gHt.isMDXComponent=!0;const xHt={toc:[]},vHt="wrapper";function LHt(t){let{components:n,...e}=t;return(0,s.kt)(vHt,(0,p.Z)({},xHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}LHt.isMDXComponent=!0;const ZHt={toc:[]},bHt="wrapper";function NHt(t){let{components:n,...e}=t;return(0,s.kt)(bHt,(0,p.Z)({},ZHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}NHt.isMDXComponent=!0;const AHt={toc:[]},zHt="wrapper";function WHt(t){let{components:n,...e}=t;return(0,s.kt)(zHt,(0,p.Z)({},AHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}WHt.isMDXComponent=!0;const IHt={toc:[]},RHt="wrapper";function PHt(t){let{components:n,...e}=t;return(0,s.kt)(RHt,(0,p.Z)({},IHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}PHt.isMDXComponent=!0;const SHt={toc:[]},EHt="wrapper";function GHt(t){let{components:n,...e}=t;return(0,s.kt)(EHt,(0,p.Z)({},SHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}GHt.isMDXComponent=!0;const OHt={toc:[]},FHt="wrapper";function BHt(t){let{components:n,...e}=t;return(0,s.kt)(FHt,(0,p.Z)({},OHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}BHt.isMDXComponent=!0;const UHt={toc:[]},VHt="wrapper";function qHt(t){let{components:n,...e}=t;return(0,s.kt)(VHt,(0,p.Z)({},UHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}qHt.isMDXComponent=!0;const jHt={toc:[]},YHt="wrapper";function QHt(t){let{components:n,...e}=t;return(0,s.kt)(YHt,(0,p.Z)({},jHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}QHt.isMDXComponent=!0;const HHt={toc:[]},$Ht="wrapper";function KHt(t){let{components:n,...e}=t;return(0,s.kt)($Ht,(0,p.Z)({},HHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}KHt.isMDXComponent=!0;const JHt={toc:[]},t$t="wrapper";function n$t(t){let{components:n,...e}=t;return(0,s.kt)(t$t,(0,p.Z)({},JHt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}n$t.isMDXComponent=!0;const e$t={toc:[]},o$t="wrapper";function p$t(t){let{components:n,...e}=t;return(0,s.kt)(o$t,(0,p.Z)({},e$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}p$t.isMDXComponent=!0;const r$t={toc:[]},s$t="wrapper";function c$t(t){let{components:n,...e}=t;return(0,s.kt)(s$t,(0,p.Z)({},r$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}c$t.isMDXComponent=!0;const i$t={toc:[]},a$t="wrapper";function l$t(t){let{components:n,...e}=t;return(0,s.kt)(a$t,(0,p.Z)({},i$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}l$t.isMDXComponent=!0;const u$t={toc:[]},m$t="wrapper";function d$t(t){let{components:n,...e}=t;return(0,s.kt)(m$t,(0,p.Z)({},u$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}d$t.isMDXComponent=!0;const h$t={toc:[]},k$t="wrapper";function f$t(t){let{components:n,...e}=t;return(0,s.kt)(k$t,(0,p.Z)({},h$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}f$t.isMDXComponent=!0;const y$t={toc:[]},M$t="wrapper";function D$t(t){let{components:n,...e}=t;return(0,s.kt)(M$t,(0,p.Z)({},y$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}D$t.isMDXComponent=!0;const X$t={toc:[]},_$t="wrapper";function w$t(t){let{components:n,...e}=t;return(0,s.kt)(_$t,(0,p.Z)({},X$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}w$t.isMDXComponent=!0;const T$t={toc:[]},C$t="wrapper";function g$t(t){let{components:n,...e}=t;return(0,s.kt)(C$t,(0,p.Z)({},T$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}g$t.isMDXComponent=!0;const x$t={toc:[]},v$t="wrapper";function L$t(t){let{components:n,...e}=t;return(0,s.kt)(v$t,(0,p.Z)({},x$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}L$t.isMDXComponent=!0;const Z$t={toc:[]},b$t="wrapper";function N$t(t){let{components:n,...e}=t;return(0,s.kt)(b$t,(0,p.Z)({},Z$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}N$t.isMDXComponent=!0;const A$t={toc:[]},z$t="wrapper";function W$t(t){let{components:n,...e}=t;return(0,s.kt)(z$t,(0,p.Z)({},A$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}W$t.isMDXComponent=!0;const I$t={toc:[]},R$t="wrapper";function P$t(t){let{components:n,...e}=t;return(0,s.kt)(R$t,(0,p.Z)({},I$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}P$t.isMDXComponent=!0;const S$t={toc:[]},E$t="wrapper";function G$t(t){let{components:n,...e}=t;return(0,s.kt)(E$t,(0,p.Z)({},S$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}G$t.isMDXComponent=!0;const O$t={toc:[]},F$t="wrapper";function B$t(t){let{components:n,...e}=t;return(0,s.kt)(F$t,(0,p.Z)({},O$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}B$t.isMDXComponent=!0;const U$t={toc:[]},V$t="wrapper";function q$t(t){let{components:n,...e}=t;return(0,s.kt)(V$t,(0,p.Z)({},U$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}q$t.isMDXComponent=!0;const j$t={toc:[]},Y$t="wrapper";function Q$t(t){let{components:n,...e}=t;return(0,s.kt)(Y$t,(0,p.Z)({},j$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Q$t.isMDXComponent=!0;const H$t={toc:[]},$$t="wrapper";function K$t(t){let{components:n,...e}=t;return(0,s.kt)($$t,(0,p.Z)({},H$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}K$t.isMDXComponent=!0;const J$t={toc:[]},tKt="wrapper";function nKt(t){let{components:n,...e}=t;return(0,s.kt)(tKt,(0,p.Z)({},J$t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}nKt.isMDXComponent=!0;const eKt={toc:[]},oKt="wrapper";function pKt(t){let{components:n,...e}=t;return(0,s.kt)(oKt,(0,p.Z)({},eKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}pKt.isMDXComponent=!0;const rKt={toc:[]},sKt="wrapper";function cKt(t){let{components:n,...e}=t;return(0,s.kt)(sKt,(0,p.Z)({},rKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}cKt.isMDXComponent=!0;const iKt={toc:[]},aKt="wrapper";function lKt(t){let{components:n,...e}=t;return(0,s.kt)(aKt,(0,p.Z)({},iKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}lKt.isMDXComponent=!0;const uKt={toc:[]},mKt="wrapper";function dKt(t){let{components:n,...e}=t;return(0,s.kt)(mKt,(0,p.Z)({},uKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}dKt.isMDXComponent=!0;const hKt={toc:[]},kKt="wrapper";function fKt(t){let{components:n,...e}=t;return(0,s.kt)(kKt,(0,p.Z)({},hKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}fKt.isMDXComponent=!0;const yKt={toc:[]},MKt="wrapper";function DKt(t){let{components:n,...e}=t;return(0,s.kt)(MKt,(0,p.Z)({},yKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}DKt.isMDXComponent=!0;const XKt={toc:[]},_Kt="wrapper";function wKt(t){let{components:n,...e}=t;return(0,s.kt)(_Kt,(0,p.Z)({},XKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}wKt.isMDXComponent=!0;const TKt={toc:[]},CKt="wrapper";function gKt(t){let{components:n,...e}=t;return(0,s.kt)(CKt,(0,p.Z)({},TKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}gKt.isMDXComponent=!0;const xKt={toc:[]},vKt="wrapper";function LKt(t){let{components:n,...e}=t;return(0,s.kt)(vKt,(0,p.Z)({},xKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}LKt.isMDXComponent=!0;const ZKt={toc:[]},bKt="wrapper";function NKt(t){let{components:n,...e}=t;return(0,s.kt)(bKt,(0,p.Z)({},ZKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}NKt.isMDXComponent=!0;const AKt={toc:[]},zKt="wrapper";function WKt(t){let{components:n,...e}=t;return(0,s.kt)(zKt,(0,p.Z)({},AKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}WKt.isMDXComponent=!0;const IKt={toc:[]},RKt="wrapper";function PKt(t){let{components:n,...e}=t;return(0,s.kt)(RKt,(0,p.Z)({},IKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}PKt.isMDXComponent=!0;const SKt={toc:[]},EKt="wrapper";function GKt(t){let{components:n,...e}=t;return(0,s.kt)(EKt,(0,p.Z)({},SKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}GKt.isMDXComponent=!0;const OKt={toc:[]},FKt="wrapper";function BKt(t){let{components:n,...e}=t;return(0,s.kt)(FKt,(0,p.Z)({},OKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}BKt.isMDXComponent=!0;const UKt={toc:[]},VKt="wrapper";function qKt(t){let{components:n,...e}=t;return(0,s.kt)(VKt,(0,p.Z)({},UKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}qKt.isMDXComponent=!0;const jKt={toc:[]},YKt="wrapper";function QKt(t){let{components:n,...e}=t;return(0,s.kt)(YKt,(0,p.Z)({},jKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}QKt.isMDXComponent=!0;const HKt={toc:[]},$Kt="wrapper";function KKt(t){let{components:n,...e}=t;return(0,s.kt)($Kt,(0,p.Z)({},HKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}KKt.isMDXComponent=!0;const JKt={toc:[]},tJt="wrapper";function nJt(t){let{components:n,...e}=t;return(0,s.kt)(tJt,(0,p.Z)({},JKt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}nJt.isMDXComponent=!0;const eJt={toc:[]},oJt="wrapper";function pJt(t){let{components:n,...e}=t;return(0,s.kt)(oJt,(0,p.Z)({},eJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}pJt.isMDXComponent=!0;const rJt={toc:[]},sJt="wrapper";function cJt(t){let{components:n,...e}=t;return(0,s.kt)(sJt,(0,p.Z)({},rJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}cJt.isMDXComponent=!0;const iJt={toc:[]},aJt="wrapper";function lJt(t){let{components:n,...e}=t;return(0,s.kt)(aJt,(0,p.Z)({},iJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}lJt.isMDXComponent=!0;const uJt={toc:[]},mJt="wrapper";function dJt(t){let{components:n,...e}=t;return(0,s.kt)(mJt,(0,p.Z)({},uJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}dJt.isMDXComponent=!0;const hJt={toc:[]},kJt="wrapper";function fJt(t){let{components:n,...e}=t;return(0,s.kt)(kJt,(0,p.Z)({},hJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}fJt.isMDXComponent=!0;const yJt={toc:[]},MJt="wrapper";function DJt(t){let{components:n,...e}=t;return(0,s.kt)(MJt,(0,p.Z)({},yJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}DJt.isMDXComponent=!0;const XJt={toc:[]},_Jt="wrapper";function wJt(t){let{components:n,...e}=t;return(0,s.kt)(_Jt,(0,p.Z)({},XJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}wJt.isMDXComponent=!0;const TJt={toc:[]},CJt="wrapper";function gJt(t){let{components:n,...e}=t;return(0,s.kt)(CJt,(0,p.Z)({},TJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}gJt.isMDXComponent=!0;const xJt={toc:[]},vJt="wrapper";function LJt(t){let{components:n,...e}=t;return(0,s.kt)(vJt,(0,p.Z)({},xJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}LJt.isMDXComponent=!0;const ZJt={toc:[]},bJt="wrapper";function NJt(t){let{components:n,...e}=t;return(0,s.kt)(bJt,(0,p.Z)({},ZJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}NJt.isMDXComponent=!0;const AJt={toc:[]},zJt="wrapper";function WJt(t){let{components:n,...e}=t;return(0,s.kt)(zJt,(0,p.Z)({},AJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}WJt.isMDXComponent=!0;const IJt={toc:[]},RJt="wrapper";function PJt(t){let{components:n,...e}=t;return(0,s.kt)(RJt,(0,p.Z)({},IJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}PJt.isMDXComponent=!0;const SJt={toc:[]},EJt="wrapper";function GJt(t){let{components:n,...e}=t;return(0,s.kt)(EJt,(0,p.Z)({},SJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}GJt.isMDXComponent=!0;const OJt={toc:[]},FJt="wrapper";function BJt(t){let{components:n,...e}=t;return(0,s.kt)(FJt,(0,p.Z)({},OJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}BJt.isMDXComponent=!0;const UJt={toc:[]},VJt="wrapper";function qJt(t){let{components:n,...e}=t;return(0,s.kt)(VJt,(0,p.Z)({},UJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}qJt.isMDXComponent=!0;const jJt={toc:[]},YJt="wrapper";function QJt(t){let{components:n,...e}=t;return(0,s.kt)(YJt,(0,p.Z)({},jJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}QJt.isMDXComponent=!0;const HJt={toc:[]},$Jt="wrapper";function KJt(t){let{components:n,...e}=t;return(0,s.kt)($Jt,(0,p.Z)({},HJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}KJt.isMDXComponent=!0;const JJt={toc:[]},t0t="wrapper";function n0t(t){let{components:n,...e}=t;return(0,s.kt)(t0t,(0,p.Z)({},JJt,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}n0t.isMDXComponent=!0;const e0t={toc:[]},o0t="wrapper";function p0t(t){let{components:n,...e}=t;return(0,s.kt)(o0t,(0,p.Z)({},e0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}p0t.isMDXComponent=!0;const r0t={toc:[]},s0t="wrapper";function c0t(t){let{components:n,...e}=t;return(0,s.kt)(s0t,(0,p.Z)({},r0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}c0t.isMDXComponent=!0;const i0t={toc:[]},a0t="wrapper";function l0t(t){let{components:n,...e}=t;return(0,s.kt)(a0t,(0,p.Z)({},i0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}l0t.isMDXComponent=!0;const u0t={toc:[]},m0t="wrapper";function d0t(t){let{components:n,...e}=t;return(0,s.kt)(m0t,(0,p.Z)({},u0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}d0t.isMDXComponent=!0;const h0t={toc:[]},k0t="wrapper";function f0t(t){let{components:n,...e}=t;return(0,s.kt)(k0t,(0,p.Z)({},h0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}f0t.isMDXComponent=!0;const y0t={toc:[]},M0t="wrapper";function D0t(t){let{components:n,...e}=t;return(0,s.kt)(M0t,(0,p.Z)({},y0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}D0t.isMDXComponent=!0;const X0t={toc:[]},_0t="wrapper";function w0t(t){let{components:n,...e}=t;return(0,s.kt)(_0t,(0,p.Z)({},X0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}w0t.isMDXComponent=!0;const T0t={toc:[]},C0t="wrapper";function g0t(t){let{components:n,...e}=t;return(0,s.kt)(C0t,(0,p.Z)({},T0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}g0t.isMDXComponent=!0;const x0t={toc:[]},v0t="wrapper";function L0t(t){let{components:n,...e}=t;return(0,s.kt)(v0t,(0,p.Z)({},x0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}L0t.isMDXComponent=!0;const Z0t={toc:[]},b0t="wrapper";function N0t(t){let{components:n,...e}=t;return(0,s.kt)(b0t,(0,p.Z)({},Z0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}N0t.isMDXComponent=!0;const A0t={toc:[]},z0t="wrapper";function W0t(t){let{components:n,...e}=t;return(0,s.kt)(z0t,(0,p.Z)({},A0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}W0t.isMDXComponent=!0;const I0t={toc:[]},R0t="wrapper";function P0t(t){let{components:n,...e}=t;return(0,s.kt)(R0t,(0,p.Z)({},I0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}P0t.isMDXComponent=!0;const S0t={toc:[]},E0t="wrapper";function G0t(t){let{components:n,...e}=t;return(0,s.kt)(E0t,(0,p.Z)({},S0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}G0t.isMDXComponent=!0;const O0t={toc:[]},F0t="wrapper";function B0t(t){let{components:n,...e}=t;return(0,s.kt)(F0t,(0,p.Z)({},O0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}B0t.isMDXComponent=!0;const U0t={toc:[]},V0t="wrapper";function q0t(t){let{components:n,...e}=t;return(0,s.kt)(V0t,(0,p.Z)({},U0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}q0t.isMDXComponent=!0;const j0t={toc:[]},Y0t="wrapper";function Q0t(t){let{components:n,...e}=t;return(0,s.kt)(Y0t,(0,p.Z)({},j0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Q0t.isMDXComponent=!0;const H0t={toc:[]},$0t="wrapper";function K0t(t){let{components:n,...e}=t;return(0,s.kt)($0t,(0,p.Z)({},H0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}K0t.isMDXComponent=!0;const J0t={toc:[]},t2t="wrapper";function n2t(t){let{components:n,...e}=t;return(0,s.kt)(t2t,(0,p.Z)({},J0t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}n2t.isMDXComponent=!0;const e2t={toc:[]},o2t="wrapper";function p2t(t){let{components:n,...e}=t;return(0,s.kt)(o2t,(0,p.Z)({},e2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}p2t.isMDXComponent=!0;const r2t={toc:[]},s2t="wrapper";function c2t(t){let{components:n,...e}=t;return(0,s.kt)(s2t,(0,p.Z)({},r2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}c2t.isMDXComponent=!0;const i2t={toc:[]},a2t="wrapper";function l2t(t){let{components:n,...e}=t;return(0,s.kt)(a2t,(0,p.Z)({},i2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}l2t.isMDXComponent=!0;const u2t={toc:[]},m2t="wrapper";function d2t(t){let{components:n,...e}=t;return(0,s.kt)(m2t,(0,p.Z)({},u2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}d2t.isMDXComponent=!0;const h2t={toc:[]},k2t="wrapper";function f2t(t){let{components:n,...e}=t;return(0,s.kt)(k2t,(0,p.Z)({},h2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}f2t.isMDXComponent=!0;const y2t={toc:[]},M2t="wrapper";function D2t(t){let{components:n,...e}=t;return(0,s.kt)(M2t,(0,p.Z)({},y2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}D2t.isMDXComponent=!0;const X2t={toc:[]},_2t="wrapper";function w2t(t){let{components:n,...e}=t;return(0,s.kt)(_2t,(0,p.Z)({},X2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}w2t.isMDXComponent=!0;const T2t={toc:[]},C2t="wrapper";function g2t(t){let{components:n,...e}=t;return(0,s.kt)(C2t,(0,p.Z)({},T2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}g2t.isMDXComponent=!0;const x2t={toc:[]},v2t="wrapper";function L2t(t){let{components:n,...e}=t;return(0,s.kt)(v2t,(0,p.Z)({},x2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}L2t.isMDXComponent=!0;const Z2t={toc:[]},b2t="wrapper";function N2t(t){let{components:n,...e}=t;return(0,s.kt)(b2t,(0,p.Z)({},Z2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}N2t.isMDXComponent=!0;const A2t={toc:[]},z2t="wrapper";function W2t(t){let{components:n,...e}=t;return(0,s.kt)(z2t,(0,p.Z)({},A2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}W2t.isMDXComponent=!0;const I2t={toc:[]},R2t="wrapper";function P2t(t){let{components:n,...e}=t;return(0,s.kt)(R2t,(0,p.Z)({},I2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}P2t.isMDXComponent=!0;const S2t={toc:[]},E2t="wrapper";function G2t(t){let{components:n,...e}=t;return(0,s.kt)(E2t,(0,p.Z)({},S2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}G2t.isMDXComponent=!0;const O2t={toc:[]},F2t="wrapper";function B2t(t){let{components:n,...e}=t;return(0,s.kt)(F2t,(0,p.Z)({},O2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}B2t.isMDXComponent=!0;const U2t={toc:[]},V2t="wrapper";function q2t(t){let{components:n,...e}=t;return(0,s.kt)(V2t,(0,p.Z)({},U2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}q2t.isMDXComponent=!0;const j2t={toc:[]},Y2t="wrapper";function Q2t(t){let{components:n,...e}=t;return(0,s.kt)(Y2t,(0,p.Z)({},j2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Q2t.isMDXComponent=!0;const H2t={toc:[]},$2t="wrapper";function K2t(t){let{components:n,...e}=t;return(0,s.kt)($2t,(0,p.Z)({},H2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}K2t.isMDXComponent=!0;const J2t={toc:[]},t6t="wrapper";function n6t(t){let{components:n,...e}=t;return(0,s.kt)(t6t,(0,p.Z)({},J2t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}n6t.isMDXComponent=!0;const e6t={toc:[]},o6t="wrapper";function p6t(t){let{components:n,...e}=t;return(0,s.kt)(o6t,(0,p.Z)({},e6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}p6t.isMDXComponent=!0;const r6t={toc:[]},s6t="wrapper";function c6t(t){let{components:n,...e}=t;return(0,s.kt)(s6t,(0,p.Z)({},r6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}c6t.isMDXComponent=!0;const i6t={toc:[]},a6t="wrapper";function l6t(t){let{components:n,...e}=t;return(0,s.kt)(a6t,(0,p.Z)({},i6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}l6t.isMDXComponent=!0;const u6t={toc:[]},m6t="wrapper";function d6t(t){let{components:n,...e}=t;return(0,s.kt)(m6t,(0,p.Z)({},u6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}d6t.isMDXComponent=!0;const h6t={toc:[]},k6t="wrapper";function f6t(t){let{components:n,...e}=t;return(0,s.kt)(k6t,(0,p.Z)({},h6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}f6t.isMDXComponent=!0;const y6t={toc:[]},M6t="wrapper";function D6t(t){let{components:n,...e}=t;return(0,s.kt)(M6t,(0,p.Z)({},y6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}D6t.isMDXComponent=!0;const X6t={toc:[]},_6t="wrapper";function w6t(t){let{components:n,...e}=t;return(0,s.kt)(_6t,(0,p.Z)({},X6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}w6t.isMDXComponent=!0;const T6t={toc:[]},C6t="wrapper";function g6t(t){let{components:n,...e}=t;return(0,s.kt)(C6t,(0,p.Z)({},T6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}g6t.isMDXComponent=!0;const x6t={toc:[]},v6t="wrapper";function L6t(t){let{components:n,...e}=t;return(0,s.kt)(v6t,(0,p.Z)({},x6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}L6t.isMDXComponent=!0;const Z6t={toc:[]},b6t="wrapper";function N6t(t){let{components:n,...e}=t;return(0,s.kt)(b6t,(0,p.Z)({},Z6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}N6t.isMDXComponent=!0;const A6t={toc:[]},z6t="wrapper";function W6t(t){let{components:n,...e}=t;return(0,s.kt)(z6t,(0,p.Z)({},A6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}W6t.isMDXComponent=!0;const I6t={toc:[]},R6t="wrapper";function P6t(t){let{components:n,...e}=t;return(0,s.kt)(R6t,(0,p.Z)({},I6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}P6t.isMDXComponent=!0;const S6t={toc:[]},E6t="wrapper";function G6t(t){let{components:n,...e}=t;return(0,s.kt)(E6t,(0,p.Z)({},S6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}G6t.isMDXComponent=!0;const O6t={toc:[]},F6t="wrapper";function B6t(t){let{components:n,...e}=t;return(0,s.kt)(F6t,(0,p.Z)({},O6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}B6t.isMDXComponent=!0;const U6t={toc:[]},V6t="wrapper";function q6t(t){let{components:n,...e}=t;return(0,s.kt)(V6t,(0,p.Z)({},U6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}q6t.isMDXComponent=!0;const j6t={toc:[]},Y6t="wrapper";function Q6t(t){let{components:n,...e}=t;return(0,s.kt)(Y6t,(0,p.Z)({},j6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Q6t.isMDXComponent=!0;const H6t={toc:[]},$6t="wrapper";function K6t(t){let{components:n,...e}=t;return(0,s.kt)($6t,(0,p.Z)({},H6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}K6t.isMDXComponent=!0;const J6t={toc:[]},t3t="wrapper";function n3t(t){let{components:n,...e}=t;return(0,s.kt)(t3t,(0,p.Z)({},J6t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}n3t.isMDXComponent=!0;const e3t={toc:[]},o3t="wrapper";function p3t(t){let{components:n,...e}=t;return(0,s.kt)(o3t,(0,p.Z)({},e3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Address to Iconify API for the requested Icon."))}p3t.isMDXComponent=!0;const r3t={toc:[]},s3t="wrapper";function c3t(t){let{components:n,...e}=t;return(0,s.kt)(s3t,(0,p.Z)({},r3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create the URL that will be used as the Image source"))}c3t.isMDXComponent=!0;const i3t={toc:[]},a3t="wrapper";function l3t(t){let{components:n,...e}=t;return(0,s.kt)(a3t,(0,p.Z)({},i3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}l3t.isMDXComponent=!0;const u3t={toc:[]},m3t="wrapper";function d3t(t){let{components:n,...e}=t;return(0,s.kt)(m3t,(0,p.Z)({},u3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}d3t.isMDXComponent=!0;const h3t={toc:[]},k3t="wrapper";function f3t(t){let{components:n,...e}=t;return(0,s.kt)(k3t,(0,p.Z)({},h3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}f3t.isMDXComponent=!0;const y3t={toc:[]},M3t="wrapper";function D3t(t){let{components:n,...e}=t;return(0,s.kt)(M3t,(0,p.Z)({},y3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}D3t.isMDXComponent=!0;const X3t={toc:[]},_3t="wrapper";function w3t(t){let{components:n,...e}=t;return(0,s.kt)(_3t,(0,p.Z)({},X3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}w3t.isMDXComponent=!0;const T3t={toc:[]},C3t="wrapper";function g3t(t){let{components:n,...e}=t;return(0,s.kt)(C3t,(0,p.Z)({},T3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}g3t.isMDXComponent=!0;const x3t={toc:[]},v3t="wrapper";function L3t(t){let{components:n,...e}=t;return(0,s.kt)(v3t,(0,p.Z)({},x3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}L3t.isMDXComponent=!0;const Z3t={toc:[]},b3t="wrapper";function N3t(t){let{components:n,...e}=t;return(0,s.kt)(b3t,(0,p.Z)({},Z3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}N3t.isMDXComponent=!0;const A3t={toc:[]},z3t="wrapper";function W3t(t){let{components:n,...e}=t;return(0,s.kt)(z3t,(0,p.Z)({},A3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}W3t.isMDXComponent=!0;const I3t={toc:[]},R3t="wrapper";function P3t(t){let{components:n,...e}=t;return(0,s.kt)(R3t,(0,p.Z)({},I3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}P3t.isMDXComponent=!0;const S3t={toc:[]},E3t="wrapper";function G3t(t){let{components:n,...e}=t;return(0,s.kt)(E3t,(0,p.Z)({},S3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d';\nimport {all, waitFor} from '@motion-canvas/core';\nimport {createRef} from '@motion-canvas/core';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  yield view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}G3t.isMDXComponent=!0;const O3t={toc:[]},F3t="wrapper";function B3t(t){let{components:n,...e}=t;return(0,s.kt)(F3t,(0,p.Z)({},O3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}B3t.isMDXComponent=!0;const U3t={toc:[]},V3t="wrapper";function q3t(t){let{components:n,...e}=t;return(0,s.kt)(V3t,(0,p.Z)({},U3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}q3t.isMDXComponent=!0;const j3t={toc:[]},Y3t="wrapper";function Q3t(t){let{components:n,...e}=t;return(0,s.kt)(Y3t,(0,p.Z)({},j3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Q3t.isMDXComponent=!0;const H3t={toc:[]},$3t="wrapper";function K3t(t){let{components:n,...e}=t;return(0,s.kt)($3t,(0,p.Z)({},H3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}K3t.isMDXComponent=!0;const J3t={toc:[]},t5t="wrapper";function n5t(t){let{components:n,...e}=t;return(0,s.kt)(t5t,(0,p.Z)({},J3t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}n5t.isMDXComponent=!0;const e5t={toc:[]},o5t="wrapper";function p5t(t){let{components:n,...e}=t;return(0,s.kt)(o5t,(0,p.Z)({},e5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}p5t.isMDXComponent=!0;const r5t={toc:[]},s5t="wrapper";function c5t(t){let{components:n,...e}=t;return(0,s.kt)(s5t,(0,p.Z)({},r5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}c5t.isMDXComponent=!0;const i5t={toc:[]},a5t="wrapper";function l5t(t){let{components:n,...e}=t;return(0,s.kt)(a5t,(0,p.Z)({},i5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}l5t.isMDXComponent=!0;const u5t={toc:[]},m5t="wrapper";function d5t(t){let{components:n,...e}=t;return(0,s.kt)(m5t,(0,p.Z)({},u5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}d5t.isMDXComponent=!0;const h5t={toc:[]},k5t="wrapper";function f5t(t){let{components:n,...e}=t;return(0,s.kt)(k5t,(0,p.Z)({},h5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}f5t.isMDXComponent=!0;const y5t={toc:[]},M5t="wrapper";function D5t(t){let{components:n,...e}=t;return(0,s.kt)(M5t,(0,p.Z)({},y5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}D5t.isMDXComponent=!0;const X5t={toc:[]},_5t="wrapper";function w5t(t){let{components:n,...e}=t;return(0,s.kt)(_5t,(0,p.Z)({},X5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}w5t.isMDXComponent=!0;const T5t={toc:[]},C5t="wrapper";function g5t(t){let{components:n,...e}=t;return(0,s.kt)(C5t,(0,p.Z)({},T5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}g5t.isMDXComponent=!0;const x5t={toc:[]},v5t="wrapper";function L5t(t){let{components:n,...e}=t;return(0,s.kt)(v5t,(0,p.Z)({},x5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}L5t.isMDXComponent=!0;const Z5t={toc:[]},b5t="wrapper";function N5t(t){let{components:n,...e}=t;return(0,s.kt)(b5t,(0,p.Z)({},Z5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}N5t.isMDXComponent=!0;const A5t={toc:[]},z5t="wrapper";function W5t(t){let{components:n,...e}=t;return(0,s.kt)(z5t,(0,p.Z)({},A5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}W5t.isMDXComponent=!0;const I5t={toc:[]},R5t="wrapper";function P5t(t){let{components:n,...e}=t;return(0,s.kt)(R5t,(0,p.Z)({},I5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}P5t.isMDXComponent=!0;const S5t={toc:[]},E5t="wrapper";function G5t(t){let{components:n,...e}=t;return(0,s.kt)(E5t,(0,p.Z)({},S5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}G5t.isMDXComponent=!0;const O5t={toc:[]},F5t="wrapper";function B5t(t){let{components:n,...e}=t;return(0,s.kt)(F5t,(0,p.Z)({},O5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}B5t.isMDXComponent=!0;const U5t={toc:[]},V5t="wrapper";function q5t(t){let{components:n,...e}=t;return(0,s.kt)(V5t,(0,p.Z)({},U5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}q5t.isMDXComponent=!0;const j5t={toc:[]},Y5t="wrapper";function Q5t(t){let{components:n,...e}=t;return(0,s.kt)(Y5t,(0,p.Z)({},j5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Q5t.isMDXComponent=!0;const H5t={toc:[]},$5t="wrapper";function K5t(t){let{components:n,...e}=t;return(0,s.kt)($5t,(0,p.Z)({},H5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}K5t.isMDXComponent=!0;const J5t={toc:[]},t1t="wrapper";function n1t(t){let{components:n,...e}=t;return(0,s.kt)(t1t,(0,p.Z)({},J5t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}n1t.isMDXComponent=!0;const e1t={toc:[]},o1t="wrapper";function p1t(t){let{components:n,...e}=t;return(0,s.kt)(o1t,(0,p.Z)({},e1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}p1t.isMDXComponent=!0;const r1t={toc:[]},s1t="wrapper";function c1t(t){let{components:n,...e}=t;return(0,s.kt)(s1t,(0,p.Z)({},r1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}c1t.isMDXComponent=!0;const i1t={toc:[]},a1t="wrapper";function l1t(t){let{components:n,...e}=t;return(0,s.kt)(a1t,(0,p.Z)({},i1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}l1t.isMDXComponent=!0;const u1t={toc:[]},m1t="wrapper";function d1t(t){let{components:n,...e}=t;return(0,s.kt)(m1t,(0,p.Z)({},u1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}d1t.isMDXComponent=!0;const h1t={toc:[]},k1t="wrapper";function f1t(t){let{components:n,...e}=t;return(0,s.kt)(k1t,(0,p.Z)({},h1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}f1t.isMDXComponent=!0;const y1t={toc:[]},M1t="wrapper";function D1t(t){let{components:n,...e}=t;return(0,s.kt)(M1t,(0,p.Z)({},y1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}D1t.isMDXComponent=!0;const X1t={toc:[]},_1t="wrapper";function w1t(t){let{components:n,...e}=t;return(0,s.kt)(_1t,(0,p.Z)({},X1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}w1t.isMDXComponent=!0;const T1t={toc:[]},C1t="wrapper";function g1t(t){let{components:n,...e}=t;return(0,s.kt)(C1t,(0,p.Z)({},T1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}g1t.isMDXComponent=!0;const x1t={toc:[]},v1t="wrapper";function L1t(t){let{components:n,...e}=t;return(0,s.kt)(v1t,(0,p.Z)({},x1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}L1t.isMDXComponent=!0;const Z1t={toc:[]},b1t="wrapper";function N1t(t){let{components:n,...e}=t;return(0,s.kt)(b1t,(0,p.Z)({},Z1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}N1t.isMDXComponent=!0;const A1t={toc:[]},z1t="wrapper";function W1t(t){let{components:n,...e}=t;return(0,s.kt)(z1t,(0,p.Z)({},A1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}W1t.isMDXComponent=!0;const I1t={toc:[]},R1t="wrapper";function P1t(t){let{components:n,...e}=t;return(0,s.kt)(R1t,(0,p.Z)({},I1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}P1t.isMDXComponent=!0;const S1t={toc:[]},E1t="wrapper";function G1t(t){let{components:n,...e}=t;return(0,s.kt)(E1t,(0,p.Z)({},S1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}G1t.isMDXComponent=!0;const O1t={toc:[]},F1t="wrapper";function B1t(t){let{components:n,...e}=t;return(0,s.kt)(F1t,(0,p.Z)({},O1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}B1t.isMDXComponent=!0;const U1t={toc:[]},V1t="wrapper";function q1t(t){let{components:n,...e}=t;return(0,s.kt)(V1t,(0,p.Z)({},U1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}q1t.isMDXComponent=!0;const j1t={toc:[]},Y1t="wrapper";function Q1t(t){let{components:n,...e}=t;return(0,s.kt)(Y1t,(0,p.Z)({},j1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Q1t.isMDXComponent=!0;const H1t={toc:[]},$1t="wrapper";function K1t(t){let{components:n,...e}=t;return(0,s.kt)($1t,(0,p.Z)({},H1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}K1t.isMDXComponent=!0;const J1t={toc:[]},t4t="wrapper";function n4t(t){let{components:n,...e}=t;return(0,s.kt)(t4t,(0,p.Z)({},J1t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}n4t.isMDXComponent=!0;const e4t={toc:[]},o4t="wrapper";function p4t(t){let{components:n,...e}=t;return(0,s.kt)(o4t,(0,p.Z)({},e4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}p4t.isMDXComponent=!0;const r4t={toc:[]},s4t="wrapper";function c4t(t){let{components:n,...e}=t;return(0,s.kt)(s4t,(0,p.Z)({},r4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}c4t.isMDXComponent=!0;const i4t={toc:[]},a4t="wrapper";function l4t(t){let{components:n,...e}=t;return(0,s.kt)(a4t,(0,p.Z)({},i4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}l4t.isMDXComponent=!0;const u4t={toc:[]},m4t="wrapper";function d4t(t){let{components:n,...e}=t;return(0,s.kt)(m4t,(0,p.Z)({},u4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}d4t.isMDXComponent=!0;const h4t={toc:[]},k4t="wrapper";function f4t(t){let{components:n,...e}=t;return(0,s.kt)(k4t,(0,p.Z)({},h4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}f4t.isMDXComponent=!0;const y4t={toc:[]},M4t="wrapper";function D4t(t){let{components:n,...e}=t;return(0,s.kt)(M4t,(0,p.Z)({},y4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}D4t.isMDXComponent=!0;const X4t={toc:[]},_4t="wrapper";function w4t(t){let{components:n,...e}=t;return(0,s.kt)(_4t,(0,p.Z)({},X4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}w4t.isMDXComponent=!0;const T4t={toc:[]},C4t="wrapper";function g4t(t){let{components:n,...e}=t;return(0,s.kt)(C4t,(0,p.Z)({},T4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}g4t.isMDXComponent=!0;const x4t={toc:[]},v4t="wrapper";function L4t(t){let{components:n,...e}=t;return(0,s.kt)(v4t,(0,p.Z)({},x4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}L4t.isMDXComponent=!0;const Z4t={toc:[]},b4t="wrapper";function N4t(t){let{components:n,...e}=t;return(0,s.kt)(b4t,(0,p.Z)({},Z4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}N4t.isMDXComponent=!0;const A4t={toc:[]},z4t="wrapper";function W4t(t){let{components:n,...e}=t;return(0,s.kt)(z4t,(0,p.Z)({},A4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}W4t.isMDXComponent=!0;const I4t={toc:[]},R4t="wrapper";function P4t(t){let{components:n,...e}=t;return(0,s.kt)(R4t,(0,p.Z)({},I4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}P4t.isMDXComponent=!0;const S4t={toc:[]},E4t="wrapper";function G4t(t){let{components:n,...e}=t;return(0,s.kt)(E4t,(0,p.Z)({},S4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}G4t.isMDXComponent=!0;const O4t={toc:[]},F4t="wrapper";function B4t(t){let{components:n,...e}=t;return(0,s.kt)(F4t,(0,p.Z)({},O4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}B4t.isMDXComponent=!0;const U4t={toc:[]},V4t="wrapper";function q4t(t){let{components:n,...e}=t;return(0,s.kt)(V4t,(0,p.Z)({},U4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}q4t.isMDXComponent=!0;const j4t={toc:[]},Y4t="wrapper";function Q4t(t){let{components:n,...e}=t;return(0,s.kt)(Y4t,(0,p.Z)({},j4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Q4t.isMDXComponent=!0;const H4t={toc:[]},$4t="wrapper";function K4t(t){let{components:n,...e}=t;return(0,s.kt)($4t,(0,p.Z)({},H4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}K4t.isMDXComponent=!0;const J4t={toc:[]},t8t="wrapper";function n8t(t){let{components:n,...e}=t;return(0,s.kt)(t8t,(0,p.Z)({},J4t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}n8t.isMDXComponent=!0;const e8t={toc:[]},o8t="wrapper";function p8t(t){let{components:n,...e}=t;return(0,s.kt)(o8t,(0,p.Z)({},e8t,e,{components:n,mdxType:"MDXLayout"}))}p8t.isMDXComponent=!0;const r8t={toc:[]},s8t="wrapper";function c8t(t){let{components:n,...e}=t;return(0,s.kt)(s8t,(0,p.Z)({},r8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}c8t.isMDXComponent=!0;const i8t={toc:[]},a8t="wrapper";function l8t(t){let{components:n,...e}=t;return(0,s.kt)(a8t,(0,p.Z)({},i8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}l8t.isMDXComponent=!0;const u8t={toc:[]},m8t="wrapper";function d8t(t){let{components:n,...e}=t;return(0,s.kt)(m8t,(0,p.Z)({},u8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}d8t.isMDXComponent=!0;const h8t={toc:[]},k8t="wrapper";function f8t(t){let{components:n,...e}=t;return(0,s.kt)(k8t,(0,p.Z)({},h8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}f8t.isMDXComponent=!0;const y8t={toc:[]},M8t="wrapper";function D8t(t){let{components:n,...e}=t;return(0,s.kt)(M8t,(0,p.Z)({},y8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}D8t.isMDXComponent=!0;const X8t={toc:[]},_8t="wrapper";function w8t(t){let{components:n,...e}=t;return(0,s.kt)(_8t,(0,p.Z)({},X8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}w8t.isMDXComponent=!0;const T8t={toc:[]},C8t="wrapper";function g8t(t){let{components:n,...e}=t;return(0,s.kt)(C8t,(0,p.Z)({},T8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}g8t.isMDXComponent=!0;const x8t={toc:[]},v8t="wrapper";function L8t(t){let{components:n,...e}=t;return(0,s.kt)(v8t,(0,p.Z)({},x8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}L8t.isMDXComponent=!0;const Z8t={toc:[]},b8t="wrapper";function N8t(t){let{components:n,...e}=t;return(0,s.kt)(b8t,(0,p.Z)({},Z8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}N8t.isMDXComponent=!0;const A8t={toc:[]},z8t="wrapper";function W8t(t){let{components:n,...e}=t;return(0,s.kt)(z8t,(0,p.Z)({},A8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}W8t.isMDXComponent=!0;const I8t={toc:[]},R8t="wrapper";function P8t(t){let{components:n,...e}=t;return(0,s.kt)(R8t,(0,p.Z)({},I8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}P8t.isMDXComponent=!0;const S8t={toc:[]},E8t="wrapper";function G8t(t){let{components:n,...e}=t;return(0,s.kt)(E8t,(0,p.Z)({},S8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}G8t.isMDXComponent=!0;const O8t={toc:[]},F8t="wrapper";function B8t(t){let{components:n,...e}=t;return(0,s.kt)(F8t,(0,p.Z)({},O8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}B8t.isMDXComponent=!0;const U8t={toc:[]},V8t="wrapper";function q8t(t){let{components:n,...e}=t;return(0,s.kt)(V8t,(0,p.Z)({},U8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}q8t.isMDXComponent=!0;const j8t={toc:[]},Y8t="wrapper";function Q8t(t){let{components:n,...e}=t;return(0,s.kt)(Y8t,(0,p.Z)({},j8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Q8t.isMDXComponent=!0;const H8t={toc:[]},$8t="wrapper";function K8t(t){let{components:n,...e}=t;return(0,s.kt)($8t,(0,p.Z)({},H8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}K8t.isMDXComponent=!0;const J8t={toc:[]},t7t="wrapper";function n7t(t){let{components:n,...e}=t;return(0,s.kt)(t7t,(0,p.Z)({},J8t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}n7t.isMDXComponent=!0;const e7t={toc:[]},o7t="wrapper";function p7t(t){let{components:n,...e}=t;return(0,s.kt)(o7t,(0,p.Z)({},e7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}p7t.isMDXComponent=!0;const r7t={toc:[]},s7t="wrapper";function c7t(t){let{components:n,...e}=t;return(0,s.kt)(s7t,(0,p.Z)({},r7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}c7t.isMDXComponent=!0;const i7t={toc:[]},a7t="wrapper";function l7t(t){let{components:n,...e}=t;return(0,s.kt)(a7t,(0,p.Z)({},i7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}l7t.isMDXComponent=!0;const u7t={toc:[]},m7t="wrapper";function d7t(t){let{components:n,...e}=t;return(0,s.kt)(m7t,(0,p.Z)({},u7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}d7t.isMDXComponent=!0;const h7t={toc:[]},k7t="wrapper";function f7t(t){let{components:n,...e}=t;return(0,s.kt)(k7t,(0,p.Z)({},h7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}f7t.isMDXComponent=!0;const y7t={toc:[]},M7t="wrapper";function D7t(t){let{components:n,...e}=t;return(0,s.kt)(M7t,(0,p.Z)({},y7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}D7t.isMDXComponent=!0;const X7t={toc:[]},_7t="wrapper";function w7t(t){let{components:n,...e}=t;return(0,s.kt)(_7t,(0,p.Z)({},X7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}w7t.isMDXComponent=!0;const T7t={toc:[]},C7t="wrapper";function g7t(t){let{components:n,...e}=t;return(0,s.kt)(C7t,(0,p.Z)({},T7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}g7t.isMDXComponent=!0;const x7t={toc:[]},v7t="wrapper";function L7t(t){let{components:n,...e}=t;return(0,s.kt)(v7t,(0,p.Z)({},x7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}L7t.isMDXComponent=!0;const Z7t={toc:[]},b7t="wrapper";function N7t(t){let{components:n,...e}=t;return(0,s.kt)(b7t,(0,p.Z)({},Z7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}N7t.isMDXComponent=!0;const A7t={toc:[]},z7t="wrapper";function W7t(t){let{components:n,...e}=t;return(0,s.kt)(z7t,(0,p.Z)({},A7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}W7t.isMDXComponent=!0;const I7t={toc:[]},R7t="wrapper";function P7t(t){let{components:n,...e}=t;return(0,s.kt)(R7t,(0,p.Z)({},I7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}P7t.isMDXComponent=!0;const S7t={toc:[]},E7t="wrapper";function G7t(t){let{components:n,...e}=t;return(0,s.kt)(E7t,(0,p.Z)({},S7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}G7t.isMDXComponent=!0;const O7t={toc:[]},F7t="wrapper";function B7t(t){let{components:n,...e}=t;return(0,s.kt)(F7t,(0,p.Z)({},O7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}B7t.isMDXComponent=!0;const U7t={toc:[]},V7t="wrapper";function q7t(t){let{components:n,...e}=t;return(0,s.kt)(V7t,(0,p.Z)({},U7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}q7t.isMDXComponent=!0;const j7t={toc:[]},Y7t="wrapper";function Q7t(t){let{components:n,...e}=t;return(0,s.kt)(Y7t,(0,p.Z)({},j7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Q7t.isMDXComponent=!0;const H7t={toc:[]},$7t="wrapper";function K7t(t){let{components:n,...e}=t;return(0,s.kt)($7t,(0,p.Z)({},H7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}K7t.isMDXComponent=!0;const J7t={toc:[]},t9t="wrapper";function n9t(t){let{components:n,...e}=t;return(0,s.kt)(t9t,(0,p.Z)({},J7t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}n9t.isMDXComponent=!0;const e9t={toc:[]},o9t="wrapper";function p9t(t){let{components:n,...e}=t;return(0,s.kt)(o9t,(0,p.Z)({},e9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}p9t.isMDXComponent=!0;const r9t={toc:[]},s9t="wrapper";function c9t(t){let{components:n,...e}=t;return(0,s.kt)(s9t,(0,p.Z)({},r9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}c9t.isMDXComponent=!0;const i9t={toc:[]},a9t="wrapper";function l9t(t){let{components:n,...e}=t;return(0,s.kt)(a9t,(0,p.Z)({},i9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}l9t.isMDXComponent=!0;const u9t={toc:[]},m9t="wrapper";function d9t(t){let{components:n,...e}=t;return(0,s.kt)(m9t,(0,p.Z)({},u9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}d9t.isMDXComponent=!0;const h9t={toc:[]},k9t="wrapper";function f9t(t){let{components:n,...e}=t;return(0,s.kt)(k9t,(0,p.Z)({},h9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}f9t.isMDXComponent=!0;const y9t={toc:[]},M9t="wrapper";function D9t(t){let{components:n,...e}=t;return(0,s.kt)(M9t,(0,p.Z)({},y9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}D9t.isMDXComponent=!0;const X9t={toc:[]},_9t="wrapper";function w9t(t){let{components:n,...e}=t;return(0,s.kt)(_9t,(0,p.Z)({},X9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}w9t.isMDXComponent=!0;const T9t={toc:[]},C9t="wrapper";function g9t(t){let{components:n,...e}=t;return(0,s.kt)(C9t,(0,p.Z)({},T9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}g9t.isMDXComponent=!0;const x9t={toc:[]},v9t="wrapper";function L9t(t){let{components:n,...e}=t;return(0,s.kt)(v9t,(0,p.Z)({},x9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}L9t.isMDXComponent=!0;const Z9t={toc:[]},b9t="wrapper";function N9t(t){let{components:n,...e}=t;return(0,s.kt)(b9t,(0,p.Z)({},Z9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}N9t.isMDXComponent=!0;const A9t={toc:[]},z9t="wrapper";function W9t(t){let{components:n,...e}=t;return(0,s.kt)(z9t,(0,p.Z)({},A9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}W9t.isMDXComponent=!0;const I9t={toc:[]},R9t="wrapper";function P9t(t){let{components:n,...e}=t;return(0,s.kt)(R9t,(0,p.Z)({},I9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}P9t.isMDXComponent=!0;const S9t={toc:[]},E9t="wrapper";function G9t(t){let{components:n,...e}=t;return(0,s.kt)(E9t,(0,p.Z)({},S9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}G9t.isMDXComponent=!0;const O9t={toc:[]},F9t="wrapper";function B9t(t){let{components:n,...e}=t;return(0,s.kt)(F9t,(0,p.Z)({},O9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}B9t.isMDXComponent=!0;const U9t={toc:[]},V9t="wrapper";function q9t(t){let{components:n,...e}=t;return(0,s.kt)(V9t,(0,p.Z)({},U9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}q9t.isMDXComponent=!0;const j9t={toc:[]},Y9t="wrapper";function Q9t(t){let{components:n,...e}=t;return(0,s.kt)(Y9t,(0,p.Z)({},j9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Q9t.isMDXComponent=!0;const H9t={toc:[]},$9t="wrapper";function K9t(t){let{components:n,...e}=t;return(0,s.kt)($9t,(0,p.Z)({},H9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}K9t.isMDXComponent=!0;const J9t={toc:[]},ttn="wrapper";function ntn(t){let{components:n,...e}=t;return(0,s.kt)(ttn,(0,p.Z)({},J9t,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ntn.isMDXComponent=!0;const etn={toc:[]},otn="wrapper";function ptn(t){let{components:n,...e}=t;return(0,s.kt)(otn,(0,p.Z)({},etn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}ptn.isMDXComponent=!0;const rtn={toc:[]},stn="wrapper";function ctn(t){let{components:n,...e}=t;return(0,s.kt)(stn,(0,p.Z)({},rtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}ctn.isMDXComponent=!0;const itn={toc:[]},atn="wrapper";function ltn(t){let{components:n,...e}=t;return(0,s.kt)(atn,(0,p.Z)({},itn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}ltn.isMDXComponent=!0;const utn={toc:[]},mtn="wrapper";function dtn(t){let{components:n,...e}=t;return(0,s.kt)(mtn,(0,p.Z)({},utn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}dtn.isMDXComponent=!0;const htn={toc:[]},ktn="wrapper";function ftn(t){let{components:n,...e}=t;return(0,s.kt)(ktn,(0,p.Z)({},htn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}ftn.isMDXComponent=!0;const ytn={toc:[]},Mtn="wrapper";function Dtn(t){let{components:n,...e}=t;return(0,s.kt)(Mtn,(0,p.Z)({},ytn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Dtn.isMDXComponent=!0;const Xtn={toc:[]},_tn="wrapper";function wtn(t){let{components:n,...e}=t;return(0,s.kt)(_tn,(0,p.Z)({},Xtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wtn.isMDXComponent=!0;const Ttn={toc:[]},Ctn="wrapper";function gtn(t){let{components:n,...e}=t;return(0,s.kt)(Ctn,(0,p.Z)({},Ttn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}gtn.isMDXComponent=!0;const xtn={toc:[]},vtn="wrapper";function Ltn(t){let{components:n,...e}=t;return(0,s.kt)(vtn,(0,p.Z)({},xtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ltn.isMDXComponent=!0;const Ztn={toc:[]},btn="wrapper";function Ntn(t){let{components:n,...e}=t;return(0,s.kt)(btn,(0,p.Z)({},Ztn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Ntn.isMDXComponent=!0;const Atn={toc:[]},ztn="wrapper";function Wtn(t){let{components:n,...e}=t;return(0,s.kt)(ztn,(0,p.Z)({},Atn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Wtn.isMDXComponent=!0;const Itn={toc:[]},Rtn="wrapper";function Ptn(t){let{components:n,...e}=t;return(0,s.kt)(Rtn,(0,p.Z)({},Itn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Ptn.isMDXComponent=!0;const Stn={toc:[]},Etn="wrapper";function Gtn(t){let{components:n,...e}=t;return(0,s.kt)(Etn,(0,p.Z)({},Stn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Gtn.isMDXComponent=!0;const Otn={toc:[]},Ftn="wrapper";function Btn(t){let{components:n,...e}=t;return(0,s.kt)(Ftn,(0,p.Z)({},Otn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Btn.isMDXComponent=!0;const Utn={toc:[]},Vtn="wrapper";function qtn(t){let{components:n,...e}=t;return(0,s.kt)(Vtn,(0,p.Z)({},Utn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qtn.isMDXComponent=!0;const jtn={toc:[]},Ytn="wrapper";function Qtn(t){let{components:n,...e}=t;return(0,s.kt)(Ytn,(0,p.Z)({},jtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Qtn.isMDXComponent=!0;const Htn={toc:[]},$tn="wrapper";function Ktn(t){let{components:n,...e}=t;return(0,s.kt)($tn,(0,p.Z)({},Htn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ktn.isMDXComponent=!0;const Jtn={toc:[]},tnn="wrapper";function nnn(t){let{components:n,...e}=t;return(0,s.kt)(tnn,(0,p.Z)({},Jtn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}nnn.isMDXComponent=!0;const enn={toc:[]},onn="wrapper";function pnn(t){let{components:n,...e}=t;return(0,s.kt)(onn,(0,p.Z)({},enn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}pnn.isMDXComponent=!0;const rnn={toc:[]},snn="wrapper";function cnn(t){let{components:n,...e}=t;return(0,s.kt)(snn,(0,p.Z)({},rnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}cnn.isMDXComponent=!0;const inn={toc:[]},ann="wrapper";function lnn(t){let{components:n,...e}=t;return(0,s.kt)(ann,(0,p.Z)({},inn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}lnn.isMDXComponent=!0;const unn={toc:[]},mnn="wrapper";function dnn(t){let{components:n,...e}=t;return(0,s.kt)(mnn,(0,p.Z)({},unn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}dnn.isMDXComponent=!0;const hnn={toc:[]},knn="wrapper";function fnn(t){let{components:n,...e}=t;return(0,s.kt)(knn,(0,p.Z)({},hnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}fnn.isMDXComponent=!0;const ynn={toc:[]},Mnn="wrapper";function Dnn(t){let{components:n,...e}=t;return(0,s.kt)(Mnn,(0,p.Z)({},ynn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}Dnn.isMDXComponent=!0;const Xnn={toc:[]},_nn="wrapper";function wnn(t){let{components:n,...e}=t;return(0,s.kt)(_nn,(0,p.Z)({},Xnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}wnn.isMDXComponent=!0;const Tnn={toc:[]},Cnn="wrapper";function gnn(t){let{components:n,...e}=t;return(0,s.kt)(Cnn,(0,p.Z)({},Tnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}gnn.isMDXComponent=!0;const xnn={toc:[]},vnn="wrapper";function Lnn(t){let{components:n,...e}=t;return(0,s.kt)(vnn,(0,p.Z)({},xnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Lnn.isMDXComponent=!0;const Znn={toc:[]},bnn="wrapper";function Nnn(t){let{components:n,...e}=t;return(0,s.kt)(bnn,(0,p.Z)({},Znn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Nnn.isMDXComponent=!0;const Ann={toc:[]},znn="wrapper";function Wnn(t){let{components:n,...e}=t;return(0,s.kt)(znn,(0,p.Z)({},Ann,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Wnn.isMDXComponent=!0;const Inn={toc:[]},Rnn="wrapper";function Pnn(t){let{components:n,...e}=t;return(0,s.kt)(Rnn,(0,p.Z)({},Inn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Pnn.isMDXComponent=!0;const Snn={toc:[]},Enn="wrapper";function Gnn(t){let{components:n,...e}=t;return(0,s.kt)(Enn,(0,p.Z)({},Snn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Gnn.isMDXComponent=!0;const Onn={toc:[]},Fnn="wrapper";function Bnn(t){let{components:n,...e}=t;return(0,s.kt)(Fnn,(0,p.Z)({},Onn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Bnn.isMDXComponent=!0;const Unn={toc:[]},Vnn="wrapper";function qnn(t){let{components:n,...e}=t;return(0,s.kt)(Vnn,(0,p.Z)({},Unn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}qnn.isMDXComponent=!0;const jnn={toc:[]},Ynn="wrapper";function Qnn(t){let{components:n,...e}=t;return(0,s.kt)(Ynn,(0,p.Z)({},jnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Qnn.isMDXComponent=!0;const Hnn={toc:[]},$nn="wrapper";function Knn(t){let{components:n,...e}=t;return(0,s.kt)($nn,(0,p.Z)({},Hnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Knn.isMDXComponent=!0;const Jnn={toc:[]},ten="wrapper";function nen(t){let{components:n,...e}=t;return(0,s.kt)(ten,(0,p.Z)({},Jnn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}nen.isMDXComponent=!0;const een={toc:[]},oen="wrapper";function pen(t){let{components:n,...e}=t;return(0,s.kt)(oen,(0,p.Z)({},een,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}pen.isMDXComponent=!0;const ren={toc:[]},sen="wrapper";function cen(t){let{components:n,...e}=t;return(0,s.kt)(sen,(0,p.Z)({},ren,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}cen.isMDXComponent=!0;const ien={toc:[]},aen="wrapper";function len(t){let{components:n,...e}=t;return(0,s.kt)(aen,(0,p.Z)({},ien,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}len.isMDXComponent=!0;const uen={toc:[]},men="wrapper";function den(t){let{components:n,...e}=t;return(0,s.kt)(men,(0,p.Z)({},uen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}den.isMDXComponent=!0;const hen={toc:[]},ken="wrapper";function fen(t){let{components:n,...e}=t;return(0,s.kt)(ken,(0,p.Z)({},hen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}fen.isMDXComponent=!0;const yen={toc:[]},Men="wrapper";function Den(t){let{components:n,...e}=t;return(0,s.kt)(Men,(0,p.Z)({},yen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Den.isMDXComponent=!0;const Xen={toc:[]},_en="wrapper";function wen(t){let{components:n,...e}=t;return(0,s.kt)(_en,(0,p.Z)({},Xen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}wen.isMDXComponent=!0;const Ten={toc:[]},Cen="wrapper";function gen(t){let{components:n,...e}=t;return(0,s.kt)(Cen,(0,p.Z)({},Ten,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}gen.isMDXComponent=!0;const xen={toc:[]},ven="wrapper";function Len(t){let{components:n,...e}=t;return(0,s.kt)(ven,(0,p.Z)({},xen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Len.isMDXComponent=!0;const Zen={toc:[]},ben="wrapper";function Nen(t){let{components:n,...e}=t;return(0,s.kt)(ben,(0,p.Z)({},Zen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Nen.isMDXComponent=!0;const Aen={toc:[]},zen="wrapper";function Wen(t){let{components:n,...e}=t;return(0,s.kt)(zen,(0,p.Z)({},Aen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Wen.isMDXComponent=!0;const Ien={toc:[]},Ren="wrapper";function Pen(t){let{components:n,...e}=t;return(0,s.kt)(Ren,(0,p.Z)({},Ien,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Pen.isMDXComponent=!0;const Sen={toc:[]},Een="wrapper";function Gen(t){let{components:n,...e}=t;return(0,s.kt)(Een,(0,p.Z)({},Sen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Gen.isMDXComponent=!0;const Oen={toc:[]},Fen="wrapper";function Ben(t){let{components:n,...e}=t;return(0,s.kt)(Fen,(0,p.Z)({},Oen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Ben.isMDXComponent=!0;const Uen={toc:[]},Ven="wrapper";function qen(t){let{components:n,...e}=t;return(0,s.kt)(Ven,(0,p.Z)({},Uen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}qen.isMDXComponent=!0;const jen={toc:[]},Yen="wrapper";function Qen(t){let{components:n,...e}=t;return(0,s.kt)(Yen,(0,p.Z)({},jen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Qen.isMDXComponent=!0;const Hen={toc:[]},$en="wrapper";function Ken(t){let{components:n,...e}=t;return(0,s.kt)($en,(0,p.Z)({},Hen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Ken.isMDXComponent=!0;const Jen={toc:[]},ton="wrapper";function non(t){let{components:n,...e}=t;return(0,s.kt)(ton,(0,p.Z)({},Jen,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}non.isMDXComponent=!0;const eon={toc:[]},oon="wrapper";function pon(t){let{components:n,...e}=t;return(0,s.kt)(oon,(0,p.Z)({},eon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}pon.isMDXComponent=!0;const ron={toc:[]},son="wrapper";function con(t){let{components:n,...e}=t;return(0,s.kt)(son,(0,p.Z)({},ron,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}con.isMDXComponent=!0;const ion={toc:[]},aon="wrapper";function lon(t){let{components:n,...e}=t;return(0,s.kt)(aon,(0,p.Z)({},ion,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}lon.isMDXComponent=!0;const uon={toc:[]},mon="wrapper";function don(t){let{components:n,...e}=t;return(0,s.kt)(mon,(0,p.Z)({},uon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}don.isMDXComponent=!0;const hon={toc:[]},kon="wrapper";function fon(t){let{components:n,...e}=t;return(0,s.kt)(kon,(0,p.Z)({},hon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}fon.isMDXComponent=!0;const yon={toc:[]},Mon="wrapper";function Don(t){let{components:n,...e}=t;return(0,s.kt)(Mon,(0,p.Z)({},yon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Don.isMDXComponent=!0;const Xon={toc:[]},_on="wrapper";function won(t){let{components:n,...e}=t;return(0,s.kt)(_on,(0,p.Z)({},Xon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}won.isMDXComponent=!0;const Ton={toc:[]},Con="wrapper";function gon(t){let{components:n,...e}=t;return(0,s.kt)(Con,(0,p.Z)({},Ton,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}gon.isMDXComponent=!0;const xon={toc:[]},von="wrapper";function Lon(t){let{components:n,...e}=t;return(0,s.kt)(von,(0,p.Z)({},xon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Lon.isMDXComponent=!0;const Zon={toc:[]},bon="wrapper";function Non(t){let{components:n,...e}=t;return(0,s.kt)(bon,(0,p.Z)({},Zon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Non.isMDXComponent=!0;const Aon={toc:[]},zon="wrapper";function Won(t){let{components:n,...e}=t;return(0,s.kt)(zon,(0,p.Z)({},Aon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Won.isMDXComponent=!0;const Ion={toc:[]},Ron="wrapper";function Pon(t){let{components:n,...e}=t;return(0,s.kt)(Ron,(0,p.Z)({},Ion,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Pon.isMDXComponent=!0;const Son={toc:[]},Eon="wrapper";function Gon(t){let{components:n,...e}=t;return(0,s.kt)(Eon,(0,p.Z)({},Son,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}Gon.isMDXComponent=!0;const Oon={toc:[]},Fon="wrapper";function Bon(t){let{components:n,...e}=t;return(0,s.kt)(Fon,(0,p.Z)({},Oon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}Bon.isMDXComponent=!0;const Uon={toc:[]},Von="wrapper";function qon(t){let{components:n,...e}=t;return(0,s.kt)(Von,(0,p.Z)({},Uon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}qon.isMDXComponent=!0;const jon={toc:[]},Yon="wrapper";function Qon(t){let{components:n,...e}=t;return(0,s.kt)(Yon,(0,p.Z)({},jon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Qon.isMDXComponent=!0;const Hon={toc:[]},$on="wrapper";function Kon(t){let{components:n,...e}=t;return(0,s.kt)($on,(0,p.Z)({},Hon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Kon.isMDXComponent=!0;const Jon={toc:[]},tpn="wrapper";function npn(t){let{components:n,...e}=t;return(0,s.kt)(tpn,(0,p.Z)({},Jon,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}npn.isMDXComponent=!0;const epn={toc:[]},opn="wrapper";function ppn(t){let{components:n,...e}=t;return(0,s.kt)(opn,(0,p.Z)({},epn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}ppn.isMDXComponent=!0;const rpn={toc:[]},spn="wrapper";function cpn(t){let{components:n,...e}=t;return(0,s.kt)(spn,(0,p.Z)({},rpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}cpn.isMDXComponent=!0;const ipn={toc:[]},apn="wrapper";function lpn(t){let{components:n,...e}=t;return(0,s.kt)(apn,(0,p.Z)({},ipn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}lpn.isMDXComponent=!0;const upn={toc:[]},mpn="wrapper";function dpn(t){let{components:n,...e}=t;return(0,s.kt)(mpn,(0,p.Z)({},upn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}dpn.isMDXComponent=!0;const hpn={toc:[]},kpn="wrapper";function fpn(t){let{components:n,...e}=t;return(0,s.kt)(kpn,(0,p.Z)({},hpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}fpn.isMDXComponent=!0;const ypn={toc:[]},Mpn="wrapper";function Dpn(t){let{components:n,...e}=t;return(0,s.kt)(Mpn,(0,p.Z)({},ypn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Dpn.isMDXComponent=!0;const Xpn={toc:[]},_pn="wrapper";function wpn(t){let{components:n,...e}=t;return(0,s.kt)(_pn,(0,p.Z)({},Xpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wpn.isMDXComponent=!0;const Tpn={toc:[]},Cpn="wrapper";function gpn(t){let{components:n,...e}=t;return(0,s.kt)(Cpn,(0,p.Z)({},Tpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}gpn.isMDXComponent=!0;const xpn={toc:[]},vpn="wrapper";function Lpn(t){let{components:n,...e}=t;return(0,s.kt)(vpn,(0,p.Z)({},xpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Lpn.isMDXComponent=!0;const Zpn={toc:[]},bpn="wrapper";function Npn(t){let{components:n,...e}=t;return(0,s.kt)(bpn,(0,p.Z)({},Zpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Npn.isMDXComponent=!0;const Apn={toc:[]},zpn="wrapper";function Wpn(t){let{components:n,...e}=t;return(0,s.kt)(zpn,(0,p.Z)({},Apn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Wpn.isMDXComponent=!0;const Ipn={toc:[]},Rpn="wrapper";function Ppn(t){let{components:n,...e}=t;return(0,s.kt)(Rpn,(0,p.Z)({},Ipn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Ppn.isMDXComponent=!0;const Spn={toc:[]},Epn="wrapper";function Gpn(t){let{components:n,...e}=t;return(0,s.kt)(Epn,(0,p.Z)({},Spn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Gpn.isMDXComponent=!0;const Opn={toc:[]},Fpn="wrapper";function Bpn(t){let{components:n,...e}=t;return(0,s.kt)(Fpn,(0,p.Z)({},Opn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Bpn.isMDXComponent=!0;const Upn={toc:[]},Vpn="wrapper";function qpn(t){let{components:n,...e}=t;return(0,s.kt)(Vpn,(0,p.Z)({},Upn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}qpn.isMDXComponent=!0;const jpn={toc:[]},Ypn="wrapper";function Qpn(t){let{components:n,...e}=t;return(0,s.kt)(Ypn,(0,p.Z)({},jpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Qpn.isMDXComponent=!0;const Hpn={toc:[]},$pn="wrapper";function Kpn(t){let{components:n,...e}=t;return(0,s.kt)($pn,(0,p.Z)({},Hpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Kpn.isMDXComponent=!0;const Jpn={toc:[]},trn="wrapper";function nrn(t){let{components:n,...e}=t;return(0,s.kt)(trn,(0,p.Z)({},Jpn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}nrn.isMDXComponent=!0;const ern={toc:[]},orn="wrapper";function prn(t){let{components:n,...e}=t;return(0,s.kt)(orn,(0,p.Z)({},ern,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}prn.isMDXComponent=!0;const rrn={toc:[]},srn="wrapper";function crn(t){let{components:n,...e}=t;return(0,s.kt)(srn,(0,p.Z)({},rrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}crn.isMDXComponent=!0;const irn={toc:[]},arn="wrapper";function lrn(t){let{components:n,...e}=t;return(0,s.kt)(arn,(0,p.Z)({},irn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}lrn.isMDXComponent=!0;const urn={toc:[]},mrn="wrapper";function drn(t){let{components:n,...e}=t;return(0,s.kt)(mrn,(0,p.Z)({},urn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}drn.isMDXComponent=!0;const hrn={toc:[]},krn="wrapper";function frn(t){let{components:n,...e}=t;return(0,s.kt)(krn,(0,p.Z)({},hrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}frn.isMDXComponent=!0;const yrn={toc:[]},Mrn="wrapper";function Drn(t){let{components:n,...e}=t;return(0,s.kt)(Mrn,(0,p.Z)({},yrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Drn.isMDXComponent=!0;const Xrn={toc:[]},_rn="wrapper";function wrn(t){let{components:n,...e}=t;return(0,s.kt)(_rn,(0,p.Z)({},Xrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}wrn.isMDXComponent=!0;const Trn={toc:[]},Crn="wrapper";function grn(t){let{components:n,...e}=t;return(0,s.kt)(Crn,(0,p.Z)({},Trn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}grn.isMDXComponent=!0;const xrn={toc:[]},vrn="wrapper";function Lrn(t){let{components:n,...e}=t;return(0,s.kt)(vrn,(0,p.Z)({},xrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Lrn.isMDXComponent=!0;const Zrn={toc:[]},brn="wrapper";function Nrn(t){let{components:n,...e}=t;return(0,s.kt)(brn,(0,p.Z)({},Zrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Nrn.isMDXComponent=!0;const Arn={toc:[]},zrn="wrapper";function Wrn(t){let{components:n,...e}=t;return(0,s.kt)(zrn,(0,p.Z)({},Arn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Wrn.isMDXComponent=!0;const Irn={toc:[]},Rrn="wrapper";function Prn(t){let{components:n,...e}=t;return(0,s.kt)(Rrn,(0,p.Z)({},Irn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Prn.isMDXComponent=!0;const Srn={toc:[]},Ern="wrapper";function Grn(t){let{components:n,...e}=t;return(0,s.kt)(Ern,(0,p.Z)({},Srn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Grn.isMDXComponent=!0;const Orn={toc:[]},Frn="wrapper";function Brn(t){let{components:n,...e}=t;return(0,s.kt)(Frn,(0,p.Z)({},Orn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Brn.isMDXComponent=!0;const Urn={toc:[]},Vrn="wrapper";function qrn(t){let{components:n,...e}=t;return(0,s.kt)(Vrn,(0,p.Z)({},Urn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}qrn.isMDXComponent=!0;const jrn={toc:[]},Yrn="wrapper";function Qrn(t){let{components:n,...e}=t;return(0,s.kt)(Yrn,(0,p.Z)({},jrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Qrn.isMDXComponent=!0;const Hrn={toc:[]},$rn="wrapper";function Krn(t){let{components:n,...e}=t;return(0,s.kt)($rn,(0,p.Z)({},Hrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Krn.isMDXComponent=!0;const Jrn={toc:[]},tsn="wrapper";function nsn(t){let{components:n,...e}=t;return(0,s.kt)(tsn,(0,p.Z)({},Jrn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}nsn.isMDXComponent=!0;const esn={toc:[]},osn="wrapper";function psn(t){let{components:n,...e}=t;return(0,s.kt)(osn,(0,p.Z)({},esn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}psn.isMDXComponent=!0;const rsn={toc:[]},ssn="wrapper";function csn(t){let{components:n,...e}=t;return(0,s.kt)(ssn,(0,p.Z)({},rsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}csn.isMDXComponent=!0;const isn={toc:[]},asn="wrapper";function lsn(t){let{components:n,...e}=t;return(0,s.kt)(asn,(0,p.Z)({},isn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lsn.isMDXComponent=!0;const usn={toc:[]},msn="wrapper";function dsn(t){let{components:n,...e}=t;return(0,s.kt)(msn,(0,p.Z)({},usn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}dsn.isMDXComponent=!0;const hsn={toc:[]},ksn="wrapper";function fsn(t){let{components:n,...e}=t;return(0,s.kt)(ksn,(0,p.Z)({},hsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}fsn.isMDXComponent=!0;const ysn={toc:[]},Msn="wrapper";function Dsn(t){let{components:n,...e}=t;return(0,s.kt)(Msn,(0,p.Z)({},ysn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Dsn.isMDXComponent=!0;const Xsn={toc:[]},_sn="wrapper";function wsn(t){let{components:n,...e}=t;return(0,s.kt)(_sn,(0,p.Z)({},Xsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}wsn.isMDXComponent=!0;const Tsn={toc:[]},Csn="wrapper";function gsn(t){let{components:n,...e}=t;return(0,s.kt)(Csn,(0,p.Z)({},Tsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}gsn.isMDXComponent=!0;const xsn={toc:[]},vsn="wrapper";function Lsn(t){let{components:n,...e}=t;return(0,s.kt)(vsn,(0,p.Z)({},xsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Lsn.isMDXComponent=!0;const Zsn={toc:[]},bsn="wrapper";function Nsn(t){let{components:n,...e}=t;return(0,s.kt)(bsn,(0,p.Z)({},Zsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Nsn.isMDXComponent=!0;const Asn={toc:[]},zsn="wrapper";function Wsn(t){let{components:n,...e}=t;return(0,s.kt)(zsn,(0,p.Z)({},Asn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Wsn.isMDXComponent=!0;const Isn={toc:[]},Rsn="wrapper";function Psn(t){let{components:n,...e}=t;return(0,s.kt)(Rsn,(0,p.Z)({},Isn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Psn.isMDXComponent=!0;const Ssn={toc:[]},Esn="wrapper";function Gsn(t){let{components:n,...e}=t;return(0,s.kt)(Esn,(0,p.Z)({},Ssn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Gsn.isMDXComponent=!0;const Osn={toc:[]},Fsn="wrapper";function Bsn(t){let{components:n,...e}=t;return(0,s.kt)(Fsn,(0,p.Z)({},Osn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node representing a knot of a ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}Bsn.isMDXComponent=!0;const Usn={toc:[]},Vsn="wrapper";function qsn(t){let{components:n,...e}=t;return(0,s.kt)(Vsn,(0,p.Z)({},Usn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}qsn.isMDXComponent=!0;const jsn={toc:[]},Ysn="wrapper";function Qsn(t){let{components:n,...e}=t;return(0,s.kt)(Ysn,(0,p.Z)({},jsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Qsn.isMDXComponent=!0;const Hsn={toc:[]},$sn="wrapper";function Ksn(t){let{components:n,...e}=t;return(0,s.kt)($sn,(0,p.Z)({},Hsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Ksn.isMDXComponent=!0;const Jsn={toc:[]},tcn="wrapper";function ncn(t){let{components:n,...e}=t;return(0,s.kt)(tcn,(0,p.Z)({},Jsn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}ncn.isMDXComponent=!0;const ecn={toc:[]},ocn="wrapper";function pcn(t){let{components:n,...e}=t;return(0,s.kt)(ocn,(0,p.Z)({},ecn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}pcn.isMDXComponent=!0;const rcn={toc:[]},scn="wrapper";function ccn(t){let{components:n,...e}=t;return(0,s.kt)(scn,(0,p.Z)({},rcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}ccn.isMDXComponent=!0;const icn={toc:[]},acn="wrapper";function lcn(t){let{components:n,...e}=t;return(0,s.kt)(acn,(0,p.Z)({},icn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}lcn.isMDXComponent=!0;const ucn={toc:[]},mcn="wrapper";function dcn(t){let{components:n,...e}=t;return(0,s.kt)(mcn,(0,p.Z)({},ucn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}dcn.isMDXComponent=!0;const hcn={toc:[]},kcn="wrapper";function fcn(t){let{components:n,...e}=t;return(0,s.kt)(kcn,(0,p.Z)({},hcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}fcn.isMDXComponent=!0;const ycn={toc:[]},Mcn="wrapper";function Dcn(t){let{components:n,...e}=t;return(0,s.kt)(Mcn,(0,p.Z)({},ycn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Dcn.isMDXComponent=!0;const Xcn={toc:[]},_cn="wrapper";function wcn(t){let{components:n,...e}=t;return(0,s.kt)(_cn,(0,p.Z)({},Xcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the startHandle."))}wcn.isMDXComponent=!0;const Tcn={toc:[]},Ccn="wrapper";function gcn(t){let{components:n,...e}=t;return(0,s.kt)(Ccn,(0,p.Z)({},Tcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}gcn.isMDXComponent=!0;const xcn={toc:[]},vcn="wrapper";function Lcn(t){let{components:n,...e}=t;return(0,s.kt)(vcn,(0,p.Z)({},xcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Lcn.isMDXComponent=!0;const Zcn={toc:[]},bcn="wrapper";function Ncn(t){let{components:n,...e}=t;return(0,s.kt)(bcn,(0,p.Z)({},Zcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Ncn.isMDXComponent=!0;const Acn={toc:[]},zcn="wrapper";function Wcn(t){let{components:n,...e}=t;return(0,s.kt)(zcn,(0,p.Z)({},Acn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Wcn.isMDXComponent=!0;const Icn={toc:[]},Rcn="wrapper";function Pcn(t){let{components:n,...e}=t;return(0,s.kt)(Rcn,(0,p.Z)({},Icn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Pcn.isMDXComponent=!0;const Scn={toc:[]},Ecn="wrapper";function Gcn(t){let{components:n,...e}=t;return(0,s.kt)(Ecn,(0,p.Z)({},Scn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Gcn.isMDXComponent=!0;const Ocn={toc:[]},Fcn="wrapper";function Bcn(t){let{components:n,...e}=t;return(0,s.kt)(Fcn,(0,p.Z)({},Ocn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Bcn.isMDXComponent=!0;const Ucn={toc:[]},Vcn="wrapper";function qcn(t){let{components:n,...e}=t;return(0,s.kt)(Vcn,(0,p.Z)({},Ucn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}qcn.isMDXComponent=!0;const jcn={toc:[]},Ycn="wrapper";function Qcn(t){let{components:n,...e}=t;return(0,s.kt)(Ycn,(0,p.Z)({},jcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Qcn.isMDXComponent=!0;const Hcn={toc:[]},$cn="wrapper";function Kcn(t){let{components:n,...e}=t;return(0,s.kt)($cn,(0,p.Z)({},Hcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Kcn.isMDXComponent=!0;const Jcn={toc:[]},tin="wrapper";function nin(t){let{components:n,...e}=t;return(0,s.kt)(tin,(0,p.Z)({},Jcn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}nin.isMDXComponent=!0;const ein={toc:[]},oin="wrapper";function pin(t){let{components:n,...e}=t;return(0,s.kt)(oin,(0,p.Z)({},ein,e,{components:n,mdxType:"MDXLayout"}))}pin.isMDXComponent=!0;const rin={toc:[]},sin="wrapper";function cin(t){let{components:n,...e}=t;return(0,s.kt)(sin,(0,p.Z)({},rin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}cin.isMDXComponent=!0;const iin={toc:[]},ain="wrapper";function lin(t){let{components:n,...e}=t;return(0,s.kt)(ain,(0,p.Z)({},iin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the endHandle."))}lin.isMDXComponent=!0;const uin={toc:[]},min="wrapper";function din(t){let{components:n,...e}=t;return(0,s.kt)(min,(0,p.Z)({},uin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}din.isMDXComponent=!0;const hin={toc:[]},kin="wrapper";function fin(t){let{components:n,...e}=t;return(0,s.kt)(kin,(0,p.Z)({},hin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}fin.isMDXComponent=!0;const yin={toc:[]},Min="wrapper";function Din(t){let{components:n,...e}=t;return(0,s.kt)(Min,(0,p.Z)({},yin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Din.isMDXComponent=!0;const Xin={toc:[]},_in="wrapper";function win(t){let{components:n,...e}=t;return(0,s.kt)(_in,(0,p.Z)({},Xin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}win.isMDXComponent=!0;const Tin={toc:[]},Cin="wrapper";function gin(t){let{components:n,...e}=t;return(0,s.kt)(Cin,(0,p.Z)({},Tin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}gin.isMDXComponent=!0;const xin={toc:[]},vin="wrapper";function Lin(t){let{components:n,...e}=t;return(0,s.kt)(vin,(0,p.Z)({},xin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Lin.isMDXComponent=!0;const Zin={toc:[]},bin="wrapper";function Nin(t){let{components:n,...e}=t;return(0,s.kt)(bin,(0,p.Z)({},Zin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Nin.isMDXComponent=!0;const Ain={toc:[]},zin="wrapper";function Win(t){let{components:n,...e}=t;return(0,s.kt)(zin,(0,p.Z)({},Ain,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Win.isMDXComponent=!0;const Iin={toc:[]},Rin="wrapper";function Pin(t){let{components:n,...e}=t;return(0,s.kt)(Rin,(0,p.Z)({},Iin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Pin.isMDXComponent=!0;const Sin={toc:[]},Ein="wrapper";function Gin(t){let{components:n,...e}=t;return(0,s.kt)(Ein,(0,p.Z)({},Sin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Gin.isMDXComponent=!0;const Oin={toc:[]},Fin="wrapper";function Bin(t){let{components:n,...e}=t;return(0,s.kt)(Fin,(0,p.Z)({},Oin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Bin.isMDXComponent=!0;const Uin={toc:[]},Vin="wrapper";function qin(t){let{components:n,...e}=t;return(0,s.kt)(Vin,(0,p.Z)({},Uin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qin.isMDXComponent=!0;const jin={toc:[]},Yin="wrapper";function Qin(t){let{components:n,...e}=t;return(0,s.kt)(Yin,(0,p.Z)({},jin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Qin.isMDXComponent=!0;const Hin={toc:[]},$in="wrapper";function Kin(t){let{components:n,...e}=t;return(0,s.kt)($in,(0,p.Z)({},Hin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Kin.isMDXComponent=!0;const Jin={toc:[]},tan="wrapper";function nan(t){let{components:n,...e}=t;return(0,s.kt)(tan,(0,p.Z)({},Jin,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}nan.isMDXComponent=!0;const ean={toc:[]},oan="wrapper";function pan(t){let{components:n,...e}=t;return(0,s.kt)(oan,(0,p.Z)({},ean,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}pan.isMDXComponent=!0;const ran={toc:[]},san="wrapper";function can(t){let{components:n,...e}=t;return(0,s.kt)(san,(0,p.Z)({},ran,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}can.isMDXComponent=!0;const ian={toc:[]},aan="wrapper";function lan(t){let{components:n,...e}=t;return(0,s.kt)(aan,(0,p.Z)({},ian,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lan.isMDXComponent=!0;const uan={toc:[]},man="wrapper";function dan(t){let{components:n,...e}=t;return(0,s.kt)(man,(0,p.Z)({},uan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}dan.isMDXComponent=!0;const han={toc:[]},kan="wrapper";function fan(t){let{components:n,...e}=t;return(0,s.kt)(kan,(0,p.Z)({},han,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}fan.isMDXComponent=!0;const yan={toc:[]},Man="wrapper";function Dan(t){let{components:n,...e}=t;return(0,s.kt)(Man,(0,p.Z)({},yan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Dan.isMDXComponent=!0;const Xan={toc:[]},_an="wrapper";function wan(t){let{components:n,...e}=t;return(0,s.kt)(_an,(0,p.Z)({},Xan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}wan.isMDXComponent=!0;const Tan={toc:[]},Can="wrapper";function gan(t){let{components:n,...e}=t;return(0,s.kt)(Can,(0,p.Z)({},Tan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}gan.isMDXComponent=!0;const xan={toc:[]},van="wrapper";function Lan(t){let{components:n,...e}=t;return(0,s.kt)(van,(0,p.Z)({},xan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Lan.isMDXComponent=!0;const Zan={toc:[]},ban="wrapper";function Nan(t){let{components:n,...e}=t;return(0,s.kt)(ban,(0,p.Z)({},Zan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Nan.isMDXComponent=!0;const Aan={toc:[]},zan="wrapper";function Wan(t){let{components:n,...e}=t;return(0,s.kt)(zan,(0,p.Z)({},Aan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Wan.isMDXComponent=!0;const Ian={toc:[]},Ran="wrapper";function Pan(t){let{components:n,...e}=t;return(0,s.kt)(Ran,(0,p.Z)({},Ian,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Pan.isMDXComponent=!0;const San={toc:[]},Ean="wrapper";function Gan(t){let{components:n,...e}=t;return(0,s.kt)(Ean,(0,p.Z)({},San,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Gan.isMDXComponent=!0;const Oan={toc:[]},Fan="wrapper";function Ban(t){let{components:n,...e}=t;return(0,s.kt)(Fan,(0,p.Z)({},Oan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Ban.isMDXComponent=!0;const Uan={toc:[]},Van="wrapper";function qan(t){let{components:n,...e}=t;return(0,s.kt)(Van,(0,p.Z)({},Uan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}qan.isMDXComponent=!0;const jan={toc:[]},Yan="wrapper";function Qan(t){let{components:n,...e}=t;return(0,s.kt)(Yan,(0,p.Z)({},jan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Qan.isMDXComponent=!0;const Han={toc:[]},$an="wrapper";function Kan(t){let{components:n,...e}=t;return(0,s.kt)($an,(0,p.Z)({},Han,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Kan.isMDXComponent=!0;const Jan={toc:[]},tln="wrapper";function nln(t){let{components:n,...e}=t;return(0,s.kt)(tln,(0,p.Z)({},Jan,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}nln.isMDXComponent=!0;const eln={toc:[]},oln="wrapper";function pln(t){let{components:n,...e}=t;return(0,s.kt)(oln,(0,p.Z)({},eln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pln.isMDXComponent=!0;const rln={toc:[]},sln="wrapper";function cln(t){let{components:n,...e}=t;return(0,s.kt)(sln,(0,p.Z)({},rln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}cln.isMDXComponent=!0;const iln={toc:[]},aln="wrapper";function lln(t){let{components:n,...e}=t;return(0,s.kt)(aln,(0,p.Z)({},iln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lln.isMDXComponent=!0;const uln={toc:[]},mln="wrapper";function dln(t){let{components:n,...e}=t;return(0,s.kt)(mln,(0,p.Z)({},uln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}dln.isMDXComponent=!0;const hln={toc:[]},kln="wrapper";function fln(t){let{components:n,...e}=t;return(0,s.kt)(kln,(0,p.Z)({},hln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}fln.isMDXComponent=!0;const yln={toc:[]},Mln="wrapper";function Dln(t){let{components:n,...e}=t;return(0,s.kt)(Mln,(0,p.Z)({},yln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Dln.isMDXComponent=!0;const Xln={toc:[]},_ln="wrapper";function wln(t){let{components:n,...e}=t;return(0,s.kt)(_ln,(0,p.Z)({},Xln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wln.isMDXComponent=!0;const Tln={toc:[]},Cln="wrapper";function gln(t){let{components:n,...e}=t;return(0,s.kt)(Cln,(0,p.Z)({},Tln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}gln.isMDXComponent=!0;const xln={toc:[]},vln="wrapper";function Lln(t){let{components:n,...e}=t;return(0,s.kt)(vln,(0,p.Z)({},xln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lln.isMDXComponent=!0;const Zln={toc:[]},bln="wrapper";function Nln(t){let{components:n,...e}=t;return(0,s.kt)(bln,(0,p.Z)({},Zln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Nln.isMDXComponent=!0;const Aln={toc:[]},zln="wrapper";function Wln(t){let{components:n,...e}=t;return(0,s.kt)(zln,(0,p.Z)({},Aln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Wln.isMDXComponent=!0;const Iln={toc:[]},Rln="wrapper";function Pln(t){let{components:n,...e}=t;return(0,s.kt)(Rln,(0,p.Z)({},Iln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Pln.isMDXComponent=!0;const Sln={toc:[]},Eln="wrapper";function Gln(t){let{components:n,...e}=t;return(0,s.kt)(Eln,(0,p.Z)({},Sln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Gln.isMDXComponent=!0;const Oln={toc:[]},Fln="wrapper";function Bln(t){let{components:n,...e}=t;return(0,s.kt)(Fln,(0,p.Z)({},Oln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Bln.isMDXComponent=!0;const Uln={toc:[]},Vln="wrapper";function qln(t){let{components:n,...e}=t;return(0,s.kt)(Vln,(0,p.Z)({},Uln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}qln.isMDXComponent=!0;const jln={toc:[]},Yln="wrapper";function Qln(t){let{components:n,...e}=t;return(0,s.kt)(Yln,(0,p.Z)({},jln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Qln.isMDXComponent=!0;const Hln={toc:[]},$ln="wrapper";function Kln(t){let{components:n,...e}=t;return(0,s.kt)($ln,(0,p.Z)({},Hln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Kln.isMDXComponent=!0;const Jln={toc:[]},tun="wrapper";function nun(t){let{components:n,...e}=t;return(0,s.kt)(tun,(0,p.Z)({},Jln,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}nun.isMDXComponent=!0;const eun={toc:[]},oun="wrapper";function pun(t){let{components:n,...e}=t;return(0,s.kt)(oun,(0,p.Z)({},eun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}pun.isMDXComponent=!0;const run={toc:[]},sun="wrapper";function cun(t){let{components:n,...e}=t;return(0,s.kt)(sun,(0,p.Z)({},run,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}cun.isMDXComponent=!0;const iun={toc:[]},aun="wrapper";function lun(t){let{components:n,...e}=t;return(0,s.kt)(aun,(0,p.Z)({},iun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}lun.isMDXComponent=!0;const uun={toc:[]},mun="wrapper";function dun(t){let{components:n,...e}=t;return(0,s.kt)(mun,(0,p.Z)({},uun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}dun.isMDXComponent=!0;const hun={toc:[]},kun="wrapper";function fun(t){let{components:n,...e}=t;return(0,s.kt)(kun,(0,p.Z)({},hun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}fun.isMDXComponent=!0;const yun={toc:[]},Mun="wrapper";function Dun(t){let{components:n,...e}=t;return(0,s.kt)(Mun,(0,p.Z)({},yun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Dun.isMDXComponent=!0;const Xun={toc:[]},_un="wrapper";function wun(t){let{components:n,...e}=t;return(0,s.kt)(_un,(0,p.Z)({},Xun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}wun.isMDXComponent=!0;const Tun={toc:[]},Cun="wrapper";function gun(t){let{components:n,...e}=t;return(0,s.kt)(Cun,(0,p.Z)({},Tun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}gun.isMDXComponent=!0;const xun={toc:[]},vun="wrapper";function Lun(t){let{components:n,...e}=t;return(0,s.kt)(vun,(0,p.Z)({},xun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Lun.isMDXComponent=!0;const Zun={toc:[]},bun="wrapper";function Nun(t){let{components:n,...e}=t;return(0,s.kt)(bun,(0,p.Z)({},Zun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Nun.isMDXComponent=!0;const Aun={toc:[]},zun="wrapper";function Wun(t){let{components:n,...e}=t;return(0,s.kt)(zun,(0,p.Z)({},Aun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Wun.isMDXComponent=!0;const Iun={toc:[]},Run="wrapper";function Pun(t){let{components:n,...e}=t;return(0,s.kt)(Run,(0,p.Z)({},Iun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Pun.isMDXComponent=!0;const Sun={toc:[]},Eun="wrapper";function Gun(t){let{components:n,...e}=t;return(0,s.kt)(Eun,(0,p.Z)({},Sun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Gun.isMDXComponent=!0;const Oun={toc:[]},Fun="wrapper";function Bun(t){let{components:n,...e}=t;return(0,s.kt)(Fun,(0,p.Z)({},Oun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Bun.isMDXComponent=!0;const Uun={toc:[]},Vun="wrapper";function qun(t){let{components:n,...e}=t;return(0,s.kt)(Vun,(0,p.Z)({},Uun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}qun.isMDXComponent=!0;const jun={toc:[]},Yun="wrapper";function Qun(t){let{components:n,...e}=t;return(0,s.kt)(Yun,(0,p.Z)({},jun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Qun.isMDXComponent=!0;const Hun={toc:[]},$un="wrapper";function Kun(t){let{components:n,...e}=t;return(0,s.kt)($un,(0,p.Z)({},Hun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Kun.isMDXComponent=!0;const Jun={toc:[]},tmn="wrapper";function nmn(t){let{components:n,...e}=t;return(0,s.kt)(tmn,(0,p.Z)({},Jun,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}nmn.isMDXComponent=!0;const emn={toc:[]},omn="wrapper";function pmn(t){let{components:n,...e}=t;return(0,s.kt)(omn,(0,p.Z)({},emn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}pmn.isMDXComponent=!0;const rmn={toc:[]},smn="wrapper";function cmn(t){let{components:n,...e}=t;return(0,s.kt)(smn,(0,p.Z)({},rmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}cmn.isMDXComponent=!0;const imn={toc:[]},amn="wrapper";function lmn(t){let{components:n,...e}=t;return(0,s.kt)(amn,(0,p.Z)({},imn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}lmn.isMDXComponent=!0;const umn={toc:[]},mmn="wrapper";function dmn(t){let{components:n,...e}=t;return(0,s.kt)(mmn,(0,p.Z)({},umn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}dmn.isMDXComponent=!0;const hmn={toc:[]},kmn="wrapper";function fmn(t){let{components:n,...e}=t;return(0,s.kt)(kmn,(0,p.Z)({},hmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}fmn.isMDXComponent=!0;const ymn={toc:[]},Mmn="wrapper";function Dmn(t){let{components:n,...e}=t;return(0,s.kt)(Mmn,(0,p.Z)({},ymn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Dmn.isMDXComponent=!0;const Xmn={toc:[]},_mn="wrapper";function wmn(t){let{components:n,...e}=t;return(0,s.kt)(_mn,(0,p.Z)({},Xmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}wmn.isMDXComponent=!0;const Tmn={toc:[]},Cmn="wrapper";function gmn(t){let{components:n,...e}=t;return(0,s.kt)(Cmn,(0,p.Z)({},Tmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}gmn.isMDXComponent=!0;const xmn={toc:[]},vmn="wrapper";function Lmn(t){let{components:n,...e}=t;return(0,s.kt)(vmn,(0,p.Z)({},xmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Lmn.isMDXComponent=!0;const Zmn={toc:[]},bmn="wrapper";function Nmn(t){let{components:n,...e}=t;return(0,s.kt)(bmn,(0,p.Z)({},Zmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Nmn.isMDXComponent=!0;const Amn={toc:[]},zmn="wrapper";function Wmn(t){let{components:n,...e}=t;return(0,s.kt)(zmn,(0,p.Z)({},Amn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Wmn.isMDXComponent=!0;const Imn={toc:[]},Rmn="wrapper";function Pmn(t){let{components:n,...e}=t;return(0,s.kt)(Rmn,(0,p.Z)({},Imn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Pmn.isMDXComponent=!0;const Smn={toc:[]},Emn="wrapper";function Gmn(t){let{components:n,...e}=t;return(0,s.kt)(Emn,(0,p.Z)({},Smn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Gmn.isMDXComponent=!0;const Omn={toc:[]},Fmn="wrapper";function Bmn(t){let{components:n,...e}=t;return(0,s.kt)(Fmn,(0,p.Z)({},Omn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Bmn.isMDXComponent=!0;const Umn={toc:[]},Vmn="wrapper";function qmn(t){let{components:n,...e}=t;return(0,s.kt)(Vmn,(0,p.Z)({},Umn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}qmn.isMDXComponent=!0;const jmn={toc:[]},Ymn="wrapper";function Qmn(t){let{components:n,...e}=t;return(0,s.kt)(Ymn,(0,p.Z)({},jmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Qmn.isMDXComponent=!0;const Hmn={toc:[]},$mn="wrapper";function Kmn(t){let{components:n,...e}=t;return(0,s.kt)($mn,(0,p.Z)({},Hmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Kmn.isMDXComponent=!0;const Jmn={toc:[]},tdn="wrapper";function ndn(t){let{components:n,...e}=t;return(0,s.kt)(tdn,(0,p.Z)({},Jmn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}ndn.isMDXComponent=!0;const edn={toc:[]},odn="wrapper";function pdn(t){let{components:n,...e}=t;return(0,s.kt)(odn,(0,p.Z)({},edn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}pdn.isMDXComponent=!0;const rdn={toc:[]},sdn="wrapper";function cdn(t){let{components:n,...e}=t;return(0,s.kt)(sdn,(0,p.Z)({},rdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}cdn.isMDXComponent=!0;const idn={toc:[]},adn="wrapper";function ldn(t){let{components:n,...e}=t;return(0,s.kt)(adn,(0,p.Z)({},idn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}ldn.isMDXComponent=!0;const udn={toc:[]},mdn="wrapper";function ddn(t){let{components:n,...e}=t;return(0,s.kt)(mdn,(0,p.Z)({},udn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ddn.isMDXComponent=!0;const hdn={toc:[]},kdn="wrapper";function fdn(t){let{components:n,...e}=t;return(0,s.kt)(kdn,(0,p.Z)({},hdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}fdn.isMDXComponent=!0;const ydn={toc:[]},Mdn="wrapper";function Ddn(t){let{components:n,...e}=t;return(0,s.kt)(Mdn,(0,p.Z)({},ydn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Ddn.isMDXComponent=!0;const Xdn={toc:[]},_dn="wrapper";function wdn(t){let{components:n,...e}=t;return(0,s.kt)(_dn,(0,p.Z)({},Xdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}wdn.isMDXComponent=!0;const Tdn={toc:[]},Cdn="wrapper";function gdn(t){let{components:n,...e}=t;return(0,s.kt)(Cdn,(0,p.Z)({},Tdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}gdn.isMDXComponent=!0;const xdn={toc:[]},vdn="wrapper";function Ldn(t){let{components:n,...e}=t;return(0,s.kt)(vdn,(0,p.Z)({},xdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Ldn.isMDXComponent=!0;const Zdn={toc:[]},bdn="wrapper";function Ndn(t){let{components:n,...e}=t;return(0,s.kt)(bdn,(0,p.Z)({},Zdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Ndn.isMDXComponent=!0;const Adn={toc:[]},zdn="wrapper";function Wdn(t){let{components:n,...e}=t;return(0,s.kt)(zdn,(0,p.Z)({},Adn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Wdn.isMDXComponent=!0;const Idn={toc:[]},Rdn="wrapper";function Pdn(t){let{components:n,...e}=t;return(0,s.kt)(Rdn,(0,p.Z)({},Idn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Pdn.isMDXComponent=!0;const Sdn={toc:[]},Edn="wrapper";function Gdn(t){let{components:n,...e}=t;return(0,s.kt)(Edn,(0,p.Z)({},Sdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Gdn.isMDXComponent=!0;const Odn={toc:[]},Fdn="wrapper";function Bdn(t){let{components:n,...e}=t;return(0,s.kt)(Fdn,(0,p.Z)({},Odn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Bdn.isMDXComponent=!0;const Udn={toc:[]},Vdn="wrapper";function qdn(t){let{components:n,...e}=t;return(0,s.kt)(Vdn,(0,p.Z)({},Udn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}qdn.isMDXComponent=!0;const jdn={toc:[]},Ydn="wrapper";function Qdn(t){let{components:n,...e}=t;return(0,s.kt)(Ydn,(0,p.Z)({},jdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Qdn.isMDXComponent=!0;const Hdn={toc:[]},$dn="wrapper";function Kdn(t){let{components:n,...e}=t;return(0,s.kt)($dn,(0,p.Z)({},Hdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Kdn.isMDXComponent=!0;const Jdn={toc:[]},thn="wrapper";function nhn(t){let{components:n,...e}=t;return(0,s.kt)(thn,(0,p.Z)({},Jdn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}nhn.isMDXComponent=!0;const ehn={toc:[]},ohn="wrapper";function phn(t){let{components:n,...e}=t;return(0,s.kt)(ohn,(0,p.Z)({},ehn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}phn.isMDXComponent=!0;const rhn={toc:[]},shn="wrapper";function chn(t){let{components:n,...e}=t;return(0,s.kt)(shn,(0,p.Z)({},rhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}chn.isMDXComponent=!0;const ihn={toc:[]},ahn="wrapper";function lhn(t){let{components:n,...e}=t;return(0,s.kt)(ahn,(0,p.Z)({},ihn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}lhn.isMDXComponent=!0;const uhn={toc:[]},mhn="wrapper";function dhn(t){let{components:n,...e}=t;return(0,s.kt)(mhn,(0,p.Z)({},uhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}dhn.isMDXComponent=!0;const hhn={toc:[]},khn="wrapper";function fhn(t){let{components:n,...e}=t;return(0,s.kt)(khn,(0,p.Z)({},hhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}fhn.isMDXComponent=!0;const yhn={toc:[]},Mhn="wrapper";function Dhn(t){let{components:n,...e}=t;return(0,s.kt)(Mhn,(0,p.Z)({},yhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Dhn.isMDXComponent=!0;const Xhn={toc:[]},_hn="wrapper";function whn(t){let{components:n,...e}=t;return(0,s.kt)(_hn,(0,p.Z)({},Xhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}whn.isMDXComponent=!0;const Thn={toc:[]},Chn="wrapper";function ghn(t){let{components:n,...e}=t;return(0,s.kt)(Chn,(0,p.Z)({},Thn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}ghn.isMDXComponent=!0;const xhn={toc:[]},vhn="wrapper";function Lhn(t){let{components:n,...e}=t;return(0,s.kt)(vhn,(0,p.Z)({},xhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Lhn.isMDXComponent=!0;const Zhn={toc:[]},bhn="wrapper";function Nhn(t){let{components:n,...e}=t;return(0,s.kt)(bhn,(0,p.Z)({},Zhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Nhn.isMDXComponent=!0;const Ahn={toc:[]},zhn="wrapper";function Whn(t){let{components:n,...e}=t;return(0,s.kt)(zhn,(0,p.Z)({},Ahn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Whn.isMDXComponent=!0;const Ihn={toc:[]},Rhn="wrapper";function Phn(t){let{components:n,...e}=t;return(0,s.kt)(Rhn,(0,p.Z)({},Ihn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Phn.isMDXComponent=!0;const Shn={toc:[]},Ehn="wrapper";function Ghn(t){let{components:n,...e}=t;return(0,s.kt)(Ehn,(0,p.Z)({},Shn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Ghn.isMDXComponent=!0;const Ohn={toc:[]},Fhn="wrapper";function Bhn(t){let{components:n,...e}=t;return(0,s.kt)(Fhn,(0,p.Z)({},Ohn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Bhn.isMDXComponent=!0;const Uhn={toc:[]},Vhn="wrapper";function qhn(t){let{components:n,...e}=t;return(0,s.kt)(Vhn,(0,p.Z)({},Uhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}qhn.isMDXComponent=!0;const jhn={toc:[]},Yhn="wrapper";function Qhn(t){let{components:n,...e}=t;return(0,s.kt)(Yhn,(0,p.Z)({},jhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Qhn.isMDXComponent=!0;const Hhn={toc:[]},$hn="wrapper";function Khn(t){let{components:n,...e}=t;return(0,s.kt)($hn,(0,p.Z)({},Hhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Khn.isMDXComponent=!0;const Jhn={toc:[]},tkn="wrapper";function nkn(t){let{components:n,...e}=t;return(0,s.kt)(tkn,(0,p.Z)({},Jhn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}nkn.isMDXComponent=!0;const ekn={toc:[]},okn="wrapper";function pkn(t){let{components:n,...e}=t;return(0,s.kt)(okn,(0,p.Z)({},ekn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}pkn.isMDXComponent=!0;const rkn={toc:[]},skn="wrapper";function ckn(t){let{components:n,...e}=t;return(0,s.kt)(skn,(0,p.Z)({},rkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}ckn.isMDXComponent=!0;const ikn={toc:[]},akn="wrapper";function lkn(t){let{components:n,...e}=t;return(0,s.kt)(akn,(0,p.Z)({},ikn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}lkn.isMDXComponent=!0;const ukn={toc:[]},mkn="wrapper";function dkn(t){let{components:n,...e}=t;return(0,s.kt)(mkn,(0,p.Z)({},ukn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}dkn.isMDXComponent=!0;const hkn={toc:[]},kkn="wrapper";function fkn(t){let{components:n,...e}=t;return(0,s.kt)(kkn,(0,p.Z)({},hkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}fkn.isMDXComponent=!0;const ykn={toc:[]},Mkn="wrapper";function Dkn(t){let{components:n,...e}=t;return(0,s.kt)(Mkn,(0,p.Z)({},ykn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Dkn.isMDXComponent=!0;const Xkn={toc:[]},_kn="wrapper";function wkn(t){let{components:n,...e}=t;return(0,s.kt)(_kn,(0,p.Z)({},Xkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}wkn.isMDXComponent=!0;const Tkn={toc:[]},Ckn="wrapper";function gkn(t){let{components:n,...e}=t;return(0,s.kt)(Ckn,(0,p.Z)({},Tkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Latex, makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Latex\n      // Note how this uses \\color to set the color.\n      tex=\"{\\color{white} ax^2+bx+c=0 \\implies x=\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}}\"\n      width={600} // height and width can calculate based on each other\n    />,\n  );\n});\n")))}gkn.isMDXComponent=!0;const xkn={toc:[]},vkn="wrapper";function Lkn(t){let{components:n,...e}=t;return(0,s.kt)(vkn,(0,p.Z)({},xkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for rendering equations with LaTeX."))}Lkn.isMDXComponent=!0;const Zkn={toc:[]},bkn="wrapper";function Nkn(t){let{components:n,...e}=t;return(0,s.kt)(bkn,(0,p.Z)({},Zkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Nkn.isMDXComponent=!0;const Akn={toc:[]},zkn="wrapper";function Wkn(t){let{components:n,...e}=t;return(0,s.kt)(zkn,(0,p.Z)({},Akn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Wkn.isMDXComponent=!0;const Ikn={toc:[]},Rkn="wrapper";function Pkn(t){let{components:n,...e}=t;return(0,s.kt)(Rkn,(0,p.Z)({},Ikn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Pkn.isMDXComponent=!0;const Skn={toc:[]},Ekn="wrapper";function Gkn(t){let{components:n,...e}=t;return(0,s.kt)(Ekn,(0,p.Z)({},Skn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Gkn.isMDXComponent=!0;const Okn={toc:[]},Fkn="wrapper";function Bkn(t){let{components:n,...e}=t;return(0,s.kt)(Fkn,(0,p.Z)({},Okn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Bkn.isMDXComponent=!0;const Ukn={toc:[]},Vkn="wrapper";function qkn(t){let{components:n,...e}=t;return(0,s.kt)(Vkn,(0,p.Z)({},Ukn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}qkn.isMDXComponent=!0;const jkn={toc:[]},Ykn="wrapper";function Qkn(t){let{components:n,...e}=t;return(0,s.kt)(Ykn,(0,p.Z)({},jkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Qkn.isMDXComponent=!0;const Hkn={toc:[]},$kn="wrapper";function Kkn(t){let{components:n,...e}=t;return(0,s.kt)($kn,(0,p.Z)({},Hkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Kkn.isMDXComponent=!0;const Jkn={toc:[]},tfn="wrapper";function nfn(t){let{components:n,...e}=t;return(0,s.kt)(tfn,(0,p.Z)({},Jkn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}nfn.isMDXComponent=!0;const efn={toc:[]},ofn="wrapper";function pfn(t){let{components:n,...e}=t;return(0,s.kt)(ofn,(0,p.Z)({},efn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}pfn.isMDXComponent=!0;const rfn={toc:[]},sfn="wrapper";function cfn(t){let{components:n,...e}=t;return(0,s.kt)(sfn,(0,p.Z)({},rfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}cfn.isMDXComponent=!0;const ifn={toc:[]},afn="wrapper";function lfn(t){let{components:n,...e}=t;return(0,s.kt)(afn,(0,p.Z)({},ifn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}lfn.isMDXComponent=!0;const ufn={toc:[]},mfn="wrapper";function dfn(t){let{components:n,...e}=t;return(0,s.kt)(mfn,(0,p.Z)({},ufn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}dfn.isMDXComponent=!0;const hfn={toc:[]},kfn="wrapper";function ffn(t){let{components:n,...e}=t;return(0,s.kt)(kfn,(0,p.Z)({},hfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}ffn.isMDXComponent=!0;const yfn={toc:[]},Mfn="wrapper";function Dfn(t){let{components:n,...e}=t;return(0,s.kt)(Mfn,(0,p.Z)({},yfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Dfn.isMDXComponent=!0;const Xfn={toc:[]},_fn="wrapper";function wfn(t){let{components:n,...e}=t;return(0,s.kt)(_fn,(0,p.Z)({},Xfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}wfn.isMDXComponent=!0;const Tfn={toc:[]},Cfn="wrapper";function gfn(t){let{components:n,...e}=t;return(0,s.kt)(Cfn,(0,p.Z)({},Tfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}gfn.isMDXComponent=!0;const xfn={toc:[]},vfn="wrapper";function Lfn(t){let{components:n,...e}=t;return(0,s.kt)(vfn,(0,p.Z)({},xfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Lfn.isMDXComponent=!0;const Zfn={toc:[]},bfn="wrapper";function Nfn(t){let{components:n,...e}=t;return(0,s.kt)(bfn,(0,p.Z)({},Zfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Nfn.isMDXComponent=!0;const Afn={toc:[]},zfn="wrapper";function Wfn(t){let{components:n,...e}=t;return(0,s.kt)(zfn,(0,p.Z)({},Afn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Wfn.isMDXComponent=!0;const Ifn={toc:[]},Rfn="wrapper";function Pfn(t){let{components:n,...e}=t;return(0,s.kt)(Rfn,(0,p.Z)({},Ifn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Pfn.isMDXComponent=!0;const Sfn={toc:[]},Efn="wrapper";function Gfn(t){let{components:n,...e}=t;return(0,s.kt)(Efn,(0,p.Z)({},Sfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Gfn.isMDXComponent=!0;const Ofn={toc:[]},Ffn="wrapper";function Bfn(t){let{components:n,...e}=t;return(0,s.kt)(Ffn,(0,p.Z)({},Ofn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Bfn.isMDXComponent=!0;const Ufn={toc:[]},Vfn="wrapper";function qfn(t){let{components:n,...e}=t;return(0,s.kt)(Vfn,(0,p.Z)({},Ufn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qfn.isMDXComponent=!0;const jfn={toc:[]},Yfn="wrapper";function Qfn(t){let{components:n,...e}=t;return(0,s.kt)(Yfn,(0,p.Z)({},jfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Qfn.isMDXComponent=!0;const Hfn={toc:[]},$fn="wrapper";function Kfn(t){let{components:n,...e}=t;return(0,s.kt)($fn,(0,p.Z)({},Hfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Kfn.isMDXComponent=!0;const Jfn={toc:[]},tyn="wrapper";function nyn(t){let{components:n,...e}=t;return(0,s.kt)(tyn,(0,p.Z)({},Jfn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}nyn.isMDXComponent=!0;const eyn={toc:[]},oyn="wrapper";function pyn(t){let{components:n,...e}=t;return(0,s.kt)(oyn,(0,p.Z)({},eyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}pyn.isMDXComponent=!0;const ryn={toc:[]},syn="wrapper";function cyn(t){let{components:n,...e}=t;return(0,s.kt)(syn,(0,p.Z)({},ryn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}cyn.isMDXComponent=!0;const iyn={toc:[]},ayn="wrapper";function lyn(t){let{components:n,...e}=t;return(0,s.kt)(ayn,(0,p.Z)({},iyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}lyn.isMDXComponent=!0;const uyn={toc:[]},myn="wrapper";function dyn(t){let{components:n,...e}=t;return(0,s.kt)(myn,(0,p.Z)({},uyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}dyn.isMDXComponent=!0;const hyn={toc:[]},kyn="wrapper";function fyn(t){let{components:n,...e}=t;return(0,s.kt)(kyn,(0,p.Z)({},hyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}fyn.isMDXComponent=!0;const yyn={toc:[]},Myn="wrapper";function Dyn(t){let{components:n,...e}=t;return(0,s.kt)(Myn,(0,p.Z)({},yyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Dyn.isMDXComponent=!0;const Xyn={toc:[]},_yn="wrapper";function wyn(t){let{components:n,...e}=t;return(0,s.kt)(_yn,(0,p.Z)({},Xyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}wyn.isMDXComponent=!0;const Tyn={toc:[]},Cyn="wrapper";function gyn(t){let{components:n,...e}=t;return(0,s.kt)(Cyn,(0,p.Z)({},Tyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}gyn.isMDXComponent=!0;const xyn={toc:[]},vyn="wrapper";function Lyn(t){let{components:n,...e}=t;return(0,s.kt)(vyn,(0,p.Z)({},xyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Lyn.isMDXComponent=!0;const Zyn={toc:[]},byn="wrapper";function Nyn(t){let{components:n,...e}=t;return(0,s.kt)(byn,(0,p.Z)({},Zyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Nyn.isMDXComponent=!0;const Ayn={toc:[]},zyn="wrapper";function Wyn(t){let{components:n,...e}=t;return(0,s.kt)(zyn,(0,p.Z)({},Ayn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Wyn.isMDXComponent=!0;const Iyn={toc:[]},Ryn="wrapper";function Pyn(t){let{components:n,...e}=t;return(0,s.kt)(Ryn,(0,p.Z)({},Iyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Pyn.isMDXComponent=!0;const Syn={toc:[]},Eyn="wrapper";function Gyn(t){let{components:n,...e}=t;return(0,s.kt)(Eyn,(0,p.Z)({},Syn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Gyn.isMDXComponent=!0;const Oyn={toc:[]},Fyn="wrapper";function Byn(t){let{components:n,...e}=t;return(0,s.kt)(Fyn,(0,p.Z)({},Oyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Byn.isMDXComponent=!0;const Uyn={toc:[]},Vyn="wrapper";function qyn(t){let{components:n,...e}=t;return(0,s.kt)(Vyn,(0,p.Z)({},Uyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}qyn.isMDXComponent=!0;const jyn={toc:[]},Yyn="wrapper";function Qyn(t){let{components:n,...e}=t;return(0,s.kt)(Yyn,(0,p.Z)({},jyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Qyn.isMDXComponent=!0;const Hyn={toc:[]},$yn="wrapper";function Kyn(t){let{components:n,...e}=t;return(0,s.kt)($yn,(0,p.Z)({},Hyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Kyn.isMDXComponent=!0;const Jyn={toc:[]},tMn="wrapper";function nMn(t){let{components:n,...e}=t;return(0,s.kt)(tMn,(0,p.Z)({},Jyn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}nMn.isMDXComponent=!0;const eMn={toc:[]},oMn="wrapper";function pMn(t){let{components:n,...e}=t;return(0,s.kt)(oMn,(0,p.Z)({},eMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}pMn.isMDXComponent=!0;const rMn={toc:[]},sMn="wrapper";function cMn(t){let{components:n,...e}=t;return(0,s.kt)(sMn,(0,p.Z)({},rMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}cMn.isMDXComponent=!0;const iMn={toc:[]},aMn="wrapper";function lMn(t){let{components:n,...e}=t;return(0,s.kt)(aMn,(0,p.Z)({},iMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}lMn.isMDXComponent=!0;const uMn={toc:[]},mMn="wrapper";function dMn(t){let{components:n,...e}=t;return(0,s.kt)(mMn,(0,p.Z)({},uMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}dMn.isMDXComponent=!0;const hMn={toc:[]},kMn="wrapper";function fMn(t){let{components:n,...e}=t;return(0,s.kt)(kMn,(0,p.Z)({},hMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}fMn.isMDXComponent=!0;const yMn={toc:[]},MMn="wrapper";function DMn(t){let{components:n,...e}=t;return(0,s.kt)(MMn,(0,p.Z)({},yMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}DMn.isMDXComponent=!0;const XMn={toc:[]},_Mn="wrapper";function wMn(t){let{components:n,...e}=t;return(0,s.kt)(_Mn,(0,p.Z)({},XMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}wMn.isMDXComponent=!0;const TMn={toc:[]},CMn="wrapper";function gMn(t){let{components:n,...e}=t;return(0,s.kt)(CMn,(0,p.Z)({},TMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}gMn.isMDXComponent=!0;const xMn={toc:[]},vMn="wrapper";function LMn(t){let{components:n,...e}=t;return(0,s.kt)(vMn,(0,p.Z)({},xMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}LMn.isMDXComponent=!0;const ZMn={toc:[]},bMn="wrapper";function NMn(t){let{components:n,...e}=t;return(0,s.kt)(bMn,(0,p.Z)({},ZMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}NMn.isMDXComponent=!0;const AMn={toc:[]},zMn="wrapper";function WMn(t){let{components:n,...e}=t;return(0,s.kt)(zMn,(0,p.Z)({},AMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}WMn.isMDXComponent=!0;const IMn={toc:[]},RMn="wrapper";function PMn(t){let{components:n,...e}=t;return(0,s.kt)(RMn,(0,p.Z)({},IMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}PMn.isMDXComponent=!0;const SMn={toc:[]},EMn="wrapper";function GMn(t){let{components:n,...e}=t;return(0,s.kt)(EMn,(0,p.Z)({},SMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}GMn.isMDXComponent=!0;const OMn={toc:[]},FMn="wrapper";function BMn(t){let{components:n,...e}=t;return(0,s.kt)(FMn,(0,p.Z)({},OMn,e,{components:n,mdxType:"MDXLayout"}))}BMn.isMDXComponent=!0;const UMn={toc:[]},VMn="wrapper";function qMn(t){let{components:n,...e}=t;return(0,s.kt)(VMn,(0,p.Z)({},UMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}qMn.isMDXComponent=!0;const jMn={toc:[]},YMn="wrapper";function QMn(t){let{components:n,...e}=t;return(0,s.kt)(YMn,(0,p.Z)({},jMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}QMn.isMDXComponent=!0;const HMn={toc:[]},$Mn="wrapper";function KMn(t){let{components:n,...e}=t;return(0,s.kt)($Mn,(0,p.Z)({},HMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}KMn.isMDXComponent=!0;const JMn={toc:[]},tDn="wrapper";function nDn(t){let{components:n,...e}=t;return(0,s.kt)(tDn,(0,p.Z)({},JMn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}nDn.isMDXComponent=!0;const eDn={toc:[]},oDn="wrapper";function pDn(t){let{components:n,...e}=t;return(0,s.kt)(oDn,(0,p.Z)({},eDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pDn.isMDXComponent=!0;const rDn={toc:[]},sDn="wrapper";function cDn(t){let{components:n,...e}=t;return(0,s.kt)(sDn,(0,p.Z)({},rDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}cDn.isMDXComponent=!0;const iDn={toc:[]},aDn="wrapper";function lDn(t){let{components:n,...e}=t;return(0,s.kt)(aDn,(0,p.Z)({},iDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lDn.isMDXComponent=!0;const uDn={toc:[]},mDn="wrapper";function dDn(t){let{components:n,...e}=t;return(0,s.kt)(mDn,(0,p.Z)({},uDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}dDn.isMDXComponent=!0;const hDn={toc:[]},kDn="wrapper";function fDn(t){let{components:n,...e}=t;return(0,s.kt)(kDn,(0,p.Z)({},hDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}fDn.isMDXComponent=!0;const yDn={toc:[]},MDn="wrapper";function DDn(t){let{components:n,...e}=t;return(0,s.kt)(MDn,(0,p.Z)({},yDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}DDn.isMDXComponent=!0;const XDn={toc:[]},_Dn="wrapper";function wDn(t){let{components:n,...e}=t;return(0,s.kt)(_Dn,(0,p.Z)({},XDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}wDn.isMDXComponent=!0;const TDn={toc:[]},CDn="wrapper";function gDn(t){let{components:n,...e}=t;return(0,s.kt)(CDn,(0,p.Z)({},TDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}gDn.isMDXComponent=!0;const xDn={toc:[]},vDn="wrapper";function LDn(t){let{components:n,...e}=t;return(0,s.kt)(vDn,(0,p.Z)({},xDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}LDn.isMDXComponent=!0;const ZDn={toc:[]},bDn="wrapper";function NDn(t){let{components:n,...e}=t;return(0,s.kt)(bDn,(0,p.Z)({},ZDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}NDn.isMDXComponent=!0;const ADn={toc:[]},zDn="wrapper";function WDn(t){let{components:n,...e}=t;return(0,s.kt)(zDn,(0,p.Z)({},ADn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}WDn.isMDXComponent=!0;const IDn={toc:[]},RDn="wrapper";function PDn(t){let{components:n,...e}=t;return(0,s.kt)(RDn,(0,p.Z)({},IDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}PDn.isMDXComponent=!0;const SDn={toc:[]},EDn="wrapper";function GDn(t){let{components:n,...e}=t;return(0,s.kt)(EDn,(0,p.Z)({},SDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}GDn.isMDXComponent=!0;const ODn={toc:[]},FDn="wrapper";function BDn(t){let{components:n,...e}=t;return(0,s.kt)(FDn,(0,p.Z)({},ODn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}BDn.isMDXComponent=!0;const UDn={toc:[]},VDn="wrapper";function qDn(t){let{components:n,...e}=t;return(0,s.kt)(VDn,(0,p.Z)({},UDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}qDn.isMDXComponent=!0;const jDn={toc:[]},YDn="wrapper";function QDn(t){let{components:n,...e}=t;return(0,s.kt)(YDn,(0,p.Z)({},jDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}QDn.isMDXComponent=!0;const HDn={toc:[]},$Dn="wrapper";function KDn(t){let{components:n,...e}=t;return(0,s.kt)($Dn,(0,p.Z)({},HDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}KDn.isMDXComponent=!0;const JDn={toc:[]},tXn="wrapper";function nXn(t){let{components:n,...e}=t;return(0,s.kt)(tXn,(0,p.Z)({},JDn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}nXn.isMDXComponent=!0;const eXn={toc:[]},oXn="wrapper";function pXn(t){let{components:n,...e}=t;return(0,s.kt)(oXn,(0,p.Z)({},eXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}pXn.isMDXComponent=!0;const rXn={toc:[]},sXn="wrapper";function cXn(t){let{components:n,...e}=t;return(0,s.kt)(sXn,(0,p.Z)({},rXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}cXn.isMDXComponent=!0;const iXn={toc:[]},aXn="wrapper";function lXn(t){let{components:n,...e}=t;return(0,s.kt)(aXn,(0,p.Z)({},iXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}lXn.isMDXComponent=!0;const uXn={toc:[]},mXn="wrapper";function dXn(t){let{components:n,...e}=t;return(0,s.kt)(mXn,(0,p.Z)({},uXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}dXn.isMDXComponent=!0;const hXn={toc:[]},kXn="wrapper";function fXn(t){let{components:n,...e}=t;return(0,s.kt)(kXn,(0,p.Z)({},hXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}fXn.isMDXComponent=!0;const yXn={toc:[]},MXn="wrapper";function DXn(t){let{components:n,...e}=t;return(0,s.kt)(MXn,(0,p.Z)({},yXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}DXn.isMDXComponent=!0;const XXn={toc:[]},_Xn="wrapper";function wXn(t){let{components:n,...e}=t;return(0,s.kt)(_Xn,(0,p.Z)({},XXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}wXn.isMDXComponent=!0;const TXn={toc:[]},CXn="wrapper";function gXn(t){let{components:n,...e}=t;return(0,s.kt)(CXn,(0,p.Z)({},TXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}gXn.isMDXComponent=!0;const xXn={toc:[]},vXn="wrapper";function LXn(t){let{components:n,...e}=t;return(0,s.kt)(vXn,(0,p.Z)({},xXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}LXn.isMDXComponent=!0;const ZXn={toc:[]},bXn="wrapper";function NXn(t){let{components:n,...e}=t;return(0,s.kt)(bXn,(0,p.Z)({},ZXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}NXn.isMDXComponent=!0;const AXn={toc:[]},zXn="wrapper";function WXn(t){let{components:n,...e}=t;return(0,s.kt)(zXn,(0,p.Z)({},AXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}WXn.isMDXComponent=!0;const IXn={toc:[]},RXn="wrapper";function PXn(t){let{components:n,...e}=t;return(0,s.kt)(RXn,(0,p.Z)({},IXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}PXn.isMDXComponent=!0;const SXn={toc:[]},EXn="wrapper";function GXn(t){let{components:n,...e}=t;return(0,s.kt)(EXn,(0,p.Z)({},SXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}GXn.isMDXComponent=!0;const OXn={toc:[]},FXn="wrapper";function BXn(t){let{components:n,...e}=t;return(0,s.kt)(FXn,(0,p.Z)({},OXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}BXn.isMDXComponent=!0;const UXn={toc:[]},VXn="wrapper";function qXn(t){let{components:n,...e}=t;return(0,s.kt)(VXn,(0,p.Z)({},UXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}qXn.isMDXComponent=!0;const jXn={toc:[]},YXn="wrapper";function QXn(t){let{components:n,...e}=t;return(0,s.kt)(YXn,(0,p.Z)({},jXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}QXn.isMDXComponent=!0;const HXn={toc:[]},$Xn="wrapper";function KXn(t){let{components:n,...e}=t;return(0,s.kt)($Xn,(0,p.Z)({},HXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}KXn.isMDXComponent=!0;const JXn={toc:[]},t_n="wrapper";function n_n(t){let{components:n,...e}=t;return(0,s.kt)(t_n,(0,p.Z)({},JXn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}n_n.isMDXComponent=!0;const e_n={toc:[]},o_n="wrapper";function p_n(t){let{components:n,...e}=t;return(0,s.kt)(o_n,(0,p.Z)({},e_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}p_n.isMDXComponent=!0;const r_n={toc:[]},s_n="wrapper";function c_n(t){let{components:n,...e}=t;return(0,s.kt)(s_n,(0,p.Z)({},r_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}c_n.isMDXComponent=!0;const i_n={toc:[]},a_n="wrapper";function l_n(t){let{components:n,...e}=t;return(0,s.kt)(a_n,(0,p.Z)({},i_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}l_n.isMDXComponent=!0;const u_n={toc:[]},m_n="wrapper";function d_n(t){let{components:n,...e}=t;return(0,s.kt)(m_n,(0,p.Z)({},u_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}d_n.isMDXComponent=!0;const h_n={toc:[]},k_n="wrapper";function f_n(t){let{components:n,...e}=t;return(0,s.kt)(k_n,(0,p.Z)({},h_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}f_n.isMDXComponent=!0;const y_n={toc:[]},M_n="wrapper";function D_n(t){let{components:n,...e}=t;return(0,s.kt)(M_n,(0,p.Z)({},y_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}D_n.isMDXComponent=!0;const X_n={toc:[]},__n="wrapper";function w_n(t){let{components:n,...e}=t;return(0,s.kt)(__n,(0,p.Z)({},X_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}w_n.isMDXComponent=!0;const T_n={toc:[]},C_n="wrapper";function g_n(t){let{components:n,...e}=t;return(0,s.kt)(C_n,(0,p.Z)({},T_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}g_n.isMDXComponent=!0;const x_n={toc:[]},v_n="wrapper";function L_n(t){let{components:n,...e}=t;return(0,s.kt)(v_n,(0,p.Z)({},x_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}L_n.isMDXComponent=!0;const Z_n={toc:[]},b_n="wrapper";function N_n(t){let{components:n,...e}=t;return(0,s.kt)(b_n,(0,p.Z)({},Z_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}N_n.isMDXComponent=!0;const A_n={toc:[]},z_n="wrapper";function W_n(t){let{components:n,...e}=t;return(0,s.kt)(z_n,(0,p.Z)({},A_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}W_n.isMDXComponent=!0;const I_n={toc:[]},R_n="wrapper";function P_n(t){let{components:n,...e}=t;return(0,s.kt)(R_n,(0,p.Z)({},I_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}P_n.isMDXComponent=!0;const S_n={toc:[]},E_n="wrapper";function G_n(t){let{components:n,...e}=t;return(0,s.kt)(E_n,(0,p.Z)({},S_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}G_n.isMDXComponent=!0;const O_n={toc:[]},F_n="wrapper";function B_n(t){let{components:n,...e}=t;return(0,s.kt)(F_n,(0,p.Z)({},O_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}B_n.isMDXComponent=!0;const U_n={toc:[]},V_n="wrapper";function q_n(t){let{components:n,...e}=t;return(0,s.kt)(V_n,(0,p.Z)({},U_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}q_n.isMDXComponent=!0;const j_n={toc:[]},Y_n="wrapper";function Q_n(t){let{components:n,...e}=t;return(0,s.kt)(Y_n,(0,p.Z)({},j_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Q_n.isMDXComponent=!0;const H_n={toc:[]},$_n="wrapper";function K_n(t){let{components:n,...e}=t;return(0,s.kt)($_n,(0,p.Z)({},H_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}K_n.isMDXComponent=!0;const J_n={toc:[]},twn="wrapper";function nwn(t){let{components:n,...e}=t;return(0,s.kt)(twn,(0,p.Z)({},J_n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}nwn.isMDXComponent=!0;const ewn={toc:[]},own="wrapper";function pwn(t){let{components:n,...e}=t;return(0,s.kt)(own,(0,p.Z)({},ewn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}pwn.isMDXComponent=!0;const rwn={toc:[]},swn="wrapper";function cwn(t){let{components:n,...e}=t;return(0,s.kt)(swn,(0,p.Z)({},rwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cwn.isMDXComponent=!0;const iwn={toc:[]},awn="wrapper";function lwn(t){let{components:n,...e}=t;return(0,s.kt)(awn,(0,p.Z)({},iwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}lwn.isMDXComponent=!0;const uwn={toc:[]},mwn="wrapper";function dwn(t){let{components:n,...e}=t;return(0,s.kt)(mwn,(0,p.Z)({},uwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dwn.isMDXComponent=!0;const hwn={toc:[]},kwn="wrapper";function fwn(t){let{components:n,...e}=t;return(0,s.kt)(kwn,(0,p.Z)({},hwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}fwn.isMDXComponent=!0;const ywn={toc:[]},Mwn="wrapper";function Dwn(t){let{components:n,...e}=t;return(0,s.kt)(Mwn,(0,p.Z)({},ywn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Dwn.isMDXComponent=!0;const Xwn={toc:[]},_wn="wrapper";function wwn(t){let{components:n,...e}=t;return(0,s.kt)(_wn,(0,p.Z)({},Xwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}wwn.isMDXComponent=!0;const Twn={toc:[]},Cwn="wrapper";function gwn(t){let{components:n,...e}=t;return(0,s.kt)(Cwn,(0,p.Z)({},Twn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}gwn.isMDXComponent=!0;const xwn={toc:[]},vwn="wrapper";function Lwn(t){let{components:n,...e}=t;return(0,s.kt)(vwn,(0,p.Z)({},xwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Lwn.isMDXComponent=!0;const Zwn={toc:[]},bwn="wrapper";function Nwn(t){let{components:n,...e}=t;return(0,s.kt)(bwn,(0,p.Z)({},Zwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Nwn.isMDXComponent=!0;const Awn={toc:[]},zwn="wrapper";function Wwn(t){let{components:n,...e}=t;return(0,s.kt)(zwn,(0,p.Z)({},Awn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Wwn.isMDXComponent=!0;const Iwn={toc:[]},Rwn="wrapper";function Pwn(t){let{components:n,...e}=t;return(0,s.kt)(Rwn,(0,p.Z)({},Iwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Pwn.isMDXComponent=!0;const Swn={toc:[]},Ewn="wrapper";function Gwn(t){let{components:n,...e}=t;return(0,s.kt)(Ewn,(0,p.Z)({},Swn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Gwn.isMDXComponent=!0;const Own={toc:[]},Fwn="wrapper";function Bwn(t){let{components:n,...e}=t;return(0,s.kt)(Fwn,(0,p.Z)({},Own,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Bwn.isMDXComponent=!0;const Uwn={toc:[]},Vwn="wrapper";function qwn(t){let{components:n,...e}=t;return(0,s.kt)(Vwn,(0,p.Z)({},Uwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}qwn.isMDXComponent=!0;const jwn={toc:[]},Ywn="wrapper";function Qwn(t){let{components:n,...e}=t;return(0,s.kt)(Ywn,(0,p.Z)({},jwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Qwn.isMDXComponent=!0;const Hwn={toc:[]},$wn="wrapper";function Kwn(t){let{components:n,...e}=t;return(0,s.kt)($wn,(0,p.Z)({},Hwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}Kwn.isMDXComponent=!0;const Jwn={toc:[]},tTn="wrapper";function nTn(t){let{components:n,...e}=t;return(0,s.kt)(tTn,(0,p.Z)({},Jwn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}nTn.isMDXComponent=!0;const eTn={toc:[]},oTn="wrapper";function pTn(t){let{components:n,...e}=t;return(0,s.kt)(oTn,(0,p.Z)({},eTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}pTn.isMDXComponent=!0;const rTn={toc:[]},sTn="wrapper";function cTn(t){let{components:n,...e}=t;return(0,s.kt)(sTn,(0,p.Z)({},rTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}cTn.isMDXComponent=!0;const iTn={toc:[]},aTn="wrapper";function lTn(t){let{components:n,...e}=t;return(0,s.kt)(aTn,(0,p.Z)({},iTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}lTn.isMDXComponent=!0;const uTn={toc:[]},mTn="wrapper";function dTn(t){let{components:n,...e}=t;return(0,s.kt)(mTn,(0,p.Z)({},uTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}dTn.isMDXComponent=!0;const hTn={toc:[]},kTn="wrapper";function fTn(t){let{components:n,...e}=t;return(0,s.kt)(kTn,(0,p.Z)({},hTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}fTn.isMDXComponent=!0;const yTn={toc:[]},MTn="wrapper";function DTn(t){let{components:n,...e}=t;return(0,s.kt)(MTn,(0,p.Z)({},yTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}DTn.isMDXComponent=!0;const XTn={toc:[]},_Tn="wrapper";function wTn(t){let{components:n,...e}=t;return(0,s.kt)(_Tn,(0,p.Z)({},XTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}wTn.isMDXComponent=!0;const TTn={toc:[]},CTn="wrapper";function gTn(t){let{components:n,...e}=t;return(0,s.kt)(CTn,(0,p.Z)({},TTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}gTn.isMDXComponent=!0;const xTn={toc:[]},vTn="wrapper";function LTn(t){let{components:n,...e}=t;return(0,s.kt)(vTn,(0,p.Z)({},xTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}LTn.isMDXComponent=!0;const ZTn={toc:[]},bTn="wrapper";function NTn(t){let{components:n,...e}=t;return(0,s.kt)(bTn,(0,p.Z)({},ZTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}NTn.isMDXComponent=!0;const ATn={toc:[]},zTn="wrapper";function WTn(t){let{components:n,...e}=t;return(0,s.kt)(zTn,(0,p.Z)({},ATn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}WTn.isMDXComponent=!0;const ITn={toc:[]},RTn="wrapper";function PTn(t){let{components:n,...e}=t;return(0,s.kt)(RTn,(0,p.Z)({},ITn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}PTn.isMDXComponent=!0;const STn={toc:[]},ETn="wrapper";function GTn(t){let{components:n,...e}=t;return(0,s.kt)(ETn,(0,p.Z)({},STn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}GTn.isMDXComponent=!0;const OTn={toc:[]},FTn="wrapper";function BTn(t){let{components:n,...e}=t;return(0,s.kt)(FTn,(0,p.Z)({},OTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}BTn.isMDXComponent=!0;const UTn={toc:[]},VTn="wrapper";function qTn(t){let{components:n,...e}=t;return(0,s.kt)(VTn,(0,p.Z)({},UTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}qTn.isMDXComponent=!0;const jTn={toc:[]},YTn="wrapper";function QTn(t){let{components:n,...e}=t;return(0,s.kt)(YTn,(0,p.Z)({},jTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}QTn.isMDXComponent=!0;const HTn={toc:[]},$Tn="wrapper";function KTn(t){let{components:n,...e}=t;return(0,s.kt)($Tn,(0,p.Z)({},HTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}KTn.isMDXComponent=!0;const JTn={toc:[]},tCn="wrapper";function nCn(t){let{components:n,...e}=t;return(0,s.kt)(tCn,(0,p.Z)({},JTn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}nCn.isMDXComponent=!0;const eCn={toc:[]},oCn="wrapper";function pCn(t){let{components:n,...e}=t;return(0,s.kt)(oCn,(0,p.Z)({},eCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}pCn.isMDXComponent=!0;const rCn={toc:[]},sCn="wrapper";function cCn(t){let{components:n,...e}=t;return(0,s.kt)(sCn,(0,p.Z)({},rCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}cCn.isMDXComponent=!0;const iCn={toc:[]},aCn="wrapper";function lCn(t){let{components:n,...e}=t;return(0,s.kt)(aCn,(0,p.Z)({},iCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}lCn.isMDXComponent=!0;const uCn={toc:[]},mCn="wrapper";function dCn(t){let{components:n,...e}=t;return(0,s.kt)(mCn,(0,p.Z)({},uCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}dCn.isMDXComponent=!0;const hCn={toc:[]},kCn="wrapper";function fCn(t){let{components:n,...e}=t;return(0,s.kt)(kCn,(0,p.Z)({},hCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}fCn.isMDXComponent=!0;const yCn={toc:[]},MCn="wrapper";function DCn(t){let{components:n,...e}=t;return(0,s.kt)(MCn,(0,p.Z)({},yCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}DCn.isMDXComponent=!0;const XCn={toc:[]},_Cn="wrapper";function wCn(t){let{components:n,...e}=t;return(0,s.kt)(_Cn,(0,p.Z)({},XCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wCn.isMDXComponent=!0;const TCn={toc:[]},CCn="wrapper";function gCn(t){let{components:n,...e}=t;return(0,s.kt)(CCn,(0,p.Z)({},TCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}gCn.isMDXComponent=!0;const xCn={toc:[]},vCn="wrapper";function LCn(t){let{components:n,...e}=t;return(0,s.kt)(vCn,(0,p.Z)({},xCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}LCn.isMDXComponent=!0;const ZCn={toc:[]},bCn="wrapper";function NCn(t){let{components:n,...e}=t;return(0,s.kt)(bCn,(0,p.Z)({},ZCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}NCn.isMDXComponent=!0;const ACn={toc:[]},zCn="wrapper";function WCn(t){let{components:n,...e}=t;return(0,s.kt)(zCn,(0,p.Z)({},ACn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}WCn.isMDXComponent=!0;const ICn={toc:[]},RCn="wrapper";function PCn(t){let{components:n,...e}=t;return(0,s.kt)(RCn,(0,p.Z)({},ICn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}PCn.isMDXComponent=!0;const SCn={toc:[]},ECn="wrapper";function GCn(t){let{components:n,...e}=t;return(0,s.kt)(ECn,(0,p.Z)({},SCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}GCn.isMDXComponent=!0;const OCn={toc:[]},FCn="wrapper";function BCn(t){let{components:n,...e}=t;return(0,s.kt)(FCn,(0,p.Z)({},OCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}BCn.isMDXComponent=!0;const UCn={toc:[]},VCn="wrapper";function qCn(t){let{components:n,...e}=t;return(0,s.kt)(VCn,(0,p.Z)({},UCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}qCn.isMDXComponent=!0;const jCn={toc:[]},YCn="wrapper";function QCn(t){let{components:n,...e}=t;return(0,s.kt)(YCn,(0,p.Z)({},jCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}QCn.isMDXComponent=!0;const HCn={toc:[]},$Cn="wrapper";function KCn(t){let{components:n,...e}=t;return(0,s.kt)($Cn,(0,p.Z)({},HCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}KCn.isMDXComponent=!0;const JCn={toc:[]},tgn="wrapper";function ngn(t){let{components:n,...e}=t;return(0,s.kt)(tgn,(0,p.Z)({},JCn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}ngn.isMDXComponent=!0;const egn={toc:[]},ogn="wrapper";function pgn(t){let{components:n,...e}=t;return(0,s.kt)(ogn,(0,p.Z)({},egn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}pgn.isMDXComponent=!0;const rgn={toc:[]},sgn="wrapper";function cgn(t){let{components:n,...e}=t;return(0,s.kt)(sgn,(0,p.Z)({},rgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}cgn.isMDXComponent=!0;const ign={toc:[]},agn="wrapper";function lgn(t){let{components:n,...e}=t;return(0,s.kt)(agn,(0,p.Z)({},ign,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}lgn.isMDXComponent=!0;const ugn={toc:[]},mgn="wrapper";function dgn(t){let{components:n,...e}=t;return(0,s.kt)(mgn,(0,p.Z)({},ugn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}dgn.isMDXComponent=!0;const hgn={toc:[]},kgn="wrapper";function fgn(t){let{components:n,...e}=t;return(0,s.kt)(kgn,(0,p.Z)({},hgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}fgn.isMDXComponent=!0;const ygn={toc:[]},Mgn="wrapper";function Dgn(t){let{components:n,...e}=t;return(0,s.kt)(Mgn,(0,p.Z)({},ygn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Dgn.isMDXComponent=!0;const Xgn={toc:[]},_gn="wrapper";function wgn(t){let{components:n,...e}=t;return(0,s.kt)(_gn,(0,p.Z)({},Xgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}wgn.isMDXComponent=!0;const Tgn={toc:[]},Cgn="wrapper";function ggn(t){let{components:n,...e}=t;return(0,s.kt)(Cgn,(0,p.Z)({},Tgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}ggn.isMDXComponent=!0;const xgn={toc:[]},vgn="wrapper";function Lgn(t){let{components:n,...e}=t;return(0,s.kt)(vgn,(0,p.Z)({},xgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}Lgn.isMDXComponent=!0;const Zgn={toc:[]},bgn="wrapper";function Ngn(t){let{components:n,...e}=t;return(0,s.kt)(bgn,(0,p.Z)({},Zgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Ngn.isMDXComponent=!0;const Agn={toc:[]},zgn="wrapper";function Wgn(t){let{components:n,...e}=t;return(0,s.kt)(zgn,(0,p.Z)({},Agn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Wgn.isMDXComponent=!0;const Ign={toc:[]},Rgn="wrapper";function Pgn(t){let{components:n,...e}=t;return(0,s.kt)(Rgn,(0,p.Z)({},Ign,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Pgn.isMDXComponent=!0;const Sgn={toc:[]},Egn="wrapper";function Ggn(t){let{components:n,...e}=t;return(0,s.kt)(Egn,(0,p.Z)({},Sgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Ggn.isMDXComponent=!0;const Ogn={toc:[]},Fgn="wrapper";function Bgn(t){let{components:n,...e}=t;return(0,s.kt)(Fgn,(0,p.Z)({},Ogn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Bgn.isMDXComponent=!0;const Ugn={toc:[]},Vgn="wrapper";function qgn(t){let{components:n,...e}=t;return(0,s.kt)(Vgn,(0,p.Z)({},Ugn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}qgn.isMDXComponent=!0;const jgn={toc:[]},Ygn="wrapper";function Qgn(t){let{components:n,...e}=t;return(0,s.kt)(Ygn,(0,p.Z)({},jgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Qgn.isMDXComponent=!0;const Hgn={toc:[]},$gn="wrapper";function Kgn(t){let{components:n,...e}=t;return(0,s.kt)($gn,(0,p.Z)({},Hgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Kgn.isMDXComponent=!0;const Jgn={toc:[]},txn="wrapper";function nxn(t){let{components:n,...e}=t;return(0,s.kt)(txn,(0,p.Z)({},Jgn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}nxn.isMDXComponent=!0;const exn={toc:[]},oxn="wrapper";function pxn(t){let{components:n,...e}=t;return(0,s.kt)(oxn,(0,p.Z)({},exn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}pxn.isMDXComponent=!0;const rxn={toc:[]},sxn="wrapper";function cxn(t){let{components:n,...e}=t;return(0,s.kt)(sxn,(0,p.Z)({},rxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cxn.isMDXComponent=!0;const ixn={toc:[]},axn="wrapper";function lxn(t){let{components:n,...e}=t;return(0,s.kt)(axn,(0,p.Z)({},ixn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lxn.isMDXComponent=!0;const uxn={toc:[]},mxn="wrapper";function dxn(t){let{components:n,...e}=t;return(0,s.kt)(mxn,(0,p.Z)({},uxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}dxn.isMDXComponent=!0;const hxn={toc:[]},kxn="wrapper";function fxn(t){let{components:n,...e}=t;return(0,s.kt)(kxn,(0,p.Z)({},hxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}fxn.isMDXComponent=!0;const yxn={toc:[]},Mxn="wrapper";function Dxn(t){let{components:n,...e}=t;return(0,s.kt)(Mxn,(0,p.Z)({},yxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Dxn.isMDXComponent=!0;const Xxn={toc:[]},_xn="wrapper";function wxn(t){let{components:n,...e}=t;return(0,s.kt)(_xn,(0,p.Z)({},Xxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wxn.isMDXComponent=!0;const Txn={toc:[]},Cxn="wrapper";function gxn(t){let{components:n,...e}=t;return(0,s.kt)(Cxn,(0,p.Z)({},Txn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}gxn.isMDXComponent=!0;const xxn={toc:[]},vxn="wrapper";function Lxn(t){let{components:n,...e}=t;return(0,s.kt)(vxn,(0,p.Z)({},xxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Lxn.isMDXComponent=!0;const Zxn={toc:[]},bxn="wrapper";function Nxn(t){let{components:n,...e}=t;return(0,s.kt)(bxn,(0,p.Z)({},Zxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Nxn.isMDXComponent=!0;const Axn={toc:[]},zxn="wrapper";function Wxn(t){let{components:n,...e}=t;return(0,s.kt)(zxn,(0,p.Z)({},Axn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Wxn.isMDXComponent=!0;const Ixn={toc:[]},Rxn="wrapper";function Pxn(t){let{components:n,...e}=t;return(0,s.kt)(Rxn,(0,p.Z)({},Ixn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Pxn.isMDXComponent=!0;const Sxn={toc:[]},Exn="wrapper";function Gxn(t){let{components:n,...e}=t;return(0,s.kt)(Exn,(0,p.Z)({},Sxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Gxn.isMDXComponent=!0;const Oxn={toc:[]},Fxn="wrapper";function Bxn(t){let{components:n,...e}=t;return(0,s.kt)(Fxn,(0,p.Z)({},Oxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Bxn.isMDXComponent=!0;const Uxn={toc:[]},Vxn="wrapper";function qxn(t){let{components:n,...e}=t;return(0,s.kt)(Vxn,(0,p.Z)({},Uxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}qxn.isMDXComponent=!0;const jxn={toc:[]},Yxn="wrapper";function Qxn(t){let{components:n,...e}=t;return(0,s.kt)(Yxn,(0,p.Z)({},jxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Qxn.isMDXComponent=!0;const Hxn={toc:[]},$xn="wrapper";function Kxn(t){let{components:n,...e}=t;return(0,s.kt)($xn,(0,p.Z)({},Hxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Kxn.isMDXComponent=!0;const Jxn={toc:[]},tvn="wrapper";function nvn(t){let{components:n,...e}=t;return(0,s.kt)(tvn,(0,p.Z)({},Jxn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}nvn.isMDXComponent=!0;const evn={toc:[]},ovn="wrapper";function pvn(t){let{components:n,...e}=t;return(0,s.kt)(ovn,(0,p.Z)({},evn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pvn.isMDXComponent=!0;const rvn={toc:[]},svn="wrapper";function cvn(t){let{components:n,...e}=t;return(0,s.kt)(svn,(0,p.Z)({},rvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cvn.isMDXComponent=!0;const ivn={toc:[]},avn="wrapper";function lvn(t){let{components:n,...e}=t;return(0,s.kt)(avn,(0,p.Z)({},ivn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}lvn.isMDXComponent=!0;const uvn={toc:[]},mvn="wrapper";function dvn(t){let{components:n,...e}=t;return(0,s.kt)(mvn,(0,p.Z)({},uvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}dvn.isMDXComponent=!0;const hvn={toc:[]},kvn="wrapper";function fvn(t){let{components:n,...e}=t;return(0,s.kt)(kvn,(0,p.Z)({},hvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}fvn.isMDXComponent=!0;const yvn={toc:[]},Mvn="wrapper";function Dvn(t){let{components:n,...e}=t;return(0,s.kt)(Mvn,(0,p.Z)({},yvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Dvn.isMDXComponent=!0;const Xvn={toc:[]},_vn="wrapper";function wvn(t){let{components:n,...e}=t;return(0,s.kt)(_vn,(0,p.Z)({},Xvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}wvn.isMDXComponent=!0;const Tvn={toc:[]},Cvn="wrapper";function gvn(t){let{components:n,...e}=t;return(0,s.kt)(Cvn,(0,p.Z)({},Tvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}gvn.isMDXComponent=!0;const xvn={toc:[]},vvn="wrapper";function Lvn(t){let{components:n,...e}=t;return(0,s.kt)(vvn,(0,p.Z)({},xvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Lvn.isMDXComponent=!0;const Zvn={toc:[]},bvn="wrapper";function Nvn(t){let{components:n,...e}=t;return(0,s.kt)(bvn,(0,p.Z)({},Zvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Nvn.isMDXComponent=!0;const Avn={toc:[]},zvn="wrapper";function Wvn(t){let{components:n,...e}=t;return(0,s.kt)(zvn,(0,p.Z)({},Avn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Wvn.isMDXComponent=!0;const Ivn={toc:[]},Rvn="wrapper";function Pvn(t){let{components:n,...e}=t;return(0,s.kt)(Rvn,(0,p.Z)({},Ivn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Pvn.isMDXComponent=!0;const Svn={toc:[]},Evn="wrapper";function Gvn(t){let{components:n,...e}=t;return(0,s.kt)(Evn,(0,p.Z)({},Svn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Gvn.isMDXComponent=!0;const Ovn={toc:[]},Fvn="wrapper";function Bvn(t){let{components:n,...e}=t;return(0,s.kt)(Fvn,(0,p.Z)({},Ovn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Bvn.isMDXComponent=!0;const Uvn={toc:[]},Vvn="wrapper";function qvn(t){let{components:n,...e}=t;return(0,s.kt)(Vvn,(0,p.Z)({},Uvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}qvn.isMDXComponent=!0;const jvn={toc:[]},Yvn="wrapper";function Qvn(t){let{components:n,...e}=t;return(0,s.kt)(Yvn,(0,p.Z)({},jvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Qvn.isMDXComponent=!0;const Hvn={toc:[]},$vn="wrapper";function Kvn(t){let{components:n,...e}=t;return(0,s.kt)($vn,(0,p.Z)({},Hvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Kvn.isMDXComponent=!0;const Jvn={toc:[]},tLn="wrapper";function nLn(t){let{components:n,...e}=t;return(0,s.kt)(tLn,(0,p.Z)({},Jvn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}nLn.isMDXComponent=!0;const eLn={toc:[]},oLn="wrapper";function pLn(t){let{components:n,...e}=t;return(0,s.kt)(oLn,(0,p.Z)({},eLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}pLn.isMDXComponent=!0;const rLn={toc:[]},sLn="wrapper";function cLn(t){let{components:n,...e}=t;return(0,s.kt)(sLn,(0,p.Z)({},rLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}cLn.isMDXComponent=!0;const iLn={toc:[]},aLn="wrapper";function lLn(t){let{components:n,...e}=t;return(0,s.kt)(aLn,(0,p.Z)({},iLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}lLn.isMDXComponent=!0;const uLn={toc:[]},mLn="wrapper";function dLn(t){let{components:n,...e}=t;return(0,s.kt)(mLn,(0,p.Z)({},uLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}dLn.isMDXComponent=!0;const hLn={toc:[]},kLn="wrapper";function fLn(t){let{components:n,...e}=t;return(0,s.kt)(kLn,(0,p.Z)({},hLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}fLn.isMDXComponent=!0;const yLn={toc:[]},MLn="wrapper";function DLn(t){let{components:n,...e}=t;return(0,s.kt)(MLn,(0,p.Z)({},yLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}DLn.isMDXComponent=!0;const XLn={toc:[]},_Ln="wrapper";function wLn(t){let{components:n,...e}=t;return(0,s.kt)(_Ln,(0,p.Z)({},XLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}wLn.isMDXComponent=!0;const TLn={toc:[]},CLn="wrapper";function gLn(t){let{components:n,...e}=t;return(0,s.kt)(CLn,(0,p.Z)({},TLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}gLn.isMDXComponent=!0;const xLn={toc:[]},vLn="wrapper";function LLn(t){let{components:n,...e}=t;return(0,s.kt)(vLn,(0,p.Z)({},xLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}LLn.isMDXComponent=!0;const ZLn={toc:[]},bLn="wrapper";function NLn(t){let{components:n,...e}=t;return(0,s.kt)(bLn,(0,p.Z)({},ZLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}NLn.isMDXComponent=!0;const ALn={toc:[]},zLn="wrapper";function WLn(t){let{components:n,...e}=t;return(0,s.kt)(zLn,(0,p.Z)({},ALn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}WLn.isMDXComponent=!0;const ILn={toc:[]},RLn="wrapper";function PLn(t){let{components:n,...e}=t;return(0,s.kt)(RLn,(0,p.Z)({},ILn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}PLn.isMDXComponent=!0;const SLn={toc:[]},ELn="wrapper";function GLn(t){let{components:n,...e}=t;return(0,s.kt)(ELn,(0,p.Z)({},SLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}GLn.isMDXComponent=!0;const OLn={toc:[]},FLn="wrapper";function BLn(t){let{components:n,...e}=t;return(0,s.kt)(FLn,(0,p.Z)({},OLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}BLn.isMDXComponent=!0;const ULn={toc:[]},VLn="wrapper";function qLn(t){let{components:n,...e}=t;return(0,s.kt)(VLn,(0,p.Z)({},ULn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qLn.isMDXComponent=!0;const jLn={toc:[]},YLn="wrapper";function QLn(t){let{components:n,...e}=t;return(0,s.kt)(YLn,(0,p.Z)({},jLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}QLn.isMDXComponent=!0;const HLn={toc:[]},$Ln="wrapper";function KLn(t){let{components:n,...e}=t;return(0,s.kt)($Ln,(0,p.Z)({},HLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}KLn.isMDXComponent=!0;const JLn={toc:[]},tZn="wrapper";function nZn(t){let{components:n,...e}=t;return(0,s.kt)(tZn,(0,p.Z)({},JLn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}nZn.isMDXComponent=!0;const eZn={toc:[]},oZn="wrapper";function pZn(t){let{components:n,...e}=t;return(0,s.kt)(oZn,(0,p.Z)({},eZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}pZn.isMDXComponent=!0;const rZn={toc:[]},sZn="wrapper";function cZn(t){let{components:n,...e}=t;return(0,s.kt)(sZn,(0,p.Z)({},rZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}cZn.isMDXComponent=!0;const iZn={toc:[]},aZn="wrapper";function lZn(t){let{components:n,...e}=t;return(0,s.kt)(aZn,(0,p.Z)({},iZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}lZn.isMDXComponent=!0;const uZn={toc:[]},mZn="wrapper";function dZn(t){let{components:n,...e}=t;return(0,s.kt)(mZn,(0,p.Z)({},uZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}dZn.isMDXComponent=!0;const hZn={toc:[]},kZn="wrapper";function fZn(t){let{components:n,...e}=t;return(0,s.kt)(kZn,(0,p.Z)({},hZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}fZn.isMDXComponent=!0;const yZn={toc:[]},MZn="wrapper";function DZn(t){let{components:n,...e}=t;return(0,s.kt)(MZn,(0,p.Z)({},yZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}DZn.isMDXComponent=!0;const XZn={toc:[]},_Zn="wrapper";function wZn(t){let{components:n,...e}=t;return(0,s.kt)(_Zn,(0,p.Z)({},XZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}wZn.isMDXComponent=!0;const TZn={toc:[]},CZn="wrapper";function gZn(t){let{components:n,...e}=t;return(0,s.kt)(CZn,(0,p.Z)({},TZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}gZn.isMDXComponent=!0;const xZn={toc:[]},vZn="wrapper";function LZn(t){let{components:n,...e}=t;return(0,s.kt)(vZn,(0,p.Z)({},xZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}LZn.isMDXComponent=!0;const ZZn={toc:[]},bZn="wrapper";function NZn(t){let{components:n,...e}=t;return(0,s.kt)(bZn,(0,p.Z)({},ZZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}NZn.isMDXComponent=!0;const AZn={toc:[]},zZn="wrapper";function WZn(t){let{components:n,...e}=t;return(0,s.kt)(zZn,(0,p.Z)({},AZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}WZn.isMDXComponent=!0;const IZn={toc:[]},RZn="wrapper";function PZn(t){let{components:n,...e}=t;return(0,s.kt)(RZn,(0,p.Z)({},IZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}PZn.isMDXComponent=!0;const SZn={toc:[]},EZn="wrapper";function GZn(t){let{components:n,...e}=t;return(0,s.kt)(EZn,(0,p.Z)({},SZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}GZn.isMDXComponent=!0;const OZn={toc:[]},FZn="wrapper";function BZn(t){let{components:n,...e}=t;return(0,s.kt)(FZn,(0,p.Z)({},OZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}BZn.isMDXComponent=!0;const UZn={toc:[]},VZn="wrapper";function qZn(t){let{components:n,...e}=t;return(0,s.kt)(VZn,(0,p.Z)({},UZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}qZn.isMDXComponent=!0;const jZn={toc:[]},YZn="wrapper";function QZn(t){let{components:n,...e}=t;return(0,s.kt)(YZn,(0,p.Z)({},jZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}QZn.isMDXComponent=!0;const HZn={toc:[]},$Zn="wrapper";function KZn(t){let{components:n,...e}=t;return(0,s.kt)($Zn,(0,p.Z)({},HZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}KZn.isMDXComponent=!0;const JZn={toc:[]},tbn="wrapper";function nbn(t){let{components:n,...e}=t;return(0,s.kt)(tbn,(0,p.Z)({},JZn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}nbn.isMDXComponent=!0;const ebn={toc:[]},obn="wrapper";function pbn(t){let{components:n,...e}=t;return(0,s.kt)(obn,(0,p.Z)({},ebn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}pbn.isMDXComponent=!0;const rbn={toc:[]},sbn="wrapper";function cbn(t){let{components:n,...e}=t;return(0,s.kt)(sbn,(0,p.Z)({},rbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}cbn.isMDXComponent=!0;const ibn={toc:[]},abn="wrapper";function lbn(t){let{components:n,...e}=t;return(0,s.kt)(abn,(0,p.Z)({},ibn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}lbn.isMDXComponent=!0;const ubn={toc:[]},mbn="wrapper";function dbn(t){let{components:n,...e}=t;return(0,s.kt)(mbn,(0,p.Z)({},ubn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}dbn.isMDXComponent=!0;const hbn={toc:[]},kbn="wrapper";function fbn(t){let{components:n,...e}=t;return(0,s.kt)(kbn,(0,p.Z)({},hbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}fbn.isMDXComponent=!0;const ybn={toc:[]},Mbn="wrapper";function Dbn(t){let{components:n,...e}=t;return(0,s.kt)(Mbn,(0,p.Z)({},ybn,e,{components:n,mdxType:"MDXLayout"}))}Dbn.isMDXComponent=!0;const Xbn={toc:[]},_bn="wrapper";function wbn(t){let{components:n,...e}=t;return(0,s.kt)(_bn,(0,p.Z)({},Xbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}wbn.isMDXComponent=!0;const Tbn={toc:[]},Cbn="wrapper";function gbn(t){let{components:n,...e}=t;return(0,s.kt)(Cbn,(0,p.Z)({},Tbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}gbn.isMDXComponent=!0;const xbn={toc:[]},vbn="wrapper";function Lbn(t){let{components:n,...e}=t;return(0,s.kt)(vbn,(0,p.Z)({},xbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Lbn.isMDXComponent=!0;const Zbn={toc:[]},bbn="wrapper";function Nbn(t){let{components:n,...e}=t;return(0,s.kt)(bbn,(0,p.Z)({},Zbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Nbn.isMDXComponent=!0;const Abn={toc:[]},zbn="wrapper";function Wbn(t){let{components:n,...e}=t;return(0,s.kt)(zbn,(0,p.Z)({},Abn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Wbn.isMDXComponent=!0;const Ibn={toc:[]},Rbn="wrapper";function Pbn(t){let{components:n,...e}=t;return(0,s.kt)(Rbn,(0,p.Z)({},Ibn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Pbn.isMDXComponent=!0;const Sbn={toc:[]},Ebn="wrapper";function Gbn(t){let{components:n,...e}=t;return(0,s.kt)(Ebn,(0,p.Z)({},Sbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Gbn.isMDXComponent=!0;const Obn={toc:[]},Fbn="wrapper";function Bbn(t){let{components:n,...e}=t;return(0,s.kt)(Fbn,(0,p.Z)({},Obn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Bbn.isMDXComponent=!0;const Ubn={toc:[]},Vbn="wrapper";function qbn(t){let{components:n,...e}=t;return(0,s.kt)(Vbn,(0,p.Z)({},Ubn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}qbn.isMDXComponent=!0;const jbn={toc:[]},Ybn="wrapper";function Qbn(t){let{components:n,...e}=t;return(0,s.kt)(Ybn,(0,p.Z)({},jbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Qbn.isMDXComponent=!0;const Hbn={toc:[]},$bn="wrapper";function Kbn(t){let{components:n,...e}=t;return(0,s.kt)($bn,(0,p.Z)({},Hbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Kbn.isMDXComponent=!0;const Jbn={toc:[]},tNn="wrapper";function nNn(t){let{components:n,...e}=t;return(0,s.kt)(tNn,(0,p.Z)({},Jbn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}nNn.isMDXComponent=!0;const eNn={toc:[]},oNn="wrapper";function pNn(t){let{components:n,...e}=t;return(0,s.kt)(oNn,(0,p.Z)({},eNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}pNn.isMDXComponent=!0;const rNn={toc:[]},sNn="wrapper";function cNn(t){let{components:n,...e}=t;return(0,s.kt)(sNn,(0,p.Z)({},rNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}cNn.isMDXComponent=!0;const iNn={toc:[]},aNn="wrapper";function lNn(t){let{components:n,...e}=t;return(0,s.kt)(aNn,(0,p.Z)({},iNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}lNn.isMDXComponent=!0;const uNn={toc:[]},mNn="wrapper";function dNn(t){let{components:n,...e}=t;return(0,s.kt)(mNn,(0,p.Z)({},uNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}dNn.isMDXComponent=!0;const hNn={toc:[]},kNn="wrapper";function fNn(t){let{components:n,...e}=t;return(0,s.kt)(kNn,(0,p.Z)({},hNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}fNn.isMDXComponent=!0;const yNn={toc:[]},MNn="wrapper";function DNn(t){let{components:n,...e}=t;return(0,s.kt)(MNn,(0,p.Z)({},yNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}DNn.isMDXComponent=!0;const XNn={toc:[]},_Nn="wrapper";function wNn(t){let{components:n,...e}=t;return(0,s.kt)(_Nn,(0,p.Z)({},XNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}wNn.isMDXComponent=!0;const TNn={toc:[]},CNn="wrapper";function gNn(t){let{components:n,...e}=t;return(0,s.kt)(CNn,(0,p.Z)({},TNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}gNn.isMDXComponent=!0;const xNn={toc:[]},vNn="wrapper";function LNn(t){let{components:n,...e}=t;return(0,s.kt)(vNn,(0,p.Z)({},xNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}LNn.isMDXComponent=!0;const ZNn={toc:[]},bNn="wrapper";function NNn(t){let{components:n,...e}=t;return(0,s.kt)(bNn,(0,p.Z)({},ZNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}NNn.isMDXComponent=!0;const ANn={toc:[]},zNn="wrapper";function WNn(t){let{components:n,...e}=t;return(0,s.kt)(zNn,(0,p.Z)({},ANn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}WNn.isMDXComponent=!0;const INn={toc:[]},RNn="wrapper";function PNn(t){let{components:n,...e}=t;return(0,s.kt)(RNn,(0,p.Z)({},INn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}PNn.isMDXComponent=!0;const SNn={toc:[]},ENn="wrapper";function GNn(t){let{components:n,...e}=t;return(0,s.kt)(ENn,(0,p.Z)({},SNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}GNn.isMDXComponent=!0;const ONn={toc:[]},FNn="wrapper";function BNn(t){let{components:n,...e}=t;return(0,s.kt)(FNn,(0,p.Z)({},ONn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}BNn.isMDXComponent=!0;const UNn={toc:[]},VNn="wrapper";function qNn(t){let{components:n,...e}=t;return(0,s.kt)(VNn,(0,p.Z)({},UNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}qNn.isMDXComponent=!0;const jNn={toc:[]},YNn="wrapper";function QNn(t){let{components:n,...e}=t;return(0,s.kt)(YNn,(0,p.Z)({},jNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}QNn.isMDXComponent=!0;const HNn={toc:[]},$Nn="wrapper";function KNn(t){let{components:n,...e}=t;return(0,s.kt)($Nn,(0,p.Z)({},HNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}KNn.isMDXComponent=!0;const JNn={toc:[]},tAn="wrapper";function nAn(t){let{components:n,...e}=t;return(0,s.kt)(tAn,(0,p.Z)({},JNn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}nAn.isMDXComponent=!0;const eAn={toc:[]},oAn="wrapper";function pAn(t){let{components:n,...e}=t;return(0,s.kt)(oAn,(0,p.Z)({},eAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pAn.isMDXComponent=!0;const rAn={toc:[]},sAn="wrapper";function cAn(t){let{components:n,...e}=t;return(0,s.kt)(sAn,(0,p.Z)({},rAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}cAn.isMDXComponent=!0;const iAn={toc:[]},aAn="wrapper";function lAn(t){let{components:n,...e}=t;return(0,s.kt)(aAn,(0,p.Z)({},iAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lAn.isMDXComponent=!0;const uAn={toc:[]},mAn="wrapper";function dAn(t){let{components:n,...e}=t;return(0,s.kt)(mAn,(0,p.Z)({},uAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dAn.isMDXComponent=!0;const hAn={toc:[]},kAn="wrapper";function fAn(t){let{components:n,...e}=t;return(0,s.kt)(kAn,(0,p.Z)({},hAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}fAn.isMDXComponent=!0;const yAn={toc:[]},MAn="wrapper";function DAn(t){let{components:n,...e}=t;return(0,s.kt)(MAn,(0,p.Z)({},yAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}DAn.isMDXComponent=!0;const XAn={toc:[]},_An="wrapper";function wAn(t){let{components:n,...e}=t;return(0,s.kt)(_An,(0,p.Z)({},XAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}wAn.isMDXComponent=!0;const TAn={toc:[]},CAn="wrapper";function gAn(t){let{components:n,...e}=t;return(0,s.kt)(CAn,(0,p.Z)({},TAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}gAn.isMDXComponent=!0;const xAn={toc:[]},vAn="wrapper";function LAn(t){let{components:n,...e}=t;return(0,s.kt)(vAn,(0,p.Z)({},xAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}LAn.isMDXComponent=!0;const ZAn={toc:[]},bAn="wrapper";function NAn(t){let{components:n,...e}=t;return(0,s.kt)(bAn,(0,p.Z)({},ZAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}NAn.isMDXComponent=!0;const AAn={toc:[]},zAn="wrapper";function WAn(t){let{components:n,...e}=t;return(0,s.kt)(zAn,(0,p.Z)({},AAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}WAn.isMDXComponent=!0;const IAn={toc:[]},RAn="wrapper";function PAn(t){let{components:n,...e}=t;return(0,s.kt)(RAn,(0,p.Z)({},IAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}PAn.isMDXComponent=!0;const SAn={toc:[]},EAn="wrapper";function GAn(t){let{components:n,...e}=t;return(0,s.kt)(EAn,(0,p.Z)({},SAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}GAn.isMDXComponent=!0;const OAn={toc:[]},FAn="wrapper";function BAn(t){let{components:n,...e}=t;return(0,s.kt)(FAn,(0,p.Z)({},OAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}BAn.isMDXComponent=!0;const UAn={toc:[]},VAn="wrapper";function qAn(t){let{components:n,...e}=t;return(0,s.kt)(VAn,(0,p.Z)({},UAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qAn.isMDXComponent=!0;const jAn={toc:[]},YAn="wrapper";function QAn(t){let{components:n,...e}=t;return(0,s.kt)(YAn,(0,p.Z)({},jAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}QAn.isMDXComponent=!0;const HAn={toc:[]},$An="wrapper";function KAn(t){let{components:n,...e}=t;return(0,s.kt)($An,(0,p.Z)({},HAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}KAn.isMDXComponent=!0;const JAn={toc:[]},tzn="wrapper";function nzn(t){let{components:n,...e}=t;return(0,s.kt)(tzn,(0,p.Z)({},JAn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}nzn.isMDXComponent=!0;const ezn={toc:[]},ozn="wrapper";function pzn(t){let{components:n,...e}=t;return(0,s.kt)(ozn,(0,p.Z)({},ezn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pzn.isMDXComponent=!0;const rzn={toc:[]},szn="wrapper";function czn(t){let{components:n,...e}=t;return(0,s.kt)(szn,(0,p.Z)({},rzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}czn.isMDXComponent=!0;const izn={toc:[]},azn="wrapper";function lzn(t){let{components:n,...e}=t;return(0,s.kt)(azn,(0,p.Z)({},izn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lzn.isMDXComponent=!0;const uzn={toc:[]},mzn="wrapper";function dzn(t){let{components:n,...e}=t;return(0,s.kt)(mzn,(0,p.Z)({},uzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}dzn.isMDXComponent=!0;const hzn={toc:[]},kzn="wrapper";function fzn(t){let{components:n,...e}=t;return(0,s.kt)(kzn,(0,p.Z)({},hzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}fzn.isMDXComponent=!0;const yzn={toc:[]},Mzn="wrapper";function Dzn(t){let{components:n,...e}=t;return(0,s.kt)(Mzn,(0,p.Z)({},yzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Dzn.isMDXComponent=!0;const Xzn={toc:[]},_zn="wrapper";function wzn(t){let{components:n,...e}=t;return(0,s.kt)(_zn,(0,p.Z)({},Xzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wzn.isMDXComponent=!0;const Tzn={toc:[]},Czn="wrapper";function gzn(t){let{components:n,...e}=t;return(0,s.kt)(Czn,(0,p.Z)({},Tzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}gzn.isMDXComponent=!0;const xzn={toc:[]},vzn="wrapper";function Lzn(t){let{components:n,...e}=t;return(0,s.kt)(vzn,(0,p.Z)({},xzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Lzn.isMDXComponent=!0;const Zzn={toc:[]},bzn="wrapper";function Nzn(t){let{components:n,...e}=t;return(0,s.kt)(bzn,(0,p.Z)({},Zzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Nzn.isMDXComponent=!0;const Azn={toc:[]},zzn="wrapper";function Wzn(t){let{components:n,...e}=t;return(0,s.kt)(zzn,(0,p.Z)({},Azn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Wzn.isMDXComponent=!0;const Izn={toc:[]},Rzn="wrapper";function Pzn(t){let{components:n,...e}=t;return(0,s.kt)(Rzn,(0,p.Z)({},Izn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Pzn.isMDXComponent=!0;const Szn={toc:[]},Ezn="wrapper";function Gzn(t){let{components:n,...e}=t;return(0,s.kt)(Ezn,(0,p.Z)({},Szn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Gzn.isMDXComponent=!0;const Ozn={toc:[]},Fzn="wrapper";function Bzn(t){let{components:n,...e}=t;return(0,s.kt)(Fzn,(0,p.Z)({},Ozn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Bzn.isMDXComponent=!0;const Uzn={toc:[]},Vzn="wrapper";function qzn(t){let{components:n,...e}=t;return(0,s.kt)(Vzn,(0,p.Z)({},Uzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}qzn.isMDXComponent=!0;const jzn={toc:[]},Yzn="wrapper";function Qzn(t){let{components:n,...e}=t;return(0,s.kt)(Yzn,(0,p.Z)({},jzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Qzn.isMDXComponent=!0;const Hzn={toc:[]},$zn="wrapper";function Kzn(t){let{components:n,...e}=t;return(0,s.kt)($zn,(0,p.Z)({},Hzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Kzn.isMDXComponent=!0;const Jzn={toc:[]},tWn="wrapper";function nWn(t){let{components:n,...e}=t;return(0,s.kt)(tWn,(0,p.Z)({},Jzn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}nWn.isMDXComponent=!0;const eWn={toc:[]},oWn="wrapper";function pWn(t){let{components:n,...e}=t;return(0,s.kt)(oWn,(0,p.Z)({},eWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}pWn.isMDXComponent=!0;const rWn={toc:[]},sWn="wrapper";function cWn(t){let{components:n,...e}=t;return(0,s.kt)(sWn,(0,p.Z)({},rWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}cWn.isMDXComponent=!0;const iWn={toc:[]},aWn="wrapper";function lWn(t){let{components:n,...e}=t;return(0,s.kt)(aWn,(0,p.Z)({},iWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}lWn.isMDXComponent=!0;const uWn={toc:[]},mWn="wrapper";function dWn(t){let{components:n,...e}=t;return(0,s.kt)(mWn,(0,p.Z)({},uWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}dWn.isMDXComponent=!0;const hWn={toc:[]},kWn="wrapper";function fWn(t){let{components:n,...e}=t;return(0,s.kt)(kWn,(0,p.Z)({},hWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}fWn.isMDXComponent=!0;const yWn={toc:[]},MWn="wrapper";function DWn(t){let{components:n,...e}=t;return(0,s.kt)(MWn,(0,p.Z)({},yWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}DWn.isMDXComponent=!0;const XWn={toc:[]},_Wn="wrapper";function wWn(t){let{components:n,...e}=t;return(0,s.kt)(_Wn,(0,p.Z)({},XWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wWn.isMDXComponent=!0;const TWn={toc:[]},CWn="wrapper";function gWn(t){let{components:n,...e}=t;return(0,s.kt)(CWn,(0,p.Z)({},TWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}gWn.isMDXComponent=!0;const xWn={toc:[]},vWn="wrapper";function LWn(t){let{components:n,...e}=t;return(0,s.kt)(vWn,(0,p.Z)({},xWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}LWn.isMDXComponent=!0;const ZWn={toc:[]},bWn="wrapper";function NWn(t){let{components:n,...e}=t;return(0,s.kt)(bWn,(0,p.Z)({},ZWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}NWn.isMDXComponent=!0;const AWn={toc:[]},zWn="wrapper";function WWn(t){let{components:n,...e}=t;return(0,s.kt)(zWn,(0,p.Z)({},AWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}WWn.isMDXComponent=!0;const IWn={toc:[]},RWn="wrapper";function PWn(t){let{components:n,...e}=t;return(0,s.kt)(RWn,(0,p.Z)({},IWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}PWn.isMDXComponent=!0;const SWn={toc:[]},EWn="wrapper";function GWn(t){let{components:n,...e}=t;return(0,s.kt)(EWn,(0,p.Z)({},SWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}GWn.isMDXComponent=!0;const OWn={toc:[]},FWn="wrapper";function BWn(t){let{components:n,...e}=t;return(0,s.kt)(FWn,(0,p.Z)({},OWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}BWn.isMDXComponent=!0;const UWn={toc:[]},VWn="wrapper";function qWn(t){let{components:n,...e}=t;return(0,s.kt)(VWn,(0,p.Z)({},UWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}qWn.isMDXComponent=!0;const jWn={toc:[]},YWn="wrapper";function QWn(t){let{components:n,...e}=t;return(0,s.kt)(YWn,(0,p.Z)({},jWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}QWn.isMDXComponent=!0;const HWn={toc:[]},$Wn="wrapper";function KWn(t){let{components:n,...e}=t;return(0,s.kt)($Wn,(0,p.Z)({},HWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}KWn.isMDXComponent=!0;const JWn={toc:[]},tIn="wrapper";function nIn(t){let{components:n,...e}=t;return(0,s.kt)(tIn,(0,p.Z)({},JWn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}nIn.isMDXComponent=!0;const eIn={toc:[]},oIn="wrapper";function pIn(t){let{components:n,...e}=t;return(0,s.kt)(oIn,(0,p.Z)({},eIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}pIn.isMDXComponent=!0;const rIn={toc:[]},sIn="wrapper";function cIn(t){let{components:n,...e}=t;return(0,s.kt)(sIn,(0,p.Z)({},rIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}cIn.isMDXComponent=!0;const iIn={toc:[]},aIn="wrapper";function lIn(t){let{components:n,...e}=t;return(0,s.kt)(aIn,(0,p.Z)({},iIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}lIn.isMDXComponent=!0;const uIn={toc:[]},mIn="wrapper";function dIn(t){let{components:n,...e}=t;return(0,s.kt)(mIn,(0,p.Z)({},uIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dIn.isMDXComponent=!0;const hIn={toc:[]},kIn="wrapper";function fIn(t){let{components:n,...e}=t;return(0,s.kt)(kIn,(0,p.Z)({},hIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}fIn.isMDXComponent=!0;const yIn={toc:[]},MIn="wrapper";function DIn(t){let{components:n,...e}=t;return(0,s.kt)(MIn,(0,p.Z)({},yIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}DIn.isMDXComponent=!0;const XIn={toc:[]},_In="wrapper";function wIn(t){let{components:n,...e}=t;return(0,s.kt)(_In,(0,p.Z)({},XIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}wIn.isMDXComponent=!0;const TIn={toc:[]},CIn="wrapper";function gIn(t){let{components:n,...e}=t;return(0,s.kt)(CIn,(0,p.Z)({},TIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}gIn.isMDXComponent=!0;const xIn={toc:[]},vIn="wrapper";function LIn(t){let{components:n,...e}=t;return(0,s.kt)(vIn,(0,p.Z)({},xIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}LIn.isMDXComponent=!0;const ZIn={toc:[]},bIn="wrapper";function NIn(t){let{components:n,...e}=t;return(0,s.kt)(bIn,(0,p.Z)({},ZIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}NIn.isMDXComponent=!0;const AIn={toc:[]},zIn="wrapper";function WIn(t){let{components:n,...e}=t;return(0,s.kt)(zIn,(0,p.Z)({},AIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}WIn.isMDXComponent=!0;const IIn={toc:[]},RIn="wrapper";function PIn(t){let{components:n,...e}=t;return(0,s.kt)(RIn,(0,p.Z)({},IIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}PIn.isMDXComponent=!0;const SIn={toc:[]},EIn="wrapper";function GIn(t){let{components:n,...e}=t;return(0,s.kt)(EIn,(0,p.Z)({},SIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}GIn.isMDXComponent=!0;const OIn={toc:[]},FIn="wrapper";function BIn(t){let{components:n,...e}=t;return(0,s.kt)(FIn,(0,p.Z)({},OIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}BIn.isMDXComponent=!0;const UIn={toc:[]},VIn="wrapper";function qIn(t){let{components:n,...e}=t;return(0,s.kt)(VIn,(0,p.Z)({},UIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}qIn.isMDXComponent=!0;const jIn={toc:[]},YIn="wrapper";function QIn(t){let{components:n,...e}=t;return(0,s.kt)(YIn,(0,p.Z)({},jIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}QIn.isMDXComponent=!0;const HIn={toc:[]},$In="wrapper";function KIn(t){let{components:n,...e}=t;return(0,s.kt)($In,(0,p.Z)({},HIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}KIn.isMDXComponent=!0;const JIn={toc:[]},tRn="wrapper";function nRn(t){let{components:n,...e}=t;return(0,s.kt)(tRn,(0,p.Z)({},JIn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}nRn.isMDXComponent=!0;const eRn={toc:[]},oRn="wrapper";function pRn(t){let{components:n,...e}=t;return(0,s.kt)(oRn,(0,p.Z)({},eRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}pRn.isMDXComponent=!0;const rRn={toc:[]},sRn="wrapper";function cRn(t){let{components:n,...e}=t;return(0,s.kt)(sRn,(0,p.Z)({},rRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cRn.isMDXComponent=!0;const iRn={toc:[]},aRn="wrapper";function lRn(t){let{components:n,...e}=t;return(0,s.kt)(aRn,(0,p.Z)({},iRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lRn.isMDXComponent=!0;const uRn={toc:[]},mRn="wrapper";function dRn(t){let{components:n,...e}=t;return(0,s.kt)(mRn,(0,p.Z)({},uRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}dRn.isMDXComponent=!0;const hRn={toc:[]},kRn="wrapper";function fRn(t){let{components:n,...e}=t;return(0,s.kt)(kRn,(0,p.Z)({},hRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}fRn.isMDXComponent=!0;const yRn={toc:[]},MRn="wrapper";function DRn(t){let{components:n,...e}=t;return(0,s.kt)(MRn,(0,p.Z)({},yRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}DRn.isMDXComponent=!0;const XRn={toc:[]},_Rn="wrapper";function wRn(t){let{components:n,...e}=t;return(0,s.kt)(_Rn,(0,p.Z)({},XRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wRn.isMDXComponent=!0;const TRn={toc:[]},CRn="wrapper";function gRn(t){let{components:n,...e}=t;return(0,s.kt)(CRn,(0,p.Z)({},TRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}gRn.isMDXComponent=!0;const xRn={toc:[]},vRn="wrapper";function LRn(t){let{components:n,...e}=t;return(0,s.kt)(vRn,(0,p.Z)({},xRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}LRn.isMDXComponent=!0;const ZRn={toc:[]},bRn="wrapper";function NRn(t){let{components:n,...e}=t;return(0,s.kt)(bRn,(0,p.Z)({},ZRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}NRn.isMDXComponent=!0;const ARn={toc:[]},zRn="wrapper";function WRn(t){let{components:n,...e}=t;return(0,s.kt)(zRn,(0,p.Z)({},ARn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WRn.isMDXComponent=!0;const IRn={toc:[]},RRn="wrapper";function PRn(t){let{components:n,...e}=t;return(0,s.kt)(RRn,(0,p.Z)({},IRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}PRn.isMDXComponent=!0;const SRn={toc:[]},ERn="wrapper";function GRn(t){let{components:n,...e}=t;return(0,s.kt)(ERn,(0,p.Z)({},SRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}GRn.isMDXComponent=!0;const ORn={toc:[]},FRn="wrapper";function BRn(t){let{components:n,...e}=t;return(0,s.kt)(FRn,(0,p.Z)({},ORn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}BRn.isMDXComponent=!0;const URn={toc:[]},VRn="wrapper";function qRn(t){let{components:n,...e}=t;return(0,s.kt)(VRn,(0,p.Z)({},URn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}qRn.isMDXComponent=!0;const jRn={toc:[]},YRn="wrapper";function QRn(t){let{components:n,...e}=t;return(0,s.kt)(YRn,(0,p.Z)({},jRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}QRn.isMDXComponent=!0;const HRn={toc:[]},$Rn="wrapper";function KRn(t){let{components:n,...e}=t;return(0,s.kt)($Rn,(0,p.Z)({},HRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}KRn.isMDXComponent=!0;const JRn={toc:[]},tPn="wrapper";function nPn(t){let{components:n,...e}=t;return(0,s.kt)(tPn,(0,p.Z)({},JRn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}nPn.isMDXComponent=!0;const ePn={toc:[]},oPn="wrapper";function pPn(t){let{components:n,...e}=t;return(0,s.kt)(oPn,(0,p.Z)({},ePn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}pPn.isMDXComponent=!0;const rPn={toc:[]},sPn="wrapper";function cPn(t){let{components:n,...e}=t;return(0,s.kt)(sPn,(0,p.Z)({},rPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}cPn.isMDXComponent=!0;const iPn={toc:[]},aPn="wrapper";function lPn(t){let{components:n,...e}=t;return(0,s.kt)(aPn,(0,p.Z)({},iPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}lPn.isMDXComponent=!0;const uPn={toc:[]},mPn="wrapper";function dPn(t){let{components:n,...e}=t;return(0,s.kt)(mPn,(0,p.Z)({},uPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}dPn.isMDXComponent=!0;const hPn={toc:[]},kPn="wrapper";function fPn(t){let{components:n,...e}=t;return(0,s.kt)(kPn,(0,p.Z)({},hPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}fPn.isMDXComponent=!0;const yPn={toc:[]},MPn="wrapper";function DPn(t){let{components:n,...e}=t;return(0,s.kt)(MPn,(0,p.Z)({},yPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}DPn.isMDXComponent=!0;const XPn={toc:[]},_Pn="wrapper";function wPn(t){let{components:n,...e}=t;return(0,s.kt)(_Pn,(0,p.Z)({},XPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}wPn.isMDXComponent=!0;const TPn={toc:[]},CPn="wrapper";function gPn(t){let{components:n,...e}=t;return(0,s.kt)(CPn,(0,p.Z)({},TPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}gPn.isMDXComponent=!0;const xPn={toc:[]},vPn="wrapper";function LPn(t){let{components:n,...e}=t;return(0,s.kt)(vPn,(0,p.Z)({},xPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}LPn.isMDXComponent=!0;const ZPn={toc:[]},bPn="wrapper";function NPn(t){let{components:n,...e}=t;return(0,s.kt)(bPn,(0,p.Z)({},ZPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}NPn.isMDXComponent=!0;const APn={toc:[]},zPn="wrapper";function WPn(t){let{components:n,...e}=t;return(0,s.kt)(zPn,(0,p.Z)({},APn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}WPn.isMDXComponent=!0;const IPn={toc:[]},RPn="wrapper";function PPn(t){let{components:n,...e}=t;return(0,s.kt)(RPn,(0,p.Z)({},IPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}PPn.isMDXComponent=!0;const SPn={toc:[]},EPn="wrapper";function GPn(t){let{components:n,...e}=t;return(0,s.kt)(EPn,(0,p.Z)({},SPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}GPn.isMDXComponent=!0;const OPn={toc:[]},FPn="wrapper";function BPn(t){let{components:n,...e}=t;return(0,s.kt)(FPn,(0,p.Z)({},OPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}BPn.isMDXComponent=!0;const UPn={toc:[]},VPn="wrapper";function qPn(t){let{components:n,...e}=t;return(0,s.kt)(VPn,(0,p.Z)({},UPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qPn.isMDXComponent=!0;const jPn={toc:[]},YPn="wrapper";function QPn(t){let{components:n,...e}=t;return(0,s.kt)(YPn,(0,p.Z)({},jPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}QPn.isMDXComponent=!0;const HPn={toc:[]},$Pn="wrapper";function KPn(t){let{components:n,...e}=t;return(0,s.kt)($Pn,(0,p.Z)({},HPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}KPn.isMDXComponent=!0;const JPn={toc:[]},tSn="wrapper";function nSn(t){let{components:n,...e}=t;return(0,s.kt)(tSn,(0,p.Z)({},JPn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}nSn.isMDXComponent=!0;const eSn={toc:[]},oSn="wrapper";function pSn(t){let{components:n,...e}=t;return(0,s.kt)(oSn,(0,p.Z)({},eSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}pSn.isMDXComponent=!0;const rSn={toc:[]},sSn="wrapper";function cSn(t){let{components:n,...e}=t;return(0,s.kt)(sSn,(0,p.Z)({},rSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}cSn.isMDXComponent=!0;const iSn={toc:[]},aSn="wrapper";function lSn(t){let{components:n,...e}=t;return(0,s.kt)(aSn,(0,p.Z)({},iSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}lSn.isMDXComponent=!0;const uSn={toc:[]},mSn="wrapper";function dSn(t){let{components:n,...e}=t;return(0,s.kt)(mSn,(0,p.Z)({},uSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}dSn.isMDXComponent=!0;const hSn={toc:[]},kSn="wrapper";function fSn(t){let{components:n,...e}=t;return(0,s.kt)(kSn,(0,p.Z)({},hSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}fSn.isMDXComponent=!0;const ySn={toc:[]},MSn="wrapper";function DSn(t){let{components:n,...e}=t;return(0,s.kt)(MSn,(0,p.Z)({},ySn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}DSn.isMDXComponent=!0;const XSn={toc:[]},_Sn="wrapper";function wSn(t){let{components:n,...e}=t;return(0,s.kt)(_Sn,(0,p.Z)({},XSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render any polygonal shape defined by a set of\npoints."))}wSn.isMDXComponent=!0;const TSn={toc:[]},CSn="wrapper";function gSn(t){let{components:n,...e}=t;return(0,s.kt)(CSn,(0,p.Z)({},TSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple line\nimport {makeScene2D, Line} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Line\n      points={[\n        [150, 50],\n        [0, -50],\n        [-150, 50],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      radius={40}\n      startArrow\n    />,\n  );\n});\n\n// snippet Polygon\nimport {makeScene2D, Line} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Line\n      points={[\n        [-200, 70],\n        [150, 70],\n        [100, -70],\n        [-100, -70],\n      ]}\n      fill={'lightseagreen'}\n      closed\n    />,\n  );\n});\n\n// snippet Using signals\nimport {makeScene2D, Line} from '@motion-canvas/2d';\nimport {createSignal} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const tip = createSignal(-150);\n  view.add(\n    <Line\n      points={[\n        [-150, 70],\n        [150, 70],\n        // this point is dynamically calculated based on the signal:\n        () => [tip(), -70],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      closed\n    />,\n  );\n\n  yield* tip(150, 1).back(1);\n});\n\n// snippet Tweening points\nimport {makeScene2D, Line} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const line = createRef<Line>();\n  view.add(\n    <Line\n      ref={line}\n      points={[\n        [-150, 70],\n        [150, 70],\n        [0, -70],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      radius={20}\n      closed\n    />,\n  );\n\n  yield* line()\n    .points(\n      [\n        [-150, 0],\n        [0, 100],\n        [150, 0],\n        [150, -70],\n        [-150, -70],\n      ],\n      2,\n    )\n    .back(2);\n});\n")))}gSn.isMDXComponent=!0;const xSn={toc:[]},vSn="wrapper";function LSn(t){let{components:n,...e}=t;return(0,s.kt)(vSn,(0,p.Z)({},xSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing lines and polygons."))}LSn.isMDXComponent=!0;const ZSn={toc:[]},bSn="wrapper";function NSn(t){let{components:n,...e}=t;return(0,s.kt)(bSn,(0,p.Z)({},ZSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}NSn.isMDXComponent=!0;const ASn={toc:[]},zSn="wrapper";function WSn(t){let{components:n,...e}=t;return(0,s.kt)(zSn,(0,p.Z)({},ASn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}WSn.isMDXComponent=!0;const ISn={toc:[]},RSn="wrapper";function PSn(t){let{components:n,...e}=t;return(0,s.kt)(RSn,(0,p.Z)({},ISn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}PSn.isMDXComponent=!0;const SSn={toc:[]},ESn="wrapper";function GSn(t){let{components:n,...e}=t;return(0,s.kt)(ESn,(0,p.Z)({},SSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}GSn.isMDXComponent=!0;const OSn={toc:[]},FSn="wrapper";function BSn(t){let{components:n,...e}=t;return(0,s.kt)(FSn,(0,p.Z)({},OSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}BSn.isMDXComponent=!0;const USn={toc:[]},VSn="wrapper";function qSn(t){let{components:n,...e}=t;return(0,s.kt)(VSn,(0,p.Z)({},USn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}qSn.isMDXComponent=!0;const jSn={toc:[]},YSn="wrapper";function QSn(t){let{components:n,...e}=t;return(0,s.kt)(YSn,(0,p.Z)({},jSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}QSn.isMDXComponent=!0;const HSn={toc:[]},$Sn="wrapper";function KSn(t){let{components:n,...e}=t;return(0,s.kt)($Sn,(0,p.Z)({},HSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}KSn.isMDXComponent=!0;const JSn={toc:[]},tEn="wrapper";function nEn(t){let{components:n,...e}=t;return(0,s.kt)(tEn,(0,p.Z)({},JSn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}nEn.isMDXComponent=!0;const eEn={toc:[]},oEn="wrapper";function pEn(t){let{components:n,...e}=t;return(0,s.kt)(oEn,(0,p.Z)({},eEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}pEn.isMDXComponent=!0;const rEn={toc:[]},sEn="wrapper";function cEn(t){let{components:n,...e}=t;return(0,s.kt)(sEn,(0,p.Z)({},rEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}cEn.isMDXComponent=!0;const iEn={toc:[]},aEn="wrapper";function lEn(t){let{components:n,...e}=t;return(0,s.kt)(aEn,(0,p.Z)({},iEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}lEn.isMDXComponent=!0;const uEn={toc:[]},mEn="wrapper";function dEn(t){let{components:n,...e}=t;return(0,s.kt)(mEn,(0,p.Z)({},uEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}dEn.isMDXComponent=!0;const hEn={toc:[]},kEn="wrapper";function fEn(t){let{components:n,...e}=t;return(0,s.kt)(kEn,(0,p.Z)({},hEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}fEn.isMDXComponent=!0;const yEn={toc:[]},MEn="wrapper";function DEn(t){let{components:n,...e}=t;return(0,s.kt)(MEn,(0,p.Z)({},yEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}DEn.isMDXComponent=!0;const XEn={toc:[]},_En="wrapper";function wEn(t){let{components:n,...e}=t;return(0,s.kt)(_En,(0,p.Z)({},XEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}wEn.isMDXComponent=!0;const TEn={toc:[]},CEn="wrapper";function gEn(t){let{components:n,...e}=t;return(0,s.kt)(CEn,(0,p.Z)({},TEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}gEn.isMDXComponent=!0;const xEn={toc:[]},vEn="wrapper";function LEn(t){let{components:n,...e}=t;return(0,s.kt)(vEn,(0,p.Z)({},xEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}LEn.isMDXComponent=!0;const ZEn={toc:[]},bEn="wrapper";function NEn(t){let{components:n,...e}=t;return(0,s.kt)(bEn,(0,p.Z)({},ZEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}NEn.isMDXComponent=!0;const AEn={toc:[]},zEn="wrapper";function WEn(t){let{components:n,...e}=t;return(0,s.kt)(zEn,(0,p.Z)({},AEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}WEn.isMDXComponent=!0;const IEn={toc:[]},REn="wrapper";function PEn(t){let{components:n,...e}=t;return(0,s.kt)(REn,(0,p.Z)({},IEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}PEn.isMDXComponent=!0;const SEn={toc:[]},EEn="wrapper";function GEn(t){let{components:n,...e}=t;return(0,s.kt)(EEn,(0,p.Z)({},SEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}GEn.isMDXComponent=!0;const OEn={toc:[]},FEn="wrapper";function BEn(t){let{components:n,...e}=t;return(0,s.kt)(FEn,(0,p.Z)({},OEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}BEn.isMDXComponent=!0;const UEn={toc:[]},VEn="wrapper";function qEn(t){let{components:n,...e}=t;return(0,s.kt)(VEn,(0,p.Z)({},UEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qEn.isMDXComponent=!0;const jEn={toc:[]},YEn="wrapper";function QEn(t){let{components:n,...e}=t;return(0,s.kt)(YEn,(0,p.Z)({},jEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}QEn.isMDXComponent=!0;const HEn={toc:[]},$En="wrapper";function KEn(t){let{components:n,...e}=t;return(0,s.kt)($En,(0,p.Z)({},HEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}KEn.isMDXComponent=!0;const JEn={toc:[]},tGn="wrapper";function nGn(t){let{components:n,...e}=t;return(0,s.kt)(tGn,(0,p.Z)({},JEn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}nGn.isMDXComponent=!0;const eGn={toc:[]},oGn="wrapper";function pGn(t){let{components:n,...e}=t;return(0,s.kt)(oGn,(0,p.Z)({},eGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}pGn.isMDXComponent=!0;const rGn={toc:[]},sGn="wrapper";function cGn(t){let{components:n,...e}=t;return(0,s.kt)(sGn,(0,p.Z)({},rGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}cGn.isMDXComponent=!0;const iGn={toc:[]},aGn="wrapper";function lGn(t){let{components:n,...e}=t;return(0,s.kt)(aGn,(0,p.Z)({},iGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}lGn.isMDXComponent=!0;const uGn={toc:[]},mGn="wrapper";function dGn(t){let{components:n,...e}=t;return(0,s.kt)(mGn,(0,p.Z)({},uGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", the Line will use the positions of its children as\npoints."))}dGn.isMDXComponent=!0;const hGn={toc:[]},kGn="wrapper";function fGn(t){let{components:n,...e}=t;return(0,s.kt)(kGn,(0,p.Z)({},hGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The points of the line."))}fGn.isMDXComponent=!0;const yGn={toc:[]},MGn="wrapper";function DGn(t){let{components:n,...e}=t;return(0,s.kt)(MGn,(0,p.Z)({},yGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}DGn.isMDXComponent=!0;const XGn={toc:[]},_Gn="wrapper";function wGn(t){let{components:n,...e}=t;return(0,s.kt)(_Gn,(0,p.Z)({},XGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wGn.isMDXComponent=!0;const TGn={toc:[]},CGn="wrapper";function gGn(t){let{components:n,...e}=t;return(0,s.kt)(CGn,(0,p.Z)({},TGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The radius of the line's corners."))}gGn.isMDXComponent=!0;const xGn={toc:[]},vGn="wrapper";function LGn(t){let{components:n,...e}=t;return(0,s.kt)(vGn,(0,p.Z)({},xGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}LGn.isMDXComponent=!0;const ZGn={toc:[]},bGn="wrapper";function NGn(t){let{components:n,...e}=t;return(0,s.kt)(bGn,(0,p.Z)({},ZGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}NGn.isMDXComponent=!0;const AGn={toc:[]},zGn="wrapper";function WGn(t){let{components:n,...e}=t;return(0,s.kt)(zGn,(0,p.Z)({},AGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}WGn.isMDXComponent=!0;const IGn={toc:[]},RGn="wrapper";function PGn(t){let{components:n,...e}=t;return(0,s.kt)(RGn,(0,p.Z)({},IGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}PGn.isMDXComponent=!0;const SGn={toc:[]},EGn="wrapper";function GGn(t){let{components:n,...e}=t;return(0,s.kt)(EGn,(0,p.Z)({},SGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}GGn.isMDXComponent=!0;const OGn={toc:[]},FGn="wrapper";function BGn(t){let{components:n,...e}=t;return(0,s.kt)(FGn,(0,p.Z)({},OGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}BGn.isMDXComponent=!0;const UGn={toc:[]},VGn="wrapper";function qGn(t){let{components:n,...e}=t;return(0,s.kt)(VGn,(0,p.Z)({},UGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}qGn.isMDXComponent=!0;const jGn={toc:[]},YGn="wrapper";function QGn(t){let{components:n,...e}=t;return(0,s.kt)(YGn,(0,p.Z)({},jGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}QGn.isMDXComponent=!0;const HGn={toc:[]},$Gn="wrapper";function KGn(t){let{components:n,...e}=t;return(0,s.kt)($Gn,(0,p.Z)({},HGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}KGn.isMDXComponent=!0;const JGn={toc:[]},tOn="wrapper";function nOn(t){let{components:n,...e}=t;return(0,s.kt)(tOn,(0,p.Z)({},JGn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}nOn.isMDXComponent=!0;const eOn={toc:[]},oOn="wrapper";function pOn(t){let{components:n,...e}=t;return(0,s.kt)(oOn,(0,p.Z)({},eOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}pOn.isMDXComponent=!0;const rOn={toc:[]},sOn="wrapper";function cOn(t){let{components:n,...e}=t;return(0,s.kt)(sOn,(0,p.Z)({},rOn,e,{components:n,mdxType:"MDXLayout"}))}cOn.isMDXComponent=!0;const iOn={toc:[]},aOn="wrapper";function lOn(t){let{components:n,...e}=t;return(0,s.kt)(aOn,(0,p.Z)({},iOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}lOn.isMDXComponent=!0;const uOn={toc:[]},mOn="wrapper";function dOn(t){let{components:n,...e}=t;return(0,s.kt)(mOn,(0,p.Z)({},uOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}dOn.isMDXComponent=!0;const hOn={toc:[]},kOn="wrapper";function fOn(t){let{components:n,...e}=t;return(0,s.kt)(kOn,(0,p.Z)({},hOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}fOn.isMDXComponent=!0;const yOn={toc:[]},MOn="wrapper";function DOn(t){let{components:n,...e}=t;return(0,s.kt)(MOn,(0,p.Z)({},yOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}DOn.isMDXComponent=!0;const XOn={toc:[]},_On="wrapper";function wOn(t){let{components:n,...e}=t;return(0,s.kt)(_On,(0,p.Z)({},XOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}wOn.isMDXComponent=!0;const TOn={toc:[]},COn="wrapper";function gOn(t){let{components:n,...e}=t;return(0,s.kt)(COn,(0,p.Z)({},TOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}gOn.isMDXComponent=!0;const xOn={toc:[]},vOn="wrapper";function LOn(t){let{components:n,...e}=t;return(0,s.kt)(vOn,(0,p.Z)({},xOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}LOn.isMDXComponent=!0;const ZOn={toc:[]},bOn="wrapper";function NOn(t){let{components:n,...e}=t;return(0,s.kt)(bOn,(0,p.Z)({},ZOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}NOn.isMDXComponent=!0;const AOn={toc:[]},zOn="wrapper";function WOn(t){let{components:n,...e}=t;return(0,s.kt)(zOn,(0,p.Z)({},AOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}WOn.isMDXComponent=!0;const IOn={toc:[]},ROn="wrapper";function POn(t){let{components:n,...e}=t;return(0,s.kt)(ROn,(0,p.Z)({},IOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}POn.isMDXComponent=!0;const SOn={toc:[]},EOn="wrapper";function GOn(t){let{components:n,...e}=t;return(0,s.kt)(EOn,(0,p.Z)({},SOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}GOn.isMDXComponent=!0;const OOn={toc:[]},FOn="wrapper";function BOn(t){let{components:n,...e}=t;return(0,s.kt)(FOn,(0,p.Z)({},OOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}BOn.isMDXComponent=!0;const UOn={toc:[]},VOn="wrapper";function qOn(t){let{components:n,...e}=t;return(0,s.kt)(VOn,(0,p.Z)({},UOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}qOn.isMDXComponent=!0;const jOn={toc:[]},YOn="wrapper";function QOn(t){let{components:n,...e}=t;return(0,s.kt)(YOn,(0,p.Z)({},jOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}QOn.isMDXComponent=!0;const HOn={toc:[]},$On="wrapper";function KOn(t){let{components:n,...e}=t;return(0,s.kt)($On,(0,p.Z)({},HOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}KOn.isMDXComponent=!0;const JOn={toc:[]},tFn="wrapper";function nFn(t){let{components:n,...e}=t;return(0,s.kt)(tFn,(0,p.Z)({},JOn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}nFn.isMDXComponent=!0;const eFn={toc:[]},oFn="wrapper";function pFn(t){let{components:n,...e}=t;return(0,s.kt)(oFn,(0,p.Z)({},eFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}pFn.isMDXComponent=!0;const rFn={toc:[]},sFn="wrapper";function cFn(t){let{components:n,...e}=t;return(0,s.kt)(sFn,(0,p.Z)({},rFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}cFn.isMDXComponent=!0;const iFn={toc:[]},aFn="wrapper";function lFn(t){let{components:n,...e}=t;return(0,s.kt)(aFn,(0,p.Z)({},iFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}lFn.isMDXComponent=!0;const uFn={toc:[]},mFn="wrapper";function dFn(t){let{components:n,...e}=t;return(0,s.kt)(mFn,(0,p.Z)({},uFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}dFn.isMDXComponent=!0;const hFn={toc:[]},kFn="wrapper";function fFn(t){let{components:n,...e}=t;return(0,s.kt)(kFn,(0,p.Z)({},hFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}fFn.isMDXComponent=!0;const yFn={toc:[]},MFn="wrapper";function DFn(t){let{components:n,...e}=t;return(0,s.kt)(MFn,(0,p.Z)({},yFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}DFn.isMDXComponent=!0;const XFn={toc:[]},_Fn="wrapper";function wFn(t){let{components:n,...e}=t;return(0,s.kt)(_Fn,(0,p.Z)({},XFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}wFn.isMDXComponent=!0;const TFn={toc:[]},CFn="wrapper";function gFn(t){let{components:n,...e}=t;return(0,s.kt)(CFn,(0,p.Z)({},TFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}gFn.isMDXComponent=!0;const xFn={toc:[]},vFn="wrapper";function LFn(t){let{components:n,...e}=t;return(0,s.kt)(vFn,(0,p.Z)({},xFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}LFn.isMDXComponent=!0;const ZFn={toc:[]},bFn="wrapper";function NFn(t){let{components:n,...e}=t;return(0,s.kt)(bFn,(0,p.Z)({},ZFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}NFn.isMDXComponent=!0;const AFn={toc:[]},zFn="wrapper";function WFn(t){let{components:n,...e}=t;return(0,s.kt)(zFn,(0,p.Z)({},AFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}WFn.isMDXComponent=!0;const IFn={toc:[]},RFn="wrapper";function PFn(t){let{components:n,...e}=t;return(0,s.kt)(RFn,(0,p.Z)({},IFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}PFn.isMDXComponent=!0;const SFn={toc:[]},EFn="wrapper";function GFn(t){let{components:n,...e}=t;return(0,s.kt)(EFn,(0,p.Z)({},SFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}GFn.isMDXComponent=!0;const OFn={toc:[]},FFn="wrapper";function BFn(t){let{components:n,...e}=t;return(0,s.kt)(FFn,(0,p.Z)({},OFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}BFn.isMDXComponent=!0;const UFn={toc:[]},VFn="wrapper";function qFn(t){let{components:n,...e}=t;return(0,s.kt)(VFn,(0,p.Z)({},UFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}qFn.isMDXComponent=!0;const jFn={toc:[]},YFn="wrapper";function QFn(t){let{components:n,...e}=t;return(0,s.kt)(YFn,(0,p.Z)({},jFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}QFn.isMDXComponent=!0;const HFn={toc:[]},$Fn="wrapper";function KFn(t){let{components:n,...e}=t;return(0,s.kt)($Fn,(0,p.Z)({},HFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}KFn.isMDXComponent=!0;const JFn={toc:[]},tBn="wrapper";function nBn(t){let{components:n,...e}=t;return(0,s.kt)(tBn,(0,p.Z)({},JFn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}nBn.isMDXComponent=!0;const eBn={toc:[]},oBn="wrapper";function pBn(t){let{components:n,...e}=t;return(0,s.kt)(oBn,(0,p.Z)({},eBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}pBn.isMDXComponent=!0;const rBn={toc:[]},sBn="wrapper";function cBn(t){let{components:n,...e}=t;return(0,s.kt)(sBn,(0,p.Z)({},rBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}cBn.isMDXComponent=!0;const iBn={toc:[]},aBn="wrapper";function lBn(t){let{components:n,...e}=t;return(0,s.kt)(aBn,(0,p.Z)({},iBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}lBn.isMDXComponent=!0;const uBn={toc:[]},mBn="wrapper";function dBn(t){let{components:n,...e}=t;return(0,s.kt)(mBn,(0,p.Z)({},uBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}dBn.isMDXComponent=!0;const hBn={toc:[]},kBn="wrapper";function fBn(t){let{components:n,...e}=t;return(0,s.kt)(kBn,(0,p.Z)({},hBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}fBn.isMDXComponent=!0;const yBn={toc:[]},MBn="wrapper";function DBn(t){let{components:n,...e}=t;return(0,s.kt)(MBn,(0,p.Z)({},yBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}DBn.isMDXComponent=!0;const XBn={toc:[]},_Bn="wrapper";function wBn(t){let{components:n,...e}=t;return(0,s.kt)(_Bn,(0,p.Z)({},XBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}wBn.isMDXComponent=!0;const TBn={toc:[]},CBn="wrapper";function gBn(t){let{components:n,...e}=t;return(0,s.kt)(CBn,(0,p.Z)({},TBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}gBn.isMDXComponent=!0;const xBn={toc:[]},vBn="wrapper";function LBn(t){let{components:n,...e}=t;return(0,s.kt)(vBn,(0,p.Z)({},xBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}LBn.isMDXComponent=!0;const ZBn={toc:[]},bBn="wrapper";function NBn(t){let{components:n,...e}=t;return(0,s.kt)(bBn,(0,p.Z)({},ZBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}NBn.isMDXComponent=!0;const ABn={toc:[]},zBn="wrapper";function WBn(t){let{components:n,...e}=t;return(0,s.kt)(zBn,(0,p.Z)({},ABn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}WBn.isMDXComponent=!0;const IBn={toc:[]},RBn="wrapper";function PBn(t){let{components:n,...e}=t;return(0,s.kt)(RBn,(0,p.Z)({},IBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}PBn.isMDXComponent=!0;const SBn={toc:[]},EBn="wrapper";function GBn(t){let{components:n,...e}=t;return(0,s.kt)(EBn,(0,p.Z)({},SBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}GBn.isMDXComponent=!0;const OBn={toc:[]},FBn="wrapper";function BBn(t){let{components:n,...e}=t;return(0,s.kt)(FBn,(0,p.Z)({},OBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}BBn.isMDXComponent=!0;const UBn={toc:[]},VBn="wrapper";function qBn(t){let{components:n,...e}=t;return(0,s.kt)(VBn,(0,p.Z)({},UBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}qBn.isMDXComponent=!0;const jBn={toc:[]},YBn="wrapper";function QBn(t){let{components:n,...e}=t;return(0,s.kt)(YBn,(0,p.Z)({},jBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}QBn.isMDXComponent=!0;const HBn={toc:[]},$Bn="wrapper";function KBn(t){let{components:n,...e}=t;return(0,s.kt)($Bn,(0,p.Z)({},HBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}KBn.isMDXComponent=!0;const JBn={toc:[]},tUn="wrapper";function nUn(t){let{components:n,...e}=t;return(0,s.kt)(tUn,(0,p.Z)({},JBn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}nUn.isMDXComponent=!0;const eUn={toc:[]},oUn="wrapper";function pUn(t){let{components:n,...e}=t;return(0,s.kt)(oUn,(0,p.Z)({},eUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}pUn.isMDXComponent=!0;const rUn={toc:[]},sUn="wrapper";function cUn(t){let{components:n,...e}=t;return(0,s.kt)(sUn,(0,p.Z)({},rUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cUn.isMDXComponent=!0;const iUn={toc:[]},aUn="wrapper";function lUn(t){let{components:n,...e}=t;return(0,s.kt)(aUn,(0,p.Z)({},iUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}lUn.isMDXComponent=!0;const uUn={toc:[]},mUn="wrapper";function dUn(t){let{components:n,...e}=t;return(0,s.kt)(mUn,(0,p.Z)({},uUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dUn.isMDXComponent=!0;const hUn={toc:[]},kUn="wrapper";function fUn(t){let{components:n,...e}=t;return(0,s.kt)(kUn,(0,p.Z)({},hUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}fUn.isMDXComponent=!0;const yUn={toc:[]},MUn="wrapper";function DUn(t){let{components:n,...e}=t;return(0,s.kt)(MUn,(0,p.Z)({},yUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}DUn.isMDXComponent=!0;const XUn={toc:[]},_Un="wrapper";function wUn(t){let{components:n,...e}=t;return(0,s.kt)(_Un,(0,p.Z)({},XUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wUn.isMDXComponent=!0;const TUn={toc:[]},CUn="wrapper";function gUn(t){let{components:n,...e}=t;return(0,s.kt)(CUn,(0,p.Z)({},TUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}gUn.isMDXComponent=!0;const xUn={toc:[]},vUn="wrapper";function LUn(t){let{components:n,...e}=t;return(0,s.kt)(vUn,(0,p.Z)({},xUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}LUn.isMDXComponent=!0;const ZUn={toc:[]},bUn="wrapper";function NUn(t){let{components:n,...e}=t;return(0,s.kt)(bUn,(0,p.Z)({},ZUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NUn.isMDXComponent=!0;const AUn={toc:[]},zUn="wrapper";function WUn(t){let{components:n,...e}=t;return(0,s.kt)(zUn,(0,p.Z)({},AUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}WUn.isMDXComponent=!0;const IUn={toc:[]},RUn="wrapper";function PUn(t){let{components:n,...e}=t;return(0,s.kt)(RUn,(0,p.Z)({},IUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}PUn.isMDXComponent=!0;const SUn={toc:[]},EUn="wrapper";function GUn(t){let{components:n,...e}=t;return(0,s.kt)(EUn,(0,p.Z)({},SUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}GUn.isMDXComponent=!0;const OUn={toc:[]},FUn="wrapper";function BUn(t){let{components:n,...e}=t;return(0,s.kt)(FUn,(0,p.Z)({},OUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}BUn.isMDXComponent=!0;const UUn={toc:[]},VUn="wrapper";function qUn(t){let{components:n,...e}=t;return(0,s.kt)(VUn,(0,p.Z)({},UUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}qUn.isMDXComponent=!0;const jUn={toc:[]},YUn="wrapper";function QUn(t){let{components:n,...e}=t;return(0,s.kt)(YUn,(0,p.Z)({},jUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}QUn.isMDXComponent=!0;const HUn={toc:[]},$Un="wrapper";function KUn(t){let{components:n,...e}=t;return(0,s.kt)($Un,(0,p.Z)({},HUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}KUn.isMDXComponent=!0;const JUn={toc:[]},tVn="wrapper";function nVn(t){let{components:n,...e}=t;return(0,s.kt)(tVn,(0,p.Z)({},JUn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}nVn.isMDXComponent=!0;const eVn={toc:[]},oVn="wrapper";function pVn(t){let{components:n,...e}=t;return(0,s.kt)(oVn,(0,p.Z)({},eVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pVn.isMDXComponent=!0;const rVn={toc:[]},sVn="wrapper";function cVn(t){let{components:n,...e}=t;return(0,s.kt)(sVn,(0,p.Z)({},rVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}cVn.isMDXComponent=!0;const iVn={toc:[]},aVn="wrapper";function lVn(t){let{components:n,...e}=t;return(0,s.kt)(aVn,(0,p.Z)({},iVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}lVn.isMDXComponent=!0;const uVn={toc:[]},mVn="wrapper";function dVn(t){let{components:n,...e}=t;return(0,s.kt)(mVn,(0,p.Z)({},uVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}dVn.isMDXComponent=!0;const hVn={toc:[]},kVn="wrapper";function fVn(t){let{components:n,...e}=t;return(0,s.kt)(kVn,(0,p.Z)({},hVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}fVn.isMDXComponent=!0;const yVn={toc:[]},MVn="wrapper";function DVn(t){let{components:n,...e}=t;return(0,s.kt)(MVn,(0,p.Z)({},yVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}DVn.isMDXComponent=!0;const XVn={toc:[]},_Vn="wrapper";function wVn(t){let{components:n,...e}=t;return(0,s.kt)(_Vn,(0,p.Z)({},XVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}wVn.isMDXComponent=!0;const TVn={toc:[]},CVn="wrapper";function gVn(t){let{components:n,...e}=t;return(0,s.kt)(CVn,(0,p.Z)({},TVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}gVn.isMDXComponent=!0;const xVn={toc:[]},vVn="wrapper";function LVn(t){let{components:n,...e}=t;return(0,s.kt)(vVn,(0,p.Z)({},xVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}LVn.isMDXComponent=!0;const ZVn={toc:[]},bVn="wrapper";function NVn(t){let{components:n,...e}=t;return(0,s.kt)(bVn,(0,p.Z)({},ZVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}NVn.isMDXComponent=!0;const AVn={toc:[]},zVn="wrapper";function WVn(t){let{components:n,...e}=t;return(0,s.kt)(zVn,(0,p.Z)({},AVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}WVn.isMDXComponent=!0;const IVn={toc:[]},RVn="wrapper";function PVn(t){let{components:n,...e}=t;return(0,s.kt)(RVn,(0,p.Z)({},IVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}PVn.isMDXComponent=!0;const SVn={toc:[]},EVn="wrapper";function GVn(t){let{components:n,...e}=t;return(0,s.kt)(EVn,(0,p.Z)({},SVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}GVn.isMDXComponent=!0;const OVn={toc:[]},FVn="wrapper";function BVn(t){let{components:n,...e}=t;return(0,s.kt)(FVn,(0,p.Z)({},OVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}BVn.isMDXComponent=!0;const UVn={toc:[]},VVn="wrapper";function qVn(t){let{components:n,...e}=t;return(0,s.kt)(VVn,(0,p.Z)({},UVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}qVn.isMDXComponent=!0;const jVn={toc:[]},YVn="wrapper";function QVn(t){let{components:n,...e}=t;return(0,s.kt)(YVn,(0,p.Z)({},jVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}QVn.isMDXComponent=!0;const HVn={toc:[]},$Vn="wrapper";function KVn(t){let{components:n,...e}=t;return(0,s.kt)($Vn,(0,p.Z)({},HVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}KVn.isMDXComponent=!0;const JVn={toc:[]},tqn="wrapper";function nqn(t){let{components:n,...e}=t;return(0,s.kt)(tqn,(0,p.Z)({},JVn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}nqn.isMDXComponent=!0;const eqn={toc:[]},oqn="wrapper";function pqn(t){let{components:n,...e}=t;return(0,s.kt)(oqn,(0,p.Z)({},eqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}pqn.isMDXComponent=!0;const rqn={toc:[]},sqn="wrapper";function cqn(t){let{components:n,...e}=t;return(0,s.kt)(sqn,(0,p.Z)({},rqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}cqn.isMDXComponent=!0;const iqn={toc:[]},aqn="wrapper";function lqn(t){let{components:n,...e}=t;return(0,s.kt)(aqn,(0,p.Z)({},iqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}lqn.isMDXComponent=!0;const uqn={toc:[]},mqn="wrapper";function dqn(t){let{components:n,...e}=t;return(0,s.kt)(mqn,(0,p.Z)({},uqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}dqn.isMDXComponent=!0;const hqn={toc:[]},kqn="wrapper";function fqn(t){let{components:n,...e}=t;return(0,s.kt)(kqn,(0,p.Z)({},hqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}fqn.isMDXComponent=!0;const yqn={toc:[]},Mqn="wrapper";function Dqn(t){let{components:n,...e}=t;return(0,s.kt)(Mqn,(0,p.Z)({},yqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Dqn.isMDXComponent=!0;const Xqn={toc:[]},_qn="wrapper";function wqn(t){let{components:n,...e}=t;return(0,s.kt)(_qn,(0,p.Z)({},Xqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wqn.isMDXComponent=!0;const Tqn={toc:[]},Cqn="wrapper";function gqn(t){let{components:n,...e}=t;return(0,s.kt)(Cqn,(0,p.Z)({},Tqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}gqn.isMDXComponent=!0;const xqn={toc:[]},vqn="wrapper";function Lqn(t){let{components:n,...e}=t;return(0,s.kt)(vqn,(0,p.Z)({},xqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Lqn.isMDXComponent=!0;const Zqn={toc:[]},bqn="wrapper";function Nqn(t){let{components:n,...e}=t;return(0,s.kt)(bqn,(0,p.Z)({},Zqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Nqn.isMDXComponent=!0;const Aqn={toc:[]},zqn="wrapper";function Wqn(t){let{components:n,...e}=t;return(0,s.kt)(zqn,(0,p.Z)({},Aqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Wqn.isMDXComponent=!0;const Iqn={toc:[]},Rqn="wrapper";function Pqn(t){let{components:n,...e}=t;return(0,s.kt)(Rqn,(0,p.Z)({},Iqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Pqn.isMDXComponent=!0;const Sqn={toc:[]},Eqn="wrapper";function Gqn(t){let{components:n,...e}=t;return(0,s.kt)(Eqn,(0,p.Z)({},Sqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Gqn.isMDXComponent=!0;const Oqn={toc:[]},Fqn="wrapper";function Bqn(t){let{components:n,...e}=t;return(0,s.kt)(Fqn,(0,p.Z)({},Oqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Bqn.isMDXComponent=!0;const Uqn={toc:[]},Vqn="wrapper";function qqn(t){let{components:n,...e}=t;return(0,s.kt)(Vqn,(0,p.Z)({},Uqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}qqn.isMDXComponent=!0;const jqn={toc:[]},Yqn="wrapper";function Qqn(t){let{components:n,...e}=t;return(0,s.kt)(Yqn,(0,p.Z)({},jqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Qqn.isMDXComponent=!0;const Hqn={toc:[]},$qn="wrapper";function Kqn(t){let{components:n,...e}=t;return(0,s.kt)($qn,(0,p.Z)({},Hqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Kqn.isMDXComponent=!0;const Jqn={toc:[]},tjn="wrapper";function njn(t){let{components:n,...e}=t;return(0,s.kt)(tjn,(0,p.Z)({},Jqn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}njn.isMDXComponent=!0;const ejn={toc:[]},ojn="wrapper";function pjn(t){let{components:n,...e}=t;return(0,s.kt)(ojn,(0,p.Z)({},ejn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}pjn.isMDXComponent=!0;const rjn={toc:[]},sjn="wrapper";function cjn(t){let{components:n,...e}=t;return(0,s.kt)(sjn,(0,p.Z)({},rjn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}cjn.isMDXComponent=!0;const ijn={toc:[]},ajn="wrapper";function ljn(t){let{components:n,...e}=t;return(0,s.kt)(ajn,(0,p.Z)({},ijn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}ljn.isMDXComponent=!0;const ujn={toc:[]},mjn="wrapper";function djn(t){let{components:n,...e}=t;return(0,s.kt)(mjn,(0,p.Z)({},ujn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}djn.isMDXComponent=!0;const hjn={toc:[]},kjn="wrapper";function fjn(t){let{components:n,...e}=t;return(0,s.kt)(kjn,(0,p.Z)({},hjn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}fjn.isMDXComponent=!0;const yjn={toc:[]},Mjn="wrapper";function Djn(t){let{components:n,...e}=t;return(0,s.kt)(Mjn,(0,p.Z)({},yjn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Djn.isMDXComponent=!0;const Xjn={toc:[]},_jn="wrapper";function wjn(t){let{components:n,...e}=t;return(0,s.kt)(_jn,(0,p.Z)({},Xjn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}wjn.isMDXComponent=!0;const Tjn={toc:[]},Cjn="wrapper";function gjn(t){let{components:n,...e}=t;return(0,s.kt)(Cjn,(0,p.Z)({},Tjn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}gjn.isMDXComponent=!0;const xjn={toc:[]},vjn="wrapper";function Ljn(t){let{components:n,...e}=t;return(0,s.kt)(vjn,(0,p.Z)({},xjn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Ljn.isMDXComponent=!0;const Zjn={toc:[]},bjn="wrapper";function Njn(t){let{components:n,...e}=t;return(0,s.kt)(bjn,(0,p.Z)({},Zjn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Njn.isMDXComponent=!0;const Ajn={toc:[]},zjn="wrapper";function Wjn(t){let{components:n,...e}=t;return(0,s.kt)(zjn,(0,p.Z)({},Ajn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Wjn.isMDXComponent=!0;const Ijn={toc:[]},Rjn="wrapper";function Pjn(t){let{components:n,...e}=t;return(0,s.kt)(Rjn,(0,p.Z)({},Ijn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Pjn.isMDXComponent=!0;const Sjn={toc:[]},Ejn="wrapper";function Gjn(t){let{components:n,...e}=t;return(0,s.kt)(Ejn,(0,p.Z)({},Sjn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Gjn.isMDXComponent=!0;const Ojn={toc:[]},Fjn="wrapper";function Bjn(t){let{components:n,...e}=t;return(0,s.kt)(Fjn,(0,p.Z)({},Ojn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Bjn.isMDXComponent=!0;const Ujn={toc:[]},Vjn="wrapper";function qjn(t){let{components:n,...e}=t;return(0,s.kt)(Vjn,(0,p.Z)({},Ujn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}qjn.isMDXComponent=!0;const jjn={toc:[]},Yjn="wrapper";function Qjn(t){let{components:n,...e}=t;return(0,s.kt)(Yjn,(0,p.Z)({},jjn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Qjn.isMDXComponent=!0;const Hjn={toc:[]},$jn="wrapper";function Kjn(t){let{components:n,...e}=t;return(0,s.kt)($jn,(0,p.Z)({},Hjn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Kjn.isMDXComponent=!0;const Jjn={toc:[]},tYn="wrapper";function nYn(t){let{components:n,...e}=t;return(0,s.kt)(tYn,(0,p.Z)({},Jjn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}nYn.isMDXComponent=!0;const eYn={toc:[]},oYn="wrapper";function pYn(t){let{components:n,...e}=t;return(0,s.kt)(oYn,(0,p.Z)({},eYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}pYn.isMDXComponent=!0;const rYn={toc:[]},sYn="wrapper";function cYn(t){let{components:n,...e}=t;return(0,s.kt)(sYn,(0,p.Z)({},rYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}cYn.isMDXComponent=!0;const iYn={toc:[]},aYn="wrapper";function lYn(t){let{components:n,...e}=t;return(0,s.kt)(aYn,(0,p.Z)({},iYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}lYn.isMDXComponent=!0;const uYn={toc:[]},mYn="wrapper";function dYn(t){let{components:n,...e}=t;return(0,s.kt)(mYn,(0,p.Z)({},uYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}dYn.isMDXComponent=!0;const hYn={toc:[]},kYn="wrapper";function fYn(t){let{components:n,...e}=t;return(0,s.kt)(kYn,(0,p.Z)({},hYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}fYn.isMDXComponent=!0;const yYn={toc:[]},MYn="wrapper";function DYn(t){let{components:n,...e}=t;return(0,s.kt)(MYn,(0,p.Z)({},yYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}DYn.isMDXComponent=!0;const XYn={toc:[]},_Yn="wrapper";function wYn(t){let{components:n,...e}=t;return(0,s.kt)(_Yn,(0,p.Z)({},XYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}wYn.isMDXComponent=!0;const TYn={toc:[]},CYn="wrapper";function gYn(t){let{components:n,...e}=t;return(0,s.kt)(CYn,(0,p.Z)({},TYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}gYn.isMDXComponent=!0;const xYn={toc:[]},vYn="wrapper";function LYn(t){let{components:n,...e}=t;return(0,s.kt)(vYn,(0,p.Z)({},xYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}LYn.isMDXComponent=!0;const ZYn={toc:[]},bYn="wrapper";function NYn(t){let{components:n,...e}=t;return(0,s.kt)(bYn,(0,p.Z)({},ZYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}NYn.isMDXComponent=!0;const AYn={toc:[]},zYn="wrapper";function WYn(t){let{components:n,...e}=t;return(0,s.kt)(zYn,(0,p.Z)({},AYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}WYn.isMDXComponent=!0;const IYn={toc:[]},RYn="wrapper";function PYn(t){let{components:n,...e}=t;return(0,s.kt)(RYn,(0,p.Z)({},IYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}PYn.isMDXComponent=!0;const SYn={toc:[]},EYn="wrapper";function GYn(t){let{components:n,...e}=t;return(0,s.kt)(EYn,(0,p.Z)({},SYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}GYn.isMDXComponent=!0;const OYn={toc:[]},FYn="wrapper";function BYn(t){let{components:n,...e}=t;return(0,s.kt)(FYn,(0,p.Z)({},OYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}BYn.isMDXComponent=!0;const UYn={toc:[]},VYn="wrapper";function qYn(t){let{components:n,...e}=t;return(0,s.kt)(VYn,(0,p.Z)({},UYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}qYn.isMDXComponent=!0;const jYn={toc:[]},YYn="wrapper";function QYn(t){let{components:n,...e}=t;return(0,s.kt)(YYn,(0,p.Z)({},jYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}QYn.isMDXComponent=!0;const HYn={toc:[]},$Yn="wrapper";function KYn(t){let{components:n,...e}=t;return(0,s.kt)($Yn,(0,p.Z)({},HYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}KYn.isMDXComponent=!0;const JYn={toc:[]},tQn="wrapper";function nQn(t){let{components:n,...e}=t;return(0,s.kt)(tQn,(0,p.Z)({},JYn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}nQn.isMDXComponent=!0;const eQn={toc:[]},oQn="wrapper";function pQn(t){let{components:n,...e}=t;return(0,s.kt)(oQn,(0,p.Z)({},eQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}pQn.isMDXComponent=!0;const rQn={toc:[]},sQn="wrapper";function cQn(t){let{components:n,...e}=t;return(0,s.kt)(sQn,(0,p.Z)({},rQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}cQn.isMDXComponent=!0;const iQn={toc:[]},aQn="wrapper";function lQn(t){let{components:n,...e}=t;return(0,s.kt)(aQn,(0,p.Z)({},iQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}lQn.isMDXComponent=!0;const uQn={toc:[]},mQn="wrapper";function dQn(t){let{components:n,...e}=t;return(0,s.kt)(mQn,(0,p.Z)({},uQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}dQn.isMDXComponent=!0;const hQn={toc:[]},kQn="wrapper";function fQn(t){let{components:n,...e}=t;return(0,s.kt)(kQn,(0,p.Z)({},hQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}fQn.isMDXComponent=!0;const yQn={toc:[]},MQn="wrapper";function DQn(t){let{components:n,...e}=t;return(0,s.kt)(MQn,(0,p.Z)({},yQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}DQn.isMDXComponent=!0;const XQn={toc:[]},_Qn="wrapper";function wQn(t){let{components:n,...e}=t;return(0,s.kt)(_Qn,(0,p.Z)({},XQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}wQn.isMDXComponent=!0;const TQn={toc:[]},CQn="wrapper";function gQn(t){let{components:n,...e}=t;return(0,s.kt)(CQn,(0,p.Z)({},TQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}gQn.isMDXComponent=!0;const xQn={toc:[]},vQn="wrapper";function LQn(t){let{components:n,...e}=t;return(0,s.kt)(vQn,(0,p.Z)({},xQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}LQn.isMDXComponent=!0;const ZQn={toc:[]},bQn="wrapper";function NQn(t){let{components:n,...e}=t;return(0,s.kt)(bQn,(0,p.Z)({},ZQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}NQn.isMDXComponent=!0;const AQn={toc:[]},zQn="wrapper";function WQn(t){let{components:n,...e}=t;return(0,s.kt)(zQn,(0,p.Z)({},AQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}WQn.isMDXComponent=!0;const IQn={toc:[]},RQn="wrapper";function PQn(t){let{components:n,...e}=t;return(0,s.kt)(RQn,(0,p.Z)({},IQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}PQn.isMDXComponent=!0;const SQn={toc:[]},EQn="wrapper";function GQn(t){let{components:n,...e}=t;return(0,s.kt)(EQn,(0,p.Z)({},SQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}GQn.isMDXComponent=!0;const OQn={toc:[]},FQn="wrapper";function BQn(t){let{components:n,...e}=t;return(0,s.kt)(FQn,(0,p.Z)({},OQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}BQn.isMDXComponent=!0;const UQn={toc:[]},VQn="wrapper";function qQn(t){let{components:n,...e}=t;return(0,s.kt)(VQn,(0,p.Z)({},UQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qQn.isMDXComponent=!0;const jQn={toc:[]},YQn="wrapper";function QQn(t){let{components:n,...e}=t;return(0,s.kt)(YQn,(0,p.Z)({},jQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}QQn.isMDXComponent=!0;const HQn={toc:[]},$Qn="wrapper";function KQn(t){let{components:n,...e}=t;return(0,s.kt)($Qn,(0,p.Z)({},HQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}KQn.isMDXComponent=!0;const JQn={toc:[]},tHn="wrapper";function nHn(t){let{components:n,...e}=t;return(0,s.kt)(tHn,(0,p.Z)({},JQn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}nHn.isMDXComponent=!0;const eHn={toc:[]},oHn="wrapper";function pHn(t){let{components:n,...e}=t;return(0,s.kt)(oHn,(0,p.Z)({},eHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}pHn.isMDXComponent=!0;const rHn={toc:[]},sHn="wrapper";function cHn(t){let{components:n,...e}=t;return(0,s.kt)(sHn,(0,p.Z)({},rHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}cHn.isMDXComponent=!0;const iHn={toc:[]},aHn="wrapper";function lHn(t){let{components:n,...e}=t;return(0,s.kt)(aHn,(0,p.Z)({},iHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}lHn.isMDXComponent=!0;const uHn={toc:[]},mHn="wrapper";function dHn(t){let{components:n,...e}=t;return(0,s.kt)(mHn,(0,p.Z)({},uHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}dHn.isMDXComponent=!0;const hHn={toc:[]},kHn="wrapper";function fHn(t){let{components:n,...e}=t;return(0,s.kt)(kHn,(0,p.Z)({},hHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}fHn.isMDXComponent=!0;const yHn={toc:[]},MHn="wrapper";function DHn(t){let{components:n,...e}=t;return(0,s.kt)(MHn,(0,p.Z)({},yHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}DHn.isMDXComponent=!0;const XHn={toc:[]},_Hn="wrapper";function wHn(t){let{components:n,...e}=t;return(0,s.kt)(_Hn,(0,p.Z)({},XHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wHn.isMDXComponent=!0;const THn={toc:[]},CHn="wrapper";function gHn(t){let{components:n,...e}=t;return(0,s.kt)(CHn,(0,p.Z)({},THn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}gHn.isMDXComponent=!0;const xHn={toc:[]},vHn="wrapper";function LHn(t){let{components:n,...e}=t;return(0,s.kt)(vHn,(0,p.Z)({},xHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}LHn.isMDXComponent=!0;const ZHn={toc:[]},bHn="wrapper";function NHn(t){let{components:n,...e}=t;return(0,s.kt)(bHn,(0,p.Z)({},ZHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}NHn.isMDXComponent=!0;const AHn={toc:[]},zHn="wrapper";function WHn(t){let{components:n,...e}=t;return(0,s.kt)(zHn,(0,p.Z)({},AHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}WHn.isMDXComponent=!0;const IHn={toc:[]},RHn="wrapper";function PHn(t){let{components:n,...e}=t;return(0,s.kt)(RHn,(0,p.Z)({},IHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}PHn.isMDXComponent=!0;const SHn={toc:[]},EHn="wrapper";function GHn(t){let{components:n,...e}=t;return(0,s.kt)(EHn,(0,p.Z)({},SHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}GHn.isMDXComponent=!0;const OHn={toc:[]},FHn="wrapper";function BHn(t){let{components:n,...e}=t;return(0,s.kt)(FHn,(0,p.Z)({},OHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}BHn.isMDXComponent=!0;const UHn={toc:[]},VHn="wrapper";function qHn(t){let{components:n,...e}=t;return(0,s.kt)(VHn,(0,p.Z)({},UHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}qHn.isMDXComponent=!0;const jHn={toc:[]},YHn="wrapper";function QHn(t){let{components:n,...e}=t;return(0,s.kt)(YHn,(0,p.Z)({},jHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}QHn.isMDXComponent=!0;const HHn={toc:[]},$Hn="wrapper";function KHn(t){let{components:n,...e}=t;return(0,s.kt)($Hn,(0,p.Z)({},HHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}KHn.isMDXComponent=!0;const JHn={toc:[]},t$n="wrapper";function n$n(t){let{components:n,...e}=t;return(0,s.kt)(t$n,(0,p.Z)({},JHn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}n$n.isMDXComponent=!0;const e$n={toc:[]},o$n="wrapper";function p$n(t){let{components:n,...e}=t;return(0,s.kt)(o$n,(0,p.Z)({},e$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}p$n.isMDXComponent=!0;const r$n={toc:[]},s$n="wrapper";function c$n(t){let{components:n,...e}=t;return(0,s.kt)(s$n,(0,p.Z)({},r$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}c$n.isMDXComponent=!0;const i$n={toc:[]},a$n="wrapper";function l$n(t){let{components:n,...e}=t;return(0,s.kt)(a$n,(0,p.Z)({},i$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}l$n.isMDXComponent=!0;const u$n={toc:[]},m$n="wrapper";function d$n(t){let{components:n,...e}=t;return(0,s.kt)(m$n,(0,p.Z)({},u$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}d$n.isMDXComponent=!0;const h$n={toc:[]},k$n="wrapper";function f$n(t){let{components:n,...e}=t;return(0,s.kt)(k$n,(0,p.Z)({},h$n,e,{components:n,mdxType:"MDXLayout"}))}f$n.isMDXComponent=!0;const y$n={toc:[]},M$n="wrapper";function D$n(t){let{components:n,...e}=t;return(0,s.kt)(M$n,(0,p.Z)({},y$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}D$n.isMDXComponent=!0;const X$n={toc:[]},_$n="wrapper";function w$n(t){let{components:n,...e}=t;return(0,s.kt)(_$n,(0,p.Z)({},X$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}w$n.isMDXComponent=!0;const T$n={toc:[]},C$n="wrapper";function g$n(t){let{components:n,...e}=t;return(0,s.kt)(C$n,(0,p.Z)({},T$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}g$n.isMDXComponent=!0;const x$n={toc:[]},v$n="wrapper";function L$n(t){let{components:n,...e}=t;return(0,s.kt)(v$n,(0,p.Z)({},x$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}L$n.isMDXComponent=!0;const Z$n={toc:[]},b$n="wrapper";function N$n(t){let{components:n,...e}=t;return(0,s.kt)(b$n,(0,p.Z)({},Z$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}N$n.isMDXComponent=!0;const A$n={toc:[]},z$n="wrapper";function W$n(t){let{components:n,...e}=t;return(0,s.kt)(z$n,(0,p.Z)({},A$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}W$n.isMDXComponent=!0;const I$n={toc:[]},R$n="wrapper";function P$n(t){let{components:n,...e}=t;return(0,s.kt)(R$n,(0,p.Z)({},I$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}P$n.isMDXComponent=!0;const S$n={toc:[]},E$n="wrapper";function G$n(t){let{components:n,...e}=t;return(0,s.kt)(E$n,(0,p.Z)({},S$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}G$n.isMDXComponent=!0;const O$n={toc:[]},F$n="wrapper";function B$n(t){let{components:n,...e}=t;return(0,s.kt)(F$n,(0,p.Z)({},O$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}B$n.isMDXComponent=!0;const U$n={toc:[]},V$n="wrapper";function q$n(t){let{components:n,...e}=t;return(0,s.kt)(V$n,(0,p.Z)({},U$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}q$n.isMDXComponent=!0;const j$n={toc:[]},Y$n="wrapper";function Q$n(t){let{components:n,...e}=t;return(0,s.kt)(Y$n,(0,p.Z)({},j$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Q$n.isMDXComponent=!0;const H$n={toc:[]},$$n="wrapper";function K$n(t){let{components:n,...e}=t;return(0,s.kt)($$n,(0,p.Z)({},H$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}K$n.isMDXComponent=!0;const J$n={toc:[]},tKn="wrapper";function nKn(t){let{components:n,...e}=t;return(0,s.kt)(tKn,(0,p.Z)({},J$n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}nKn.isMDXComponent=!0;const eKn={toc:[]},oKn="wrapper";function pKn(t){let{components:n,...e}=t;return(0,s.kt)(oKn,(0,p.Z)({},eKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}pKn.isMDXComponent=!0;const rKn={toc:[]},sKn="wrapper";function cKn(t){let{components:n,...e}=t;return(0,s.kt)(sKn,(0,p.Z)({},rKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}cKn.isMDXComponent=!0;const iKn={toc:[]},aKn="wrapper";function lKn(t){let{components:n,...e}=t;return(0,s.kt)(aKn,(0,p.Z)({},iKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}lKn.isMDXComponent=!0;const uKn={toc:[]},mKn="wrapper";function dKn(t){let{components:n,...e}=t;return(0,s.kt)(mKn,(0,p.Z)({},uKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dKn.isMDXComponent=!0;const hKn={toc:[]},kKn="wrapper";function fKn(t){let{components:n,...e}=t;return(0,s.kt)(kKn,(0,p.Z)({},hKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}fKn.isMDXComponent=!0;const yKn={toc:[]},MKn="wrapper";function DKn(t){let{components:n,...e}=t;return(0,s.kt)(MKn,(0,p.Z)({},yKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}DKn.isMDXComponent=!0;const XKn={toc:[]},_Kn="wrapper";function wKn(t){let{components:n,...e}=t;return(0,s.kt)(_Kn,(0,p.Z)({},XKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}wKn.isMDXComponent=!0;const TKn={toc:[]},CKn="wrapper";function gKn(t){let{components:n,...e}=t;return(0,s.kt)(CKn,(0,p.Z)({},TKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}gKn.isMDXComponent=!0;const xKn={toc:[]},vKn="wrapper";function LKn(t){let{components:n,...e}=t;return(0,s.kt)(vKn,(0,p.Z)({},xKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}LKn.isMDXComponent=!0;const ZKn={toc:[]},bKn="wrapper";function NKn(t){let{components:n,...e}=t;return(0,s.kt)(bKn,(0,p.Z)({},ZKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}NKn.isMDXComponent=!0;const AKn={toc:[]},zKn="wrapper";function WKn(t){let{components:n,...e}=t;return(0,s.kt)(zKn,(0,p.Z)({},AKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}WKn.isMDXComponent=!0;const IKn={toc:[]},RKn="wrapper";function PKn(t){let{components:n,...e}=t;return(0,s.kt)(RKn,(0,p.Z)({},IKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}PKn.isMDXComponent=!0;const SKn={toc:[]},EKn="wrapper";function GKn(t){let{components:n,...e}=t;return(0,s.kt)(EKn,(0,p.Z)({},SKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}GKn.isMDXComponent=!0;const OKn={toc:[]},FKn="wrapper";function BKn(t){let{components:n,...e}=t;return(0,s.kt)(FKn,(0,p.Z)({},OKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}BKn.isMDXComponent=!0;const UKn={toc:[]},VKn="wrapper";function qKn(t){let{components:n,...e}=t;return(0,s.kt)(VKn,(0,p.Z)({},UKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qKn.isMDXComponent=!0;const jKn={toc:[]},YKn="wrapper";function QKn(t){let{components:n,...e}=t;return(0,s.kt)(YKn,(0,p.Z)({},jKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}QKn.isMDXComponent=!0;const HKn={toc:[]},$Kn="wrapper";function KKn(t){let{components:n,...e}=t;return(0,s.kt)($Kn,(0,p.Z)({},HKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}KKn.isMDXComponent=!0;const JKn={toc:[]},tJn="wrapper";function nJn(t){let{components:n,...e}=t;return(0,s.kt)(tJn,(0,p.Z)({},JKn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}nJn.isMDXComponent=!0;const eJn={toc:[]},oJn="wrapper";function pJn(t){let{components:n,...e}=t;return(0,s.kt)(oJn,(0,p.Z)({},eJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}pJn.isMDXComponent=!0;const rJn={toc:[]},sJn="wrapper";function cJn(t){let{components:n,...e}=t;return(0,s.kt)(sJn,(0,p.Z)({},rJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cJn.isMDXComponent=!0;const iJn={toc:[]},aJn="wrapper";function lJn(t){let{components:n,...e}=t;return(0,s.kt)(aJn,(0,p.Z)({},iJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}lJn.isMDXComponent=!0;const uJn={toc:[]},mJn="wrapper";function dJn(t){let{components:n,...e}=t;return(0,s.kt)(mJn,(0,p.Z)({},uJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dJn.isMDXComponent=!0;const hJn={toc:[]},kJn="wrapper";function fJn(t){let{components:n,...e}=t;return(0,s.kt)(kJn,(0,p.Z)({},hJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}fJn.isMDXComponent=!0;const yJn={toc:[]},MJn="wrapper";function DJn(t){let{components:n,...e}=t;return(0,s.kt)(MJn,(0,p.Z)({},yJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}DJn.isMDXComponent=!0;const XJn={toc:[]},_Jn="wrapper";function wJn(t){let{components:n,...e}=t;return(0,s.kt)(_Jn,(0,p.Z)({},XJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}wJn.isMDXComponent=!0;const TJn={toc:[]},CJn="wrapper";function gJn(t){let{components:n,...e}=t;return(0,s.kt)(CJn,(0,p.Z)({},TJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}gJn.isMDXComponent=!0;const xJn={toc:[]},vJn="wrapper";function LJn(t){let{components:n,...e}=t;return(0,s.kt)(vJn,(0,p.Z)({},xJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}LJn.isMDXComponent=!0;const ZJn={toc:[]},bJn="wrapper";function NJn(t){let{components:n,...e}=t;return(0,s.kt)(bJn,(0,p.Z)({},ZJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NJn.isMDXComponent=!0;const AJn={toc:[]},zJn="wrapper";function WJn(t){let{components:n,...e}=t;return(0,s.kt)(zJn,(0,p.Z)({},AJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}WJn.isMDXComponent=!0;const IJn={toc:[]},RJn="wrapper";function PJn(t){let{components:n,...e}=t;return(0,s.kt)(RJn,(0,p.Z)({},IJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}PJn.isMDXComponent=!0;const SJn={toc:[]},EJn="wrapper";function GJn(t){let{components:n,...e}=t;return(0,s.kt)(EJn,(0,p.Z)({},SJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}GJn.isMDXComponent=!0;const OJn={toc:[]},FJn="wrapper";function BJn(t){let{components:n,...e}=t;return(0,s.kt)(FJn,(0,p.Z)({},OJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}BJn.isMDXComponent=!0;const UJn={toc:[]},VJn="wrapper";function qJn(t){let{components:n,...e}=t;return(0,s.kt)(VJn,(0,p.Z)({},UJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}qJn.isMDXComponent=!0;const jJn={toc:[]},YJn="wrapper";function QJn(t){let{components:n,...e}=t;return(0,s.kt)(YJn,(0,p.Z)({},jJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}QJn.isMDXComponent=!0;const HJn={toc:[]},$Jn="wrapper";function KJn(t){let{components:n,...e}=t;return(0,s.kt)($Jn,(0,p.Z)({},HJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}KJn.isMDXComponent=!0;const JJn={toc:[]},t0n="wrapper";function n0n(t){let{components:n,...e}=t;return(0,s.kt)(t0n,(0,p.Z)({},JJn,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}n0n.isMDXComponent=!0;const e0n={toc:[]},o0n="wrapper";function p0n(t){let{components:n,...e}=t;return(0,s.kt)(o0n,(0,p.Z)({},e0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}p0n.isMDXComponent=!0;const r0n={toc:[]},s0n="wrapper";function c0n(t){let{components:n,...e}=t;return(0,s.kt)(s0n,(0,p.Z)({},r0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}c0n.isMDXComponent=!0;const i0n={toc:[]},a0n="wrapper";function l0n(t){let{components:n,...e}=t;return(0,s.kt)(a0n,(0,p.Z)({},i0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}l0n.isMDXComponent=!0;const u0n={toc:[]},m0n="wrapper";function d0n(t){let{components:n,...e}=t;return(0,s.kt)(m0n,(0,p.Z)({},u0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}d0n.isMDXComponent=!0;const h0n={toc:[]},k0n="wrapper";function f0n(t){let{components:n,...e}=t;return(0,s.kt)(k0n,(0,p.Z)({},h0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}f0n.isMDXComponent=!0;const y0n={toc:[]},M0n="wrapper";function D0n(t){let{components:n,...e}=t;return(0,s.kt)(M0n,(0,p.Z)({},y0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}D0n.isMDXComponent=!0;const X0n={toc:[]},_0n="wrapper";function w0n(t){let{components:n,...e}=t;return(0,s.kt)(_0n,(0,p.Z)({},X0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}w0n.isMDXComponent=!0;const T0n={toc:[]},C0n="wrapper";function g0n(t){let{components:n,...e}=t;return(0,s.kt)(C0n,(0,p.Z)({},T0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}g0n.isMDXComponent=!0;const x0n={toc:[]},v0n="wrapper";function L0n(t){let{components:n,...e}=t;return(0,s.kt)(v0n,(0,p.Z)({},x0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}L0n.isMDXComponent=!0;const Z0n={toc:[]},b0n="wrapper";function N0n(t){let{components:n,...e}=t;return(0,s.kt)(b0n,(0,p.Z)({},Z0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}N0n.isMDXComponent=!0;const A0n={toc:[]},z0n="wrapper";function W0n(t){let{components:n,...e}=t;return(0,s.kt)(z0n,(0,p.Z)({},A0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}W0n.isMDXComponent=!0;const I0n={toc:[]},R0n="wrapper";function P0n(t){let{components:n,...e}=t;return(0,s.kt)(R0n,(0,p.Z)({},I0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}P0n.isMDXComponent=!0;const S0n={toc:[]},E0n="wrapper";function G0n(t){let{components:n,...e}=t;return(0,s.kt)(E0n,(0,p.Z)({},S0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}G0n.isMDXComponent=!0;const O0n={toc:[]},F0n="wrapper";function B0n(t){let{components:n,...e}=t;return(0,s.kt)(F0n,(0,p.Z)({},O0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}B0n.isMDXComponent=!0;const U0n={toc:[]},V0n="wrapper";function q0n(t){let{components:n,...e}=t;return(0,s.kt)(V0n,(0,p.Z)({},U0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}q0n.isMDXComponent=!0;const j0n={toc:[]},Y0n="wrapper";function Q0n(t){let{components:n,...e}=t;return(0,s.kt)(Y0n,(0,p.Z)({},j0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Q0n.isMDXComponent=!0;const H0n={toc:[]},$0n="wrapper";function K0n(t){let{components:n,...e}=t;return(0,s.kt)($0n,(0,p.Z)({},H0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}K0n.isMDXComponent=!0;const J0n={toc:[]},t2n="wrapper";function n2n(t){let{components:n,...e}=t;return(0,s.kt)(t2n,(0,p.Z)({},J0n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}n2n.isMDXComponent=!0;const e2n={toc:[]},o2n="wrapper";function p2n(t){let{components:n,...e}=t;return(0,s.kt)(o2n,(0,p.Z)({},e2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}p2n.isMDXComponent=!0;const r2n={toc:[]},s2n="wrapper";function c2n(t){let{components:n,...e}=t;return(0,s.kt)(s2n,(0,p.Z)({},r2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}c2n.isMDXComponent=!0;const i2n={toc:[]},a2n="wrapper";function l2n(t){let{components:n,...e}=t;return(0,s.kt)(a2n,(0,p.Z)({},i2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}l2n.isMDXComponent=!0;const u2n={toc:[]},m2n="wrapper";function d2n(t){let{components:n,...e}=t;return(0,s.kt)(m2n,(0,p.Z)({},u2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}d2n.isMDXComponent=!0;const h2n={toc:[]},k2n="wrapper";function f2n(t){let{components:n,...e}=t;return(0,s.kt)(k2n,(0,p.Z)({},h2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}f2n.isMDXComponent=!0;const y2n={toc:[]},M2n="wrapper";function D2n(t){let{components:n,...e}=t;return(0,s.kt)(M2n,(0,p.Z)({},y2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}D2n.isMDXComponent=!0;const X2n={toc:[]},_2n="wrapper";function w2n(t){let{components:n,...e}=t;return(0,s.kt)(_2n,(0,p.Z)({},X2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}w2n.isMDXComponent=!0;const T2n={toc:[]},C2n="wrapper";function g2n(t){let{components:n,...e}=t;return(0,s.kt)(C2n,(0,p.Z)({},T2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}g2n.isMDXComponent=!0;const x2n={toc:[]},v2n="wrapper";function L2n(t){let{components:n,...e}=t;return(0,s.kt)(v2n,(0,p.Z)({},x2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}L2n.isMDXComponent=!0;const Z2n={toc:[]},b2n="wrapper";function N2n(t){let{components:n,...e}=t;return(0,s.kt)(b2n,(0,p.Z)({},Z2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}N2n.isMDXComponent=!0;const A2n={toc:[]},z2n="wrapper";function W2n(t){let{components:n,...e}=t;return(0,s.kt)(z2n,(0,p.Z)({},A2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}W2n.isMDXComponent=!0;const I2n={toc:[]},R2n="wrapper";function P2n(t){let{components:n,...e}=t;return(0,s.kt)(R2n,(0,p.Z)({},I2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}P2n.isMDXComponent=!0;const S2n={toc:[]},E2n="wrapper";function G2n(t){let{components:n,...e}=t;return(0,s.kt)(E2n,(0,p.Z)({},S2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}G2n.isMDXComponent=!0;const O2n={toc:[]},F2n="wrapper";function B2n(t){let{components:n,...e}=t;return(0,s.kt)(F2n,(0,p.Z)({},O2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}B2n.isMDXComponent=!0;const U2n={toc:[]},V2n="wrapper";function q2n(t){let{components:n,...e}=t;return(0,s.kt)(V2n,(0,p.Z)({},U2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}q2n.isMDXComponent=!0;const j2n={toc:[]},Y2n="wrapper";function Q2n(t){let{components:n,...e}=t;return(0,s.kt)(Y2n,(0,p.Z)({},j2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Q2n.isMDXComponent=!0;const H2n={toc:[]},$2n="wrapper";function K2n(t){let{components:n,...e}=t;return(0,s.kt)($2n,(0,p.Z)({},H2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}K2n.isMDXComponent=!0;const J2n={toc:[]},t6n="wrapper";function n6n(t){let{components:n,...e}=t;return(0,s.kt)(t6n,(0,p.Z)({},J2n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}n6n.isMDXComponent=!0;const e6n={toc:[]},o6n="wrapper";function p6n(t){let{components:n,...e}=t;return(0,s.kt)(o6n,(0,p.Z)({},e6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}p6n.isMDXComponent=!0;const r6n={toc:[]},s6n="wrapper";function c6n(t){let{components:n,...e}=t;return(0,s.kt)(s6n,(0,p.Z)({},r6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}c6n.isMDXComponent=!0;const i6n={toc:[]},a6n="wrapper";function l6n(t){let{components:n,...e}=t;return(0,s.kt)(a6n,(0,p.Z)({},i6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}l6n.isMDXComponent=!0;const u6n={toc:[]},m6n="wrapper";function d6n(t){let{components:n,...e}=t;return(0,s.kt)(m6n,(0,p.Z)({},u6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}d6n.isMDXComponent=!0;const h6n={toc:[]},k6n="wrapper";function f6n(t){let{components:n,...e}=t;return(0,s.kt)(k6n,(0,p.Z)({},h6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}f6n.isMDXComponent=!0;const y6n={toc:[]},M6n="wrapper";function D6n(t){let{components:n,...e}=t;return(0,s.kt)(M6n,(0,p.Z)({},y6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}D6n.isMDXComponent=!0;const X6n={toc:[]},_6n="wrapper";function w6n(t){let{components:n,...e}=t;return(0,s.kt)(_6n,(0,p.Z)({},X6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}w6n.isMDXComponent=!0;const T6n={toc:[]},C6n="wrapper";function g6n(t){let{components:n,...e}=t;return(0,s.kt)(C6n,(0,p.Z)({},T6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}g6n.isMDXComponent=!0;const x6n={toc:[]},v6n="wrapper";function L6n(t){let{components:n,...e}=t;return(0,s.kt)(v6n,(0,p.Z)({},x6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}L6n.isMDXComponent=!0;const Z6n={toc:[]},b6n="wrapper";function N6n(t){let{components:n,...e}=t;return(0,s.kt)(b6n,(0,p.Z)({},Z6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}N6n.isMDXComponent=!0;const A6n={toc:[]},z6n="wrapper";function W6n(t){let{components:n,...e}=t;return(0,s.kt)(z6n,(0,p.Z)({},A6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}W6n.isMDXComponent=!0;const I6n={toc:[]},R6n="wrapper";function P6n(t){let{components:n,...e}=t;return(0,s.kt)(R6n,(0,p.Z)({},I6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}P6n.isMDXComponent=!0;const S6n={toc:[]},E6n="wrapper";function G6n(t){let{components:n,...e}=t;return(0,s.kt)(E6n,(0,p.Z)({},S6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}G6n.isMDXComponent=!0;const O6n={toc:[]},F6n="wrapper";function B6n(t){let{components:n,...e}=t;return(0,s.kt)(F6n,(0,p.Z)({},O6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}B6n.isMDXComponent=!0;const U6n={toc:[]},V6n="wrapper";function q6n(t){let{components:n,...e}=t;return(0,s.kt)(V6n,(0,p.Z)({},U6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}q6n.isMDXComponent=!0;const j6n={toc:[]},Y6n="wrapper";function Q6n(t){let{components:n,...e}=t;return(0,s.kt)(Y6n,(0,p.Z)({},j6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Q6n.isMDXComponent=!0;const H6n={toc:[]},$6n="wrapper";function K6n(t){let{components:n,...e}=t;return(0,s.kt)($6n,(0,p.Z)({},H6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}K6n.isMDXComponent=!0;const J6n={toc:[]},t3n="wrapper";function n3n(t){let{components:n,...e}=t;return(0,s.kt)(t3n,(0,p.Z)({},J6n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}n3n.isMDXComponent=!0;const e3n={toc:[]},o3n="wrapper";function p3n(t){let{components:n,...e}=t;return(0,s.kt)(o3n,(0,p.Z)({},e3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}p3n.isMDXComponent=!0;const r3n={toc:[]},s3n="wrapper";function c3n(t){let{components:n,...e}=t;return(0,s.kt)(s3n,(0,p.Z)({},r3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}c3n.isMDXComponent=!0;const i3n={toc:[]},a3n="wrapper";function l3n(t){let{components:n,...e}=t;return(0,s.kt)(a3n,(0,p.Z)({},i3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}l3n.isMDXComponent=!0;const u3n={toc:[]},m3n="wrapper";function d3n(t){let{components:n,...e}=t;return(0,s.kt)(m3n,(0,p.Z)({},u3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}d3n.isMDXComponent=!0;const h3n={toc:[]},k3n="wrapper";function f3n(t){let{components:n,...e}=t;return(0,s.kt)(k3n,(0,p.Z)({},h3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}f3n.isMDXComponent=!0;const y3n={toc:[]},M3n="wrapper";function D3n(t){let{components:n,...e}=t;return(0,s.kt)(M3n,(0,p.Z)({},y3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}D3n.isMDXComponent=!0;const X3n={toc:[]},_3n="wrapper";function w3n(t){let{components:n,...e}=t;return(0,s.kt)(_3n,(0,p.Z)({},X3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}w3n.isMDXComponent=!0;const T3n={toc:[]},C3n="wrapper";function g3n(t){let{components:n,...e}=t;return(0,s.kt)(C3n,(0,p.Z)({},T3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}g3n.isMDXComponent=!0;const x3n={toc:[]},v3n="wrapper";function L3n(t){let{components:n,...e}=t;return(0,s.kt)(v3n,(0,p.Z)({},x3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}L3n.isMDXComponent=!0;const Z3n={toc:[]},b3n="wrapper";function N3n(t){let{components:n,...e}=t;return(0,s.kt)(b3n,(0,p.Z)({},Z3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}N3n.isMDXComponent=!0;const A3n={toc:[]},z3n="wrapper";function W3n(t){let{components:n,...e}=t;return(0,s.kt)(z3n,(0,p.Z)({},A3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}W3n.isMDXComponent=!0;const I3n={toc:[]},R3n="wrapper";function P3n(t){let{components:n,...e}=t;return(0,s.kt)(R3n,(0,p.Z)({},I3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}P3n.isMDXComponent=!0;const S3n={toc:[]},E3n="wrapper";function G3n(t){let{components:n,...e}=t;return(0,s.kt)(E3n,(0,p.Z)({},S3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}G3n.isMDXComponent=!0;const O3n={toc:[]},F3n="wrapper";function B3n(t){let{components:n,...e}=t;return(0,s.kt)(F3n,(0,p.Z)({},O3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}B3n.isMDXComponent=!0;const U3n={toc:[]},V3n="wrapper";function q3n(t){let{components:n,...e}=t;return(0,s.kt)(V3n,(0,p.Z)({},U3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}q3n.isMDXComponent=!0;const j3n={toc:[]},Y3n="wrapper";function Q3n(t){let{components:n,...e}=t;return(0,s.kt)(Y3n,(0,p.Z)({},j3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Q3n.isMDXComponent=!0;const H3n={toc:[]},$3n="wrapper";function K3n(t){let{components:n,...e}=t;return(0,s.kt)($3n,(0,p.Z)({},H3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}K3n.isMDXComponent=!0;const J3n={toc:[]},t5n="wrapper";function n5n(t){let{components:n,...e}=t;return(0,s.kt)(t5n,(0,p.Z)({},J3n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}n5n.isMDXComponent=!0;const e5n={toc:[]},o5n="wrapper";function p5n(t){let{components:n,...e}=t;return(0,s.kt)(o5n,(0,p.Z)({},e5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}p5n.isMDXComponent=!0;const r5n={toc:[]},s5n="wrapper";function c5n(t){let{components:n,...e}=t;return(0,s.kt)(s5n,(0,p.Z)({},r5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}c5n.isMDXComponent=!0;const i5n={toc:[]},a5n="wrapper";function l5n(t){let{components:n,...e}=t;return(0,s.kt)(a5n,(0,p.Z)({},i5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}l5n.isMDXComponent=!0;const u5n={toc:[]},m5n="wrapper";function d5n(t){let{components:n,...e}=t;return(0,s.kt)(m5n,(0,p.Z)({},u5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}d5n.isMDXComponent=!0;const h5n={toc:[]},k5n="wrapper";function f5n(t){let{components:n,...e}=t;return(0,s.kt)(k5n,(0,p.Z)({},h5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}f5n.isMDXComponent=!0;const y5n={toc:[]},M5n="wrapper";function D5n(t){let{components:n,...e}=t;return(0,s.kt)(M5n,(0,p.Z)({},y5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}D5n.isMDXComponent=!0;const X5n={toc:[]},_5n="wrapper";function w5n(t){let{components:n,...e}=t;return(0,s.kt)(_5n,(0,p.Z)({},X5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}w5n.isMDXComponent=!0;const T5n={toc:[]},C5n="wrapper";function g5n(t){let{components:n,...e}=t;return(0,s.kt)(C5n,(0,p.Z)({},T5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}g5n.isMDXComponent=!0;const x5n={toc:[]},v5n="wrapper";function L5n(t){let{components:n,...e}=t;return(0,s.kt)(v5n,(0,p.Z)({},x5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}L5n.isMDXComponent=!0;const Z5n={toc:[]},b5n="wrapper";function N5n(t){let{components:n,...e}=t;return(0,s.kt)(b5n,(0,p.Z)({},Z5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}N5n.isMDXComponent=!0;const A5n={toc:[]},z5n="wrapper";function W5n(t){let{components:n,...e}=t;return(0,s.kt)(z5n,(0,p.Z)({},A5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}W5n.isMDXComponent=!0;const I5n={toc:[]},R5n="wrapper";function P5n(t){let{components:n,...e}=t;return(0,s.kt)(R5n,(0,p.Z)({},I5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}P5n.isMDXComponent=!0;const S5n={toc:[]},E5n="wrapper";function G5n(t){let{components:n,...e}=t;return(0,s.kt)(E5n,(0,p.Z)({},S5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}G5n.isMDXComponent=!0;const O5n={toc:[]},F5n="wrapper";function B5n(t){let{components:n,...e}=t;return(0,s.kt)(F5n,(0,p.Z)({},O5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}B5n.isMDXComponent=!0;const U5n={toc:[]},V5n="wrapper";function q5n(t){let{components:n,...e}=t;return(0,s.kt)(V5n,(0,p.Z)({},U5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}q5n.isMDXComponent=!0;const j5n={toc:[]},Y5n="wrapper";function Q5n(t){let{components:n,...e}=t;return(0,s.kt)(Y5n,(0,p.Z)({},j5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Q5n.isMDXComponent=!0;const H5n={toc:[]},$5n="wrapper";function K5n(t){let{components:n,...e}=t;return(0,s.kt)($5n,(0,p.Z)({},H5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}K5n.isMDXComponent=!0;const J5n={toc:[]},t1n="wrapper";function n1n(t){let{components:n,...e}=t;return(0,s.kt)(t1n,(0,p.Z)({},J5n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}n1n.isMDXComponent=!0;const e1n={toc:[]},o1n="wrapper";function p1n(t){let{components:n,...e}=t;return(0,s.kt)(o1n,(0,p.Z)({},e1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}p1n.isMDXComponent=!0;const r1n={toc:[]},s1n="wrapper";function c1n(t){let{components:n,...e}=t;return(0,s.kt)(s1n,(0,p.Z)({},r1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}c1n.isMDXComponent=!0;const i1n={toc:[]},a1n="wrapper";function l1n(t){let{components:n,...e}=t;return(0,s.kt)(a1n,(0,p.Z)({},i1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}l1n.isMDXComponent=!0;const u1n={toc:[]},m1n="wrapper";function d1n(t){let{components:n,...e}=t;return(0,s.kt)(m1n,(0,p.Z)({},u1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}d1n.isMDXComponent=!0;const h1n={toc:[]},k1n="wrapper";function f1n(t){let{components:n,...e}=t;return(0,s.kt)(k1n,(0,p.Z)({},h1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}f1n.isMDXComponent=!0;const y1n={toc:[]},M1n="wrapper";function D1n(t){let{components:n,...e}=t;return(0,s.kt)(M1n,(0,p.Z)({},y1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}D1n.isMDXComponent=!0;const X1n={toc:[]},_1n="wrapper";function w1n(t){let{components:n,...e}=t;return(0,s.kt)(_1n,(0,p.Z)({},X1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}w1n.isMDXComponent=!0;const T1n={toc:[]},C1n="wrapper";function g1n(t){let{components:n,...e}=t;return(0,s.kt)(C1n,(0,p.Z)({},T1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}g1n.isMDXComponent=!0;const x1n={toc:[]},v1n="wrapper";function L1n(t){let{components:n,...e}=t;return(0,s.kt)(v1n,(0,p.Z)({},x1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}L1n.isMDXComponent=!0;const Z1n={toc:[]},b1n="wrapper";function N1n(t){let{components:n,...e}=t;return(0,s.kt)(b1n,(0,p.Z)({},Z1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}N1n.isMDXComponent=!0;const A1n={toc:[]},z1n="wrapper";function W1n(t){let{components:n,...e}=t;return(0,s.kt)(z1n,(0,p.Z)({},A1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}W1n.isMDXComponent=!0;const I1n={toc:[]},R1n="wrapper";function P1n(t){let{components:n,...e}=t;return(0,s.kt)(R1n,(0,p.Z)({},I1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}P1n.isMDXComponent=!0;const S1n={toc:[]},E1n="wrapper";function G1n(t){let{components:n,...e}=t;return(0,s.kt)(E1n,(0,p.Z)({},S1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}G1n.isMDXComponent=!0;const O1n={toc:[]},F1n="wrapper";function B1n(t){let{components:n,...e}=t;return(0,s.kt)(F1n,(0,p.Z)({},O1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}B1n.isMDXComponent=!0;const U1n={toc:[]},V1n="wrapper";function q1n(t){let{components:n,...e}=t;return(0,s.kt)(V1n,(0,p.Z)({},U1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}q1n.isMDXComponent=!0;const j1n={toc:[]},Y1n="wrapper";function Q1n(t){let{components:n,...e}=t;return(0,s.kt)(Y1n,(0,p.Z)({},j1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Q1n.isMDXComponent=!0;const H1n={toc:[]},$1n="wrapper";function K1n(t){let{components:n,...e}=t;return(0,s.kt)($1n,(0,p.Z)({},H1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}K1n.isMDXComponent=!0;const J1n={toc:[]},t4n="wrapper";function n4n(t){let{components:n,...e}=t;return(0,s.kt)(t4n,(0,p.Z)({},J1n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}n4n.isMDXComponent=!0;const e4n={toc:[]},o4n="wrapper";function p4n(t){let{components:n,...e}=t;return(0,s.kt)(o4n,(0,p.Z)({},e4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}p4n.isMDXComponent=!0;const r4n={toc:[]},s4n="wrapper";function c4n(t){let{components:n,...e}=t;return(0,s.kt)(s4n,(0,p.Z)({},r4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}c4n.isMDXComponent=!0;const i4n={toc:[]},a4n="wrapper";function l4n(t){let{components:n,...e}=t;return(0,s.kt)(a4n,(0,p.Z)({},i4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}l4n.isMDXComponent=!0;const u4n={toc:[]},m4n="wrapper";function d4n(t){let{components:n,...e}=t;return(0,s.kt)(m4n,(0,p.Z)({},u4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}d4n.isMDXComponent=!0;const h4n={toc:[]},k4n="wrapper";function f4n(t){let{components:n,...e}=t;return(0,s.kt)(k4n,(0,p.Z)({},h4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}f4n.isMDXComponent=!0;const y4n={toc:[]},M4n="wrapper";function D4n(t){let{components:n,...e}=t;return(0,s.kt)(M4n,(0,p.Z)({},y4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}D4n.isMDXComponent=!0;const X4n={toc:[]},_4n="wrapper";function w4n(t){let{components:n,...e}=t;return(0,s.kt)(_4n,(0,p.Z)({},X4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}w4n.isMDXComponent=!0;const T4n={toc:[]},C4n="wrapper";function g4n(t){let{components:n,...e}=t;return(0,s.kt)(C4n,(0,p.Z)({},T4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}g4n.isMDXComponent=!0;const x4n={toc:[]},v4n="wrapper";function L4n(t){let{components:n,...e}=t;return(0,s.kt)(v4n,(0,p.Z)({},x4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}L4n.isMDXComponent=!0;const Z4n={toc:[]},b4n="wrapper";function N4n(t){let{components:n,...e}=t;return(0,s.kt)(b4n,(0,p.Z)({},Z4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}N4n.isMDXComponent=!0;const A4n={toc:[]},z4n="wrapper";function W4n(t){let{components:n,...e}=t;return(0,s.kt)(z4n,(0,p.Z)({},A4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}W4n.isMDXComponent=!0;const I4n={toc:[]},R4n="wrapper";function P4n(t){let{components:n,...e}=t;return(0,s.kt)(R4n,(0,p.Z)({},I4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}P4n.isMDXComponent=!0;const S4n={toc:[]},E4n="wrapper";function G4n(t){let{components:n,...e}=t;return(0,s.kt)(E4n,(0,p.Z)({},S4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}G4n.isMDXComponent=!0;const O4n={toc:[]},F4n="wrapper";function B4n(t){let{components:n,...e}=t;return(0,s.kt)(F4n,(0,p.Z)({},O4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}B4n.isMDXComponent=!0;const U4n={toc:[]},V4n="wrapper";function q4n(t){let{components:n,...e}=t;return(0,s.kt)(V4n,(0,p.Z)({},U4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}q4n.isMDXComponent=!0;const j4n={toc:[]},Y4n="wrapper";function Q4n(t){let{components:n,...e}=t;return(0,s.kt)(Y4n,(0,p.Z)({},j4n,e,{components:n,mdxType:"MDXLayout"}))}Q4n.isMDXComponent=!0;const H4n={toc:[]},$4n="wrapper";function K4n(t){let{components:n,...e}=t;return(0,s.kt)($4n,(0,p.Z)({},H4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}K4n.isMDXComponent=!0;const J4n={toc:[]},t8n="wrapper";function n8n(t){let{components:n,...e}=t;return(0,s.kt)(t8n,(0,p.Z)({},J4n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}n8n.isMDXComponent=!0;const e8n={toc:[]},o8n="wrapper";function p8n(t){let{components:n,...e}=t;return(0,s.kt)(o8n,(0,p.Z)({},e8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}p8n.isMDXComponent=!0;const r8n={toc:[]},s8n="wrapper";function c8n(t){let{components:n,...e}=t;return(0,s.kt)(s8n,(0,p.Z)({},r8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}c8n.isMDXComponent=!0;const i8n={toc:[]},a8n="wrapper";function l8n(t){let{components:n,...e}=t;return(0,s.kt)(a8n,(0,p.Z)({},i8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}l8n.isMDXComponent=!0;const u8n={toc:[]},m8n="wrapper";function d8n(t){let{components:n,...e}=t;return(0,s.kt)(m8n,(0,p.Z)({},u8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}d8n.isMDXComponent=!0;const h8n={toc:[]},k8n="wrapper";function f8n(t){let{components:n,...e}=t;return(0,s.kt)(k8n,(0,p.Z)({},h8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}f8n.isMDXComponent=!0;const y8n={toc:[]},M8n="wrapper";function D8n(t){let{components:n,...e}=t;return(0,s.kt)(M8n,(0,p.Z)({},y8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}D8n.isMDXComponent=!0;const X8n={toc:[]},_8n="wrapper";function w8n(t){let{components:n,...e}=t;return(0,s.kt)(_8n,(0,p.Z)({},X8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}w8n.isMDXComponent=!0;const T8n={toc:[]},C8n="wrapper";function g8n(t){let{components:n,...e}=t;return(0,s.kt)(C8n,(0,p.Z)({},T8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}g8n.isMDXComponent=!0;const x8n={toc:[]},v8n="wrapper";function L8n(t){let{components:n,...e}=t;return(0,s.kt)(v8n,(0,p.Z)({},x8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}L8n.isMDXComponent=!0;const Z8n={toc:[]},b8n="wrapper";function N8n(t){let{components:n,...e}=t;return(0,s.kt)(b8n,(0,p.Z)({},Z8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}N8n.isMDXComponent=!0;const A8n={toc:[]},z8n="wrapper";function W8n(t){let{components:n,...e}=t;return(0,s.kt)(z8n,(0,p.Z)({},A8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}W8n.isMDXComponent=!0;const I8n={toc:[]},R8n="wrapper";function P8n(t){let{components:n,...e}=t;return(0,s.kt)(R8n,(0,p.Z)({},I8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}P8n.isMDXComponent=!0;const S8n={toc:[]},E8n="wrapper";function G8n(t){let{components:n,...e}=t;return(0,s.kt)(E8n,(0,p.Z)({},S8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}G8n.isMDXComponent=!0;const O8n={toc:[]},F8n="wrapper";function B8n(t){let{components:n,...e}=t;return(0,s.kt)(F8n,(0,p.Z)({},O8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}B8n.isMDXComponent=!0;const U8n={toc:[]},V8n="wrapper";function q8n(t){let{components:n,...e}=t;return(0,s.kt)(V8n,(0,p.Z)({},U8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}q8n.isMDXComponent=!0;const j8n={toc:[]},Y8n="wrapper";function Q8n(t){let{components:n,...e}=t;return(0,s.kt)(Y8n,(0,p.Z)({},j8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Q8n.isMDXComponent=!0;const H8n={toc:[]},$8n="wrapper";function K8n(t){let{components:n,...e}=t;return(0,s.kt)($8n,(0,p.Z)({},H8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}K8n.isMDXComponent=!0;const J8n={toc:[]},t7n="wrapper";function n7n(t){let{components:n,...e}=t;return(0,s.kt)(t7n,(0,p.Z)({},J8n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}n7n.isMDXComponent=!0;const e7n={toc:[]},o7n="wrapper";function p7n(t){let{components:n,...e}=t;return(0,s.kt)(o7n,(0,p.Z)({},e7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}p7n.isMDXComponent=!0;const r7n={toc:[]},s7n="wrapper";function c7n(t){let{components:n,...e}=t;return(0,s.kt)(s7n,(0,p.Z)({},r7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}c7n.isMDXComponent=!0;const i7n={toc:[]},a7n="wrapper";function l7n(t){let{components:n,...e}=t;return(0,s.kt)(a7n,(0,p.Z)({},i7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}l7n.isMDXComponent=!0;const u7n={toc:[]},m7n="wrapper";function d7n(t){let{components:n,...e}=t;return(0,s.kt)(m7n,(0,p.Z)({},u7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}d7n.isMDXComponent=!0;const h7n={toc:[]},k7n="wrapper";function f7n(t){let{components:n,...e}=t;return(0,s.kt)(k7n,(0,p.Z)({},h7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}f7n.isMDXComponent=!0;const y7n={toc:[]},M7n="wrapper";function D7n(t){let{components:n,...e}=t;return(0,s.kt)(M7n,(0,p.Z)({},y7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}D7n.isMDXComponent=!0;const X7n={toc:[]},_7n="wrapper";function w7n(t){let{components:n,...e}=t;return(0,s.kt)(_7n,(0,p.Z)({},X7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}w7n.isMDXComponent=!0;const T7n={toc:[]},C7n="wrapper";function g7n(t){let{components:n,...e}=t;return(0,s.kt)(C7n,(0,p.Z)({},T7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}g7n.isMDXComponent=!0;const x7n={toc:[]},v7n="wrapper";function L7n(t){let{components:n,...e}=t;return(0,s.kt)(v7n,(0,p.Z)({},x7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}L7n.isMDXComponent=!0;const Z7n={toc:[]},b7n="wrapper";function N7n(t){let{components:n,...e}=t;return(0,s.kt)(b7n,(0,p.Z)({},Z7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}N7n.isMDXComponent=!0;const A7n={toc:[]},z7n="wrapper";function W7n(t){let{components:n,...e}=t;return(0,s.kt)(z7n,(0,p.Z)({},A7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}W7n.isMDXComponent=!0;const I7n={toc:[]},R7n="wrapper";function P7n(t){let{components:n,...e}=t;return(0,s.kt)(R7n,(0,p.Z)({},I7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}P7n.isMDXComponent=!0;const S7n={toc:[]},E7n="wrapper";function G7n(t){let{components:n,...e}=t;return(0,s.kt)(E7n,(0,p.Z)({},S7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}G7n.isMDXComponent=!0;const O7n={toc:[]},F7n="wrapper";function B7n(t){let{components:n,...e}=t;return(0,s.kt)(F7n,(0,p.Z)({},O7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}B7n.isMDXComponent=!0;const U7n={toc:[]},V7n="wrapper";function q7n(t){let{components:n,...e}=t;return(0,s.kt)(V7n,(0,p.Z)({},U7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}q7n.isMDXComponent=!0;const j7n={toc:[]},Y7n="wrapper";function Q7n(t){let{components:n,...e}=t;return(0,s.kt)(Y7n,(0,p.Z)({},j7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Q7n.isMDXComponent=!0;const H7n={toc:[]},$7n="wrapper";function K7n(t){let{components:n,...e}=t;return(0,s.kt)($7n,(0,p.Z)({},H7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}K7n.isMDXComponent=!0;const J7n={toc:[]},t9n="wrapper";function n9n(t){let{components:n,...e}=t;return(0,s.kt)(t9n,(0,p.Z)({},J7n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}n9n.isMDXComponent=!0;const e9n={toc:[]},o9n="wrapper";function p9n(t){let{components:n,...e}=t;return(0,s.kt)(o9n,(0,p.Z)({},e9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}p9n.isMDXComponent=!0;const r9n={toc:[]},s9n="wrapper";function c9n(t){let{components:n,...e}=t;return(0,s.kt)(s9n,(0,p.Z)({},r9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}c9n.isMDXComponent=!0;const i9n={toc:[]},a9n="wrapper";function l9n(t){let{components:n,...e}=t;return(0,s.kt)(a9n,(0,p.Z)({},i9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}l9n.isMDXComponent=!0;const u9n={toc:[]},m9n="wrapper";function d9n(t){let{components:n,...e}=t;return(0,s.kt)(m9n,(0,p.Z)({},u9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}d9n.isMDXComponent=!0;const h9n={toc:[]},k9n="wrapper";function f9n(t){let{components:n,...e}=t;return(0,s.kt)(k9n,(0,p.Z)({},h9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}f9n.isMDXComponent=!0;const y9n={toc:[]},M9n="wrapper";function D9n(t){let{components:n,...e}=t;return(0,s.kt)(M9n,(0,p.Z)({},y9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}D9n.isMDXComponent=!0;const X9n={toc:[]},_9n="wrapper";function w9n(t){let{components:n,...e}=t;return(0,s.kt)(_9n,(0,p.Z)({},X9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}w9n.isMDXComponent=!0;const T9n={toc:[]},C9n="wrapper";function g9n(t){let{components:n,...e}=t;return(0,s.kt)(C9n,(0,p.Z)({},T9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}g9n.isMDXComponent=!0;const x9n={toc:[]},v9n="wrapper";function L9n(t){let{components:n,...e}=t;return(0,s.kt)(v9n,(0,p.Z)({},x9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}L9n.isMDXComponent=!0;const Z9n={toc:[]},b9n="wrapper";function N9n(t){let{components:n,...e}=t;return(0,s.kt)(b9n,(0,p.Z)({},Z9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}N9n.isMDXComponent=!0;const A9n={toc:[]},z9n="wrapper";function W9n(t){let{components:n,...e}=t;return(0,s.kt)(z9n,(0,p.Z)({},A9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}W9n.isMDXComponent=!0;const I9n={toc:[]},R9n="wrapper";function P9n(t){let{components:n,...e}=t;return(0,s.kt)(R9n,(0,p.Z)({},I9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}P9n.isMDXComponent=!0;const S9n={toc:[]},E9n="wrapper";function G9n(t){let{components:n,...e}=t;return(0,s.kt)(E9n,(0,p.Z)({},S9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}G9n.isMDXComponent=!0;const O9n={toc:[]},F9n="wrapper";function B9n(t){let{components:n,...e}=t;return(0,s.kt)(F9n,(0,p.Z)({},O9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}B9n.isMDXComponent=!0;const U9n={toc:[]},V9n="wrapper";function q9n(t){let{components:n,...e}=t;return(0,s.kt)(V9n,(0,p.Z)({},U9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}q9n.isMDXComponent=!0;const j9n={toc:[]},Y9n="wrapper";function Q9n(t){let{components:n,...e}=t;return(0,s.kt)(Y9n,(0,p.Z)({},j9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Q9n.isMDXComponent=!0;const H9n={toc:[]},$9n="wrapper";function K9n(t){let{components:n,...e}=t;return(0,s.kt)($9n,(0,p.Z)({},H9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}K9n.isMDXComponent=!0;const J9n={toc:[]},tte="wrapper";function nte(t){let{components:n,...e}=t;return(0,s.kt)(tte,(0,p.Z)({},J9n,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}nte.isMDXComponent=!0;const ete={toc:[]},ote="wrapper";function pte(t){let{components:n,...e}=t;return(0,s.kt)(ote,(0,p.Z)({},ete,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}pte.isMDXComponent=!0;const rte={toc:[]},ste="wrapper";function cte(t){let{components:n,...e}=t;return(0,s.kt)(ste,(0,p.Z)({},rte,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cte.isMDXComponent=!0;const ite={toc:[]},ate="wrapper";function lte(t){let{components:n,...e}=t;return(0,s.kt)(ate,(0,p.Z)({},ite,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}lte.isMDXComponent=!0;const ute={toc:[]},mte="wrapper";function dte(t){let{components:n,...e}=t;return(0,s.kt)(mte,(0,p.Z)({},ute,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dte.isMDXComponent=!0;const hte={toc:[]},kte="wrapper";function fte(t){let{components:n,...e}=t;return(0,s.kt)(kte,(0,p.Z)({},hte,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}fte.isMDXComponent=!0;const yte={toc:[]},Mte="wrapper";function Dte(t){let{components:n,...e}=t;return(0,s.kt)(Mte,(0,p.Z)({},yte,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Dte.isMDXComponent=!0;const Xte={toc:[]},_te="wrapper";function wte(t){let{components:n,...e}=t;return(0,s.kt)(_te,(0,p.Z)({},Xte,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}wte.isMDXComponent=!0;const Tte={toc:[]},Cte="wrapper";function gte(t){let{components:n,...e}=t;return(0,s.kt)(Cte,(0,p.Z)({},Tte,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}gte.isMDXComponent=!0;const xte={toc:[]},vte="wrapper";function Lte(t){let{components:n,...e}=t;return(0,s.kt)(vte,(0,p.Z)({},xte,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Lte.isMDXComponent=!0;const Zte={toc:[]},bte="wrapper";function Nte(t){let{components:n,...e}=t;return(0,s.kt)(bte,(0,p.Z)({},Zte,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Nte.isMDXComponent=!0;const Ate={toc:[]},zte="wrapper";function Wte(t){let{components:n,...e}=t;return(0,s.kt)(zte,(0,p.Z)({},Ate,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Wte.isMDXComponent=!0;const Ite={toc:[]},Rte="wrapper";function Pte(t){let{components:n,...e}=t;return(0,s.kt)(Rte,(0,p.Z)({},Ite,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Pte.isMDXComponent=!0;const Ste={toc:[]},Ete="wrapper";function Gte(t){let{components:n,...e}=t;return(0,s.kt)(Ete,(0,p.Z)({},Ste,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Gte.isMDXComponent=!0;const Ote={toc:[]},Fte="wrapper";function Bte(t){let{components:n,...e}=t;return(0,s.kt)(Fte,(0,p.Z)({},Ote,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Bte.isMDXComponent=!0;const Ute={toc:[]},Vte="wrapper";function qte(t){let{components:n,...e}=t;return(0,s.kt)(Vte,(0,p.Z)({},Ute,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}qte.isMDXComponent=!0;const jte={toc:[]},Yte="wrapper";function Qte(t){let{components:n,...e}=t;return(0,s.kt)(Yte,(0,p.Z)({},jte,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Qte.isMDXComponent=!0;const Hte={toc:[]},$te="wrapper";function Kte(t){let{components:n,...e}=t;return(0,s.kt)($te,(0,p.Z)({},Hte,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Kte.isMDXComponent=!0;const Jte={toc:[]},tne="wrapper";function nne(t){let{components:n,...e}=t;return(0,s.kt)(tne,(0,p.Z)({},Jte,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}nne.isMDXComponent=!0;const ene={toc:[]},one="wrapper";function pne(t){let{components:n,...e}=t;return(0,s.kt)(one,(0,p.Z)({},ene,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}pne.isMDXComponent=!0;const rne={toc:[]},sne="wrapper";function cne(t){let{components:n,...e}=t;return(0,s.kt)(sne,(0,p.Z)({},rne,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}cne.isMDXComponent=!0;const ine={toc:[]},ane="wrapper";function lne(t){let{components:n,...e}=t;return(0,s.kt)(ane,(0,p.Z)({},ine,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}lne.isMDXComponent=!0;const une={toc:[]},mne="wrapper";function dne(t){let{components:n,...e}=t;return(0,s.kt)(mne,(0,p.Z)({},une,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}dne.isMDXComponent=!0;const hne={toc:[]},kne="wrapper";function fne(t){let{components:n,...e}=t;return(0,s.kt)(kne,(0,p.Z)({},hne,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}fne.isMDXComponent=!0;const yne={toc:[]},Mne="wrapper";function Dne(t){let{components:n,...e}=t;return(0,s.kt)(Mne,(0,p.Z)({},yne,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Dne.isMDXComponent=!0;const Xne={toc:[]},_ne="wrapper";function wne(t){let{components:n,...e}=t;return(0,s.kt)(_ne,(0,p.Z)({},Xne,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}wne.isMDXComponent=!0;const Tne={toc:[]},Cne="wrapper";function gne(t){let{components:n,...e}=t;return(0,s.kt)(Cne,(0,p.Z)({},Tne,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}gne.isMDXComponent=!0;const xne={toc:[]},vne="wrapper";function Lne(t){let{components:n,...e}=t;return(0,s.kt)(vne,(0,p.Z)({},xne,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Lne.isMDXComponent=!0;const Zne={toc:[]},bne="wrapper";function Nne(t){let{components:n,...e}=t;return(0,s.kt)(bne,(0,p.Z)({},Zne,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Nne.isMDXComponent=!0;const Ane={toc:[]},zne="wrapper";function Wne(t){let{components:n,...e}=t;return(0,s.kt)(zne,(0,p.Z)({},Ane,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Wne.isMDXComponent=!0;const Ine={toc:[]},Rne="wrapper";function Pne(t){let{components:n,...e}=t;return(0,s.kt)(Rne,(0,p.Z)({},Ine,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Pne.isMDXComponent=!0;const Sne={toc:[]},Ene="wrapper";function Gne(t){let{components:n,...e}=t;return(0,s.kt)(Ene,(0,p.Z)({},Sne,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Gne.isMDXComponent=!0;const One={toc:[]},Fne="wrapper";function Bne(t){let{components:n,...e}=t;return(0,s.kt)(Fne,(0,p.Z)({},One,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Bne.isMDXComponent=!0;const Une={toc:[]},Vne="wrapper";function qne(t){let{components:n,...e}=t;return(0,s.kt)(Vne,(0,p.Z)({},Une,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}qne.isMDXComponent=!0;const jne={toc:[]},Yne="wrapper";function Qne(t){let{components:n,...e}=t;return(0,s.kt)(Yne,(0,p.Z)({},jne,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Qne.isMDXComponent=!0;const Hne={toc:[]},$ne="wrapper";function Kne(t){let{components:n,...e}=t;return(0,s.kt)($ne,(0,p.Z)({},Hne,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Kne.isMDXComponent=!0;const Jne={toc:[]},tee="wrapper";function nee(t){let{components:n,...e}=t;return(0,s.kt)(tee,(0,p.Z)({},Jne,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}nee.isMDXComponent=!0;const eee={toc:[]},oee="wrapper";function pee(t){let{components:n,...e}=t;return(0,s.kt)(oee,(0,p.Z)({},eee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}pee.isMDXComponent=!0;const ree={toc:[]},see="wrapper";function cee(t){let{components:n,...e}=t;return(0,s.kt)(see,(0,p.Z)({},ree,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}cee.isMDXComponent=!0;const iee={toc:[]},aee="wrapper";function lee(t){let{components:n,...e}=t;return(0,s.kt)(aee,(0,p.Z)({},iee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}lee.isMDXComponent=!0;const uee={toc:[]},mee="wrapper";function dee(t){let{components:n,...e}=t;return(0,s.kt)(mee,(0,p.Z)({},uee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}dee.isMDXComponent=!0;const hee={toc:[]},kee="wrapper";function fee(t){let{components:n,...e}=t;return(0,s.kt)(kee,(0,p.Z)({},hee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}fee.isMDXComponent=!0;const yee={toc:[]},Mee="wrapper";function Dee(t){let{components:n,...e}=t;return(0,s.kt)(Mee,(0,p.Z)({},yee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Dee.isMDXComponent=!0;const Xee={toc:[]},_ee="wrapper";function wee(t){let{components:n,...e}=t;return(0,s.kt)(_ee,(0,p.Z)({},Xee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wee.isMDXComponent=!0;const Tee={toc:[]},Cee="wrapper";function gee(t){let{components:n,...e}=t;return(0,s.kt)(Cee,(0,p.Z)({},Tee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}gee.isMDXComponent=!0;const xee={toc:[]},vee="wrapper";function Lee(t){let{components:n,...e}=t;return(0,s.kt)(vee,(0,p.Z)({},xee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Lee.isMDXComponent=!0;const Zee={toc:[]},bee="wrapper";function Nee(t){let{components:n,...e}=t;return(0,s.kt)(bee,(0,p.Z)({},Zee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Nee.isMDXComponent=!0;const Aee={toc:[]},zee="wrapper";function Wee(t){let{components:n,...e}=t;return(0,s.kt)(zee,(0,p.Z)({},Aee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Wee.isMDXComponent=!0;const Iee={toc:[]},Ree="wrapper";function Pee(t){let{components:n,...e}=t;return(0,s.kt)(Ree,(0,p.Z)({},Iee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Pee.isMDXComponent=!0;const See={toc:[]},Eee="wrapper";function Gee(t){let{components:n,...e}=t;return(0,s.kt)(Eee,(0,p.Z)({},See,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Gee.isMDXComponent=!0;const Oee={toc:[]},Fee="wrapper";function Bee(t){let{components:n,...e}=t;return(0,s.kt)(Fee,(0,p.Z)({},Oee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Bee.isMDXComponent=!0;const Uee={toc:[]},Vee="wrapper";function qee(t){let{components:n,...e}=t;return(0,s.kt)(Vee,(0,p.Z)({},Uee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}qee.isMDXComponent=!0;const jee={toc:[]},Yee="wrapper";function Qee(t){let{components:n,...e}=t;return(0,s.kt)(Yee,(0,p.Z)({},jee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Qee.isMDXComponent=!0;const Hee={toc:[]},$ee="wrapper";function Kee(t){let{components:n,...e}=t;return(0,s.kt)($ee,(0,p.Z)({},Hee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Kee.isMDXComponent=!0;const Jee={toc:[]},toe="wrapper";function noe(t){let{components:n,...e}=t;return(0,s.kt)(toe,(0,p.Z)({},Jee,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}noe.isMDXComponent=!0;const eoe={toc:[]},ooe="wrapper";function poe(t){let{components:n,...e}=t;return(0,s.kt)(ooe,(0,p.Z)({},eoe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}poe.isMDXComponent=!0;const roe={toc:[]},soe="wrapper";function coe(t){let{components:n,...e}=t;return(0,s.kt)(soe,(0,p.Z)({},roe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}coe.isMDXComponent=!0;const ioe={toc:[]},aoe="wrapper";function loe(t){let{components:n,...e}=t;return(0,s.kt)(aoe,(0,p.Z)({},ioe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}loe.isMDXComponent=!0;const uoe={toc:[]},moe="wrapper";function doe(t){let{components:n,...e}=t;return(0,s.kt)(moe,(0,p.Z)({},uoe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}doe.isMDXComponent=!0;const hoe={toc:[]},koe="wrapper";function foe(t){let{components:n,...e}=t;return(0,s.kt)(koe,(0,p.Z)({},hoe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}foe.isMDXComponent=!0;const yoe={toc:[]},Moe="wrapper";function Doe(t){let{components:n,...e}=t;return(0,s.kt)(Moe,(0,p.Z)({},yoe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Doe.isMDXComponent=!0;const Xoe={toc:[]},_oe="wrapper";function woe(t){let{components:n,...e}=t;return(0,s.kt)(_oe,(0,p.Z)({},Xoe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}woe.isMDXComponent=!0;const Toe={toc:[]},Coe="wrapper";function goe(t){let{components:n,...e}=t;return(0,s.kt)(Coe,(0,p.Z)({},Toe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}goe.isMDXComponent=!0;const xoe={toc:[]},voe="wrapper";function Loe(t){let{components:n,...e}=t;return(0,s.kt)(voe,(0,p.Z)({},xoe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Loe.isMDXComponent=!0;const Zoe={toc:[]},boe="wrapper";function Noe(t){let{components:n,...e}=t;return(0,s.kt)(boe,(0,p.Z)({},Zoe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Noe.isMDXComponent=!0;const Aoe={toc:[]},zoe="wrapper";function Woe(t){let{components:n,...e}=t;return(0,s.kt)(zoe,(0,p.Z)({},Aoe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Woe.isMDXComponent=!0;const Ioe={toc:[]},Roe="wrapper";function Poe(t){let{components:n,...e}=t;return(0,s.kt)(Roe,(0,p.Z)({},Ioe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Poe.isMDXComponent=!0;const Soe={toc:[]},Eoe="wrapper";function Goe(t){let{components:n,...e}=t;return(0,s.kt)(Eoe,(0,p.Z)({},Soe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Goe.isMDXComponent=!0;const Ooe={toc:[]},Foe="wrapper";function Boe(t){let{components:n,...e}=t;return(0,s.kt)(Foe,(0,p.Z)({},Ooe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Boe.isMDXComponent=!0;const Uoe={toc:[]},Voe="wrapper";function qoe(t){let{components:n,...e}=t;return(0,s.kt)(Voe,(0,p.Z)({},Uoe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}qoe.isMDXComponent=!0;const joe={toc:[]},Yoe="wrapper";function Qoe(t){let{components:n,...e}=t;return(0,s.kt)(Yoe,(0,p.Z)({},joe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Qoe.isMDXComponent=!0;const Hoe={toc:[]},$oe="wrapper";function Koe(t){let{components:n,...e}=t;return(0,s.kt)($oe,(0,p.Z)({},Hoe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Koe.isMDXComponent=!0;const Joe={toc:[]},tpe="wrapper";function npe(t){let{components:n,...e}=t;return(0,s.kt)(tpe,(0,p.Z)({},Joe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}npe.isMDXComponent=!0;const epe={toc:[]},ope="wrapper";function ppe(t){let{components:n,...e}=t;return(0,s.kt)(ope,(0,p.Z)({},epe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ppe.isMDXComponent=!0;const rpe={toc:[]},spe="wrapper";function cpe(t){let{components:n,...e}=t;return(0,s.kt)(spe,(0,p.Z)({},rpe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}cpe.isMDXComponent=!0;const ipe={toc:[]},ape="wrapper";function lpe(t){let{components:n,...e}=t;return(0,s.kt)(ape,(0,p.Z)({},ipe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}lpe.isMDXComponent=!0;const upe={toc:[]},mpe="wrapper";function dpe(t){let{components:n,...e}=t;return(0,s.kt)(mpe,(0,p.Z)({},upe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}dpe.isMDXComponent=!0;const hpe={toc:[]},kpe="wrapper";function fpe(t){let{components:n,...e}=t;return(0,s.kt)(kpe,(0,p.Z)({},hpe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}fpe.isMDXComponent=!0;const ype={toc:[]},Mpe="wrapper";function Dpe(t){let{components:n,...e}=t;return(0,s.kt)(Mpe,(0,p.Z)({},ype,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Dpe.isMDXComponent=!0;const Xpe={toc:[]},_pe="wrapper";function wpe(t){let{components:n,...e}=t;return(0,s.kt)(_pe,(0,p.Z)({},Xpe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}wpe.isMDXComponent=!0;const Tpe={toc:[]},Cpe="wrapper";function gpe(t){let{components:n,...e}=t;return(0,s.kt)(Cpe,(0,p.Z)({},Tpe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}gpe.isMDXComponent=!0;const xpe={toc:[]},vpe="wrapper";function Lpe(t){let{components:n,...e}=t;return(0,s.kt)(vpe,(0,p.Z)({},xpe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Lpe.isMDXComponent=!0;const Zpe={toc:[]},bpe="wrapper";function Npe(t){let{components:n,...e}=t;return(0,s.kt)(bpe,(0,p.Z)({},Zpe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Npe.isMDXComponent=!0;const Ape={toc:[]},zpe="wrapper";function Wpe(t){let{components:n,...e}=t;return(0,s.kt)(zpe,(0,p.Z)({},Ape,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Wpe.isMDXComponent=!0;const Ipe={toc:[]},Rpe="wrapper";function Ppe(t){let{components:n,...e}=t;return(0,s.kt)(Rpe,(0,p.Z)({},Ipe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Ppe.isMDXComponent=!0;const Spe={toc:[]},Epe="wrapper";function Gpe(t){let{components:n,...e}=t;return(0,s.kt)(Epe,(0,p.Z)({},Spe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Gpe.isMDXComponent=!0;const Ope={toc:[]},Fpe="wrapper";function Bpe(t){let{components:n,...e}=t;return(0,s.kt)(Fpe,(0,p.Z)({},Ope,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Bpe.isMDXComponent=!0;const Upe={toc:[]},Vpe="wrapper";function qpe(t){let{components:n,...e}=t;return(0,s.kt)(Vpe,(0,p.Z)({},Upe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}qpe.isMDXComponent=!0;const jpe={toc:[]},Ype="wrapper";function Qpe(t){let{components:n,...e}=t;return(0,s.kt)(Ype,(0,p.Z)({},jpe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Qpe.isMDXComponent=!0;const Hpe={toc:[]},$pe="wrapper";function Kpe(t){let{components:n,...e}=t;return(0,s.kt)($pe,(0,p.Z)({},Hpe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Kpe.isMDXComponent=!0;const Jpe={toc:[]},tre="wrapper";function nre(t){let{components:n,...e}=t;return(0,s.kt)(tre,(0,p.Z)({},Jpe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}nre.isMDXComponent=!0;const ere={toc:[]},ore="wrapper";function pre(t){let{components:n,...e}=t;return(0,s.kt)(ore,(0,p.Z)({},ere,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}pre.isMDXComponent=!0;const rre={toc:[]},sre="wrapper";function cre(t){let{components:n,...e}=t;return(0,s.kt)(sre,(0,p.Z)({},rre,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}cre.isMDXComponent=!0;const ire={toc:[]},are="wrapper";function lre(t){let{components:n,...e}=t;return(0,s.kt)(are,(0,p.Z)({},ire,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}lre.isMDXComponent=!0;const ure={toc:[]},mre="wrapper";function dre(t){let{components:n,...e}=t;return(0,s.kt)(mre,(0,p.Z)({},ure,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}dre.isMDXComponent=!0;const hre={toc:[]},kre="wrapper";function fre(t){let{components:n,...e}=t;return(0,s.kt)(kre,(0,p.Z)({},hre,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}fre.isMDXComponent=!0;const yre={toc:[]},Mre="wrapper";function Dre(t){let{components:n,...e}=t;return(0,s.kt)(Mre,(0,p.Z)({},yre,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Dre.isMDXComponent=!0;const Xre={toc:[]},_re="wrapper";function wre(t){let{components:n,...e}=t;return(0,s.kt)(_re,(0,p.Z)({},Xre,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}wre.isMDXComponent=!0;const Tre={toc:[]},Cre="wrapper";function gre(t){let{components:n,...e}=t;return(0,s.kt)(Cre,(0,p.Z)({},Tre,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}gre.isMDXComponent=!0;const xre={toc:[]},vre="wrapper";function Lre(t){let{components:n,...e}=t;return(0,s.kt)(vre,(0,p.Z)({},xre,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Lre.isMDXComponent=!0;const Zre={toc:[]},bre="wrapper";function Nre(t){let{components:n,...e}=t;return(0,s.kt)(bre,(0,p.Z)({},Zre,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Nre.isMDXComponent=!0;const Are={toc:[]},zre="wrapper";function Wre(t){let{components:n,...e}=t;return(0,s.kt)(zre,(0,p.Z)({},Are,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Wre.isMDXComponent=!0;const Ire={toc:[]},Rre="wrapper";function Pre(t){let{components:n,...e}=t;return(0,s.kt)(Rre,(0,p.Z)({},Ire,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Pre.isMDXComponent=!0;const Sre={toc:[]},Ere="wrapper";function Gre(t){let{components:n,...e}=t;return(0,s.kt)(Ere,(0,p.Z)({},Sre,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Gre.isMDXComponent=!0;const Ore={toc:[]},Fre="wrapper";function Bre(t){let{components:n,...e}=t;return(0,s.kt)(Fre,(0,p.Z)({},Ore,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Bre.isMDXComponent=!0;const Ure={toc:[]},Vre="wrapper";function qre(t){let{components:n,...e}=t;return(0,s.kt)(Vre,(0,p.Z)({},Ure,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}qre.isMDXComponent=!0;const jre={toc:[]},Yre="wrapper";function Qre(t){let{components:n,...e}=t;return(0,s.kt)(Yre,(0,p.Z)({},jre,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Qre.isMDXComponent=!0;const Hre={toc:[]},$re="wrapper";function Kre(t){let{components:n,...e}=t;return(0,s.kt)($re,(0,p.Z)({},Hre,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Kre.isMDXComponent=!0;const Jre={toc:[]},tse="wrapper";function nse(t){let{components:n,...e}=t;return(0,s.kt)(tse,(0,p.Z)({},Jre,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}nse.isMDXComponent=!0;const ese={toc:[]},ose="wrapper";function pse(t){let{components:n,...e}=t;return(0,s.kt)(ose,(0,p.Z)({},ese,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}pse.isMDXComponent=!0;const rse={toc:[]},sse="wrapper";function cse(t){let{components:n,...e}=t;return(0,s.kt)(sse,(0,p.Z)({},rse,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}cse.isMDXComponent=!0;const ise={toc:[]},ase="wrapper";function lse(t){let{components:n,...e}=t;return(0,s.kt)(ase,(0,p.Z)({},ise,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticeable if the number of sides is low, e.g. for a\ntriangle."))}lse.isMDXComponent=!0;const use={toc:[]},mse="wrapper";function dse(t){let{components:n,...e}=t;return(0,s.kt)(mse,(0,p.Z)({},use,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}dse.isMDXComponent=!0;const hse={toc:[]},kse="wrapper";function fse(t){let{components:n,...e}=t;return(0,s.kt)(kse,(0,p.Z)({},hse,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing regular polygons."))}fse.isMDXComponent=!0;const yse={toc:[]},Mse="wrapper";function Dse(t){let{components:n,...e}=t;return(0,s.kt)(Mse,(0,p.Z)({},yse,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Dse.isMDXComponent=!0;const Xse={toc:[]},_se="wrapper";function wse(t){let{components:n,...e}=t;return(0,s.kt)(_se,(0,p.Z)({},Xse,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}wse.isMDXComponent=!0;const Tse={toc:[]},Cse="wrapper";function gse(t){let{components:n,...e}=t;return(0,s.kt)(Cse,(0,p.Z)({},Tse,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}gse.isMDXComponent=!0;const xse={toc:[]},vse="wrapper";function Lse(t){let{components:n,...e}=t;return(0,s.kt)(vse,(0,p.Z)({},xse,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Lse.isMDXComponent=!0;const Zse={toc:[]},bse="wrapper";function Nse(t){let{components:n,...e}=t;return(0,s.kt)(bse,(0,p.Z)({},Zse,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Nse.isMDXComponent=!0;const Ase={toc:[]},zse="wrapper";function Wse(t){let{components:n,...e}=t;return(0,s.kt)(zse,(0,p.Z)({},Ase,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Wse.isMDXComponent=!0;const Ise={toc:[]},Rse="wrapper";function Pse(t){let{components:n,...e}=t;return(0,s.kt)(Rse,(0,p.Z)({},Ise,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Pse.isMDXComponent=!0;const Sse={toc:[]},Ese="wrapper";function Gse(t){let{components:n,...e}=t;return(0,s.kt)(Ese,(0,p.Z)({},Sse,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Gse.isMDXComponent=!0;const Ose={toc:[]},Fse="wrapper";function Bse(t){let{components:n,...e}=t;return(0,s.kt)(Fse,(0,p.Z)({},Ose,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Bse.isMDXComponent=!0;const Use={toc:[]},Vse="wrapper";function qse(t){let{components:n,...e}=t;return(0,s.kt)(Vse,(0,p.Z)({},Use,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}qse.isMDXComponent=!0;const jse={toc:[]},Yse="wrapper";function Qse(t){let{components:n,...e}=t;return(0,s.kt)(Yse,(0,p.Z)({},jse,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Qse.isMDXComponent=!0;const Hse={toc:[]},$se="wrapper";function Kse(t){let{components:n,...e}=t;return(0,s.kt)($se,(0,p.Z)({},Hse,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Kse.isMDXComponent=!0;const Jse={toc:[]},tce="wrapper";function nce(t){let{components:n,...e}=t;return(0,s.kt)(tce,(0,p.Z)({},Jse,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}nce.isMDXComponent=!0;const ece={toc:[]},oce="wrapper";function pce(t){let{components:n,...e}=t;return(0,s.kt)(oce,(0,p.Z)({},ece,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}pce.isMDXComponent=!0;const rce={toc:[]},sce="wrapper";function cce(t){let{components:n,...e}=t;return(0,s.kt)(sce,(0,p.Z)({},rce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}cce.isMDXComponent=!0;const ice={toc:[]},ace="wrapper";function lce(t){let{components:n,...e}=t;return(0,s.kt)(ace,(0,p.Z)({},ice,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}lce.isMDXComponent=!0;const uce={toc:[]},mce="wrapper";function dce(t){let{components:n,...e}=t;return(0,s.kt)(mce,(0,p.Z)({},uce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}dce.isMDXComponent=!0;const hce={toc:[]},kce="wrapper";function fce(t){let{components:n,...e}=t;return(0,s.kt)(kce,(0,p.Z)({},hce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}fce.isMDXComponent=!0;const yce={toc:[]},Mce="wrapper";function Dce(t){let{components:n,...e}=t;return(0,s.kt)(Mce,(0,p.Z)({},yce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Dce.isMDXComponent=!0;const Xce={toc:[]},_ce="wrapper";function wce(t){let{components:n,...e}=t;return(0,s.kt)(_ce,(0,p.Z)({},Xce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}wce.isMDXComponent=!0;const Tce={toc:[]},Cce="wrapper";function gce(t){let{components:n,...e}=t;return(0,s.kt)(Cce,(0,p.Z)({},Tce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}gce.isMDXComponent=!0;const xce={toc:[]},vce="wrapper";function Lce(t){let{components:n,...e}=t;return(0,s.kt)(vce,(0,p.Z)({},xce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Lce.isMDXComponent=!0;const Zce={toc:[]},bce="wrapper";function Nce(t){let{components:n,...e}=t;return(0,s.kt)(bce,(0,p.Z)({},Zce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Nce.isMDXComponent=!0;const Ace={toc:[]},zce="wrapper";function Wce(t){let{components:n,...e}=t;return(0,s.kt)(zce,(0,p.Z)({},Ace,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Wce.isMDXComponent=!0;const Ice={toc:[]},Rce="wrapper";function Pce(t){let{components:n,...e}=t;return(0,s.kt)(Rce,(0,p.Z)({},Ice,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Pce.isMDXComponent=!0;const Sce={toc:[]},Ece="wrapper";function Gce(t){let{components:n,...e}=t;return(0,s.kt)(Ece,(0,p.Z)({},Sce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Gce.isMDXComponent=!0;const Oce={toc:[]},Fce="wrapper";function Bce(t){let{components:n,...e}=t;return(0,s.kt)(Fce,(0,p.Z)({},Oce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Bce.isMDXComponent=!0;const Uce={toc:[]},Vce="wrapper";function qce(t){let{components:n,...e}=t;return(0,s.kt)(Vce,(0,p.Z)({},Uce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}qce.isMDXComponent=!0;const jce={toc:[]},Yce="wrapper";function Qce(t){let{components:n,...e}=t;return(0,s.kt)(Yce,(0,p.Z)({},jce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}Qce.isMDXComponent=!0;const Hce={toc:[]},$ce="wrapper";function Kce(t){let{components:n,...e}=t;return(0,s.kt)($ce,(0,p.Z)({},Hce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}Kce.isMDXComponent=!0;const Jce={toc:[]},tie="wrapper";function nie(t){let{components:n,...e}=t;return(0,s.kt)(tie,(0,p.Z)({},Jce,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}nie.isMDXComponent=!0;const eie={toc:[]},oie="wrapper";function pie(t){let{components:n,...e}=t;return(0,s.kt)(oie,(0,p.Z)({},eie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}pie.isMDXComponent=!0;const rie={toc:[]},sie="wrapper";function cie(t){let{components:n,...e}=t;return(0,s.kt)(sie,(0,p.Z)({},rie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}cie.isMDXComponent=!0;const iie={toc:[]},aie="wrapper";function lie(t){let{components:n,...e}=t;return(0,s.kt)(aie,(0,p.Z)({},iie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}lie.isMDXComponent=!0;const uie={toc:[]},mie="wrapper";function die(t){let{components:n,...e}=t;return(0,s.kt)(mie,(0,p.Z)({},uie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}die.isMDXComponent=!0;const hie={toc:[]},kie="wrapper";function fie(t){let{components:n,...e}=t;return(0,s.kt)(kie,(0,p.Z)({},hie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}fie.isMDXComponent=!0;const yie={toc:[]},Mie="wrapper";function Die(t){let{components:n,...e}=t;return(0,s.kt)(Mie,(0,p.Z)({},yie,e,{components:n,mdxType:"MDXLayout"}))}Die.isMDXComponent=!0;const Xie={toc:[]},_ie="wrapper";function wie(t){let{components:n,...e}=t;return(0,s.kt)(_ie,(0,p.Z)({},Xie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}wie.isMDXComponent=!0;const Tie={toc:[]},Cie="wrapper";function gie(t){let{components:n,...e}=t;return(0,s.kt)(Cie,(0,p.Z)({},Tie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}gie.isMDXComponent=!0;const xie={toc:[]},vie="wrapper";function Lie(t){let{components:n,...e}=t;return(0,s.kt)(vie,(0,p.Z)({},xie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Lie.isMDXComponent=!0;const Zie={toc:[]},bie="wrapper";function Nie(t){let{components:n,...e}=t;return(0,s.kt)(bie,(0,p.Z)({},Zie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Nie.isMDXComponent=!0;const Aie={toc:[]},zie="wrapper";function Wie(t){let{components:n,...e}=t;return(0,s.kt)(zie,(0,p.Z)({},Aie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Wie.isMDXComponent=!0;const Iie={toc:[]},Rie="wrapper";function Pie(t){let{components:n,...e}=t;return(0,s.kt)(Rie,(0,p.Z)({},Iie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Pie.isMDXComponent=!0;const Sie={toc:[]},Eie="wrapper";function Gie(t){let{components:n,...e}=t;return(0,s.kt)(Eie,(0,p.Z)({},Sie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Gie.isMDXComponent=!0;const Oie={toc:[]},Fie="wrapper";function Bie(t){let{components:n,...e}=t;return(0,s.kt)(Fie,(0,p.Z)({},Oie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Bie.isMDXComponent=!0;const Uie={toc:[]},Vie="wrapper";function qie(t){let{components:n,...e}=t;return(0,s.kt)(Vie,(0,p.Z)({},Uie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}qie.isMDXComponent=!0;const jie={toc:[]},Yie="wrapper";function Qie(t){let{components:n,...e}=t;return(0,s.kt)(Yie,(0,p.Z)({},jie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Qie.isMDXComponent=!0;const Hie={toc:[]},$ie="wrapper";function Kie(t){let{components:n,...e}=t;return(0,s.kt)($ie,(0,p.Z)({},Hie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Kie.isMDXComponent=!0;const Jie={toc:[]},tae="wrapper";function nae(t){let{components:n,...e}=t;return(0,s.kt)(tae,(0,p.Z)({},Jie,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}nae.isMDXComponent=!0;const eae={toc:[]},oae="wrapper";function pae(t){let{components:n,...e}=t;return(0,s.kt)(oae,(0,p.Z)({},eae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}pae.isMDXComponent=!0;const rae={toc:[]},sae="wrapper";function cae(t){let{components:n,...e}=t;return(0,s.kt)(sae,(0,p.Z)({},rae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}cae.isMDXComponent=!0;const iae={toc:[]},aae="wrapper";function lae(t){let{components:n,...e}=t;return(0,s.kt)(aae,(0,p.Z)({},iae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}lae.isMDXComponent=!0;const uae={toc:[]},mae="wrapper";function dae(t){let{components:n,...e}=t;return(0,s.kt)(mae,(0,p.Z)({},uae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}dae.isMDXComponent=!0;const hae={toc:[]},kae="wrapper";function fae(t){let{components:n,...e}=t;return(0,s.kt)(kae,(0,p.Z)({},hae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}fae.isMDXComponent=!0;const yae={toc:[]},Mae="wrapper";function Dae(t){let{components:n,...e}=t;return(0,s.kt)(Mae,(0,p.Z)({},yae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Dae.isMDXComponent=!0;const Xae={toc:[]},_ae="wrapper";function wae(t){let{components:n,...e}=t;return(0,s.kt)(_ae,(0,p.Z)({},Xae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}wae.isMDXComponent=!0;const Tae={toc:[]},Cae="wrapper";function gae(t){let{components:n,...e}=t;return(0,s.kt)(Cae,(0,p.Z)({},Tae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}gae.isMDXComponent=!0;const xae={toc:[]},vae="wrapper";function Lae(t){let{components:n,...e}=t;return(0,s.kt)(vae,(0,p.Z)({},xae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Lae.isMDXComponent=!0;const Zae={toc:[]},bae="wrapper";function Nae(t){let{components:n,...e}=t;return(0,s.kt)(bae,(0,p.Z)({},Zae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Nae.isMDXComponent=!0;const Aae={toc:[]},zae="wrapper";function Wae(t){let{components:n,...e}=t;return(0,s.kt)(zae,(0,p.Z)({},Aae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Wae.isMDXComponent=!0;const Iae={toc:[]},Rae="wrapper";function Pae(t){let{components:n,...e}=t;return(0,s.kt)(Rae,(0,p.Z)({},Iae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Pae.isMDXComponent=!0;const Sae={toc:[]},Eae="wrapper";function Gae(t){let{components:n,...e}=t;return(0,s.kt)(Eae,(0,p.Z)({},Sae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Gae.isMDXComponent=!0;const Oae={toc:[]},Fae="wrapper";function Bae(t){let{components:n,...e}=t;return(0,s.kt)(Fae,(0,p.Z)({},Oae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Bae.isMDXComponent=!0;const Uae={toc:[]},Vae="wrapper";function qae(t){let{components:n,...e}=t;return(0,s.kt)(Vae,(0,p.Z)({},Uae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}qae.isMDXComponent=!0;const jae={toc:[]},Yae="wrapper";function Qae(t){let{components:n,...e}=t;return(0,s.kt)(Yae,(0,p.Z)({},jae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Qae.isMDXComponent=!0;const Hae={toc:[]},$ae="wrapper";function Kae(t){let{components:n,...e}=t;return(0,s.kt)($ae,(0,p.Z)({},Hae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Kae.isMDXComponent=!0;const Jae={toc:[]},tle="wrapper";function nle(t){let{components:n,...e}=t;return(0,s.kt)(tle,(0,p.Z)({},Jae,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}nle.isMDXComponent=!0;const ele={toc:[]},ole="wrapper";function ple(t){let{components:n,...e}=t;return(0,s.kt)(ole,(0,p.Z)({},ele,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ple.isMDXComponent=!0;const rle={toc:[]},sle="wrapper";function cle(t){let{components:n,...e}=t;return(0,s.kt)(sle,(0,p.Z)({},rle,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}cle.isMDXComponent=!0;const ile={toc:[]},ale="wrapper";function lle(t){let{components:n,...e}=t;return(0,s.kt)(ale,(0,p.Z)({},ile,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lle.isMDXComponent=!0;const ule={toc:[]},mle="wrapper";function dle(t){let{components:n,...e}=t;return(0,s.kt)(mle,(0,p.Z)({},ule,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dle.isMDXComponent=!0;const hle={toc:[]},kle="wrapper";function fle(t){let{components:n,...e}=t;return(0,s.kt)(kle,(0,p.Z)({},hle,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}fle.isMDXComponent=!0;const yle={toc:[]},Mle="wrapper";function Dle(t){let{components:n,...e}=t;return(0,s.kt)(Mle,(0,p.Z)({},yle,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Dle.isMDXComponent=!0;const Xle={toc:[]},_le="wrapper";function wle(t){let{components:n,...e}=t;return(0,s.kt)(_le,(0,p.Z)({},Xle,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}wle.isMDXComponent=!0;const Tle={toc:[]},Cle="wrapper";function gle(t){let{components:n,...e}=t;return(0,s.kt)(Cle,(0,p.Z)({},Tle,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}gle.isMDXComponent=!0;const xle={toc:[]},vle="wrapper";function Lle(t){let{components:n,...e}=t;return(0,s.kt)(vle,(0,p.Z)({},xle,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lle.isMDXComponent=!0;const Zle={toc:[]},ble="wrapper";function Nle(t){let{components:n,...e}=t;return(0,s.kt)(ble,(0,p.Z)({},Zle,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Nle.isMDXComponent=!0;const Ale={toc:[]},zle="wrapper";function Wle(t){let{components:n,...e}=t;return(0,s.kt)(zle,(0,p.Z)({},Ale,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Wle.isMDXComponent=!0;const Ile={toc:[]},Rle="wrapper";function Ple(t){let{components:n,...e}=t;return(0,s.kt)(Rle,(0,p.Z)({},Ile,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Ple.isMDXComponent=!0;const Sle={toc:[]},Ele="wrapper";function Gle(t){let{components:n,...e}=t;return(0,s.kt)(Ele,(0,p.Z)({},Sle,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Gle.isMDXComponent=!0;const Ole={toc:[]},Fle="wrapper";function Ble(t){let{components:n,...e}=t;return(0,s.kt)(Fle,(0,p.Z)({},Ole,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Ble.isMDXComponent=!0;const Ule={toc:[]},Vle="wrapper";function qle(t){let{components:n,...e}=t;return(0,s.kt)(Vle,(0,p.Z)({},Ule,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qle.isMDXComponent=!0;const jle={toc:[]},Yle="wrapper";function Qle(t){let{components:n,...e}=t;return(0,s.kt)(Yle,(0,p.Z)({},jle,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Qle.isMDXComponent=!0;const Hle={toc:[]},$le="wrapper";function Kle(t){let{components:n,...e}=t;return(0,s.kt)($le,(0,p.Z)({},Hle,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Kle.isMDXComponent=!0;const Jle={toc:[]},tue="wrapper";function nue(t){let{components:n,...e}=t;return(0,s.kt)(tue,(0,p.Z)({},Jle,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}nue.isMDXComponent=!0;const eue={toc:[]},oue="wrapper";function pue(t){let{components:n,...e}=t;return(0,s.kt)(oue,(0,p.Z)({},eue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pue.isMDXComponent=!0;const rue={toc:[]},sue="wrapper";function cue(t){let{components:n,...e}=t;return(0,s.kt)(sue,(0,p.Z)({},rue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}cue.isMDXComponent=!0;const iue={toc:[]},aue="wrapper";function lue(t){let{components:n,...e}=t;return(0,s.kt)(aue,(0,p.Z)({},iue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lue.isMDXComponent=!0;const uue={toc:[]},mue="wrapper";function due(t){let{components:n,...e}=t;return(0,s.kt)(mue,(0,p.Z)({},uue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}due.isMDXComponent=!0;const hue={toc:[]},kue="wrapper";function fue(t){let{components:n,...e}=t;return(0,s.kt)(kue,(0,p.Z)({},hue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}fue.isMDXComponent=!0;const yue={toc:[]},Mue="wrapper";function Due(t){let{components:n,...e}=t;return(0,s.kt)(Mue,(0,p.Z)({},yue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Due.isMDXComponent=!0;const Xue={toc:[]},_ue="wrapper";function wue(t){let{components:n,...e}=t;return(0,s.kt)(_ue,(0,p.Z)({},Xue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wue.isMDXComponent=!0;const Tue={toc:[]},Cue="wrapper";function gue(t){let{components:n,...e}=t;return(0,s.kt)(Cue,(0,p.Z)({},Tue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}gue.isMDXComponent=!0;const xue={toc:[]},vue="wrapper";function Lue(t){let{components:n,...e}=t;return(0,s.kt)(vue,(0,p.Z)({},xue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Lue.isMDXComponent=!0;const Zue={toc:[]},bue="wrapper";function Nue(t){let{components:n,...e}=t;return(0,s.kt)(bue,(0,p.Z)({},Zue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Nue.isMDXComponent=!0;const Aue={toc:[]},zue="wrapper";function Wue(t){let{components:n,...e}=t;return(0,s.kt)(zue,(0,p.Z)({},Aue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Wue.isMDXComponent=!0;const Iue={toc:[]},Rue="wrapper";function Pue(t){let{components:n,...e}=t;return(0,s.kt)(Rue,(0,p.Z)({},Iue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Pue.isMDXComponent=!0;const Sue={toc:[]},Eue="wrapper";function Gue(t){let{components:n,...e}=t;return(0,s.kt)(Eue,(0,p.Z)({},Sue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Gue.isMDXComponent=!0;const Oue={toc:[]},Fue="wrapper";function Bue(t){let{components:n,...e}=t;return(0,s.kt)(Fue,(0,p.Z)({},Oue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Bue.isMDXComponent=!0;const Uue={toc:[]},Vue="wrapper";function que(t){let{components:n,...e}=t;return(0,s.kt)(Vue,(0,p.Z)({},Uue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}que.isMDXComponent=!0;const jue={toc:[]},Yue="wrapper";function Que(t){let{components:n,...e}=t;return(0,s.kt)(Yue,(0,p.Z)({},jue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Que.isMDXComponent=!0;const Hue={toc:[]},$ue="wrapper";function Kue(t){let{components:n,...e}=t;return(0,s.kt)($ue,(0,p.Z)({},Hue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Kue.isMDXComponent=!0;const Jue={toc:[]},tme="wrapper";function nme(t){let{components:n,...e}=t;return(0,s.kt)(tme,(0,p.Z)({},Jue,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}nme.isMDXComponent=!0;const eme={toc:[]},ome="wrapper";function pme(t){let{components:n,...e}=t;return(0,s.kt)(ome,(0,p.Z)({},eme,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}pme.isMDXComponent=!0;const rme={toc:[]},sme="wrapper";function cme(t){let{components:n,...e}=t;return(0,s.kt)(sme,(0,p.Z)({},rme,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}cme.isMDXComponent=!0;const ime={toc:[]},ame="wrapper";function lme(t){let{components:n,...e}=t;return(0,s.kt)(ame,(0,p.Z)({},ime,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}lme.isMDXComponent=!0;const ume={toc:[]},mme="wrapper";function dme(t){let{components:n,...e}=t;return(0,s.kt)(mme,(0,p.Z)({},ume,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}dme.isMDXComponent=!0;const hme={toc:[]},kme="wrapper";function fme(t){let{components:n,...e}=t;return(0,s.kt)(kme,(0,p.Z)({},hme,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}fme.isMDXComponent=!0;const yme={toc:[]},Mme="wrapper";function Dme(t){let{components:n,...e}=t;return(0,s.kt)(Mme,(0,p.Z)({},yme,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Dme.isMDXComponent=!0;const Xme={toc:[]},_me="wrapper";function wme(t){let{components:n,...e}=t;return(0,s.kt)(_me,(0,p.Z)({},Xme,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wme.isMDXComponent=!0;const Tme={toc:[]},Cme="wrapper";function gme(t){let{components:n,...e}=t;return(0,s.kt)(Cme,(0,p.Z)({},Tme,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}gme.isMDXComponent=!0;const xme={toc:[]},vme="wrapper";function Lme(t){let{components:n,...e}=t;return(0,s.kt)(vme,(0,p.Z)({},xme,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Lme.isMDXComponent=!0;const Zme={toc:[]},bme="wrapper";function Nme(t){let{components:n,...e}=t;return(0,s.kt)(bme,(0,p.Z)({},Zme,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Nme.isMDXComponent=!0;const Ame={toc:[]},zme="wrapper";function Wme(t){let{components:n,...e}=t;return(0,s.kt)(zme,(0,p.Z)({},Ame,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Wme.isMDXComponent=!0;const Ime={toc:[]},Rme="wrapper";function Pme(t){let{components:n,...e}=t;return(0,s.kt)(Rme,(0,p.Z)({},Ime,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Pme.isMDXComponent=!0;const Sme={toc:[]},Eme="wrapper";function Gme(t){let{components:n,...e}=t;return(0,s.kt)(Eme,(0,p.Z)({},Sme,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Gme.isMDXComponent=!0;const Ome={toc:[]},Fme="wrapper";function Bme(t){let{components:n,...e}=t;return(0,s.kt)(Fme,(0,p.Z)({},Ome,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Bme.isMDXComponent=!0;const Ume={toc:[]},Vme="wrapper";function qme(t){let{components:n,...e}=t;return(0,s.kt)(Vme,(0,p.Z)({},Ume,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}qme.isMDXComponent=!0;const jme={toc:[]},Yme="wrapper";function Qme(t){let{components:n,...e}=t;return(0,s.kt)(Yme,(0,p.Z)({},jme,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Qme.isMDXComponent=!0;const Hme={toc:[]},$me="wrapper";function Kme(t){let{components:n,...e}=t;return(0,s.kt)($me,(0,p.Z)({},Hme,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Kme.isMDXComponent=!0;const Jme={toc:[]},tde="wrapper";function nde(t){let{components:n,...e}=t;return(0,s.kt)(tde,(0,p.Z)({},Jme,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}nde.isMDXComponent=!0;const ede={toc:[]},ode="wrapper";function pde(t){let{components:n,...e}=t;return(0,s.kt)(ode,(0,p.Z)({},ede,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}pde.isMDXComponent=!0;const rde={toc:[]},sde="wrapper";function cde(t){let{components:n,...e}=t;return(0,s.kt)(sde,(0,p.Z)({},rde,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}cde.isMDXComponent=!0;const ide={toc:[]},ade="wrapper";function lde(t){let{components:n,...e}=t;return(0,s.kt)(ade,(0,p.Z)({},ide,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}lde.isMDXComponent=!0;const ude={toc:[]},mde="wrapper";function dde(t){let{components:n,...e}=t;return(0,s.kt)(mde,(0,p.Z)({},ude,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dde.isMDXComponent=!0;const hde={toc:[]},kde="wrapper";function fde(t){let{components:n,...e}=t;return(0,s.kt)(kde,(0,p.Z)({},hde,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}fde.isMDXComponent=!0;const yde={toc:[]},Mde="wrapper";function Dde(t){let{components:n,...e}=t;return(0,s.kt)(Mde,(0,p.Z)({},yde,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Dde.isMDXComponent=!0;const Xde={toc:[]},_de="wrapper";function wde(t){let{components:n,...e}=t;return(0,s.kt)(_de,(0,p.Z)({},Xde,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}wde.isMDXComponent=!0;const Tde={toc:[]},Cde="wrapper";function gde(t){let{components:n,...e}=t;return(0,s.kt)(Cde,(0,p.Z)({},Tde,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}gde.isMDXComponent=!0;const xde={toc:[]},vde="wrapper";function Lde(t){let{components:n,...e}=t;return(0,s.kt)(vde,(0,p.Z)({},xde,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Lde.isMDXComponent=!0;const Zde={toc:[]},bde="wrapper";function Nde(t){let{components:n,...e}=t;return(0,s.kt)(bde,(0,p.Z)({},Zde,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Nde.isMDXComponent=!0;const Ade={toc:[]},zde="wrapper";function Wde(t){let{components:n,...e}=t;return(0,s.kt)(zde,(0,p.Z)({},Ade,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Wde.isMDXComponent=!0;const Ide={toc:[]},Rde="wrapper";function Pde(t){let{components:n,...e}=t;return(0,s.kt)(Rde,(0,p.Z)({},Ide,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Pde.isMDXComponent=!0;const Sde={toc:[]},Ede="wrapper";function Gde(t){let{components:n,...e}=t;return(0,s.kt)(Ede,(0,p.Z)({},Sde,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Gde.isMDXComponent=!0;const Ode={toc:[]},Fde="wrapper";function Bde(t){let{components:n,...e}=t;return(0,s.kt)(Fde,(0,p.Z)({},Ode,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Bde.isMDXComponent=!0;const Ude={toc:[]},Vde="wrapper";function qde(t){let{components:n,...e}=t;return(0,s.kt)(Vde,(0,p.Z)({},Ude,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}qde.isMDXComponent=!0;const jde={toc:[]},Yde="wrapper";function Qde(t){let{components:n,...e}=t;return(0,s.kt)(Yde,(0,p.Z)({},jde,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Qde.isMDXComponent=!0;const Hde={toc:[]},$de="wrapper";function Kde(t){let{components:n,...e}=t;return(0,s.kt)($de,(0,p.Z)({},Hde,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Kde.isMDXComponent=!0;const Jde={toc:[]},the="wrapper";function nhe(t){let{components:n,...e}=t;return(0,s.kt)(the,(0,p.Z)({},Jde,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}nhe.isMDXComponent=!0;const ehe={toc:[]},ohe="wrapper";function phe(t){let{components:n,...e}=t;return(0,s.kt)(ohe,(0,p.Z)({},ehe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}phe.isMDXComponent=!0;const rhe={toc:[]},she="wrapper";function che(t){let{components:n,...e}=t;return(0,s.kt)(she,(0,p.Z)({},rhe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}che.isMDXComponent=!0;const ihe={toc:[]},ahe="wrapper";function lhe(t){let{components:n,...e}=t;return(0,s.kt)(ahe,(0,p.Z)({},ihe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lhe.isMDXComponent=!0;const uhe={toc:[]},mhe="wrapper";function dhe(t){let{components:n,...e}=t;return(0,s.kt)(mhe,(0,p.Z)({},uhe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}dhe.isMDXComponent=!0;const hhe={toc:[]},khe="wrapper";function fhe(t){let{components:n,...e}=t;return(0,s.kt)(khe,(0,p.Z)({},hhe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}fhe.isMDXComponent=!0;const yhe={toc:[]},Mhe="wrapper";function Dhe(t){let{components:n,...e}=t;return(0,s.kt)(Mhe,(0,p.Z)({},yhe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Dhe.isMDXComponent=!0;const Xhe={toc:[]},_he="wrapper";function whe(t){let{components:n,...e}=t;return(0,s.kt)(_he,(0,p.Z)({},Xhe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}whe.isMDXComponent=!0;const The={toc:[]},Che="wrapper";function ghe(t){let{components:n,...e}=t;return(0,s.kt)(Che,(0,p.Z)({},The,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}ghe.isMDXComponent=!0;const xhe={toc:[]},vhe="wrapper";function Lhe(t){let{components:n,...e}=t;return(0,s.kt)(vhe,(0,p.Z)({},xhe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Lhe.isMDXComponent=!0;const Zhe={toc:[]},bhe="wrapper";function Nhe(t){let{components:n,...e}=t;return(0,s.kt)(bhe,(0,p.Z)({},Zhe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Nhe.isMDXComponent=!0;const Ahe={toc:[]},zhe="wrapper";function Whe(t){let{components:n,...e}=t;return(0,s.kt)(zhe,(0,p.Z)({},Ahe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Whe.isMDXComponent=!0;const Ihe={toc:[]},Rhe="wrapper";function Phe(t){let{components:n,...e}=t;return(0,s.kt)(Rhe,(0,p.Z)({},Ihe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Phe.isMDXComponent=!0;const She={toc:[]},Ehe="wrapper";function Ghe(t){let{components:n,...e}=t;return(0,s.kt)(Ehe,(0,p.Z)({},She,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Ghe.isMDXComponent=!0;const Ohe={toc:[]},Fhe="wrapper";function Bhe(t){let{components:n,...e}=t;return(0,s.kt)(Fhe,(0,p.Z)({},Ohe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Bhe.isMDXComponent=!0;const Uhe={toc:[]},Vhe="wrapper";function qhe(t){let{components:n,...e}=t;return(0,s.kt)(Vhe,(0,p.Z)({},Uhe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}qhe.isMDXComponent=!0;const jhe={toc:[]},Yhe="wrapper";function Qhe(t){let{components:n,...e}=t;return(0,s.kt)(Yhe,(0,p.Z)({},jhe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Qhe.isMDXComponent=!0;const Hhe={toc:[]},$he="wrapper";function Khe(t){let{components:n,...e}=t;return(0,s.kt)($he,(0,p.Z)({},Hhe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Khe.isMDXComponent=!0;const Jhe={toc:[]},tke="wrapper";function nke(t){let{components:n,...e}=t;return(0,s.kt)(tke,(0,p.Z)({},Jhe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}nke.isMDXComponent=!0;const eke={toc:[]},oke="wrapper";function pke(t){let{components:n,...e}=t;return(0,s.kt)(oke,(0,p.Z)({},eke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}pke.isMDXComponent=!0;const rke={toc:[]},ske="wrapper";function cke(t){let{components:n,...e}=t;return(0,s.kt)(ske,(0,p.Z)({},rke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}cke.isMDXComponent=!0;const ike={toc:[]},ake="wrapper";function lke(t){let{components:n,...e}=t;return(0,s.kt)(ake,(0,p.Z)({},ike,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}lke.isMDXComponent=!0;const uke={toc:[]},mke="wrapper";function dke(t){let{components:n,...e}=t;return(0,s.kt)(mke,(0,p.Z)({},uke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}dke.isMDXComponent=!0;const hke={toc:[]},kke="wrapper";function fke(t){let{components:n,...e}=t;return(0,s.kt)(kke,(0,p.Z)({},hke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}fke.isMDXComponent=!0;const yke={toc:[]},Mke="wrapper";function Dke(t){let{components:n,...e}=t;return(0,s.kt)(Mke,(0,p.Z)({},yke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Dke.isMDXComponent=!0;const Xke={toc:[]},_ke="wrapper";function wke(t){let{components:n,...e}=t;return(0,s.kt)(_ke,(0,p.Z)({},Xke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}wke.isMDXComponent=!0;const Tke={toc:[]},Cke="wrapper";function gke(t){let{components:n,...e}=t;return(0,s.kt)(Cke,(0,p.Z)({},Tke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}gke.isMDXComponent=!0;const xke={toc:[]},vke="wrapper";function Lke(t){let{components:n,...e}=t;return(0,s.kt)(vke,(0,p.Z)({},xke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Lke.isMDXComponent=!0;const Zke={toc:[]},bke="wrapper";function Nke(t){let{components:n,...e}=t;return(0,s.kt)(bke,(0,p.Z)({},Zke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Nke.isMDXComponent=!0;const Ake={toc:[]},zke="wrapper";function Wke(t){let{components:n,...e}=t;return(0,s.kt)(zke,(0,p.Z)({},Ake,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Wke.isMDXComponent=!0;const Ike={toc:[]},Rke="wrapper";function Pke(t){let{components:n,...e}=t;return(0,s.kt)(Rke,(0,p.Z)({},Ike,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Pke.isMDXComponent=!0;const Ske={toc:[]},Eke="wrapper";function Gke(t){let{components:n,...e}=t;return(0,s.kt)(Eke,(0,p.Z)({},Ske,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Gke.isMDXComponent=!0;const Oke={toc:[]},Fke="wrapper";function Bke(t){let{components:n,...e}=t;return(0,s.kt)(Fke,(0,p.Z)({},Oke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Bke.isMDXComponent=!0;const Uke={toc:[]},Vke="wrapper";function qke(t){let{components:n,...e}=t;return(0,s.kt)(Vke,(0,p.Z)({},Uke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qke.isMDXComponent=!0;const jke={toc:[]},Yke="wrapper";function Qke(t){let{components:n,...e}=t;return(0,s.kt)(Yke,(0,p.Z)({},jke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Qke.isMDXComponent=!0;const Hke={toc:[]},$ke="wrapper";function Kke(t){let{components:n,...e}=t;return(0,s.kt)($ke,(0,p.Z)({},Hke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Kke.isMDXComponent=!0;const Jke={toc:[]},tfe="wrapper";function nfe(t){let{components:n,...e}=t;return(0,s.kt)(tfe,(0,p.Z)({},Jke,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}nfe.isMDXComponent=!0;const efe={toc:[]},ofe="wrapper";function pfe(t){let{components:n,...e}=t;return(0,s.kt)(ofe,(0,p.Z)({},efe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}pfe.isMDXComponent=!0;const rfe={toc:[]},sfe="wrapper";function cfe(t){let{components:n,...e}=t;return(0,s.kt)(sfe,(0,p.Z)({},rfe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}cfe.isMDXComponent=!0;const ife={toc:[]},afe="wrapper";function lfe(t){let{components:n,...e}=t;return(0,s.kt)(afe,(0,p.Z)({},ife,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}lfe.isMDXComponent=!0;const ufe={toc:[]},mfe="wrapper";function dfe(t){let{components:n,...e}=t;return(0,s.kt)(mfe,(0,p.Z)({},ufe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}dfe.isMDXComponent=!0;const hfe={toc:[]},kfe="wrapper";function ffe(t){let{components:n,...e}=t;return(0,s.kt)(kfe,(0,p.Z)({},hfe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}ffe.isMDXComponent=!0;const yfe={toc:[]},Mfe="wrapper";function Dfe(t){let{components:n,...e}=t;return(0,s.kt)(Mfe,(0,p.Z)({},yfe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Dfe.isMDXComponent=!0;const Xfe={toc:[]},_fe="wrapper";function wfe(t){let{components:n,...e}=t;return(0,s.kt)(_fe,(0,p.Z)({},Xfe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, QuadBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}wfe.isMDXComponent=!0;const Tfe={toc:[]},Cfe="wrapper";function gfe(t){let{components:n,...e}=t;return(0,s.kt)(Cfe,(0,p.Z)({},Tfe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}gfe.isMDXComponent=!0;const xfe={toc:[]},vfe="wrapper";function Lfe(t){let{components:n,...e}=t;return(0,s.kt)(vfe,(0,p.Z)({},xfe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Lfe.isMDXComponent=!0;const Zfe={toc:[]},bfe="wrapper";function Nfe(t){let{components:n,...e}=t;return(0,s.kt)(bfe,(0,p.Z)({},Zfe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Nfe.isMDXComponent=!0;const Afe={toc:[]},zfe="wrapper";function Wfe(t){let{components:n,...e}=t;return(0,s.kt)(zfe,(0,p.Z)({},Afe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Wfe.isMDXComponent=!0;const Ife={toc:[]},Rfe="wrapper";function Pfe(t){let{components:n,...e}=t;return(0,s.kt)(Rfe,(0,p.Z)({},Ife,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Pfe.isMDXComponent=!0;const Sfe={toc:[]},Efe="wrapper";function Gfe(t){let{components:n,...e}=t;return(0,s.kt)(Efe,(0,p.Z)({},Sfe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Gfe.isMDXComponent=!0;const Ofe={toc:[]},Ffe="wrapper";function Bfe(t){let{components:n,...e}=t;return(0,s.kt)(Ffe,(0,p.Z)({},Ofe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Bfe.isMDXComponent=!0;const Ufe={toc:[]},Vfe="wrapper";function qfe(t){let{components:n,...e}=t;return(0,s.kt)(Vfe,(0,p.Z)({},Ufe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}qfe.isMDXComponent=!0;const jfe={toc:[]},Yfe="wrapper";function Qfe(t){let{components:n,...e}=t;return(0,s.kt)(Yfe,(0,p.Z)({},jfe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Qfe.isMDXComponent=!0;const Hfe={toc:[]},$fe="wrapper";function Kfe(t){let{components:n,...e}=t;return(0,s.kt)($fe,(0,p.Z)({},Hfe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Kfe.isMDXComponent=!0;const Jfe={toc:[]},tye="wrapper";function nye(t){let{components:n,...e}=t;return(0,s.kt)(tye,(0,p.Z)({},Jfe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}nye.isMDXComponent=!0;const eye={toc:[]},oye="wrapper";function pye(t){let{components:n,...e}=t;return(0,s.kt)(oye,(0,p.Z)({},eye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}pye.isMDXComponent=!0;const rye={toc:[]},sye="wrapper";function cye(t){let{components:n,...e}=t;return(0,s.kt)(sye,(0,p.Z)({},rye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}cye.isMDXComponent=!0;const iye={toc:[]},aye="wrapper";function lye(t){let{components:n,...e}=t;return(0,s.kt)(aye,(0,p.Z)({},iye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}lye.isMDXComponent=!0;const uye={toc:[]},mye="wrapper";function dye(t){let{components:n,...e}=t;return(0,s.kt)(mye,(0,p.Z)({},uye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}dye.isMDXComponent=!0;const hye={toc:[]},kye="wrapper";function fye(t){let{components:n,...e}=t;return(0,s.kt)(kye,(0,p.Z)({},hye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}fye.isMDXComponent=!0;const yye={toc:[]},Mye="wrapper";function Dye(t){let{components:n,...e}=t;return(0,s.kt)(Mye,(0,p.Z)({},yye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Dye.isMDXComponent=!0;const Xye={toc:[]},_ye="wrapper";function wye(t){let{components:n,...e}=t;return(0,s.kt)(_ye,(0,p.Z)({},Xye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wye.isMDXComponent=!0;const Tye={toc:[]},Cye="wrapper";function gye(t){let{components:n,...e}=t;return(0,s.kt)(Cye,(0,p.Z)({},Tye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}gye.isMDXComponent=!0;const xye={toc:[]},vye="wrapper";function Lye(t){let{components:n,...e}=t;return(0,s.kt)(vye,(0,p.Z)({},xye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Lye.isMDXComponent=!0;const Zye={toc:[]},bye="wrapper";function Nye(t){let{components:n,...e}=t;return(0,s.kt)(bye,(0,p.Z)({},Zye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Nye.isMDXComponent=!0;const Aye={toc:[]},zye="wrapper";function Wye(t){let{components:n,...e}=t;return(0,s.kt)(zye,(0,p.Z)({},Aye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Wye.isMDXComponent=!0;const Iye={toc:[]},Rye="wrapper";function Pye(t){let{components:n,...e}=t;return(0,s.kt)(Rye,(0,p.Z)({},Iye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Pye.isMDXComponent=!0;const Sye={toc:[]},Eye="wrapper";function Gye(t){let{components:n,...e}=t;return(0,s.kt)(Eye,(0,p.Z)({},Sye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Gye.isMDXComponent=!0;const Oye={toc:[]},Fye="wrapper";function Bye(t){let{components:n,...e}=t;return(0,s.kt)(Fye,(0,p.Z)({},Oye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Bye.isMDXComponent=!0;const Uye={toc:[]},Vye="wrapper";function qye(t){let{components:n,...e}=t;return(0,s.kt)(Vye,(0,p.Z)({},Uye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}qye.isMDXComponent=!0;const jye={toc:[]},Yye="wrapper";function Qye(t){let{components:n,...e}=t;return(0,s.kt)(Yye,(0,p.Z)({},jye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Qye.isMDXComponent=!0;const Hye={toc:[]},$ye="wrapper";function Kye(t){let{components:n,...e}=t;return(0,s.kt)($ye,(0,p.Z)({},Hye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Kye.isMDXComponent=!0;const Jye={toc:[]},tMe="wrapper";function nMe(t){let{components:n,...e}=t;return(0,s.kt)(tMe,(0,p.Z)({},Jye,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}nMe.isMDXComponent=!0;const eMe={toc:[]},oMe="wrapper";function pMe(t){let{components:n,...e}=t;return(0,s.kt)(oMe,(0,p.Z)({},eMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}pMe.isMDXComponent=!0;const rMe={toc:[]},sMe="wrapper";function cMe(t){let{components:n,...e}=t;return(0,s.kt)(sMe,(0,p.Z)({},rMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}cMe.isMDXComponent=!0;const iMe={toc:[]},aMe="wrapper";function lMe(t){let{components:n,...e}=t;return(0,s.kt)(aMe,(0,p.Z)({},iMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}lMe.isMDXComponent=!0;const uMe={toc:[]},mMe="wrapper";function dMe(t){let{components:n,...e}=t;return(0,s.kt)(mMe,(0,p.Z)({},uMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The control point of the B\xe9zier curve."))}dMe.isMDXComponent=!0;const hMe={toc:[]},kMe="wrapper";function fMe(t){let{components:n,...e}=t;return(0,s.kt)(kMe,(0,p.Z)({},hMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}fMe.isMDXComponent=!0;const yMe={toc:[]},MMe="wrapper";function DMe(t){let{components:n,...e}=t;return(0,s.kt)(MMe,(0,p.Z)({},yMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}DMe.isMDXComponent=!0;const XMe={toc:[]},_Me="wrapper";function wMe(t){let{components:n,...e}=t;return(0,s.kt)(_Me,(0,p.Z)({},XMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wMe.isMDXComponent=!0;const TMe={toc:[]},CMe="wrapper";function gMe(t){let{components:n,...e}=t;return(0,s.kt)(CMe,(0,p.Z)({},TMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}gMe.isMDXComponent=!0;const xMe={toc:[]},vMe="wrapper";function LMe(t){let{components:n,...e}=t;return(0,s.kt)(vMe,(0,p.Z)({},xMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}LMe.isMDXComponent=!0;const ZMe={toc:[]},bMe="wrapper";function NMe(t){let{components:n,...e}=t;return(0,s.kt)(bMe,(0,p.Z)({},ZMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}NMe.isMDXComponent=!0;const AMe={toc:[]},zMe="wrapper";function WMe(t){let{components:n,...e}=t;return(0,s.kt)(zMe,(0,p.Z)({},AMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}WMe.isMDXComponent=!0;const IMe={toc:[]},RMe="wrapper";function PMe(t){let{components:n,...e}=t;return(0,s.kt)(RMe,(0,p.Z)({},IMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}PMe.isMDXComponent=!0;const SMe={toc:[]},EMe="wrapper";function GMe(t){let{components:n,...e}=t;return(0,s.kt)(EMe,(0,p.Z)({},SMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}GMe.isMDXComponent=!0;const OMe={toc:[]},FMe="wrapper";function BMe(t){let{components:n,...e}=t;return(0,s.kt)(FMe,(0,p.Z)({},OMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}BMe.isMDXComponent=!0;const UMe={toc:[]},VMe="wrapper";function qMe(t){let{components:n,...e}=t;return(0,s.kt)(VMe,(0,p.Z)({},UMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}qMe.isMDXComponent=!0;const jMe={toc:[]},YMe="wrapper";function QMe(t){let{components:n,...e}=t;return(0,s.kt)(YMe,(0,p.Z)({},jMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}QMe.isMDXComponent=!0;const HMe={toc:[]},$Me="wrapper";function KMe(t){let{components:n,...e}=t;return(0,s.kt)($Me,(0,p.Z)({},HMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}KMe.isMDXComponent=!0;const JMe={toc:[]},tDe="wrapper";function nDe(t){let{components:n,...e}=t;return(0,s.kt)(tDe,(0,p.Z)({},JMe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}nDe.isMDXComponent=!0;const eDe={toc:[]},oDe="wrapper";function pDe(t){let{components:n,...e}=t;return(0,s.kt)(oDe,(0,p.Z)({},eDe,e,{components:n,mdxType:"MDXLayout"}))}pDe.isMDXComponent=!0;const rDe={toc:[]},sDe="wrapper";function cDe(t){let{components:n,...e}=t;return(0,s.kt)(sDe,(0,p.Z)({},rDe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}cDe.isMDXComponent=!0;const iDe={toc:[]},aDe="wrapper";function lDe(t){let{components:n,...e}=t;return(0,s.kt)(aDe,(0,p.Z)({},iDe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}lDe.isMDXComponent=!0;const uDe={toc:[]},mDe="wrapper";function dDe(t){let{components:n,...e}=t;return(0,s.kt)(mDe,(0,p.Z)({},uDe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}dDe.isMDXComponent=!0;const hDe={toc:[]},kDe="wrapper";function fDe(t){let{components:n,...e}=t;return(0,s.kt)(kDe,(0,p.Z)({},hDe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}fDe.isMDXComponent=!0;const yDe={toc:[]},MDe="wrapper";function DDe(t){let{components:n,...e}=t;return(0,s.kt)(MDe,(0,p.Z)({},yDe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}DDe.isMDXComponent=!0;const XDe={toc:[]},_De="wrapper";function wDe(t){let{components:n,...e}=t;return(0,s.kt)(_De,(0,p.Z)({},XDe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}wDe.isMDXComponent=!0;const TDe={toc:[]},CDe="wrapper";function gDe(t){let{components:n,...e}=t;return(0,s.kt)(CDe,(0,p.Z)({},TDe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}gDe.isMDXComponent=!0;const xDe={toc:[]},vDe="wrapper";function LDe(t){let{components:n,...e}=t;return(0,s.kt)(vDe,(0,p.Z)({},xDe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}LDe.isMDXComponent=!0;const ZDe={toc:[]},bDe="wrapper";function NDe(t){let{components:n,...e}=t;return(0,s.kt)(bDe,(0,p.Z)({},ZDe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}NDe.isMDXComponent=!0;const ADe={toc:[]},zDe="wrapper";function WDe(t){let{components:n,...e}=t;return(0,s.kt)(zDe,(0,p.Z)({},ADe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}WDe.isMDXComponent=!0;const IDe={toc:[]},RDe="wrapper";function PDe(t){let{components:n,...e}=t;return(0,s.kt)(RDe,(0,p.Z)({},IDe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}PDe.isMDXComponent=!0;const SDe={toc:[]},EDe="wrapper";function GDe(t){let{components:n,...e}=t;return(0,s.kt)(EDe,(0,p.Z)({},SDe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}GDe.isMDXComponent=!0;const ODe={toc:[]},FDe="wrapper";function BDe(t){let{components:n,...e}=t;return(0,s.kt)(FDe,(0,p.Z)({},ODe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}BDe.isMDXComponent=!0;const UDe={toc:[]},VDe="wrapper";function qDe(t){let{components:n,...e}=t;return(0,s.kt)(VDe,(0,p.Z)({},UDe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}qDe.isMDXComponent=!0;const jDe={toc:[]},YDe="wrapper";function QDe(t){let{components:n,...e}=t;return(0,s.kt)(YDe,(0,p.Z)({},jDe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}QDe.isMDXComponent=!0;const HDe={toc:[]},$De="wrapper";function KDe(t){let{components:n,...e}=t;return(0,s.kt)($De,(0,p.Z)({},HDe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}KDe.isMDXComponent=!0;const JDe={toc:[]},tXe="wrapper";function nXe(t){let{components:n,...e}=t;return(0,s.kt)(tXe,(0,p.Z)({},JDe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}nXe.isMDXComponent=!0;const eXe={toc:[]},oXe="wrapper";function pXe(t){let{components:n,...e}=t;return(0,s.kt)(oXe,(0,p.Z)({},eXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}pXe.isMDXComponent=!0;const rXe={toc:[]},sXe="wrapper";function cXe(t){let{components:n,...e}=t;return(0,s.kt)(sXe,(0,p.Z)({},rXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}cXe.isMDXComponent=!0;const iXe={toc:[]},aXe="wrapper";function lXe(t){let{components:n,...e}=t;return(0,s.kt)(aXe,(0,p.Z)({},iXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}lXe.isMDXComponent=!0;const uXe={toc:[]},mXe="wrapper";function dXe(t){let{components:n,...e}=t;return(0,s.kt)(mXe,(0,p.Z)({},uXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}dXe.isMDXComponent=!0;const hXe={toc:[]},kXe="wrapper";function fXe(t){let{components:n,...e}=t;return(0,s.kt)(kXe,(0,p.Z)({},hXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}fXe.isMDXComponent=!0;const yXe={toc:[]},MXe="wrapper";function DXe(t){let{components:n,...e}=t;return(0,s.kt)(MXe,(0,p.Z)({},yXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}DXe.isMDXComponent=!0;const XXe={toc:[]},_Xe="wrapper";function wXe(t){let{components:n,...e}=t;return(0,s.kt)(_Xe,(0,p.Z)({},XXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}wXe.isMDXComponent=!0;const TXe={toc:[]},CXe="wrapper";function gXe(t){let{components:n,...e}=t;return(0,s.kt)(CXe,(0,p.Z)({},TXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}gXe.isMDXComponent=!0;const xXe={toc:[]},vXe="wrapper";function LXe(t){let{components:n,...e}=t;return(0,s.kt)(vXe,(0,p.Z)({},xXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}LXe.isMDXComponent=!0;const ZXe={toc:[]},bXe="wrapper";function NXe(t){let{components:n,...e}=t;return(0,s.kt)(bXe,(0,p.Z)({},ZXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}NXe.isMDXComponent=!0;const AXe={toc:[]},zXe="wrapper";function WXe(t){let{components:n,...e}=t;return(0,s.kt)(zXe,(0,p.Z)({},AXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}WXe.isMDXComponent=!0;const IXe={toc:[]},RXe="wrapper";function PXe(t){let{components:n,...e}=t;return(0,s.kt)(RXe,(0,p.Z)({},IXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}PXe.isMDXComponent=!0;const SXe={toc:[]},EXe="wrapper";function GXe(t){let{components:n,...e}=t;return(0,s.kt)(EXe,(0,p.Z)({},SXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}GXe.isMDXComponent=!0;const OXe={toc:[]},FXe="wrapper";function BXe(t){let{components:n,...e}=t;return(0,s.kt)(FXe,(0,p.Z)({},OXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}BXe.isMDXComponent=!0;const UXe={toc:[]},VXe="wrapper";function qXe(t){let{components:n,...e}=t;return(0,s.kt)(VXe,(0,p.Z)({},UXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}qXe.isMDXComponent=!0;const jXe={toc:[]},YXe="wrapper";function QXe(t){let{components:n,...e}=t;return(0,s.kt)(YXe,(0,p.Z)({},jXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}QXe.isMDXComponent=!0;const HXe={toc:[]},$Xe="wrapper";function KXe(t){let{components:n,...e}=t;return(0,s.kt)($Xe,(0,p.Z)({},HXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}KXe.isMDXComponent=!0;const JXe={toc:[]},t_e="wrapper";function n_e(t){let{components:n,...e}=t;return(0,s.kt)(t_e,(0,p.Z)({},JXe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}n_e.isMDXComponent=!0;const e_e={toc:[]},o_e="wrapper";function p_e(t){let{components:n,...e}=t;return(0,s.kt)(o_e,(0,p.Z)({},e_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}p_e.isMDXComponent=!0;const r_e={toc:[]},s_e="wrapper";function c_e(t){let{components:n,...e}=t;return(0,s.kt)(s_e,(0,p.Z)({},r_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}c_e.isMDXComponent=!0;const i_e={toc:[]},a_e="wrapper";function l_e(t){let{components:n,...e}=t;return(0,s.kt)(a_e,(0,p.Z)({},i_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}l_e.isMDXComponent=!0;const u_e={toc:[]},m_e="wrapper";function d_e(t){let{components:n,...e}=t;return(0,s.kt)(m_e,(0,p.Z)({},u_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}d_e.isMDXComponent=!0;const h_e={toc:[]},k_e="wrapper";function f_e(t){let{components:n,...e}=t;return(0,s.kt)(k_e,(0,p.Z)({},h_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}f_e.isMDXComponent=!0;const y_e={toc:[]},M_e="wrapper";function D_e(t){let{components:n,...e}=t;return(0,s.kt)(M_e,(0,p.Z)({},y_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}D_e.isMDXComponent=!0;const X_e={toc:[]},__e="wrapper";function w_e(t){let{components:n,...e}=t;return(0,s.kt)(__e,(0,p.Z)({},X_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}w_e.isMDXComponent=!0;const T_e={toc:[]},C_e="wrapper";function g_e(t){let{components:n,...e}=t;return(0,s.kt)(C_e,(0,p.Z)({},T_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}g_e.isMDXComponent=!0;const x_e={toc:[]},v_e="wrapper";function L_e(t){let{components:n,...e}=t;return(0,s.kt)(v_e,(0,p.Z)({},x_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}L_e.isMDXComponent=!0;const Z_e={toc:[]},b_e="wrapper";function N_e(t){let{components:n,...e}=t;return(0,s.kt)(b_e,(0,p.Z)({},Z_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}N_e.isMDXComponent=!0;const A_e={toc:[]},z_e="wrapper";function W_e(t){let{components:n,...e}=t;return(0,s.kt)(z_e,(0,p.Z)({},A_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}W_e.isMDXComponent=!0;const I_e={toc:[]},R_e="wrapper";function P_e(t){let{components:n,...e}=t;return(0,s.kt)(R_e,(0,p.Z)({},I_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}P_e.isMDXComponent=!0;const S_e={toc:[]},E_e="wrapper";function G_e(t){let{components:n,...e}=t;return(0,s.kt)(E_e,(0,p.Z)({},S_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}G_e.isMDXComponent=!0;const O_e={toc:[]},F_e="wrapper";function B_e(t){let{components:n,...e}=t;return(0,s.kt)(F_e,(0,p.Z)({},O_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}B_e.isMDXComponent=!0;const U_e={toc:[]},V_e="wrapper";function q_e(t){let{components:n,...e}=t;return(0,s.kt)(V_e,(0,p.Z)({},U_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}q_e.isMDXComponent=!0;const j_e={toc:[]},Y_e="wrapper";function Q_e(t){let{components:n,...e}=t;return(0,s.kt)(Y_e,(0,p.Z)({},j_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Q_e.isMDXComponent=!0;const H_e={toc:[]},$_e="wrapper";function K_e(t){let{components:n,...e}=t;return(0,s.kt)($_e,(0,p.Z)({},H_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}K_e.isMDXComponent=!0;const J_e={toc:[]},twe="wrapper";function nwe(t){let{components:n,...e}=t;return(0,s.kt)(twe,(0,p.Z)({},J_e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}nwe.isMDXComponent=!0;const ewe={toc:[]},owe="wrapper";function pwe(t){let{components:n,...e}=t;return(0,s.kt)(owe,(0,p.Z)({},ewe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pwe.isMDXComponent=!0;const rwe={toc:[]},swe="wrapper";function cwe(t){let{components:n,...e}=t;return(0,s.kt)(swe,(0,p.Z)({},rwe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}cwe.isMDXComponent=!0;const iwe={toc:[]},awe="wrapper";function lwe(t){let{components:n,...e}=t;return(0,s.kt)(awe,(0,p.Z)({},iwe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lwe.isMDXComponent=!0;const uwe={toc:[]},mwe="wrapper";function dwe(t){let{components:n,...e}=t;return(0,s.kt)(mwe,(0,p.Z)({},uwe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}dwe.isMDXComponent=!0;const hwe={toc:[]},kwe="wrapper";function fwe(t){let{components:n,...e}=t;return(0,s.kt)(kwe,(0,p.Z)({},hwe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}fwe.isMDXComponent=!0;const ywe={toc:[]},Mwe="wrapper";function Dwe(t){let{components:n,...e}=t;return(0,s.kt)(Mwe,(0,p.Z)({},ywe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Dwe.isMDXComponent=!0;const Xwe={toc:[]},_we="wrapper";function wwe(t){let{components:n,...e}=t;return(0,s.kt)(_we,(0,p.Z)({},Xwe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wwe.isMDXComponent=!0;const Twe={toc:[]},Cwe="wrapper";function gwe(t){let{components:n,...e}=t;return(0,s.kt)(Cwe,(0,p.Z)({},Twe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}gwe.isMDXComponent=!0;const xwe={toc:[]},vwe="wrapper";function Lwe(t){let{components:n,...e}=t;return(0,s.kt)(vwe,(0,p.Z)({},xwe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lwe.isMDXComponent=!0;const Zwe={toc:[]},bwe="wrapper";function Nwe(t){let{components:n,...e}=t;return(0,s.kt)(bwe,(0,p.Z)({},Zwe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Nwe.isMDXComponent=!0;const Awe={toc:[]},zwe="wrapper";function Wwe(t){let{components:n,...e}=t;return(0,s.kt)(zwe,(0,p.Z)({},Awe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Wwe.isMDXComponent=!0;const Iwe={toc:[]},Rwe="wrapper";function Pwe(t){let{components:n,...e}=t;return(0,s.kt)(Rwe,(0,p.Z)({},Iwe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Pwe.isMDXComponent=!0;const Swe={toc:[]},Ewe="wrapper";function Gwe(t){let{components:n,...e}=t;return(0,s.kt)(Ewe,(0,p.Z)({},Swe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Gwe.isMDXComponent=!0;const Owe={toc:[]},Fwe="wrapper";function Bwe(t){let{components:n,...e}=t;return(0,s.kt)(Fwe,(0,p.Z)({},Owe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Bwe.isMDXComponent=!0;const Uwe={toc:[]},Vwe="wrapper";function qwe(t){let{components:n,...e}=t;return(0,s.kt)(Vwe,(0,p.Z)({},Uwe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qwe.isMDXComponent=!0;const jwe={toc:[]},Ywe="wrapper";function Qwe(t){let{components:n,...e}=t;return(0,s.kt)(Ywe,(0,p.Z)({},jwe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Qwe.isMDXComponent=!0;const Hwe={toc:[]},$we="wrapper";function Kwe(t){let{components:n,...e}=t;return(0,s.kt)($we,(0,p.Z)({},Hwe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Kwe.isMDXComponent=!0;const Jwe={toc:[]},tTe="wrapper";function nTe(t){let{components:n,...e}=t;return(0,s.kt)(tTe,(0,p.Z)({},Jwe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}nTe.isMDXComponent=!0;const eTe={toc:[]},oTe="wrapper";function pTe(t){let{components:n,...e}=t;return(0,s.kt)(oTe,(0,p.Z)({},eTe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}pTe.isMDXComponent=!0;const rTe={toc:[]},sTe="wrapper";function cTe(t){let{components:n,...e}=t;return(0,s.kt)(sTe,(0,p.Z)({},rTe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}cTe.isMDXComponent=!0;const iTe={toc:[]},aTe="wrapper";function lTe(t){let{components:n,...e}=t;return(0,s.kt)(aTe,(0,p.Z)({},iTe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}lTe.isMDXComponent=!0;const uTe={toc:[]},mTe="wrapper";function dTe(t){let{components:n,...e}=t;return(0,s.kt)(mTe,(0,p.Z)({},uTe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}dTe.isMDXComponent=!0;const hTe={toc:[]},kTe="wrapper";function fTe(t){let{components:n,...e}=t;return(0,s.kt)(kTe,(0,p.Z)({},hTe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}fTe.isMDXComponent=!0;const yTe={toc:[]},MTe="wrapper";function DTe(t){let{components:n,...e}=t;return(0,s.kt)(MTe,(0,p.Z)({},yTe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}DTe.isMDXComponent=!0;const XTe={toc:[]},_Te="wrapper";function wTe(t){let{components:n,...e}=t;return(0,s.kt)(_Te,(0,p.Z)({},XTe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}wTe.isMDXComponent=!0;const TTe={toc:[]},CTe="wrapper";function gTe(t){let{components:n,...e}=t;return(0,s.kt)(CTe,(0,p.Z)({},TTe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}gTe.isMDXComponent=!0;const xTe={toc:[]},vTe="wrapper";function LTe(t){let{components:n,...e}=t;return(0,s.kt)(vTe,(0,p.Z)({},xTe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}LTe.isMDXComponent=!0;const ZTe={toc:[]},bTe="wrapper";function NTe(t){let{components:n,...e}=t;return(0,s.kt)(bTe,(0,p.Z)({},ZTe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}NTe.isMDXComponent=!0;const ATe={toc:[]},zTe="wrapper";function WTe(t){let{components:n,...e}=t;return(0,s.kt)(zTe,(0,p.Z)({},ATe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}WTe.isMDXComponent=!0;const ITe={toc:[]},RTe="wrapper";function PTe(t){let{components:n,...e}=t;return(0,s.kt)(RTe,(0,p.Z)({},ITe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}PTe.isMDXComponent=!0;const STe={toc:[]},ETe="wrapper";function GTe(t){let{components:n,...e}=t;return(0,s.kt)(ETe,(0,p.Z)({},STe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}GTe.isMDXComponent=!0;const OTe={toc:[]},FTe="wrapper";function BTe(t){let{components:n,...e}=t;return(0,s.kt)(FTe,(0,p.Z)({},OTe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}BTe.isMDXComponent=!0;const UTe={toc:[]},VTe="wrapper";function qTe(t){let{components:n,...e}=t;return(0,s.kt)(VTe,(0,p.Z)({},UTe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}qTe.isMDXComponent=!0;const jTe={toc:[]},YTe="wrapper";function QTe(t){let{components:n,...e}=t;return(0,s.kt)(YTe,(0,p.Z)({},jTe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}QTe.isMDXComponent=!0;const HTe={toc:[]},$Te="wrapper";function KTe(t){let{components:n,...e}=t;return(0,s.kt)($Te,(0,p.Z)({},HTe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}KTe.isMDXComponent=!0;const JTe={toc:[]},tCe="wrapper";function nCe(t){let{components:n,...e}=t;return(0,s.kt)(tCe,(0,p.Z)({},JTe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}nCe.isMDXComponent=!0;const eCe={toc:[]},oCe="wrapper";function pCe(t){let{components:n,...e}=t;return(0,s.kt)(oCe,(0,p.Z)({},eCe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}pCe.isMDXComponent=!0;const rCe={toc:[]},sCe="wrapper";function cCe(t){let{components:n,...e}=t;return(0,s.kt)(sCe,(0,p.Z)({},rCe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}cCe.isMDXComponent=!0;const iCe={toc:[]},aCe="wrapper";function lCe(t){let{components:n,...e}=t;return(0,s.kt)(aCe,(0,p.Z)({},iCe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}lCe.isMDXComponent=!0;const uCe={toc:[]},mCe="wrapper";function dCe(t){let{components:n,...e}=t;return(0,s.kt)(mCe,(0,p.Z)({},uCe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}dCe.isMDXComponent=!0;const hCe={toc:[]},kCe="wrapper";function fCe(t){let{components:n,...e}=t;return(0,s.kt)(kCe,(0,p.Z)({},hCe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}fCe.isMDXComponent=!0;const yCe={toc:[]},MCe="wrapper";function DCe(t){let{components:n,...e}=t;return(0,s.kt)(MCe,(0,p.Z)({},yCe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}DCe.isMDXComponent=!0;const XCe={toc:[]},_Ce="wrapper";function wCe(t){let{components:n,...e}=t;return(0,s.kt)(_Ce,(0,p.Z)({},XCe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}wCe.isMDXComponent=!0;const TCe={toc:[]},CCe="wrapper";function gCe(t){let{components:n,...e}=t;return(0,s.kt)(CCe,(0,p.Z)({},TCe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}gCe.isMDXComponent=!0;const xCe={toc:[]},vCe="wrapper";function LCe(t){let{components:n,...e}=t;return(0,s.kt)(vCe,(0,p.Z)({},xCe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}LCe.isMDXComponent=!0;const ZCe={toc:[]},bCe="wrapper";function NCe(t){let{components:n,...e}=t;return(0,s.kt)(bCe,(0,p.Z)({},ZCe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}NCe.isMDXComponent=!0;const ACe={toc:[]},zCe="wrapper";function WCe(t){let{components:n,...e}=t;return(0,s.kt)(zCe,(0,p.Z)({},ACe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}WCe.isMDXComponent=!0;const ICe={toc:[]},RCe="wrapper";function PCe(t){let{components:n,...e}=t;return(0,s.kt)(RCe,(0,p.Z)({},ICe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}PCe.isMDXComponent=!0;const SCe={toc:[]},ECe="wrapper";function GCe(t){let{components:n,...e}=t;return(0,s.kt)(ECe,(0,p.Z)({},SCe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}GCe.isMDXComponent=!0;const OCe={toc:[]},FCe="wrapper";function BCe(t){let{components:n,...e}=t;return(0,s.kt)(FCe,(0,p.Z)({},OCe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}BCe.isMDXComponent=!0;const UCe={toc:[]},VCe="wrapper";function qCe(t){let{components:n,...e}=t;return(0,s.kt)(VCe,(0,p.Z)({},UCe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}qCe.isMDXComponent=!0;const jCe={toc:[]},YCe="wrapper";function QCe(t){let{components:n,...e}=t;return(0,s.kt)(YCe,(0,p.Z)({},jCe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}QCe.isMDXComponent=!0;const HCe={toc:[]},$Ce="wrapper";function KCe(t){let{components:n,...e}=t;return(0,s.kt)($Ce,(0,p.Z)({},HCe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}KCe.isMDXComponent=!0;const JCe={toc:[]},tge="wrapper";function nge(t){let{components:n,...e}=t;return(0,s.kt)(tge,(0,p.Z)({},JCe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}nge.isMDXComponent=!0;const ege={toc:[]},oge="wrapper";function pge(t){let{components:n,...e}=t;return(0,s.kt)(oge,(0,p.Z)({},ege,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}pge.isMDXComponent=!0;const rge={toc:[]},sge="wrapper";function cge(t){let{components:n,...e}=t;return(0,s.kt)(sge,(0,p.Z)({},rge,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}cge.isMDXComponent=!0;const ige={toc:[]},age="wrapper";function lge(t){let{components:n,...e}=t;return(0,s.kt)(age,(0,p.Z)({},ige,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}lge.isMDXComponent=!0;const uge={toc:[]},mge="wrapper";function dge(t){let{components:n,...e}=t;return(0,s.kt)(mge,(0,p.Z)({},uge,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}dge.isMDXComponent=!0;const hge={toc:[]},kge="wrapper";function fge(t){let{components:n,...e}=t;return(0,s.kt)(kge,(0,p.Z)({},hge,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}fge.isMDXComponent=!0;const yge={toc:[]},Mge="wrapper";function Dge(t){let{components:n,...e}=t;return(0,s.kt)(Mge,(0,p.Z)({},yge,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Dge.isMDXComponent=!0;const Xge={toc:[]},_ge="wrapper";function wge(t){let{components:n,...e}=t;return(0,s.kt)(_ge,(0,p.Z)({},Xge,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}wge.isMDXComponent=!0;const Tge={toc:[]},Cge="wrapper";function gge(t){let{components:n,...e}=t;return(0,s.kt)(Cge,(0,p.Z)({},Tge,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}gge.isMDXComponent=!0;const xge={toc:[]},vge="wrapper";function Lge(t){let{components:n,...e}=t;return(0,s.kt)(vge,(0,p.Z)({},xge,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Lge.isMDXComponent=!0;const Zge={toc:[]},bge="wrapper";function Nge(t){let{components:n,...e}=t;return(0,s.kt)(bge,(0,p.Z)({},Zge,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Nge.isMDXComponent=!0;const Age={toc:[]},zge="wrapper";function Wge(t){let{components:n,...e}=t;return(0,s.kt)(zge,(0,p.Z)({},Age,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Wge.isMDXComponent=!0;const Ige={toc:[]},Rge="wrapper";function Pge(t){let{components:n,...e}=t;return(0,s.kt)(Rge,(0,p.Z)({},Ige,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Pge.isMDXComponent=!0;const Sge={toc:[]},Ege="wrapper";function Gge(t){let{components:n,...e}=t;return(0,s.kt)(Ege,(0,p.Z)({},Sge,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Gge.isMDXComponent=!0;const Oge={toc:[]},Fge="wrapper";function Bge(t){let{components:n,...e}=t;return(0,s.kt)(Fge,(0,p.Z)({},Oge,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Bge.isMDXComponent=!0;const Uge={toc:[]},Vge="wrapper";function qge(t){let{components:n,...e}=t;return(0,s.kt)(Vge,(0,p.Z)({},Uge,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}qge.isMDXComponent=!0;const jge={toc:[]},Yge="wrapper";function Qge(t){let{components:n,...e}=t;return(0,s.kt)(Yge,(0,p.Z)({},jge,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Qge.isMDXComponent=!0;const Hge={toc:[]},$ge="wrapper";function Kge(t){let{components:n,...e}=t;return(0,s.kt)($ge,(0,p.Z)({},Hge,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Kge.isMDXComponent=!0;const Jge={toc:[]},txe="wrapper";function nxe(t){let{components:n,...e}=t;return(0,s.kt)(txe,(0,p.Z)({},Jge,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}nxe.isMDXComponent=!0;const exe={toc:[]},oxe="wrapper";function pxe(t){let{components:n,...e}=t;return(0,s.kt)(oxe,(0,p.Z)({},exe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}pxe.isMDXComponent=!0;const rxe={toc:[]},sxe="wrapper";function cxe(t){let{components:n,...e}=t;return(0,s.kt)(sxe,(0,p.Z)({},rxe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}cxe.isMDXComponent=!0;const ixe={toc:[]},axe="wrapper";function lxe(t){let{components:n,...e}=t;return(0,s.kt)(axe,(0,p.Z)({},ixe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}lxe.isMDXComponent=!0;const uxe={toc:[]},mxe="wrapper";function dxe(t){let{components:n,...e}=t;return(0,s.kt)(mxe,(0,p.Z)({},uxe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}dxe.isMDXComponent=!0;const hxe={toc:[]},kxe="wrapper";function fxe(t){let{components:n,...e}=t;return(0,s.kt)(kxe,(0,p.Z)({},hxe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}fxe.isMDXComponent=!0;const yxe={toc:[]},Mxe="wrapper";function Dxe(t){let{components:n,...e}=t;return(0,s.kt)(Mxe,(0,p.Z)({},yxe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Dxe.isMDXComponent=!0;const Xxe={toc:[]},_xe="wrapper";function wxe(t){let{components:n,...e}=t;return(0,s.kt)(_xe,(0,p.Z)({},Xxe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}wxe.isMDXComponent=!0;const Txe={toc:[]},Cxe="wrapper";function gxe(t){let{components:n,...e}=t;return(0,s.kt)(Cxe,(0,p.Z)({},Txe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}gxe.isMDXComponent=!0;const xxe={toc:[]},vxe="wrapper";function Lxe(t){let{components:n,...e}=t;return(0,s.kt)(vxe,(0,p.Z)({},xxe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Lxe.isMDXComponent=!0;const Zxe={toc:[]},bxe="wrapper";function Nxe(t){let{components:n,...e}=t;return(0,s.kt)(bxe,(0,p.Z)({},Zxe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Nxe.isMDXComponent=!0;const Axe={toc:[]},zxe="wrapper";function Wxe(t){let{components:n,...e}=t;return(0,s.kt)(zxe,(0,p.Z)({},Axe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Wxe.isMDXComponent=!0;const Ixe={toc:[]},Rxe="wrapper";function Pxe(t){let{components:n,...e}=t;return(0,s.kt)(Rxe,(0,p.Z)({},Ixe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Pxe.isMDXComponent=!0;const Sxe={toc:[]},Exe="wrapper";function Gxe(t){let{components:n,...e}=t;return(0,s.kt)(Exe,(0,p.Z)({},Sxe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Gxe.isMDXComponent=!0;const Oxe={toc:[]},Fxe="wrapper";function Bxe(t){let{components:n,...e}=t;return(0,s.kt)(Fxe,(0,p.Z)({},Oxe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Bxe.isMDXComponent=!0;const Uxe={toc:[]},Vxe="wrapper";function qxe(t){let{components:n,...e}=t;return(0,s.kt)(Vxe,(0,p.Z)({},Uxe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}qxe.isMDXComponent=!0;const jxe={toc:[]},Yxe="wrapper";function Qxe(t){let{components:n,...e}=t;return(0,s.kt)(Yxe,(0,p.Z)({},jxe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Qxe.isMDXComponent=!0;const Hxe={toc:[]},$xe="wrapper";function Kxe(t){let{components:n,...e}=t;return(0,s.kt)($xe,(0,p.Z)({},Hxe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Kxe.isMDXComponent=!0;const Jxe={toc:[]},tve="wrapper";function nve(t){let{components:n,...e}=t;return(0,s.kt)(tve,(0,p.Z)({},Jxe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}nve.isMDXComponent=!0;const eve={toc:[]},ove="wrapper";function pve(t){let{components:n,...e}=t;return(0,s.kt)(ove,(0,p.Z)({},eve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}pve.isMDXComponent=!0;const rve={toc:[]},sve="wrapper";function cve(t){let{components:n,...e}=t;return(0,s.kt)(sve,(0,p.Z)({},rve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}cve.isMDXComponent=!0;const ive={toc:[]},ave="wrapper";function lve(t){let{components:n,...e}=t;return(0,s.kt)(ave,(0,p.Z)({},ive,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}lve.isMDXComponent=!0;const uve={toc:[]},mve="wrapper";function dve(t){let{components:n,...e}=t;return(0,s.kt)(mve,(0,p.Z)({},uve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}dve.isMDXComponent=!0;const hve={toc:[]},kve="wrapper";function fve(t){let{components:n,...e}=t;return(0,s.kt)(kve,(0,p.Z)({},hve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}fve.isMDXComponent=!0;const yve={toc:[]},Mve="wrapper";function Dve(t){let{components:n,...e}=t;return(0,s.kt)(Mve,(0,p.Z)({},yve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Dve.isMDXComponent=!0;const Xve={toc:[]},_ve="wrapper";function wve(t){let{components:n,...e}=t;return(0,s.kt)(_ve,(0,p.Z)({},Xve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}wve.isMDXComponent=!0;const Tve={toc:[]},Cve="wrapper";function gve(t){let{components:n,...e}=t;return(0,s.kt)(Cve,(0,p.Z)({},Tve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}gve.isMDXComponent=!0;const xve={toc:[]},vve="wrapper";function Lve(t){let{components:n,...e}=t;return(0,s.kt)(vve,(0,p.Z)({},xve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Lve.isMDXComponent=!0;const Zve={toc:[]},bve="wrapper";function Nve(t){let{components:n,...e}=t;return(0,s.kt)(bve,(0,p.Z)({},Zve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Nve.isMDXComponent=!0;const Ave={toc:[]},zve="wrapper";function Wve(t){let{components:n,...e}=t;return(0,s.kt)(zve,(0,p.Z)({},Ave,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Wve.isMDXComponent=!0;const Ive={toc:[]},Rve="wrapper";function Pve(t){let{components:n,...e}=t;return(0,s.kt)(Rve,(0,p.Z)({},Ive,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Pve.isMDXComponent=!0;const Sve={toc:[]},Eve="wrapper";function Gve(t){let{components:n,...e}=t;return(0,s.kt)(Eve,(0,p.Z)({},Sve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Gve.isMDXComponent=!0;const Ove={toc:[]},Fve="wrapper";function Bve(t){let{components:n,...e}=t;return(0,s.kt)(Fve,(0,p.Z)({},Ove,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Bve.isMDXComponent=!0;const Uve={toc:[]},Vve="wrapper";function qve(t){let{components:n,...e}=t;return(0,s.kt)(Vve,(0,p.Z)({},Uve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}qve.isMDXComponent=!0;const jve={toc:[]},Yve="wrapper";function Qve(t){let{components:n,...e}=t;return(0,s.kt)(Yve,(0,p.Z)({},jve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Qve.isMDXComponent=!0;const Hve={toc:[]},$ve="wrapper";function Kve(t){let{components:n,...e}=t;return(0,s.kt)($ve,(0,p.Z)({},Hve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Kve.isMDXComponent=!0;const Jve={toc:[]},tLe="wrapper";function nLe(t){let{components:n,...e}=t;return(0,s.kt)(tLe,(0,p.Z)({},Jve,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}nLe.isMDXComponent=!0;const eLe={toc:[]},oLe="wrapper";function pLe(t){let{components:n,...e}=t;return(0,s.kt)(oLe,(0,p.Z)({},eLe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}pLe.isMDXComponent=!0;const rLe={toc:[]},sLe="wrapper";function cLe(t){let{components:n,...e}=t;return(0,s.kt)(sLe,(0,p.Z)({},rLe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}cLe.isMDXComponent=!0;const iLe={toc:[]},aLe="wrapper";function lLe(t){let{components:n,...e}=t;return(0,s.kt)(aLe,(0,p.Z)({},iLe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}lLe.isMDXComponent=!0;const uLe={toc:[]},mLe="wrapper";function dLe(t){let{components:n,...e}=t;return(0,s.kt)(mLe,(0,p.Z)({},uLe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}dLe.isMDXComponent=!0;const hLe={toc:[]},kLe="wrapper";function fLe(t){let{components:n,...e}=t;return(0,s.kt)(kLe,(0,p.Z)({},hLe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}fLe.isMDXComponent=!0;const yLe={toc:[]},MLe="wrapper";function DLe(t){let{components:n,...e}=t;return(0,s.kt)(MLe,(0,p.Z)({},yLe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d';\nimport {Ray} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}DLe.isMDXComponent=!0;const XLe={toc:[]},_Le="wrapper";function wLe(t){let{components:n,...e}=t;return(0,s.kt)(_Le,(0,p.Z)({},XLe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing an individual line segment."))}wLe.isMDXComponent=!0;const TLe={toc:[]},CLe="wrapper";function gLe(t){let{components:n,...e}=t;return(0,s.kt)(CLe,(0,p.Z)({},TLe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}gLe.isMDXComponent=!0;const xLe={toc:[]},vLe="wrapper";function LLe(t){let{components:n,...e}=t;return(0,s.kt)(vLe,(0,p.Z)({},xLe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}LLe.isMDXComponent=!0;const ZLe={toc:[]},bLe="wrapper";function NLe(t){let{components:n,...e}=t;return(0,s.kt)(bLe,(0,p.Z)({},ZLe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}NLe.isMDXComponent=!0;const ALe={toc:[]},zLe="wrapper";function WLe(t){let{components:n,...e}=t;return(0,s.kt)(zLe,(0,p.Z)({},ALe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}WLe.isMDXComponent=!0;const ILe={toc:[]},RLe="wrapper";function PLe(t){let{components:n,...e}=t;return(0,s.kt)(RLe,(0,p.Z)({},ILe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}PLe.isMDXComponent=!0;const SLe={toc:[]},ELe="wrapper";function GLe(t){let{components:n,...e}=t;return(0,s.kt)(ELe,(0,p.Z)({},SLe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}GLe.isMDXComponent=!0;const OLe={toc:[]},FLe="wrapper";function BLe(t){let{components:n,...e}=t;return(0,s.kt)(FLe,(0,p.Z)({},OLe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}BLe.isMDXComponent=!0;const ULe={toc:[]},VLe="wrapper";function qLe(t){let{components:n,...e}=t;return(0,s.kt)(VLe,(0,p.Z)({},ULe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}qLe.isMDXComponent=!0;const jLe={toc:[]},YLe="wrapper";function QLe(t){let{components:n,...e}=t;return(0,s.kt)(YLe,(0,p.Z)({},jLe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}QLe.isMDXComponent=!0;const HLe={toc:[]},$Le="wrapper";function KLe(t){let{components:n,...e}=t;return(0,s.kt)($Le,(0,p.Z)({},HLe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}KLe.isMDXComponent=!0;const JLe={toc:[]},tZe="wrapper";function nZe(t){let{components:n,...e}=t;return(0,s.kt)(tZe,(0,p.Z)({},JLe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}nZe.isMDXComponent=!0;const eZe={toc:[]},oZe="wrapper";function pZe(t){let{components:n,...e}=t;return(0,s.kt)(oZe,(0,p.Z)({},eZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}pZe.isMDXComponent=!0;const rZe={toc:[]},sZe="wrapper";function cZe(t){let{components:n,...e}=t;return(0,s.kt)(sZe,(0,p.Z)({},rZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}cZe.isMDXComponent=!0;const iZe={toc:[]},aZe="wrapper";function lZe(t){let{components:n,...e}=t;return(0,s.kt)(aZe,(0,p.Z)({},iZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lZe.isMDXComponent=!0;const uZe={toc:[]},mZe="wrapper";function dZe(t){let{components:n,...e}=t;return(0,s.kt)(mZe,(0,p.Z)({},uZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}dZe.isMDXComponent=!0;const hZe={toc:[]},kZe="wrapper";function fZe(t){let{components:n,...e}=t;return(0,s.kt)(kZe,(0,p.Z)({},hZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}fZe.isMDXComponent=!0;const yZe={toc:[]},MZe="wrapper";function DZe(t){let{components:n,...e}=t;return(0,s.kt)(MZe,(0,p.Z)({},yZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}DZe.isMDXComponent=!0;const XZe={toc:[]},_Ze="wrapper";function wZe(t){let{components:n,...e}=t;return(0,s.kt)(_Ze,(0,p.Z)({},XZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}wZe.isMDXComponent=!0;const TZe={toc:[]},CZe="wrapper";function gZe(t){let{components:n,...e}=t;return(0,s.kt)(CZe,(0,p.Z)({},TZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gZe.isMDXComponent=!0;const xZe={toc:[]},vZe="wrapper";function LZe(t){let{components:n,...e}=t;return(0,s.kt)(vZe,(0,p.Z)({},xZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}LZe.isMDXComponent=!0;const ZZe={toc:[]},bZe="wrapper";function NZe(t){let{components:n,...e}=t;return(0,s.kt)(bZe,(0,p.Z)({},ZZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}NZe.isMDXComponent=!0;const AZe={toc:[]},zZe="wrapper";function WZe(t){let{components:n,...e}=t;return(0,s.kt)(zZe,(0,p.Z)({},AZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}WZe.isMDXComponent=!0;const IZe={toc:[]},RZe="wrapper";function PZe(t){let{components:n,...e}=t;return(0,s.kt)(RZe,(0,p.Z)({},IZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}PZe.isMDXComponent=!0;const SZe={toc:[]},EZe="wrapper";function GZe(t){let{components:n,...e}=t;return(0,s.kt)(EZe,(0,p.Z)({},SZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}GZe.isMDXComponent=!0;const OZe={toc:[]},FZe="wrapper";function BZe(t){let{components:n,...e}=t;return(0,s.kt)(FZe,(0,p.Z)({},OZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}BZe.isMDXComponent=!0;const UZe={toc:[]},VZe="wrapper";function qZe(t){let{components:n,...e}=t;return(0,s.kt)(VZe,(0,p.Z)({},UZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}qZe.isMDXComponent=!0;const jZe={toc:[]},YZe="wrapper";function QZe(t){let{components:n,...e}=t;return(0,s.kt)(YZe,(0,p.Z)({},jZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}QZe.isMDXComponent=!0;const HZe={toc:[]},$Ze="wrapper";function KZe(t){let{components:n,...e}=t;return(0,s.kt)($Ze,(0,p.Z)({},HZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}KZe.isMDXComponent=!0;const JZe={toc:[]},tbe="wrapper";function nbe(t){let{components:n,...e}=t;return(0,s.kt)(tbe,(0,p.Z)({},JZe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}nbe.isMDXComponent=!0;const ebe={toc:[]},obe="wrapper";function pbe(t){let{components:n,...e}=t;return(0,s.kt)(obe,(0,p.Z)({},ebe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}pbe.isMDXComponent=!0;const rbe={toc:[]},sbe="wrapper";function cbe(t){let{components:n,...e}=t;return(0,s.kt)(sbe,(0,p.Z)({},rbe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}cbe.isMDXComponent=!0;const ibe={toc:[]},abe="wrapper";function lbe(t){let{components:n,...e}=t;return(0,s.kt)(abe,(0,p.Z)({},ibe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lbe.isMDXComponent=!0;const ube={toc:[]},mbe="wrapper";function dbe(t){let{components:n,...e}=t;return(0,s.kt)(mbe,(0,p.Z)({},ube,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}dbe.isMDXComponent=!0;const hbe={toc:[]},kbe="wrapper";function fbe(t){let{components:n,...e}=t;return(0,s.kt)(kbe,(0,p.Z)({},hbe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}fbe.isMDXComponent=!0;const ybe={toc:[]},Mbe="wrapper";function Dbe(t){let{components:n,...e}=t;return(0,s.kt)(Mbe,(0,p.Z)({},ybe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Dbe.isMDXComponent=!0;const Xbe={toc:[]},_be="wrapper";function wbe(t){let{components:n,...e}=t;return(0,s.kt)(_be,(0,p.Z)({},Xbe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}wbe.isMDXComponent=!0;const Tbe={toc:[]},Cbe="wrapper";function gbe(t){let{components:n,...e}=t;return(0,s.kt)(Cbe,(0,p.Z)({},Tbe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}gbe.isMDXComponent=!0;const xbe={toc:[]},vbe="wrapper";function Lbe(t){let{components:n,...e}=t;return(0,s.kt)(vbe,(0,p.Z)({},xbe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Lbe.isMDXComponent=!0;const Zbe={toc:[]},bbe="wrapper";function Nbe(t){let{components:n,...e}=t;return(0,s.kt)(bbe,(0,p.Z)({},Zbe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Nbe.isMDXComponent=!0;const Abe={toc:[]},zbe="wrapper";function Wbe(t){let{components:n,...e}=t;return(0,s.kt)(zbe,(0,p.Z)({},Abe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Wbe.isMDXComponent=!0;const Ibe={toc:[]},Rbe="wrapper";function Pbe(t){let{components:n,...e}=t;return(0,s.kt)(Rbe,(0,p.Z)({},Ibe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Pbe.isMDXComponent=!0;const Sbe={toc:[]},Ebe="wrapper";function Gbe(t){let{components:n,...e}=t;return(0,s.kt)(Ebe,(0,p.Z)({},Sbe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Gbe.isMDXComponent=!0;const Obe={toc:[]},Fbe="wrapper";function Bbe(t){let{components:n,...e}=t;return(0,s.kt)(Fbe,(0,p.Z)({},Obe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Bbe.isMDXComponent=!0;const Ube={toc:[]},Vbe="wrapper";function qbe(t){let{components:n,...e}=t;return(0,s.kt)(Vbe,(0,p.Z)({},Ube,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}qbe.isMDXComponent=!0;const jbe={toc:[]},Ybe="wrapper";function Qbe(t){let{components:n,...e}=t;return(0,s.kt)(Ybe,(0,p.Z)({},jbe,e,{components:n,mdxType:"MDXLayout"}))}Qbe.isMDXComponent=!0;const Hbe={toc:[]},$be="wrapper";function Kbe(t){let{components:n,...e}=t;return(0,s.kt)($be,(0,p.Z)({},Hbe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Kbe.isMDXComponent=!0;const Jbe={toc:[]},tNe="wrapper";function nNe(t){let{components:n,...e}=t;return(0,s.kt)(tNe,(0,p.Z)({},Jbe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}nNe.isMDXComponent=!0;const eNe={toc:[]},oNe="wrapper";function pNe(t){let{components:n,...e}=t;return(0,s.kt)(oNe,(0,p.Z)({},eNe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pNe.isMDXComponent=!0;const rNe={toc:[]},sNe="wrapper";function cNe(t){let{components:n,...e}=t;return(0,s.kt)(sNe,(0,p.Z)({},rNe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}cNe.isMDXComponent=!0;const iNe={toc:[]},aNe="wrapper";function lNe(t){let{components:n,...e}=t;return(0,s.kt)(aNe,(0,p.Z)({},iNe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lNe.isMDXComponent=!0;const uNe={toc:[]},mNe="wrapper";function dNe(t){let{components:n,...e}=t;return(0,s.kt)(mNe,(0,p.Z)({},uNe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}dNe.isMDXComponent=!0;const hNe={toc:[]},kNe="wrapper";function fNe(t){let{components:n,...e}=t;return(0,s.kt)(kNe,(0,p.Z)({},hNe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}fNe.isMDXComponent=!0;const yNe={toc:[]},MNe="wrapper";function DNe(t){let{components:n,...e}=t;return(0,s.kt)(MNe,(0,p.Z)({},yNe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}DNe.isMDXComponent=!0;const XNe={toc:[]},_Ne="wrapper";function wNe(t){let{components:n,...e}=t;return(0,s.kt)(_Ne,(0,p.Z)({},XNe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}wNe.isMDXComponent=!0;const TNe={toc:[]},CNe="wrapper";function gNe(t){let{components:n,...e}=t;return(0,s.kt)(CNe,(0,p.Z)({},TNe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}gNe.isMDXComponent=!0;const xNe={toc:[]},vNe="wrapper";function LNe(t){let{components:n,...e}=t;return(0,s.kt)(vNe,(0,p.Z)({},xNe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}LNe.isMDXComponent=!0;const ZNe={toc:[]},bNe="wrapper";function NNe(t){let{components:n,...e}=t;return(0,s.kt)(bNe,(0,p.Z)({},ZNe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}NNe.isMDXComponent=!0;const ANe={toc:[]},zNe="wrapper";function WNe(t){let{components:n,...e}=t;return(0,s.kt)(zNe,(0,p.Z)({},ANe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}WNe.isMDXComponent=!0;const INe={toc:[]},RNe="wrapper";function PNe(t){let{components:n,...e}=t;return(0,s.kt)(RNe,(0,p.Z)({},INe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}PNe.isMDXComponent=!0;const SNe={toc:[]},ENe="wrapper";function GNe(t){let{components:n,...e}=t;return(0,s.kt)(ENe,(0,p.Z)({},SNe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}GNe.isMDXComponent=!0;const ONe={toc:[]},FNe="wrapper";function BNe(t){let{components:n,...e}=t;return(0,s.kt)(FNe,(0,p.Z)({},ONe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}BNe.isMDXComponent=!0;const UNe={toc:[]},VNe="wrapper";function qNe(t){let{components:n,...e}=t;return(0,s.kt)(VNe,(0,p.Z)({},UNe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}qNe.isMDXComponent=!0;const jNe={toc:[]},YNe="wrapper";function QNe(t){let{components:n,...e}=t;return(0,s.kt)(YNe,(0,p.Z)({},jNe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}QNe.isMDXComponent=!0;const HNe={toc:[]},$Ne="wrapper";function KNe(t){let{components:n,...e}=t;return(0,s.kt)($Ne,(0,p.Z)({},HNe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}KNe.isMDXComponent=!0;const JNe={toc:[]},tAe="wrapper";function nAe(t){let{components:n,...e}=t;return(0,s.kt)(tAe,(0,p.Z)({},JNe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}nAe.isMDXComponent=!0;const eAe={toc:[]},oAe="wrapper";function pAe(t){let{components:n,...e}=t;return(0,s.kt)(oAe,(0,p.Z)({},eAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}pAe.isMDXComponent=!0;const rAe={toc:[]},sAe="wrapper";function cAe(t){let{components:n,...e}=t;return(0,s.kt)(sAe,(0,p.Z)({},rAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}cAe.isMDXComponent=!0;const iAe={toc:[]},aAe="wrapper";function lAe(t){let{components:n,...e}=t;return(0,s.kt)(aAe,(0,p.Z)({},iAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}lAe.isMDXComponent=!0;const uAe={toc:[]},mAe="wrapper";function dAe(t){let{components:n,...e}=t;return(0,s.kt)(mAe,(0,p.Z)({},uAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}dAe.isMDXComponent=!0;const hAe={toc:[]},kAe="wrapper";function fAe(t){let{components:n,...e}=t;return(0,s.kt)(kAe,(0,p.Z)({},hAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}fAe.isMDXComponent=!0;const yAe={toc:[]},MAe="wrapper";function DAe(t){let{components:n,...e}=t;return(0,s.kt)(MAe,(0,p.Z)({},yAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}DAe.isMDXComponent=!0;const XAe={toc:[]},_Ae="wrapper";function wAe(t){let{components:n,...e}=t;return(0,s.kt)(_Ae,(0,p.Z)({},XAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}wAe.isMDXComponent=!0;const TAe={toc:[]},CAe="wrapper";function gAe(t){let{components:n,...e}=t;return(0,s.kt)(CAe,(0,p.Z)({},TAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}gAe.isMDXComponent=!0;const xAe={toc:[]},vAe="wrapper";function LAe(t){let{components:n,...e}=t;return(0,s.kt)(vAe,(0,p.Z)({},xAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}LAe.isMDXComponent=!0;const ZAe={toc:[]},bAe="wrapper";function NAe(t){let{components:n,...e}=t;return(0,s.kt)(bAe,(0,p.Z)({},ZAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}NAe.isMDXComponent=!0;const AAe={toc:[]},zAe="wrapper";function WAe(t){let{components:n,...e}=t;return(0,s.kt)(zAe,(0,p.Z)({},AAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}WAe.isMDXComponent=!0;const IAe={toc:[]},RAe="wrapper";function PAe(t){let{components:n,...e}=t;return(0,s.kt)(RAe,(0,p.Z)({},IAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}PAe.isMDXComponent=!0;const SAe={toc:[]},EAe="wrapper";function GAe(t){let{components:n,...e}=t;return(0,s.kt)(EAe,(0,p.Z)({},SAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}GAe.isMDXComponent=!0;const OAe={toc:[]},FAe="wrapper";function BAe(t){let{components:n,...e}=t;return(0,s.kt)(FAe,(0,p.Z)({},OAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}BAe.isMDXComponent=!0;const UAe={toc:[]},VAe="wrapper";function qAe(t){let{components:n,...e}=t;return(0,s.kt)(VAe,(0,p.Z)({},UAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}qAe.isMDXComponent=!0;const jAe={toc:[]},YAe="wrapper";function QAe(t){let{components:n,...e}=t;return(0,s.kt)(YAe,(0,p.Z)({},jAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}QAe.isMDXComponent=!0;const HAe={toc:[]},$Ae="wrapper";function KAe(t){let{components:n,...e}=t;return(0,s.kt)($Ae,(0,p.Z)({},HAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}KAe.isMDXComponent=!0;const JAe={toc:[]},tze="wrapper";function nze(t){let{components:n,...e}=t;return(0,s.kt)(tze,(0,p.Z)({},JAe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}nze.isMDXComponent=!0;const eze={toc:[]},oze="wrapper";function pze(t){let{components:n,...e}=t;return(0,s.kt)(oze,(0,p.Z)({},eze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}pze.isMDXComponent=!0;const rze={toc:[]},sze="wrapper";function cze(t){let{components:n,...e}=t;return(0,s.kt)(sze,(0,p.Z)({},rze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}cze.isMDXComponent=!0;const ize={toc:[]},aze="wrapper";function lze(t){let{components:n,...e}=t;return(0,s.kt)(aze,(0,p.Z)({},ize,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}lze.isMDXComponent=!0;const uze={toc:[]},mze="wrapper";function dze(t){let{components:n,...e}=t;return(0,s.kt)(mze,(0,p.Z)({},uze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}dze.isMDXComponent=!0;const hze={toc:[]},kze="wrapper";function fze(t){let{components:n,...e}=t;return(0,s.kt)(kze,(0,p.Z)({},hze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}fze.isMDXComponent=!0;const yze={toc:[]},Mze="wrapper";function Dze(t){let{components:n,...e}=t;return(0,s.kt)(Mze,(0,p.Z)({},yze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Dze.isMDXComponent=!0;const Xze={toc:[]},_ze="wrapper";function wze(t){let{components:n,...e}=t;return(0,s.kt)(_ze,(0,p.Z)({},Xze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}wze.isMDXComponent=!0;const Tze={toc:[]},Cze="wrapper";function gze(t){let{components:n,...e}=t;return(0,s.kt)(Cze,(0,p.Z)({},Tze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}gze.isMDXComponent=!0;const xze={toc:[]},vze="wrapper";function Lze(t){let{components:n,...e}=t;return(0,s.kt)(vze,(0,p.Z)({},xze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Lze.isMDXComponent=!0;const Zze={toc:[]},bze="wrapper";function Nze(t){let{components:n,...e}=t;return(0,s.kt)(bze,(0,p.Z)({},Zze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Nze.isMDXComponent=!0;const Aze={toc:[]},zze="wrapper";function Wze(t){let{components:n,...e}=t;return(0,s.kt)(zze,(0,p.Z)({},Aze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Wze.isMDXComponent=!0;const Ize={toc:[]},Rze="wrapper";function Pze(t){let{components:n,...e}=t;return(0,s.kt)(Rze,(0,p.Z)({},Ize,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Pze.isMDXComponent=!0;const Sze={toc:[]},Eze="wrapper";function Gze(t){let{components:n,...e}=t;return(0,s.kt)(Eze,(0,p.Z)({},Sze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Gze.isMDXComponent=!0;const Oze={toc:[]},Fze="wrapper";function Bze(t){let{components:n,...e}=t;return(0,s.kt)(Fze,(0,p.Z)({},Oze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Bze.isMDXComponent=!0;const Uze={toc:[]},Vze="wrapper";function qze(t){let{components:n,...e}=t;return(0,s.kt)(Vze,(0,p.Z)({},Uze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}qze.isMDXComponent=!0;const jze={toc:[]},Yze="wrapper";function Qze(t){let{components:n,...e}=t;return(0,s.kt)(Yze,(0,p.Z)({},jze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Qze.isMDXComponent=!0;const Hze={toc:[]},$ze="wrapper";function Kze(t){let{components:n,...e}=t;return(0,s.kt)($ze,(0,p.Z)({},Hze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Kze.isMDXComponent=!0;const Jze={toc:[]},tWe="wrapper";function nWe(t){let{components:n,...e}=t;return(0,s.kt)(tWe,(0,p.Z)({},Jze,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}nWe.isMDXComponent=!0;const eWe={toc:[]},oWe="wrapper";function pWe(t){let{components:n,...e}=t;return(0,s.kt)(oWe,(0,p.Z)({},eWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pWe.isMDXComponent=!0;const rWe={toc:[]},sWe="wrapper";function cWe(t){let{components:n,...e}=t;return(0,s.kt)(sWe,(0,p.Z)({},rWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}cWe.isMDXComponent=!0;const iWe={toc:[]},aWe="wrapper";function lWe(t){let{components:n,...e}=t;return(0,s.kt)(aWe,(0,p.Z)({},iWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lWe.isMDXComponent=!0;const uWe={toc:[]},mWe="wrapper";function dWe(t){let{components:n,...e}=t;return(0,s.kt)(mWe,(0,p.Z)({},uWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}dWe.isMDXComponent=!0;const hWe={toc:[]},kWe="wrapper";function fWe(t){let{components:n,...e}=t;return(0,s.kt)(kWe,(0,p.Z)({},hWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}fWe.isMDXComponent=!0;const yWe={toc:[]},MWe="wrapper";function DWe(t){let{components:n,...e}=t;return(0,s.kt)(MWe,(0,p.Z)({},yWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}DWe.isMDXComponent=!0;const XWe={toc:[]},_We="wrapper";function wWe(t){let{components:n,...e}=t;return(0,s.kt)(_We,(0,p.Z)({},XWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wWe.isMDXComponent=!0;const TWe={toc:[]},CWe="wrapper";function gWe(t){let{components:n,...e}=t;return(0,s.kt)(CWe,(0,p.Z)({},TWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}gWe.isMDXComponent=!0;const xWe={toc:[]},vWe="wrapper";function LWe(t){let{components:n,...e}=t;return(0,s.kt)(vWe,(0,p.Z)({},xWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}LWe.isMDXComponent=!0;const ZWe={toc:[]},bWe="wrapper";function NWe(t){let{components:n,...e}=t;return(0,s.kt)(bWe,(0,p.Z)({},ZWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}NWe.isMDXComponent=!0;const AWe={toc:[]},zWe="wrapper";function WWe(t){let{components:n,...e}=t;return(0,s.kt)(zWe,(0,p.Z)({},AWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}WWe.isMDXComponent=!0;const IWe={toc:[]},RWe="wrapper";function PWe(t){let{components:n,...e}=t;return(0,s.kt)(RWe,(0,p.Z)({},IWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}PWe.isMDXComponent=!0;const SWe={toc:[]},EWe="wrapper";function GWe(t){let{components:n,...e}=t;return(0,s.kt)(EWe,(0,p.Z)({},SWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}GWe.isMDXComponent=!0;const OWe={toc:[]},FWe="wrapper";function BWe(t){let{components:n,...e}=t;return(0,s.kt)(FWe,(0,p.Z)({},OWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}BWe.isMDXComponent=!0;const UWe={toc:[]},VWe="wrapper";function qWe(t){let{components:n,...e}=t;return(0,s.kt)(VWe,(0,p.Z)({},UWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}qWe.isMDXComponent=!0;const jWe={toc:[]},YWe="wrapper";function QWe(t){let{components:n,...e}=t;return(0,s.kt)(YWe,(0,p.Z)({},jWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}QWe.isMDXComponent=!0;const HWe={toc:[]},$We="wrapper";function KWe(t){let{components:n,...e}=t;return(0,s.kt)($We,(0,p.Z)({},HWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}KWe.isMDXComponent=!0;const JWe={toc:[]},tIe="wrapper";function nIe(t){let{components:n,...e}=t;return(0,s.kt)(tIe,(0,p.Z)({},JWe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}nIe.isMDXComponent=!0;const eIe={toc:[]},oIe="wrapper";function pIe(t){let{components:n,...e}=t;return(0,s.kt)(oIe,(0,p.Z)({},eIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}pIe.isMDXComponent=!0;const rIe={toc:[]},sIe="wrapper";function cIe(t){let{components:n,...e}=t;return(0,s.kt)(sIe,(0,p.Z)({},rIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}cIe.isMDXComponent=!0;const iIe={toc:[]},aIe="wrapper";function lIe(t){let{components:n,...e}=t;return(0,s.kt)(aIe,(0,p.Z)({},iIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}lIe.isMDXComponent=!0;const uIe={toc:[]},mIe="wrapper";function dIe(t){let{components:n,...e}=t;return(0,s.kt)(mIe,(0,p.Z)({},uIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}dIe.isMDXComponent=!0;const hIe={toc:[]},kIe="wrapper";function fIe(t){let{components:n,...e}=t;return(0,s.kt)(kIe,(0,p.Z)({},hIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}fIe.isMDXComponent=!0;const yIe={toc:[]},MIe="wrapper";function DIe(t){let{components:n,...e}=t;return(0,s.kt)(MIe,(0,p.Z)({},yIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}DIe.isMDXComponent=!0;const XIe={toc:[]},_Ie="wrapper";function wIe(t){let{components:n,...e}=t;return(0,s.kt)(_Ie,(0,p.Z)({},XIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}wIe.isMDXComponent=!0;const TIe={toc:[]},CIe="wrapper";function gIe(t){let{components:n,...e}=t;return(0,s.kt)(CIe,(0,p.Z)({},TIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}gIe.isMDXComponent=!0;const xIe={toc:[]},vIe="wrapper";function LIe(t){let{components:n,...e}=t;return(0,s.kt)(vIe,(0,p.Z)({},xIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}LIe.isMDXComponent=!0;const ZIe={toc:[]},bIe="wrapper";function NIe(t){let{components:n,...e}=t;return(0,s.kt)(bIe,(0,p.Z)({},ZIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}NIe.isMDXComponent=!0;const AIe={toc:[]},zIe="wrapper";function WIe(t){let{components:n,...e}=t;return(0,s.kt)(zIe,(0,p.Z)({},AIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}WIe.isMDXComponent=!0;const IIe={toc:[]},RIe="wrapper";function PIe(t){let{components:n,...e}=t;return(0,s.kt)(RIe,(0,p.Z)({},IIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}PIe.isMDXComponent=!0;const SIe={toc:[]},EIe="wrapper";function GIe(t){let{components:n,...e}=t;return(0,s.kt)(EIe,(0,p.Z)({},SIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}GIe.isMDXComponent=!0;const OIe={toc:[]},FIe="wrapper";function BIe(t){let{components:n,...e}=t;return(0,s.kt)(FIe,(0,p.Z)({},OIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}BIe.isMDXComponent=!0;const UIe={toc:[]},VIe="wrapper";function qIe(t){let{components:n,...e}=t;return(0,s.kt)(VIe,(0,p.Z)({},UIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}qIe.isMDXComponent=!0;const jIe={toc:[]},YIe="wrapper";function QIe(t){let{components:n,...e}=t;return(0,s.kt)(YIe,(0,p.Z)({},jIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}QIe.isMDXComponent=!0;const HIe={toc:[]},$Ie="wrapper";function KIe(t){let{components:n,...e}=t;return(0,s.kt)($Ie,(0,p.Z)({},HIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}KIe.isMDXComponent=!0;const JIe={toc:[]},tRe="wrapper";function nRe(t){let{components:n,...e}=t;return(0,s.kt)(tRe,(0,p.Z)({},JIe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}nRe.isMDXComponent=!0;const eRe={toc:[]},oRe="wrapper";function pRe(t){let{components:n,...e}=t;return(0,s.kt)(oRe,(0,p.Z)({},eRe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}pRe.isMDXComponent=!0;const rRe={toc:[]},sRe="wrapper";function cRe(t){let{components:n,...e}=t;return(0,s.kt)(sRe,(0,p.Z)({},rRe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}cRe.isMDXComponent=!0;const iRe={toc:[]},aRe="wrapper";function lRe(t){let{components:n,...e}=t;return(0,s.kt)(aRe,(0,p.Z)({},iRe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}lRe.isMDXComponent=!0;const uRe={toc:[]},mRe="wrapper";function dRe(t){let{components:n,...e}=t;return(0,s.kt)(mRe,(0,p.Z)({},uRe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}dRe.isMDXComponent=!0;const hRe={toc:[]},kRe="wrapper";function fRe(t){let{components:n,...e}=t;return(0,s.kt)(kRe,(0,p.Z)({},hRe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}fRe.isMDXComponent=!0;const yRe={toc:[]},MRe="wrapper";function DRe(t){let{components:n,...e}=t;return(0,s.kt)(MRe,(0,p.Z)({},yRe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}DRe.isMDXComponent=!0;const XRe={toc:[]},_Re="wrapper";function wRe(t){let{components:n,...e}=t;return(0,s.kt)(_Re,(0,p.Z)({},XRe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}wRe.isMDXComponent=!0;const TRe={toc:[]},CRe="wrapper";function gRe(t){let{components:n,...e}=t;return(0,s.kt)(CRe,(0,p.Z)({},TRe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}gRe.isMDXComponent=!0;const xRe={toc:[]},vRe="wrapper";function LRe(t){let{components:n,...e}=t;return(0,s.kt)(vRe,(0,p.Z)({},xRe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}LRe.isMDXComponent=!0;const ZRe={toc:[]},bRe="wrapper";function NRe(t){let{components:n,...e}=t;return(0,s.kt)(bRe,(0,p.Z)({},ZRe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}NRe.isMDXComponent=!0;const ARe={toc:[]},zRe="wrapper";function WRe(t){let{components:n,...e}=t;return(0,s.kt)(zRe,(0,p.Z)({},ARe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}WRe.isMDXComponent=!0;const IRe={toc:[]},RRe="wrapper";function PRe(t){let{components:n,...e}=t;return(0,s.kt)(RRe,(0,p.Z)({},IRe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}PRe.isMDXComponent=!0;const SRe={toc:[]},ERe="wrapper";function GRe(t){let{components:n,...e}=t;return(0,s.kt)(ERe,(0,p.Z)({},SRe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}GRe.isMDXComponent=!0;const ORe={toc:[]},FRe="wrapper";function BRe(t){let{components:n,...e}=t;return(0,s.kt)(FRe,(0,p.Z)({},ORe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}BRe.isMDXComponent=!0;const URe={toc:[]},VRe="wrapper";function qRe(t){let{components:n,...e}=t;return(0,s.kt)(VRe,(0,p.Z)({},URe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}qRe.isMDXComponent=!0;const jRe={toc:[]},YRe="wrapper";function QRe(t){let{components:n,...e}=t;return(0,s.kt)(YRe,(0,p.Z)({},jRe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}QRe.isMDXComponent=!0;const HRe={toc:[]},$Re="wrapper";function KRe(t){let{components:n,...e}=t;return(0,s.kt)($Re,(0,p.Z)({},HRe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}KRe.isMDXComponent=!0;const JRe={toc:[]},tPe="wrapper";function nPe(t){let{components:n,...e}=t;return(0,s.kt)(tPe,(0,p.Z)({},JRe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}nPe.isMDXComponent=!0;const ePe={toc:[]},oPe="wrapper";function pPe(t){let{components:n,...e}=t;return(0,s.kt)(oPe,(0,p.Z)({},ePe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}pPe.isMDXComponent=!0;const rPe={toc:[]},sPe="wrapper";function cPe(t){let{components:n,...e}=t;return(0,s.kt)(sPe,(0,p.Z)({},rPe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}cPe.isMDXComponent=!0;const iPe={toc:[]},aPe="wrapper";function lPe(t){let{components:n,...e}=t;return(0,s.kt)(aPe,(0,p.Z)({},iPe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}lPe.isMDXComponent=!0;const uPe={toc:[]},mPe="wrapper";function dPe(t){let{components:n,...e}=t;return(0,s.kt)(mPe,(0,p.Z)({},uPe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}dPe.isMDXComponent=!0;const hPe={toc:[]},kPe="wrapper";function fPe(t){let{components:n,...e}=t;return(0,s.kt)(kPe,(0,p.Z)({},hPe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}fPe.isMDXComponent=!0;const yPe={toc:[]},MPe="wrapper";function DPe(t){let{components:n,...e}=t;return(0,s.kt)(MPe,(0,p.Z)({},yPe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}DPe.isMDXComponent=!0;const XPe={toc:[]},_Pe="wrapper";function wPe(t){let{components:n,...e}=t;return(0,s.kt)(_Pe,(0,p.Z)({},XPe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}wPe.isMDXComponent=!0;const TPe={toc:[]},CPe="wrapper";function gPe(t){let{components:n,...e}=t;return(0,s.kt)(CPe,(0,p.Z)({},TPe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}gPe.isMDXComponent=!0;const xPe={toc:[]},vPe="wrapper";function LPe(t){let{components:n,...e}=t;return(0,s.kt)(vPe,(0,p.Z)({},xPe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}LPe.isMDXComponent=!0;const ZPe={toc:[]},bPe="wrapper";function NPe(t){let{components:n,...e}=t;return(0,s.kt)(bPe,(0,p.Z)({},ZPe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}NPe.isMDXComponent=!0;const APe={toc:[]},zPe="wrapper";function WPe(t){let{components:n,...e}=t;return(0,s.kt)(zPe,(0,p.Z)({},APe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}WPe.isMDXComponent=!0;const IPe={toc:[]},RPe="wrapper";function PPe(t){let{components:n,...e}=t;return(0,s.kt)(RPe,(0,p.Z)({},IPe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}PPe.isMDXComponent=!0;const SPe={toc:[]},EPe="wrapper";function GPe(t){let{components:n,...e}=t;return(0,s.kt)(EPe,(0,p.Z)({},SPe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}GPe.isMDXComponent=!0;const OPe={toc:[]},FPe="wrapper";function BPe(t){let{components:n,...e}=t;return(0,s.kt)(FPe,(0,p.Z)({},OPe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}BPe.isMDXComponent=!0;const UPe={toc:[]},VPe="wrapper";function qPe(t){let{components:n,...e}=t;return(0,s.kt)(VPe,(0,p.Z)({},UPe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qPe.isMDXComponent=!0;const jPe={toc:[]},YPe="wrapper";function QPe(t){let{components:n,...e}=t;return(0,s.kt)(YPe,(0,p.Z)({},jPe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}QPe.isMDXComponent=!0;const HPe={toc:[]},$Pe="wrapper";function KPe(t){let{components:n,...e}=t;return(0,s.kt)($Pe,(0,p.Z)({},HPe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}KPe.isMDXComponent=!0;const JPe={toc:[]},tSe="wrapper";function nSe(t){let{components:n,...e}=t;return(0,s.kt)(tSe,(0,p.Z)({},JPe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}nSe.isMDXComponent=!0;const eSe={toc:[]},oSe="wrapper";function pSe(t){let{components:n,...e}=t;return(0,s.kt)(oSe,(0,p.Z)({},eSe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}pSe.isMDXComponent=!0;const rSe={toc:[]},sSe="wrapper";function cSe(t){let{components:n,...e}=t;return(0,s.kt)(sSe,(0,p.Z)({},rSe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cSe.isMDXComponent=!0;const iSe={toc:[]},aSe="wrapper";function lSe(t){let{components:n,...e}=t;return(0,s.kt)(aSe,(0,p.Z)({},iSe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lSe.isMDXComponent=!0;const uSe={toc:[]},mSe="wrapper";function dSe(t){let{components:n,...e}=t;return(0,s.kt)(mSe,(0,p.Z)({},uSe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}dSe.isMDXComponent=!0;const hSe={toc:[]},kSe="wrapper";function fSe(t){let{components:n,...e}=t;return(0,s.kt)(kSe,(0,p.Z)({},hSe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}fSe.isMDXComponent=!0;const ySe={toc:[]},MSe="wrapper";function DSe(t){let{components:n,...e}=t;return(0,s.kt)(MSe,(0,p.Z)({},ySe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}DSe.isMDXComponent=!0;const XSe={toc:[]},_Se="wrapper";function wSe(t){let{components:n,...e}=t;return(0,s.kt)(_Se,(0,p.Z)({},XSe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}wSe.isMDXComponent=!0;const TSe={toc:[]},CSe="wrapper";function gSe(t){let{components:n,...e}=t;return(0,s.kt)(CSe,(0,p.Z)({},TSe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}gSe.isMDXComponent=!0;const xSe={toc:[]},vSe="wrapper";function LSe(t){let{components:n,...e}=t;return(0,s.kt)(vSe,(0,p.Z)({},xSe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}LSe.isMDXComponent=!0;const ZSe={toc:[]},bSe="wrapper";function NSe(t){let{components:n,...e}=t;return(0,s.kt)(bSe,(0,p.Z)({},ZSe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}NSe.isMDXComponent=!0;const ASe={toc:[]},zSe="wrapper";function WSe(t){let{components:n,...e}=t;return(0,s.kt)(zSe,(0,p.Z)({},ASe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}WSe.isMDXComponent=!0;const ISe={toc:[]},RSe="wrapper";function PSe(t){let{components:n,...e}=t;return(0,s.kt)(RSe,(0,p.Z)({},ISe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}PSe.isMDXComponent=!0;const SSe={toc:[]},ESe="wrapper";function GSe(t){let{components:n,...e}=t;return(0,s.kt)(ESe,(0,p.Z)({},SSe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}GSe.isMDXComponent=!0;const OSe={toc:[]},FSe="wrapper";function BSe(t){let{components:n,...e}=t;return(0,s.kt)(FSe,(0,p.Z)({},OSe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}BSe.isMDXComponent=!0;const USe={toc:[]},VSe="wrapper";function qSe(t){let{components:n,...e}=t;return(0,s.kt)(VSe,(0,p.Z)({},USe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qSe.isMDXComponent=!0;const jSe={toc:[]},YSe="wrapper";function QSe(t){let{components:n,...e}=t;return(0,s.kt)(YSe,(0,p.Z)({},jSe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}QSe.isMDXComponent=!0;const HSe={toc:[]},$Se="wrapper";function KSe(t){let{components:n,...e}=t;return(0,s.kt)($Se,(0,p.Z)({},HSe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}KSe.isMDXComponent=!0;const JSe={toc:[]},tEe="wrapper";function nEe(t){let{components:n,...e}=t;return(0,s.kt)(tEe,(0,p.Z)({},JSe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}nEe.isMDXComponent=!0;const eEe={toc:[]},oEe="wrapper";function pEe(t){let{components:n,...e}=t;return(0,s.kt)(oEe,(0,p.Z)({},eEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}pEe.isMDXComponent=!0;const rEe={toc:[]},sEe="wrapper";function cEe(t){let{components:n,...e}=t;return(0,s.kt)(sEe,(0,p.Z)({},rEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}cEe.isMDXComponent=!0;const iEe={toc:[]},aEe="wrapper";function lEe(t){let{components:n,...e}=t;return(0,s.kt)(aEe,(0,p.Z)({},iEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}lEe.isMDXComponent=!0;const uEe={toc:[]},mEe="wrapper";function dEe(t){let{components:n,...e}=t;return(0,s.kt)(mEe,(0,p.Z)({},uEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}dEe.isMDXComponent=!0;const hEe={toc:[]},kEe="wrapper";function fEe(t){let{components:n,...e}=t;return(0,s.kt)(kEe,(0,p.Z)({},hEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}fEe.isMDXComponent=!0;const yEe={toc:[]},MEe="wrapper";function DEe(t){let{components:n,...e}=t;return(0,s.kt)(MEe,(0,p.Z)({},yEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}DEe.isMDXComponent=!0;const XEe={toc:[]},_Ee="wrapper";function wEe(t){let{components:n,...e}=t;return(0,s.kt)(_Ee,(0,p.Z)({},XEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}wEe.isMDXComponent=!0;const TEe={toc:[]},CEe="wrapper";function gEe(t){let{components:n,...e}=t;return(0,s.kt)(CEe,(0,p.Z)({},TEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}gEe.isMDXComponent=!0;const xEe={toc:[]},vEe="wrapper";function LEe(t){let{components:n,...e}=t;return(0,s.kt)(vEe,(0,p.Z)({},xEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}LEe.isMDXComponent=!0;const ZEe={toc:[]},bEe="wrapper";function NEe(t){let{components:n,...e}=t;return(0,s.kt)(bEe,(0,p.Z)({},ZEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}NEe.isMDXComponent=!0;const AEe={toc:[]},zEe="wrapper";function WEe(t){let{components:n,...e}=t;return(0,s.kt)(zEe,(0,p.Z)({},AEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}WEe.isMDXComponent=!0;const IEe={toc:[]},REe="wrapper";function PEe(t){let{components:n,...e}=t;return(0,s.kt)(REe,(0,p.Z)({},IEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}PEe.isMDXComponent=!0;const SEe={toc:[]},EEe="wrapper";function GEe(t){let{components:n,...e}=t;return(0,s.kt)(EEe,(0,p.Z)({},SEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}GEe.isMDXComponent=!0;const OEe={toc:[]},FEe="wrapper";function BEe(t){let{components:n,...e}=t;return(0,s.kt)(FEe,(0,p.Z)({},OEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}BEe.isMDXComponent=!0;const UEe={toc:[]},VEe="wrapper";function qEe(t){let{components:n,...e}=t;return(0,s.kt)(VEe,(0,p.Z)({},UEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qEe.isMDXComponent=!0;const jEe={toc:[]},YEe="wrapper";function QEe(t){let{components:n,...e}=t;return(0,s.kt)(YEe,(0,p.Z)({},jEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}QEe.isMDXComponent=!0;const HEe={toc:[]},$Ee="wrapper";function KEe(t){let{components:n,...e}=t;return(0,s.kt)($Ee,(0,p.Z)({},HEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}KEe.isMDXComponent=!0;const JEe={toc:[]},tGe="wrapper";function nGe(t){let{components:n,...e}=t;return(0,s.kt)(tGe,(0,p.Z)({},JEe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}nGe.isMDXComponent=!0;const eGe={toc:[]},oGe="wrapper";function pGe(t){let{components:n,...e}=t;return(0,s.kt)(oGe,(0,p.Z)({},eGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}pGe.isMDXComponent=!0;const rGe={toc:[]},sGe="wrapper";function cGe(t){let{components:n,...e}=t;return(0,s.kt)(sGe,(0,p.Z)({},rGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}cGe.isMDXComponent=!0;const iGe={toc:[]},aGe="wrapper";function lGe(t){let{components:n,...e}=t;return(0,s.kt)(aGe,(0,p.Z)({},iGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}lGe.isMDXComponent=!0;const uGe={toc:[]},mGe="wrapper";function dGe(t){let{components:n,...e}=t;return(0,s.kt)(mGe,(0,p.Z)({},uGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}dGe.isMDXComponent=!0;const hGe={toc:[]},kGe="wrapper";function fGe(t){let{components:n,...e}=t;return(0,s.kt)(kGe,(0,p.Z)({},hGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}fGe.isMDXComponent=!0;const yGe={toc:[]},MGe="wrapper";function DGe(t){let{components:n,...e}=t;return(0,s.kt)(MGe,(0,p.Z)({},yGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}DGe.isMDXComponent=!0;const XGe={toc:[]},_Ge="wrapper";function wGe(t){let{components:n,...e}=t;return(0,s.kt)(_Ge,(0,p.Z)({},XGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}wGe.isMDXComponent=!0;const TGe={toc:[]},CGe="wrapper";function gGe(t){let{components:n,...e}=t;return(0,s.kt)(CGe,(0,p.Z)({},TGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}gGe.isMDXComponent=!0;const xGe={toc:[]},vGe="wrapper";function LGe(t){let{components:n,...e}=t;return(0,s.kt)(vGe,(0,p.Z)({},xGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}LGe.isMDXComponent=!0;const ZGe={toc:[]},bGe="wrapper";function NGe(t){let{components:n,...e}=t;return(0,s.kt)(bGe,(0,p.Z)({},ZGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}NGe.isMDXComponent=!0;const AGe={toc:[]},zGe="wrapper";function WGe(t){let{components:n,...e}=t;return(0,s.kt)(zGe,(0,p.Z)({},AGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}WGe.isMDXComponent=!0;const IGe={toc:[]},RGe="wrapper";function PGe(t){let{components:n,...e}=t;return(0,s.kt)(RGe,(0,p.Z)({},IGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}PGe.isMDXComponent=!0;const SGe={toc:[]},EGe="wrapper";function GGe(t){let{components:n,...e}=t;return(0,s.kt)(EGe,(0,p.Z)({},SGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}GGe.isMDXComponent=!0;const OGe={toc:[]},FGe="wrapper";function BGe(t){let{components:n,...e}=t;return(0,s.kt)(FGe,(0,p.Z)({},OGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}BGe.isMDXComponent=!0;const UGe={toc:[]},VGe="wrapper";function qGe(t){let{components:n,...e}=t;return(0,s.kt)(VGe,(0,p.Z)({},UGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}qGe.isMDXComponent=!0;const jGe={toc:[]},YGe="wrapper";function QGe(t){let{components:n,...e}=t;return(0,s.kt)(YGe,(0,p.Z)({},jGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}QGe.isMDXComponent=!0;const HGe={toc:[]},$Ge="wrapper";function KGe(t){let{components:n,...e}=t;return(0,s.kt)($Ge,(0,p.Z)({},HGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}KGe.isMDXComponent=!0;const JGe={toc:[]},tOe="wrapper";function nOe(t){let{components:n,...e}=t;return(0,s.kt)(tOe,(0,p.Z)({},JGe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}nOe.isMDXComponent=!0;const eOe={toc:[]},oOe="wrapper";function pOe(t){let{components:n,...e}=t;return(0,s.kt)(oOe,(0,p.Z)({},eOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}pOe.isMDXComponent=!0;const rOe={toc:[]},sOe="wrapper";function cOe(t){let{components:n,...e}=t;return(0,s.kt)(sOe,(0,p.Z)({},rOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}cOe.isMDXComponent=!0;const iOe={toc:[]},aOe="wrapper";function lOe(t){let{components:n,...e}=t;return(0,s.kt)(aOe,(0,p.Z)({},iOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}lOe.isMDXComponent=!0;const uOe={toc:[]},mOe="wrapper";function dOe(t){let{components:n,...e}=t;return(0,s.kt)(mOe,(0,p.Z)({},uOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}dOe.isMDXComponent=!0;const hOe={toc:[]},kOe="wrapper";function fOe(t){let{components:n,...e}=t;return(0,s.kt)(kOe,(0,p.Z)({},hOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}fOe.isMDXComponent=!0;const yOe={toc:[]},MOe="wrapper";function DOe(t){let{components:n,...e}=t;return(0,s.kt)(MOe,(0,p.Z)({},yOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}DOe.isMDXComponent=!0;const XOe={toc:[]},_Oe="wrapper";function wOe(t){let{components:n,...e}=t;return(0,s.kt)(_Oe,(0,p.Z)({},XOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wOe.isMDXComponent=!0;const TOe={toc:[]},COe="wrapper";function gOe(t){let{components:n,...e}=t;return(0,s.kt)(COe,(0,p.Z)({},TOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}gOe.isMDXComponent=!0;const xOe={toc:[]},vOe="wrapper";function LOe(t){let{components:n,...e}=t;return(0,s.kt)(vOe,(0,p.Z)({},xOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}LOe.isMDXComponent=!0;const ZOe={toc:[]},bOe="wrapper";function NOe(t){let{components:n,...e}=t;return(0,s.kt)(bOe,(0,p.Z)({},ZOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}NOe.isMDXComponent=!0;const AOe={toc:[]},zOe="wrapper";function WOe(t){let{components:n,...e}=t;return(0,s.kt)(zOe,(0,p.Z)({},AOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}WOe.isMDXComponent=!0;const IOe={toc:[]},ROe="wrapper";function POe(t){let{components:n,...e}=t;return(0,s.kt)(ROe,(0,p.Z)({},IOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}POe.isMDXComponent=!0;const SOe={toc:[]},EOe="wrapper";function GOe(t){let{components:n,...e}=t;return(0,s.kt)(EOe,(0,p.Z)({},SOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}GOe.isMDXComponent=!0;const OOe={toc:[]},FOe="wrapper";function BOe(t){let{components:n,...e}=t;return(0,s.kt)(FOe,(0,p.Z)({},OOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}BOe.isMDXComponent=!0;const UOe={toc:[]},VOe="wrapper";function qOe(t){let{components:n,...e}=t;return(0,s.kt)(VOe,(0,p.Z)({},UOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qOe.isMDXComponent=!0;const jOe={toc:[]},YOe="wrapper";function QOe(t){let{components:n,...e}=t;return(0,s.kt)(YOe,(0,p.Z)({},jOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}QOe.isMDXComponent=!0;const HOe={toc:[]},$Oe="wrapper";function KOe(t){let{components:n,...e}=t;return(0,s.kt)($Oe,(0,p.Z)({},HOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}KOe.isMDXComponent=!0;const JOe={toc:[]},tFe="wrapper";function nFe(t){let{components:n,...e}=t;return(0,s.kt)(tFe,(0,p.Z)({},JOe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}nFe.isMDXComponent=!0;const eFe={toc:[]},oFe="wrapper";function pFe(t){let{components:n,...e}=t;return(0,s.kt)(oFe,(0,p.Z)({},eFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}pFe.isMDXComponent=!0;const rFe={toc:[]},sFe="wrapper";function cFe(t){let{components:n,...e}=t;return(0,s.kt)(sFe,(0,p.Z)({},rFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}cFe.isMDXComponent=!0;const iFe={toc:[]},aFe="wrapper";function lFe(t){let{components:n,...e}=t;return(0,s.kt)(aFe,(0,p.Z)({},iFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}lFe.isMDXComponent=!0;const uFe={toc:[]},mFe="wrapper";function dFe(t){let{components:n,...e}=t;return(0,s.kt)(mFe,(0,p.Z)({},uFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}dFe.isMDXComponent=!0;const hFe={toc:[]},kFe="wrapper";function fFe(t){let{components:n,...e}=t;return(0,s.kt)(kFe,(0,p.Z)({},hFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}fFe.isMDXComponent=!0;const yFe={toc:[]},MFe="wrapper";function DFe(t){let{components:n,...e}=t;return(0,s.kt)(MFe,(0,p.Z)({},yFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}DFe.isMDXComponent=!0;const XFe={toc:[]},_Fe="wrapper";function wFe(t){let{components:n,...e}=t;return(0,s.kt)(_Fe,(0,p.Z)({},XFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}wFe.isMDXComponent=!0;const TFe={toc:[]},CFe="wrapper";function gFe(t){let{components:n,...e}=t;return(0,s.kt)(CFe,(0,p.Z)({},TFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}gFe.isMDXComponent=!0;const xFe={toc:[]},vFe="wrapper";function LFe(t){let{components:n,...e}=t;return(0,s.kt)(vFe,(0,p.Z)({},xFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}LFe.isMDXComponent=!0;const ZFe={toc:[]},bFe="wrapper";function NFe(t){let{components:n,...e}=t;return(0,s.kt)(bFe,(0,p.Z)({},ZFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}NFe.isMDXComponent=!0;const AFe={toc:[]},zFe="wrapper";function WFe(t){let{components:n,...e}=t;return(0,s.kt)(zFe,(0,p.Z)({},AFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}WFe.isMDXComponent=!0;const IFe={toc:[]},RFe="wrapper";function PFe(t){let{components:n,...e}=t;return(0,s.kt)(RFe,(0,p.Z)({},IFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}PFe.isMDXComponent=!0;const SFe={toc:[]},EFe="wrapper";function GFe(t){let{components:n,...e}=t;return(0,s.kt)(EFe,(0,p.Z)({},SFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}GFe.isMDXComponent=!0;const OFe={toc:[]},FFe="wrapper";function BFe(t){let{components:n,...e}=t;return(0,s.kt)(FFe,(0,p.Z)({},OFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}BFe.isMDXComponent=!0;const UFe={toc:[]},VFe="wrapper";function qFe(t){let{components:n,...e}=t;return(0,s.kt)(VFe,(0,p.Z)({},UFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}qFe.isMDXComponent=!0;const jFe={toc:[]},YFe="wrapper";function QFe(t){let{components:n,...e}=t;return(0,s.kt)(YFe,(0,p.Z)({},jFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}QFe.isMDXComponent=!0;const HFe={toc:[]},$Fe="wrapper";function KFe(t){let{components:n,...e}=t;return(0,s.kt)($Fe,(0,p.Z)({},HFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}KFe.isMDXComponent=!0;const JFe={toc:[]},tBe="wrapper";function nBe(t){let{components:n,...e}=t;return(0,s.kt)(tBe,(0,p.Z)({},JFe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}nBe.isMDXComponent=!0;const eBe={toc:[]},oBe="wrapper";function pBe(t){let{components:n,...e}=t;return(0,s.kt)(oBe,(0,p.Z)({},eBe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}pBe.isMDXComponent=!0;const rBe={toc:[]},sBe="wrapper";function cBe(t){let{components:n,...e}=t;return(0,s.kt)(sBe,(0,p.Z)({},rBe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}cBe.isMDXComponent=!0;const iBe={toc:[]},aBe="wrapper";function lBe(t){let{components:n,...e}=t;return(0,s.kt)(aBe,(0,p.Z)({},iBe,e,{components:n,mdxType:"MDXLayout"}))}lBe.isMDXComponent=!0;const uBe={toc:[]},mBe="wrapper";function dBe(t){let{components:n,...e}=t;return(0,s.kt)(mBe,(0,p.Z)({},uBe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}dBe.isMDXComponent=!0;const hBe={toc:[]},kBe="wrapper";function fBe(t){let{components:n,...e}=t;return(0,s.kt)(kBe,(0,p.Z)({},hBe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}fBe.isMDXComponent=!0;const yBe={toc:[]},MBe="wrapper";function DBe(t){let{components:n,...e}=t;return(0,s.kt)(MBe,(0,p.Z)({},yBe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}DBe.isMDXComponent=!0;const XBe={toc:[]},_Be="wrapper";function wBe(t){let{components:n,...e}=t;return(0,s.kt)(_Be,(0,p.Z)({},XBe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}wBe.isMDXComponent=!0;const TBe={toc:[]},CBe="wrapper";function gBe(t){let{components:n,...e}=t;return(0,s.kt)(CBe,(0,p.Z)({},TBe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}gBe.isMDXComponent=!0;const xBe={toc:[]},vBe="wrapper";function LBe(t){let{components:n,...e}=t;return(0,s.kt)(vBe,(0,p.Z)({},xBe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}LBe.isMDXComponent=!0;const ZBe={toc:[]},bBe="wrapper";function NBe(t){let{components:n,...e}=t;return(0,s.kt)(bBe,(0,p.Z)({},ZBe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}NBe.isMDXComponent=!0;const ABe={toc:[]},zBe="wrapper";function WBe(t){let{components:n,...e}=t;return(0,s.kt)(zBe,(0,p.Z)({},ABe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}WBe.isMDXComponent=!0;const IBe={toc:[]},RBe="wrapper";function PBe(t){let{components:n,...e}=t;return(0,s.kt)(RBe,(0,p.Z)({},IBe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}PBe.isMDXComponent=!0;const SBe={toc:[]},EBe="wrapper";function GBe(t){let{components:n,...e}=t;return(0,s.kt)(EBe,(0,p.Z)({},SBe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}GBe.isMDXComponent=!0;const OBe={toc:[]},FBe="wrapper";function BBe(t){let{components:n,...e}=t;return(0,s.kt)(FBe,(0,p.Z)({},OBe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}BBe.isMDXComponent=!0;const UBe={toc:[]},VBe="wrapper";function qBe(t){let{components:n,...e}=t;return(0,s.kt)(VBe,(0,p.Z)({},UBe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}qBe.isMDXComponent=!0;const jBe={toc:[]},YBe="wrapper";function QBe(t){let{components:n,...e}=t;return(0,s.kt)(YBe,(0,p.Z)({},jBe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}QBe.isMDXComponent=!0;const HBe={toc:[]},$Be="wrapper";function KBe(t){let{components:n,...e}=t;return(0,s.kt)($Be,(0,p.Z)({},HBe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}KBe.isMDXComponent=!0;const JBe={toc:[]},tUe="wrapper";function nUe(t){let{components:n,...e}=t;return(0,s.kt)(tUe,(0,p.Z)({},JBe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}nUe.isMDXComponent=!0;const eUe={toc:[]},oUe="wrapper";function pUe(t){let{components:n,...e}=t;return(0,s.kt)(oUe,(0,p.Z)({},eUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}pUe.isMDXComponent=!0;const rUe={toc:[]},sUe="wrapper";function cUe(t){let{components:n,...e}=t;return(0,s.kt)(sUe,(0,p.Z)({},rUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}cUe.isMDXComponent=!0;const iUe={toc:[]},aUe="wrapper";function lUe(t){let{components:n,...e}=t;return(0,s.kt)(aUe,(0,p.Z)({},iUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}lUe.isMDXComponent=!0;const uUe={toc:[]},mUe="wrapper";function dUe(t){let{components:n,...e}=t;return(0,s.kt)(mUe,(0,p.Z)({},uUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}dUe.isMDXComponent=!0;const hUe={toc:[]},kUe="wrapper";function fUe(t){let{components:n,...e}=t;return(0,s.kt)(kUe,(0,p.Z)({},hUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}fUe.isMDXComponent=!0;const yUe={toc:[]},MUe="wrapper";function DUe(t){let{components:n,...e}=t;return(0,s.kt)(MUe,(0,p.Z)({},yUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}DUe.isMDXComponent=!0;const XUe={toc:[]},_Ue="wrapper";function wUe(t){let{components:n,...e}=t;return(0,s.kt)(_Ue,(0,p.Z)({},XUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}wUe.isMDXComponent=!0;const TUe={toc:[]},CUe="wrapper";function gUe(t){let{components:n,...e}=t;return(0,s.kt)(CUe,(0,p.Z)({},TUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}gUe.isMDXComponent=!0;const xUe={toc:[]},vUe="wrapper";function LUe(t){let{components:n,...e}=t;return(0,s.kt)(vUe,(0,p.Z)({},xUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}LUe.isMDXComponent=!0;const ZUe={toc:[]},bUe="wrapper";function NUe(t){let{components:n,...e}=t;return(0,s.kt)(bUe,(0,p.Z)({},ZUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}NUe.isMDXComponent=!0;const AUe={toc:[]},zUe="wrapper";function WUe(t){let{components:n,...e}=t;return(0,s.kt)(zUe,(0,p.Z)({},AUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}WUe.isMDXComponent=!0;const IUe={toc:[]},RUe="wrapper";function PUe(t){let{components:n,...e}=t;return(0,s.kt)(RUe,(0,p.Z)({},IUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}PUe.isMDXComponent=!0;const SUe={toc:[]},EUe="wrapper";function GUe(t){let{components:n,...e}=t;return(0,s.kt)(EUe,(0,p.Z)({},SUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}GUe.isMDXComponent=!0;const OUe={toc:[]},FUe="wrapper";function BUe(t){let{components:n,...e}=t;return(0,s.kt)(FUe,(0,p.Z)({},OUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}BUe.isMDXComponent=!0;const UUe={toc:[]},VUe="wrapper";function qUe(t){let{components:n,...e}=t;return(0,s.kt)(VUe,(0,p.Z)({},UUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}qUe.isMDXComponent=!0;const jUe={toc:[]},YUe="wrapper";function QUe(t){let{components:n,...e}=t;return(0,s.kt)(YUe,(0,p.Z)({},jUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}QUe.isMDXComponent=!0;const HUe={toc:[]},$Ue="wrapper";function KUe(t){let{components:n,...e}=t;return(0,s.kt)($Ue,(0,p.Z)({},HUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}KUe.isMDXComponent=!0;const JUe={toc:[]},tVe="wrapper";function nVe(t){let{components:n,...e}=t;return(0,s.kt)(tVe,(0,p.Z)({},JUe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}nVe.isMDXComponent=!0;const eVe={toc:[]},oVe="wrapper";function pVe(t){let{components:n,...e}=t;return(0,s.kt)(oVe,(0,p.Z)({},eVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}pVe.isMDXComponent=!0;const rVe={toc:[]},sVe="wrapper";function cVe(t){let{components:n,...e}=t;return(0,s.kt)(sVe,(0,p.Z)({},rVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}cVe.isMDXComponent=!0;const iVe={toc:[]},aVe="wrapper";function lVe(t){let{components:n,...e}=t;return(0,s.kt)(aVe,(0,p.Z)({},iVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}lVe.isMDXComponent=!0;const uVe={toc:[]},mVe="wrapper";function dVe(t){let{components:n,...e}=t;return(0,s.kt)(mVe,(0,p.Z)({},uVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}dVe.isMDXComponent=!0;const hVe={toc:[]},kVe="wrapper";function fVe(t){let{components:n,...e}=t;return(0,s.kt)(kVe,(0,p.Z)({},hVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}fVe.isMDXComponent=!0;const yVe={toc:[]},MVe="wrapper";function DVe(t){let{components:n,...e}=t;return(0,s.kt)(MVe,(0,p.Z)({},yVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}DVe.isMDXComponent=!0;const XVe={toc:[]},_Ve="wrapper";function wVe(t){let{components:n,...e}=t;return(0,s.kt)(_Ve,(0,p.Z)({},XVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}wVe.isMDXComponent=!0;const TVe={toc:[]},CVe="wrapper";function gVe(t){let{components:n,...e}=t;return(0,s.kt)(CVe,(0,p.Z)({},TVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}gVe.isMDXComponent=!0;const xVe={toc:[]},vVe="wrapper";function LVe(t){let{components:n,...e}=t;return(0,s.kt)(vVe,(0,p.Z)({},xVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}LVe.isMDXComponent=!0;const ZVe={toc:[]},bVe="wrapper";function NVe(t){let{components:n,...e}=t;return(0,s.kt)(bVe,(0,p.Z)({},ZVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}NVe.isMDXComponent=!0;const AVe={toc:[]},zVe="wrapper";function WVe(t){let{components:n,...e}=t;return(0,s.kt)(zVe,(0,p.Z)({},AVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}WVe.isMDXComponent=!0;const IVe={toc:[]},RVe="wrapper";function PVe(t){let{components:n,...e}=t;return(0,s.kt)(RVe,(0,p.Z)({},IVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}PVe.isMDXComponent=!0;const SVe={toc:[]},EVe="wrapper";function GVe(t){let{components:n,...e}=t;return(0,s.kt)(EVe,(0,p.Z)({},SVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}GVe.isMDXComponent=!0;const OVe={toc:[]},FVe="wrapper";function BVe(t){let{components:n,...e}=t;return(0,s.kt)(FVe,(0,p.Z)({},OVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}BVe.isMDXComponent=!0;const UVe={toc:[]},VVe="wrapper";function qVe(t){let{components:n,...e}=t;return(0,s.kt)(VVe,(0,p.Z)({},UVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qVe.isMDXComponent=!0;const jVe={toc:[]},YVe="wrapper";function QVe(t){let{components:n,...e}=t;return(0,s.kt)(YVe,(0,p.Z)({},jVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}QVe.isMDXComponent=!0;const HVe={toc:[]},$Ve="wrapper";function KVe(t){let{components:n,...e}=t;return(0,s.kt)($Ve,(0,p.Z)({},HVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}KVe.isMDXComponent=!0;const JVe={toc:[]},tqe="wrapper";function nqe(t){let{components:n,...e}=t;return(0,s.kt)(tqe,(0,p.Z)({},JVe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}nqe.isMDXComponent=!0;const eqe={toc:[]},oqe="wrapper";function pqe(t){let{components:n,...e}=t;return(0,s.kt)(oqe,(0,p.Z)({},eqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}pqe.isMDXComponent=!0;const rqe={toc:[]},sqe="wrapper";function cqe(t){let{components:n,...e}=t;return(0,s.kt)(sqe,(0,p.Z)({},rqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}cqe.isMDXComponent=!0;const iqe={toc:[]},aqe="wrapper";function lqe(t){let{components:n,...e}=t;return(0,s.kt)(aqe,(0,p.Z)({},iqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lqe.isMDXComponent=!0;const uqe={toc:[]},mqe="wrapper";function dqe(t){let{components:n,...e}=t;return(0,s.kt)(mqe,(0,p.Z)({},uqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}dqe.isMDXComponent=!0;const hqe={toc:[]},kqe="wrapper";function fqe(t){let{components:n,...e}=t;return(0,s.kt)(kqe,(0,p.Z)({},hqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}fqe.isMDXComponent=!0;const yqe={toc:[]},Mqe="wrapper";function Dqe(t){let{components:n,...e}=t;return(0,s.kt)(Mqe,(0,p.Z)({},yqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Dqe.isMDXComponent=!0;const Xqe={toc:[]},_qe="wrapper";function wqe(t){let{components:n,...e}=t;return(0,s.kt)(_qe,(0,p.Z)({},Xqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wqe.isMDXComponent=!0;const Tqe={toc:[]},Cqe="wrapper";function gqe(t){let{components:n,...e}=t;return(0,s.kt)(Cqe,(0,p.Z)({},Tqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}gqe.isMDXComponent=!0;const xqe={toc:[]},vqe="wrapper";function Lqe(t){let{components:n,...e}=t;return(0,s.kt)(vqe,(0,p.Z)({},xqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lqe.isMDXComponent=!0;const Zqe={toc:[]},bqe="wrapper";function Nqe(t){let{components:n,...e}=t;return(0,s.kt)(bqe,(0,p.Z)({},Zqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Nqe.isMDXComponent=!0;const Aqe={toc:[]},zqe="wrapper";function Wqe(t){let{components:n,...e}=t;return(0,s.kt)(zqe,(0,p.Z)({},Aqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Wqe.isMDXComponent=!0;const Iqe={toc:[]},Rqe="wrapper";function Pqe(t){let{components:n,...e}=t;return(0,s.kt)(Rqe,(0,p.Z)({},Iqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Pqe.isMDXComponent=!0;const Sqe={toc:[]},Eqe="wrapper";function Gqe(t){let{components:n,...e}=t;return(0,s.kt)(Eqe,(0,p.Z)({},Sqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Gqe.isMDXComponent=!0;const Oqe={toc:[]},Fqe="wrapper";function Bqe(t){let{components:n,...e}=t;return(0,s.kt)(Fqe,(0,p.Z)({},Oqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Bqe.isMDXComponent=!0;const Uqe={toc:[]},Vqe="wrapper";function qqe(t){let{components:n,...e}=t;return(0,s.kt)(Vqe,(0,p.Z)({},Uqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qqe.isMDXComponent=!0;const jqe={toc:[]},Yqe="wrapper";function Qqe(t){let{components:n,...e}=t;return(0,s.kt)(Yqe,(0,p.Z)({},jqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Qqe.isMDXComponent=!0;const Hqe={toc:[]},$qe="wrapper";function Kqe(t){let{components:n,...e}=t;return(0,s.kt)($qe,(0,p.Z)({},Hqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Kqe.isMDXComponent=!0;const Jqe={toc:[]},tje="wrapper";function nje(t){let{components:n,...e}=t;return(0,s.kt)(tje,(0,p.Z)({},Jqe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}nje.isMDXComponent=!0;const eje={toc:[]},oje="wrapper";function pje(t){let{components:n,...e}=t;return(0,s.kt)(oje,(0,p.Z)({},eje,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}pje.isMDXComponent=!0;const rje={toc:[]},sje="wrapper";function cje(t){let{components:n,...e}=t;return(0,s.kt)(sje,(0,p.Z)({},rje,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}cje.isMDXComponent=!0;const ije={toc:[]},aje="wrapper";function lje(t){let{components:n,...e}=t;return(0,s.kt)(aje,(0,p.Z)({},ije,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}lje.isMDXComponent=!0;const uje={toc:[]},mje="wrapper";function dje(t){let{components:n,...e}=t;return(0,s.kt)(mje,(0,p.Z)({},uje,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}dje.isMDXComponent=!0;const hje={toc:[]},kje="wrapper";function fje(t){let{components:n,...e}=t;return(0,s.kt)(kje,(0,p.Z)({},hje,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}fje.isMDXComponent=!0;const yje={toc:[]},Mje="wrapper";function Dje(t){let{components:n,...e}=t;return(0,s.kt)(Mje,(0,p.Z)({},yje,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Dje.isMDXComponent=!0;const Xje={toc:[]},_je="wrapper";function wje(t){let{components:n,...e}=t;return(0,s.kt)(_je,(0,p.Z)({},Xje,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}wje.isMDXComponent=!0;const Tje={toc:[]},Cje="wrapper";function gje(t){let{components:n,...e}=t;return(0,s.kt)(Cje,(0,p.Z)({},Tje,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}gje.isMDXComponent=!0;const xje={toc:[]},vje="wrapper";function Lje(t){let{components:n,...e}=t;return(0,s.kt)(vje,(0,p.Z)({},xje,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Lje.isMDXComponent=!0;const Zje={toc:[]},bje="wrapper";function Nje(t){let{components:n,...e}=t;return(0,s.kt)(bje,(0,p.Z)({},Zje,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Nje.isMDXComponent=!0;const Aje={toc:[]},zje="wrapper";function Wje(t){let{components:n,...e}=t;return(0,s.kt)(zje,(0,p.Z)({},Aje,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Wje.isMDXComponent=!0;const Ije={toc:[]},Rje="wrapper";function Pje(t){let{components:n,...e}=t;return(0,s.kt)(Rje,(0,p.Z)({},Ije,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Pje.isMDXComponent=!0;const Sje={toc:[]},Eje="wrapper";function Gje(t){let{components:n,...e}=t;return(0,s.kt)(Eje,(0,p.Z)({},Sje,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Gje.isMDXComponent=!0;const Oje={toc:[]},Fje="wrapper";function Bje(t){let{components:n,...e}=t;return(0,s.kt)(Fje,(0,p.Z)({},Oje,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Bje.isMDXComponent=!0;const Uje={toc:[]},Vje="wrapper";function qje(t){let{components:n,...e}=t;return(0,s.kt)(Vje,(0,p.Z)({},Uje,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}qje.isMDXComponent=!0;const jje={toc:[]},Yje="wrapper";function Qje(t){let{components:n,...e}=t;return(0,s.kt)(Yje,(0,p.Z)({},jje,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Qje.isMDXComponent=!0;const Hje={toc:[]},$je="wrapper";function Kje(t){let{components:n,...e}=t;return(0,s.kt)($je,(0,p.Z)({},Hje,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Kje.isMDXComponent=!0;const Jje={toc:[]},tYe="wrapper";function nYe(t){let{components:n,...e}=t;return(0,s.kt)(tYe,(0,p.Z)({},Jje,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}nYe.isMDXComponent=!0;const eYe={toc:[]},oYe="wrapper";function pYe(t){let{components:n,...e}=t;return(0,s.kt)(oYe,(0,p.Z)({},eYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}pYe.isMDXComponent=!0;const rYe={toc:[]},sYe="wrapper";function cYe(t){let{components:n,...e}=t;return(0,s.kt)(sYe,(0,p.Z)({},rYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}cYe.isMDXComponent=!0;const iYe={toc:[]},aYe="wrapper";function lYe(t){let{components:n,...e}=t;return(0,s.kt)(aYe,(0,p.Z)({},iYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}lYe.isMDXComponent=!0;const uYe={toc:[]},mYe="wrapper";function dYe(t){let{components:n,...e}=t;return(0,s.kt)(mYe,(0,p.Z)({},uYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}dYe.isMDXComponent=!0;const hYe={toc:[]},kYe="wrapper";function fYe(t){let{components:n,...e}=t;return(0,s.kt)(kYe,(0,p.Z)({},hYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}fYe.isMDXComponent=!0;const yYe={toc:[]},MYe="wrapper";function DYe(t){let{components:n,...e}=t;return(0,s.kt)(MYe,(0,p.Z)({},yYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}DYe.isMDXComponent=!0;const XYe={toc:[]},_Ye="wrapper";function wYe(t){let{components:n,...e}=t;return(0,s.kt)(_Ye,(0,p.Z)({},XYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}wYe.isMDXComponent=!0;const TYe={toc:[]},CYe="wrapper";function gYe(t){let{components:n,...e}=t;return(0,s.kt)(CYe,(0,p.Z)({},TYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}gYe.isMDXComponent=!0;const xYe={toc:[]},vYe="wrapper";function LYe(t){let{components:n,...e}=t;return(0,s.kt)(vYe,(0,p.Z)({},xYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}LYe.isMDXComponent=!0;const ZYe={toc:[]},bYe="wrapper";function NYe(t){let{components:n,...e}=t;return(0,s.kt)(bYe,(0,p.Z)({},ZYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}NYe.isMDXComponent=!0;const AYe={toc:[]},zYe="wrapper";function WYe(t){let{components:n,...e}=t;return(0,s.kt)(zYe,(0,p.Z)({},AYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}WYe.isMDXComponent=!0;const IYe={toc:[]},RYe="wrapper";function PYe(t){let{components:n,...e}=t;return(0,s.kt)(RYe,(0,p.Z)({},IYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}PYe.isMDXComponent=!0;const SYe={toc:[]},EYe="wrapper";function GYe(t){let{components:n,...e}=t;return(0,s.kt)(EYe,(0,p.Z)({},SYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}GYe.isMDXComponent=!0;const OYe={toc:[]},FYe="wrapper";function BYe(t){let{components:n,...e}=t;return(0,s.kt)(FYe,(0,p.Z)({},OYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}BYe.isMDXComponent=!0;const UYe={toc:[]},VYe="wrapper";function qYe(t){let{components:n,...e}=t;return(0,s.kt)(VYe,(0,p.Z)({},UYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}qYe.isMDXComponent=!0;const jYe={toc:[]},YYe="wrapper";function QYe(t){let{components:n,...e}=t;return(0,s.kt)(YYe,(0,p.Z)({},jYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}QYe.isMDXComponent=!0;const HYe={toc:[]},$Ye="wrapper";function KYe(t){let{components:n,...e}=t;return(0,s.kt)($Ye,(0,p.Z)({},HYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}KYe.isMDXComponent=!0;const JYe={toc:[]},tQe="wrapper";function nQe(t){let{components:n,...e}=t;return(0,s.kt)(tQe,(0,p.Z)({},JYe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}nQe.isMDXComponent=!0;const eQe={toc:[]},oQe="wrapper";function pQe(t){let{components:n,...e}=t;return(0,s.kt)(oQe,(0,p.Z)({},eQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}pQe.isMDXComponent=!0;const rQe={toc:[]},sQe="wrapper";function cQe(t){let{components:n,...e}=t;return(0,s.kt)(sQe,(0,p.Z)({},rQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}cQe.isMDXComponent=!0;const iQe={toc:[]},aQe="wrapper";function lQe(t){let{components:n,...e}=t;return(0,s.kt)(aQe,(0,p.Z)({},iQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}lQe.isMDXComponent=!0;const uQe={toc:[]},mQe="wrapper";function dQe(t){let{components:n,...e}=t;return(0,s.kt)(mQe,(0,p.Z)({},uQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}dQe.isMDXComponent=!0;const hQe={toc:[]},kQe="wrapper";function fQe(t){let{components:n,...e}=t;return(0,s.kt)(kQe,(0,p.Z)({},hQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}fQe.isMDXComponent=!0;const yQe={toc:[]},MQe="wrapper";function DQe(t){let{components:n,...e}=t;return(0,s.kt)(MQe,(0,p.Z)({},yQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}DQe.isMDXComponent=!0;const XQe={toc:[]},_Qe="wrapper";function wQe(t){let{components:n,...e}=t;return(0,s.kt)(_Qe,(0,p.Z)({},XQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}wQe.isMDXComponent=!0;const TQe={toc:[]},CQe="wrapper";function gQe(t){let{components:n,...e}=t;return(0,s.kt)(CQe,(0,p.Z)({},TQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}gQe.isMDXComponent=!0;const xQe={toc:[]},vQe="wrapper";function LQe(t){let{components:n,...e}=t;return(0,s.kt)(vQe,(0,p.Z)({},xQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}LQe.isMDXComponent=!0;const ZQe={toc:[]},bQe="wrapper";function NQe(t){let{components:n,...e}=t;return(0,s.kt)(bQe,(0,p.Z)({},ZQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}NQe.isMDXComponent=!0;const AQe={toc:[]},zQe="wrapper";function WQe(t){let{components:n,...e}=t;return(0,s.kt)(zQe,(0,p.Z)({},AQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}WQe.isMDXComponent=!0;const IQe={toc:[]},RQe="wrapper";function PQe(t){let{components:n,...e}=t;return(0,s.kt)(RQe,(0,p.Z)({},IQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}PQe.isMDXComponent=!0;const SQe={toc:[]},EQe="wrapper";function GQe(t){let{components:n,...e}=t;return(0,s.kt)(EQe,(0,p.Z)({},SQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}GQe.isMDXComponent=!0;const OQe={toc:[]},FQe="wrapper";function BQe(t){let{components:n,...e}=t;return(0,s.kt)(FQe,(0,p.Z)({},OQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}BQe.isMDXComponent=!0;const UQe={toc:[]},VQe="wrapper";function qQe(t){let{components:n,...e}=t;return(0,s.kt)(VQe,(0,p.Z)({},UQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}qQe.isMDXComponent=!0;const jQe={toc:[]},YQe="wrapper";function QQe(t){let{components:n,...e}=t;return(0,s.kt)(YQe,(0,p.Z)({},jQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}QQe.isMDXComponent=!0;const HQe={toc:[]},$Qe="wrapper";function KQe(t){let{components:n,...e}=t;return(0,s.kt)($Qe,(0,p.Z)({},HQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}KQe.isMDXComponent=!0;const JQe={toc:[]},tHe="wrapper";function nHe(t){let{components:n,...e}=t;return(0,s.kt)(tHe,(0,p.Z)({},JQe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}nHe.isMDXComponent=!0;const eHe={toc:[]},oHe="wrapper";function pHe(t){let{components:n,...e}=t;return(0,s.kt)(oHe,(0,p.Z)({},eHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pHe.isMDXComponent=!0;const rHe={toc:[]},sHe="wrapper";function cHe(t){let{components:n,...e}=t;return(0,s.kt)(sHe,(0,p.Z)({},rHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}cHe.isMDXComponent=!0;const iHe={toc:[]},aHe="wrapper";function lHe(t){let{components:n,...e}=t;return(0,s.kt)(aHe,(0,p.Z)({},iHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}lHe.isMDXComponent=!0;const uHe={toc:[]},mHe="wrapper";function dHe(t){let{components:n,...e}=t;return(0,s.kt)(mHe,(0,p.Z)({},uHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}dHe.isMDXComponent=!0;const hHe={toc:[]},kHe="wrapper";function fHe(t){let{components:n,...e}=t;return(0,s.kt)(kHe,(0,p.Z)({},hHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}fHe.isMDXComponent=!0;const yHe={toc:[]},MHe="wrapper";function DHe(t){let{components:n,...e}=t;return(0,s.kt)(MHe,(0,p.Z)({},yHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}DHe.isMDXComponent=!0;const XHe={toc:[]},_He="wrapper";function wHe(t){let{components:n,...e}=t;return(0,s.kt)(_He,(0,p.Z)({},XHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}wHe.isMDXComponent=!0;const THe={toc:[]},CHe="wrapper";function gHe(t){let{components:n,...e}=t;return(0,s.kt)(CHe,(0,p.Z)({},THe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}gHe.isMDXComponent=!0;const xHe={toc:[]},vHe="wrapper";function LHe(t){let{components:n,...e}=t;return(0,s.kt)(vHe,(0,p.Z)({},xHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}LHe.isMDXComponent=!0;const ZHe={toc:[]},bHe="wrapper";function NHe(t){let{components:n,...e}=t;return(0,s.kt)(bHe,(0,p.Z)({},ZHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}NHe.isMDXComponent=!0;const AHe={toc:[]},zHe="wrapper";function WHe(t){let{components:n,...e}=t;return(0,s.kt)(zHe,(0,p.Z)({},AHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}WHe.isMDXComponent=!0;const IHe={toc:[]},RHe="wrapper";function PHe(t){let{components:n,...e}=t;return(0,s.kt)(RHe,(0,p.Z)({},IHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}PHe.isMDXComponent=!0;const SHe={toc:[]},EHe="wrapper";function GHe(t){let{components:n,...e}=t;return(0,s.kt)(EHe,(0,p.Z)({},SHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}GHe.isMDXComponent=!0;const OHe={toc:[]},FHe="wrapper";function BHe(t){let{components:n,...e}=t;return(0,s.kt)(FHe,(0,p.Z)({},OHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}BHe.isMDXComponent=!0;const UHe={toc:[]},VHe="wrapper";function qHe(t){let{components:n,...e}=t;return(0,s.kt)(VHe,(0,p.Z)({},UHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qHe.isMDXComponent=!0;const jHe={toc:[]},YHe="wrapper";function QHe(t){let{components:n,...e}=t;return(0,s.kt)(YHe,(0,p.Z)({},jHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}QHe.isMDXComponent=!0;const HHe={toc:[]},$He="wrapper";function KHe(t){let{components:n,...e}=t;return(0,s.kt)($He,(0,p.Z)({},HHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}KHe.isMDXComponent=!0;const JHe={toc:[]},t$e="wrapper";function n$e(t){let{components:n,...e}=t;return(0,s.kt)(t$e,(0,p.Z)({},JHe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}n$e.isMDXComponent=!0;const e$e={toc:[]},o$e="wrapper";function p$e(t){let{components:n,...e}=t;return(0,s.kt)(o$e,(0,p.Z)({},e$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}p$e.isMDXComponent=!0;const r$e={toc:[]},s$e="wrapper";function c$e(t){let{components:n,...e}=t;return(0,s.kt)(s$e,(0,p.Z)({},r$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}c$e.isMDXComponent=!0;const i$e={toc:[]},a$e="wrapper";function l$e(t){let{components:n,...e}=t;return(0,s.kt)(a$e,(0,p.Z)({},i$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}l$e.isMDXComponent=!0;const u$e={toc:[]},m$e="wrapper";function d$e(t){let{components:n,...e}=t;return(0,s.kt)(m$e,(0,p.Z)({},u$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}d$e.isMDXComponent=!0;const h$e={toc:[]},k$e="wrapper";function f$e(t){let{components:n,...e}=t;return(0,s.kt)(k$e,(0,p.Z)({},h$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}f$e.isMDXComponent=!0;const y$e={toc:[]},M$e="wrapper";function D$e(t){let{components:n,...e}=t;return(0,s.kt)(M$e,(0,p.Z)({},y$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}D$e.isMDXComponent=!0;const X$e={toc:[]},_$e="wrapper";function w$e(t){let{components:n,...e}=t;return(0,s.kt)(_$e,(0,p.Z)({},X$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}w$e.isMDXComponent=!0;const T$e={toc:[]},C$e="wrapper";function g$e(t){let{components:n,...e}=t;return(0,s.kt)(C$e,(0,p.Z)({},T$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}g$e.isMDXComponent=!0;const x$e={toc:[]},v$e="wrapper";function L$e(t){let{components:n,...e}=t;return(0,s.kt)(v$e,(0,p.Z)({},x$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}L$e.isMDXComponent=!0;const Z$e={toc:[]},b$e="wrapper";function N$e(t){let{components:n,...e}=t;return(0,s.kt)(b$e,(0,p.Z)({},Z$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}N$e.isMDXComponent=!0;const A$e={toc:[]},z$e="wrapper";function W$e(t){let{components:n,...e}=t;return(0,s.kt)(z$e,(0,p.Z)({},A$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}W$e.isMDXComponent=!0;const I$e={toc:[]},R$e="wrapper";function P$e(t){let{components:n,...e}=t;return(0,s.kt)(R$e,(0,p.Z)({},I$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}P$e.isMDXComponent=!0;const S$e={toc:[]},E$e="wrapper";function G$e(t){let{components:n,...e}=t;return(0,s.kt)(E$e,(0,p.Z)({},S$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}G$e.isMDXComponent=!0;const O$e={toc:[]},F$e="wrapper";function B$e(t){let{components:n,...e}=t;return(0,s.kt)(F$e,(0,p.Z)({},O$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}B$e.isMDXComponent=!0;const U$e={toc:[]},V$e="wrapper";function q$e(t){let{components:n,...e}=t;return(0,s.kt)(V$e,(0,p.Z)({},U$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}q$e.isMDXComponent=!0;const j$e={toc:[]},Y$e="wrapper";function Q$e(t){let{components:n,...e}=t;return(0,s.kt)(Y$e,(0,p.Z)({},j$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Q$e.isMDXComponent=!0;const H$e={toc:[]},$$e="wrapper";function K$e(t){let{components:n,...e}=t;return(0,s.kt)($$e,(0,p.Z)({},H$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}K$e.isMDXComponent=!0;const J$e={toc:[]},tKe="wrapper";function nKe(t){let{components:n,...e}=t;return(0,s.kt)(tKe,(0,p.Z)({},J$e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}nKe.isMDXComponent=!0;const eKe={toc:[]},oKe="wrapper";function pKe(t){let{components:n,...e}=t;return(0,s.kt)(oKe,(0,p.Z)({},eKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}pKe.isMDXComponent=!0;const rKe={toc:[]},sKe="wrapper";function cKe(t){let{components:n,...e}=t;return(0,s.kt)(sKe,(0,p.Z)({},rKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}cKe.isMDXComponent=!0;const iKe={toc:[]},aKe="wrapper";function lKe(t){let{components:n,...e}=t;return(0,s.kt)(aKe,(0,p.Z)({},iKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}lKe.isMDXComponent=!0;const uKe={toc:[]},mKe="wrapper";function dKe(t){let{components:n,...e}=t;return(0,s.kt)(mKe,(0,p.Z)({},uKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}dKe.isMDXComponent=!0;const hKe={toc:[]},kKe="wrapper";function fKe(t){let{components:n,...e}=t;return(0,s.kt)(kKe,(0,p.Z)({},hKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}fKe.isMDXComponent=!0;const yKe={toc:[]},MKe="wrapper";function DKe(t){let{components:n,...e}=t;return(0,s.kt)(MKe,(0,p.Z)({},yKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}DKe.isMDXComponent=!0;const XKe={toc:[]},_Ke="wrapper";function wKe(t){let{components:n,...e}=t;return(0,s.kt)(_Ke,(0,p.Z)({},XKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}wKe.isMDXComponent=!0;const TKe={toc:[]},CKe="wrapper";function gKe(t){let{components:n,...e}=t;return(0,s.kt)(CKe,(0,p.Z)({},TKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you're not interested in animating SVG, you can use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img"},(0,s.kt)("inlineCode",{parentName:"a"},"Img"))," instead."))}gKe.isMDXComponent=!0;const xKe={toc:[]},vKe="wrapper";function LKe(t){let{components:n,...e}=t;return(0,s.kt)(vKe,(0,p.Z)({},xKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A Node for drawing and animating SVG images."))}LKe.isMDXComponent=!0;const ZKe={toc:[]},bKe="wrapper";function NKe(t){let{components:n,...e}=t;return(0,s.kt)(bKe,(0,p.Z)({},ZKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}NKe.isMDXComponent=!0;const AKe={toc:[]},zKe="wrapper";function WKe(t){let{components:n,...e}=t;return(0,s.kt)(zKe,(0,p.Z)({},AKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}WKe.isMDXComponent=!0;const IKe={toc:[]},RKe="wrapper";function PKe(t){let{components:n,...e}=t;return(0,s.kt)(RKe,(0,p.Z)({},IKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}PKe.isMDXComponent=!0;const SKe={toc:[]},EKe="wrapper";function GKe(t){let{components:n,...e}=t;return(0,s.kt)(EKe,(0,p.Z)({},SKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}GKe.isMDXComponent=!0;const OKe={toc:[]},FKe="wrapper";function BKe(t){let{components:n,...e}=t;return(0,s.kt)(FKe,(0,p.Z)({},OKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}BKe.isMDXComponent=!0;const UKe={toc:[]},VKe="wrapper";function qKe(t){let{components:n,...e}=t;return(0,s.kt)(VKe,(0,p.Z)({},UKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}qKe.isMDXComponent=!0;const jKe={toc:[]},YKe="wrapper";function QKe(t){let{components:n,...e}=t;return(0,s.kt)(YKe,(0,p.Z)({},jKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}QKe.isMDXComponent=!0;const HKe={toc:[]},$Ke="wrapper";function KKe(t){let{components:n,...e}=t;return(0,s.kt)($Ke,(0,p.Z)({},HKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}KKe.isMDXComponent=!0;const JKe={toc:[]},tJe="wrapper";function nJe(t){let{components:n,...e}=t;return(0,s.kt)(tJe,(0,p.Z)({},JKe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}nJe.isMDXComponent=!0;const eJe={toc:[]},oJe="wrapper";function pJe(t){let{components:n,...e}=t;return(0,s.kt)(oJe,(0,p.Z)({},eJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}pJe.isMDXComponent=!0;const rJe={toc:[]},sJe="wrapper";function cJe(t){let{components:n,...e}=t;return(0,s.kt)(sJe,(0,p.Z)({},rJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}cJe.isMDXComponent=!0;const iJe={toc:[]},aJe="wrapper";function lJe(t){let{components:n,...e}=t;return(0,s.kt)(aJe,(0,p.Z)({},iJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lJe.isMDXComponent=!0;const uJe={toc:[]},mJe="wrapper";function dJe(t){let{components:n,...e}=t;return(0,s.kt)(mJe,(0,p.Z)({},uJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}dJe.isMDXComponent=!0;const hJe={toc:[]},kJe="wrapper";function fJe(t){let{components:n,...e}=t;return(0,s.kt)(kJe,(0,p.Z)({},hJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}fJe.isMDXComponent=!0;const yJe={toc:[]},MJe="wrapper";function DJe(t){let{components:n,...e}=t;return(0,s.kt)(MJe,(0,p.Z)({},yJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}DJe.isMDXComponent=!0;const XJe={toc:[]},_Je="wrapper";function wJe(t){let{components:n,...e}=t;return(0,s.kt)(_Je,(0,p.Z)({},XJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}wJe.isMDXComponent=!0;const TJe={toc:[]},CJe="wrapper";function gJe(t){let{components:n,...e}=t;return(0,s.kt)(CJe,(0,p.Z)({},TJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}gJe.isMDXComponent=!0;const xJe={toc:[]},vJe="wrapper";function LJe(t){let{components:n,...e}=t;return(0,s.kt)(vJe,(0,p.Z)({},xJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}LJe.isMDXComponent=!0;const ZJe={toc:[]},bJe="wrapper";function NJe(t){let{components:n,...e}=t;return(0,s.kt)(bJe,(0,p.Z)({},ZJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}NJe.isMDXComponent=!0;const AJe={toc:[]},zJe="wrapper";function WJe(t){let{components:n,...e}=t;return(0,s.kt)(zJe,(0,p.Z)({},AJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}WJe.isMDXComponent=!0;const IJe={toc:[]},RJe="wrapper";function PJe(t){let{components:n,...e}=t;return(0,s.kt)(RJe,(0,p.Z)({},IJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}PJe.isMDXComponent=!0;const SJe={toc:[]},EJe="wrapper";function GJe(t){let{components:n,...e}=t;return(0,s.kt)(EJe,(0,p.Z)({},SJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}GJe.isMDXComponent=!0;const OJe={toc:[]},FJe="wrapper";function BJe(t){let{components:n,...e}=t;return(0,s.kt)(FJe,(0,p.Z)({},OJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}BJe.isMDXComponent=!0;const UJe={toc:[]},VJe="wrapper";function qJe(t){let{components:n,...e}=t;return(0,s.kt)(VJe,(0,p.Z)({},UJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}qJe.isMDXComponent=!0;const jJe={toc:[]},YJe="wrapper";function QJe(t){let{components:n,...e}=t;return(0,s.kt)(YJe,(0,p.Z)({},jJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}QJe.isMDXComponent=!0;const HJe={toc:[]},$Je="wrapper";function KJe(t){let{components:n,...e}=t;return(0,s.kt)($Je,(0,p.Z)({},HJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}KJe.isMDXComponent=!0;const JJe={toc:[]},t0e="wrapper";function n0e(t){let{components:n,...e}=t;return(0,s.kt)(t0e,(0,p.Z)({},JJe,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}n0e.isMDXComponent=!0;const e0e={toc:[]},o0e="wrapper";function p0e(t){let{components:n,...e}=t;return(0,s.kt)(o0e,(0,p.Z)({},e0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}p0e.isMDXComponent=!0;const r0e={toc:[]},s0e="wrapper";function c0e(t){let{components:n,...e}=t;return(0,s.kt)(s0e,(0,p.Z)({},r0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}c0e.isMDXComponent=!0;const i0e={toc:[]},a0e="wrapper";function l0e(t){let{components:n,...e}=t;return(0,s.kt)(a0e,(0,p.Z)({},i0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}l0e.isMDXComponent=!0;const u0e={toc:[]},m0e="wrapper";function d0e(t){let{components:n,...e}=t;return(0,s.kt)(m0e,(0,p.Z)({},u0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}d0e.isMDXComponent=!0;const h0e={toc:[]},k0e="wrapper";function f0e(t){let{components:n,...e}=t;return(0,s.kt)(k0e,(0,p.Z)({},h0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}f0e.isMDXComponent=!0;const y0e={toc:[]},M0e="wrapper";function D0e(t){let{components:n,...e}=t;return(0,s.kt)(M0e,(0,p.Z)({},y0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}D0e.isMDXComponent=!0;const X0e={toc:[]},_0e="wrapper";function w0e(t){let{components:n,...e}=t;return(0,s.kt)(_0e,(0,p.Z)({},X0e,e,{components:n,mdxType:"MDXLayout"}))}w0e.isMDXComponent=!0;const T0e={toc:[]},C0e="wrapper";function g0e(t){let{components:n,...e}=t;return(0,s.kt)(C0e,(0,p.Z)({},T0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"SVG string to be rendered"))}g0e.isMDXComponent=!0;const x0e={toc:[]},v0e="wrapper";function L0e(t){let{components:n,...e}=t;return(0,s.kt)(v0e,(0,p.Z)({},x0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}L0e.isMDXComponent=!0;const Z0e={toc:[]},b0e="wrapper";function N0e(t){let{components:n,...e}=t;return(0,s.kt)(b0e,(0,p.Z)({},Z0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}N0e.isMDXComponent=!0;const A0e={toc:[]},z0e="wrapper";function W0e(t){let{components:n,...e}=t;return(0,s.kt)(z0e,(0,p.Z)({},A0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}W0e.isMDXComponent=!0;const I0e={toc:[]},R0e="wrapper";function P0e(t){let{components:n,...e}=t;return(0,s.kt)(R0e,(0,p.Z)({},I0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}P0e.isMDXComponent=!0;const S0e={toc:[]},E0e="wrapper";function G0e(t){let{components:n,...e}=t;return(0,s.kt)(E0e,(0,p.Z)({},S0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}G0e.isMDXComponent=!0;const O0e={toc:[]},F0e="wrapper";function B0e(t){let{components:n,...e}=t;return(0,s.kt)(F0e,(0,p.Z)({},O0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}B0e.isMDXComponent=!0;const U0e={toc:[]},V0e="wrapper";function q0e(t){let{components:n,...e}=t;return(0,s.kt)(V0e,(0,p.Z)({},U0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Child to wrap all SVG node"))}q0e.isMDXComponent=!0;const j0e={toc:[]},Y0e="wrapper";function Q0e(t){let{components:n,...e}=t;return(0,s.kt)(Y0e,(0,p.Z)({},j0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Q0e.isMDXComponent=!0;const H0e={toc:[]},$0e="wrapper";function K0e(t){let{components:n,...e}=t;return(0,s.kt)($0e,(0,p.Z)({},H0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}K0e.isMDXComponent=!0;const J0e={toc:[]},t2e="wrapper";function n2e(t){let{components:n,...e}=t;return(0,s.kt)(t2e,(0,p.Z)({},J0e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}n2e.isMDXComponent=!0;const e2e={toc:[]},o2e="wrapper";function p2e(t){let{components:n,...e}=t;return(0,s.kt)(o2e,(0,p.Z)({},e2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}p2e.isMDXComponent=!0;const r2e={toc:[]},s2e="wrapper";function c2e(t){let{components:n,...e}=t;return(0,s.kt)(s2e,(0,p.Z)({},r2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}c2e.isMDXComponent=!0;const i2e={toc:[]},a2e="wrapper";function l2e(t){let{components:n,...e}=t;return(0,s.kt)(a2e,(0,p.Z)({},i2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}l2e.isMDXComponent=!0;const u2e={toc:[]},m2e="wrapper";function d2e(t){let{components:n,...e}=t;return(0,s.kt)(m2e,(0,p.Z)({},u2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}d2e.isMDXComponent=!0;const h2e={toc:[]},k2e="wrapper";function f2e(t){let{components:n,...e}=t;return(0,s.kt)(k2e,(0,p.Z)({},h2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}f2e.isMDXComponent=!0;const y2e={toc:[]},M2e="wrapper";function D2e(t){let{components:n,...e}=t;return(0,s.kt)(M2e,(0,p.Z)({},y2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}D2e.isMDXComponent=!0;const X2e={toc:[]},_2e="wrapper";function w2e(t){let{components:n,...e}=t;return(0,s.kt)(_2e,(0,p.Z)({},X2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}w2e.isMDXComponent=!0;const T2e={toc:[]},C2e="wrapper";function g2e(t){let{components:n,...e}=t;return(0,s.kt)(C2e,(0,p.Z)({},T2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}g2e.isMDXComponent=!0;const x2e={toc:[]},v2e="wrapper";function L2e(t){let{components:n,...e}=t;return(0,s.kt)(v2e,(0,p.Z)({},x2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData")," to convert."))}L2e.isMDXComponent=!0;const Z2e={toc:[]},b2e="wrapper";function N2e(t){let{components:n,...e}=t;return(0,s.kt)(b2e,(0,p.Z)({},Z2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGShapeData")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGShape"),"."))}N2e.isMDXComponent=!0;const A2e={toc:[]},z2e="wrapper";function W2e(t){let{components:n,...e}=t;return(0,s.kt)(z2e,(0,p.Z)({},A2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"SVGShapeData")," to convert."))}W2e.isMDXComponent=!0;const I2e={toc:[]},R2e="wrapper";function P2e(t){let{components:n,...e}=t;return(0,s.kt)(R2e,(0,p.Z)({},I2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}P2e.isMDXComponent=!0;const S2e={toc:[]},E2e="wrapper";function G2e(t){let{components:n,...e}=t;return(0,s.kt)(E2e,(0,p.Z)({},S2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}G2e.isMDXComponent=!0;const O2e={toc:[]},F2e="wrapper";function B2e(t){let{components:n,...e}=t;return(0,s.kt)(F2e,(0,p.Z)({},O2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}B2e.isMDXComponent=!0;const U2e={toc:[]},V2e="wrapper";function q2e(t){let{components:n,...e}=t;return(0,s.kt)(V2e,(0,p.Z)({},U2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}q2e.isMDXComponent=!0;const j2e={toc:[]},Y2e="wrapper";function Q2e(t){let{components:n,...e}=t;return(0,s.kt)(Y2e,(0,p.Z)({},j2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Q2e.isMDXComponent=!0;const H2e={toc:[]},$2e="wrapper";function K2e(t){let{components:n,...e}=t;return(0,s.kt)($2e,(0,p.Z)({},H2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}K2e.isMDXComponent=!0;const J2e={toc:[]},t6e="wrapper";function n6e(t){let{components:n,...e}=t;return(0,s.kt)(t6e,(0,p.Z)({},J2e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}n6e.isMDXComponent=!0;const e6e={toc:[]},o6e="wrapper";function p6e(t){let{components:n,...e}=t;return(0,s.kt)(o6e,(0,p.Z)({},e6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}p6e.isMDXComponent=!0;const r6e={toc:[]},s6e="wrapper";function c6e(t){let{components:n,...e}=t;return(0,s.kt)(s6e,(0,p.Z)({},r6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}c6e.isMDXComponent=!0;const i6e={toc:[]},a6e="wrapper";function l6e(t){let{components:n,...e}=t;return(0,s.kt)(a6e,(0,p.Z)({},i6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}l6e.isMDXComponent=!0;const u6e={toc:[]},m6e="wrapper";function d6e(t){let{components:n,...e}=t;return(0,s.kt)(m6e,(0,p.Z)({},u6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}d6e.isMDXComponent=!0;const h6e={toc:[]},k6e="wrapper";function f6e(t){let{components:n,...e}=t;return(0,s.kt)(k6e,(0,p.Z)({},h6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}f6e.isMDXComponent=!0;const y6e={toc:[]},M6e="wrapper";function D6e(t){let{components:n,...e}=t;return(0,s.kt)(M6e,(0,p.Z)({},y6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}D6e.isMDXComponent=!0;const X6e={toc:[]},_6e="wrapper";function w6e(t){let{components:n,...e}=t;return(0,s.kt)(_6e,(0,p.Z)({},X6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}w6e.isMDXComponent=!0;const T6e={toc:[]},C6e="wrapper";function g6e(t){let{components:n,...e}=t;return(0,s.kt)(C6e,(0,p.Z)({},T6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}g6e.isMDXComponent=!0;const x6e={toc:[]},v6e="wrapper";function L6e(t){let{components:n,...e}=t;return(0,s.kt)(v6e,(0,p.Z)({},x6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}L6e.isMDXComponent=!0;const Z6e={toc:[]},b6e="wrapper";function N6e(t){let{components:n,...e}=t;return(0,s.kt)(b6e,(0,p.Z)({},Z6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}N6e.isMDXComponent=!0;const A6e={toc:[]},z6e="wrapper";function W6e(t){let{components:n,...e}=t;return(0,s.kt)(z6e,(0,p.Z)({},A6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}W6e.isMDXComponent=!0;const I6e={toc:[]},R6e="wrapper";function P6e(t){let{components:n,...e}=t;return(0,s.kt)(R6e,(0,p.Z)({},I6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}P6e.isMDXComponent=!0;const S6e={toc:[]},E6e="wrapper";function G6e(t){let{components:n,...e}=t;return(0,s.kt)(E6e,(0,p.Z)({},S6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}G6e.isMDXComponent=!0;const O6e={toc:[]},F6e="wrapper";function B6e(t){let{components:n,...e}=t;return(0,s.kt)(F6e,(0,p.Z)({},O6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}B6e.isMDXComponent=!0;const U6e={toc:[]},V6e="wrapper";function q6e(t){let{components:n,...e}=t;return(0,s.kt)(V6e,(0,p.Z)({},U6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}q6e.isMDXComponent=!0;const j6e={toc:[]},Y6e="wrapper";function Q6e(t){let{components:n,...e}=t;return(0,s.kt)(Y6e,(0,p.Z)({},j6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Q6e.isMDXComponent=!0;const H6e={toc:[]},$6e="wrapper";function K6e(t){let{components:n,...e}=t;return(0,s.kt)($6e,(0,p.Z)({},H6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}K6e.isMDXComponent=!0;const J6e={toc:[]},t3e="wrapper";function n3e(t){let{components:n,...e}=t;return(0,s.kt)(t3e,(0,p.Z)({},J6e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}n3e.isMDXComponent=!0;const e3e={toc:[]},o3e="wrapper";function p3e(t){let{components:n,...e}=t;return(0,s.kt)(o3e,(0,p.Z)({},e3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}p3e.isMDXComponent=!0;const r3e={toc:[]},s3e="wrapper";function c3e(t){let{components:n,...e}=t;return(0,s.kt)(s3e,(0,p.Z)({},r3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}c3e.isMDXComponent=!0;const i3e={toc:[]},a3e="wrapper";function l3e(t){let{components:n,...e}=t;return(0,s.kt)(a3e,(0,p.Z)({},i3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}l3e.isMDXComponent=!0;const u3e={toc:[]},m3e="wrapper";function d3e(t){let{components:n,...e}=t;return(0,s.kt)(m3e,(0,p.Z)({},u3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}d3e.isMDXComponent=!0;const h3e={toc:[]},k3e="wrapper";function f3e(t){let{components:n,...e}=t;return(0,s.kt)(k3e,(0,p.Z)({},h3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}f3e.isMDXComponent=!0;const y3e={toc:[]},M3e="wrapper";function D3e(t){let{components:n,...e}=t;return(0,s.kt)(M3e,(0,p.Z)({},y3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}D3e.isMDXComponent=!0;const X3e={toc:[]},_3e="wrapper";function w3e(t){let{components:n,...e}=t;return(0,s.kt)(_3e,(0,p.Z)({},X3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}w3e.isMDXComponent=!0;const T3e={toc:[]},C3e="wrapper";function g3e(t){let{components:n,...e}=t;return(0,s.kt)(C3e,(0,p.Z)({},T3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}g3e.isMDXComponent=!0;const x3e={toc:[]},v3e="wrapper";function L3e(t){let{components:n,...e}=t;return(0,s.kt)(v3e,(0,p.Z)({},x3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}L3e.isMDXComponent=!0;const Z3e={toc:[]},b3e="wrapper";function N3e(t){let{components:n,...e}=t;return(0,s.kt)(b3e,(0,p.Z)({},Z3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}N3e.isMDXComponent=!0;const A3e={toc:[]},z3e="wrapper";function W3e(t){let{components:n,...e}=t;return(0,s.kt)(z3e,(0,p.Z)({},A3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}W3e.isMDXComponent=!0;const I3e={toc:[]},R3e="wrapper";function P3e(t){let{components:n,...e}=t;return(0,s.kt)(R3e,(0,p.Z)({},I3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}P3e.isMDXComponent=!0;const S3e={toc:[]},E3e="wrapper";function G3e(t){let{components:n,...e}=t;return(0,s.kt)(E3e,(0,p.Z)({},S3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}G3e.isMDXComponent=!0;const O3e={toc:[]},F3e="wrapper";function B3e(t){let{components:n,...e}=t;return(0,s.kt)(F3e,(0,p.Z)({},O3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}B3e.isMDXComponent=!0;const U3e={toc:[]},V3e="wrapper";function q3e(t){let{components:n,...e}=t;return(0,s.kt)(V3e,(0,p.Z)({},U3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a tweening list to tween between two SVG nodes."))}q3e.isMDXComponent=!0;const j3e={toc:[]},Y3e="wrapper";function Q3e(t){let{components:n,...e}=t;return(0,s.kt)(Y3e,(0,p.Z)({},j3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial node,"))}Q3e.isMDXComponent=!0;const H3e={toc:[]},$3e="wrapper";function K3e(t){let{components:n,...e}=t;return(0,s.kt)($3e,(0,p.Z)({},H3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The final node."))}K3e.isMDXComponent=!0;const J3e={toc:[]},t5e="wrapper";function n5e(t){let{components:n,...e}=t;return(0,s.kt)(t5e,(0,p.Z)({},J3e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}n5e.isMDXComponent=!0;const e5e={toc:[]},o5e="wrapper";function p5e(t){let{components:n,...e}=t;return(0,s.kt)(o5e,(0,p.Z)({},e5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function."))}p5e.isMDXComponent=!0;const r5e={toc:[]},s5e="wrapper";function c5e(t){let{components:n,...e}=t;return(0,s.kt)(s5e,(0,p.Z)({},r5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}c5e.isMDXComponent=!0;const i5e={toc:[]},a5e="wrapper";function l5e(t){let{components:n,...e}=t;return(0,s.kt)(a5e,(0,p.Z)({},i5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}l5e.isMDXComponent=!0;const u5e={toc:[]},m5e="wrapper";function d5e(t){let{components:n,...e}=t;return(0,s.kt)(m5e,(0,p.Z)({},u5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get all SVG nodes with the given id."))}d5e.isMDXComponent=!0;const h5e={toc:[]},k5e="wrapper";function f5e(t){let{components:n,...e}=t;return(0,s.kt)(k5e,(0,p.Z)({},h5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An id to query."))}f5e.isMDXComponent=!0;const y5e={toc:[]},M5e="wrapper";function D5e(t){let{components:n,...e}=t;return(0,s.kt)(M5e,(0,p.Z)({},y5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}D5e.isMDXComponent=!0;const X5e={toc:[]},_5e="wrapper";function w5e(t){let{components:n,...e}=t;return(0,s.kt)(_5e,(0,p.Z)({},X5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}w5e.isMDXComponent=!0;const T5e={toc:[]},C5e="wrapper";function g5e(t){let{components:n,...e}=t;return(0,s.kt)(C5e,(0,p.Z)({},T5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}g5e.isMDXComponent=!0;const x5e={toc:[]},v5e="wrapper";function L5e(t){let{components:n,...e}=t;return(0,s.kt)(v5e,(0,p.Z)({},x5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}L5e.isMDXComponent=!0;const Z5e={toc:[]},b5e="wrapper";function N5e(t){let{components:n,...e}=t;return(0,s.kt)(b5e,(0,p.Z)({},Z5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}N5e.isMDXComponent=!0;const A5e={toc:[]},z5e="wrapper";function W5e(t){let{components:n,...e}=t;return(0,s.kt)(z5e,(0,p.Z)({},A5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}W5e.isMDXComponent=!0;const I5e={toc:[]},R5e="wrapper";function P5e(t){let{components:n,...e}=t;return(0,s.kt)(R5e,(0,p.Z)({},I5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}P5e.isMDXComponent=!0;const S5e={toc:[]},E5e="wrapper";function G5e(t){let{components:n,...e}=t;return(0,s.kt)(E5e,(0,p.Z)({},S5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}G5e.isMDXComponent=!0;const O5e={toc:[]},F5e="wrapper";function B5e(t){let{components:n,...e}=t;return(0,s.kt)(F5e,(0,p.Z)({},O5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}B5e.isMDXComponent=!0;const U5e={toc:[]},V5e="wrapper";function q5e(t){let{components:n,...e}=t;return(0,s.kt)(V5e,(0,p.Z)({},U5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}q5e.isMDXComponent=!0;const j5e={toc:[]},Y5e="wrapper";function Q5e(t){let{components:n,...e}=t;return(0,s.kt)(Y5e,(0,p.Z)({},j5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Q5e.isMDXComponent=!0;const H5e={toc:[]},$5e="wrapper";function K5e(t){let{components:n,...e}=t;return(0,s.kt)($5e,(0,p.Z)({},H5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}K5e.isMDXComponent=!0;const J5e={toc:[]},t1e="wrapper";function n1e(t){let{components:n,...e}=t;return(0,s.kt)(t1e,(0,p.Z)({},J5e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}n1e.isMDXComponent=!0;const e1e={toc:[]},o1e="wrapper";function p1e(t){let{components:n,...e}=t;return(0,s.kt)(o1e,(0,p.Z)({},e1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}p1e.isMDXComponent=!0;const r1e={toc:[]},s1e="wrapper";function c1e(t){let{components:n,...e}=t;return(0,s.kt)(s1e,(0,p.Z)({},r1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}c1e.isMDXComponent=!0;const i1e={toc:[]},a1e="wrapper";function l1e(t){let{components:n,...e}=t;return(0,s.kt)(a1e,(0,p.Z)({},i1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}l1e.isMDXComponent=!0;const u1e={toc:[]},m1e="wrapper";function d1e(t){let{components:n,...e}=t;return(0,s.kt)(m1e,(0,p.Z)({},u1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}d1e.isMDXComponent=!0;const h1e={toc:[]},k1e="wrapper";function f1e(t){let{components:n,...e}=t;return(0,s.kt)(k1e,(0,p.Z)({},h1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}f1e.isMDXComponent=!0;const y1e={toc:[]},M1e="wrapper";function D1e(t){let{components:n,...e}=t;return(0,s.kt)(M1e,(0,p.Z)({},y1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}D1e.isMDXComponent=!0;const X1e={toc:[]},_1e="wrapper";function w1e(t){let{components:n,...e}=t;return(0,s.kt)(_1e,(0,p.Z)({},X1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}w1e.isMDXComponent=!0;const T1e={toc:[]},C1e="wrapper";function g1e(t){let{components:n,...e}=t;return(0,s.kt)(C1e,(0,p.Z)({},T1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}g1e.isMDXComponent=!0;const x1e={toc:[]},v1e="wrapper";function L1e(t){let{components:n,...e}=t;return(0,s.kt)(v1e,(0,p.Z)({},x1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}L1e.isMDXComponent=!0;const Z1e={toc:[]},b1e="wrapper";function N1e(t){let{components:n,...e}=t;return(0,s.kt)(b1e,(0,p.Z)({},Z1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}N1e.isMDXComponent=!0;const A1e={toc:[]},z1e="wrapper";function W1e(t){let{components:n,...e}=t;return(0,s.kt)(z1e,(0,p.Z)({},A1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}W1e.isMDXComponent=!0;const I1e={toc:[]},R1e="wrapper";function P1e(t){let{components:n,...e}=t;return(0,s.kt)(R1e,(0,p.Z)({},I1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}P1e.isMDXComponent=!0;const S1e={toc:[]},E1e="wrapper";function G1e(t){let{components:n,...e}=t;return(0,s.kt)(E1e,(0,p.Z)({},S1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}G1e.isMDXComponent=!0;const O1e={toc:[]},F1e="wrapper";function B1e(t){let{components:n,...e}=t;return(0,s.kt)(F1e,(0,p.Z)({},O1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}B1e.isMDXComponent=!0;const U1e={toc:[]},V1e="wrapper";function q1e(t){let{components:n,...e}=t;return(0,s.kt)(V1e,(0,p.Z)({},U1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}q1e.isMDXComponent=!0;const j1e={toc:[]},Y1e="wrapper";function Q1e(t){let{components:n,...e}=t;return(0,s.kt)(Y1e,(0,p.Z)({},j1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Q1e.isMDXComponent=!0;const H1e={toc:[]},$1e="wrapper";function K1e(t){let{components:n,...e}=t;return(0,s.kt)($1e,(0,p.Z)({},H1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}K1e.isMDXComponent=!0;const J1e={toc:[]},t4e="wrapper";function n4e(t){let{components:n,...e}=t;return(0,s.kt)(t4e,(0,p.Z)({},J1e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}n4e.isMDXComponent=!0;const e4e={toc:[]},o4e="wrapper";function p4e(t){let{components:n,...e}=t;return(0,s.kt)(o4e,(0,p.Z)({},e4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}p4e.isMDXComponent=!0;const r4e={toc:[]},s4e="wrapper";function c4e(t){let{components:n,...e}=t;return(0,s.kt)(s4e,(0,p.Z)({},r4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}c4e.isMDXComponent=!0;const i4e={toc:[]},a4e="wrapper";function l4e(t){let{components:n,...e}=t;return(0,s.kt)(a4e,(0,p.Z)({},i4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}l4e.isMDXComponent=!0;const u4e={toc:[]},m4e="wrapper";function d4e(t){let{components:n,...e}=t;return(0,s.kt)(m4e,(0,p.Z)({},u4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}d4e.isMDXComponent=!0;const h4e={toc:[]},k4e="wrapper";function f4e(t){let{components:n,...e}=t;return(0,s.kt)(k4e,(0,p.Z)({},h4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}f4e.isMDXComponent=!0;const y4e={toc:[]},M4e="wrapper";function D4e(t){let{components:n,...e}=t;return(0,s.kt)(M4e,(0,p.Z)({},y4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}D4e.isMDXComponent=!0;const X4e={toc:[]},_4e="wrapper";function w4e(t){let{components:n,...e}=t;return(0,s.kt)(_4e,(0,p.Z)({},X4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}w4e.isMDXComponent=!0;const T4e={toc:[]},C4e="wrapper";function g4e(t){let{components:n,...e}=t;return(0,s.kt)(C4e,(0,p.Z)({},T4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}g4e.isMDXComponent=!0;const x4e={toc:[]},v4e="wrapper";function L4e(t){let{components:n,...e}=t;return(0,s.kt)(v4e,(0,p.Z)({},x4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}L4e.isMDXComponent=!0;const Z4e={toc:[]},b4e="wrapper";function N4e(t){let{components:n,...e}=t;return(0,s.kt)(b4e,(0,p.Z)({},Z4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}N4e.isMDXComponent=!0;const A4e={toc:[]},z4e="wrapper";function W4e(t){let{components:n,...e}=t;return(0,s.kt)(z4e,(0,p.Z)({},A4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}W4e.isMDXComponent=!0;const I4e={toc:[]},R4e="wrapper";function P4e(t){let{components:n,...e}=t;return(0,s.kt)(R4e,(0,p.Z)({},I4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}P4e.isMDXComponent=!0;const S4e={toc:[]},E4e="wrapper";function G4e(t){let{components:n,...e}=t;return(0,s.kt)(E4e,(0,p.Z)({},S4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}G4e.isMDXComponent=!0;const O4e={toc:[]},F4e="wrapper";function B4e(t){let{components:n,...e}=t;return(0,s.kt)(F4e,(0,p.Z)({},O4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert an SVG string to ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}B4e.isMDXComponent=!0;const U4e={toc:[]},V4e="wrapper";function q4e(t){let{components:n,...e}=t;return(0,s.kt)(V4e,(0,p.Z)({},U4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An SVG string to be parsed."))}q4e.isMDXComponent=!0;const j4e={toc:[]},Y4e="wrapper";function Q4e(t){let{components:n,...e}=t;return(0,s.kt)(Y4e,(0,p.Z)({},j4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Q4e.isMDXComponent=!0;const H4e={toc:[]},$4e="wrapper";function K4e(t){let{components:n,...e}=t;return(0,s.kt)($4e,(0,p.Z)({},H4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}K4e.isMDXComponent=!0;const J4e={toc:[]},t8e="wrapper";function n8e(t){let{components:n,...e}=t;return(0,s.kt)(t8e,(0,p.Z)({},J4e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}n8e.isMDXComponent=!0;const e8e={toc:[]},o8e="wrapper";function p8e(t){let{components:n,...e}=t;return(0,s.kt)(o8e,(0,p.Z)({},e8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}p8e.isMDXComponent=!0;const r8e={toc:[]},s8e="wrapper";function c8e(t){let{components:n,...e}=t;return(0,s.kt)(s8e,(0,p.Z)({},r8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}c8e.isMDXComponent=!0;const i8e={toc:[]},a8e="wrapper";function l8e(t){let{components:n,...e}=t;return(0,s.kt)(a8e,(0,p.Z)({},i8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}l8e.isMDXComponent=!0;const u8e={toc:[]},m8e="wrapper";function d8e(t){let{components:n,...e}=t;return(0,s.kt)(m8e,(0,p.Z)({},u8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}d8e.isMDXComponent=!0;const h8e={toc:[]},k8e="wrapper";function f8e(t){let{components:n,...e}=t;return(0,s.kt)(k8e,(0,p.Z)({},h8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}f8e.isMDXComponent=!0;const y8e={toc:[]},M8e="wrapper";function D8e(t){let{components:n,...e}=t;return(0,s.kt)(M8e,(0,p.Z)({},y8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}D8e.isMDXComponent=!0;const X8e={toc:[]},_8e="wrapper";function w8e(t){let{components:n,...e}=t;return(0,s.kt)(_8e,(0,p.Z)({},X8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}w8e.isMDXComponent=!0;const T8e={toc:[]},C8e="wrapper";function g8e(t){let{components:n,...e}=t;return(0,s.kt)(C8e,(0,p.Z)({},T8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}g8e.isMDXComponent=!0;const x8e={toc:[]},v8e="wrapper";function L8e(t){let{components:n,...e}=t;return(0,s.kt)(v8e,(0,p.Z)({},x8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}L8e.isMDXComponent=!0;const Z8e={toc:[]},b8e="wrapper";function N8e(t){let{components:n,...e}=t;return(0,s.kt)(b8e,(0,p.Z)({},Z8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}N8e.isMDXComponent=!0;const A8e={toc:[]},z8e="wrapper";function W8e(t){let{components:n,...e}=t;return(0,s.kt)(z8e,(0,p.Z)({},A8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}W8e.isMDXComponent=!0;const I8e={toc:[]},R8e="wrapper";function P8e(t){let{components:n,...e}=t;return(0,s.kt)(R8e,(0,p.Z)({},I8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}P8e.isMDXComponent=!0;const S8e={toc:[]},E8e="wrapper";function G8e(t){let{components:n,...e}=t;return(0,s.kt)(E8e,(0,p.Z)({},S8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}G8e.isMDXComponent=!0;const O8e={toc:[]},F8e="wrapper";function B8e(t){let{components:n,...e}=t;return(0,s.kt)(F8e,(0,p.Z)({},O8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}B8e.isMDXComponent=!0;const U8e={toc:[]},V8e="wrapper";function q8e(t){let{components:n,...e}=t;return(0,s.kt)(V8e,(0,p.Z)({},U8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}q8e.isMDXComponent=!0;const j8e={toc:[]},Y8e="wrapper";function Q8e(t){let{components:n,...e}=t;return(0,s.kt)(Y8e,(0,p.Z)({},j8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Q8e.isMDXComponent=!0;const H8e={toc:[]},$8e="wrapper";function K8e(t){let{components:n,...e}=t;return(0,s.kt)($8e,(0,p.Z)({},H8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}K8e.isMDXComponent=!0;const J8e={toc:[]},t7e="wrapper";function n7e(t){let{components:n,...e}=t;return(0,s.kt)(t7e,(0,p.Z)({},J8e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}n7e.isMDXComponent=!0;const e7e={toc:[]},o7e="wrapper";function p7e(t){let{components:n,...e}=t;return(0,s.kt)(o7e,(0,p.Z)({},e7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}p7e.isMDXComponent=!0;const r7e={toc:[]},s7e="wrapper";function c7e(t){let{components:n,...e}=t;return(0,s.kt)(s7e,(0,p.Z)({},r7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}c7e.isMDXComponent=!0;const i7e={toc:[]},a7e="wrapper";function l7e(t){let{components:n,...e}=t;return(0,s.kt)(a7e,(0,p.Z)({},i7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}l7e.isMDXComponent=!0;const u7e={toc:[]},m7e="wrapper";function d7e(t){let{components:n,...e}=t;return(0,s.kt)(m7e,(0,p.Z)({},u7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}d7e.isMDXComponent=!0;const h7e={toc:[]},k7e="wrapper";function f7e(t){let{components:n,...e}=t;return(0,s.kt)(k7e,(0,p.Z)({},h7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}f7e.isMDXComponent=!0;const y7e={toc:[]},M7e="wrapper";function D7e(t){let{components:n,...e}=t;return(0,s.kt)(M7e,(0,p.Z)({},y7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}D7e.isMDXComponent=!0;const X7e={toc:[]},_7e="wrapper";function w7e(t){let{components:n,...e}=t;return(0,s.kt)(_7e,(0,p.Z)({},X7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}w7e.isMDXComponent=!0;const T7e={toc:[]},C7e="wrapper";function g7e(t){let{components:n,...e}=t;return(0,s.kt)(C7e,(0,p.Z)({},T7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}g7e.isMDXComponent=!0;const x7e={toc:[]},v7e="wrapper";function L7e(t){let{components:n,...e}=t;return(0,s.kt)(v7e,(0,p.Z)({},x7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}L7e.isMDXComponent=!0;const Z7e={toc:[]},b7e="wrapper";function N7e(t){let{components:n,...e}=t;return(0,s.kt)(b7e,(0,p.Z)({},Z7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}N7e.isMDXComponent=!0;const A7e={toc:[]},z7e="wrapper";function W7e(t){let{components:n,...e}=t;return(0,s.kt)(z7e,(0,p.Z)({},A7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}W7e.isMDXComponent=!0;const I7e={toc:[]},R7e="wrapper";function P7e(t){let{components:n,...e}=t;return(0,s.kt)(R7e,(0,p.Z)({},I7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}P7e.isMDXComponent=!0;const S7e={toc:[]},E7e="wrapper";function G7e(t){let{components:n,...e}=t;return(0,s.kt)(E7e,(0,p.Z)({},S7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}G7e.isMDXComponent=!0;const O7e={toc:[]},F7e="wrapper";function B7e(t){let{components:n,...e}=t;return(0,s.kt)(F7e,(0,p.Z)({},O7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}B7e.isMDXComponent=!0;const U7e={toc:[]},V7e="wrapper";function q7e(t){let{components:n,...e}=t;return(0,s.kt)(V7e,(0,p.Z)({},U7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}q7e.isMDXComponent=!0;const j7e={toc:[]},Y7e="wrapper";function Q7e(t){let{components:n,...e}=t;return(0,s.kt)(Y7e,(0,p.Z)({},j7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Q7e.isMDXComponent=!0;const H7e={toc:[]},$7e="wrapper";function K7e(t){let{components:n,...e}=t;return(0,s.kt)($7e,(0,p.Z)({},H7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}K7e.isMDXComponent=!0;const J7e={toc:[]},t9e="wrapper";function n9e(t){let{components:n,...e}=t;return(0,s.kt)(t9e,(0,p.Z)({},J7e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}n9e.isMDXComponent=!0;const e9e={toc:[]},o9e="wrapper";function p9e(t){let{components:n,...e}=t;return(0,s.kt)(o9e,(0,p.Z)({},e9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}p9e.isMDXComponent=!0;const r9e={toc:[]},s9e="wrapper";function c9e(t){let{components:n,...e}=t;return(0,s.kt)(s9e,(0,p.Z)({},r9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}c9e.isMDXComponent=!0;const i9e={toc:[]},a9e="wrapper";function l9e(t){let{components:n,...e}=t;return(0,s.kt)(a9e,(0,p.Z)({},i9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}l9e.isMDXComponent=!0;const u9e={toc:[]},m9e="wrapper";function d9e(t){let{components:n,...e}=t;return(0,s.kt)(m9e,(0,p.Z)({},u9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}d9e.isMDXComponent=!0;const h9e={toc:[]},k9e="wrapper";function f9e(t){let{components:n,...e}=t;return(0,s.kt)(k9e,(0,p.Z)({},h9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"MotionCanvas Shape properties"))}f9e.isMDXComponent=!0;const y9e={toc:[]},M9e="wrapper";function D9e(t){let{components:n,...e}=t;return(0,s.kt)(M9e,(0,p.Z)({},y9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get position, rotation and scale from Matrix transformation as Shape properties"))}D9e.isMDXComponent=!0;const X9e={toc:[]},_9e="wrapper";function w9e(t){let{components:n,...e}=t;return(0,s.kt)(_9e,(0,p.Z)({},X9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Matrix transformation"))}w9e.isMDXComponent=!0;const T9e={toc:[]},C9e="wrapper";function g9e(t){let{components:n,...e}=t;return(0,s.kt)(C9e,(0,p.Z)({},T9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData")," that can be used to build SVGDocument."))}g9e.isMDXComponent=!0;const x9e={toc:[]},v9e="wrapper";function L9e(t){let{components:n,...e}=t;return(0,s.kt)(v9e,(0,p.Z)({},x9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse an SVG string as ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData"),"."))}L9e.isMDXComponent=!0;const Z9e={toc:[]},b9e="wrapper";function N9e(t){let{components:n,...e}=t;return(0,s.kt)(b9e,(0,p.Z)({},Z9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"And SVG string to be parsed."))}N9e.isMDXComponent=!0;const A9e={toc:[]},z9e="wrapper";function W9e(t){let{components:n,...e}=t;return(0,s.kt)(z9e,(0,p.Z)({},A9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}W9e.isMDXComponent=!0;const I9e={toc:[]},R9e="wrapper";function P9e(t){let{components:n,...e}=t;return(0,s.kt)(R9e,(0,p.Z)({},I9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}P9e.isMDXComponent=!0;const S9e={toc:[]},E9e="wrapper";function G9e(t){let{components:n,...e}=t;return(0,s.kt)(E9e,(0,p.Z)({},S9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}G9e.isMDXComponent=!0;const O9e={toc:[]},F9e="wrapper";function B9e(t){let{components:n,...e}=t;return(0,s.kt)(F9e,(0,p.Z)({},O9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}B9e.isMDXComponent=!0;const U9e={toc:[]},V9e="wrapper";function q9e(t){let{components:n,...e}=t;return(0,s.kt)(V9e,(0,p.Z)({},U9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}q9e.isMDXComponent=!0;const j9e={toc:[]},Y9e="wrapper";function Q9e(t){let{components:n,...e}=t;return(0,s.kt)(Y9e,(0,p.Z)({},j9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Q9e.isMDXComponent=!0;const H9e={toc:[]},$9e="wrapper";function K9e(t){let{components:n,...e}=t;return(0,s.kt)($9e,(0,p.Z)({},H9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}K9e.isMDXComponent=!0;const J9e={toc:[]},tto="wrapper";function nto(t){let{components:n,...e}=t;return(0,s.kt)(tto,(0,p.Z)({},J9e,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}nto.isMDXComponent=!0;const eto={toc:[]},oto="wrapper";function pto(t){let{components:n,...e}=t;return(0,s.kt)(oto,(0,p.Z)({},eto,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}pto.isMDXComponent=!0;const rto={toc:[]},sto="wrapper";function cto(t){let{components:n,...e}=t;return(0,s.kt)(sto,(0,p.Z)({},rto,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}cto.isMDXComponent=!0;const ito={toc:[]},ato="wrapper";function lto(t){let{components:n,...e}=t;return(0,s.kt)(ato,(0,p.Z)({},ito,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}lto.isMDXComponent=!0;const uto={toc:[]},mto="wrapper";function dto(t){let{components:n,...e}=t;return(0,s.kt)(mto,(0,p.Z)({},uto,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}dto.isMDXComponent=!0;const hto={toc:[]},kto="wrapper";function fto(t){let{components:n,...e}=t;return(0,s.kt)(kto,(0,p.Z)({},hto,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}fto.isMDXComponent=!0;const yto={toc:[]},Mto="wrapper";function Dto(t){let{components:n,...e}=t;return(0,s.kt)(Mto,(0,p.Z)({},yto,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Dto.isMDXComponent=!0;const Xto={toc:[]},_to="wrapper";function wto(t){let{components:n,...e}=t;return(0,s.kt)(_to,(0,p.Z)({},Xto,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}wto.isMDXComponent=!0;const Tto={toc:[]},Cto="wrapper";function gto(t){let{components:n,...e}=t;return(0,s.kt)(Cto,(0,p.Z)({},Tto,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}gto.isMDXComponent=!0;const xto={toc:[]},vto="wrapper";function Lto(t){let{components:n,...e}=t;return(0,s.kt)(vto,(0,p.Z)({},xto,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Lto.isMDXComponent=!0;const Zto={toc:[]},bto="wrapper";function Nto(t){let{components:n,...e}=t;return(0,s.kt)(bto,(0,p.Z)({},Zto,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Nto.isMDXComponent=!0;const Ato={toc:[]},zto="wrapper";function Wto(t){let{components:n,...e}=t;return(0,s.kt)(zto,(0,p.Z)({},Ato,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Wto.isMDXComponent=!0;const Ito={toc:[]},Rto="wrapper";function Pto(t){let{components:n,...e}=t;return(0,s.kt)(Rto,(0,p.Z)({},Ito,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Pto.isMDXComponent=!0;const Sto={toc:[]},Eto="wrapper";function Gto(t){let{components:n,...e}=t;return(0,s.kt)(Eto,(0,p.Z)({},Sto,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Gto.isMDXComponent=!0;const Oto={toc:[]},Fto="wrapper";function Bto(t){let{components:n,...e}=t;return(0,s.kt)(Fto,(0,p.Z)({},Oto,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Bto.isMDXComponent=!0;const Uto={toc:[]},Vto="wrapper";function qto(t){let{components:n,...e}=t;return(0,s.kt)(Vto,(0,p.Z)({},Uto,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}qto.isMDXComponent=!0;const jto={toc:[]},Yto="wrapper";function Qto(t){let{components:n,...e}=t;return(0,s.kt)(Yto,(0,p.Z)({},jto,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Qto.isMDXComponent=!0;const Hto={toc:[]},$to="wrapper";function Kto(t){let{components:n,...e}=t;return(0,s.kt)($to,(0,p.Z)({},Hto,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Kto.isMDXComponent=!0;const Jto={toc:[]},tno="wrapper";function nno(t){let{components:n,...e}=t;return(0,s.kt)(tno,(0,p.Z)({},Jto,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}nno.isMDXComponent=!0;const eno={toc:[]},ono="wrapper";function pno(t){let{components:n,...e}=t;return(0,s.kt)(ono,(0,p.Z)({},eno,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}pno.isMDXComponent=!0;const rno={toc:[]},sno="wrapper";function cno(t){let{components:n,...e}=t;return(0,s.kt)(sno,(0,p.Z)({},rno,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}cno.isMDXComponent=!0;const ino={toc:[]},ano="wrapper";function lno(t){let{components:n,...e}=t;return(0,s.kt)(ano,(0,p.Z)({},ino,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}lno.isMDXComponent=!0;const uno={toc:[]},mno="wrapper";function dno(t){let{components:n,...e}=t;return(0,s.kt)(mno,(0,p.Z)({},uno,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}dno.isMDXComponent=!0;const hno={toc:[]},kno="wrapper";function fno(t){let{components:n,...e}=t;return(0,s.kt)(kno,(0,p.Z)({},hno,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}fno.isMDXComponent=!0;const yno={toc:[]},Mno="wrapper";function Dno(t){let{components:n,...e}=t;return(0,s.kt)(Mno,(0,p.Z)({},yno,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Dno.isMDXComponent=!0;const Xno={toc:[]},_no="wrapper";function wno(t){let{components:n,...e}=t;return(0,s.kt)(_no,(0,p.Z)({},Xno,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}wno.isMDXComponent=!0;const Tno={toc:[]},Cno="wrapper";function gno(t){let{components:n,...e}=t;return(0,s.kt)(Cno,(0,p.Z)({},Tno,e,{components:n,mdxType:"MDXLayout"}))}gno.isMDXComponent=!0;const xno={toc:[]},vno="wrapper";function Lno(t){let{components:n,...e}=t;return(0,s.kt)(vno,(0,p.Z)({},xno,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Lno.isMDXComponent=!0;const Zno={toc:[]},bno="wrapper";function Nno(t){let{components:n,...e}=t;return(0,s.kt)(bno,(0,p.Z)({},Zno,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Nno.isMDXComponent=!0;const Ano={toc:[]},zno="wrapper";function Wno(t){let{components:n,...e}=t;return(0,s.kt)(zno,(0,p.Z)({},Ano,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Wno.isMDXComponent=!0;const Ino={toc:[]},Rno="wrapper";function Pno(t){let{components:n,...e}=t;return(0,s.kt)(Rno,(0,p.Z)({},Ino,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Pno.isMDXComponent=!0;const Sno={toc:[]},Eno="wrapper";function Gno(t){let{components:n,...e}=t;return(0,s.kt)(Eno,(0,p.Z)({},Sno,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Gno.isMDXComponent=!0;const Ono={toc:[]},Fno="wrapper";function Bno(t){let{components:n,...e}=t;return(0,s.kt)(Fno,(0,p.Z)({},Ono,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Bno.isMDXComponent=!0;const Uno={toc:[]},Vno="wrapper";function qno(t){let{components:n,...e}=t;return(0,s.kt)(Vno,(0,p.Z)({},Uno,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}qno.isMDXComponent=!0;const jno={toc:[]},Yno="wrapper";function Qno(t){let{components:n,...e}=t;return(0,s.kt)(Yno,(0,p.Z)({},jno,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Qno.isMDXComponent=!0;const Hno={toc:[]},$no="wrapper";function Kno(t){let{components:n,...e}=t;return(0,s.kt)($no,(0,p.Z)({},Hno,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Kno.isMDXComponent=!0;const Jno={toc:[]},teo="wrapper";function neo(t){let{components:n,...e}=t;return(0,s.kt)(teo,(0,p.Z)({},Jno,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}neo.isMDXComponent=!0;const eeo={toc:[]},oeo="wrapper";function peo(t){let{components:n,...e}=t;return(0,s.kt)(oeo,(0,p.Z)({},eeo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}peo.isMDXComponent=!0;const reo={toc:[]},seo="wrapper";function ceo(t){let{components:n,...e}=t;return(0,s.kt)(seo,(0,p.Z)({},reo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}ceo.isMDXComponent=!0;const ieo={toc:[]},aeo="wrapper";function leo(t){let{components:n,...e}=t;return(0,s.kt)(aeo,(0,p.Z)({},ieo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}leo.isMDXComponent=!0;const ueo={toc:[]},meo="wrapper";function deo(t){let{components:n,...e}=t;return(0,s.kt)(meo,(0,p.Z)({},ueo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}deo.isMDXComponent=!0;const heo={toc:[]},keo="wrapper";function feo(t){let{components:n,...e}=t;return(0,s.kt)(keo,(0,p.Z)({},heo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}feo.isMDXComponent=!0;const yeo={toc:[]},Meo="wrapper";function Deo(t){let{components:n,...e}=t;return(0,s.kt)(Meo,(0,p.Z)({},yeo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Deo.isMDXComponent=!0;const Xeo={toc:[]},_eo="wrapper";function weo(t){let{components:n,...e}=t;return(0,s.kt)(_eo,(0,p.Z)({},Xeo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}weo.isMDXComponent=!0;const Teo={toc:[]},Ceo="wrapper";function geo(t){let{components:n,...e}=t;return(0,s.kt)(Ceo,(0,p.Z)({},Teo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}geo.isMDXComponent=!0;const xeo={toc:[]},veo="wrapper";function Leo(t){let{components:n,...e}=t;return(0,s.kt)(veo,(0,p.Z)({},xeo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Leo.isMDXComponent=!0;const Zeo={toc:[]},beo="wrapper";function Neo(t){let{components:n,...e}=t;return(0,s.kt)(beo,(0,p.Z)({},Zeo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Neo.isMDXComponent=!0;const Aeo={toc:[]},zeo="wrapper";function Weo(t){let{components:n,...e}=t;return(0,s.kt)(zeo,(0,p.Z)({},Aeo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Weo.isMDXComponent=!0;const Ieo={toc:[]},Reo="wrapper";function Peo(t){let{components:n,...e}=t;return(0,s.kt)(Reo,(0,p.Z)({},Ieo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Peo.isMDXComponent=!0;const Seo={toc:[]},Eeo="wrapper";function Geo(t){let{components:n,...e}=t;return(0,s.kt)(Eeo,(0,p.Z)({},Seo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Geo.isMDXComponent=!0;const Oeo={toc:[]},Feo="wrapper";function Beo(t){let{components:n,...e}=t;return(0,s.kt)(Feo,(0,p.Z)({},Oeo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Beo.isMDXComponent=!0;const Ueo={toc:[]},Veo="wrapper";function qeo(t){let{components:n,...e}=t;return(0,s.kt)(Veo,(0,p.Z)({},Ueo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}qeo.isMDXComponent=!0;const jeo={toc:[]},Yeo="wrapper";function Qeo(t){let{components:n,...e}=t;return(0,s.kt)(Yeo,(0,p.Z)({},jeo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Qeo.isMDXComponent=!0;const Heo={toc:[]},$eo="wrapper";function Keo(t){let{components:n,...e}=t;return(0,s.kt)($eo,(0,p.Z)({},Heo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Keo.isMDXComponent=!0;const Jeo={toc:[]},too="wrapper";function noo(t){let{components:n,...e}=t;return(0,s.kt)(too,(0,p.Z)({},Jeo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}noo.isMDXComponent=!0;const eoo={toc:[]},ooo="wrapper";function poo(t){let{components:n,...e}=t;return(0,s.kt)(ooo,(0,p.Z)({},eoo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}poo.isMDXComponent=!0;const roo={toc:[]},soo="wrapper";function coo(t){let{components:n,...e}=t;return(0,s.kt)(soo,(0,p.Z)({},roo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}coo.isMDXComponent=!0;const ioo={toc:[]},aoo="wrapper";function loo(t){let{components:n,...e}=t;return(0,s.kt)(aoo,(0,p.Z)({},ioo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}loo.isMDXComponent=!0;const uoo={toc:[]},moo="wrapper";function doo(t){let{components:n,...e}=t;return(0,s.kt)(moo,(0,p.Z)({},uoo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}doo.isMDXComponent=!0;const hoo={toc:[]},koo="wrapper";function foo(t){let{components:n,...e}=t;return(0,s.kt)(koo,(0,p.Z)({},hoo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}foo.isMDXComponent=!0;const yoo={toc:[]},Moo="wrapper";function Doo(t){let{components:n,...e}=t;return(0,s.kt)(Moo,(0,p.Z)({},yoo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Doo.isMDXComponent=!0;const Xoo={toc:[]},_oo="wrapper";function woo(t){let{components:n,...e}=t;return(0,s.kt)(_oo,(0,p.Z)({},Xoo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}woo.isMDXComponent=!0;const Too={toc:[]},Coo="wrapper";function goo(t){let{components:n,...e}=t;return(0,s.kt)(Coo,(0,p.Z)({},Too,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}goo.isMDXComponent=!0;const xoo={toc:[]},voo="wrapper";function Loo(t){let{components:n,...e}=t;return(0,s.kt)(voo,(0,p.Z)({},xoo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Loo.isMDXComponent=!0;const Zoo={toc:[]},boo="wrapper";function Noo(t){let{components:n,...e}=t;return(0,s.kt)(boo,(0,p.Z)({},Zoo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Noo.isMDXComponent=!0;const Aoo={toc:[]},zoo="wrapper";function Woo(t){let{components:n,...e}=t;return(0,s.kt)(zoo,(0,p.Z)({},Aoo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Woo.isMDXComponent=!0;const Ioo={toc:[]},Roo="wrapper";function Poo(t){let{components:n,...e}=t;return(0,s.kt)(Roo,(0,p.Z)({},Ioo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Poo.isMDXComponent=!0;const Soo={toc:[]},Eoo="wrapper";function Goo(t){let{components:n,...e}=t;return(0,s.kt)(Eoo,(0,p.Z)({},Soo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Goo.isMDXComponent=!0;const Ooo={toc:[]},Foo="wrapper";function Boo(t){let{components:n,...e}=t;return(0,s.kt)(Foo,(0,p.Z)({},Ooo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Boo.isMDXComponent=!0;const Uoo={toc:[]},Voo="wrapper";function qoo(t){let{components:n,...e}=t;return(0,s.kt)(Voo,(0,p.Z)({},Uoo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qoo.isMDXComponent=!0;const joo={toc:[]},Yoo="wrapper";function Qoo(t){let{components:n,...e}=t;return(0,s.kt)(Yoo,(0,p.Z)({},joo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Qoo.isMDXComponent=!0;const Hoo={toc:[]},$oo="wrapper";function Koo(t){let{components:n,...e}=t;return(0,s.kt)($oo,(0,p.Z)({},Hoo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Koo.isMDXComponent=!0;const Joo={toc:[]},tpo="wrapper";function npo(t){let{components:n,...e}=t;return(0,s.kt)(tpo,(0,p.Z)({},Joo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}npo.isMDXComponent=!0;const epo={toc:[]},opo="wrapper";function ppo(t){let{components:n,...e}=t;return(0,s.kt)(opo,(0,p.Z)({},epo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}ppo.isMDXComponent=!0;const rpo={toc:[]},spo="wrapper";function cpo(t){let{components:n,...e}=t;return(0,s.kt)(spo,(0,p.Z)({},rpo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}cpo.isMDXComponent=!0;const ipo={toc:[]},apo="wrapper";function lpo(t){let{components:n,...e}=t;return(0,s.kt)(apo,(0,p.Z)({},ipo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lpo.isMDXComponent=!0;const upo={toc:[]},mpo="wrapper";function dpo(t){let{components:n,...e}=t;return(0,s.kt)(mpo,(0,p.Z)({},upo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}dpo.isMDXComponent=!0;const hpo={toc:[]},kpo="wrapper";function fpo(t){let{components:n,...e}=t;return(0,s.kt)(kpo,(0,p.Z)({},hpo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}fpo.isMDXComponent=!0;const ypo={toc:[]},Mpo="wrapper";function Dpo(t){let{components:n,...e}=t;return(0,s.kt)(Mpo,(0,p.Z)({},ypo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Dpo.isMDXComponent=!0;const Xpo={toc:[]},_po="wrapper";function wpo(t){let{components:n,...e}=t;return(0,s.kt)(_po,(0,p.Z)({},Xpo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wpo.isMDXComponent=!0;const Tpo={toc:[]},Cpo="wrapper";function gpo(t){let{components:n,...e}=t;return(0,s.kt)(Cpo,(0,p.Z)({},Tpo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}gpo.isMDXComponent=!0;const xpo={toc:[]},vpo="wrapper";function Lpo(t){let{components:n,...e}=t;return(0,s.kt)(vpo,(0,p.Z)({},xpo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Lpo.isMDXComponent=!0;const Zpo={toc:[]},bpo="wrapper";function Npo(t){let{components:n,...e}=t;return(0,s.kt)(bpo,(0,p.Z)({},Zpo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Npo.isMDXComponent=!0;const Apo={toc:[]},zpo="wrapper";function Wpo(t){let{components:n,...e}=t;return(0,s.kt)(zpo,(0,p.Z)({},Apo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Wpo.isMDXComponent=!0;const Ipo={toc:[]},Rpo="wrapper";function Ppo(t){let{components:n,...e}=t;return(0,s.kt)(Rpo,(0,p.Z)({},Ipo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Ppo.isMDXComponent=!0;const Spo={toc:[]},Epo="wrapper";function Gpo(t){let{components:n,...e}=t;return(0,s.kt)(Epo,(0,p.Z)({},Spo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Gpo.isMDXComponent=!0;const Opo={toc:[]},Fpo="wrapper";function Bpo(t){let{components:n,...e}=t;return(0,s.kt)(Fpo,(0,p.Z)({},Opo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Bpo.isMDXComponent=!0;const Upo={toc:[]},Vpo="wrapper";function qpo(t){let{components:n,...e}=t;return(0,s.kt)(Vpo,(0,p.Z)({},Upo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}qpo.isMDXComponent=!0;const jpo={toc:[]},Ypo="wrapper";function Qpo(t){let{components:n,...e}=t;return(0,s.kt)(Ypo,(0,p.Z)({},jpo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Qpo.isMDXComponent=!0;const Hpo={toc:[]},$po="wrapper";function Kpo(t){let{components:n,...e}=t;return(0,s.kt)($po,(0,p.Z)({},Hpo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Kpo.isMDXComponent=!0;const Jpo={toc:[]},tro="wrapper";function nro(t){let{components:n,...e}=t;return(0,s.kt)(tro,(0,p.Z)({},Jpo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}nro.isMDXComponent=!0;const ero={toc:[]},oro="wrapper";function pro(t){let{components:n,...e}=t;return(0,s.kt)(oro,(0,p.Z)({},ero,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}pro.isMDXComponent=!0;const rro={toc:[]},sro="wrapper";function cro(t){let{components:n,...e}=t;return(0,s.kt)(sro,(0,p.Z)({},rro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}cro.isMDXComponent=!0;const iro={toc:[]},aro="wrapper";function lro(t){let{components:n,...e}=t;return(0,s.kt)(aro,(0,p.Z)({},iro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}lro.isMDXComponent=!0;const uro={toc:[]},mro="wrapper";function dro(t){let{components:n,...e}=t;return(0,s.kt)(mro,(0,p.Z)({},uro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}dro.isMDXComponent=!0;const hro={toc:[]},kro="wrapper";function fro(t){let{components:n,...e}=t;return(0,s.kt)(kro,(0,p.Z)({},hro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}fro.isMDXComponent=!0;const yro={toc:[]},Mro="wrapper";function Dro(t){let{components:n,...e}=t;return(0,s.kt)(Mro,(0,p.Z)({},yro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Dro.isMDXComponent=!0;const Xro={toc:[]},_ro="wrapper";function wro(t){let{components:n,...e}=t;return(0,s.kt)(_ro,(0,p.Z)({},Xro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}wro.isMDXComponent=!0;const Tro={toc:[]},Cro="wrapper";function gro(t){let{components:n,...e}=t;return(0,s.kt)(Cro,(0,p.Z)({},Tro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}gro.isMDXComponent=!0;const xro={toc:[]},vro="wrapper";function Lro(t){let{components:n,...e}=t;return(0,s.kt)(vro,(0,p.Z)({},xro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Lro.isMDXComponent=!0;const Zro={toc:[]},bro="wrapper";function Nro(t){let{components:n,...e}=t;return(0,s.kt)(bro,(0,p.Z)({},Zro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Nro.isMDXComponent=!0;const Aro={toc:[]},zro="wrapper";function Wro(t){let{components:n,...e}=t;return(0,s.kt)(zro,(0,p.Z)({},Aro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Wro.isMDXComponent=!0;const Iro={toc:[]},Rro="wrapper";function Pro(t){let{components:n,...e}=t;return(0,s.kt)(Rro,(0,p.Z)({},Iro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Pro.isMDXComponent=!0;const Sro={toc:[]},Ero="wrapper";function Gro(t){let{components:n,...e}=t;return(0,s.kt)(Ero,(0,p.Z)({},Sro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Gro.isMDXComponent=!0;const Oro={toc:[]},Fro="wrapper";function Bro(t){let{components:n,...e}=t;return(0,s.kt)(Fro,(0,p.Z)({},Oro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Bro.isMDXComponent=!0;const Uro={toc:[]},Vro="wrapper";function qro(t){let{components:n,...e}=t;return(0,s.kt)(Vro,(0,p.Z)({},Uro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}qro.isMDXComponent=!0;const jro={toc:[]},Yro="wrapper";function Qro(t){let{components:n,...e}=t;return(0,s.kt)(Yro,(0,p.Z)({},jro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Qro.isMDXComponent=!0;const Hro={toc:[]},$ro="wrapper";function Kro(t){let{components:n,...e}=t;return(0,s.kt)($ro,(0,p.Z)({},Hro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Kro.isMDXComponent=!0;const Jro={toc:[]},tso="wrapper";function nso(t){let{components:n,...e}=t;return(0,s.kt)(tso,(0,p.Z)({},Jro,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}nso.isMDXComponent=!0;const eso={toc:[]},oso="wrapper";function pso(t){let{components:n,...e}=t;return(0,s.kt)(oso,(0,p.Z)({},eso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}pso.isMDXComponent=!0;const rso={toc:[]},sso="wrapper";function cso(t){let{components:n,...e}=t;return(0,s.kt)(sso,(0,p.Z)({},rso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}cso.isMDXComponent=!0;const iso={toc:[]},aso="wrapper";function lso(t){let{components:n,...e}=t;return(0,s.kt)(aso,(0,p.Z)({},iso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}lso.isMDXComponent=!0;const uso={toc:[]},mso="wrapper";function dso(t){let{components:n,...e}=t;return(0,s.kt)(mso,(0,p.Z)({},uso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}dso.isMDXComponent=!0;const hso={toc:[]},kso="wrapper";function fso(t){let{components:n,...e}=t;return(0,s.kt)(kso,(0,p.Z)({},hso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}fso.isMDXComponent=!0;const yso={toc:[]},Mso="wrapper";function Dso(t){let{components:n,...e}=t;return(0,s.kt)(Mso,(0,p.Z)({},yso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Dso.isMDXComponent=!0;const Xso={toc:[]},_so="wrapper";function wso(t){let{components:n,...e}=t;return(0,s.kt)(_so,(0,p.Z)({},Xso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}wso.isMDXComponent=!0;const Tso={toc:[]},Cso="wrapper";function gso(t){let{components:n,...e}=t;return(0,s.kt)(Cso,(0,p.Z)({},Tso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}gso.isMDXComponent=!0;const xso={toc:[]},vso="wrapper";function Lso(t){let{components:n,...e}=t;return(0,s.kt)(vso,(0,p.Z)({},xso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Lso.isMDXComponent=!0;const Zso={toc:[]},bso="wrapper";function Nso(t){let{components:n,...e}=t;return(0,s.kt)(bso,(0,p.Z)({},Zso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Nso.isMDXComponent=!0;const Aso={toc:[]},zso="wrapper";function Wso(t){let{components:n,...e}=t;return(0,s.kt)(zso,(0,p.Z)({},Aso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Wso.isMDXComponent=!0;const Iso={toc:[]},Rso="wrapper";function Pso(t){let{components:n,...e}=t;return(0,s.kt)(Rso,(0,p.Z)({},Iso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Pso.isMDXComponent=!0;const Sso={toc:[]},Eso="wrapper";function Gso(t){let{components:n,...e}=t;return(0,s.kt)(Eso,(0,p.Z)({},Sso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Gso.isMDXComponent=!0;const Oso={toc:[]},Fso="wrapper";function Bso(t){let{components:n,...e}=t;return(0,s.kt)(Fso,(0,p.Z)({},Oso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Bso.isMDXComponent=!0;const Uso={toc:[]},Vso="wrapper";function qso(t){let{components:n,...e}=t;return(0,s.kt)(Vso,(0,p.Z)({},Uso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}qso.isMDXComponent=!0;const jso={toc:[]},Yso="wrapper";function Qso(t){let{components:n,...e}=t;return(0,s.kt)(Yso,(0,p.Z)({},jso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Qso.isMDXComponent=!0;const Hso={toc:[]},$so="wrapper";function Kso(t){let{components:n,...e}=t;return(0,s.kt)($so,(0,p.Z)({},Hso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Kso.isMDXComponent=!0;const Jso={toc:[]},tco="wrapper";function nco(t){let{components:n,...e}=t;return(0,s.kt)(tco,(0,p.Z)({},Jso,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}nco.isMDXComponent=!0;const eco={toc:[]},oco="wrapper";function pco(t){let{components:n,...e}=t;return(0,s.kt)(oco,(0,p.Z)({},eco,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}pco.isMDXComponent=!0;const rco={toc:[]},sco="wrapper";function cco(t){let{components:n,...e}=t;return(0,s.kt)(sco,(0,p.Z)({},rco,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}cco.isMDXComponent=!0;const ico={toc:[]},aco="wrapper";function lco(t){let{components:n,...e}=t;return(0,s.kt)(aco,(0,p.Z)({},ico,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}lco.isMDXComponent=!0;const uco={toc:[]},mco="wrapper";function dco(t){let{components:n,...e}=t;return(0,s.kt)(mco,(0,p.Z)({},uco,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dco.isMDXComponent=!0;const hco={toc:[]},kco="wrapper";function fco(t){let{components:n,...e}=t;return(0,s.kt)(kco,(0,p.Z)({},hco,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}fco.isMDXComponent=!0;const yco={toc:[]},Mco="wrapper";function Dco(t){let{components:n,...e}=t;return(0,s.kt)(Mco,(0,p.Z)({},yco,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Dco.isMDXComponent=!0;const Xco={toc:[]},_co="wrapper";function wco(t){let{components:n,...e}=t;return(0,s.kt)(_co,(0,p.Z)({},Xco,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}wco.isMDXComponent=!0;const Tco={toc:[]},Cco="wrapper";function gco(t){let{components:n,...e}=t;return(0,s.kt)(Cco,(0,p.Z)({},Tco,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}gco.isMDXComponent=!0;const xco={toc:[]},vco="wrapper";function Lco(t){let{components:n,...e}=t;return(0,s.kt)(vco,(0,p.Z)({},xco,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Lco.isMDXComponent=!0;const Zco={toc:[]},bco="wrapper";function Nco(t){let{components:n,...e}=t;return(0,s.kt)(bco,(0,p.Z)({},Zco,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Nco.isMDXComponent=!0;const Aco={toc:[]},zco="wrapper";function Wco(t){let{components:n,...e}=t;return(0,s.kt)(zco,(0,p.Z)({},Aco,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Wco.isMDXComponent=!0;const Ico={toc:[]},Rco="wrapper";function Pco(t){let{components:n,...e}=t;return(0,s.kt)(Rco,(0,p.Z)({},Ico,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Pco.isMDXComponent=!0;const Sco={toc:[]},Eco="wrapper";function Gco(t){let{components:n,...e}=t;return(0,s.kt)(Eco,(0,p.Z)({},Sco,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Gco.isMDXComponent=!0;const Oco={toc:[]},Fco="wrapper";function Bco(t){let{components:n,...e}=t;return(0,s.kt)(Fco,(0,p.Z)({},Oco,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Bco.isMDXComponent=!0;const Uco={toc:[]},Vco="wrapper";function qco(t){let{components:n,...e}=t;return(0,s.kt)(Vco,(0,p.Z)({},Uco,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}qco.isMDXComponent=!0;const jco={toc:[]},Yco="wrapper";function Qco(t){let{components:n,...e}=t;return(0,s.kt)(Yco,(0,p.Z)({},jco,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Qco.isMDXComponent=!0;const Hco={toc:[]},$co="wrapper";function Kco(t){let{components:n,...e}=t;return(0,s.kt)($co,(0,p.Z)({},Hco,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Kco.isMDXComponent=!0;const Jco={toc:[]},tio="wrapper";function nio(t){let{components:n,...e}=t;return(0,s.kt)(tio,(0,p.Z)({},Jco,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}nio.isMDXComponent=!0;const eio={toc:[]},oio="wrapper";function pio(t){let{components:n,...e}=t;return(0,s.kt)(oio,(0,p.Z)({},eio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pio.isMDXComponent=!0;const rio={toc:[]},sio="wrapper";function cio(t){let{components:n,...e}=t;return(0,s.kt)(sio,(0,p.Z)({},rio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cio.isMDXComponent=!0;const iio={toc:[]},aio="wrapper";function lio(t){let{components:n,...e}=t;return(0,s.kt)(aio,(0,p.Z)({},iio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}lio.isMDXComponent=!0;const uio={toc:[]},mio="wrapper";function dio(t){let{components:n,...e}=t;return(0,s.kt)(mio,(0,p.Z)({},uio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}dio.isMDXComponent=!0;const hio={toc:[]},kio="wrapper";function fio(t){let{components:n,...e}=t;return(0,s.kt)(kio,(0,p.Z)({},hio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}fio.isMDXComponent=!0;const yio={toc:[]},Mio="wrapper";function Dio(t){let{components:n,...e}=t;return(0,s.kt)(Mio,(0,p.Z)({},yio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Dio.isMDXComponent=!0;const Xio={toc:[]},_io="wrapper";function wio(t){let{components:n,...e}=t;return(0,s.kt)(_io,(0,p.Z)({},Xio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}wio.isMDXComponent=!0;const Tio={toc:[]},Cio="wrapper";function gio(t){let{components:n,...e}=t;return(0,s.kt)(Cio,(0,p.Z)({},Tio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}gio.isMDXComponent=!0;const xio={toc:[]},vio="wrapper";function Lio(t){let{components:n,...e}=t;return(0,s.kt)(vio,(0,p.Z)({},xio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Lio.isMDXComponent=!0;const Zio={toc:[]},bio="wrapper";function Nio(t){let{components:n,...e}=t;return(0,s.kt)(bio,(0,p.Z)({},Zio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Nio.isMDXComponent=!0;const Aio={toc:[]},zio="wrapper";function Wio(t){let{components:n,...e}=t;return(0,s.kt)(zio,(0,p.Z)({},Aio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Wio.isMDXComponent=!0;const Iio={toc:[]},Rio="wrapper";function Pio(t){let{components:n,...e}=t;return(0,s.kt)(Rio,(0,p.Z)({},Iio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Pio.isMDXComponent=!0;const Sio={toc:[]},Eio="wrapper";function Gio(t){let{components:n,...e}=t;return(0,s.kt)(Eio,(0,p.Z)({},Sio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Gio.isMDXComponent=!0;const Oio={toc:[]},Fio="wrapper";function Bio(t){let{components:n,...e}=t;return(0,s.kt)(Fio,(0,p.Z)({},Oio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Bio.isMDXComponent=!0;const Uio={toc:[]},Vio="wrapper";function qio(t){let{components:n,...e}=t;return(0,s.kt)(Vio,(0,p.Z)({},Uio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}qio.isMDXComponent=!0;const jio={toc:[]},Yio="wrapper";function Qio(t){let{components:n,...e}=t;return(0,s.kt)(Yio,(0,p.Z)({},jio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Qio.isMDXComponent=!0;const Hio={toc:[]},$io="wrapper";function Kio(t){let{components:n,...e}=t;return(0,s.kt)($io,(0,p.Z)({},Hio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Kio.isMDXComponent=!0;const Jio={toc:[]},tao="wrapper";function nao(t){let{components:n,...e}=t;return(0,s.kt)(tao,(0,p.Z)({},Jio,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}nao.isMDXComponent=!0;const eao={toc:[]},oao="wrapper";function pao(t){let{components:n,...e}=t;return(0,s.kt)(oao,(0,p.Z)({},eao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}pao.isMDXComponent=!0;const rao={toc:[]},sao="wrapper";function cao(t){let{components:n,...e}=t;return(0,s.kt)(sao,(0,p.Z)({},rao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}cao.isMDXComponent=!0;const iao={toc:[]},aao="wrapper";function lao(t){let{components:n,...e}=t;return(0,s.kt)(aao,(0,p.Z)({},iao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}lao.isMDXComponent=!0;const uao={toc:[]},mao="wrapper";function dao(t){let{components:n,...e}=t;return(0,s.kt)(mao,(0,p.Z)({},uao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}dao.isMDXComponent=!0;const hao={toc:[]},kao="wrapper";function fao(t){let{components:n,...e}=t;return(0,s.kt)(kao,(0,p.Z)({},hao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}fao.isMDXComponent=!0;const yao={toc:[]},Mao="wrapper";function Dao(t){let{components:n,...e}=t;return(0,s.kt)(Mao,(0,p.Z)({},yao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Dao.isMDXComponent=!0;const Xao={toc:[]},_ao="wrapper";function wao(t){let{components:n,...e}=t;return(0,s.kt)(_ao,(0,p.Z)({},Xao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}wao.isMDXComponent=!0;const Tao={toc:[]},Cao="wrapper";function gao(t){let{components:n,...e}=t;return(0,s.kt)(Cao,(0,p.Z)({},Tao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}gao.isMDXComponent=!0;const xao={toc:[]},vao="wrapper";function Lao(t){let{components:n,...e}=t;return(0,s.kt)(vao,(0,p.Z)({},xao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}Lao.isMDXComponent=!0;const Zao={toc:[]},bao="wrapper";function Nao(t){let{components:n,...e}=t;return(0,s.kt)(bao,(0,p.Z)({},Zao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining knots using the ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.kt)("p",null,"Defining knots with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}Nao.isMDXComponent=!0;const Aao={toc:[]},zao="wrapper";function Wao(t){let{components:n,...e}=t;return(0,s.kt)(zao,(0,p.Z)({},Aao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a smooth line through a number of points."))}Wao.isMDXComponent=!0;const Iao={toc:[]},Rao="wrapper";function Pao(t){let{components:n,...e}=t;return(0,s.kt)(Rao,(0,p.Z)({},Iao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Pao.isMDXComponent=!0;const Sao={toc:[]},Eao="wrapper";function Gao(t){let{components:n,...e}=t;return(0,s.kt)(Eao,(0,p.Z)({},Sao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Gao.isMDXComponent=!0;const Oao={toc:[]},Fao="wrapper";function Bao(t){let{components:n,...e}=t;return(0,s.kt)(Fao,(0,p.Z)({},Oao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Bao.isMDXComponent=!0;const Uao={toc:[]},Vao="wrapper";function qao(t){let{components:n,...e}=t;return(0,s.kt)(Vao,(0,p.Z)({},Uao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}qao.isMDXComponent=!0;const jao={toc:[]},Yao="wrapper";function Qao(t){let{components:n,...e}=t;return(0,s.kt)(Yao,(0,p.Z)({},jao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Qao.isMDXComponent=!0;const Hao={toc:[]},$ao="wrapper";function Kao(t){let{components:n,...e}=t;return(0,s.kt)($ao,(0,p.Z)({},Hao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Kao.isMDXComponent=!0;const Jao={toc:[]},tlo="wrapper";function nlo(t){let{components:n,...e}=t;return(0,s.kt)(tlo,(0,p.Z)({},Jao,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}nlo.isMDXComponent=!0;const elo={toc:[]},olo="wrapper";function plo(t){let{components:n,...e}=t;return(0,s.kt)(olo,(0,p.Z)({},elo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}plo.isMDXComponent=!0;const rlo={toc:[]},slo="wrapper";function clo(t){let{components:n,...e}=t;return(0,s.kt)(slo,(0,p.Z)({},rlo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}clo.isMDXComponent=!0;const ilo={toc:[]},alo="wrapper";function llo(t){let{components:n,...e}=t;return(0,s.kt)(alo,(0,p.Z)({},ilo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}llo.isMDXComponent=!0;const ulo={toc:[]},mlo="wrapper";function dlo(t){let{components:n,...e}=t;return(0,s.kt)(mlo,(0,p.Z)({},ulo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}dlo.isMDXComponent=!0;const hlo={toc:[]},klo="wrapper";function flo(t){let{components:n,...e}=t;return(0,s.kt)(klo,(0,p.Z)({},hlo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}flo.isMDXComponent=!0;const ylo={toc:[]},Mlo="wrapper";function Dlo(t){let{components:n,...e}=t;return(0,s.kt)(Mlo,(0,p.Z)({},ylo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Dlo.isMDXComponent=!0;const Xlo={toc:[]},_lo="wrapper";function wlo(t){let{components:n,...e}=t;return(0,s.kt)(_lo,(0,p.Z)({},Xlo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}wlo.isMDXComponent=!0;const Tlo={toc:[]},Clo="wrapper";function glo(t){let{components:n,...e}=t;return(0,s.kt)(Clo,(0,p.Z)({},Tlo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}glo.isMDXComponent=!0;const xlo={toc:[]},vlo="wrapper";function Llo(t){let{components:n,...e}=t;return(0,s.kt)(vlo,(0,p.Z)({},xlo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Llo.isMDXComponent=!0;const Zlo={toc:[]},blo="wrapper";function Nlo(t){let{components:n,...e}=t;return(0,s.kt)(blo,(0,p.Z)({},Zlo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Nlo.isMDXComponent=!0;const Alo={toc:[]},zlo="wrapper";function Wlo(t){let{components:n,...e}=t;return(0,s.kt)(zlo,(0,p.Z)({},Alo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Wlo.isMDXComponent=!0;const Ilo={toc:[]},Rlo="wrapper";function Plo(t){let{components:n,...e}=t;return(0,s.kt)(Rlo,(0,p.Z)({},Ilo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Plo.isMDXComponent=!0;const Slo={toc:[]},Elo="wrapper";function Glo(t){let{components:n,...e}=t;return(0,s.kt)(Elo,(0,p.Z)({},Slo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Glo.isMDXComponent=!0;const Olo={toc:[]},Flo="wrapper";function Blo(t){let{components:n,...e}=t;return(0,s.kt)(Flo,(0,p.Z)({},Olo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Blo.isMDXComponent=!0;const Ulo={toc:[]},Vlo="wrapper";function qlo(t){let{components:n,...e}=t;return(0,s.kt)(Vlo,(0,p.Z)({},Ulo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}qlo.isMDXComponent=!0;const jlo={toc:[]},Ylo="wrapper";function Qlo(t){let{components:n,...e}=t;return(0,s.kt)(Ylo,(0,p.Z)({},jlo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Qlo.isMDXComponent=!0;const Hlo={toc:[]},$lo="wrapper";function Klo(t){let{components:n,...e}=t;return(0,s.kt)($lo,(0,p.Z)({},Hlo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Klo.isMDXComponent=!0;const Jlo={toc:[]},tuo="wrapper";function nuo(t){let{components:n,...e}=t;return(0,s.kt)(tuo,(0,p.Z)({},Jlo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}nuo.isMDXComponent=!0;const euo={toc:[]},ouo="wrapper";function puo(t){let{components:n,...e}=t;return(0,s.kt)(ouo,(0,p.Z)({},euo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}puo.isMDXComponent=!0;const ruo={toc:[]},suo="wrapper";function cuo(t){let{components:n,...e}=t;return(0,s.kt)(suo,(0,p.Z)({},ruo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}cuo.isMDXComponent=!0;const iuo={toc:[]},auo="wrapper";function luo(t){let{components:n,...e}=t;return(0,s.kt)(auo,(0,p.Z)({},iuo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}luo.isMDXComponent=!0;const uuo={toc:[]},muo="wrapper";function duo(t){let{components:n,...e}=t;return(0,s.kt)(muo,(0,p.Z)({},uuo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}duo.isMDXComponent=!0;const huo={toc:[]},kuo="wrapper";function fuo(t){let{components:n,...e}=t;return(0,s.kt)(kuo,(0,p.Z)({},huo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}fuo.isMDXComponent=!0;const yuo={toc:[]},Muo="wrapper";function Duo(t){let{components:n,...e}=t;return(0,s.kt)(Muo,(0,p.Z)({},yuo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Duo.isMDXComponent=!0;const Xuo={toc:[]},_uo="wrapper";function wuo(t){let{components:n,...e}=t;return(0,s.kt)(_uo,(0,p.Z)({},Xuo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wuo.isMDXComponent=!0;const Tuo={toc:[]},Cuo="wrapper";function guo(t){let{components:n,...e}=t;return(0,s.kt)(Cuo,(0,p.Z)({},Tuo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}guo.isMDXComponent=!0;const xuo={toc:[]},vuo="wrapper";function Luo(t){let{components:n,...e}=t;return(0,s.kt)(vuo,(0,p.Z)({},xuo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Luo.isMDXComponent=!0;const Zuo={toc:[]},buo="wrapper";function Nuo(t){let{components:n,...e}=t;return(0,s.kt)(buo,(0,p.Z)({},Zuo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Nuo.isMDXComponent=!0;const Auo={toc:[]},zuo="wrapper";function Wuo(t){let{components:n,...e}=t;return(0,s.kt)(zuo,(0,p.Z)({},Auo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Wuo.isMDXComponent=!0;const Iuo={toc:[]},Ruo="wrapper";function Puo(t){let{components:n,...e}=t;return(0,s.kt)(Ruo,(0,p.Z)({},Iuo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Puo.isMDXComponent=!0;const Suo={toc:[]},Euo="wrapper";function Guo(t){let{components:n,...e}=t;return(0,s.kt)(Euo,(0,p.Z)({},Suo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Guo.isMDXComponent=!0;const Ouo={toc:[]},Fuo="wrapper";function Buo(t){let{components:n,...e}=t;return(0,s.kt)(Fuo,(0,p.Z)({},Ouo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Buo.isMDXComponent=!0;const Uuo={toc:[]},Vuo="wrapper";function quo(t){let{components:n,...e}=t;return(0,s.kt)(Vuo,(0,p.Z)({},Uuo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}quo.isMDXComponent=!0;const juo={toc:[]},Yuo="wrapper";function Quo(t){let{components:n,...e}=t;return(0,s.kt)(Yuo,(0,p.Z)({},juo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Quo.isMDXComponent=!0;const Huo={toc:[]},$uo="wrapper";function Kuo(t){let{components:n,...e}=t;return(0,s.kt)($uo,(0,p.Z)({},Huo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Kuo.isMDXComponent=!0;const Juo={toc:[]},tmo="wrapper";function nmo(t){let{components:n,...e}=t;return(0,s.kt)(tmo,(0,p.Z)({},Juo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}nmo.isMDXComponent=!0;const emo={toc:[]},omo="wrapper";function pmo(t){let{components:n,...e}=t;return(0,s.kt)(omo,(0,p.Z)({},emo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0.4"))}pmo.isMDXComponent=!0;const rmo={toc:[]},smo="wrapper";function cmo(t){let{components:n,...e}=t;return(0,s.kt)(smo,(0,p.Z)({},rmo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}cmo.isMDXComponent=!0;const imo={toc:[]},amo="wrapper";function lmo(t){let{components:n,...e}=t;return(0,s.kt)(amo,(0,p.Z)({},imo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}lmo.isMDXComponent=!0;const umo={toc:[]},mmo="wrapper";function dmo(t){let{components:n,...e}=t;return(0,s.kt)(mmo,(0,p.Z)({},umo,e,{components:n,mdxType:"MDXLayout"}))}dmo.isMDXComponent=!0;const hmo={toc:[]},kmo="wrapper";function fmo(t){let{components:n,...e}=t;return(0,s.kt)(kmo,(0,p.Z)({},hmo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}fmo.isMDXComponent=!0;const ymo={toc:[]},Mmo="wrapper";function Dmo(t){let{components:n,...e}=t;return(0,s.kt)(Mmo,(0,p.Z)({},ymo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Dmo.isMDXComponent=!0;const Xmo={toc:[]},_mo="wrapper";function wmo(t){let{components:n,...e}=t;return(0,s.kt)(_mo,(0,p.Z)({},Xmo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wmo.isMDXComponent=!0;const Tmo={toc:[]},Cmo="wrapper";function gmo(t){let{components:n,...e}=t;return(0,s.kt)(Cmo,(0,p.Z)({},Tmo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}gmo.isMDXComponent=!0;const xmo={toc:[]},vmo="wrapper";function Lmo(t){let{components:n,...e}=t;return(0,s.kt)(vmo,(0,p.Z)({},xmo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Lmo.isMDXComponent=!0;const Zmo={toc:[]},bmo="wrapper";function Nmo(t){let{components:n,...e}=t;return(0,s.kt)(bmo,(0,p.Z)({},Zmo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Nmo.isMDXComponent=!0;const Amo={toc:[]},zmo="wrapper";function Wmo(t){let{components:n,...e}=t;return(0,s.kt)(zmo,(0,p.Z)({},Amo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Wmo.isMDXComponent=!0;const Imo={toc:[]},Rmo="wrapper";function Pmo(t){let{components:n,...e}=t;return(0,s.kt)(Rmo,(0,p.Z)({},Imo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Pmo.isMDXComponent=!0;const Smo={toc:[]},Emo="wrapper";function Gmo(t){let{components:n,...e}=t;return(0,s.kt)(Emo,(0,p.Z)({},Smo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Gmo.isMDXComponent=!0;const Omo={toc:[]},Fmo="wrapper";function Bmo(t){let{components:n,...e}=t;return(0,s.kt)(Fmo,(0,p.Z)({},Omo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Bmo.isMDXComponent=!0;const Umo={toc:[]},Vmo="wrapper";function qmo(t){let{components:n,...e}=t;return(0,s.kt)(Vmo,(0,p.Z)({},Umo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}qmo.isMDXComponent=!0;const jmo={toc:[]},Ymo="wrapper";function Qmo(t){let{components:n,...e}=t;return(0,s.kt)(Ymo,(0,p.Z)({},jmo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Qmo.isMDXComponent=!0;const Hmo={toc:[]},$mo="wrapper";function Kmo(t){let{components:n,...e}=t;return(0,s.kt)($mo,(0,p.Z)({},Hmo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Kmo.isMDXComponent=!0;const Jmo={toc:[]},tdo="wrapper";function ndo(t){let{components:n,...e}=t;return(0,s.kt)(tdo,(0,p.Z)({},Jmo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}ndo.isMDXComponent=!0;const edo={toc:[]},odo="wrapper";function pdo(t){let{components:n,...e}=t;return(0,s.kt)(odo,(0,p.Z)({},edo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}pdo.isMDXComponent=!0;const rdo={toc:[]},sdo="wrapper";function cdo(t){let{components:n,...e}=t;return(0,s.kt)(sdo,(0,p.Z)({},rdo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}cdo.isMDXComponent=!0;const ido={toc:[]},ado="wrapper";function ldo(t){let{components:n,...e}=t;return(0,s.kt)(ado,(0,p.Z)({},ido,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}ldo.isMDXComponent=!0;const udo={toc:[]},mdo="wrapper";function ddo(t){let{components:n,...e}=t;return(0,s.kt)(mdo,(0,p.Z)({},udo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}ddo.isMDXComponent=!0;const hdo={toc:[]},kdo="wrapper";function fdo(t){let{components:n,...e}=t;return(0,s.kt)(kdo,(0,p.Z)({},hdo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}fdo.isMDXComponent=!0;const ydo={toc:[]},Mdo="wrapper";function Ddo(t){let{components:n,...e}=t;return(0,s.kt)(Mdo,(0,p.Z)({},ydo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Ddo.isMDXComponent=!0;const Xdo={toc:[]},_do="wrapper";function wdo(t){let{components:n,...e}=t;return(0,s.kt)(_do,(0,p.Z)({},Xdo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}wdo.isMDXComponent=!0;const Tdo={toc:[]},Cdo="wrapper";function gdo(t){let{components:n,...e}=t;return(0,s.kt)(Cdo,(0,p.Z)({},Tdo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}gdo.isMDXComponent=!0;const xdo={toc:[]},vdo="wrapper";function Ldo(t){let{components:n,...e}=t;return(0,s.kt)(vdo,(0,p.Z)({},xdo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Ldo.isMDXComponent=!0;const Zdo={toc:[]},bdo="wrapper";function Ndo(t){let{components:n,...e}=t;return(0,s.kt)(bdo,(0,p.Z)({},Zdo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Ndo.isMDXComponent=!0;const Ado={toc:[]},zdo="wrapper";function Wdo(t){let{components:n,...e}=t;return(0,s.kt)(zdo,(0,p.Z)({},Ado,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Wdo.isMDXComponent=!0;const Ido={toc:[]},Rdo="wrapper";function Pdo(t){let{components:n,...e}=t;return(0,s.kt)(Rdo,(0,p.Z)({},Ido,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Pdo.isMDXComponent=!0;const Sdo={toc:[]},Edo="wrapper";function Gdo(t){let{components:n,...e}=t;return(0,s.kt)(Edo,(0,p.Z)({},Sdo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Gdo.isMDXComponent=!0;const Odo={toc:[]},Fdo="wrapper";function Bdo(t){let{components:n,...e}=t;return(0,s.kt)(Fdo,(0,p.Z)({},Odo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Bdo.isMDXComponent=!0;const Udo={toc:[]},Vdo="wrapper";function qdo(t){let{components:n,...e}=t;return(0,s.kt)(Vdo,(0,p.Z)({},Udo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}qdo.isMDXComponent=!0;const jdo={toc:[]},Ydo="wrapper";function Qdo(t){let{components:n,...e}=t;return(0,s.kt)(Ydo,(0,p.Z)({},jdo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Qdo.isMDXComponent=!0;const Hdo={toc:[]},$do="wrapper";function Kdo(t){let{components:n,...e}=t;return(0,s.kt)($do,(0,p.Z)({},Hdo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Kdo.isMDXComponent=!0;const Jdo={toc:[]},tho="wrapper";function nho(t){let{components:n,...e}=t;return(0,s.kt)(tho,(0,p.Z)({},Jdo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}nho.isMDXComponent=!0;const eho={toc:[]},oho="wrapper";function pho(t){let{components:n,...e}=t;return(0,s.kt)(oho,(0,p.Z)({},eho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pho.isMDXComponent=!0;const rho={toc:[]},sho="wrapper";function cho(t){let{components:n,...e}=t;return(0,s.kt)(sho,(0,p.Z)({},rho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}cho.isMDXComponent=!0;const iho={toc:[]},aho="wrapper";function lho(t){let{components:n,...e}=t;return(0,s.kt)(aho,(0,p.Z)({},iho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}lho.isMDXComponent=!0;const uho={toc:[]},mho="wrapper";function dho(t){let{components:n,...e}=t;return(0,s.kt)(mho,(0,p.Z)({},uho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}dho.isMDXComponent=!0;const hho={toc:[]},kho="wrapper";function fho(t){let{components:n,...e}=t;return(0,s.kt)(kho,(0,p.Z)({},hho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}fho.isMDXComponent=!0;const yho={toc:[]},Mho="wrapper";function Dho(t){let{components:n,...e}=t;return(0,s.kt)(Mho,(0,p.Z)({},yho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Dho.isMDXComponent=!0;const Xho={toc:[]},_ho="wrapper";function who(t){let{components:n,...e}=t;return(0,s.kt)(_ho,(0,p.Z)({},Xho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}who.isMDXComponent=!0;const Tho={toc:[]},Cho="wrapper";function gho(t){let{components:n,...e}=t;return(0,s.kt)(Cho,(0,p.Z)({},Tho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}gho.isMDXComponent=!0;const xho={toc:[]},vho="wrapper";function Lho(t){let{components:n,...e}=t;return(0,s.kt)(vho,(0,p.Z)({},xho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Lho.isMDXComponent=!0;const Zho={toc:[]},bho="wrapper";function Nho(t){let{components:n,...e}=t;return(0,s.kt)(bho,(0,p.Z)({},Zho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Nho.isMDXComponent=!0;const Aho={toc:[]},zho="wrapper";function Who(t){let{components:n,...e}=t;return(0,s.kt)(zho,(0,p.Z)({},Aho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Who.isMDXComponent=!0;const Iho={toc:[]},Rho="wrapper";function Pho(t){let{components:n,...e}=t;return(0,s.kt)(Rho,(0,p.Z)({},Iho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Pho.isMDXComponent=!0;const Sho={toc:[]},Eho="wrapper";function Gho(t){let{components:n,...e}=t;return(0,s.kt)(Eho,(0,p.Z)({},Sho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Gho.isMDXComponent=!0;const Oho={toc:[]},Fho="wrapper";function Bho(t){let{components:n,...e}=t;return(0,s.kt)(Fho,(0,p.Z)({},Oho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Bho.isMDXComponent=!0;const Uho={toc:[]},Vho="wrapper";function qho(t){let{components:n,...e}=t;return(0,s.kt)(Vho,(0,p.Z)({},Uho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}qho.isMDXComponent=!0;const jho={toc:[]},Yho="wrapper";function Qho(t){let{components:n,...e}=t;return(0,s.kt)(Yho,(0,p.Z)({},jho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Qho.isMDXComponent=!0;const Hho={toc:[]},$ho="wrapper";function Kho(t){let{components:n,...e}=t;return(0,s.kt)($ho,(0,p.Z)({},Hho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Kho.isMDXComponent=!0;const Jho={toc:[]},tko="wrapper";function nko(t){let{components:n,...e}=t;return(0,s.kt)(tko,(0,p.Z)({},Jho,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}nko.isMDXComponent=!0;const eko={toc:[]},oko="wrapper";function pko(t){let{components:n,...e}=t;return(0,s.kt)(oko,(0,p.Z)({},eko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pko.isMDXComponent=!0;const rko={toc:[]},sko="wrapper";function cko(t){let{components:n,...e}=t;return(0,s.kt)(sko,(0,p.Z)({},rko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}cko.isMDXComponent=!0;const iko={toc:[]},ako="wrapper";function lko(t){let{components:n,...e}=t;return(0,s.kt)(ako,(0,p.Z)({},iko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}lko.isMDXComponent=!0;const uko={toc:[]},mko="wrapper";function dko(t){let{components:n,...e}=t;return(0,s.kt)(mko,(0,p.Z)({},uko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dko.isMDXComponent=!0;const hko={toc:[]},kko="wrapper";function fko(t){let{components:n,...e}=t;return(0,s.kt)(kko,(0,p.Z)({},hko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}fko.isMDXComponent=!0;const yko={toc:[]},Mko="wrapper";function Dko(t){let{components:n,...e}=t;return(0,s.kt)(Mko,(0,p.Z)({},yko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Dko.isMDXComponent=!0;const Xko={toc:[]},_ko="wrapper";function wko(t){let{components:n,...e}=t;return(0,s.kt)(_ko,(0,p.Z)({},Xko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wko.isMDXComponent=!0;const Tko={toc:[]},Cko="wrapper";function gko(t){let{components:n,...e}=t;return(0,s.kt)(Cko,(0,p.Z)({},Tko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}gko.isMDXComponent=!0;const xko={toc:[]},vko="wrapper";function Lko(t){let{components:n,...e}=t;return(0,s.kt)(vko,(0,p.Z)({},xko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Lko.isMDXComponent=!0;const Zko={toc:[]},bko="wrapper";function Nko(t){let{components:n,...e}=t;return(0,s.kt)(bko,(0,p.Z)({},Zko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Nko.isMDXComponent=!0;const Ako={toc:[]},zko="wrapper";function Wko(t){let{components:n,...e}=t;return(0,s.kt)(zko,(0,p.Z)({},Ako,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Wko.isMDXComponent=!0;const Iko={toc:[]},Rko="wrapper";function Pko(t){let{components:n,...e}=t;return(0,s.kt)(Rko,(0,p.Z)({},Iko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Pko.isMDXComponent=!0;const Sko={toc:[]},Eko="wrapper";function Gko(t){let{components:n,...e}=t;return(0,s.kt)(Eko,(0,p.Z)({},Sko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Gko.isMDXComponent=!0;const Oko={toc:[]},Fko="wrapper";function Bko(t){let{components:n,...e}=t;return(0,s.kt)(Fko,(0,p.Z)({},Oko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Bko.isMDXComponent=!0;const Uko={toc:[]},Vko="wrapper";function qko(t){let{components:n,...e}=t;return(0,s.kt)(Vko,(0,p.Z)({},Uko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}qko.isMDXComponent=!0;const jko={toc:[]},Yko="wrapper";function Qko(t){let{components:n,...e}=t;return(0,s.kt)(Yko,(0,p.Z)({},jko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Qko.isMDXComponent=!0;const Hko={toc:[]},$ko="wrapper";function Kko(t){let{components:n,...e}=t;return(0,s.kt)($ko,(0,p.Z)({},Hko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Kko.isMDXComponent=!0;const Jko={toc:[]},tfo="wrapper";function nfo(t){let{components:n,...e}=t;return(0,s.kt)(tfo,(0,p.Z)({},Jko,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}nfo.isMDXComponent=!0;const efo={toc:[]},ofo="wrapper";function pfo(t){let{components:n,...e}=t;return(0,s.kt)(ofo,(0,p.Z)({},efo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pfo.isMDXComponent=!0;const rfo={toc:[]},sfo="wrapper";function cfo(t){let{components:n,...e}=t;return(0,s.kt)(sfo,(0,p.Z)({},rfo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}cfo.isMDXComponent=!0;const ifo={toc:[]},afo="wrapper";function lfo(t){let{components:n,...e}=t;return(0,s.kt)(afo,(0,p.Z)({},ifo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lfo.isMDXComponent=!0;const ufo={toc:[]},mfo="wrapper";function dfo(t){let{components:n,...e}=t;return(0,s.kt)(mfo,(0,p.Z)({},ufo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}dfo.isMDXComponent=!0;const hfo={toc:[]},kfo="wrapper";function ffo(t){let{components:n,...e}=t;return(0,s.kt)(kfo,(0,p.Z)({},hfo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}ffo.isMDXComponent=!0;const yfo={toc:[]},Mfo="wrapper";function Dfo(t){let{components:n,...e}=t;return(0,s.kt)(Mfo,(0,p.Z)({},yfo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Dfo.isMDXComponent=!0;const Xfo={toc:[]},_fo="wrapper";function wfo(t){let{components:n,...e}=t;return(0,s.kt)(_fo,(0,p.Z)({},Xfo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}wfo.isMDXComponent=!0;const Tfo={toc:[]},Cfo="wrapper";function gfo(t){let{components:n,...e}=t;return(0,s.kt)(Cfo,(0,p.Z)({},Tfo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}gfo.isMDXComponent=!0;const xfo={toc:[]},vfo="wrapper";function Lfo(t){let{components:n,...e}=t;return(0,s.kt)(vfo,(0,p.Z)({},xfo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Lfo.isMDXComponent=!0;const Zfo={toc:[]},bfo="wrapper";function Nfo(t){let{components:n,...e}=t;return(0,s.kt)(bfo,(0,p.Z)({},Zfo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Nfo.isMDXComponent=!0;const Afo={toc:[]},zfo="wrapper";function Wfo(t){let{components:n,...e}=t;return(0,s.kt)(zfo,(0,p.Z)({},Afo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Wfo.isMDXComponent=!0;const Ifo={toc:[]},Rfo="wrapper";function Pfo(t){let{components:n,...e}=t;return(0,s.kt)(Rfo,(0,p.Z)({},Ifo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Pfo.isMDXComponent=!0;const Sfo={toc:[]},Efo="wrapper";function Gfo(t){let{components:n,...e}=t;return(0,s.kt)(Efo,(0,p.Z)({},Sfo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Gfo.isMDXComponent=!0;const Ofo={toc:[]},Ffo="wrapper";function Bfo(t){let{components:n,...e}=t;return(0,s.kt)(Ffo,(0,p.Z)({},Ofo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Bfo.isMDXComponent=!0;const Ufo={toc:[]},Vfo="wrapper";function qfo(t){let{components:n,...e}=t;return(0,s.kt)(Vfo,(0,p.Z)({},Ufo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}qfo.isMDXComponent=!0;const jfo={toc:[]},Yfo="wrapper";function Qfo(t){let{components:n,...e}=t;return(0,s.kt)(Yfo,(0,p.Z)({},jfo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Qfo.isMDXComponent=!0;const Hfo={toc:[]},$fo="wrapper";function Kfo(t){let{components:n,...e}=t;return(0,s.kt)($fo,(0,p.Z)({},Hfo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Kfo.isMDXComponent=!0;const Jfo={toc:[]},tyo="wrapper";function nyo(t){let{components:n,...e}=t;return(0,s.kt)(tyo,(0,p.Z)({},Jfo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}nyo.isMDXComponent=!0;const eyo={toc:[]},oyo="wrapper";function pyo(t){let{components:n,...e}=t;return(0,s.kt)(oyo,(0,p.Z)({},eyo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}pyo.isMDXComponent=!0;const ryo={toc:[]},syo="wrapper";function cyo(t){let{components:n,...e}=t;return(0,s.kt)(syo,(0,p.Z)({},ryo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}cyo.isMDXComponent=!0;const iyo={toc:[]},ayo="wrapper";function lyo(t){let{components:n,...e}=t;return(0,s.kt)(ayo,(0,p.Z)({},iyo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}lyo.isMDXComponent=!0;const uyo={toc:[]},myo="wrapper";function dyo(t){let{components:n,...e}=t;return(0,s.kt)(myo,(0,p.Z)({},uyo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dyo.isMDXComponent=!0;const hyo={toc:[]},kyo="wrapper";function fyo(t){let{components:n,...e}=t;return(0,s.kt)(kyo,(0,p.Z)({},hyo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}fyo.isMDXComponent=!0;const yyo={toc:[]},Myo="wrapper";function Dyo(t){let{components:n,...e}=t;return(0,s.kt)(Myo,(0,p.Z)({},yyo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Dyo.isMDXComponent=!0;const Xyo={toc:[]},_yo="wrapper";function wyo(t){let{components:n,...e}=t;return(0,s.kt)(_yo,(0,p.Z)({},Xyo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wyo.isMDXComponent=!0;const Tyo={toc:[]},Cyo="wrapper";function gyo(t){let{components:n,...e}=t;return(0,s.kt)(Cyo,(0,p.Z)({},Tyo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}gyo.isMDXComponent=!0;const xyo={toc:[]},vyo="wrapper";function Lyo(t){let{components:n,...e}=t;return(0,s.kt)(vyo,(0,p.Z)({},xyo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Lyo.isMDXComponent=!0;const Zyo={toc:[]},byo="wrapper";function Nyo(t){let{components:n,...e}=t;return(0,s.kt)(byo,(0,p.Z)({},Zyo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Nyo.isMDXComponent=!0;const Ayo={toc:[]},zyo="wrapper";function Wyo(t){let{components:n,...e}=t;return(0,s.kt)(zyo,(0,p.Z)({},Ayo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Wyo.isMDXComponent=!0;const Iyo={toc:[]},Ryo="wrapper";function Pyo(t){let{components:n,...e}=t;return(0,s.kt)(Ryo,(0,p.Z)({},Iyo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Pyo.isMDXComponent=!0;const Syo={toc:[]},Eyo="wrapper";function Gyo(t){let{components:n,...e}=t;return(0,s.kt)(Eyo,(0,p.Z)({},Syo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Gyo.isMDXComponent=!0;const Oyo={toc:[]},Fyo="wrapper";function Byo(t){let{components:n,...e}=t;return(0,s.kt)(Fyo,(0,p.Z)({},Oyo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Byo.isMDXComponent=!0;const Uyo={toc:[]},Vyo="wrapper";function qyo(t){let{components:n,...e}=t;return(0,s.kt)(Vyo,(0,p.Z)({},Uyo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qyo.isMDXComponent=!0;const jyo={toc:[]},Yyo="wrapper";function Qyo(t){let{components:n,...e}=t;return(0,s.kt)(Yyo,(0,p.Z)({},jyo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Qyo.isMDXComponent=!0;const Hyo={toc:[]},$yo="wrapper";function Kyo(t){let{components:n,...e}=t;return(0,s.kt)($yo,(0,p.Z)({},Hyo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Kyo.isMDXComponent=!0;const Jyo={toc:[]},tMo="wrapper";function nMo(t){let{components:n,...e}=t;return(0,s.kt)(tMo,(0,p.Z)({},Jyo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}nMo.isMDXComponent=!0;const eMo={toc:[]},oMo="wrapper";function pMo(t){let{components:n,...e}=t;return(0,s.kt)(oMo,(0,p.Z)({},eMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}pMo.isMDXComponent=!0;const rMo={toc:[]},sMo="wrapper";function cMo(t){let{components:n,...e}=t;return(0,s.kt)(sMo,(0,p.Z)({},rMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}cMo.isMDXComponent=!0;const iMo={toc:[]},aMo="wrapper";function lMo(t){let{components:n,...e}=t;return(0,s.kt)(aMo,(0,p.Z)({},iMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}lMo.isMDXComponent=!0;const uMo={toc:[]},mMo="wrapper";function dMo(t){let{components:n,...e}=t;return(0,s.kt)(mMo,(0,p.Z)({},uMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}dMo.isMDXComponent=!0;const hMo={toc:[]},kMo="wrapper";function fMo(t){let{components:n,...e}=t;return(0,s.kt)(kMo,(0,p.Z)({},hMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}fMo.isMDXComponent=!0;const yMo={toc:[]},MMo="wrapper";function DMo(t){let{components:n,...e}=t;return(0,s.kt)(MMo,(0,p.Z)({},yMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}DMo.isMDXComponent=!0;const XMo={toc:[]},_Mo="wrapper";function wMo(t){let{components:n,...e}=t;return(0,s.kt)(_Mo,(0,p.Z)({},XMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}wMo.isMDXComponent=!0;const TMo={toc:[]},CMo="wrapper";function gMo(t){let{components:n,...e}=t;return(0,s.kt)(CMo,(0,p.Z)({},TMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}gMo.isMDXComponent=!0;const xMo={toc:[]},vMo="wrapper";function LMo(t){let{components:n,...e}=t;return(0,s.kt)(vMo,(0,p.Z)({},xMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}LMo.isMDXComponent=!0;const ZMo={toc:[]},bMo="wrapper";function NMo(t){let{components:n,...e}=t;return(0,s.kt)(bMo,(0,p.Z)({},ZMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}NMo.isMDXComponent=!0;const AMo={toc:[]},zMo="wrapper";function WMo(t){let{components:n,...e}=t;return(0,s.kt)(zMo,(0,p.Z)({},AMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}WMo.isMDXComponent=!0;const IMo={toc:[]},RMo="wrapper";function PMo(t){let{components:n,...e}=t;return(0,s.kt)(RMo,(0,p.Z)({},IMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}PMo.isMDXComponent=!0;const SMo={toc:[]},EMo="wrapper";function GMo(t){let{components:n,...e}=t;return(0,s.kt)(EMo,(0,p.Z)({},SMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}GMo.isMDXComponent=!0;const OMo={toc:[]},FMo="wrapper";function BMo(t){let{components:n,...e}=t;return(0,s.kt)(FMo,(0,p.Z)({},OMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}BMo.isMDXComponent=!0;const UMo={toc:[]},VMo="wrapper";function qMo(t){let{components:n,...e}=t;return(0,s.kt)(VMo,(0,p.Z)({},UMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}qMo.isMDXComponent=!0;const jMo={toc:[]},YMo="wrapper";function QMo(t){let{components:n,...e}=t;return(0,s.kt)(YMo,(0,p.Z)({},jMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}QMo.isMDXComponent=!0;const HMo={toc:[]},$Mo="wrapper";function KMo(t){let{components:n,...e}=t;return(0,s.kt)($Mo,(0,p.Z)({},HMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}KMo.isMDXComponent=!0;const JMo={toc:[]},tDo="wrapper";function nDo(t){let{components:n,...e}=t;return(0,s.kt)(tDo,(0,p.Z)({},JMo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}nDo.isMDXComponent=!0;const eDo={toc:[]},oDo="wrapper";function pDo(t){let{components:n,...e}=t;return(0,s.kt)(oDo,(0,p.Z)({},eDo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}pDo.isMDXComponent=!0;const rDo={toc:[]},sDo="wrapper";function cDo(t){let{components:n,...e}=t;return(0,s.kt)(sDo,(0,p.Z)({},rDo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cDo.isMDXComponent=!0;const iDo={toc:[]},aDo="wrapper";function lDo(t){let{components:n,...e}=t;return(0,s.kt)(aDo,(0,p.Z)({},iDo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lDo.isMDXComponent=!0;const uDo={toc:[]},mDo="wrapper";function dDo(t){let{components:n,...e}=t;return(0,s.kt)(mDo,(0,p.Z)({},uDo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}dDo.isMDXComponent=!0;const hDo={toc:[]},kDo="wrapper";function fDo(t){let{components:n,...e}=t;return(0,s.kt)(kDo,(0,p.Z)({},hDo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}fDo.isMDXComponent=!0;const yDo={toc:[]},MDo="wrapper";function DDo(t){let{components:n,...e}=t;return(0,s.kt)(MDo,(0,p.Z)({},yDo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}DDo.isMDXComponent=!0;const XDo={toc:[]},_Do="wrapper";function wDo(t){let{components:n,...e}=t;return(0,s.kt)(_Do,(0,p.Z)({},XDo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wDo.isMDXComponent=!0;const TDo={toc:[]},CDo="wrapper";function gDo(t){let{components:n,...e}=t;return(0,s.kt)(CDo,(0,p.Z)({},TDo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}gDo.isMDXComponent=!0;const xDo={toc:[]},vDo="wrapper";function LDo(t){let{components:n,...e}=t;return(0,s.kt)(vDo,(0,p.Z)({},xDo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}LDo.isMDXComponent=!0;const ZDo={toc:[]},bDo="wrapper";function NDo(t){let{components:n,...e}=t;return(0,s.kt)(bDo,(0,p.Z)({},ZDo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}NDo.isMDXComponent=!0;const ADo={toc:[]},zDo="wrapper";function WDo(t){let{components:n,...e}=t;return(0,s.kt)(zDo,(0,p.Z)({},ADo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WDo.isMDXComponent=!0;const IDo={toc:[]},RDo="wrapper";function PDo(t){let{components:n,...e}=t;return(0,s.kt)(RDo,(0,p.Z)({},IDo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}PDo.isMDXComponent=!0;const SDo={toc:[]},EDo="wrapper";function GDo(t){let{components:n,...e}=t;return(0,s.kt)(EDo,(0,p.Z)({},SDo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}GDo.isMDXComponent=!0;const ODo={toc:[]},FDo="wrapper";function BDo(t){let{components:n,...e}=t;return(0,s.kt)(FDo,(0,p.Z)({},ODo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}BDo.isMDXComponent=!0;const UDo={toc:[]},VDo="wrapper";function qDo(t){let{components:n,...e}=t;return(0,s.kt)(VDo,(0,p.Z)({},UDo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}qDo.isMDXComponent=!0;const jDo={toc:[]},YDo="wrapper";function QDo(t){let{components:n,...e}=t;return(0,s.kt)(YDo,(0,p.Z)({},jDo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}QDo.isMDXComponent=!0;const HDo={toc:[]},$Do="wrapper";function KDo(t){let{components:n,...e}=t;return(0,s.kt)($Do,(0,p.Z)({},HDo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}KDo.isMDXComponent=!0;const JDo={toc:[]},tXo="wrapper";function nXo(t){let{components:n,...e}=t;return(0,s.kt)(tXo,(0,p.Z)({},JDo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}nXo.isMDXComponent=!0;const eXo={toc:[]},oXo="wrapper";function pXo(t){let{components:n,...e}=t;return(0,s.kt)(oXo,(0,p.Z)({},eXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pXo.isMDXComponent=!0;const rXo={toc:[]},sXo="wrapper";function cXo(t){let{components:n,...e}=t;return(0,s.kt)(sXo,(0,p.Z)({},rXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cXo.isMDXComponent=!0;const iXo={toc:[]},aXo="wrapper";function lXo(t){let{components:n,...e}=t;return(0,s.kt)(aXo,(0,p.Z)({},iXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}lXo.isMDXComponent=!0;const uXo={toc:[]},mXo="wrapper";function dXo(t){let{components:n,...e}=t;return(0,s.kt)(mXo,(0,p.Z)({},uXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}dXo.isMDXComponent=!0;const hXo={toc:[]},kXo="wrapper";function fXo(t){let{components:n,...e}=t;return(0,s.kt)(kXo,(0,p.Z)({},hXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}fXo.isMDXComponent=!0;const yXo={toc:[]},MXo="wrapper";function DXo(t){let{components:n,...e}=t;return(0,s.kt)(MXo,(0,p.Z)({},yXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}DXo.isMDXComponent=!0;const XXo={toc:[]},_Xo="wrapper";function wXo(t){let{components:n,...e}=t;return(0,s.kt)(_Xo,(0,p.Z)({},XXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}wXo.isMDXComponent=!0;const TXo={toc:[]},CXo="wrapper";function gXo(t){let{components:n,...e}=t;return(0,s.kt)(CXo,(0,p.Z)({},TXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}gXo.isMDXComponent=!0;const xXo={toc:[]},vXo="wrapper";function LXo(t){let{components:n,...e}=t;return(0,s.kt)(vXo,(0,p.Z)({},xXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}LXo.isMDXComponent=!0;const ZXo={toc:[]},bXo="wrapper";function NXo(t){let{components:n,...e}=t;return(0,s.kt)(bXo,(0,p.Z)({},ZXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}NXo.isMDXComponent=!0;const AXo={toc:[]},zXo="wrapper";function WXo(t){let{components:n,...e}=t;return(0,s.kt)(zXo,(0,p.Z)({},AXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}WXo.isMDXComponent=!0;const IXo={toc:[]},RXo="wrapper";function PXo(t){let{components:n,...e}=t;return(0,s.kt)(RXo,(0,p.Z)({},IXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}PXo.isMDXComponent=!0;const SXo={toc:[]},EXo="wrapper";function GXo(t){let{components:n,...e}=t;return(0,s.kt)(EXo,(0,p.Z)({},SXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}GXo.isMDXComponent=!0;const OXo={toc:[]},FXo="wrapper";function BXo(t){let{components:n,...e}=t;return(0,s.kt)(FXo,(0,p.Z)({},OXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}BXo.isMDXComponent=!0;const UXo={toc:[]},VXo="wrapper";function qXo(t){let{components:n,...e}=t;return(0,s.kt)(VXo,(0,p.Z)({},UXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}qXo.isMDXComponent=!0;const jXo={toc:[]},YXo="wrapper";function QXo(t){let{components:n,...e}=t;return(0,s.kt)(YXo,(0,p.Z)({},jXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}QXo.isMDXComponent=!0;const HXo={toc:[]},$Xo="wrapper";function KXo(t){let{components:n,...e}=t;return(0,s.kt)($Xo,(0,p.Z)({},HXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}KXo.isMDXComponent=!0;const JXo={toc:[]},t_o="wrapper";function n_o(t){let{components:n,...e}=t;return(0,s.kt)(t_o,(0,p.Z)({},JXo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}n_o.isMDXComponent=!0;const e_o={toc:[]},o_o="wrapper";function p_o(t){let{components:n,...e}=t;return(0,s.kt)(o_o,(0,p.Z)({},e_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}p_o.isMDXComponent=!0;const r_o={toc:[]},s_o="wrapper";function c_o(t){let{components:n,...e}=t;return(0,s.kt)(s_o,(0,p.Z)({},r_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}c_o.isMDXComponent=!0;const i_o={toc:[]},a_o="wrapper";function l_o(t){let{components:n,...e}=t;return(0,s.kt)(a_o,(0,p.Z)({},i_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}l_o.isMDXComponent=!0;const u_o={toc:[]},m_o="wrapper";function d_o(t){let{components:n,...e}=t;return(0,s.kt)(m_o,(0,p.Z)({},u_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}d_o.isMDXComponent=!0;const h_o={toc:[]},k_o="wrapper";function f_o(t){let{components:n,...e}=t;return(0,s.kt)(k_o,(0,p.Z)({},h_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}f_o.isMDXComponent=!0;const y_o={toc:[]},M_o="wrapper";function D_o(t){let{components:n,...e}=t;return(0,s.kt)(M_o,(0,p.Z)({},y_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}D_o.isMDXComponent=!0;const X_o={toc:[]},__o="wrapper";function w_o(t){let{components:n,...e}=t;return(0,s.kt)(__o,(0,p.Z)({},X_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}w_o.isMDXComponent=!0;const T_o={toc:[]},C_o="wrapper";function g_o(t){let{components:n,...e}=t;return(0,s.kt)(C_o,(0,p.Z)({},T_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}g_o.isMDXComponent=!0;const x_o={toc:[]},v_o="wrapper";function L_o(t){let{components:n,...e}=t;return(0,s.kt)(v_o,(0,p.Z)({},x_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}L_o.isMDXComponent=!0;const Z_o={toc:[]},b_o="wrapper";function N_o(t){let{components:n,...e}=t;return(0,s.kt)(b_o,(0,p.Z)({},Z_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}N_o.isMDXComponent=!0;const A_o={toc:[]},z_o="wrapper";function W_o(t){let{components:n,...e}=t;return(0,s.kt)(z_o,(0,p.Z)({},A_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}W_o.isMDXComponent=!0;const I_o={toc:[]},R_o="wrapper";function P_o(t){let{components:n,...e}=t;return(0,s.kt)(R_o,(0,p.Z)({},I_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}P_o.isMDXComponent=!0;const S_o={toc:[]},E_o="wrapper";function G_o(t){let{components:n,...e}=t;return(0,s.kt)(E_o,(0,p.Z)({},S_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}G_o.isMDXComponent=!0;const O_o={toc:[]},F_o="wrapper";function B_o(t){let{components:n,...e}=t;return(0,s.kt)(F_o,(0,p.Z)({},O_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}B_o.isMDXComponent=!0;const U_o={toc:[]},V_o="wrapper";function q_o(t){let{components:n,...e}=t;return(0,s.kt)(V_o,(0,p.Z)({},U_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}q_o.isMDXComponent=!0;const j_o={toc:[]},Y_o="wrapper";function Q_o(t){let{components:n,...e}=t;return(0,s.kt)(Y_o,(0,p.Z)({},j_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Q_o.isMDXComponent=!0;const H_o={toc:[]},$_o="wrapper";function K_o(t){let{components:n,...e}=t;return(0,s.kt)($_o,(0,p.Z)({},H_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}K_o.isMDXComponent=!0;const J_o={toc:[]},two="wrapper";function nwo(t){let{components:n,...e}=t;return(0,s.kt)(two,(0,p.Z)({},J_o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}nwo.isMDXComponent=!0;const ewo={toc:[]},owo="wrapper";function pwo(t){let{components:n,...e}=t;return(0,s.kt)(owo,(0,p.Z)({},ewo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}pwo.isMDXComponent=!0;const rwo={toc:[]},swo="wrapper";function cwo(t){let{components:n,...e}=t;return(0,s.kt)(swo,(0,p.Z)({},rwo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}cwo.isMDXComponent=!0;const iwo={toc:[]},awo="wrapper";function lwo(t){let{components:n,...e}=t;return(0,s.kt)(awo,(0,p.Z)({},iwo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}lwo.isMDXComponent=!0;const uwo={toc:[]},mwo="wrapper";function dwo(t){let{components:n,...e}=t;return(0,s.kt)(mwo,(0,p.Z)({},uwo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}dwo.isMDXComponent=!0;const hwo={toc:[]},kwo="wrapper";function fwo(t){let{components:n,...e}=t;return(0,s.kt)(kwo,(0,p.Z)({},hwo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}fwo.isMDXComponent=!0;const ywo={toc:[]},Mwo="wrapper";function Dwo(t){let{components:n,...e}=t;return(0,s.kt)(Mwo,(0,p.Z)({},ywo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Dwo.isMDXComponent=!0;const Xwo={toc:[]},_wo="wrapper";function wwo(t){let{components:n,...e}=t;return(0,s.kt)(_wo,(0,p.Z)({},Xwo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}wwo.isMDXComponent=!0;const Two={toc:[]},Cwo="wrapper";function gwo(t){let{components:n,...e}=t;return(0,s.kt)(Cwo,(0,p.Z)({},Two,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}gwo.isMDXComponent=!0;const xwo={toc:[]},vwo="wrapper";function Lwo(t){let{components:n,...e}=t;return(0,s.kt)(vwo,(0,p.Z)({},xwo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Lwo.isMDXComponent=!0;const Zwo={toc:[]},bwo="wrapper";function Nwo(t){let{components:n,...e}=t;return(0,s.kt)(bwo,(0,p.Z)({},Zwo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Nwo.isMDXComponent=!0;const Awo={toc:[]},zwo="wrapper";function Wwo(t){let{components:n,...e}=t;return(0,s.kt)(zwo,(0,p.Z)({},Awo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Wwo.isMDXComponent=!0;const Iwo={toc:[]},Rwo="wrapper";function Pwo(t){let{components:n,...e}=t;return(0,s.kt)(Rwo,(0,p.Z)({},Iwo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Pwo.isMDXComponent=!0;const Swo={toc:[]},Ewo="wrapper";function Gwo(t){let{components:n,...e}=t;return(0,s.kt)(Ewo,(0,p.Z)({},Swo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Gwo.isMDXComponent=!0;const Owo={toc:[]},Fwo="wrapper";function Bwo(t){let{components:n,...e}=t;return(0,s.kt)(Fwo,(0,p.Z)({},Owo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Bwo.isMDXComponent=!0;const Uwo={toc:[]},Vwo="wrapper";function qwo(t){let{components:n,...e}=t;return(0,s.kt)(Vwo,(0,p.Z)({},Uwo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}qwo.isMDXComponent=!0;const jwo={toc:[]},Ywo="wrapper";function Qwo(t){let{components:n,...e}=t;return(0,s.kt)(Ywo,(0,p.Z)({},jwo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Qwo.isMDXComponent=!0;const Hwo={toc:[]},$wo="wrapper";function Kwo(t){let{components:n,...e}=t;return(0,s.kt)($wo,(0,p.Z)({},Hwo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Kwo.isMDXComponent=!0;const Jwo={toc:[]},tTo="wrapper";function nTo(t){let{components:n,...e}=t;return(0,s.kt)(tTo,(0,p.Z)({},Jwo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}nTo.isMDXComponent=!0;const eTo={toc:[]},oTo="wrapper";function pTo(t){let{components:n,...e}=t;return(0,s.kt)(oTo,(0,p.Z)({},eTo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}pTo.isMDXComponent=!0;const rTo={toc:[]},sTo="wrapper";function cTo(t){let{components:n,...e}=t;return(0,s.kt)(sTo,(0,p.Z)({},rTo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}cTo.isMDXComponent=!0;const iTo={toc:[]},aTo="wrapper";function lTo(t){let{components:n,...e}=t;return(0,s.kt)(aTo,(0,p.Z)({},iTo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}lTo.isMDXComponent=!0;const uTo={toc:[]},mTo="wrapper";function dTo(t){let{components:n,...e}=t;return(0,s.kt)(mTo,(0,p.Z)({},uTo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}dTo.isMDXComponent=!0;const hTo={toc:[]},kTo="wrapper";function fTo(t){let{components:n,...e}=t;return(0,s.kt)(kTo,(0,p.Z)({},hTo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}fTo.isMDXComponent=!0;const yTo={toc:[]},MTo="wrapper";function DTo(t){let{components:n,...e}=t;return(0,s.kt)(MTo,(0,p.Z)({},yTo,e,{components:n,mdxType:"MDXLayout"}))}DTo.isMDXComponent=!0;const XTo={toc:[]},_To="wrapper";function wTo(t){let{components:n,...e}=t;return(0,s.kt)(_To,(0,p.Z)({},XTo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}wTo.isMDXComponent=!0;const TTo={toc:[]},CTo="wrapper";function gTo(t){let{components:n,...e}=t;return(0,s.kt)(CTo,(0,p.Z)({},TTo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}gTo.isMDXComponent=!0;const xTo={toc:[]},vTo="wrapper";function LTo(t){let{components:n,...e}=t;return(0,s.kt)(vTo,(0,p.Z)({},xTo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}LTo.isMDXComponent=!0;const ZTo={toc:[]},bTo="wrapper";function NTo(t){let{components:n,...e}=t;return(0,s.kt)(bTo,(0,p.Z)({},ZTo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}NTo.isMDXComponent=!0;const ATo={toc:[]},zTo="wrapper";function WTo(t){let{components:n,...e}=t;return(0,s.kt)(zTo,(0,p.Z)({},ATo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}WTo.isMDXComponent=!0;const ITo={toc:[]},RTo="wrapper";function PTo(t){let{components:n,...e}=t;return(0,s.kt)(RTo,(0,p.Z)({},ITo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}PTo.isMDXComponent=!0;const STo={toc:[]},ETo="wrapper";function GTo(t){let{components:n,...e}=t;return(0,s.kt)(ETo,(0,p.Z)({},STo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}GTo.isMDXComponent=!0;const OTo={toc:[]},FTo="wrapper";function BTo(t){let{components:n,...e}=t;return(0,s.kt)(FTo,(0,p.Z)({},OTo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}BTo.isMDXComponent=!0;const UTo={toc:[]},VTo="wrapper";function qTo(t){let{components:n,...e}=t;return(0,s.kt)(VTo,(0,p.Z)({},UTo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}qTo.isMDXComponent=!0;const jTo={toc:[]},YTo="wrapper";function QTo(t){let{components:n,...e}=t;return(0,s.kt)(YTo,(0,p.Z)({},jTo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}QTo.isMDXComponent=!0;const HTo={toc:[]},$To="wrapper";function KTo(t){let{components:n,...e}=t;return(0,s.kt)($To,(0,p.Z)({},HTo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}KTo.isMDXComponent=!0;const JTo={toc:[]},tCo="wrapper";function nCo(t){let{components:n,...e}=t;return(0,s.kt)(tCo,(0,p.Z)({},JTo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}nCo.isMDXComponent=!0;const eCo={toc:[]},oCo="wrapper";function pCo(t){let{components:n,...e}=t;return(0,s.kt)(oCo,(0,p.Z)({},eCo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}pCo.isMDXComponent=!0;const rCo={toc:[]},sCo="wrapper";function cCo(t){let{components:n,...e}=t;return(0,s.kt)(sCo,(0,p.Z)({},rCo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}cCo.isMDXComponent=!0;const iCo={toc:[]},aCo="wrapper";function lCo(t){let{components:n,...e}=t;return(0,s.kt)(aCo,(0,p.Z)({},iCo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}lCo.isMDXComponent=!0;const uCo={toc:[]},mCo="wrapper";function dCo(t){let{components:n,...e}=t;return(0,s.kt)(mCo,(0,p.Z)({},uCo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}dCo.isMDXComponent=!0;const hCo={toc:[]},kCo="wrapper";function fCo(t){let{components:n,...e}=t;return(0,s.kt)(kCo,(0,p.Z)({},hCo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}fCo.isMDXComponent=!0;const yCo={toc:[]},MCo="wrapper";function DCo(t){let{components:n,...e}=t;return(0,s.kt)(MCo,(0,p.Z)({},yCo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}DCo.isMDXComponent=!0;const XCo={toc:[]},_Co="wrapper";function wCo(t){let{components:n,...e}=t;return(0,s.kt)(_Co,(0,p.Z)({},XCo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}wCo.isMDXComponent=!0;const TCo={toc:[]},CCo="wrapper";function gCo(t){let{components:n,...e}=t;return(0,s.kt)(CCo,(0,p.Z)({},TCo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}gCo.isMDXComponent=!0;const xCo={toc:[]},vCo="wrapper";function LCo(t){let{components:n,...e}=t;return(0,s.kt)(vCo,(0,p.Z)({},xCo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}LCo.isMDXComponent=!0;const ZCo={toc:[]},bCo="wrapper";function NCo(t){let{components:n,...e}=t;return(0,s.kt)(bCo,(0,p.Z)({},ZCo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}NCo.isMDXComponent=!0;const ACo={toc:[]},zCo="wrapper";function WCo(t){let{components:n,...e}=t;return(0,s.kt)(zCo,(0,p.Z)({},ACo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}WCo.isMDXComponent=!0;const ICo={toc:[]},RCo="wrapper";function PCo(t){let{components:n,...e}=t;return(0,s.kt)(RCo,(0,p.Z)({},ICo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}PCo.isMDXComponent=!0;const SCo={toc:[]},ECo="wrapper";function GCo(t){let{components:n,...e}=t;return(0,s.kt)(ECo,(0,p.Z)({},SCo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}GCo.isMDXComponent=!0;const OCo={toc:[]},FCo="wrapper";function BCo(t){let{components:n,...e}=t;return(0,s.kt)(FCo,(0,p.Z)({},OCo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}BCo.isMDXComponent=!0;const UCo={toc:[]},VCo="wrapper";function qCo(t){let{components:n,...e}=t;return(0,s.kt)(VCo,(0,p.Z)({},UCo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}qCo.isMDXComponent=!0;const jCo={toc:[]},YCo="wrapper";function QCo(t){let{components:n,...e}=t;return(0,s.kt)(YCo,(0,p.Z)({},jCo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}QCo.isMDXComponent=!0;const HCo={toc:[]},$Co="wrapper";function KCo(t){let{components:n,...e}=t;return(0,s.kt)($Co,(0,p.Z)({},HCo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}KCo.isMDXComponent=!0;const JCo={toc:[]},tgo="wrapper";function ngo(t){let{components:n,...e}=t;return(0,s.kt)(tgo,(0,p.Z)({},JCo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}ngo.isMDXComponent=!0;const ego={toc:[]},ogo="wrapper";function pgo(t){let{components:n,...e}=t;return(0,s.kt)(ogo,(0,p.Z)({},ego,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pgo.isMDXComponent=!0;const rgo={toc:[]},sgo="wrapper";function cgo(t){let{components:n,...e}=t;return(0,s.kt)(sgo,(0,p.Z)({},rgo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}cgo.isMDXComponent=!0;const igo={toc:[]},ago="wrapper";function lgo(t){let{components:n,...e}=t;return(0,s.kt)(ago,(0,p.Z)({},igo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lgo.isMDXComponent=!0;const ugo={toc:[]},mgo="wrapper";function dgo(t){let{components:n,...e}=t;return(0,s.kt)(mgo,(0,p.Z)({},ugo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dgo.isMDXComponent=!0;const hgo={toc:[]},kgo="wrapper";function fgo(t){let{components:n,...e}=t;return(0,s.kt)(kgo,(0,p.Z)({},hgo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}fgo.isMDXComponent=!0;const ygo={toc:[]},Mgo="wrapper";function Dgo(t){let{components:n,...e}=t;return(0,s.kt)(Mgo,(0,p.Z)({},ygo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Dgo.isMDXComponent=!0;const Xgo={toc:[]},_go="wrapper";function wgo(t){let{components:n,...e}=t;return(0,s.kt)(_go,(0,p.Z)({},Xgo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}wgo.isMDXComponent=!0;const Tgo={toc:[]},Cgo="wrapper";function ggo(t){let{components:n,...e}=t;return(0,s.kt)(Cgo,(0,p.Z)({},Tgo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}ggo.isMDXComponent=!0;const xgo={toc:[]},vgo="wrapper";function Lgo(t){let{components:n,...e}=t;return(0,s.kt)(vgo,(0,p.Z)({},xgo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lgo.isMDXComponent=!0;const Zgo={toc:[]},bgo="wrapper";function Ngo(t){let{components:n,...e}=t;return(0,s.kt)(bgo,(0,p.Z)({},Zgo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Ngo.isMDXComponent=!0;const Ago={toc:[]},zgo="wrapper";function Wgo(t){let{components:n,...e}=t;return(0,s.kt)(zgo,(0,p.Z)({},Ago,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Wgo.isMDXComponent=!0;const Igo={toc:[]},Rgo="wrapper";function Pgo(t){let{components:n,...e}=t;return(0,s.kt)(Rgo,(0,p.Z)({},Igo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Pgo.isMDXComponent=!0;const Sgo={toc:[]},Ego="wrapper";function Ggo(t){let{components:n,...e}=t;return(0,s.kt)(Ego,(0,p.Z)({},Sgo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ggo.isMDXComponent=!0;const Ogo={toc:[]},Fgo="wrapper";function Bgo(t){let{components:n,...e}=t;return(0,s.kt)(Fgo,(0,p.Z)({},Ogo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Bgo.isMDXComponent=!0;const Ugo={toc:[]},Vgo="wrapper";function qgo(t){let{components:n,...e}=t;return(0,s.kt)(Vgo,(0,p.Z)({},Ugo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qgo.isMDXComponent=!0;const jgo={toc:[]},Ygo="wrapper";function Qgo(t){let{components:n,...e}=t;return(0,s.kt)(Ygo,(0,p.Z)({},jgo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Qgo.isMDXComponent=!0;const Hgo={toc:[]},$go="wrapper";function Kgo(t){let{components:n,...e}=t;return(0,s.kt)($go,(0,p.Z)({},Hgo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Kgo.isMDXComponent=!0;const Jgo={toc:[]},txo="wrapper";function nxo(t){let{components:n,...e}=t;return(0,s.kt)(txo,(0,p.Z)({},Jgo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}nxo.isMDXComponent=!0;const exo={toc:[]},oxo="wrapper";function pxo(t){let{components:n,...e}=t;return(0,s.kt)(oxo,(0,p.Z)({},exo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pxo.isMDXComponent=!0;const rxo={toc:[]},sxo="wrapper";function cxo(t){let{components:n,...e}=t;return(0,s.kt)(sxo,(0,p.Z)({},rxo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}cxo.isMDXComponent=!0;const ixo={toc:[]},axo="wrapper";function lxo(t){let{components:n,...e}=t;return(0,s.kt)(axo,(0,p.Z)({},ixo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lxo.isMDXComponent=!0;const uxo={toc:[]},mxo="wrapper";function dxo(t){let{components:n,...e}=t;return(0,s.kt)(mxo,(0,p.Z)({},uxo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}dxo.isMDXComponent=!0;const hxo={toc:[]},kxo="wrapper";function fxo(t){let{components:n,...e}=t;return(0,s.kt)(kxo,(0,p.Z)({},hxo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}fxo.isMDXComponent=!0;const yxo={toc:[]},Mxo="wrapper";function Dxo(t){let{components:n,...e}=t;return(0,s.kt)(Mxo,(0,p.Z)({},yxo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Dxo.isMDXComponent=!0;const Xxo={toc:[]},_xo="wrapper";function wxo(t){let{components:n,...e}=t;return(0,s.kt)(_xo,(0,p.Z)({},Xxo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wxo.isMDXComponent=!0;const Txo={toc:[]},Cxo="wrapper";function gxo(t){let{components:n,...e}=t;return(0,s.kt)(Cxo,(0,p.Z)({},Txo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}gxo.isMDXComponent=!0;const xxo={toc:[]},vxo="wrapper";function Lxo(t){let{components:n,...e}=t;return(0,s.kt)(vxo,(0,p.Z)({},xxo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Lxo.isMDXComponent=!0;const Zxo={toc:[]},bxo="wrapper";function Nxo(t){let{components:n,...e}=t;return(0,s.kt)(bxo,(0,p.Z)({},Zxo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Nxo.isMDXComponent=!0;const Axo={toc:[]},zxo="wrapper";function Wxo(t){let{components:n,...e}=t;return(0,s.kt)(zxo,(0,p.Z)({},Axo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Wxo.isMDXComponent=!0;const Ixo={toc:[]},Rxo="wrapper";function Pxo(t){let{components:n,...e}=t;return(0,s.kt)(Rxo,(0,p.Z)({},Ixo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Pxo.isMDXComponent=!0;const Sxo={toc:[]},Exo="wrapper";function Gxo(t){let{components:n,...e}=t;return(0,s.kt)(Exo,(0,p.Z)({},Sxo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Gxo.isMDXComponent=!0;const Oxo={toc:[]},Fxo="wrapper";function Bxo(t){let{components:n,...e}=t;return(0,s.kt)(Fxo,(0,p.Z)({},Oxo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Bxo.isMDXComponent=!0;const Uxo={toc:[]},Vxo="wrapper";function qxo(t){let{components:n,...e}=t;return(0,s.kt)(Vxo,(0,p.Z)({},Uxo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}qxo.isMDXComponent=!0;const jxo={toc:[]},Yxo="wrapper";function Qxo(t){let{components:n,...e}=t;return(0,s.kt)(Yxo,(0,p.Z)({},jxo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Qxo.isMDXComponent=!0;const Hxo={toc:[]},$xo="wrapper";function Kxo(t){let{components:n,...e}=t;return(0,s.kt)($xo,(0,p.Z)({},Hxo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Kxo.isMDXComponent=!0;const Jxo={toc:[]},tvo="wrapper";function nvo(t){let{components:n,...e}=t;return(0,s.kt)(tvo,(0,p.Z)({},Jxo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}nvo.isMDXComponent=!0;const evo={toc:[]},ovo="wrapper";function pvo(t){let{components:n,...e}=t;return(0,s.kt)(ovo,(0,p.Z)({},evo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}pvo.isMDXComponent=!0;const rvo={toc:[]},svo="wrapper";function cvo(t){let{components:n,...e}=t;return(0,s.kt)(svo,(0,p.Z)({},rvo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}cvo.isMDXComponent=!0;const ivo={toc:[]},avo="wrapper";function lvo(t){let{components:n,...e}=t;return(0,s.kt)(avo,(0,p.Z)({},ivo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}lvo.isMDXComponent=!0;const uvo={toc:[]},mvo="wrapper";function dvo(t){let{components:n,...e}=t;return(0,s.kt)(mvo,(0,p.Z)({},uvo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}dvo.isMDXComponent=!0;const hvo={toc:[]},kvo="wrapper";function fvo(t){let{components:n,...e}=t;return(0,s.kt)(kvo,(0,p.Z)({},hvo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}fvo.isMDXComponent=!0;const yvo={toc:[]},Mvo="wrapper";function Dvo(t){let{components:n,...e}=t;return(0,s.kt)(Mvo,(0,p.Z)({},yvo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Dvo.isMDXComponent=!0;const Xvo={toc:[]},_vo="wrapper";function wvo(t){let{components:n,...e}=t;return(0,s.kt)(_vo,(0,p.Z)({},Xvo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wvo.isMDXComponent=!0;const Tvo={toc:[]},Cvo="wrapper";function gvo(t){let{components:n,...e}=t;return(0,s.kt)(Cvo,(0,p.Z)({},Tvo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}gvo.isMDXComponent=!0;const xvo={toc:[]},vvo="wrapper";function Lvo(t){let{components:n,...e}=t;return(0,s.kt)(vvo,(0,p.Z)({},xvo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Lvo.isMDXComponent=!0;const Zvo={toc:[]},bvo="wrapper";function Nvo(t){let{components:n,...e}=t;return(0,s.kt)(bvo,(0,p.Z)({},Zvo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Nvo.isMDXComponent=!0;const Avo={toc:[]},zvo="wrapper";function Wvo(t){let{components:n,...e}=t;return(0,s.kt)(zvo,(0,p.Z)({},Avo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Wvo.isMDXComponent=!0;const Ivo={toc:[]},Rvo="wrapper";function Pvo(t){let{components:n,...e}=t;return(0,s.kt)(Rvo,(0,p.Z)({},Ivo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Pvo.isMDXComponent=!0;const Svo={toc:[]},Evo="wrapper";function Gvo(t){let{components:n,...e}=t;return(0,s.kt)(Evo,(0,p.Z)({},Svo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Gvo.isMDXComponent=!0;const Ovo={toc:[]},Fvo="wrapper";function Bvo(t){let{components:n,...e}=t;return(0,s.kt)(Fvo,(0,p.Z)({},Ovo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Bvo.isMDXComponent=!0;const Uvo={toc:[]},Vvo="wrapper";function qvo(t){let{components:n,...e}=t;return(0,s.kt)(Vvo,(0,p.Z)({},Uvo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}qvo.isMDXComponent=!0;const jvo={toc:[]},Yvo="wrapper";function Qvo(t){let{components:n,...e}=t;return(0,s.kt)(Yvo,(0,p.Z)({},jvo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Qvo.isMDXComponent=!0;const Hvo={toc:[]},$vo="wrapper";function Kvo(t){let{components:n,...e}=t;return(0,s.kt)($vo,(0,p.Z)({},Hvo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Kvo.isMDXComponent=!0;const Jvo={toc:[]},tLo="wrapper";function nLo(t){let{components:n,...e}=t;return(0,s.kt)(tLo,(0,p.Z)({},Jvo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}nLo.isMDXComponent=!0;const eLo={toc:[]},oLo="wrapper";function pLo(t){let{components:n,...e}=t;return(0,s.kt)(oLo,(0,p.Z)({},eLo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}pLo.isMDXComponent=!0;const rLo={toc:[]},sLo="wrapper";function cLo(t){let{components:n,...e}=t;return(0,s.kt)(sLo,(0,p.Z)({},rLo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}cLo.isMDXComponent=!0;const iLo={toc:[]},aLo="wrapper";function lLo(t){let{components:n,...e}=t;return(0,s.kt)(aLo,(0,p.Z)({},iLo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}lLo.isMDXComponent=!0;const uLo={toc:[]},mLo="wrapper";function dLo(t){let{components:n,...e}=t;return(0,s.kt)(mLo,(0,p.Z)({},uLo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dLo.isMDXComponent=!0;const hLo={toc:[]},kLo="wrapper";function fLo(t){let{components:n,...e}=t;return(0,s.kt)(kLo,(0,p.Z)({},hLo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}fLo.isMDXComponent=!0;const yLo={toc:[]},MLo="wrapper";function DLo(t){let{components:n,...e}=t;return(0,s.kt)(MLo,(0,p.Z)({},yLo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}DLo.isMDXComponent=!0;const XLo={toc:[]},_Lo="wrapper";function wLo(t){let{components:n,...e}=t;return(0,s.kt)(_Lo,(0,p.Z)({},XLo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}wLo.isMDXComponent=!0;const TLo={toc:[]},CLo="wrapper";function gLo(t){let{components:n,...e}=t;return(0,s.kt)(CLo,(0,p.Z)({},TLo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}gLo.isMDXComponent=!0;const xLo={toc:[]},vLo="wrapper";function LLo(t){let{components:n,...e}=t;return(0,s.kt)(vLo,(0,p.Z)({},xLo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}LLo.isMDXComponent=!0;const ZLo={toc:[]},bLo="wrapper";function NLo(t){let{components:n,...e}=t;return(0,s.kt)(bLo,(0,p.Z)({},ZLo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}NLo.isMDXComponent=!0;const ALo={toc:[]},zLo="wrapper";function WLo(t){let{components:n,...e}=t;return(0,s.kt)(zLo,(0,p.Z)({},ALo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}WLo.isMDXComponent=!0;const ILo={toc:[]},RLo="wrapper";function PLo(t){let{components:n,...e}=t;return(0,s.kt)(RLo,(0,p.Z)({},ILo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}PLo.isMDXComponent=!0;const SLo={toc:[]},ELo="wrapper";function GLo(t){let{components:n,...e}=t;return(0,s.kt)(ELo,(0,p.Z)({},SLo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}GLo.isMDXComponent=!0;const OLo={toc:[]},FLo="wrapper";function BLo(t){let{components:n,...e}=t;return(0,s.kt)(FLo,(0,p.Z)({},OLo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}BLo.isMDXComponent=!0;const ULo={toc:[]},VLo="wrapper";function qLo(t){let{components:n,...e}=t;return(0,s.kt)(VLo,(0,p.Z)({},ULo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}qLo.isMDXComponent=!0;const jLo={toc:[]},YLo="wrapper";function QLo(t){let{components:n,...e}=t;return(0,s.kt)(YLo,(0,p.Z)({},jLo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}QLo.isMDXComponent=!0;const HLo={toc:[]},$Lo="wrapper";function KLo(t){let{components:n,...e}=t;return(0,s.kt)($Lo,(0,p.Z)({},HLo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}KLo.isMDXComponent=!0;const JLo={toc:[]},tZo="wrapper";function nZo(t){let{components:n,...e}=t;return(0,s.kt)(tZo,(0,p.Z)({},JLo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}nZo.isMDXComponent=!0;const eZo={toc:[]},oZo="wrapper";function pZo(t){let{components:n,...e}=t;return(0,s.kt)(oZo,(0,p.Z)({},eZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}pZo.isMDXComponent=!0;const rZo={toc:[]},sZo="wrapper";function cZo(t){let{components:n,...e}=t;return(0,s.kt)(sZo,(0,p.Z)({},rZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cZo.isMDXComponent=!0;const iZo={toc:[]},aZo="wrapper";function lZo(t){let{components:n,...e}=t;return(0,s.kt)(aZo,(0,p.Z)({},iZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lZo.isMDXComponent=!0;const uZo={toc:[]},mZo="wrapper";function dZo(t){let{components:n,...e}=t;return(0,s.kt)(mZo,(0,p.Z)({},uZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}dZo.isMDXComponent=!0;const hZo={toc:[]},kZo="wrapper";function fZo(t){let{components:n,...e}=t;return(0,s.kt)(kZo,(0,p.Z)({},hZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}fZo.isMDXComponent=!0;const yZo={toc:[]},MZo="wrapper";function DZo(t){let{components:n,...e}=t;return(0,s.kt)(MZo,(0,p.Z)({},yZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}DZo.isMDXComponent=!0;const XZo={toc:[]},_Zo="wrapper";function wZo(t){let{components:n,...e}=t;return(0,s.kt)(_Zo,(0,p.Z)({},XZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wZo.isMDXComponent=!0;const TZo={toc:[]},CZo="wrapper";function gZo(t){let{components:n,...e}=t;return(0,s.kt)(CZo,(0,p.Z)({},TZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}gZo.isMDXComponent=!0;const xZo={toc:[]},vZo="wrapper";function LZo(t){let{components:n,...e}=t;return(0,s.kt)(vZo,(0,p.Z)({},xZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}LZo.isMDXComponent=!0;const ZZo={toc:[]},bZo="wrapper";function NZo(t){let{components:n,...e}=t;return(0,s.kt)(bZo,(0,p.Z)({},ZZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}NZo.isMDXComponent=!0;const AZo={toc:[]},zZo="wrapper";function WZo(t){let{components:n,...e}=t;return(0,s.kt)(zZo,(0,p.Z)({},AZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WZo.isMDXComponent=!0;const IZo={toc:[]},RZo="wrapper";function PZo(t){let{components:n,...e}=t;return(0,s.kt)(RZo,(0,p.Z)({},IZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}PZo.isMDXComponent=!0;const SZo={toc:[]},EZo="wrapper";function GZo(t){let{components:n,...e}=t;return(0,s.kt)(EZo,(0,p.Z)({},SZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}GZo.isMDXComponent=!0;const OZo={toc:[]},FZo="wrapper";function BZo(t){let{components:n,...e}=t;return(0,s.kt)(FZo,(0,p.Z)({},OZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}BZo.isMDXComponent=!0;const UZo={toc:[]},VZo="wrapper";function qZo(t){let{components:n,...e}=t;return(0,s.kt)(VZo,(0,p.Z)({},UZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}qZo.isMDXComponent=!0;const jZo={toc:[]},YZo="wrapper";function QZo(t){let{components:n,...e}=t;return(0,s.kt)(YZo,(0,p.Z)({},jZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}QZo.isMDXComponent=!0;const HZo={toc:[]},$Zo="wrapper";function KZo(t){let{components:n,...e}=t;return(0,s.kt)($Zo,(0,p.Z)({},HZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}KZo.isMDXComponent=!0;const JZo={toc:[]},tbo="wrapper";function nbo(t){let{components:n,...e}=t;return(0,s.kt)(tbo,(0,p.Z)({},JZo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}nbo.isMDXComponent=!0;const ebo={toc:[]},obo="wrapper";function pbo(t){let{components:n,...e}=t;return(0,s.kt)(obo,(0,p.Z)({},ebo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}pbo.isMDXComponent=!0;const rbo={toc:[]},sbo="wrapper";function cbo(t){let{components:n,...e}=t;return(0,s.kt)(sbo,(0,p.Z)({},rbo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}cbo.isMDXComponent=!0;const ibo={toc:[]},abo="wrapper";function lbo(t){let{components:n,...e}=t;return(0,s.kt)(abo,(0,p.Z)({},ibo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}lbo.isMDXComponent=!0;const ubo={toc:[]},mbo="wrapper";function dbo(t){let{components:n,...e}=t;return(0,s.kt)(mbo,(0,p.Z)({},ubo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}dbo.isMDXComponent=!0;const hbo={toc:[]},kbo="wrapper";function fbo(t){let{components:n,...e}=t;return(0,s.kt)(kbo,(0,p.Z)({},hbo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}fbo.isMDXComponent=!0;const ybo={toc:[]},Mbo="wrapper";function Dbo(t){let{components:n,...e}=t;return(0,s.kt)(Mbo,(0,p.Z)({},ybo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Dbo.isMDXComponent=!0;const Xbo={toc:[]},_bo="wrapper";function wbo(t){let{components:n,...e}=t;return(0,s.kt)(_bo,(0,p.Z)({},Xbo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}wbo.isMDXComponent=!0;const Tbo={toc:[]},Cbo="wrapper";function gbo(t){let{components:n,...e}=t;return(0,s.kt)(Cbo,(0,p.Z)({},Tbo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}gbo.isMDXComponent=!0;const xbo={toc:[]},vbo="wrapper";function Lbo(t){let{components:n,...e}=t;return(0,s.kt)(vbo,(0,p.Z)({},xbo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Lbo.isMDXComponent=!0;const Zbo={toc:[]},bbo="wrapper";function Nbo(t){let{components:n,...e}=t;return(0,s.kt)(bbo,(0,p.Z)({},Zbo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Nbo.isMDXComponent=!0;const Abo={toc:[]},zbo="wrapper";function Wbo(t){let{components:n,...e}=t;return(0,s.kt)(zbo,(0,p.Z)({},Abo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Wbo.isMDXComponent=!0;const Ibo={toc:[]},Rbo="wrapper";function Pbo(t){let{components:n,...e}=t;return(0,s.kt)(Rbo,(0,p.Z)({},Ibo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Pbo.isMDXComponent=!0;const Sbo={toc:[]},Ebo="wrapper";function Gbo(t){let{components:n,...e}=t;return(0,s.kt)(Ebo,(0,p.Z)({},Sbo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Gbo.isMDXComponent=!0;const Obo={toc:[]},Fbo="wrapper";function Bbo(t){let{components:n,...e}=t;return(0,s.kt)(Fbo,(0,p.Z)({},Obo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Bbo.isMDXComponent=!0;const Ubo={toc:[]},Vbo="wrapper";function qbo(t){let{components:n,...e}=t;return(0,s.kt)(Vbo,(0,p.Z)({},Ubo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qbo.isMDXComponent=!0;const jbo={toc:[]},Ybo="wrapper";function Qbo(t){let{components:n,...e}=t;return(0,s.kt)(Ybo,(0,p.Z)({},jbo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Qbo.isMDXComponent=!0;const Hbo={toc:[]},$bo="wrapper";function Kbo(t){let{components:n,...e}=t;return(0,s.kt)($bo,(0,p.Z)({},Hbo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Kbo.isMDXComponent=!0;const Jbo={toc:[]},tNo="wrapper";function nNo(t){let{components:n,...e}=t;return(0,s.kt)(tNo,(0,p.Z)({},Jbo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}nNo.isMDXComponent=!0;const eNo={toc:[]},oNo="wrapper";function pNo(t){let{components:n,...e}=t;return(0,s.kt)(oNo,(0,p.Z)({},eNo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}pNo.isMDXComponent=!0;const rNo={toc:[]},sNo="wrapper";function cNo(t){let{components:n,...e}=t;return(0,s.kt)(sNo,(0,p.Z)({},rNo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}cNo.isMDXComponent=!0;const iNo={toc:[]},aNo="wrapper";function lNo(t){let{components:n,...e}=t;return(0,s.kt)(aNo,(0,p.Z)({},iNo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}lNo.isMDXComponent=!0;const uNo={toc:[]},mNo="wrapper";function dNo(t){let{components:n,...e}=t;return(0,s.kt)(mNo,(0,p.Z)({},uNo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}dNo.isMDXComponent=!0;const hNo={toc:[]},kNo="wrapper";function fNo(t){let{components:n,...e}=t;return(0,s.kt)(kNo,(0,p.Z)({},hNo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}fNo.isMDXComponent=!0;const yNo={toc:[]},MNo="wrapper";function DNo(t){let{components:n,...e}=t;return(0,s.kt)(MNo,(0,p.Z)({},yNo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}DNo.isMDXComponent=!0;const XNo={toc:[]},_No="wrapper";function wNo(t){let{components:n,...e}=t;return(0,s.kt)(_No,(0,p.Z)({},XNo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut for"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Txt fontWeight={700} />\n")))}wNo.isMDXComponent=!0;const TNo={toc:[]},CNo="wrapper";function gNo(t){let{components:n,...e}=t;return(0,s.kt)(CNo,(0,p.Z)({},TNo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a bold text node."))}gNo.isMDXComponent=!0;const xNo={toc:[]},vNo="wrapper";function LNo(t){let{components:n,...e}=t;return(0,s.kt)(vNo,(0,p.Z)({},xNo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Additional text properties."))}LNo.isMDXComponent=!0;const ZNo={toc:[]},bNo="wrapper";function NNo(t){let{components:n,...e}=t;return(0,s.kt)(bNo,(0,p.Z)({},ZNo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut for"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Txt fontStyle={'italic'} />\n")))}NNo.isMDXComponent=!0;const ANo={toc:[]},zNo="wrapper";function WNo(t){let{components:n,...e}=t;return(0,s.kt)(zNo,(0,p.Z)({},ANo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an italic text node."))}WNo.isMDXComponent=!0;const INo={toc:[]},RNo="wrapper";function PNo(t){let{components:n,...e}=t;return(0,s.kt)(RNo,(0,p.Z)({},INo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Additional text properties."))}PNo.isMDXComponent=!0;const SNo={toc:[]},ENo="wrapper";function GNo(t){let{components:n,...e}=t;return(0,s.kt)(ENo,(0,p.Z)({},SNo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}GNo.isMDXComponent=!0;const ONo={toc:[]},FNo="wrapper";function BNo(t){let{components:n,...e}=t;return(0,s.kt)(FNo,(0,p.Z)({},ONo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}BNo.isMDXComponent=!0;const UNo={toc:[]},VNo="wrapper";function qNo(t){let{components:n,...e}=t;return(0,s.kt)(VNo,(0,p.Z)({},UNo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}qNo.isMDXComponent=!0;const jNo={toc:[]},YNo="wrapper";function QNo(t){let{components:n,...e}=t;return(0,s.kt)(YNo,(0,p.Z)({},jNo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}QNo.isMDXComponent=!0;const HNo={toc:[]},$No="wrapper";function KNo(t){let{components:n,...e}=t;return(0,s.kt)($No,(0,p.Z)({},HNo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}KNo.isMDXComponent=!0;const JNo={toc:[]},tAo="wrapper";function nAo(t){let{components:n,...e}=t;return(0,s.kt)(tAo,(0,p.Z)({},JNo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}nAo.isMDXComponent=!0;const eAo={toc:[]},oAo="wrapper";function pAo(t){let{components:n,...e}=t;return(0,s.kt)(oAo,(0,p.Z)({},eAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}pAo.isMDXComponent=!0;const rAo={toc:[]},sAo="wrapper";function cAo(t){let{components:n,...e}=t;return(0,s.kt)(sAo,(0,p.Z)({},rAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}cAo.isMDXComponent=!0;const iAo={toc:[]},aAo="wrapper";function lAo(t){let{components:n,...e}=t;return(0,s.kt)(aAo,(0,p.Z)({},iAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}lAo.isMDXComponent=!0;const uAo={toc:[]},mAo="wrapper";function dAo(t){let{components:n,...e}=t;return(0,s.kt)(mAo,(0,p.Z)({},uAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}dAo.isMDXComponent=!0;const hAo={toc:[]},kAo="wrapper";function fAo(t){let{components:n,...e}=t;return(0,s.kt)(kAo,(0,p.Z)({},hAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}fAo.isMDXComponent=!0;const yAo={toc:[]},MAo="wrapper";function DAo(t){let{components:n,...e}=t;return(0,s.kt)(MAo,(0,p.Z)({},yAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}DAo.isMDXComponent=!0;const XAo={toc:[]},_Ao="wrapper";function wAo(t){let{components:n,...e}=t;return(0,s.kt)(_Ao,(0,p.Z)({},XAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}wAo.isMDXComponent=!0;const TAo={toc:[]},CAo="wrapper";function gAo(t){let{components:n,...e}=t;return(0,s.kt)(CAo,(0,p.Z)({},TAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}gAo.isMDXComponent=!0;const xAo={toc:[]},vAo="wrapper";function LAo(t){let{components:n,...e}=t;return(0,s.kt)(vAo,(0,p.Z)({},xAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}LAo.isMDXComponent=!0;const ZAo={toc:[]},bAo="wrapper";function NAo(t){let{components:n,...e}=t;return(0,s.kt)(bAo,(0,p.Z)({},ZAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}NAo.isMDXComponent=!0;const AAo={toc:[]},zAo="wrapper";function WAo(t){let{components:n,...e}=t;return(0,s.kt)(zAo,(0,p.Z)({},AAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}WAo.isMDXComponent=!0;const IAo={toc:[]},RAo="wrapper";function PAo(t){let{components:n,...e}=t;return(0,s.kt)(RAo,(0,p.Z)({},IAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}PAo.isMDXComponent=!0;const SAo={toc:[]},EAo="wrapper";function GAo(t){let{components:n,...e}=t;return(0,s.kt)(EAo,(0,p.Z)({},SAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}GAo.isMDXComponent=!0;const OAo={toc:[]},FAo="wrapper";function BAo(t){let{components:n,...e}=t;return(0,s.kt)(FAo,(0,p.Z)({},OAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}BAo.isMDXComponent=!0;const UAo={toc:[]},VAo="wrapper";function qAo(t){let{components:n,...e}=t;return(0,s.kt)(VAo,(0,p.Z)({},UAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}qAo.isMDXComponent=!0;const jAo={toc:[]},YAo="wrapper";function QAo(t){let{components:n,...e}=t;return(0,s.kt)(YAo,(0,p.Z)({},jAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}QAo.isMDXComponent=!0;const HAo={toc:[]},$Ao="wrapper";function KAo(t){let{components:n,...e}=t;return(0,s.kt)($Ao,(0,p.Z)({},HAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}KAo.isMDXComponent=!0;const JAo={toc:[]},tzo="wrapper";function nzo(t){let{components:n,...e}=t;return(0,s.kt)(tzo,(0,p.Z)({},JAo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nzo.isMDXComponent=!0;const ezo={toc:[]},ozo="wrapper";function pzo(t){let{components:n,...e}=t;return(0,s.kt)(ozo,(0,p.Z)({},ezo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}pzo.isMDXComponent=!0;const rzo={toc:[]},szo="wrapper";function czo(t){let{components:n,...e}=t;return(0,s.kt)(szo,(0,p.Z)({},rzo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}czo.isMDXComponent=!0;const izo={toc:[]},azo="wrapper";function lzo(t){let{components:n,...e}=t;return(0,s.kt)(azo,(0,p.Z)({},izo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}lzo.isMDXComponent=!0;const uzo={toc:[]},mzo="wrapper";function dzo(t){let{components:n,...e}=t;return(0,s.kt)(mzo,(0,p.Z)({},uzo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}dzo.isMDXComponent=!0;const hzo={toc:[]},kzo="wrapper";function fzo(t){let{components:n,...e}=t;return(0,s.kt)(kzo,(0,p.Z)({},hzo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}fzo.isMDXComponent=!0;const yzo={toc:[]},Mzo="wrapper";function Dzo(t){let{components:n,...e}=t;return(0,s.kt)(Mzo,(0,p.Z)({},yzo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}Dzo.isMDXComponent=!0;const Xzo={toc:[]},_zo="wrapper";function wzo(t){let{components:n,...e}=t;return(0,s.kt)(_zo,(0,p.Z)({},Xzo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}wzo.isMDXComponent=!0;const Tzo={toc:[]},Czo="wrapper";function gzo(t){let{components:n,...e}=t;return(0,s.kt)(Czo,(0,p.Z)({},Tzo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}gzo.isMDXComponent=!0;const xzo={toc:[]},vzo="wrapper";function Lzo(t){let{components:n,...e}=t;return(0,s.kt)(vzo,(0,p.Z)({},xzo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Lzo.isMDXComponent=!0;const Zzo={toc:[]},bzo="wrapper";function Nzo(t){let{components:n,...e}=t;return(0,s.kt)(bzo,(0,p.Z)({},Zzo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Nzo.isMDXComponent=!0;const Azo={toc:[]},zzo="wrapper";function Wzo(t){let{components:n,...e}=t;return(0,s.kt)(zzo,(0,p.Z)({},Azo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Wzo.isMDXComponent=!0;const Izo={toc:[]},Rzo="wrapper";function Pzo(t){let{components:n,...e}=t;return(0,s.kt)(Rzo,(0,p.Z)({},Izo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Pzo.isMDXComponent=!0;const Szo={toc:[]},Ezo="wrapper";function Gzo(t){let{components:n,...e}=t;return(0,s.kt)(Ezo,(0,p.Z)({},Szo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"1"))}Gzo.isMDXComponent=!0;const Ozo={toc:[]},Fzo="wrapper";function Bzo(t){let{components:n,...e}=t;return(0,s.kt)(Fzo,(0,p.Z)({},Ozo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rate at which the video plays, as multiples of the normal speed."))}Bzo.isMDXComponent=!0;const Uzo={toc:[]},Vzo="wrapper";function qzo(t){let{components:n,...e}=t;return(0,s.kt)(Vzo,(0,p.Z)({},Uzo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}qzo.isMDXComponent=!0;const jzo={toc:[]},Yzo="wrapper";function Qzo(t){let{components:n,...e}=t;return(0,s.kt)(Yzo,(0,p.Z)({},jzo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Qzo.isMDXComponent=!0;const Hzo={toc:[]},$zo="wrapper";function Kzo(t){let{components:n,...e}=t;return(0,s.kt)($zo,(0,p.Z)({},Hzo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Kzo.isMDXComponent=!0;const Jzo={toc:[]},tWo="wrapper";function nWo(t){let{components:n,...e}=t;return(0,s.kt)(tWo,(0,p.Z)({},Jzo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}nWo.isMDXComponent=!0;const eWo={toc:[]},oWo="wrapper";function pWo(t){let{components:n,...e}=t;return(0,s.kt)(oWo,(0,p.Z)({},eWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}pWo.isMDXComponent=!0;const rWo={toc:[]},sWo="wrapper";function cWo(t){let{components:n,...e}=t;return(0,s.kt)(sWo,(0,p.Z)({},rWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}cWo.isMDXComponent=!0;const iWo={toc:[]},aWo="wrapper";function lWo(t){let{components:n,...e}=t;return(0,s.kt)(aWo,(0,p.Z)({},iWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}lWo.isMDXComponent=!0;const uWo={toc:[]},mWo="wrapper";function dWo(t){let{components:n,...e}=t;return(0,s.kt)(mWo,(0,p.Z)({},uWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}dWo.isMDXComponent=!0;const hWo={toc:[]},kWo="wrapper";function fWo(t){let{components:n,...e}=t;return(0,s.kt)(kWo,(0,p.Z)({},hWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}fWo.isMDXComponent=!0;const yWo={toc:[]},MWo="wrapper";function DWo(t){let{components:n,...e}=t;return(0,s.kt)(MWo,(0,p.Z)({},yWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}DWo.isMDXComponent=!0;const XWo={toc:[]},_Wo="wrapper";function wWo(t){let{components:n,...e}=t;return(0,s.kt)(_Wo,(0,p.Z)({},XWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}wWo.isMDXComponent=!0;const TWo={toc:[]},CWo="wrapper";function gWo(t){let{components:n,...e}=t;return(0,s.kt)(CWo,(0,p.Z)({},TWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}gWo.isMDXComponent=!0;const xWo={toc:[]},vWo="wrapper";function LWo(t){let{components:n,...e}=t;return(0,s.kt)(vWo,(0,p.Z)({},xWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}LWo.isMDXComponent=!0;const ZWo={toc:[]},bWo="wrapper";function NWo(t){let{components:n,...e}=t;return(0,s.kt)(bWo,(0,p.Z)({},ZWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}NWo.isMDXComponent=!0;const AWo={toc:[]},zWo="wrapper";function WWo(t){let{components:n,...e}=t;return(0,s.kt)(zWo,(0,p.Z)({},AWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}WWo.isMDXComponent=!0;const IWo={toc:[]},RWo="wrapper";function PWo(t){let{components:n,...e}=t;return(0,s.kt)(RWo,(0,p.Z)({},IWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}PWo.isMDXComponent=!0;const SWo={toc:[]},EWo="wrapper";function GWo(t){let{components:n,...e}=t;return(0,s.kt)(EWo,(0,p.Z)({},SWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}GWo.isMDXComponent=!0;const OWo={toc:[]},FWo="wrapper";function BWo(t){let{components:n,...e}=t;return(0,s.kt)(FWo,(0,p.Z)({},OWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}BWo.isMDXComponent=!0;const UWo={toc:[]},VWo="wrapper";function qWo(t){let{components:n,...e}=t;return(0,s.kt)(VWo,(0,p.Z)({},UWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}qWo.isMDXComponent=!0;const jWo={toc:[]},YWo="wrapper";function QWo(t){let{components:n,...e}=t;return(0,s.kt)(YWo,(0,p.Z)({},jWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}QWo.isMDXComponent=!0;const HWo={toc:[]},$Wo="wrapper";function KWo(t){let{components:n,...e}=t;return(0,s.kt)($Wo,(0,p.Z)({},HWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}KWo.isMDXComponent=!0;const JWo={toc:[]},tIo="wrapper";function nIo(t){let{components:n,...e}=t;return(0,s.kt)(tIo,(0,p.Z)({},JWo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}nIo.isMDXComponent=!0;const eIo={toc:[]},oIo="wrapper";function pIo(t){let{components:n,...e}=t;return(0,s.kt)(oIo,(0,p.Z)({},eIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}pIo.isMDXComponent=!0;const rIo={toc:[]},sIo="wrapper";function cIo(t){let{components:n,...e}=t;return(0,s.kt)(sIo,(0,p.Z)({},rIo,e,{components:n,mdxType:"MDXLayout"}))}cIo.isMDXComponent=!0;const iIo={toc:[]},aIo="wrapper";function lIo(t){let{components:n,...e}=t;return(0,s.kt)(aIo,(0,p.Z)({},iIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local video:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import video from './example.mp4';\n// ...\nview.add(<Video src={video} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Video src="https://example.com/video.mp4" />)\n')))}lIo.isMDXComponent=!0;const uIo={toc:[]},mIo="wrapper";function dIo(t){let{components:n,...e}=t;return(0,s.kt)(mIo,(0,p.Z)({},uIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}dIo.isMDXComponent=!0;const hIo={toc:[]},kIo="wrapper";function fIo(t){let{components:n,...e}=t;return(0,s.kt)(kIo,(0,p.Z)({},hIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}fIo.isMDXComponent=!0;const yIo={toc:[]},MIo="wrapper";function DIo(t){let{components:n,...e}=t;return(0,s.kt)(MIo,(0,p.Z)({},yIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}DIo.isMDXComponent=!0;const XIo={toc:[]},_Io="wrapper";function wIo(t){let{components:n,...e}=t;return(0,s.kt)(_Io,(0,p.Z)({},XIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wIo.isMDXComponent=!0;const TIo={toc:[]},CIo="wrapper";function gIo(t){let{components:n,...e}=t;return(0,s.kt)(CIo,(0,p.Z)({},TIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}gIo.isMDXComponent=!0;const xIo={toc:[]},vIo="wrapper";function LIo(t){let{components:n,...e}=t;return(0,s.kt)(vIo,(0,p.Z)({},xIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}LIo.isMDXComponent=!0;const ZIo={toc:[]},bIo="wrapper";function NIo(t){let{components:n,...e}=t;return(0,s.kt)(bIo,(0,p.Z)({},ZIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}NIo.isMDXComponent=!0;const AIo={toc:[]},zIo="wrapper";function WIo(t){let{components:n,...e}=t;return(0,s.kt)(zIo,(0,p.Z)({},AIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}WIo.isMDXComponent=!0;const IIo={toc:[]},RIo="wrapper";function PIo(t){let{components:n,...e}=t;return(0,s.kt)(RIo,(0,p.Z)({},IIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}PIo.isMDXComponent=!0;const SIo={toc:[]},EIo="wrapper";function GIo(t){let{components:n,...e}=t;return(0,s.kt)(EIo,(0,p.Z)({},SIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}GIo.isMDXComponent=!0;const OIo={toc:[]},FIo="wrapper";function BIo(t){let{components:n,...e}=t;return(0,s.kt)(FIo,(0,p.Z)({},OIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}BIo.isMDXComponent=!0;const UIo={toc:[]},VIo="wrapper";function qIo(t){let{components:n,...e}=t;return(0,s.kt)(VIo,(0,p.Z)({},UIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}qIo.isMDXComponent=!0;const jIo={toc:[]},YIo="wrapper";function QIo(t){let{components:n,...e}=t;return(0,s.kt)(YIo,(0,p.Z)({},jIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}QIo.isMDXComponent=!0;const HIo={toc:[]},$Io="wrapper";function KIo(t){let{components:n,...e}=t;return(0,s.kt)($Io,(0,p.Z)({},HIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}KIo.isMDXComponent=!0;const JIo={toc:[]},tRo="wrapper";function nRo(t){let{components:n,...e}=t;return(0,s.kt)(tRo,(0,p.Z)({},JIo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}nRo.isMDXComponent=!0;const eRo={toc:[]},oRo="wrapper";function pRo(t){let{components:n,...e}=t;return(0,s.kt)(oRo,(0,p.Z)({},eRo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}pRo.isMDXComponent=!0;const rRo={toc:[]},sRo="wrapper";function cRo(t){let{components:n,...e}=t;return(0,s.kt)(sRo,(0,p.Z)({},rRo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}cRo.isMDXComponent=!0;const iRo={toc:[]},aRo="wrapper";function lRo(t){let{components:n,...e}=t;return(0,s.kt)(aRo,(0,p.Z)({},iRo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}lRo.isMDXComponent=!0;const uRo={toc:[]},mRo="wrapper";function dRo(t){let{components:n,...e}=t;return(0,s.kt)(mRo,(0,p.Z)({},uRo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}dRo.isMDXComponent=!0;const hRo={toc:[]},kRo="wrapper";function fRo(t){let{components:n,...e}=t;return(0,s.kt)(kRo,(0,p.Z)({},hRo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}fRo.isMDXComponent=!0;const yRo={toc:[]},MRo="wrapper";function DRo(t){let{components:n,...e}=t;return(0,s.kt)(MRo,(0,p.Z)({},yRo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}DRo.isMDXComponent=!0;const XRo={toc:[]},_Ro="wrapper";function wRo(t){let{components:n,...e}=t;return(0,s.kt)(_Ro,(0,p.Z)({},XRo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}wRo.isMDXComponent=!0;const TRo={toc:[]},CRo="wrapper";function gRo(t){let{components:n,...e}=t;return(0,s.kt)(CRo,(0,p.Z)({},TRo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}gRo.isMDXComponent=!0;const xRo={toc:[]},vRo="wrapper";function LRo(t){let{components:n,...e}=t;return(0,s.kt)(vRo,(0,p.Z)({},xRo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}LRo.isMDXComponent=!0;const ZRo={toc:[]},bRo="wrapper";function NRo(t){let{components:n,...e}=t;return(0,s.kt)(bRo,(0,p.Z)({},ZRo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}NRo.isMDXComponent=!0;const ARo={toc:[]},zRo="wrapper";function WRo(t){let{components:n,...e}=t;return(0,s.kt)(zRo,(0,p.Z)({},ARo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}WRo.isMDXComponent=!0;const IRo={toc:[]},RRo="wrapper";function PRo(t){let{components:n,...e}=t;return(0,s.kt)(RRo,(0,p.Z)({},IRo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}PRo.isMDXComponent=!0;const SRo={toc:[]},ERo="wrapper";function GRo(t){let{components:n,...e}=t;return(0,s.kt)(ERo,(0,p.Z)({},SRo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}GRo.isMDXComponent=!0;const ORo={toc:[]},FRo="wrapper";function BRo(t){let{components:n,...e}=t;return(0,s.kt)(FRo,(0,p.Z)({},ORo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}BRo.isMDXComponent=!0;const URo={toc:[]},VRo="wrapper";function qRo(t){let{components:n,...e}=t;return(0,s.kt)(VRo,(0,p.Z)({},URo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}qRo.isMDXComponent=!0;const jRo={toc:[]},YRo="wrapper";function QRo(t){let{components:n,...e}=t;return(0,s.kt)(YRo,(0,p.Z)({},jRo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}QRo.isMDXComponent=!0;const HRo={toc:[]},$Ro="wrapper";function KRo(t){let{components:n,...e}=t;return(0,s.kt)($Ro,(0,p.Z)({},HRo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}KRo.isMDXComponent=!0;const JRo={toc:[]},tPo="wrapper";function nPo(t){let{components:n,...e}=t;return(0,s.kt)(tPo,(0,p.Z)({},JRo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}nPo.isMDXComponent=!0;const ePo={toc:[]},oPo="wrapper";function pPo(t){let{components:n,...e}=t;return(0,s.kt)(oPo,(0,p.Z)({},ePo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pPo.isMDXComponent=!0;const rPo={toc:[]},sPo="wrapper";function cPo(t){let{components:n,...e}=t;return(0,s.kt)(sPo,(0,p.Z)({},rPo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}cPo.isMDXComponent=!0;const iPo={toc:[]},aPo="wrapper";function lPo(t){let{components:n,...e}=t;return(0,s.kt)(aPo,(0,p.Z)({},iPo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}lPo.isMDXComponent=!0;const uPo={toc:[]},mPo="wrapper";function dPo(t){let{components:n,...e}=t;return(0,s.kt)(mPo,(0,p.Z)({},uPo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}dPo.isMDXComponent=!0;const hPo={toc:[]},kPo="wrapper";function fPo(t){let{components:n,...e}=t;return(0,s.kt)(kPo,(0,p.Z)({},hPo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}fPo.isMDXComponent=!0;const yPo={toc:[]},MPo="wrapper";function DPo(t){let{components:n,...e}=t;return(0,s.kt)(MPo,(0,p.Z)({},yPo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}DPo.isMDXComponent=!0;const XPo={toc:[]},_Po="wrapper";function wPo(t){let{components:n,...e}=t;return(0,s.kt)(_Po,(0,p.Z)({},XPo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}wPo.isMDXComponent=!0;const TPo={toc:[]},CPo="wrapper";function gPo(t){let{components:n,...e}=t;return(0,s.kt)(CPo,(0,p.Z)({},TPo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}gPo.isMDXComponent=!0;const xPo={toc:[]},vPo="wrapper";function LPo(t){let{components:n,...e}=t;return(0,s.kt)(vPo,(0,p.Z)({},xPo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}LPo.isMDXComponent=!0;const ZPo={toc:[]},bPo="wrapper";function NPo(t){let{components:n,...e}=t;return(0,s.kt)(bPo,(0,p.Z)({},ZPo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}NPo.isMDXComponent=!0;const APo={toc:[]},zPo="wrapper";function WPo(t){let{components:n,...e}=t;return(0,s.kt)(zPo,(0,p.Z)({},APo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}WPo.isMDXComponent=!0;const IPo={toc:[]},RPo="wrapper";function PPo(t){let{components:n,...e}=t;return(0,s.kt)(RPo,(0,p.Z)({},IPo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}PPo.isMDXComponent=!0;const SPo={toc:[]},EPo="wrapper";function GPo(t){let{components:n,...e}=t;return(0,s.kt)(EPo,(0,p.Z)({},SPo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}GPo.isMDXComponent=!0;const OPo={toc:[]},FPo="wrapper";function BPo(t){let{components:n,...e}=t;return(0,s.kt)(FPo,(0,p.Z)({},OPo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}BPo.isMDXComponent=!0;const UPo={toc:[]},VPo="wrapper";function qPo(t){let{components:n,...e}=t;return(0,s.kt)(VPo,(0,p.Z)({},UPo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}qPo.isMDXComponent=!0;const jPo={toc:[]},YPo="wrapper";function QPo(t){let{components:n,...e}=t;return(0,s.kt)(YPo,(0,p.Z)({},jPo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}QPo.isMDXComponent=!0;const HPo={toc:[]},$Po="wrapper";function KPo(t){let{components:n,...e}=t;return(0,s.kt)($Po,(0,p.Z)({},HPo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}KPo.isMDXComponent=!0;const JPo={toc:[]},tSo="wrapper";function nSo(t){let{components:n,...e}=t;return(0,s.kt)(tSo,(0,p.Z)({},JPo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}nSo.isMDXComponent=!0;const eSo={toc:[]},oSo="wrapper";function pSo(t){let{components:n,...e}=t;return(0,s.kt)(oSo,(0,p.Z)({},eSo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pSo.isMDXComponent=!0;const rSo={toc:[]},sSo="wrapper";function cSo(t){let{components:n,...e}=t;return(0,s.kt)(sSo,(0,p.Z)({},rSo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}cSo.isMDXComponent=!0;const iSo={toc:[]},aSo="wrapper";function lSo(t){let{components:n,...e}=t;return(0,s.kt)(aSo,(0,p.Z)({},iSo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}lSo.isMDXComponent=!0;const uSo={toc:[]},mSo="wrapper";function dSo(t){let{components:n,...e}=t;return(0,s.kt)(mSo,(0,p.Z)({},uSo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dSo.isMDXComponent=!0;const hSo={toc:[]},kSo="wrapper";function fSo(t){let{components:n,...e}=t;return(0,s.kt)(kSo,(0,p.Z)({},hSo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}fSo.isMDXComponent=!0;const ySo={toc:[]},MSo="wrapper";function DSo(t){let{components:n,...e}=t;return(0,s.kt)(MSo,(0,p.Z)({},ySo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}DSo.isMDXComponent=!0;const XSo={toc:[]},_So="wrapper";function wSo(t){let{components:n,...e}=t;return(0,s.kt)(_So,(0,p.Z)({},XSo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wSo.isMDXComponent=!0;const TSo={toc:[]},CSo="wrapper";function gSo(t){let{components:n,...e}=t;return(0,s.kt)(CSo,(0,p.Z)({},TSo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}gSo.isMDXComponent=!0;const xSo={toc:[]},vSo="wrapper";function LSo(t){let{components:n,...e}=t;return(0,s.kt)(vSo,(0,p.Z)({},xSo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}LSo.isMDXComponent=!0;const ZSo={toc:[]},bSo="wrapper";function NSo(t){let{components:n,...e}=t;return(0,s.kt)(bSo,(0,p.Z)({},ZSo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NSo.isMDXComponent=!0;const ASo={toc:[]},zSo="wrapper";function WSo(t){let{components:n,...e}=t;return(0,s.kt)(zSo,(0,p.Z)({},ASo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}WSo.isMDXComponent=!0;const ISo={toc:[]},RSo="wrapper";function PSo(t){let{components:n,...e}=t;return(0,s.kt)(RSo,(0,p.Z)({},ISo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}PSo.isMDXComponent=!0;const SSo={toc:[]},ESo="wrapper";function GSo(t){let{components:n,...e}=t;return(0,s.kt)(ESo,(0,p.Z)({},SSo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}GSo.isMDXComponent=!0;const OSo={toc:[]},FSo="wrapper";function BSo(t){let{components:n,...e}=t;return(0,s.kt)(FSo,(0,p.Z)({},OSo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}BSo.isMDXComponent=!0;const USo={toc:[]},VSo="wrapper";function qSo(t){let{components:n,...e}=t;return(0,s.kt)(VSo,(0,p.Z)({},USo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}qSo.isMDXComponent=!0;const jSo={toc:[]},YSo="wrapper";function QSo(t){let{components:n,...e}=t;return(0,s.kt)(YSo,(0,p.Z)({},jSo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}QSo.isMDXComponent=!0;const HSo={toc:[]},$So="wrapper";function KSo(t){let{components:n,...e}=t;return(0,s.kt)($So,(0,p.Z)({},HSo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}KSo.isMDXComponent=!0;const JSo={toc:[]},tEo="wrapper";function nEo(t){let{components:n,...e}=t;return(0,s.kt)(tEo,(0,p.Z)({},JSo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}nEo.isMDXComponent=!0;const eEo={toc:[]},oEo="wrapper";function pEo(t){let{components:n,...e}=t;return(0,s.kt)(oEo,(0,p.Z)({},eEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pEo.isMDXComponent=!0;const rEo={toc:[]},sEo="wrapper";function cEo(t){let{components:n,...e}=t;return(0,s.kt)(sEo,(0,p.Z)({},rEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}cEo.isMDXComponent=!0;const iEo={toc:[]},aEo="wrapper";function lEo(t){let{components:n,...e}=t;return(0,s.kt)(aEo,(0,p.Z)({},iEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lEo.isMDXComponent=!0;const uEo={toc:[]},mEo="wrapper";function dEo(t){let{components:n,...e}=t;return(0,s.kt)(mEo,(0,p.Z)({},uEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}dEo.isMDXComponent=!0;const hEo={toc:[]},kEo="wrapper";function fEo(t){let{components:n,...e}=t;return(0,s.kt)(kEo,(0,p.Z)({},hEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}fEo.isMDXComponent=!0;const yEo={toc:[]},MEo="wrapper";function DEo(t){let{components:n,...e}=t;return(0,s.kt)(MEo,(0,p.Z)({},yEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}DEo.isMDXComponent=!0;const XEo={toc:[]},_Eo="wrapper";function wEo(t){let{components:n,...e}=t;return(0,s.kt)(_Eo,(0,p.Z)({},XEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}wEo.isMDXComponent=!0;const TEo={toc:[]},CEo="wrapper";function gEo(t){let{components:n,...e}=t;return(0,s.kt)(CEo,(0,p.Z)({},TEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}gEo.isMDXComponent=!0;const xEo={toc:[]},vEo="wrapper";function LEo(t){let{components:n,...e}=t;return(0,s.kt)(vEo,(0,p.Z)({},xEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}LEo.isMDXComponent=!0;const ZEo={toc:[]},bEo="wrapper";function NEo(t){let{components:n,...e}=t;return(0,s.kt)(bEo,(0,p.Z)({},ZEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}NEo.isMDXComponent=!0;const AEo={toc:[]},zEo="wrapper";function WEo(t){let{components:n,...e}=t;return(0,s.kt)(zEo,(0,p.Z)({},AEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}WEo.isMDXComponent=!0;const IEo={toc:[]},REo="wrapper";function PEo(t){let{components:n,...e}=t;return(0,s.kt)(REo,(0,p.Z)({},IEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}PEo.isMDXComponent=!0;const SEo={toc:[]},EEo="wrapper";function GEo(t){let{components:n,...e}=t;return(0,s.kt)(EEo,(0,p.Z)({},SEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}GEo.isMDXComponent=!0;const OEo={toc:[]},FEo="wrapper";function BEo(t){let{components:n,...e}=t;return(0,s.kt)(FEo,(0,p.Z)({},OEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}BEo.isMDXComponent=!0;const UEo={toc:[]},VEo="wrapper";function qEo(t){let{components:n,...e}=t;return(0,s.kt)(VEo,(0,p.Z)({},UEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}qEo.isMDXComponent=!0;const jEo={toc:[]},YEo="wrapper";function QEo(t){let{components:n,...e}=t;return(0,s.kt)(YEo,(0,p.Z)({},jEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}QEo.isMDXComponent=!0;const HEo={toc:[]},$Eo="wrapper";function KEo(t){let{components:n,...e}=t;return(0,s.kt)($Eo,(0,p.Z)({},HEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}KEo.isMDXComponent=!0;const JEo={toc:[]},tGo="wrapper";function nGo(t){let{components:n,...e}=t;return(0,s.kt)(tGo,(0,p.Z)({},JEo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}nGo.isMDXComponent=!0;const eGo={toc:[]},oGo="wrapper";function pGo(t){let{components:n,...e}=t;return(0,s.kt)(oGo,(0,p.Z)({},eGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}pGo.isMDXComponent=!0;const rGo={toc:[]},sGo="wrapper";function cGo(t){let{components:n,...e}=t;return(0,s.kt)(sGo,(0,p.Z)({},rGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}cGo.isMDXComponent=!0;const iGo={toc:[]},aGo="wrapper";function lGo(t){let{components:n,...e}=t;return(0,s.kt)(aGo,(0,p.Z)({},iGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}lGo.isMDXComponent=!0;const uGo={toc:[]},mGo="wrapper";function dGo(t){let{components:n,...e}=t;return(0,s.kt)(mGo,(0,p.Z)({},uGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dGo.isMDXComponent=!0;const hGo={toc:[]},kGo="wrapper";function fGo(t){let{components:n,...e}=t;return(0,s.kt)(kGo,(0,p.Z)({},hGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}fGo.isMDXComponent=!0;const yGo={toc:[]},MGo="wrapper";function DGo(t){let{components:n,...e}=t;return(0,s.kt)(MGo,(0,p.Z)({},yGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}DGo.isMDXComponent=!0;const XGo={toc:[]},_Go="wrapper";function wGo(t){let{components:n,...e}=t;return(0,s.kt)(_Go,(0,p.Z)({},XGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wGo.isMDXComponent=!0;const TGo={toc:[]},CGo="wrapper";function gGo(t){let{components:n,...e}=t;return(0,s.kt)(CGo,(0,p.Z)({},TGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}gGo.isMDXComponent=!0;const xGo={toc:[]},vGo="wrapper";function LGo(t){let{components:n,...e}=t;return(0,s.kt)(vGo,(0,p.Z)({},xGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}LGo.isMDXComponent=!0;const ZGo={toc:[]},bGo="wrapper";function NGo(t){let{components:n,...e}=t;return(0,s.kt)(bGo,(0,p.Z)({},ZGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}NGo.isMDXComponent=!0;const AGo={toc:[]},zGo="wrapper";function WGo(t){let{components:n,...e}=t;return(0,s.kt)(zGo,(0,p.Z)({},AGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}WGo.isMDXComponent=!0;const IGo={toc:[]},RGo="wrapper";function PGo(t){let{components:n,...e}=t;return(0,s.kt)(RGo,(0,p.Z)({},IGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}PGo.isMDXComponent=!0;const SGo={toc:[]},EGo="wrapper";function GGo(t){let{components:n,...e}=t;return(0,s.kt)(EGo,(0,p.Z)({},SGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}GGo.isMDXComponent=!0;const OGo={toc:[]},FGo="wrapper";function BGo(t){let{components:n,...e}=t;return(0,s.kt)(FGo,(0,p.Z)({},OGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}BGo.isMDXComponent=!0;const UGo={toc:[]},VGo="wrapper";function qGo(t){let{components:n,...e}=t;return(0,s.kt)(VGo,(0,p.Z)({},UGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qGo.isMDXComponent=!0;const jGo={toc:[]},YGo="wrapper";function QGo(t){let{components:n,...e}=t;return(0,s.kt)(YGo,(0,p.Z)({},jGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}QGo.isMDXComponent=!0;const HGo={toc:[]},$Go="wrapper";function KGo(t){let{components:n,...e}=t;return(0,s.kt)($Go,(0,p.Z)({},HGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}KGo.isMDXComponent=!0;const JGo={toc:[]},tOo="wrapper";function nOo(t){let{components:n,...e}=t;return(0,s.kt)(tOo,(0,p.Z)({},JGo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}nOo.isMDXComponent=!0;const eOo={toc:[]},oOo="wrapper";function pOo(t){let{components:n,...e}=t;return(0,s.kt)(oOo,(0,p.Z)({},eOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}pOo.isMDXComponent=!0;const rOo={toc:[]},sOo="wrapper";function cOo(t){let{components:n,...e}=t;return(0,s.kt)(sOo,(0,p.Z)({},rOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}cOo.isMDXComponent=!0;const iOo={toc:[]},aOo="wrapper";function lOo(t){let{components:n,...e}=t;return(0,s.kt)(aOo,(0,p.Z)({},iOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}lOo.isMDXComponent=!0;const uOo={toc:[]},mOo="wrapper";function dOo(t){let{components:n,...e}=t;return(0,s.kt)(mOo,(0,p.Z)({},uOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}dOo.isMDXComponent=!0;const hOo={toc:[]},kOo="wrapper";function fOo(t){let{components:n,...e}=t;return(0,s.kt)(kOo,(0,p.Z)({},hOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}fOo.isMDXComponent=!0;const yOo={toc:[]},MOo="wrapper";function DOo(t){let{components:n,...e}=t;return(0,s.kt)(MOo,(0,p.Z)({},yOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}DOo.isMDXComponent=!0;const XOo={toc:[]},_Oo="wrapper";function wOo(t){let{components:n,...e}=t;return(0,s.kt)(_Oo,(0,p.Z)({},XOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}wOo.isMDXComponent=!0;const TOo={toc:[]},COo="wrapper";function gOo(t){let{components:n,...e}=t;return(0,s.kt)(COo,(0,p.Z)({},TOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}gOo.isMDXComponent=!0;const xOo={toc:[]},vOo="wrapper";function LOo(t){let{components:n,...e}=t;return(0,s.kt)(vOo,(0,p.Z)({},xOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}LOo.isMDXComponent=!0;const ZOo={toc:[]},bOo="wrapper";function NOo(t){let{components:n,...e}=t;return(0,s.kt)(bOo,(0,p.Z)({},ZOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}NOo.isMDXComponent=!0;const AOo={toc:[]},zOo="wrapper";function WOo(t){let{components:n,...e}=t;return(0,s.kt)(zOo,(0,p.Z)({},AOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}WOo.isMDXComponent=!0;const IOo={toc:[]},ROo="wrapper";function POo(t){let{components:n,...e}=t;return(0,s.kt)(ROo,(0,p.Z)({},IOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}POo.isMDXComponent=!0;const SOo={toc:[]},EOo="wrapper";function GOo(t){let{components:n,...e}=t;return(0,s.kt)(EOo,(0,p.Z)({},SOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}GOo.isMDXComponent=!0;const OOo={toc:[]},FOo="wrapper";function BOo(t){let{components:n,...e}=t;return(0,s.kt)(FOo,(0,p.Z)({},OOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}BOo.isMDXComponent=!0;const UOo={toc:[]},VOo="wrapper";function qOo(t){let{components:n,...e}=t;return(0,s.kt)(VOo,(0,p.Z)({},UOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}qOo.isMDXComponent=!0;const jOo={toc:[]},YOo="wrapper";function QOo(t){let{components:n,...e}=t;return(0,s.kt)(YOo,(0,p.Z)({},jOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}QOo.isMDXComponent=!0;const HOo={toc:[]},$Oo="wrapper";function KOo(t){let{components:n,...e}=t;return(0,s.kt)($Oo,(0,p.Z)({},HOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}KOo.isMDXComponent=!0;const JOo={toc:[]},tFo="wrapper";function nFo(t){let{components:n,...e}=t;return(0,s.kt)(tFo,(0,p.Z)({},JOo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}nFo.isMDXComponent=!0;const eFo={toc:[]},oFo="wrapper";function pFo(t){let{components:n,...e}=t;return(0,s.kt)(oFo,(0,p.Z)({},eFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}pFo.isMDXComponent=!0;const rFo={toc:[]},sFo="wrapper";function cFo(t){let{components:n,...e}=t;return(0,s.kt)(sFo,(0,p.Z)({},rFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cFo.isMDXComponent=!0;const iFo={toc:[]},aFo="wrapper";function lFo(t){let{components:n,...e}=t;return(0,s.kt)(aFo,(0,p.Z)({},iFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lFo.isMDXComponent=!0;const uFo={toc:[]},mFo="wrapper";function dFo(t){let{components:n,...e}=t;return(0,s.kt)(mFo,(0,p.Z)({},uFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}dFo.isMDXComponent=!0;const hFo={toc:[]},kFo="wrapper";function fFo(t){let{components:n,...e}=t;return(0,s.kt)(kFo,(0,p.Z)({},hFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}fFo.isMDXComponent=!0;const yFo={toc:[]},MFo="wrapper";function DFo(t){let{components:n,...e}=t;return(0,s.kt)(MFo,(0,p.Z)({},yFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}DFo.isMDXComponent=!0;const XFo={toc:[]},_Fo="wrapper";function wFo(t){let{components:n,...e}=t;return(0,s.kt)(_Fo,(0,p.Z)({},XFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wFo.isMDXComponent=!0;const TFo={toc:[]},CFo="wrapper";function gFo(t){let{components:n,...e}=t;return(0,s.kt)(CFo,(0,p.Z)({},TFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}gFo.isMDXComponent=!0;const xFo={toc:[]},vFo="wrapper";function LFo(t){let{components:n,...e}=t;return(0,s.kt)(vFo,(0,p.Z)({},xFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}LFo.isMDXComponent=!0;const ZFo={toc:[]},bFo="wrapper";function NFo(t){let{components:n,...e}=t;return(0,s.kt)(bFo,(0,p.Z)({},ZFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}NFo.isMDXComponent=!0;const AFo={toc:[]},zFo="wrapper";function WFo(t){let{components:n,...e}=t;return(0,s.kt)(zFo,(0,p.Z)({},AFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WFo.isMDXComponent=!0;const IFo={toc:[]},RFo="wrapper";function PFo(t){let{components:n,...e}=t;return(0,s.kt)(RFo,(0,p.Z)({},IFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}PFo.isMDXComponent=!0;const SFo={toc:[]},EFo="wrapper";function GFo(t){let{components:n,...e}=t;return(0,s.kt)(EFo,(0,p.Z)({},SFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}GFo.isMDXComponent=!0;const OFo={toc:[]},FFo="wrapper";function BFo(t){let{components:n,...e}=t;return(0,s.kt)(FFo,(0,p.Z)({},OFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}BFo.isMDXComponent=!0;const UFo={toc:[]},VFo="wrapper";function qFo(t){let{components:n,...e}=t;return(0,s.kt)(VFo,(0,p.Z)({},UFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}qFo.isMDXComponent=!0;const jFo={toc:[]},YFo="wrapper";function QFo(t){let{components:n,...e}=t;return(0,s.kt)(YFo,(0,p.Z)({},jFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}QFo.isMDXComponent=!0;const HFo={toc:[]},$Fo="wrapper";function KFo(t){let{components:n,...e}=t;return(0,s.kt)($Fo,(0,p.Z)({},HFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}KFo.isMDXComponent=!0;const JFo={toc:[]},tBo="wrapper";function nBo(t){let{components:n,...e}=t;return(0,s.kt)(tBo,(0,p.Z)({},JFo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}nBo.isMDXComponent=!0;const eBo={toc:[]},oBo="wrapper";function pBo(t){let{components:n,...e}=t;return(0,s.kt)(oBo,(0,p.Z)({},eBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}pBo.isMDXComponent=!0;const rBo={toc:[]},sBo="wrapper";function cBo(t){let{components:n,...e}=t;return(0,s.kt)(sBo,(0,p.Z)({},rBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}cBo.isMDXComponent=!0;const iBo={toc:[]},aBo="wrapper";function lBo(t){let{components:n,...e}=t;return(0,s.kt)(aBo,(0,p.Z)({},iBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}lBo.isMDXComponent=!0;const uBo={toc:[]},mBo="wrapper";function dBo(t){let{components:n,...e}=t;return(0,s.kt)(mBo,(0,p.Z)({},uBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}dBo.isMDXComponent=!0;const hBo={toc:[]},kBo="wrapper";function fBo(t){let{components:n,...e}=t;return(0,s.kt)(kBo,(0,p.Z)({},hBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}fBo.isMDXComponent=!0;const yBo={toc:[]},MBo="wrapper";function DBo(t){let{components:n,...e}=t;return(0,s.kt)(MBo,(0,p.Z)({},yBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}DBo.isMDXComponent=!0;const XBo={toc:[]},_Bo="wrapper";function wBo(t){let{components:n,...e}=t;return(0,s.kt)(_Bo,(0,p.Z)({},XBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}wBo.isMDXComponent=!0;const TBo={toc:[]},CBo="wrapper";function gBo(t){let{components:n,...e}=t;return(0,s.kt)(CBo,(0,p.Z)({},TBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}gBo.isMDXComponent=!0;const xBo={toc:[]},vBo="wrapper";function LBo(t){let{components:n,...e}=t;return(0,s.kt)(vBo,(0,p.Z)({},xBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}LBo.isMDXComponent=!0;const ZBo={toc:[]},bBo="wrapper";function NBo(t){let{components:n,...e}=t;return(0,s.kt)(bBo,(0,p.Z)({},ZBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}NBo.isMDXComponent=!0;const ABo={toc:[]},zBo="wrapper";function WBo(t){let{components:n,...e}=t;return(0,s.kt)(zBo,(0,p.Z)({},ABo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}WBo.isMDXComponent=!0;const IBo={toc:[]},RBo="wrapper";function PBo(t){let{components:n,...e}=t;return(0,s.kt)(RBo,(0,p.Z)({},IBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}PBo.isMDXComponent=!0;const SBo={toc:[]},EBo="wrapper";function GBo(t){let{components:n,...e}=t;return(0,s.kt)(EBo,(0,p.Z)({},SBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}GBo.isMDXComponent=!0;const OBo={toc:[]},FBo="wrapper";function BBo(t){let{components:n,...e}=t;return(0,s.kt)(FBo,(0,p.Z)({},OBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}BBo.isMDXComponent=!0;const UBo={toc:[]},VBo="wrapper";function qBo(t){let{components:n,...e}=t;return(0,s.kt)(VBo,(0,p.Z)({},UBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}qBo.isMDXComponent=!0;const jBo={toc:[]},YBo="wrapper";function QBo(t){let{components:n,...e}=t;return(0,s.kt)(YBo,(0,p.Z)({},jBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}QBo.isMDXComponent=!0;const HBo={toc:[]},$Bo="wrapper";function KBo(t){let{components:n,...e}=t;return(0,s.kt)($Bo,(0,p.Z)({},HBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}KBo.isMDXComponent=!0;const JBo={toc:[]},tUo="wrapper";function nUo(t){let{components:n,...e}=t;return(0,s.kt)(tUo,(0,p.Z)({},JBo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}nUo.isMDXComponent=!0;const eUo={toc:[]},oUo="wrapper";function pUo(t){let{components:n,...e}=t;return(0,s.kt)(oUo,(0,p.Z)({},eUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}pUo.isMDXComponent=!0;const rUo={toc:[]},sUo="wrapper";function cUo(t){let{components:n,...e}=t;return(0,s.kt)(sUo,(0,p.Z)({},rUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}cUo.isMDXComponent=!0;const iUo={toc:[]},aUo="wrapper";function lUo(t){let{components:n,...e}=t;return(0,s.kt)(aUo,(0,p.Z)({},iUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}lUo.isMDXComponent=!0;const uUo={toc:[]},mUo="wrapper";function dUo(t){let{components:n,...e}=t;return(0,s.kt)(mUo,(0,p.Z)({},uUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}dUo.isMDXComponent=!0;const hUo={toc:[]},kUo="wrapper";function fUo(t){let{components:n,...e}=t;return(0,s.kt)(kUo,(0,p.Z)({},hUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}fUo.isMDXComponent=!0;const yUo={toc:[]},MUo="wrapper";function DUo(t){let{components:n,...e}=t;return(0,s.kt)(MUo,(0,p.Z)({},yUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}DUo.isMDXComponent=!0;const XUo={toc:[]},_Uo="wrapper";function wUo(t){let{components:n,...e}=t;return(0,s.kt)(_Uo,(0,p.Z)({},XUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}wUo.isMDXComponent=!0;const TUo={toc:[]},CUo="wrapper";function gUo(t){let{components:n,...e}=t;return(0,s.kt)(CUo,(0,p.Z)({},TUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}gUo.isMDXComponent=!0;const xUo={toc:[]},vUo="wrapper";function LUo(t){let{components:n,...e}=t;return(0,s.kt)(vUo,(0,p.Z)({},xUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}LUo.isMDXComponent=!0;const ZUo={toc:[]},bUo="wrapper";function NUo(t){let{components:n,...e}=t;return(0,s.kt)(bUo,(0,p.Z)({},ZUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}NUo.isMDXComponent=!0;const AUo={toc:[]},zUo="wrapper";function WUo(t){let{components:n,...e}=t;return(0,s.kt)(zUo,(0,p.Z)({},AUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}WUo.isMDXComponent=!0;const IUo={toc:[]},RUo="wrapper";function PUo(t){let{components:n,...e}=t;return(0,s.kt)(RUo,(0,p.Z)({},IUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}PUo.isMDXComponent=!0;const SUo={toc:[]},EUo="wrapper";function GUo(t){let{components:n,...e}=t;return(0,s.kt)(EUo,(0,p.Z)({},SUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}GUo.isMDXComponent=!0;const OUo={toc:[]},FUo="wrapper";function BUo(t){let{components:n,...e}=t;return(0,s.kt)(FUo,(0,p.Z)({},OUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}BUo.isMDXComponent=!0;const UUo={toc:[]},VUo="wrapper";function qUo(t){let{components:n,...e}=t;return(0,s.kt)(VUo,(0,p.Z)({},UUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}qUo.isMDXComponent=!0;const jUo={toc:[]},YUo="wrapper";function QUo(t){let{components:n,...e}=t;return(0,s.kt)(YUo,(0,p.Z)({},jUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}QUo.isMDXComponent=!0;const HUo={toc:[]},$Uo="wrapper";function KUo(t){let{components:n,...e}=t;return(0,s.kt)($Uo,(0,p.Z)({},HUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}KUo.isMDXComponent=!0;const JUo={toc:[]},tVo="wrapper";function nVo(t){let{components:n,...e}=t;return(0,s.kt)(tVo,(0,p.Z)({},JUo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}nVo.isMDXComponent=!0;const eVo={toc:[]},oVo="wrapper";function pVo(t){let{components:n,...e}=t;return(0,s.kt)(oVo,(0,p.Z)({},eVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}pVo.isMDXComponent=!0;const rVo={toc:[]},sVo="wrapper";function cVo(t){let{components:n,...e}=t;return(0,s.kt)(sVo,(0,p.Z)({},rVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}cVo.isMDXComponent=!0;const iVo={toc:[]},aVo="wrapper";function lVo(t){let{components:n,...e}=t;return(0,s.kt)(aVo,(0,p.Z)({},iVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}lVo.isMDXComponent=!0;const uVo={toc:[]},mVo="wrapper";function dVo(t){let{components:n,...e}=t;return(0,s.kt)(mVo,(0,p.Z)({},uVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}dVo.isMDXComponent=!0;const hVo={toc:[]},kVo="wrapper";function fVo(t){let{components:n,...e}=t;return(0,s.kt)(kVo,(0,p.Z)({},hVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}fVo.isMDXComponent=!0;const yVo={toc:[]},MVo="wrapper";function DVo(t){let{components:n,...e}=t;return(0,s.kt)(MVo,(0,p.Z)({},yVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}DVo.isMDXComponent=!0;const XVo={toc:[]},_Vo="wrapper";function wVo(t){let{components:n,...e}=t;return(0,s.kt)(_Vo,(0,p.Z)({},XVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}wVo.isMDXComponent=!0;const TVo={toc:[]},CVo="wrapper";function gVo(t){let{components:n,...e}=t;return(0,s.kt)(CVo,(0,p.Z)({},TVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}gVo.isMDXComponent=!0;const xVo={toc:[]},vVo="wrapper";function LVo(t){let{components:n,...e}=t;return(0,s.kt)(vVo,(0,p.Z)({},xVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}LVo.isMDXComponent=!0;const ZVo={toc:[]},bVo="wrapper";function NVo(t){let{components:n,...e}=t;return(0,s.kt)(bVo,(0,p.Z)({},ZVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}NVo.isMDXComponent=!0;const AVo={toc:[]},zVo="wrapper";function WVo(t){let{components:n,...e}=t;return(0,s.kt)(zVo,(0,p.Z)({},AVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}WVo.isMDXComponent=!0;const IVo={toc:[]},RVo="wrapper";function PVo(t){let{components:n,...e}=t;return(0,s.kt)(RVo,(0,p.Z)({},IVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}PVo.isMDXComponent=!0;const SVo={toc:[]},EVo="wrapper";function GVo(t){let{components:n,...e}=t;return(0,s.kt)(EVo,(0,p.Z)({},SVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}GVo.isMDXComponent=!0;const OVo={toc:[]},FVo="wrapper";function BVo(t){let{components:n,...e}=t;return(0,s.kt)(FVo,(0,p.Z)({},OVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}BVo.isMDXComponent=!0;const UVo={toc:[]},VVo="wrapper";function qVo(t){let{components:n,...e}=t;return(0,s.kt)(VVo,(0,p.Z)({},UVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}qVo.isMDXComponent=!0;const jVo={toc:[]},YVo="wrapper";function QVo(t){let{components:n,...e}=t;return(0,s.kt)(YVo,(0,p.Z)({},jVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}QVo.isMDXComponent=!0;const HVo={toc:[]},$Vo="wrapper";function KVo(t){let{components:n,...e}=t;return(0,s.kt)($Vo,(0,p.Z)({},HVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}KVo.isMDXComponent=!0;const JVo={toc:[]},tqo="wrapper";function nqo(t){let{components:n,...e}=t;return(0,s.kt)(tqo,(0,p.Z)({},JVo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}nqo.isMDXComponent=!0;const eqo={toc:[]},oqo="wrapper";function pqo(t){let{components:n,...e}=t;return(0,s.kt)(oqo,(0,p.Z)({},eqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}pqo.isMDXComponent=!0;const rqo={toc:[]},sqo="wrapper";function cqo(t){let{components:n,...e}=t;return(0,s.kt)(sqo,(0,p.Z)({},rqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}cqo.isMDXComponent=!0;const iqo={toc:[]},aqo="wrapper";function lqo(t){let{components:n,...e}=t;return(0,s.kt)(aqo,(0,p.Z)({},iqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}lqo.isMDXComponent=!0;const uqo={toc:[]},mqo="wrapper";function dqo(t){let{components:n,...e}=t;return(0,s.kt)(mqo,(0,p.Z)({},uqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}dqo.isMDXComponent=!0;const hqo={toc:[]},kqo="wrapper";function fqo(t){let{components:n,...e}=t;return(0,s.kt)(kqo,(0,p.Z)({},hqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}fqo.isMDXComponent=!0;const yqo={toc:[]},Mqo="wrapper";function Dqo(t){let{components:n,...e}=t;return(0,s.kt)(Mqo,(0,p.Z)({},yqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Dqo.isMDXComponent=!0;const Xqo={toc:[]},_qo="wrapper";function wqo(t){let{components:n,...e}=t;return(0,s.kt)(_qo,(0,p.Z)({},Xqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wqo.isMDXComponent=!0;const Tqo={toc:[]},Cqo="wrapper";function gqo(t){let{components:n,...e}=t;return(0,s.kt)(Cqo,(0,p.Z)({},Tqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}gqo.isMDXComponent=!0;const xqo={toc:[]},vqo="wrapper";function Lqo(t){let{components:n,...e}=t;return(0,s.kt)(vqo,(0,p.Z)({},xqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Lqo.isMDXComponent=!0;const Zqo={toc:[]},bqo="wrapper";function Nqo(t){let{components:n,...e}=t;return(0,s.kt)(bqo,(0,p.Z)({},Zqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Nqo.isMDXComponent=!0;const Aqo={toc:[]},zqo="wrapper";function Wqo(t){let{components:n,...e}=t;return(0,s.kt)(zqo,(0,p.Z)({},Aqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Wqo.isMDXComponent=!0;const Iqo={toc:[]},Rqo="wrapper";function Pqo(t){let{components:n,...e}=t;return(0,s.kt)(Rqo,(0,p.Z)({},Iqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Pqo.isMDXComponent=!0;const Sqo={toc:[]},Eqo="wrapper";function Gqo(t){let{components:n,...e}=t;return(0,s.kt)(Eqo,(0,p.Z)({},Sqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Gqo.isMDXComponent=!0;const Oqo={toc:[]},Fqo="wrapper";function Bqo(t){let{components:n,...e}=t;return(0,s.kt)(Fqo,(0,p.Z)({},Oqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Bqo.isMDXComponent=!0;const Uqo={toc:[]},Vqo="wrapper";function qqo(t){let{components:n,...e}=t;return(0,s.kt)(Vqo,(0,p.Z)({},Uqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}qqo.isMDXComponent=!0;const jqo={toc:[]},Yqo="wrapper";function Qqo(t){let{components:n,...e}=t;return(0,s.kt)(Yqo,(0,p.Z)({},jqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Qqo.isMDXComponent=!0;const Hqo={toc:[]},$qo="wrapper";function Kqo(t){let{components:n,...e}=t;return(0,s.kt)($qo,(0,p.Z)({},Hqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Kqo.isMDXComponent=!0;const Jqo={toc:[]},tjo="wrapper";function njo(t){let{components:n,...e}=t;return(0,s.kt)(tjo,(0,p.Z)({},Jqo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}njo.isMDXComponent=!0;const ejo={toc:[]},ojo="wrapper";function pjo(t){let{components:n,...e}=t;return(0,s.kt)(ojo,(0,p.Z)({},ejo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}pjo.isMDXComponent=!0;const rjo={toc:[]},sjo="wrapper";function cjo(t){let{components:n,...e}=t;return(0,s.kt)(sjo,(0,p.Z)({},rjo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}cjo.isMDXComponent=!0;const ijo={toc:[]},ajo="wrapper";function ljo(t){let{components:n,...e}=t;return(0,s.kt)(ajo,(0,p.Z)({},ijo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}ljo.isMDXComponent=!0;const ujo={toc:[]},mjo="wrapper";function djo(t){let{components:n,...e}=t;return(0,s.kt)(mjo,(0,p.Z)({},ujo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}djo.isMDXComponent=!0;const hjo={toc:[]},kjo="wrapper";function fjo(t){let{components:n,...e}=t;return(0,s.kt)(kjo,(0,p.Z)({},hjo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}fjo.isMDXComponent=!0;const yjo={toc:[]},Mjo="wrapper";function Djo(t){let{components:n,...e}=t;return(0,s.kt)(Mjo,(0,p.Z)({},yjo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Djo.isMDXComponent=!0;const Xjo={toc:[]},_jo="wrapper";function wjo(t){let{components:n,...e}=t;return(0,s.kt)(_jo,(0,p.Z)({},Xjo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}wjo.isMDXComponent=!0;const Tjo={toc:[]},Cjo="wrapper";function gjo(t){let{components:n,...e}=t;return(0,s.kt)(Cjo,(0,p.Z)({},Tjo,e,{components:n,mdxType:"MDXLayout"}))}gjo.isMDXComponent=!0;const xjo={toc:[]},vjo="wrapper";function Ljo(t){let{components:n,...e}=t;return(0,s.kt)(vjo,(0,p.Z)({},xjo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Ljo.isMDXComponent=!0;const Zjo={toc:[]},bjo="wrapper";function Njo(t){let{components:n,...e}=t;return(0,s.kt)(bjo,(0,p.Z)({},Zjo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Njo.isMDXComponent=!0;const Ajo={toc:[]},zjo="wrapper";function Wjo(t){let{components:n,...e}=t;return(0,s.kt)(zjo,(0,p.Z)({},Ajo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Wjo.isMDXComponent=!0;const Ijo={toc:[]},Rjo="wrapper";function Pjo(t){let{components:n,...e}=t;return(0,s.kt)(Rjo,(0,p.Z)({},Ijo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Pjo.isMDXComponent=!0;const Sjo={toc:[]},Ejo="wrapper";function Gjo(t){let{components:n,...e}=t;return(0,s.kt)(Ejo,(0,p.Z)({},Sjo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Gjo.isMDXComponent=!0;const Ojo={toc:[]},Fjo="wrapper";function Bjo(t){let{components:n,...e}=t;return(0,s.kt)(Fjo,(0,p.Z)({},Ojo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Bjo.isMDXComponent=!0;const Ujo={toc:[]},Vjo="wrapper";function qjo(t){let{components:n,...e}=t;return(0,s.kt)(Vjo,(0,p.Z)({},Ujo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}qjo.isMDXComponent=!0;const jjo={toc:[]},Yjo="wrapper";function Qjo(t){let{components:n,...e}=t;return(0,s.kt)(Yjo,(0,p.Z)({},jjo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Qjo.isMDXComponent=!0;const Hjo={toc:[]},$jo="wrapper";function Kjo(t){let{components:n,...e}=t;return(0,s.kt)($jo,(0,p.Z)({},Hjo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Kjo.isMDXComponent=!0;const Jjo={toc:[]},tYo="wrapper";function nYo(t){let{components:n,...e}=t;return(0,s.kt)(tYo,(0,p.Z)({},Jjo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}nYo.isMDXComponent=!0;const eYo={toc:[]},oYo="wrapper";function pYo(t){let{components:n,...e}=t;return(0,s.kt)(oYo,(0,p.Z)({},eYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}pYo.isMDXComponent=!0;const rYo={toc:[]},sYo="wrapper";function cYo(t){let{components:n,...e}=t;return(0,s.kt)(sYo,(0,p.Z)({},rYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}cYo.isMDXComponent=!0;const iYo={toc:[]},aYo="wrapper";function lYo(t){let{components:n,...e}=t;return(0,s.kt)(aYo,(0,p.Z)({},iYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}lYo.isMDXComponent=!0;const uYo={toc:[]},mYo="wrapper";function dYo(t){let{components:n,...e}=t;return(0,s.kt)(mYo,(0,p.Z)({},uYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}dYo.isMDXComponent=!0;const hYo={toc:[]},kYo="wrapper";function fYo(t){let{components:n,...e}=t;return(0,s.kt)(kYo,(0,p.Z)({},hYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}fYo.isMDXComponent=!0;const yYo={toc:[]},MYo="wrapper";function DYo(t){let{components:n,...e}=t;return(0,s.kt)(MYo,(0,p.Z)({},yYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}DYo.isMDXComponent=!0;const XYo={toc:[]},_Yo="wrapper";function wYo(t){let{components:n,...e}=t;return(0,s.kt)(_Yo,(0,p.Z)({},XYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}wYo.isMDXComponent=!0;const TYo={toc:[]},CYo="wrapper";function gYo(t){let{components:n,...e}=t;return(0,s.kt)(CYo,(0,p.Z)({},TYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}gYo.isMDXComponent=!0;const xYo={toc:[]},vYo="wrapper";function LYo(t){let{components:n,...e}=t;return(0,s.kt)(vYo,(0,p.Z)({},xYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}LYo.isMDXComponent=!0;const ZYo={toc:[]},bYo="wrapper";function NYo(t){let{components:n,...e}=t;return(0,s.kt)(bYo,(0,p.Z)({},ZYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}NYo.isMDXComponent=!0;const AYo={toc:[]},zYo="wrapper";function WYo(t){let{components:n,...e}=t;return(0,s.kt)(zYo,(0,p.Z)({},AYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}WYo.isMDXComponent=!0;const IYo={toc:[]},RYo="wrapper";function PYo(t){let{components:n,...e}=t;return(0,s.kt)(RYo,(0,p.Z)({},IYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}PYo.isMDXComponent=!0;const SYo={toc:[]},EYo="wrapper";function GYo(t){let{components:n,...e}=t;return(0,s.kt)(EYo,(0,p.Z)({},SYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}GYo.isMDXComponent=!0;const OYo={toc:[]},FYo="wrapper";function BYo(t){let{components:n,...e}=t;return(0,s.kt)(FYo,(0,p.Z)({},OYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}BYo.isMDXComponent=!0;const UYo={toc:[]},VYo="wrapper";function qYo(t){let{components:n,...e}=t;return(0,s.kt)(VYo,(0,p.Z)({},UYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}qYo.isMDXComponent=!0;const jYo={toc:[]},YYo="wrapper";function QYo(t){let{components:n,...e}=t;return(0,s.kt)(YYo,(0,p.Z)({},jYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}QYo.isMDXComponent=!0;const HYo={toc:[]},$Yo="wrapper";function KYo(t){let{components:n,...e}=t;return(0,s.kt)($Yo,(0,p.Z)({},HYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}KYo.isMDXComponent=!0;const JYo={toc:[]},tQo="wrapper";function nQo(t){let{components:n,...e}=t;return(0,s.kt)(tQo,(0,p.Z)({},JYo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nQo.isMDXComponent=!0;const eQo={toc:[]},oQo="wrapper";function pQo(t){let{components:n,...e}=t;return(0,s.kt)(oQo,(0,p.Z)({},eQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}pQo.isMDXComponent=!0;const rQo={toc:[]},sQo="wrapper";function cQo(t){let{components:n,...e}=t;return(0,s.kt)(sQo,(0,p.Z)({},rQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}cQo.isMDXComponent=!0;const iQo={toc:[]},aQo="wrapper";function lQo(t){let{components:n,...e}=t;return(0,s.kt)(aQo,(0,p.Z)({},iQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}lQo.isMDXComponent=!0;const uQo={toc:[]},mQo="wrapper";function dQo(t){let{components:n,...e}=t;return(0,s.kt)(mQo,(0,p.Z)({},uQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}dQo.isMDXComponent=!0;const hQo={toc:[]},kQo="wrapper";function fQo(t){let{components:n,...e}=t;return(0,s.kt)(kQo,(0,p.Z)({},hQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}fQo.isMDXComponent=!0;const yQo={toc:[]},MQo="wrapper";function DQo(t){let{components:n,...e}=t;return(0,s.kt)(MQo,(0,p.Z)({},yQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}DQo.isMDXComponent=!0;const XQo={toc:[]},_Qo="wrapper";function wQo(t){let{components:n,...e}=t;return(0,s.kt)(_Qo,(0,p.Z)({},XQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}wQo.isMDXComponent=!0;const TQo={toc:[]},CQo="wrapper";function gQo(t){let{components:n,...e}=t;return(0,s.kt)(CQo,(0,p.Z)({},TQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}gQo.isMDXComponent=!0;const xQo={toc:[]},vQo="wrapper";function LQo(t){let{components:n,...e}=t;return(0,s.kt)(vQo,(0,p.Z)({},xQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}LQo.isMDXComponent=!0;const ZQo={toc:[]},bQo="wrapper";function NQo(t){let{components:n,...e}=t;return(0,s.kt)(bQo,(0,p.Z)({},ZQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}NQo.isMDXComponent=!0;const AQo={toc:[]},zQo="wrapper";function WQo(t){let{components:n,...e}=t;return(0,s.kt)(zQo,(0,p.Z)({},AQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}WQo.isMDXComponent=!0;const IQo={toc:[]},RQo="wrapper";function PQo(t){let{components:n,...e}=t;return(0,s.kt)(RQo,(0,p.Z)({},IQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}PQo.isMDXComponent=!0;const SQo={toc:[]},EQo="wrapper";function GQo(t){let{components:n,...e}=t;return(0,s.kt)(EQo,(0,p.Z)({},SQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}GQo.isMDXComponent=!0;const OQo={toc:[]},FQo="wrapper";function BQo(t){let{components:n,...e}=t;return(0,s.kt)(FQo,(0,p.Z)({},OQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}BQo.isMDXComponent=!0;const UQo={toc:[]},VQo="wrapper";function qQo(t){let{components:n,...e}=t;return(0,s.kt)(VQo,(0,p.Z)({},UQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}qQo.isMDXComponent=!0;const jQo={toc:[]},YQo="wrapper";function QQo(t){let{components:n,...e}=t;return(0,s.kt)(YQo,(0,p.Z)({},jQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}QQo.isMDXComponent=!0;const HQo={toc:[]},$Qo="wrapper";function KQo(t){let{components:n,...e}=t;return(0,s.kt)($Qo,(0,p.Z)({},HQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}KQo.isMDXComponent=!0;const JQo={toc:[]},tHo="wrapper";function nHo(t){let{components:n,...e}=t;return(0,s.kt)(tHo,(0,p.Z)({},JQo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}nHo.isMDXComponent=!0;const eHo={toc:[]},oHo="wrapper";function pHo(t){let{components:n,...e}=t;return(0,s.kt)(oHo,(0,p.Z)({},eHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}pHo.isMDXComponent=!0;const rHo={toc:[]},sHo="wrapper";function cHo(t){let{components:n,...e}=t;return(0,s.kt)(sHo,(0,p.Z)({},rHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cHo.isMDXComponent=!0;const iHo={toc:[]},aHo="wrapper";function lHo(t){let{components:n,...e}=t;return(0,s.kt)(aHo,(0,p.Z)({},iHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}lHo.isMDXComponent=!0;const uHo={toc:[]},mHo="wrapper";function dHo(t){let{components:n,...e}=t;return(0,s.kt)(mHo,(0,p.Z)({},uHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}dHo.isMDXComponent=!0;const hHo={toc:[]},kHo="wrapper";function fHo(t){let{components:n,...e}=t;return(0,s.kt)(kHo,(0,p.Z)({},hHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}fHo.isMDXComponent=!0;const yHo={toc:[]},MHo="wrapper";function DHo(t){let{components:n,...e}=t;return(0,s.kt)(MHo,(0,p.Z)({},yHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}DHo.isMDXComponent=!0;const XHo={toc:[]},_Ho="wrapper";function wHo(t){let{components:n,...e}=t;return(0,s.kt)(_Ho,(0,p.Z)({},XHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}wHo.isMDXComponent=!0;const THo={toc:[]},CHo="wrapper";function gHo(t){let{components:n,...e}=t;return(0,s.kt)(CHo,(0,p.Z)({},THo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}gHo.isMDXComponent=!0;const xHo={toc:[]},vHo="wrapper";function LHo(t){let{components:n,...e}=t;return(0,s.kt)(vHo,(0,p.Z)({},xHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}LHo.isMDXComponent=!0;const ZHo={toc:[]},bHo="wrapper";function NHo(t){let{components:n,...e}=t;return(0,s.kt)(bHo,(0,p.Z)({},ZHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NHo.isMDXComponent=!0;const AHo={toc:[]},zHo="wrapper";function WHo(t){let{components:n,...e}=t;return(0,s.kt)(zHo,(0,p.Z)({},AHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}WHo.isMDXComponent=!0;const IHo={toc:[]},RHo="wrapper";function PHo(t){let{components:n,...e}=t;return(0,s.kt)(RHo,(0,p.Z)({},IHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}PHo.isMDXComponent=!0;const SHo={toc:[]},EHo="wrapper";function GHo(t){let{components:n,...e}=t;return(0,s.kt)(EHo,(0,p.Z)({},SHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}GHo.isMDXComponent=!0;const OHo={toc:[]},FHo="wrapper";function BHo(t){let{components:n,...e}=t;return(0,s.kt)(FHo,(0,p.Z)({},OHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}BHo.isMDXComponent=!0;const UHo={toc:[]},VHo="wrapper";function qHo(t){let{components:n,...e}=t;return(0,s.kt)(VHo,(0,p.Z)({},UHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}qHo.isMDXComponent=!0;const jHo={toc:[]},YHo="wrapper";function QHo(t){let{components:n,...e}=t;return(0,s.kt)(YHo,(0,p.Z)({},jHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}QHo.isMDXComponent=!0;const HHo={toc:[]},$Ho="wrapper";function KHo(t){let{components:n,...e}=t;return(0,s.kt)($Ho,(0,p.Z)({},HHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}KHo.isMDXComponent=!0;const JHo={toc:[]},t$o="wrapper";function n$o(t){let{components:n,...e}=t;return(0,s.kt)(t$o,(0,p.Z)({},JHo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}n$o.isMDXComponent=!0;const e$o={toc:[]},o$o="wrapper";function p$o(t){let{components:n,...e}=t;return(0,s.kt)(o$o,(0,p.Z)({},e$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find a node by its key."))}p$o.isMDXComponent=!0;const r$o={toc:[]},s$o="wrapper";function c$o(t){let{components:n,...e}=t;return(0,s.kt)(s$o,(0,p.Z)({},r$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The key of the node."))}c$o.isMDXComponent=!0;const i$o={toc:[]},a$o="wrapper";function l$o(t){let{components:n,...e}=t;return(0,s.kt)(a$o,(0,p.Z)({},i$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}l$o.isMDXComponent=!0;const u$o={toc:[]},m$o="wrapper";function d$o(t){let{components:n,...e}=t;return(0,s.kt)(m$o,(0,p.Z)({},u$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}d$o.isMDXComponent=!0;const h$o={toc:[]},k$o="wrapper";function f$o(t){let{components:n,...e}=t;return(0,s.kt)(k$o,(0,p.Z)({},h$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}f$o.isMDXComponent=!0;const y$o={toc:[]},M$o="wrapper";function D$o(t){let{components:n,...e}=t;return(0,s.kt)(M$o,(0,p.Z)({},y$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}D$o.isMDXComponent=!0;const X$o={toc:[]},_$o="wrapper";function w$o(t){let{components:n,...e}=t;return(0,s.kt)(_$o,(0,p.Z)({},X$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}w$o.isMDXComponent=!0;const T$o={toc:[]},C$o="wrapper";function g$o(t){let{components:n,...e}=t;return(0,s.kt)(C$o,(0,p.Z)({},T$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}g$o.isMDXComponent=!0;const x$o={toc:[]},v$o="wrapper";function L$o(t){let{components:n,...e}=t;return(0,s.kt)(v$o,(0,p.Z)({},x$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}L$o.isMDXComponent=!0;const Z$o={toc:[]},b$o="wrapper";function N$o(t){let{components:n,...e}=t;return(0,s.kt)(b$o,(0,p.Z)({},Z$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}N$o.isMDXComponent=!0;const A$o={toc:[]},z$o="wrapper";function W$o(t){let{components:n,...e}=t;return(0,s.kt)(z$o,(0,p.Z)({},A$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}W$o.isMDXComponent=!0;const I$o={toc:[]},R$o="wrapper";function P$o(t){let{components:n,...e}=t;return(0,s.kt)(R$o,(0,p.Z)({},I$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}P$o.isMDXComponent=!0;const S$o={toc:[]},E$o="wrapper";function G$o(t){let{components:n,...e}=t;return(0,s.kt)(E$o,(0,p.Z)({},S$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}G$o.isMDXComponent=!0;const O$o={toc:[]},F$o="wrapper";function B$o(t){let{components:n,...e}=t;return(0,s.kt)(F$o,(0,p.Z)({},O$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}B$o.isMDXComponent=!0;const U$o={toc:[]},V$o="wrapper";function q$o(t){let{components:n,...e}=t;return(0,s.kt)(V$o,(0,p.Z)({},U$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}q$o.isMDXComponent=!0;const j$o={toc:[]},Y$o="wrapper";function Q$o(t){let{components:n,...e}=t;return(0,s.kt)(Y$o,(0,p.Z)({},j$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Q$o.isMDXComponent=!0;const H$o={toc:[]},$$o="wrapper";function K$o(t){let{components:n,...e}=t;return(0,s.kt)($$o,(0,p.Z)({},H$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}K$o.isMDXComponent=!0;const J$o={toc:[]},tKo="wrapper";function nKo(t){let{components:n,...e}=t;return(0,s.kt)(tKo,(0,p.Z)({},J$o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}nKo.isMDXComponent=!0;const eKo={toc:[]},oKo="wrapper";function pKo(t){let{components:n,...e}=t;return(0,s.kt)(oKo,(0,p.Z)({},eKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}pKo.isMDXComponent=!0;const rKo={toc:[]},sKo="wrapper";function cKo(t){let{components:n,...e}=t;return(0,s.kt)(sKo,(0,p.Z)({},rKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}cKo.isMDXComponent=!0;const iKo={toc:[]},aKo="wrapper";function lKo(t){let{components:n,...e}=t;return(0,s.kt)(aKo,(0,p.Z)({},iKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}lKo.isMDXComponent=!0;const uKo={toc:[]},mKo="wrapper";function dKo(t){let{components:n,...e}=t;return(0,s.kt)(mKo,(0,p.Z)({},uKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}dKo.isMDXComponent=!0;const hKo={toc:[]},kKo="wrapper";function fKo(t){let{components:n,...e}=t;return(0,s.kt)(kKo,(0,p.Z)({},hKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}fKo.isMDXComponent=!0;const yKo={toc:[]},MKo="wrapper";function DKo(t){let{components:n,...e}=t;return(0,s.kt)(MKo,(0,p.Z)({},yKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}DKo.isMDXComponent=!0;const XKo={toc:[]},_Ko="wrapper";function wKo(t){let{components:n,...e}=t;return(0,s.kt)(_Ko,(0,p.Z)({},XKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wKo.isMDXComponent=!0;const TKo={toc:[]},CKo="wrapper";function gKo(t){let{components:n,...e}=t;return(0,s.kt)(CKo,(0,p.Z)({},TKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}gKo.isMDXComponent=!0;const xKo={toc:[]},vKo="wrapper";function LKo(t){let{components:n,...e}=t;return(0,s.kt)(vKo,(0,p.Z)({},xKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}LKo.isMDXComponent=!0;const ZKo={toc:[]},bKo="wrapper";function NKo(t){let{components:n,...e}=t;return(0,s.kt)(bKo,(0,p.Z)({},ZKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}NKo.isMDXComponent=!0;const AKo={toc:[]},zKo="wrapper";function WKo(t){let{components:n,...e}=t;return(0,s.kt)(zKo,(0,p.Z)({},AKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}WKo.isMDXComponent=!0;const IKo={toc:[]},RKo="wrapper";function PKo(t){let{components:n,...e}=t;return(0,s.kt)(RKo,(0,p.Z)({},IKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}PKo.isMDXComponent=!0;const SKo={toc:[]},EKo="wrapper";function GKo(t){let{components:n,...e}=t;return(0,s.kt)(EKo,(0,p.Z)({},SKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}GKo.isMDXComponent=!0;const OKo={toc:[]},FKo="wrapper";function BKo(t){let{components:n,...e}=t;return(0,s.kt)(FKo,(0,p.Z)({},OKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}BKo.isMDXComponent=!0;const UKo={toc:[]},VKo="wrapper";function qKo(t){let{components:n,...e}=t;return(0,s.kt)(VKo,(0,p.Z)({},UKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}qKo.isMDXComponent=!0;const jKo={toc:[]},YKo="wrapper";function QKo(t){let{components:n,...e}=t;return(0,s.kt)(YKo,(0,p.Z)({},jKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}QKo.isMDXComponent=!0;const HKo={toc:[]},$Ko="wrapper";function KKo(t){let{components:n,...e}=t;return(0,s.kt)($Ko,(0,p.Z)({},HKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}KKo.isMDXComponent=!0;const JKo={toc:[]},tJo="wrapper";function nJo(t){let{components:n,...e}=t;return(0,s.kt)(tJo,(0,p.Z)({},JKo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}nJo.isMDXComponent=!0;const eJo={toc:[]},oJo="wrapper";function pJo(t){let{components:n,...e}=t;return(0,s.kt)(oJo,(0,p.Z)({},eJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}pJo.isMDXComponent=!0;const rJo={toc:[]},sJo="wrapper";function cJo(t){let{components:n,...e}=t;return(0,s.kt)(sJo,(0,p.Z)({},rJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}cJo.isMDXComponent=!0;const iJo={toc:[]},aJo="wrapper";function lJo(t){let{components:n,...e}=t;return(0,s.kt)(aJo,(0,p.Z)({},iJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lJo.isMDXComponent=!0;const uJo={toc:[]},mJo="wrapper";function dJo(t){let{components:n,...e}=t;return(0,s.kt)(mJo,(0,p.Z)({},uJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}dJo.isMDXComponent=!0;const hJo={toc:[]},kJo="wrapper";function fJo(t){let{components:n,...e}=t;return(0,s.kt)(kJo,(0,p.Z)({},hJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}fJo.isMDXComponent=!0;const yJo={toc:[]},MJo="wrapper";function DJo(t){let{components:n,...e}=t;return(0,s.kt)(MJo,(0,p.Z)({},yJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}DJo.isMDXComponent=!0;const XJo={toc:[]},_Jo="wrapper";function wJo(t){let{components:n,...e}=t;return(0,s.kt)(_Jo,(0,p.Z)({},XJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}wJo.isMDXComponent=!0;const TJo={toc:[]},CJo="wrapper";function gJo(t){let{components:n,...e}=t;return(0,s.kt)(CJo,(0,p.Z)({},TJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}gJo.isMDXComponent=!0;const xJo={toc:[]},vJo="wrapper";function LJo(t){let{components:n,...e}=t;return(0,s.kt)(vJo,(0,p.Z)({},xJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}LJo.isMDXComponent=!0;const ZJo={toc:[]},bJo="wrapper";function NJo(t){let{components:n,...e}=t;return(0,s.kt)(bJo,(0,p.Z)({},ZJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}NJo.isMDXComponent=!0;const AJo={toc:[]},zJo="wrapper";function WJo(t){let{components:n,...e}=t;return(0,s.kt)(zJo,(0,p.Z)({},AJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}WJo.isMDXComponent=!0;const IJo={toc:[]},RJo="wrapper";function PJo(t){let{components:n,...e}=t;return(0,s.kt)(RJo,(0,p.Z)({},IJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}PJo.isMDXComponent=!0;const SJo={toc:[]},EJo="wrapper";function GJo(t){let{components:n,...e}=t;return(0,s.kt)(EJo,(0,p.Z)({},SJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}GJo.isMDXComponent=!0;const OJo={toc:[]},FJo="wrapper";function BJo(t){let{components:n,...e}=t;return(0,s.kt)(FJo,(0,p.Z)({},OJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}BJo.isMDXComponent=!0;const UJo={toc:[]},VJo="wrapper";function qJo(t){let{components:n,...e}=t;return(0,s.kt)(VJo,(0,p.Z)({},UJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}qJo.isMDXComponent=!0;const jJo={toc:[]},YJo="wrapper";function QJo(t){let{components:n,...e}=t;return(0,s.kt)(YJo,(0,p.Z)({},jJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}QJo.isMDXComponent=!0;const HJo={toc:[]},$Jo="wrapper";function KJo(t){let{components:n,...e}=t;return(0,s.kt)($Jo,(0,p.Z)({},HJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}KJo.isMDXComponent=!0;const JJo={toc:[]},t0o="wrapper";function n0o(t){let{components:n,...e}=t;return(0,s.kt)(t0o,(0,p.Z)({},JJo,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}n0o.isMDXComponent=!0;const e0o={toc:[]},o0o="wrapper";function p0o(t){let{components:n,...e}=t;return(0,s.kt)(o0o,(0,p.Z)({},e0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}p0o.isMDXComponent=!0;const r0o={toc:[]},s0o="wrapper";function c0o(t){let{components:n,...e}=t;return(0,s.kt)(s0o,(0,p.Z)({},r0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}c0o.isMDXComponent=!0;const i0o={toc:[]},a0o="wrapper";function l0o(t){let{components:n,...e}=t;return(0,s.kt)(a0o,(0,p.Z)({},i0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}l0o.isMDXComponent=!0;const u0o={toc:[]},m0o="wrapper";function d0o(t){let{components:n,...e}=t;return(0,s.kt)(m0o,(0,p.Z)({},u0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}d0o.isMDXComponent=!0;const h0o={toc:[]},k0o="wrapper";function f0o(t){let{components:n,...e}=t;return(0,s.kt)(k0o,(0,p.Z)({},h0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}f0o.isMDXComponent=!0;const y0o={toc:[]},M0o="wrapper";function D0o(t){let{components:n,...e}=t;return(0,s.kt)(M0o,(0,p.Z)({},y0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}D0o.isMDXComponent=!0;const X0o={toc:[]},_0o="wrapper";function w0o(t){let{components:n,...e}=t;return(0,s.kt)(_0o,(0,p.Z)({},X0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}w0o.isMDXComponent=!0;const T0o={toc:[]},C0o="wrapper";function g0o(t){let{components:n,...e}=t;return(0,s.kt)(C0o,(0,p.Z)({},T0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}g0o.isMDXComponent=!0;const x0o={toc:[]},v0o="wrapper";function L0o(t){let{components:n,...e}=t;return(0,s.kt)(v0o,(0,p.Z)({},x0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}L0o.isMDXComponent=!0;const Z0o={toc:[]},b0o="wrapper";function N0o(t){let{components:n,...e}=t;return(0,s.kt)(b0o,(0,p.Z)({},Z0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}N0o.isMDXComponent=!0;const A0o={toc:[]},z0o="wrapper";function W0o(t){let{components:n,...e}=t;return(0,s.kt)(z0o,(0,p.Z)({},A0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}W0o.isMDXComponent=!0;const I0o={toc:[]},R0o="wrapper";function P0o(t){let{components:n,...e}=t;return(0,s.kt)(R0o,(0,p.Z)({},I0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}P0o.isMDXComponent=!0;const S0o={toc:[]},E0o="wrapper";function G0o(t){let{components:n,...e}=t;return(0,s.kt)(E0o,(0,p.Z)({},S0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}G0o.isMDXComponent=!0;const O0o={toc:[]},F0o="wrapper";function B0o(t){let{components:n,...e}=t;return(0,s.kt)(F0o,(0,p.Z)({},O0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}B0o.isMDXComponent=!0;const U0o={toc:[]},V0o="wrapper";function q0o(t){let{components:n,...e}=t;return(0,s.kt)(V0o,(0,p.Z)({},U0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}q0o.isMDXComponent=!0;const j0o={toc:[]},Y0o="wrapper";function Q0o(t){let{components:n,...e}=t;return(0,s.kt)(Y0o,(0,p.Z)({},j0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Q0o.isMDXComponent=!0;const H0o={toc:[]},$0o="wrapper";function K0o(t){let{components:n,...e}=t;return(0,s.kt)($0o,(0,p.Z)({},H0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}K0o.isMDXComponent=!0;const J0o={toc:[]},t2o="wrapper";function n2o(t){let{components:n,...e}=t;return(0,s.kt)(t2o,(0,p.Z)({},J0o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}n2o.isMDXComponent=!0;const e2o={toc:[]},o2o="wrapper";function p2o(t){let{components:n,...e}=t;return(0,s.kt)(o2o,(0,p.Z)({},e2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}p2o.isMDXComponent=!0;const r2o={toc:[]},s2o="wrapper";function c2o(t){let{components:n,...e}=t;return(0,s.kt)(s2o,(0,p.Z)({},r2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}c2o.isMDXComponent=!0;const i2o={toc:[]},a2o="wrapper";function l2o(t){let{components:n,...e}=t;return(0,s.kt)(a2o,(0,p.Z)({},i2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}l2o.isMDXComponent=!0;const u2o={toc:[]},m2o="wrapper";function d2o(t){let{components:n,...e}=t;return(0,s.kt)(m2o,(0,p.Z)({},u2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}d2o.isMDXComponent=!0;const h2o={toc:[]},k2o="wrapper";function f2o(t){let{components:n,...e}=t;return(0,s.kt)(k2o,(0,p.Z)({},h2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}f2o.isMDXComponent=!0;const y2o={toc:[]},M2o="wrapper";function D2o(t){let{components:n,...e}=t;return(0,s.kt)(M2o,(0,p.Z)({},y2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}D2o.isMDXComponent=!0;const X2o={toc:[]},_2o="wrapper";function w2o(t){let{components:n,...e}=t;return(0,s.kt)(_2o,(0,p.Z)({},X2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}w2o.isMDXComponent=!0;const T2o={toc:[]},C2o="wrapper";function g2o(t){let{components:n,...e}=t;return(0,s.kt)(C2o,(0,p.Z)({},T2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}g2o.isMDXComponent=!0;const x2o={toc:[]},v2o="wrapper";function L2o(t){let{components:n,...e}=t;return(0,s.kt)(v2o,(0,p.Z)({},x2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}L2o.isMDXComponent=!0;const Z2o={toc:[]},b2o="wrapper";function N2o(t){let{components:n,...e}=t;return(0,s.kt)(b2o,(0,p.Z)({},Z2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}N2o.isMDXComponent=!0;const A2o={toc:[]},z2o="wrapper";function W2o(t){let{components:n,...e}=t;return(0,s.kt)(z2o,(0,p.Z)({},A2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}W2o.isMDXComponent=!0;const I2o={toc:[]},R2o="wrapper";function P2o(t){let{components:n,...e}=t;return(0,s.kt)(R2o,(0,p.Z)({},I2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}P2o.isMDXComponent=!0;const S2o={toc:[]},E2o="wrapper";function G2o(t){let{components:n,...e}=t;return(0,s.kt)(E2o,(0,p.Z)({},S2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}G2o.isMDXComponent=!0;const O2o={toc:[]},F2o="wrapper";function B2o(t){let{components:n,...e}=t;return(0,s.kt)(F2o,(0,p.Z)({},O2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}B2o.isMDXComponent=!0;const U2o={toc:[]},V2o="wrapper";function q2o(t){let{components:n,...e}=t;return(0,s.kt)(V2o,(0,p.Z)({},U2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}q2o.isMDXComponent=!0;const j2o={toc:[]},Y2o="wrapper";function Q2o(t){let{components:n,...e}=t;return(0,s.kt)(Y2o,(0,p.Z)({},j2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Q2o.isMDXComponent=!0;const H2o={toc:[]},$2o="wrapper";function K2o(t){let{components:n,...e}=t;return(0,s.kt)($2o,(0,p.Z)({},H2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}K2o.isMDXComponent=!0;const J2o={toc:[]},t6o="wrapper";function n6o(t){let{components:n,...e}=t;return(0,s.kt)(t6o,(0,p.Z)({},J2o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}n6o.isMDXComponent=!0;const e6o={toc:[]},o6o="wrapper";function p6o(t){let{components:n,...e}=t;return(0,s.kt)(o6o,(0,p.Z)({},e6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}p6o.isMDXComponent=!0;const r6o={toc:[]},s6o="wrapper";function c6o(t){let{components:n,...e}=t;return(0,s.kt)(s6o,(0,p.Z)({},r6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}c6o.isMDXComponent=!0;const i6o={toc:[]},a6o="wrapper";function l6o(t){let{components:n,...e}=t;return(0,s.kt)(a6o,(0,p.Z)({},i6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}l6o.isMDXComponent=!0;const u6o={toc:[]},m6o="wrapper";function d6o(t){let{components:n,...e}=t;return(0,s.kt)(m6o,(0,p.Z)({},u6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}d6o.isMDXComponent=!0;const h6o={toc:[]},k6o="wrapper";function f6o(t){let{components:n,...e}=t;return(0,s.kt)(k6o,(0,p.Z)({},h6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}f6o.isMDXComponent=!0;const y6o={toc:[]},M6o="wrapper";function D6o(t){let{components:n,...e}=t;return(0,s.kt)(M6o,(0,p.Z)({},y6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}D6o.isMDXComponent=!0;const X6o={toc:[]},_6o="wrapper";function w6o(t){let{components:n,...e}=t;return(0,s.kt)(_6o,(0,p.Z)({},X6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}w6o.isMDXComponent=!0;const T6o={toc:[]},C6o="wrapper";function g6o(t){let{components:n,...e}=t;return(0,s.kt)(C6o,(0,p.Z)({},T6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}g6o.isMDXComponent=!0;const x6o={toc:[]},v6o="wrapper";function L6o(t){let{components:n,...e}=t;return(0,s.kt)(v6o,(0,p.Z)({},x6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}L6o.isMDXComponent=!0;const Z6o={toc:[]},b6o="wrapper";function N6o(t){let{components:n,...e}=t;return(0,s.kt)(b6o,(0,p.Z)({},Z6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}N6o.isMDXComponent=!0;const A6o={toc:[]},z6o="wrapper";function W6o(t){let{components:n,...e}=t;return(0,s.kt)(z6o,(0,p.Z)({},A6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}W6o.isMDXComponent=!0;const I6o={toc:[]},R6o="wrapper";function P6o(t){let{components:n,...e}=t;return(0,s.kt)(R6o,(0,p.Z)({},I6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}P6o.isMDXComponent=!0;const S6o={toc:[]},E6o="wrapper";function G6o(t){let{components:n,...e}=t;return(0,s.kt)(E6o,(0,p.Z)({},S6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}G6o.isMDXComponent=!0;const O6o={toc:[]},F6o="wrapper";function B6o(t){let{components:n,...e}=t;return(0,s.kt)(F6o,(0,p.Z)({},O6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}B6o.isMDXComponent=!0;const U6o={toc:[]},V6o="wrapper";function q6o(t){let{components:n,...e}=t;return(0,s.kt)(V6o,(0,p.Z)({},U6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}q6o.isMDXComponent=!0;const j6o={toc:[]},Y6o="wrapper";function Q6o(t){let{components:n,...e}=t;return(0,s.kt)(Y6o,(0,p.Z)({},j6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Q6o.isMDXComponent=!0;const H6o={toc:[]},$6o="wrapper";function K6o(t){let{components:n,...e}=t;return(0,s.kt)($6o,(0,p.Z)({},H6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}K6o.isMDXComponent=!0;const J6o={toc:[]},t3o="wrapper";function n3o(t){let{components:n,...e}=t;return(0,s.kt)(t3o,(0,p.Z)({},J6o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}n3o.isMDXComponent=!0;const e3o={toc:[]},o3o="wrapper";function p3o(t){let{components:n,...e}=t;return(0,s.kt)(o3o,(0,p.Z)({},e3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p3o.isMDXComponent=!0;const r3o={toc:[]},s3o="wrapper";function c3o(t){let{components:n,...e}=t;return(0,s.kt)(s3o,(0,p.Z)({},r3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}c3o.isMDXComponent=!0;const i3o={toc:[]},a3o="wrapper";function l3o(t){let{components:n,...e}=t;return(0,s.kt)(a3o,(0,p.Z)({},i3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}l3o.isMDXComponent=!0;const u3o={toc:[]},m3o="wrapper";function d3o(t){let{components:n,...e}=t;return(0,s.kt)(m3o,(0,p.Z)({},u3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}d3o.isMDXComponent=!0;const h3o={toc:[]},k3o="wrapper";function f3o(t){let{components:n,...e}=t;return(0,s.kt)(k3o,(0,p.Z)({},h3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}f3o.isMDXComponent=!0;const y3o={toc:[]},M3o="wrapper";function D3o(t){let{components:n,...e}=t;return(0,s.kt)(M3o,(0,p.Z)({},y3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}D3o.isMDXComponent=!0;const X3o={toc:[]},_3o="wrapper";function w3o(t){let{components:n,...e}=t;return(0,s.kt)(_3o,(0,p.Z)({},X3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the circle begins at ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}w3o.isMDXComponent=!0;const T3o={toc:[]},C3o="wrapper";function g3o(t){let{components:n,...e}=t;return(0,s.kt)(C3o,(0,p.Z)({},T3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the circle sector should be drawn counterclockwise."))}g3o.isMDXComponent=!0;const x3o={toc:[]},v3o="wrapper";function L3o(t){let{components:n,...e}=t;return(0,s.kt)(v3o,(0,p.Z)({},x3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}L3o.isMDXComponent=!0;const Z3o={toc:[]},b3o="wrapper";function N3o(t){let{components:n,...e}=t;return(0,s.kt)(b3o,(0,p.Z)({},Z3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}N3o.isMDXComponent=!0;const A3o={toc:[]},z3o="wrapper";function W3o(t){let{components:n,...e}=t;return(0,s.kt)(z3o,(0,p.Z)({},A3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}W3o.isMDXComponent=!0;const I3o={toc:[]},R3o="wrapper";function P3o(t){let{components:n,...e}=t;return(0,s.kt)(R3o,(0,p.Z)({},I3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}P3o.isMDXComponent=!0;const S3o={toc:[]},E3o="wrapper";function G3o(t){let{components:n,...e}=t;return(0,s.kt)(E3o,(0,p.Z)({},S3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}G3o.isMDXComponent=!0;const O3o={toc:[]},F3o="wrapper";function B3o(t){let{components:n,...e}=t;return(0,s.kt)(F3o,(0,p.Z)({},O3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}B3o.isMDXComponent=!0;const U3o={toc:[]},V3o="wrapper";function q3o(t){let{components:n,...e}=t;return(0,s.kt)(V3o,(0,p.Z)({},U3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}q3o.isMDXComponent=!0;const j3o={toc:[]},Y3o="wrapper";function Q3o(t){let{components:n,...e}=t;return(0,s.kt)(Y3o,(0,p.Z)({},j3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Q3o.isMDXComponent=!0;const H3o={toc:[]},$3o="wrapper";function K3o(t){let{components:n,...e}=t;return(0,s.kt)($3o,(0,p.Z)({},H3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}K3o.isMDXComponent=!0;const J3o={toc:[]},t5o="wrapper";function n5o(t){let{components:n,...e}=t;return(0,s.kt)(t5o,(0,p.Z)({},J3o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}n5o.isMDXComponent=!0;const e5o={toc:[]},o5o="wrapper";function p5o(t){let{components:n,...e}=t;return(0,s.kt)(o5o,(0,p.Z)({},e5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}p5o.isMDXComponent=!0;const r5o={toc:[]},s5o="wrapper";function c5o(t){let{components:n,...e}=t;return(0,s.kt)(s5o,(0,p.Z)({},r5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}c5o.isMDXComponent=!0;const i5o={toc:[]},a5o="wrapper";function l5o(t){let{components:n,...e}=t;return(0,s.kt)(a5o,(0,p.Z)({},i5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}l5o.isMDXComponent=!0;const u5o={toc:[]},m5o="wrapper";function d5o(t){let{components:n,...e}=t;return(0,s.kt)(m5o,(0,p.Z)({},u5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}d5o.isMDXComponent=!0;const h5o={toc:[]},k5o="wrapper";function f5o(t){let{components:n,...e}=t;return(0,s.kt)(k5o,(0,p.Z)({},h5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}f5o.isMDXComponent=!0;const y5o={toc:[]},M5o="wrapper";function D5o(t){let{components:n,...e}=t;return(0,s.kt)(M5o,(0,p.Z)({},y5o,e,{components:n,mdxType:"MDXLayout"}))}D5o.isMDXComponent=!0;const X5o={toc:[]},_5o="wrapper";function w5o(t){let{components:n,...e}=t;return(0,s.kt)(_5o,(0,p.Z)({},X5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}w5o.isMDXComponent=!0;const T5o={toc:[]},C5o="wrapper";function g5o(t){let{components:n,...e}=t;return(0,s.kt)(C5o,(0,p.Z)({},T5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}g5o.isMDXComponent=!0;const x5o={toc:[]},v5o="wrapper";function L5o(t){let{components:n,...e}=t;return(0,s.kt)(v5o,(0,p.Z)({},x5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}L5o.isMDXComponent=!0;const Z5o={toc:[]},b5o="wrapper";function N5o(t){let{components:n,...e}=t;return(0,s.kt)(b5o,(0,p.Z)({},Z5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}N5o.isMDXComponent=!0;const A5o={toc:[]},z5o="wrapper";function W5o(t){let{components:n,...e}=t;return(0,s.kt)(z5o,(0,p.Z)({},A5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}W5o.isMDXComponent=!0;const I5o={toc:[]},R5o="wrapper";function P5o(t){let{components:n,...e}=t;return(0,s.kt)(R5o,(0,p.Z)({},I5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}P5o.isMDXComponent=!0;const S5o={toc:[]},E5o="wrapper";function G5o(t){let{components:n,...e}=t;return(0,s.kt)(E5o,(0,p.Z)({},S5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}G5o.isMDXComponent=!0;const O5o={toc:[]},F5o="wrapper";function B5o(t){let{components:n,...e}=t;return(0,s.kt)(F5o,(0,p.Z)({},O5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}B5o.isMDXComponent=!0;const U5o={toc:[]},V5o="wrapper";function q5o(t){let{components:n,...e}=t;return(0,s.kt)(V5o,(0,p.Z)({},U5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}q5o.isMDXComponent=!0;const j5o={toc:[]},Y5o="wrapper";function Q5o(t){let{components:n,...e}=t;return(0,s.kt)(Y5o,(0,p.Z)({},j5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Q5o.isMDXComponent=!0;const H5o={toc:[]},$5o="wrapper";function K5o(t){let{components:n,...e}=t;return(0,s.kt)($5o,(0,p.Z)({},H5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}K5o.isMDXComponent=!0;const J5o={toc:[]},t1o="wrapper";function n1o(t){let{components:n,...e}=t;return(0,s.kt)(t1o,(0,p.Z)({},J5o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}n1o.isMDXComponent=!0;const e1o={toc:[]},o1o="wrapper";function p1o(t){let{components:n,...e}=t;return(0,s.kt)(o1o,(0,p.Z)({},e1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p1o.isMDXComponent=!0;const r1o={toc:[]},s1o="wrapper";function c1o(t){let{components:n,...e}=t;return(0,s.kt)(s1o,(0,p.Z)({},r1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}c1o.isMDXComponent=!0;const i1o={toc:[]},a1o="wrapper";function l1o(t){let{components:n,...e}=t;return(0,s.kt)(a1o,(0,p.Z)({},i1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}l1o.isMDXComponent=!0;const u1o={toc:[]},m1o="wrapper";function d1o(t){let{components:n,...e}=t;return(0,s.kt)(m1o,(0,p.Z)({},u1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}d1o.isMDXComponent=!0;const h1o={toc:[]},k1o="wrapper";function f1o(t){let{components:n,...e}=t;return(0,s.kt)(k1o,(0,p.Z)({},h1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}f1o.isMDXComponent=!0;const y1o={toc:[]},M1o="wrapper";function D1o(t){let{components:n,...e}=t;return(0,s.kt)(M1o,(0,p.Z)({},y1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}D1o.isMDXComponent=!0;const X1o={toc:[]},_1o="wrapper";function w1o(t){let{components:n,...e}=t;return(0,s.kt)(_1o,(0,p.Z)({},X1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w1o.isMDXComponent=!0;const T1o={toc:[]},C1o="wrapper";function g1o(t){let{components:n,...e}=t;return(0,s.kt)(C1o,(0,p.Z)({},T1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}g1o.isMDXComponent=!0;const x1o={toc:[]},v1o="wrapper";function L1o(t){let{components:n,...e}=t;return(0,s.kt)(v1o,(0,p.Z)({},x1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}L1o.isMDXComponent=!0;const Z1o={toc:[]},b1o="wrapper";function N1o(t){let{components:n,...e}=t;return(0,s.kt)(b1o,(0,p.Z)({},Z1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}N1o.isMDXComponent=!0;const A1o={toc:[]},z1o="wrapper";function W1o(t){let{components:n,...e}=t;return(0,s.kt)(z1o,(0,p.Z)({},A1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}W1o.isMDXComponent=!0;const I1o={toc:[]},R1o="wrapper";function P1o(t){let{components:n,...e}=t;return(0,s.kt)(R1o,(0,p.Z)({},I1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}P1o.isMDXComponent=!0;const S1o={toc:[]},E1o="wrapper";function G1o(t){let{components:n,...e}=t;return(0,s.kt)(E1o,(0,p.Z)({},S1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}G1o.isMDXComponent=!0;const O1o={toc:[]},F1o="wrapper";function B1o(t){let{components:n,...e}=t;return(0,s.kt)(F1o,(0,p.Z)({},O1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}B1o.isMDXComponent=!0;const U1o={toc:[]},V1o="wrapper";function q1o(t){let{components:n,...e}=t;return(0,s.kt)(V1o,(0,p.Z)({},U1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}q1o.isMDXComponent=!0;const j1o={toc:[]},Y1o="wrapper";function Q1o(t){let{components:n,...e}=t;return(0,s.kt)(Y1o,(0,p.Z)({},j1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Q1o.isMDXComponent=!0;const H1o={toc:[]},$1o="wrapper";function K1o(t){let{components:n,...e}=t;return(0,s.kt)($1o,(0,p.Z)({},H1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}K1o.isMDXComponent=!0;const J1o={toc:[]},t4o="wrapper";function n4o(t){let{components:n,...e}=t;return(0,s.kt)(t4o,(0,p.Z)({},J1o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}n4o.isMDXComponent=!0;const e4o={toc:[]},o4o="wrapper";function p4o(t){let{components:n,...e}=t;return(0,s.kt)(o4o,(0,p.Z)({},e4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p4o.isMDXComponent=!0;const r4o={toc:[]},s4o="wrapper";function c4o(t){let{components:n,...e}=t;return(0,s.kt)(s4o,(0,p.Z)({},r4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}c4o.isMDXComponent=!0;const i4o={toc:[]},a4o="wrapper";function l4o(t){let{components:n,...e}=t;return(0,s.kt)(a4o,(0,p.Z)({},i4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}l4o.isMDXComponent=!0;const u4o={toc:[]},m4o="wrapper";function d4o(t){let{components:n,...e}=t;return(0,s.kt)(m4o,(0,p.Z)({},u4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}d4o.isMDXComponent=!0;const h4o={toc:[]},k4o="wrapper";function f4o(t){let{components:n,...e}=t;return(0,s.kt)(k4o,(0,p.Z)({},h4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}f4o.isMDXComponent=!0;const y4o={toc:[]},M4o="wrapper";function D4o(t){let{components:n,...e}=t;return(0,s.kt)(M4o,(0,p.Z)({},y4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}D4o.isMDXComponent=!0;const X4o={toc:[]},_4o="wrapper";function w4o(t){let{components:n,...e}=t;return(0,s.kt)(_4o,(0,p.Z)({},X4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}w4o.isMDXComponent=!0;const T4o={toc:[]},C4o="wrapper";function g4o(t){let{components:n,...e}=t;return(0,s.kt)(C4o,(0,p.Z)({},T4o,e,{components:n,mdxType:"MDXLayout"}))}g4o.isMDXComponent=!0;const x4o={toc:[]},v4o="wrapper";function L4o(t){let{components:n,...e}=t;return(0,s.kt)(v4o,(0,p.Z)({},x4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}L4o.isMDXComponent=!0;const Z4o={toc:[]},b4o="wrapper";function N4o(t){let{components:n,...e}=t;return(0,s.kt)(b4o,(0,p.Z)({},Z4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}N4o.isMDXComponent=!0;const A4o={toc:[]},z4o="wrapper";function W4o(t){let{components:n,...e}=t;return(0,s.kt)(z4o,(0,p.Z)({},A4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}W4o.isMDXComponent=!0;const I4o={toc:[]},R4o="wrapper";function P4o(t){let{components:n,...e}=t;return(0,s.kt)(R4o,(0,p.Z)({},I4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}P4o.isMDXComponent=!0;const S4o={toc:[]},E4o="wrapper";function G4o(t){let{components:n,...e}=t;return(0,s.kt)(E4o,(0,p.Z)({},S4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}G4o.isMDXComponent=!0;const O4o={toc:[]},F4o="wrapper";function B4o(t){let{components:n,...e}=t;return(0,s.kt)(F4o,(0,p.Z)({},O4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}B4o.isMDXComponent=!0;const U4o={toc:[]},V4o="wrapper";function q4o(t){let{components:n,...e}=t;return(0,s.kt)(V4o,(0,p.Z)({},U4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}q4o.isMDXComponent=!0;const j4o={toc:[]},Y4o="wrapper";function Q4o(t){let{components:n,...e}=t;return(0,s.kt)(Y4o,(0,p.Z)({},j4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Q4o.isMDXComponent=!0;const H4o={toc:[]},$4o="wrapper";function K4o(t){let{components:n,...e}=t;return(0,s.kt)($4o,(0,p.Z)({},H4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}K4o.isMDXComponent=!0;const J4o={toc:[]},t8o="wrapper";function n8o(t){let{components:n,...e}=t;return(0,s.kt)(t8o,(0,p.Z)({},J4o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}n8o.isMDXComponent=!0;const e8o={toc:[]},o8o="wrapper";function p8o(t){let{components:n,...e}=t;return(0,s.kt)(o8o,(0,p.Z)({},e8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p8o.isMDXComponent=!0;const r8o={toc:[]},s8o="wrapper";function c8o(t){let{components:n,...e}=t;return(0,s.kt)(s8o,(0,p.Z)({},r8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}c8o.isMDXComponent=!0;const i8o={toc:[]},a8o="wrapper";function l8o(t){let{components:n,...e}=t;return(0,s.kt)(a8o,(0,p.Z)({},i8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}l8o.isMDXComponent=!0;const u8o={toc:[]},m8o="wrapper";function d8o(t){let{components:n,...e}=t;return(0,s.kt)(m8o,(0,p.Z)({},u8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}d8o.isMDXComponent=!0;const h8o={toc:[]},k8o="wrapper";function f8o(t){let{components:n,...e}=t;return(0,s.kt)(k8o,(0,p.Z)({},h8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}f8o.isMDXComponent=!0;const y8o={toc:[]},M8o="wrapper";function D8o(t){let{components:n,...e}=t;return(0,s.kt)(M8o,(0,p.Z)({},y8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}D8o.isMDXComponent=!0;const X8o={toc:[]},_8o="wrapper";function w8o(t){let{components:n,...e}=t;return(0,s.kt)(_8o,(0,p.Z)({},X8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w8o.isMDXComponent=!0;const T8o={toc:[]},C8o="wrapper";function g8o(t){let{components:n,...e}=t;return(0,s.kt)(C8o,(0,p.Z)({},T8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}g8o.isMDXComponent=!0;const x8o={toc:[]},v8o="wrapper";function L8o(t){let{components:n,...e}=t;return(0,s.kt)(v8o,(0,p.Z)({},x8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}L8o.isMDXComponent=!0;const Z8o={toc:[]},b8o="wrapper";function N8o(t){let{components:n,...e}=t;return(0,s.kt)(b8o,(0,p.Z)({},Z8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}N8o.isMDXComponent=!0;const A8o={toc:[]},z8o="wrapper";function W8o(t){let{components:n,...e}=t;return(0,s.kt)(z8o,(0,p.Z)({},A8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}W8o.isMDXComponent=!0;const I8o={toc:[]},R8o="wrapper";function P8o(t){let{components:n,...e}=t;return(0,s.kt)(R8o,(0,p.Z)({},I8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}P8o.isMDXComponent=!0;const S8o={toc:[]},E8o="wrapper";function G8o(t){let{components:n,...e}=t;return(0,s.kt)(E8o,(0,p.Z)({},S8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}G8o.isMDXComponent=!0;const O8o={toc:[]},F8o="wrapper";function B8o(t){let{components:n,...e}=t;return(0,s.kt)(F8o,(0,p.Z)({},O8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}B8o.isMDXComponent=!0;const U8o={toc:[]},V8o="wrapper";function q8o(t){let{components:n,...e}=t;return(0,s.kt)(V8o,(0,p.Z)({},U8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}q8o.isMDXComponent=!0;const j8o={toc:[]},Y8o="wrapper";function Q8o(t){let{components:n,...e}=t;return(0,s.kt)(Y8o,(0,p.Z)({},j8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Q8o.isMDXComponent=!0;const H8o={toc:[]},$8o="wrapper";function K8o(t){let{components:n,...e}=t;return(0,s.kt)($8o,(0,p.Z)({},H8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}K8o.isMDXComponent=!0;const J8o={toc:[]},t7o="wrapper";function n7o(t){let{components:n,...e}=t;return(0,s.kt)(t7o,(0,p.Z)({},J8o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}n7o.isMDXComponent=!0;const e7o={toc:[]},o7o="wrapper";function p7o(t){let{components:n,...e}=t;return(0,s.kt)(o7o,(0,p.Z)({},e7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p7o.isMDXComponent=!0;const r7o={toc:[]},s7o="wrapper";function c7o(t){let{components:n,...e}=t;return(0,s.kt)(s7o,(0,p.Z)({},r7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}c7o.isMDXComponent=!0;const i7o={toc:[]},a7o="wrapper";function l7o(t){let{components:n,...e}=t;return(0,s.kt)(a7o,(0,p.Z)({},i7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}l7o.isMDXComponent=!0;const u7o={toc:[]},m7o="wrapper";function d7o(t){let{components:n,...e}=t;return(0,s.kt)(m7o,(0,p.Z)({},u7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}d7o.isMDXComponent=!0;const h7o={toc:[]},k7o="wrapper";function f7o(t){let{components:n,...e}=t;return(0,s.kt)(k7o,(0,p.Z)({},h7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}f7o.isMDXComponent=!0;const y7o={toc:[]},M7o="wrapper";function D7o(t){let{components:n,...e}=t;return(0,s.kt)(M7o,(0,p.Z)({},y7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}D7o.isMDXComponent=!0;const X7o={toc:[]},_7o="wrapper";function w7o(t){let{components:n,...e}=t;return(0,s.kt)(_7o,(0,p.Z)({},X7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}w7o.isMDXComponent=!0;const T7o={toc:[]},C7o="wrapper";function g7o(t){let{components:n,...e}=t;return(0,s.kt)(C7o,(0,p.Z)({},T7o,e,{components:n,mdxType:"MDXLayout"}))}g7o.isMDXComponent=!0;const x7o={toc:[]},v7o="wrapper";function L7o(t){let{components:n,...e}=t;return(0,s.kt)(v7o,(0,p.Z)({},x7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}L7o.isMDXComponent=!0;const Z7o={toc:[]},b7o="wrapper";function N7o(t){let{components:n,...e}=t;return(0,s.kt)(b7o,(0,p.Z)({},Z7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}N7o.isMDXComponent=!0;const A7o={toc:[]},z7o="wrapper";function W7o(t){let{components:n,...e}=t;return(0,s.kt)(z7o,(0,p.Z)({},A7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}W7o.isMDXComponent=!0;const I7o={toc:[]},R7o="wrapper";function P7o(t){let{components:n,...e}=t;return(0,s.kt)(R7o,(0,p.Z)({},I7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}P7o.isMDXComponent=!0;const S7o={toc:[]},E7o="wrapper";function G7o(t){let{components:n,...e}=t;return(0,s.kt)(E7o,(0,p.Z)({},S7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}G7o.isMDXComponent=!0;const O7o={toc:[]},F7o="wrapper";function B7o(t){let{components:n,...e}=t;return(0,s.kt)(F7o,(0,p.Z)({},O7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}B7o.isMDXComponent=!0;const U7o={toc:[]},V7o="wrapper";function q7o(t){let{components:n,...e}=t;return(0,s.kt)(V7o,(0,p.Z)({},U7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}q7o.isMDXComponent=!0;const j7o={toc:[]},Y7o="wrapper";function Q7o(t){let{components:n,...e}=t;return(0,s.kt)(Y7o,(0,p.Z)({},j7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Q7o.isMDXComponent=!0;const H7o={toc:[]},$7o="wrapper";function K7o(t){let{components:n,...e}=t;return(0,s.kt)($7o,(0,p.Z)({},H7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}K7o.isMDXComponent=!0;const J7o={toc:[]},t9o="wrapper";function n9o(t){let{components:n,...e}=t;return(0,s.kt)(t9o,(0,p.Z)({},J7o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}n9o.isMDXComponent=!0;const e9o={toc:[]},o9o="wrapper";function p9o(t){let{components:n,...e}=t;return(0,s.kt)(o9o,(0,p.Z)({},e9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p9o.isMDXComponent=!0;const r9o={toc:[]},s9o="wrapper";function c9o(t){let{components:n,...e}=t;return(0,s.kt)(s9o,(0,p.Z)({},r9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}c9o.isMDXComponent=!0;const i9o={toc:[]},a9o="wrapper";function l9o(t){let{components:n,...e}=t;return(0,s.kt)(a9o,(0,p.Z)({},i9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}l9o.isMDXComponent=!0;const u9o={toc:[]},m9o="wrapper";function d9o(t){let{components:n,...e}=t;return(0,s.kt)(m9o,(0,p.Z)({},u9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}d9o.isMDXComponent=!0;const h9o={toc:[]},k9o="wrapper";function f9o(t){let{components:n,...e}=t;return(0,s.kt)(k9o,(0,p.Z)({},h9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}f9o.isMDXComponent=!0;const y9o={toc:[]},M9o="wrapper";function D9o(t){let{components:n,...e}=t;return(0,s.kt)(M9o,(0,p.Z)({},y9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}D9o.isMDXComponent=!0;const X9o={toc:[]},_9o="wrapper";function w9o(t){let{components:n,...e}=t;return(0,s.kt)(_9o,(0,p.Z)({},X9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w9o.isMDXComponent=!0;const T9o={toc:[]},C9o="wrapper";function g9o(t){let{components:n,...e}=t;return(0,s.kt)(C9o,(0,p.Z)({},T9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}g9o.isMDXComponent=!0;const x9o={toc:[]},v9o="wrapper";function L9o(t){let{components:n,...e}=t;return(0,s.kt)(v9o,(0,p.Z)({},x9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}L9o.isMDXComponent=!0;const Z9o={toc:[]},b9o="wrapper";function N9o(t){let{components:n,...e}=t;return(0,s.kt)(b9o,(0,p.Z)({},Z9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the end of each grid line."))}N9o.isMDXComponent=!0;const A9o={toc:[]},z9o="wrapper";function W9o(t){let{components:n,...e}=t;return(0,s.kt)(z9o,(0,p.Z)({},A9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}W9o.isMDXComponent=!0;const I9o={toc:[]},R9o="wrapper";function P9o(t){let{components:n,...e}=t;return(0,s.kt)(R9o,(0,p.Z)({},I9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}P9o.isMDXComponent=!0;const S9o={toc:[]},E9o="wrapper";function G9o(t){let{components:n,...e}=t;return(0,s.kt)(E9o,(0,p.Z)({},S9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}G9o.isMDXComponent=!0;const O9o={toc:[]},F9o="wrapper";function B9o(t){let{components:n,...e}=t;return(0,s.kt)(F9o,(0,p.Z)({},O9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}B9o.isMDXComponent=!0;const U9o={toc:[]},V9o="wrapper";function q9o(t){let{components:n,...e}=t;return(0,s.kt)(V9o,(0,p.Z)({},U9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}q9o.isMDXComponent=!0;const j9o={toc:[]},Y9o="wrapper";function Q9o(t){let{components:n,...e}=t;return(0,s.kt)(Y9o,(0,p.Z)({},j9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Q9o.isMDXComponent=!0;const H9o={toc:[]},$9o="wrapper";function K9o(t){let{components:n,...e}=t;return(0,s.kt)($9o,(0,p.Z)({},H9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The spacing between the grid lines."))}K9o.isMDXComponent=!0;const J9o={toc:[]},ttp="wrapper";function ntp(t){let{components:n,...e}=t;return(0,s.kt)(ttp,(0,p.Z)({},J9o,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}ntp.isMDXComponent=!0;const etp={toc:[]},otp="wrapper";function ptp(t){let{components:n,...e}=t;return(0,s.kt)(otp,(0,p.Z)({},etp,e,{components:n,mdxType:"MDXLayout"}))}ptp.isMDXComponent=!0;const rtp={toc:[]},stp="wrapper";function ctp(t){let{components:n,...e}=t;return(0,s.kt)(stp,(0,p.Z)({},rtp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}ctp.isMDXComponent=!0;const itp={toc:[]},atp="wrapper";function ltp(t){let{components:n,...e}=t;return(0,s.kt)(atp,(0,p.Z)({},itp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}ltp.isMDXComponent=!0;const utp={toc:[]},mtp="wrapper";function dtp(t){let{components:n,...e}=t;return(0,s.kt)(mtp,(0,p.Z)({},utp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dtp.isMDXComponent=!0;const htp={toc:[]},ktp="wrapper";function ftp(t){let{components:n,...e}=t;return(0,s.kt)(ktp,(0,p.Z)({},htp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}ftp.isMDXComponent=!0;const ytp={toc:[]},Mtp="wrapper";function Dtp(t){let{components:n,...e}=t;return(0,s.kt)(Mtp,(0,p.Z)({},ytp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Dtp.isMDXComponent=!0;const Xtp={toc:[]},_tp="wrapper";function wtp(t){let{components:n,...e}=t;return(0,s.kt)(_tp,(0,p.Z)({},Xtp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wtp.isMDXComponent=!0;const Ttp={toc:[]},Ctp="wrapper";function gtp(t){let{components:n,...e}=t;return(0,s.kt)(Ctp,(0,p.Z)({},Ttp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gtp.isMDXComponent=!0;const xtp={toc:[]},vtp="wrapper";function Ltp(t){let{components:n,...e}=t;return(0,s.kt)(vtp,(0,p.Z)({},xtp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Ltp.isMDXComponent=!0;const Ztp={toc:[]},btp="wrapper";function Ntp(t){let{components:n,...e}=t;return(0,s.kt)(btp,(0,p.Z)({},Ztp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Ntp.isMDXComponent=!0;const Atp={toc:[]},ztp="wrapper";function Wtp(t){let{components:n,...e}=t;return(0,s.kt)(ztp,(0,p.Z)({},Atp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Wtp.isMDXComponent=!0;const Itp={toc:[]},Rtp="wrapper";function Ptp(t){let{components:n,...e}=t;return(0,s.kt)(Rtp,(0,p.Z)({},Itp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Ptp.isMDXComponent=!0;const Stp={toc:[]},Etp="wrapper";function Gtp(t){let{components:n,...e}=t;return(0,s.kt)(Etp,(0,p.Z)({},Stp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Gtp.isMDXComponent=!0;const Otp={toc:[]},Ftp="wrapper";function Btp(t){let{components:n,...e}=t;return(0,s.kt)(Ftp,(0,p.Z)({},Otp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Btp.isMDXComponent=!0;const Utp={toc:[]},Vtp="wrapper";function qtp(t){let{components:n,...e}=t;return(0,s.kt)(Vtp,(0,p.Z)({},Utp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}qtp.isMDXComponent=!0;const jtp={toc:[]},Ytp="wrapper";function Qtp(t){let{components:n,...e}=t;return(0,s.kt)(Ytp,(0,p.Z)({},jtp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qtp.isMDXComponent=!0;const Htp={toc:[]},$tp="wrapper";function Ktp(t){let{components:n,...e}=t;return(0,s.kt)($tp,(0,p.Z)({},Htp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Ktp.isMDXComponent=!0;const Jtp={toc:[]},tnp="wrapper";function nnp(t){let{components:n,...e}=t;return(0,s.kt)(tnp,(0,p.Z)({},Jtp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nnp.isMDXComponent=!0;const enp={toc:[]},onp="wrapper";function pnp(t){let{components:n,...e}=t;return(0,s.kt)(onp,(0,p.Z)({},enp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pnp.isMDXComponent=!0;const rnp={toc:[]},snp="wrapper";function cnp(t){let{components:n,...e}=t;return(0,s.kt)(snp,(0,p.Z)({},rnp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}cnp.isMDXComponent=!0;const inp={toc:[]},anp="wrapper";function lnp(t){let{components:n,...e}=t;return(0,s.kt)(anp,(0,p.Z)({},inp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}lnp.isMDXComponent=!0;const unp={toc:[]},mnp="wrapper";function dnp(t){let{components:n,...e}=t;return(0,s.kt)(mnp,(0,p.Z)({},unp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}dnp.isMDXComponent=!0;const hnp={toc:[]},knp="wrapper";function fnp(t){let{components:n,...e}=t;return(0,s.kt)(knp,(0,p.Z)({},hnp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}fnp.isMDXComponent=!0;const ynp={toc:[]},Mnp="wrapper";function Dnp(t){let{components:n,...e}=t;return(0,s.kt)(Mnp,(0,p.Z)({},ynp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Dnp.isMDXComponent=!0;const Xnp={toc:[]},_np="wrapper";function wnp(t){let{components:n,...e}=t;return(0,s.kt)(_np,(0,p.Z)({},Xnp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}wnp.isMDXComponent=!0;const Tnp={toc:[]},Cnp="wrapper";function gnp(t){let{components:n,...e}=t;return(0,s.kt)(Cnp,(0,p.Z)({},Tnp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}gnp.isMDXComponent=!0;const xnp={toc:[]},vnp="wrapper";function Lnp(t){let{components:n,...e}=t;return(0,s.kt)(vnp,(0,p.Z)({},xnp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Lnp.isMDXComponent=!0;const Znp={toc:[]},bnp="wrapper";function Nnp(t){let{components:n,...e}=t;return(0,s.kt)(bnp,(0,p.Z)({},Znp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Nnp.isMDXComponent=!0;const Anp={toc:[]},znp="wrapper";function Wnp(t){let{components:n,...e}=t;return(0,s.kt)(znp,(0,p.Z)({},Anp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Wnp.isMDXComponent=!0;const Inp={toc:[]},Rnp="wrapper";function Pnp(t){let{components:n,...e}=t;return(0,s.kt)(Rnp,(0,p.Z)({},Inp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Pnp.isMDXComponent=!0;const Snp={toc:[]},Enp="wrapper";function Gnp(t){let{components:n,...e}=t;return(0,s.kt)(Enp,(0,p.Z)({},Snp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Gnp.isMDXComponent=!0;const Onp={toc:[]},Fnp="wrapper";function Bnp(t){let{components:n,...e}=t;return(0,s.kt)(Fnp,(0,p.Z)({},Onp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}Bnp.isMDXComponent=!0;const Unp={toc:[]},Vnp="wrapper";function qnp(t){let{components:n,...e}=t;return(0,s.kt)(Vnp,(0,p.Z)({},Unp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}qnp.isMDXComponent=!0;const jnp={toc:[]},Ynp="wrapper";function Qnp(t){let{components:n,...e}=t;return(0,s.kt)(Ynp,(0,p.Z)({},jnp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qnp.isMDXComponent=!0;const Hnp={toc:[]},$np="wrapper";function Knp(t){let{components:n,...e}=t;return(0,s.kt)($np,(0,p.Z)({},Hnp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Knp.isMDXComponent=!0;const Jnp={toc:[]},tep="wrapper";function nep(t){let{components:n,...e}=t;return(0,s.kt)(tep,(0,p.Z)({},Jnp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}nep.isMDXComponent=!0;const eep={toc:[]},oep="wrapper";function pep(t){let{components:n,...e}=t;return(0,s.kt)(oep,(0,p.Z)({},eep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}pep.isMDXComponent=!0;const rep={toc:[]},sep="wrapper";function cep(t){let{components:n,...e}=t;return(0,s.kt)(sep,(0,p.Z)({},rep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}cep.isMDXComponent=!0;const iep={toc:[]},aep="wrapper";function lep(t){let{components:n,...e}=t;return(0,s.kt)(aep,(0,p.Z)({},iep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}lep.isMDXComponent=!0;const uep={toc:[]},mep="wrapper";function dep(t){let{components:n,...e}=t;return(0,s.kt)(mep,(0,p.Z)({},uep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dep.isMDXComponent=!0;const hep={toc:[]},kep="wrapper";function fep(t){let{components:n,...e}=t;return(0,s.kt)(kep,(0,p.Z)({},hep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}fep.isMDXComponent=!0;const yep={toc:[]},Mep="wrapper";function Dep(t){let{components:n,...e}=t;return(0,s.kt)(Mep,(0,p.Z)({},yep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Dep.isMDXComponent=!0;const Xep={toc:[]},_ep="wrapper";function wep(t){let{components:n,...e}=t;return(0,s.kt)(_ep,(0,p.Z)({},Xep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}wep.isMDXComponent=!0;const Tep={toc:[]},Cep="wrapper";function gep(t){let{components:n,...e}=t;return(0,s.kt)(Cep,(0,p.Z)({},Tep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}gep.isMDXComponent=!0;const xep={toc:[]},vep="wrapper";function Lep(t){let{components:n,...e}=t;return(0,s.kt)(vep,(0,p.Z)({},xep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Lep.isMDXComponent=!0;const Zep={toc:[]},bep="wrapper";function Nep(t){let{components:n,...e}=t;return(0,s.kt)(bep,(0,p.Z)({},Zep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Nep.isMDXComponent=!0;const Aep={toc:[]},zep="wrapper";function Wep(t){let{components:n,...e}=t;return(0,s.kt)(zep,(0,p.Z)({},Aep,e,{components:n,mdxType:"MDXLayout"}))}Wep.isMDXComponent=!0;const Iep={toc:[]},Rep="wrapper";function Pep(t){let{components:n,...e}=t;return(0,s.kt)(Rep,(0,p.Z)({},Iep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Pep.isMDXComponent=!0;const Sep={toc:[]},Eep="wrapper";function Gep(t){let{components:n,...e}=t;return(0,s.kt)(Eep,(0,p.Z)({},Sep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Gep.isMDXComponent=!0;const Oep={toc:[]},Fep="wrapper";function Bep(t){let{components:n,...e}=t;return(0,s.kt)(Fep,(0,p.Z)({},Oep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Bep.isMDXComponent=!0;const Uep={toc:[]},Vep="wrapper";function qep(t){let{components:n,...e}=t;return(0,s.kt)(Vep,(0,p.Z)({},Uep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qep.isMDXComponent=!0;const jep={toc:[]},Yep="wrapper";function Qep(t){let{components:n,...e}=t;return(0,s.kt)(Yep,(0,p.Z)({},jep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Qep.isMDXComponent=!0;const Hep={toc:[]},$ep="wrapper";function Kep(t){let{components:n,...e}=t;return(0,s.kt)($ep,(0,p.Z)({},Hep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Kep.isMDXComponent=!0;const Jep={toc:[]},top="wrapper";function nop(t){let{components:n,...e}=t;return(0,s.kt)(top,(0,p.Z)({},Jep,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}nop.isMDXComponent=!0;const eop={toc:[]},oop="wrapper";function pop(t){let{components:n,...e}=t;return(0,s.kt)(oop,(0,p.Z)({},eop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pop.isMDXComponent=!0;const rop={toc:[]},sop="wrapper";function cop(t){let{components:n,...e}=t;return(0,s.kt)(sop,(0,p.Z)({},rop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}cop.isMDXComponent=!0;const iop={toc:[]},aop="wrapper";function lop(t){let{components:n,...e}=t;return(0,s.kt)(aop,(0,p.Z)({},iop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lop.isMDXComponent=!0;const uop={toc:[]},mop="wrapper";function dop(t){let{components:n,...e}=t;return(0,s.kt)(mop,(0,p.Z)({},uop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}dop.isMDXComponent=!0;const hop={toc:[]},kop="wrapper";function fop(t){let{components:n,...e}=t;return(0,s.kt)(kop,(0,p.Z)({},hop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}fop.isMDXComponent=!0;const yop={toc:[]},Mop="wrapper";function Dop(t){let{components:n,...e}=t;return(0,s.kt)(Mop,(0,p.Z)({},yop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Dop.isMDXComponent=!0;const Xop={toc:[]},_op="wrapper";function wop(t){let{components:n,...e}=t;return(0,s.kt)(_op,(0,p.Z)({},Xop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}wop.isMDXComponent=!0;const Top={toc:[]},Cop="wrapper";function gop(t){let{components:n,...e}=t;return(0,s.kt)(Cop,(0,p.Z)({},Top,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}gop.isMDXComponent=!0;const xop={toc:[]},vop="wrapper";function Lop(t){let{components:n,...e}=t;return(0,s.kt)(vop,(0,p.Z)({},xop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Lop.isMDXComponent=!0;const Zop={toc:[]},bop="wrapper";function Nop(t){let{components:n,...e}=t;return(0,s.kt)(bop,(0,p.Z)({},Zop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Nop.isMDXComponent=!0;const Aop={toc:[]},zop="wrapper";function Wop(t){let{components:n,...e}=t;return(0,s.kt)(zop,(0,p.Z)({},Aop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wop.isMDXComponent=!0;const Iop={toc:[]},Rop="wrapper";function Pop(t){let{components:n,...e}=t;return(0,s.kt)(Rop,(0,p.Z)({},Iop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Pop.isMDXComponent=!0;const Sop={toc:[]},Eop="wrapper";function Gop(t){let{components:n,...e}=t;return(0,s.kt)(Eop,(0,p.Z)({},Sop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Gop.isMDXComponent=!0;const Oop={toc:[]},Fop="wrapper";function Bop(t){let{components:n,...e}=t;return(0,s.kt)(Fop,(0,p.Z)({},Oop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Bop.isMDXComponent=!0;const Uop={toc:[]},Vop="wrapper";function qop(t){let{components:n,...e}=t;return(0,s.kt)(Vop,(0,p.Z)({},Uop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qop.isMDXComponent=!0;const jop={toc:[]},Yop="wrapper";function Qop(t){let{components:n,...e}=t;return(0,s.kt)(Yop,(0,p.Z)({},jop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Qop.isMDXComponent=!0;const Hop={toc:[]},$op="wrapper";function Kop(t){let{components:n,...e}=t;return(0,s.kt)($op,(0,p.Z)({},Hop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Kop.isMDXComponent=!0;const Jop={toc:[]},tpp="wrapper";function npp(t){let{components:n,...e}=t;return(0,s.kt)(tpp,(0,p.Z)({},Jop,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}npp.isMDXComponent=!0;const epp={toc:[]},opp="wrapper";function ppp(t){let{components:n,...e}=t;return(0,s.kt)(opp,(0,p.Z)({},epp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ppp.isMDXComponent=!0;const rpp={toc:[]},spp="wrapper";function cpp(t){let{components:n,...e}=t;return(0,s.kt)(spp,(0,p.Z)({},rpp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}cpp.isMDXComponent=!0;const ipp={toc:[]},app="wrapper";function lpp(t){let{components:n,...e}=t;return(0,s.kt)(app,(0,p.Z)({},ipp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}lpp.isMDXComponent=!0;const upp={toc:[]},mpp="wrapper";function dpp(t){let{components:n,...e}=t;return(0,s.kt)(mpp,(0,p.Z)({},upp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}dpp.isMDXComponent=!0;const hpp={toc:[]},kpp="wrapper";function fpp(t){let{components:n,...e}=t;return(0,s.kt)(kpp,(0,p.Z)({},hpp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}fpp.isMDXComponent=!0;const ypp={toc:[]},Mpp="wrapper";function Dpp(t){let{components:n,...e}=t;return(0,s.kt)(Mpp,(0,p.Z)({},ypp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Dpp.isMDXComponent=!0;const Xpp={toc:[]},_pp="wrapper";function wpp(t){let{components:n,...e}=t;return(0,s.kt)(_pp,(0,p.Z)({},Xpp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}wpp.isMDXComponent=!0;const Tpp={toc:[]},Cpp="wrapper";function gpp(t){let{components:n,...e}=t;return(0,s.kt)(Cpp,(0,p.Z)({},Tpp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}gpp.isMDXComponent=!0;const xpp={toc:[]},vpp="wrapper";function Lpp(t){let{components:n,...e}=t;return(0,s.kt)(vpp,(0,p.Z)({},xpp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lpp.isMDXComponent=!0;const Zpp={toc:[]},bpp="wrapper";function Npp(t){let{components:n,...e}=t;return(0,s.kt)(bpp,(0,p.Z)({},Zpp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Npp.isMDXComponent=!0;const App={toc:[]},zpp="wrapper";function Wpp(t){let{components:n,...e}=t;return(0,s.kt)(zpp,(0,p.Z)({},App,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Wpp.isMDXComponent=!0;const Ipp={toc:[]},Rpp="wrapper";function Ppp(t){let{components:n,...e}=t;return(0,s.kt)(Rpp,(0,p.Z)({},Ipp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Ppp.isMDXComponent=!0;const Spp={toc:[]},Epp="wrapper";function Gpp(t){let{components:n,...e}=t;return(0,s.kt)(Epp,(0,p.Z)({},Spp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Gpp.isMDXComponent=!0;const Opp={toc:[]},Fpp="wrapper";function Bpp(t){let{components:n,...e}=t;return(0,s.kt)(Fpp,(0,p.Z)({},Opp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Bpp.isMDXComponent=!0;const Upp={toc:[]},Vpp="wrapper";function qpp(t){let{components:n,...e}=t;return(0,s.kt)(Vpp,(0,p.Z)({},Upp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qpp.isMDXComponent=!0;const jpp={toc:[]},Ypp="wrapper";function Qpp(t){let{components:n,...e}=t;return(0,s.kt)(Ypp,(0,p.Z)({},jpp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Qpp.isMDXComponent=!0;const Hpp={toc:[]},$pp="wrapper";function Kpp(t){let{components:n,...e}=t;return(0,s.kt)($pp,(0,p.Z)({},Hpp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Kpp.isMDXComponent=!0;const Jpp={toc:[]},trp="wrapper";function nrp(t){let{components:n,...e}=t;return(0,s.kt)(trp,(0,p.Z)({},Jpp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}nrp.isMDXComponent=!0;const erp={toc:[]},orp="wrapper";function prp(t){let{components:n,...e}=t;return(0,s.kt)(orp,(0,p.Z)({},erp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}prp.isMDXComponent=!0;const rrp={toc:[]},srp="wrapper";function crp(t){let{components:n,...e}=t;return(0,s.kt)(srp,(0,p.Z)({},rrp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}crp.isMDXComponent=!0;const irp={toc:[]},arp="wrapper";function lrp(t){let{components:n,...e}=t;return(0,s.kt)(arp,(0,p.Z)({},irp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}lrp.isMDXComponent=!0;const urp={toc:[]},mrp="wrapper";function drp(t){let{components:n,...e}=t;return(0,s.kt)(mrp,(0,p.Z)({},urp,e,{components:n,mdxType:"MDXLayout"}))}drp.isMDXComponent=!0;const hrp={toc:[]},krp="wrapper";function frp(t){let{components:n,...e}=t;return(0,s.kt)(krp,(0,p.Z)({},hrp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}frp.isMDXComponent=!0;const yrp={toc:[]},Mrp="wrapper";function Drp(t){let{components:n,...e}=t;return(0,s.kt)(Mrp,(0,p.Z)({},yrp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Drp.isMDXComponent=!0;const Xrp={toc:[]},_rp="wrapper";function wrp(t){let{components:n,...e}=t;return(0,s.kt)(_rp,(0,p.Z)({},Xrp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}wrp.isMDXComponent=!0;const Trp={toc:[]},Crp="wrapper";function grp(t){let{components:n,...e}=t;return(0,s.kt)(Crp,(0,p.Z)({},Trp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}grp.isMDXComponent=!0;const xrp={toc:[]},vrp="wrapper";function Lrp(t){let{components:n,...e}=t;return(0,s.kt)(vrp,(0,p.Z)({},xrp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Lrp.isMDXComponent=!0;const Zrp={toc:[]},brp="wrapper";function Nrp(t){let{components:n,...e}=t;return(0,s.kt)(brp,(0,p.Z)({},Zrp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Nrp.isMDXComponent=!0;const Arp={toc:[]},zrp="wrapper";function Wrp(t){let{components:n,...e}=t;return(0,s.kt)(zrp,(0,p.Z)({},Arp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Wrp.isMDXComponent=!0;const Irp={toc:[]},Rrp="wrapper";function Prp(t){let{components:n,...e}=t;return(0,s.kt)(Rrp,(0,p.Z)({},Irp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Prp.isMDXComponent=!0;const Srp={toc:[]},Erp="wrapper";function Grp(t){let{components:n,...e}=t;return(0,s.kt)(Erp,(0,p.Z)({},Srp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Grp.isMDXComponent=!0;const Orp={toc:[]},Frp="wrapper";function Brp(t){let{components:n,...e}=t;return(0,s.kt)(Frp,(0,p.Z)({},Orp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Brp.isMDXComponent=!0;const Urp={toc:[]},Vrp="wrapper";function qrp(t){let{components:n,...e}=t;return(0,s.kt)(Vrp,(0,p.Z)({},Urp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}qrp.isMDXComponent=!0;const jrp={toc:[]},Yrp="wrapper";function Qrp(t){let{components:n,...e}=t;return(0,s.kt)(Yrp,(0,p.Z)({},jrp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qrp.isMDXComponent=!0;const Hrp={toc:[]},$rp="wrapper";function Krp(t){let{components:n,...e}=t;return(0,s.kt)($rp,(0,p.Z)({},Hrp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Krp.isMDXComponent=!0;const Jrp={toc:[]},tsp="wrapper";function nsp(t){let{components:n,...e}=t;return(0,s.kt)(tsp,(0,p.Z)({},Jrp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}nsp.isMDXComponent=!0;const esp={toc:[]},osp="wrapper";function psp(t){let{components:n,...e}=t;return(0,s.kt)(osp,(0,p.Z)({},esp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}psp.isMDXComponent=!0;const rsp={toc:[]},ssp="wrapper";function csp(t){let{components:n,...e}=t;return(0,s.kt)(ssp,(0,p.Z)({},rsp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}csp.isMDXComponent=!0;const isp={toc:[]},asp="wrapper";function lsp(t){let{components:n,...e}=t;return(0,s.kt)(asp,(0,p.Z)({},isp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}lsp.isMDXComponent=!0;const usp={toc:[]},msp="wrapper";function dsp(t){let{components:n,...e}=t;return(0,s.kt)(msp,(0,p.Z)({},usp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}dsp.isMDXComponent=!0;const hsp={toc:[]},ksp="wrapper";function fsp(t){let{components:n,...e}=t;return(0,s.kt)(ksp,(0,p.Z)({},hsp,e,{components:n,mdxType:"MDXLayout"}))}fsp.isMDXComponent=!0;const ysp={toc:[]},Msp="wrapper";function Dsp(t){let{components:n,...e}=t;return(0,s.kt)(Msp,(0,p.Z)({},ysp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Dsp.isMDXComponent=!0;const Xsp={toc:[]},_sp="wrapper";function wsp(t){let{components:n,...e}=t;return(0,s.kt)(_sp,(0,p.Z)({},Xsp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}wsp.isMDXComponent=!0;const Tsp={toc:[]},Csp="wrapper";function gsp(t){let{components:n,...e}=t;return(0,s.kt)(Csp,(0,p.Z)({},Tsp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}gsp.isMDXComponent=!0;const xsp={toc:[]},vsp="wrapper";function Lsp(t){let{components:n,...e}=t;return(0,s.kt)(vsp,(0,p.Z)({},xsp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Lsp.isMDXComponent=!0;const Zsp={toc:[]},bsp="wrapper";function Nsp(t){let{components:n,...e}=t;return(0,s.kt)(bsp,(0,p.Z)({},Zsp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Nsp.isMDXComponent=!0;const Asp={toc:[]},zsp="wrapper";function Wsp(t){let{components:n,...e}=t;return(0,s.kt)(zsp,(0,p.Z)({},Asp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Wsp.isMDXComponent=!0;const Isp={toc:[]},Rsp="wrapper";function Psp(t){let{components:n,...e}=t;return(0,s.kt)(Rsp,(0,p.Z)({},Isp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Psp.isMDXComponent=!0;const Ssp={toc:[]},Esp="wrapper";function Gsp(t){let{components:n,...e}=t;return(0,s.kt)(Esp,(0,p.Z)({},Ssp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Gsp.isMDXComponent=!0;const Osp={toc:[]},Fsp="wrapper";function Bsp(t){let{components:n,...e}=t;return(0,s.kt)(Fsp,(0,p.Z)({},Osp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bsp.isMDXComponent=!0;const Usp={toc:[]},Vsp="wrapper";function qsp(t){let{components:n,...e}=t;return(0,s.kt)(Vsp,(0,p.Z)({},Usp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}qsp.isMDXComponent=!0;const jsp={toc:[]},Ysp="wrapper";function Qsp(t){let{components:n,...e}=t;return(0,s.kt)(Ysp,(0,p.Z)({},jsp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qsp.isMDXComponent=!0;const Hsp={toc:[]},$sp="wrapper";function Ksp(t){let{components:n,...e}=t;return(0,s.kt)($sp,(0,p.Z)({},Hsp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ksp.isMDXComponent=!0;const Jsp={toc:[]},tcp="wrapper";function ncp(t){let{components:n,...e}=t;return(0,s.kt)(tcp,(0,p.Z)({},Jsp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}ncp.isMDXComponent=!0;const ecp={toc:[]},ocp="wrapper";function pcp(t){let{components:n,...e}=t;return(0,s.kt)(ocp,(0,p.Z)({},ecp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}pcp.isMDXComponent=!0;const rcp={toc:[]},scp="wrapper";function ccp(t){let{components:n,...e}=t;return(0,s.kt)(scp,(0,p.Z)({},rcp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ccp.isMDXComponent=!0;const icp={toc:[]},acp="wrapper";function lcp(t){let{components:n,...e}=t;return(0,s.kt)(acp,(0,p.Z)({},icp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}lcp.isMDXComponent=!0;const ucp={toc:[]},mcp="wrapper";function dcp(t){let{components:n,...e}=t;return(0,s.kt)(mcp,(0,p.Z)({},ucp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}dcp.isMDXComponent=!0;const hcp={toc:[]},kcp="wrapper";function fcp(t){let{components:n,...e}=t;return(0,s.kt)(kcp,(0,p.Z)({},hcp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}fcp.isMDXComponent=!0;const ycp={toc:[]},Mcp="wrapper";function Dcp(t){let{components:n,...e}=t;return(0,s.kt)(Mcp,(0,p.Z)({},ycp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Dcp.isMDXComponent=!0;const Xcp={toc:[]},_cp="wrapper";function wcp(t){let{components:n,...e}=t;return(0,s.kt)(_cp,(0,p.Z)({},Xcp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}wcp.isMDXComponent=!0;const Tcp={toc:[]},Ccp="wrapper";function gcp(t){let{components:n,...e}=t;return(0,s.kt)(Ccp,(0,p.Z)({},Tcp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}gcp.isMDXComponent=!0;const xcp={toc:[]},vcp="wrapper";function Lcp(t){let{components:n,...e}=t;return(0,s.kt)(vcp,(0,p.Z)({},xcp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Lcp.isMDXComponent=!0;const Zcp={toc:[]},bcp="wrapper";function Ncp(t){let{components:n,...e}=t;return(0,s.kt)(bcp,(0,p.Z)({},Zcp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ncp.isMDXComponent=!0;const Acp={toc:[]},zcp="wrapper";function Wcp(t){let{components:n,...e}=t;return(0,s.kt)(zcp,(0,p.Z)({},Acp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Wcp.isMDXComponent=!0;const Icp={toc:[]},Rcp="wrapper";function Pcp(t){let{components:n,...e}=t;return(0,s.kt)(Rcp,(0,p.Z)({},Icp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Pcp.isMDXComponent=!0;const Scp={toc:[]},Ecp="wrapper";function Gcp(t){let{components:n,...e}=t;return(0,s.kt)(Ecp,(0,p.Z)({},Scp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Gcp.isMDXComponent=!0;const Ocp={toc:[]},Fcp="wrapper";function Bcp(t){let{components:n,...e}=t;return(0,s.kt)(Fcp,(0,p.Z)({},Ocp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Bcp.isMDXComponent=!0;const Ucp={toc:[]},Vcp="wrapper";function qcp(t){let{components:n,...e}=t;return(0,s.kt)(Vcp,(0,p.Z)({},Ucp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}qcp.isMDXComponent=!0;const jcp={toc:[]},Ycp="wrapper";function Qcp(t){let{components:n,...e}=t;return(0,s.kt)(Ycp,(0,p.Z)({},jcp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qcp.isMDXComponent=!0;const Hcp={toc:[]},$cp="wrapper";function Kcp(t){let{components:n,...e}=t;return(0,s.kt)($cp,(0,p.Z)({},Hcp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Kcp.isMDXComponent=!0;const Jcp={toc:[]},tip="wrapper";function nip(t){let{components:n,...e}=t;return(0,s.kt)(tip,(0,p.Z)({},Jcp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}nip.isMDXComponent=!0;const eip={toc:[]},oip="wrapper";function pip(t){let{components:n,...e}=t;return(0,s.kt)(oip,(0,p.Z)({},eip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}pip.isMDXComponent=!0;const rip={toc:[]},sip="wrapper";function cip(t){let{components:n,...e}=t;return(0,s.kt)(sip,(0,p.Z)({},rip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}cip.isMDXComponent=!0;const iip={toc:[]},aip="wrapper";function lip(t){let{components:n,...e}=t;return(0,s.kt)(aip,(0,p.Z)({},iip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}lip.isMDXComponent=!0;const uip={toc:[]},mip="wrapper";function dip(t){let{components:n,...e}=t;return(0,s.kt)(mip,(0,p.Z)({},uip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}dip.isMDXComponent=!0;const hip={toc:[]},kip="wrapper";function fip(t){let{components:n,...e}=t;return(0,s.kt)(kip,(0,p.Z)({},hip,e,{components:n,mdxType:"MDXLayout"}))}fip.isMDXComponent=!0;const yip={toc:[]},Mip="wrapper";function Dip(t){let{components:n,...e}=t;return(0,s.kt)(Mip,(0,p.Z)({},yip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Dip.isMDXComponent=!0;const Xip={toc:[]},_ip="wrapper";function wip(t){let{components:n,...e}=t;return(0,s.kt)(_ip,(0,p.Z)({},Xip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wip.isMDXComponent=!0;const Tip={toc:[]},Cip="wrapper";function gip(t){let{components:n,...e}=t;return(0,s.kt)(Cip,(0,p.Z)({},Tip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}gip.isMDXComponent=!0;const xip={toc:[]},vip="wrapper";function Lip(t){let{components:n,...e}=t;return(0,s.kt)(vip,(0,p.Z)({},xip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Lip.isMDXComponent=!0;const Zip={toc:[]},bip="wrapper";function Nip(t){let{components:n,...e}=t;return(0,s.kt)(bip,(0,p.Z)({},Zip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Nip.isMDXComponent=!0;const Aip={toc:[]},zip="wrapper";function Wip(t){let{components:n,...e}=t;return(0,s.kt)(zip,(0,p.Z)({},Aip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Wip.isMDXComponent=!0;const Iip={toc:[]},Rip="wrapper";function Pip(t){let{components:n,...e}=t;return(0,s.kt)(Rip,(0,p.Z)({},Iip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Pip.isMDXComponent=!0;const Sip={toc:[]},Eip="wrapper";function Gip(t){let{components:n,...e}=t;return(0,s.kt)(Eip,(0,p.Z)({},Sip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Gip.isMDXComponent=!0;const Oip={toc:[]},Fip="wrapper";function Bip(t){let{components:n,...e}=t;return(0,s.kt)(Fip,(0,p.Z)({},Oip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Bip.isMDXComponent=!0;const Uip={toc:[]},Vip="wrapper";function qip(t){let{components:n,...e}=t;return(0,s.kt)(Vip,(0,p.Z)({},Uip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qip.isMDXComponent=!0;const jip={toc:[]},Yip="wrapper";function Qip(t){let{components:n,...e}=t;return(0,s.kt)(Yip,(0,p.Z)({},jip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Qip.isMDXComponent=!0;const Hip={toc:[]},$ip="wrapper";function Kip(t){let{components:n,...e}=t;return(0,s.kt)($ip,(0,p.Z)({},Hip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kip.isMDXComponent=!0;const Jip={toc:[]},tap="wrapper";function nap(t){let{components:n,...e}=t;return(0,s.kt)(tap,(0,p.Z)({},Jip,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}nap.isMDXComponent=!0;const eap={toc:[]},oap="wrapper";function pap(t){let{components:n,...e}=t;return(0,s.kt)(oap,(0,p.Z)({},eap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pap.isMDXComponent=!0;const rap={toc:[]},sap="wrapper";function cap(t){let{components:n,...e}=t;return(0,s.kt)(sap,(0,p.Z)({},rap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}cap.isMDXComponent=!0;const iap={toc:[]},aap="wrapper";function lap(t){let{components:n,...e}=t;return(0,s.kt)(aap,(0,p.Z)({},iap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lap.isMDXComponent=!0;const uap={toc:[]},map="wrapper";function dap(t){let{components:n,...e}=t;return(0,s.kt)(map,(0,p.Z)({},uap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}dap.isMDXComponent=!0;const hap={toc:[]},kap="wrapper";function fap(t){let{components:n,...e}=t;return(0,s.kt)(kap,(0,p.Z)({},hap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}fap.isMDXComponent=!0;const yap={toc:[]},Map="wrapper";function Dap(t){let{components:n,...e}=t;return(0,s.kt)(Map,(0,p.Z)({},yap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Dap.isMDXComponent=!0;const Xap={toc:[]},_ap="wrapper";function wap(t){let{components:n,...e}=t;return(0,s.kt)(_ap,(0,p.Z)({},Xap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wap.isMDXComponent=!0;const Tap={toc:[]},Cap="wrapper";function gap(t){let{components:n,...e}=t;return(0,s.kt)(Cap,(0,p.Z)({},Tap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}gap.isMDXComponent=!0;const xap={toc:[]},vap="wrapper";function Lap(t){let{components:n,...e}=t;return(0,s.kt)(vap,(0,p.Z)({},xap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Lap.isMDXComponent=!0;const Zap={toc:[]},bap="wrapper";function Nap(t){let{components:n,...e}=t;return(0,s.kt)(bap,(0,p.Z)({},Zap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Nap.isMDXComponent=!0;const Aap={toc:[]},zap="wrapper";function Wap(t){let{components:n,...e}=t;return(0,s.kt)(zap,(0,p.Z)({},Aap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wap.isMDXComponent=!0;const Iap={toc:[]},Rap="wrapper";function Pap(t){let{components:n,...e}=t;return(0,s.kt)(Rap,(0,p.Z)({},Iap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Pap.isMDXComponent=!0;const Sap={toc:[]},Eap="wrapper";function Gap(t){let{components:n,...e}=t;return(0,s.kt)(Eap,(0,p.Z)({},Sap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Gap.isMDXComponent=!0;const Oap={toc:[]},Fap="wrapper";function Bap(t){let{components:n,...e}=t;return(0,s.kt)(Fap,(0,p.Z)({},Oap,e,{components:n,mdxType:"MDXLayout"}))}Bap.isMDXComponent=!0;const Uap={toc:[]},Vap="wrapper";function qap(t){let{components:n,...e}=t;return(0,s.kt)(Vap,(0,p.Z)({},Uap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qap.isMDXComponent=!0;const jap={toc:[]},Yap="wrapper";function Qap(t){let{components:n,...e}=t;return(0,s.kt)(Yap,(0,p.Z)({},jap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Qap.isMDXComponent=!0;const Hap={toc:[]},$ap="wrapper";function Kap(t){let{components:n,...e}=t;return(0,s.kt)($ap,(0,p.Z)({},Hap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kap.isMDXComponent=!0;const Jap={toc:[]},tlp="wrapper";function nlp(t){let{components:n,...e}=t;return(0,s.kt)(tlp,(0,p.Z)({},Jap,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}nlp.isMDXComponent=!0;const elp={toc:[]},olp="wrapper";function plp(t){let{components:n,...e}=t;return(0,s.kt)(olp,(0,p.Z)({},elp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}plp.isMDXComponent=!0;const rlp={toc:[]},slp="wrapper";function clp(t){let{components:n,...e}=t;return(0,s.kt)(slp,(0,p.Z)({},rlp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}clp.isMDXComponent=!0;const ilp={toc:[]},alp="wrapper";function llp(t){let{components:n,...e}=t;return(0,s.kt)(alp,(0,p.Z)({},ilp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}llp.isMDXComponent=!0;const ulp={toc:[]},mlp="wrapper";function dlp(t){let{components:n,...e}=t;return(0,s.kt)(mlp,(0,p.Z)({},ulp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}dlp.isMDXComponent=!0;const hlp={toc:[]},klp="wrapper";function flp(t){let{components:n,...e}=t;return(0,s.kt)(klp,(0,p.Z)({},hlp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}flp.isMDXComponent=!0;const ylp={toc:[]},Mlp="wrapper";function Dlp(t){let{components:n,...e}=t;return(0,s.kt)(Mlp,(0,p.Z)({},ylp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Dlp.isMDXComponent=!0;const Xlp={toc:[]},_lp="wrapper";function wlp(t){let{components:n,...e}=t;return(0,s.kt)(_lp,(0,p.Z)({},Xlp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wlp.isMDXComponent=!0;const Tlp={toc:[]},Clp="wrapper";function glp(t){let{components:n,...e}=t;return(0,s.kt)(Clp,(0,p.Z)({},Tlp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}glp.isMDXComponent=!0;const xlp={toc:[]},vlp="wrapper";function Llp(t){let{components:n,...e}=t;return(0,s.kt)(vlp,(0,p.Z)({},xlp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Llp.isMDXComponent=!0;const Zlp={toc:[]},blp="wrapper";function Nlp(t){let{components:n,...e}=t;return(0,s.kt)(blp,(0,p.Z)({},Zlp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Nlp.isMDXComponent=!0;const Alp={toc:[]},zlp="wrapper";function Wlp(t){let{components:n,...e}=t;return(0,s.kt)(zlp,(0,p.Z)({},Alp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Wlp.isMDXComponent=!0;const Ilp={toc:[]},Rlp="wrapper";function Plp(t){let{components:n,...e}=t;return(0,s.kt)(Rlp,(0,p.Z)({},Ilp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Plp.isMDXComponent=!0;const Slp={toc:[]},Elp="wrapper";function Glp(t){let{components:n,...e}=t;return(0,s.kt)(Elp,(0,p.Z)({},Slp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Glp.isMDXComponent=!0;const Olp={toc:[]},Flp="wrapper";function Blp(t){let{components:n,...e}=t;return(0,s.kt)(Flp,(0,p.Z)({},Olp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Blp.isMDXComponent=!0;const Ulp={toc:[]},Vlp="wrapper";function qlp(t){let{components:n,...e}=t;return(0,s.kt)(Vlp,(0,p.Z)({},Ulp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qlp.isMDXComponent=!0;const jlp={toc:[]},Ylp="wrapper";function Qlp(t){let{components:n,...e}=t;return(0,s.kt)(Ylp,(0,p.Z)({},jlp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Qlp.isMDXComponent=!0;const Hlp={toc:[]},$lp="wrapper";function Klp(t){let{components:n,...e}=t;return(0,s.kt)($lp,(0,p.Z)({},Hlp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Klp.isMDXComponent=!0;const Jlp={toc:[]},tup="wrapper";function nup(t){let{components:n,...e}=t;return(0,s.kt)(tup,(0,p.Z)({},Jlp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}nup.isMDXComponent=!0;const eup={toc:[]},oup="wrapper";function pup(t){let{components:n,...e}=t;return(0,s.kt)(oup,(0,p.Z)({},eup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pup.isMDXComponent=!0;const rup={toc:[]},sup="wrapper";function cup(t){let{components:n,...e}=t;return(0,s.kt)(sup,(0,p.Z)({},rup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}cup.isMDXComponent=!0;const iup={toc:[]},aup="wrapper";function lup(t){let{components:n,...e}=t;return(0,s.kt)(aup,(0,p.Z)({},iup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}lup.isMDXComponent=!0;const uup={toc:[]},mup="wrapper";function dup(t){let{components:n,...e}=t;return(0,s.kt)(mup,(0,p.Z)({},uup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}dup.isMDXComponent=!0;const hup={toc:[]},kup="wrapper";function fup(t){let{components:n,...e}=t;return(0,s.kt)(kup,(0,p.Z)({},hup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", the Line will use the positions of its children as\npoints."))}fup.isMDXComponent=!0;const yup={toc:[]},Mup="wrapper";function Dup(t){let{components:n,...e}=t;return(0,s.kt)(Mup,(0,p.Z)({},yup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The points of the line."))}Dup.isMDXComponent=!0;const Xup={toc:[]},_up="wrapper";function wup(t){let{components:n,...e}=t;return(0,s.kt)(_up,(0,p.Z)({},Xup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The radius of the line's corners."))}wup.isMDXComponent=!0;const Tup={toc:[]},Cup="wrapper";function gup(t){let{components:n,...e}=t;return(0,s.kt)(Cup,(0,p.Z)({},Tup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gup.isMDXComponent=!0;const xup={toc:[]},vup="wrapper";function Lup(t){let{components:n,...e}=t;return(0,s.kt)(vup,(0,p.Z)({},xup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Lup.isMDXComponent=!0;const Zup={toc:[]},bup="wrapper";function Nup(t){let{components:n,...e}=t;return(0,s.kt)(bup,(0,p.Z)({},Zup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Nup.isMDXComponent=!0;const Aup={toc:[]},zup="wrapper";function Wup(t){let{components:n,...e}=t;return(0,s.kt)(zup,(0,p.Z)({},Aup,e,{components:n,mdxType:"MDXLayout"}))}Wup.isMDXComponent=!0;const Iup={toc:[]},Rup="wrapper";function Pup(t){let{components:n,...e}=t;return(0,s.kt)(Rup,(0,p.Z)({},Iup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Pup.isMDXComponent=!0;const Sup={toc:[]},Eup="wrapper";function Gup(t){let{components:n,...e}=t;return(0,s.kt)(Eup,(0,p.Z)({},Sup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Gup.isMDXComponent=!0;const Oup={toc:[]},Fup="wrapper";function Bup(t){let{components:n,...e}=t;return(0,s.kt)(Fup,(0,p.Z)({},Oup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Bup.isMDXComponent=!0;const Uup={toc:[]},Vup="wrapper";function qup(t){let{components:n,...e}=t;return(0,s.kt)(Vup,(0,p.Z)({},Uup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}qup.isMDXComponent=!0;const jup={toc:[]},Yup="wrapper";function Qup(t){let{components:n,...e}=t;return(0,s.kt)(Yup,(0,p.Z)({},jup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Qup.isMDXComponent=!0;const Hup={toc:[]},$up="wrapper";function Kup(t){let{components:n,...e}=t;return(0,s.kt)($up,(0,p.Z)({},Hup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Kup.isMDXComponent=!0;const Jup={toc:[]},tmp="wrapper";function nmp(t){let{components:n,...e}=t;return(0,s.kt)(tmp,(0,p.Z)({},Jup,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nmp.isMDXComponent=!0;const emp={toc:[]},omp="wrapper";function pmp(t){let{components:n,...e}=t;return(0,s.kt)(omp,(0,p.Z)({},emp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}pmp.isMDXComponent=!0;const rmp={toc:[]},smp="wrapper";function cmp(t){let{components:n,...e}=t;return(0,s.kt)(smp,(0,p.Z)({},rmp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cmp.isMDXComponent=!0;const imp={toc:[]},amp="wrapper";function lmp(t){let{components:n,...e}=t;return(0,s.kt)(amp,(0,p.Z)({},imp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lmp.isMDXComponent=!0;const ump={toc:[]},mmp="wrapper";function dmp(t){let{components:n,...e}=t;return(0,s.kt)(mmp,(0,p.Z)({},ump,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dmp.isMDXComponent=!0;const hmp={toc:[]},kmp="wrapper";function fmp(t){let{components:n,...e}=t;return(0,s.kt)(kmp,(0,p.Z)({},hmp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}fmp.isMDXComponent=!0;const ymp={toc:[]},Mmp="wrapper";function Dmp(t){let{components:n,...e}=t;return(0,s.kt)(Mmp,(0,p.Z)({},ymp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Dmp.isMDXComponent=!0;const Xmp={toc:[]},_mp="wrapper";function wmp(t){let{components:n,...e}=t;return(0,s.kt)(_mp,(0,p.Z)({},Xmp,e,{components:n,mdxType:"MDXLayout"}))}wmp.isMDXComponent=!0;const Tmp={toc:[]},Cmp="wrapper";function gmp(t){let{components:n,...e}=t;return(0,s.kt)(Cmp,(0,p.Z)({},Tmp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}gmp.isMDXComponent=!0;const xmp={toc:[]},vmp="wrapper";function Lmp(t){let{components:n,...e}=t;return(0,s.kt)(vmp,(0,p.Z)({},xmp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Lmp.isMDXComponent=!0;const Zmp={toc:[]},bmp="wrapper";function Nmp(t){let{components:n,...e}=t;return(0,s.kt)(bmp,(0,p.Z)({},Zmp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Nmp.isMDXComponent=!0;const Amp={toc:[]},zmp="wrapper";function Wmp(t){let{components:n,...e}=t;return(0,s.kt)(zmp,(0,p.Z)({},Amp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Wmp.isMDXComponent=!0;const Imp={toc:[]},Rmp="wrapper";function Pmp(t){let{components:n,...e}=t;return(0,s.kt)(Rmp,(0,p.Z)({},Imp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pmp.isMDXComponent=!0;const Smp={toc:[]},Emp="wrapper";function Gmp(t){let{components:n,...e}=t;return(0,s.kt)(Emp,(0,p.Z)({},Smp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Gmp.isMDXComponent=!0;const Omp={toc:[]},Fmp="wrapper";function Bmp(t){let{components:n,...e}=t;return(0,s.kt)(Fmp,(0,p.Z)({},Omp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bmp.isMDXComponent=!0;const Ump={toc:[]},Vmp="wrapper";function qmp(t){let{components:n,...e}=t;return(0,s.kt)(Vmp,(0,p.Z)({},Ump,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}qmp.isMDXComponent=!0;const jmp={toc:[]},Ymp="wrapper";function Qmp(t){let{components:n,...e}=t;return(0,s.kt)(Ymp,(0,p.Z)({},jmp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Qmp.isMDXComponent=!0;const Hmp={toc:[]},$mp="wrapper";function Kmp(t){let{components:n,...e}=t;return(0,s.kt)($mp,(0,p.Z)({},Hmp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Kmp.isMDXComponent=!0;const Jmp={toc:[]},tdp="wrapper";function ndp(t){let{components:n,...e}=t;return(0,s.kt)(tdp,(0,p.Z)({},Jmp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}ndp.isMDXComponent=!0;const edp={toc:[]},odp="wrapper";function pdp(t){let{components:n,...e}=t;return(0,s.kt)(odp,(0,p.Z)({},edp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}pdp.isMDXComponent=!0;const rdp={toc:[]},sdp="wrapper";function cdp(t){let{components:n,...e}=t;return(0,s.kt)(sdp,(0,p.Z)({},rdp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cdp.isMDXComponent=!0;const idp={toc:[]},adp="wrapper";function ldp(t){let{components:n,...e}=t;return(0,s.kt)(adp,(0,p.Z)({},idp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}ldp.isMDXComponent=!0;const udp={toc:[]},mdp="wrapper";function ddp(t){let{components:n,...e}=t;return(0,s.kt)(mdp,(0,p.Z)({},udp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}ddp.isMDXComponent=!0;const hdp={toc:[]},kdp="wrapper";function fdp(t){let{components:n,...e}=t;return(0,s.kt)(kdp,(0,p.Z)({},hdp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}fdp.isMDXComponent=!0;const ydp={toc:[]},Mdp="wrapper";function Ddp(t){let{components:n,...e}=t;return(0,s.kt)(Mdp,(0,p.Z)({},ydp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ddp.isMDXComponent=!0;const Xdp={toc:[]},_dp="wrapper";function wdp(t){let{components:n,...e}=t;return(0,s.kt)(_dp,(0,p.Z)({},Xdp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}wdp.isMDXComponent=!0;const Tdp={toc:[]},Cdp="wrapper";function gdp(t){let{components:n,...e}=t;return(0,s.kt)(Cdp,(0,p.Z)({},Tdp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}gdp.isMDXComponent=!0;const xdp={toc:[]},vdp="wrapper";function Ldp(t){let{components:n,...e}=t;return(0,s.kt)(vdp,(0,p.Z)({},xdp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Ldp.isMDXComponent=!0;const Zdp={toc:[]},bdp="wrapper";function Ndp(t){let{components:n,...e}=t;return(0,s.kt)(bdp,(0,p.Z)({},Zdp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ndp.isMDXComponent=!0;const Adp={toc:[]},zdp="wrapper";function Wdp(t){let{components:n,...e}=t;return(0,s.kt)(zdp,(0,p.Z)({},Adp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Wdp.isMDXComponent=!0;const Idp={toc:[]},Rdp="wrapper";function Pdp(t){let{components:n,...e}=t;return(0,s.kt)(Rdp,(0,p.Z)({},Idp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Pdp.isMDXComponent=!0;const Sdp={toc:[]},Edp="wrapper";function Gdp(t){let{components:n,...e}=t;return(0,s.kt)(Edp,(0,p.Z)({},Sdp,e,{components:n,mdxType:"MDXLayout"}))}Gdp.isMDXComponent=!0;const Odp={toc:[]},Fdp="wrapper";function Bdp(t){let{components:n,...e}=t;return(0,s.kt)(Fdp,(0,p.Z)({},Odp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Bdp.isMDXComponent=!0;const Udp={toc:[]},Vdp="wrapper";function qdp(t){let{components:n,...e}=t;return(0,s.kt)(Vdp,(0,p.Z)({},Udp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}qdp.isMDXComponent=!0;const jdp={toc:[]},Ydp="wrapper";function Qdp(t){let{components:n,...e}=t;return(0,s.kt)(Ydp,(0,p.Z)({},jdp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Qdp.isMDXComponent=!0;const Hdp={toc:[]},$dp="wrapper";function Kdp(t){let{components:n,...e}=t;return(0,s.kt)($dp,(0,p.Z)({},Hdp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Kdp.isMDXComponent=!0;const Jdp={toc:[]},thp="wrapper";function nhp(t){let{components:n,...e}=t;return(0,s.kt)(thp,(0,p.Z)({},Jdp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}nhp.isMDXComponent=!0;const ehp={toc:[]},ohp="wrapper";function php(t){let{components:n,...e}=t;return(0,s.kt)(ohp,(0,p.Z)({},ehp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}php.isMDXComponent=!0;const rhp={toc:[]},shp="wrapper";function chp(t){let{components:n,...e}=t;return(0,s.kt)(shp,(0,p.Z)({},rhp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}chp.isMDXComponent=!0;const ihp={toc:[]},ahp="wrapper";function lhp(t){let{components:n,...e}=t;return(0,s.kt)(ahp,(0,p.Z)({},ihp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}lhp.isMDXComponent=!0;const uhp={toc:[]},mhp="wrapper";function dhp(t){let{components:n,...e}=t;return(0,s.kt)(mhp,(0,p.Z)({},uhp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dhp.isMDXComponent=!0;const hhp={toc:[]},khp="wrapper";function fhp(t){let{components:n,...e}=t;return(0,s.kt)(khp,(0,p.Z)({},hhp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}fhp.isMDXComponent=!0;const yhp={toc:[]},Mhp="wrapper";function Dhp(t){let{components:n,...e}=t;return(0,s.kt)(Mhp,(0,p.Z)({},yhp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Dhp.isMDXComponent=!0;const Xhp={toc:[]},_hp="wrapper";function whp(t){let{components:n,...e}=t;return(0,s.kt)(_hp,(0,p.Z)({},Xhp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}whp.isMDXComponent=!0;const Thp={toc:[]},Chp="wrapper";function ghp(t){let{components:n,...e}=t;return(0,s.kt)(Chp,(0,p.Z)({},Thp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ghp.isMDXComponent=!0;const xhp={toc:[]},vhp="wrapper";function Lhp(t){let{components:n,...e}=t;return(0,s.kt)(vhp,(0,p.Z)({},xhp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Lhp.isMDXComponent=!0;const Zhp={toc:[]},bhp="wrapper";function Nhp(t){let{components:n,...e}=t;return(0,s.kt)(bhp,(0,p.Z)({},Zhp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Nhp.isMDXComponent=!0;const Ahp={toc:[]},zhp="wrapper";function Whp(t){let{components:n,...e}=t;return(0,s.kt)(zhp,(0,p.Z)({},Ahp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Whp.isMDXComponent=!0;const Ihp={toc:[]},Rhp="wrapper";function Php(t){let{components:n,...e}=t;return(0,s.kt)(Rhp,(0,p.Z)({},Ihp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Php.isMDXComponent=!0;const Shp={toc:[]},Ehp="wrapper";function Ghp(t){let{components:n,...e}=t;return(0,s.kt)(Ehp,(0,p.Z)({},Shp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ghp.isMDXComponent=!0;const Ohp={toc:[]},Fhp="wrapper";function Bhp(t){let{components:n,...e}=t;return(0,s.kt)(Fhp,(0,p.Z)({},Ohp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bhp.isMDXComponent=!0;const Uhp={toc:[]},Vhp="wrapper";function qhp(t){let{components:n,...e}=t;return(0,s.kt)(Vhp,(0,p.Z)({},Uhp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qhp.isMDXComponent=!0;const jhp={toc:[]},Yhp="wrapper";function Qhp(t){let{components:n,...e}=t;return(0,s.kt)(Yhp,(0,p.Z)({},jhp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Qhp.isMDXComponent=!0;const Hhp={toc:[]},$hp="wrapper";function Khp(t){let{components:n,...e}=t;return(0,s.kt)($hp,(0,p.Z)({},Hhp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Khp.isMDXComponent=!0;const Jhp={toc:[]},tkp="wrapper";function nkp(t){let{components:n,...e}=t;return(0,s.kt)(tkp,(0,p.Z)({},Jhp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nkp.isMDXComponent=!0;const ekp={toc:[]},okp="wrapper";function pkp(t){let{components:n,...e}=t;return(0,s.kt)(okp,(0,p.Z)({},ekp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pkp.isMDXComponent=!0;const rkp={toc:[]},skp="wrapper";function ckp(t){let{components:n,...e}=t;return(0,s.kt)(skp,(0,p.Z)({},rkp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}ckp.isMDXComponent=!0;const ikp={toc:[]},akp="wrapper";function lkp(t){let{components:n,...e}=t;return(0,s.kt)(akp,(0,p.Z)({},ikp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}lkp.isMDXComponent=!0;const ukp={toc:[]},mkp="wrapper";function dkp(t){let{components:n,...e}=t;return(0,s.kt)(mkp,(0,p.Z)({},ukp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}dkp.isMDXComponent=!0;const hkp={toc:[]},kkp="wrapper";function fkp(t){let{components:n,...e}=t;return(0,s.kt)(kkp,(0,p.Z)({},hkp,e,{components:n,mdxType:"MDXLayout"}))}fkp.isMDXComponent=!0;const ykp={toc:[]},Mkp="wrapper";function Dkp(t){let{components:n,...e}=t;return(0,s.kt)(Mkp,(0,p.Z)({},ykp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Dkp.isMDXComponent=!0;const Xkp={toc:[]},_kp="wrapper";function wkp(t){let{components:n,...e}=t;return(0,s.kt)(_kp,(0,p.Z)({},Xkp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}wkp.isMDXComponent=!0;const Tkp={toc:[]},Ckp="wrapper";function gkp(t){let{components:n,...e}=t;return(0,s.kt)(Ckp,(0,p.Z)({},Tkp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gkp.isMDXComponent=!0;const xkp={toc:[]},vkp="wrapper";function Lkp(t){let{components:n,...e}=t;return(0,s.kt)(vkp,(0,p.Z)({},xkp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Lkp.isMDXComponent=!0;const Zkp={toc:[]},bkp="wrapper";function Nkp(t){let{components:n,...e}=t;return(0,s.kt)(bkp,(0,p.Z)({},Zkp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Nkp.isMDXComponent=!0;const Akp={toc:[]},zkp="wrapper";function Wkp(t){let{components:n,...e}=t;return(0,s.kt)(zkp,(0,p.Z)({},Akp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Wkp.isMDXComponent=!0;const Ikp={toc:[]},Rkp="wrapper";function Pkp(t){let{components:n,...e}=t;return(0,s.kt)(Rkp,(0,p.Z)({},Ikp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Pkp.isMDXComponent=!0;const Skp={toc:[]},Ekp="wrapper";function Gkp(t){let{components:n,...e}=t;return(0,s.kt)(Ekp,(0,p.Z)({},Skp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Gkp.isMDXComponent=!0;const Okp={toc:[]},Fkp="wrapper";function Bkp(t){let{components:n,...e}=t;return(0,s.kt)(Fkp,(0,p.Z)({},Okp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bkp.isMDXComponent=!0;const Ukp={toc:[]},Vkp="wrapper";function qkp(t){let{components:n,...e}=t;return(0,s.kt)(Vkp,(0,p.Z)({},Ukp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}qkp.isMDXComponent=!0;const jkp={toc:[]},Ykp="wrapper";function Qkp(t){let{components:n,...e}=t;return(0,s.kt)(Ykp,(0,p.Z)({},jkp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qkp.isMDXComponent=!0;const Hkp={toc:[]},$kp="wrapper";function Kkp(t){let{components:n,...e}=t;return(0,s.kt)($kp,(0,p.Z)({},Hkp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Kkp.isMDXComponent=!0;const Jkp={toc:[]},tfp="wrapper";function nfp(t){let{components:n,...e}=t;return(0,s.kt)(tfp,(0,p.Z)({},Jkp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nfp.isMDXComponent=!0;const efp={toc:[]},ofp="wrapper";function pfp(t){let{components:n,...e}=t;return(0,s.kt)(ofp,(0,p.Z)({},efp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pfp.isMDXComponent=!0;const rfp={toc:[]},sfp="wrapper";function cfp(t){let{components:n,...e}=t;return(0,s.kt)(sfp,(0,p.Z)({},rfp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}cfp.isMDXComponent=!0;const ifp={toc:[]},afp="wrapper";function lfp(t){let{components:n,...e}=t;return(0,s.kt)(afp,(0,p.Z)({},ifp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}lfp.isMDXComponent=!0;const ufp={toc:[]},mfp="wrapper";function dfp(t){let{components:n,...e}=t;return(0,s.kt)(mfp,(0,p.Z)({},ufp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}dfp.isMDXComponent=!0;const hfp={toc:[]},kfp="wrapper";function ffp(t){let{components:n,...e}=t;return(0,s.kt)(kfp,(0,p.Z)({},hfp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}ffp.isMDXComponent=!0;const yfp={toc:[]},Mfp="wrapper";function Dfp(t){let{components:n,...e}=t;return(0,s.kt)(Mfp,(0,p.Z)({},yfp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Dfp.isMDXComponent=!0;const Xfp={toc:[]},_fp="wrapper";function wfp(t){let{components:n,...e}=t;return(0,s.kt)(_fp,(0,p.Z)({},Xfp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}wfp.isMDXComponent=!0;const Tfp={toc:[]},Cfp="wrapper";function gfp(t){let{components:n,...e}=t;return(0,s.kt)(Cfp,(0,p.Z)({},Tfp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}gfp.isMDXComponent=!0;const xfp={toc:[]},vfp="wrapper";function Lfp(t){let{components:n,...e}=t;return(0,s.kt)(vfp,(0,p.Z)({},xfp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Lfp.isMDXComponent=!0;const Zfp={toc:[]},bfp="wrapper";function Nfp(t){let{components:n,...e}=t;return(0,s.kt)(bfp,(0,p.Z)({},Zfp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Nfp.isMDXComponent=!0;const Afp={toc:[]},zfp="wrapper";function Wfp(t){let{components:n,...e}=t;return(0,s.kt)(zfp,(0,p.Z)({},Afp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Wfp.isMDXComponent=!0;const Ifp={toc:[]},Rfp="wrapper";function Pfp(t){let{components:n,...e}=t;return(0,s.kt)(Rfp,(0,p.Z)({},Ifp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Pfp.isMDXComponent=!0;const Sfp={toc:[]},Efp="wrapper";function Gfp(t){let{components:n,...e}=t;return(0,s.kt)(Efp,(0,p.Z)({},Sfp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Gfp.isMDXComponent=!0;const Ofp={toc:[]},Ffp="wrapper";function Bfp(t){let{components:n,...e}=t;return(0,s.kt)(Ffp,(0,p.Z)({},Ofp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bfp.isMDXComponent=!0;const Ufp={toc:[]},Vfp="wrapper";function qfp(t){let{components:n,...e}=t;return(0,s.kt)(Vfp,(0,p.Z)({},Ufp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}qfp.isMDXComponent=!0;const jfp={toc:[]},Yfp="wrapper";function Qfp(t){let{components:n,...e}=t;return(0,s.kt)(Yfp,(0,p.Z)({},jfp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Qfp.isMDXComponent=!0;const Hfp={toc:[]},$fp="wrapper";function Kfp(t){let{components:n,...e}=t;return(0,s.kt)($fp,(0,p.Z)({},Hfp,e,{components:n,mdxType:"MDXLayout"}))}Kfp.isMDXComponent=!0;const Jfp={toc:[]},typ="wrapper";function nyp(t){let{components:n,...e}=t;return(0,s.kt)(typ,(0,p.Z)({},Jfp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}nyp.isMDXComponent=!0;const eyp={toc:[]},oyp="wrapper";function pyp(t){let{components:n,...e}=t;return(0,s.kt)(oyp,(0,p.Z)({},eyp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}pyp.isMDXComponent=!0;const ryp={toc:[]},syp="wrapper";function cyp(t){let{components:n,...e}=t;return(0,s.kt)(syp,(0,p.Z)({},ryp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cyp.isMDXComponent=!0;const iyp={toc:[]},ayp="wrapper";function lyp(t){let{components:n,...e}=t;return(0,s.kt)(ayp,(0,p.Z)({},iyp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}lyp.isMDXComponent=!0;const uyp={toc:[]},myp="wrapper";function dyp(t){let{components:n,...e}=t;return(0,s.kt)(myp,(0,p.Z)({},uyp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}dyp.isMDXComponent=!0;const hyp={toc:[]},kyp="wrapper";function fyp(t){let{components:n,...e}=t;return(0,s.kt)(kyp,(0,p.Z)({},hyp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}fyp.isMDXComponent=!0;const yyp={toc:[]},Myp="wrapper";function Dyp(t){let{components:n,...e}=t;return(0,s.kt)(Myp,(0,p.Z)({},yyp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Dyp.isMDXComponent=!0;const Xyp={toc:[]},_yp="wrapper";function wyp(t){let{components:n,...e}=t;return(0,s.kt)(_yp,(0,p.Z)({},Xyp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}wyp.isMDXComponent=!0;const Typ={toc:[]},Cyp="wrapper";function gyp(t){let{components:n,...e}=t;return(0,s.kt)(Cyp,(0,p.Z)({},Typ,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gyp.isMDXComponent=!0;const xyp={toc:[]},vyp="wrapper";function Lyp(t){let{components:n,...e}=t;return(0,s.kt)(vyp,(0,p.Z)({},xyp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Lyp.isMDXComponent=!0;const Zyp={toc:[]},byp="wrapper";function Nyp(t){let{components:n,...e}=t;return(0,s.kt)(byp,(0,p.Z)({},Zyp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Nyp.isMDXComponent=!0;const Ayp={toc:[]},zyp="wrapper";function Wyp(t){let{components:n,...e}=t;return(0,s.kt)(zyp,(0,p.Z)({},Ayp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Wyp.isMDXComponent=!0;const Iyp={toc:[]},Ryp="wrapper";function Pyp(t){let{components:n,...e}=t;return(0,s.kt)(Ryp,(0,p.Z)({},Iyp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Pyp.isMDXComponent=!0;const Syp={toc:[]},Eyp="wrapper";function Gyp(t){let{components:n,...e}=t;return(0,s.kt)(Eyp,(0,p.Z)({},Syp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Gyp.isMDXComponent=!0;const Oyp={toc:[]},Fyp="wrapper";function Byp(t){let{components:n,...e}=t;return(0,s.kt)(Fyp,(0,p.Z)({},Oyp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Byp.isMDXComponent=!0;const Uyp={toc:[]},Vyp="wrapper";function qyp(t){let{components:n,...e}=t;return(0,s.kt)(Vyp,(0,p.Z)({},Uyp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}qyp.isMDXComponent=!0;const jyp={toc:[]},Yyp="wrapper";function Qyp(t){let{components:n,...e}=t;return(0,s.kt)(Yyp,(0,p.Z)({},jyp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qyp.isMDXComponent=!0;const Hyp={toc:[]},$yp="wrapper";function Kyp(t){let{components:n,...e}=t;return(0,s.kt)($yp,(0,p.Z)({},Hyp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Kyp.isMDXComponent=!0;const Jyp={toc:[]},tMp="wrapper";function nMp(t){let{components:n,...e}=t;return(0,s.kt)(tMp,(0,p.Z)({},Jyp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nMp.isMDXComponent=!0;const eMp={toc:[]},oMp="wrapper";function pMp(t){let{components:n,...e}=t;return(0,s.kt)(oMp,(0,p.Z)({},eMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pMp.isMDXComponent=!0;const rMp={toc:[]},sMp="wrapper";function cMp(t){let{components:n,...e}=t;return(0,s.kt)(sMp,(0,p.Z)({},rMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}cMp.isMDXComponent=!0;const iMp={toc:[]},aMp="wrapper";function lMp(t){let{components:n,...e}=t;return(0,s.kt)(aMp,(0,p.Z)({},iMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}lMp.isMDXComponent=!0;const uMp={toc:[]},mMp="wrapper";function dMp(t){let{components:n,...e}=t;return(0,s.kt)(mMp,(0,p.Z)({},uMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}dMp.isMDXComponent=!0;const hMp={toc:[]},kMp="wrapper";function fMp(t){let{components:n,...e}=t;return(0,s.kt)(kMp,(0,p.Z)({},hMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}fMp.isMDXComponent=!0;const yMp={toc:[]},MMp="wrapper";function DMp(t){let{components:n,...e}=t;return(0,s.kt)(MMp,(0,p.Z)({},yMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}DMp.isMDXComponent=!0;const XMp={toc:[]},_Mp="wrapper";function wMp(t){let{components:n,...e}=t;return(0,s.kt)(_Mp,(0,p.Z)({},XMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}wMp.isMDXComponent=!0;const TMp={toc:[]},CMp="wrapper";function gMp(t){let{components:n,...e}=t;return(0,s.kt)(CMp,(0,p.Z)({},TMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}gMp.isMDXComponent=!0;const xMp={toc:[]},vMp="wrapper";function LMp(t){let{components:n,...e}=t;return(0,s.kt)(vMp,(0,p.Z)({},xMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}LMp.isMDXComponent=!0;const ZMp={toc:[]},bMp="wrapper";function NMp(t){let{components:n,...e}=t;return(0,s.kt)(bMp,(0,p.Z)({},ZMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}NMp.isMDXComponent=!0;const AMp={toc:[]},zMp="wrapper";function WMp(t){let{components:n,...e}=t;return(0,s.kt)(zMp,(0,p.Z)({},AMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WMp.isMDXComponent=!0;const IMp={toc:[]},RMp="wrapper";function PMp(t){let{components:n,...e}=t;return(0,s.kt)(RMp,(0,p.Z)({},IMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}PMp.isMDXComponent=!0;const SMp={toc:[]},EMp="wrapper";function GMp(t){let{components:n,...e}=t;return(0,s.kt)(EMp,(0,p.Z)({},SMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}GMp.isMDXComponent=!0;const OMp={toc:[]},FMp="wrapper";function BMp(t){let{components:n,...e}=t;return(0,s.kt)(FMp,(0,p.Z)({},OMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}BMp.isMDXComponent=!0;const UMp={toc:[]},VMp="wrapper";function qMp(t){let{components:n,...e}=t;return(0,s.kt)(VMp,(0,p.Z)({},UMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qMp.isMDXComponent=!0;const jMp={toc:[]},YMp="wrapper";function QMp(t){let{components:n,...e}=t;return(0,s.kt)(YMp,(0,p.Z)({},jMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}QMp.isMDXComponent=!0;const HMp={toc:[]},$Mp="wrapper";function KMp(t){let{components:n,...e}=t;return(0,s.kt)($Mp,(0,p.Z)({},HMp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}KMp.isMDXComponent=!0;const JMp={toc:[]},tDp="wrapper";function nDp(t){let{components:n,...e}=t;return(0,s.kt)(tDp,(0,p.Z)({},JMp,e,{components:n,mdxType:"MDXLayout"}))}nDp.isMDXComponent=!0;const eDp={toc:[]},oDp="wrapper";function pDp(t){let{components:n,...e}=t;return(0,s.kt)(oDp,(0,p.Z)({},eDp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pDp.isMDXComponent=!0;const rDp={toc:[]},sDp="wrapper";function cDp(t){let{components:n,...e}=t;return(0,s.kt)(sDp,(0,p.Z)({},rDp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}cDp.isMDXComponent=!0;const iDp={toc:[]},aDp="wrapper";function lDp(t){let{components:n,...e}=t;return(0,s.kt)(aDp,(0,p.Z)({},iDp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lDp.isMDXComponent=!0;const uDp={toc:[]},mDp="wrapper";function dDp(t){let{components:n,...e}=t;return(0,s.kt)(mDp,(0,p.Z)({},uDp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}dDp.isMDXComponent=!0;const hDp={toc:[]},kDp="wrapper";function fDp(t){let{components:n,...e}=t;return(0,s.kt)(kDp,(0,p.Z)({},hDp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}fDp.isMDXComponent=!0;const yDp={toc:[]},MDp="wrapper";function DDp(t){let{components:n,...e}=t;return(0,s.kt)(MDp,(0,p.Z)({},yDp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}DDp.isMDXComponent=!0;const XDp={toc:[]},_Dp="wrapper";function wDp(t){let{components:n,...e}=t;return(0,s.kt)(_Dp,(0,p.Z)({},XDp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}wDp.isMDXComponent=!0;const TDp={toc:[]},CDp="wrapper";function gDp(t){let{components:n,...e}=t;return(0,s.kt)(CDp,(0,p.Z)({},TDp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gDp.isMDXComponent=!0;const xDp={toc:[]},vDp="wrapper";function LDp(t){let{components:n,...e}=t;return(0,s.kt)(vDp,(0,p.Z)({},xDp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}LDp.isMDXComponent=!0;const ZDp={toc:[]},bDp="wrapper";function NDp(t){let{components:n,...e}=t;return(0,s.kt)(bDp,(0,p.Z)({},ZDp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}NDp.isMDXComponent=!0;const ADp={toc:[]},zDp="wrapper";function WDp(t){let{components:n,...e}=t;return(0,s.kt)(zDp,(0,p.Z)({},ADp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}WDp.isMDXComponent=!0;const IDp={toc:[]},RDp="wrapper";function PDp(t){let{components:n,...e}=t;return(0,s.kt)(RDp,(0,p.Z)({},IDp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}PDp.isMDXComponent=!0;const SDp={toc:[]},EDp="wrapper";function GDp(t){let{components:n,...e}=t;return(0,s.kt)(EDp,(0,p.Z)({},SDp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}GDp.isMDXComponent=!0;const ODp={toc:[]},FDp="wrapper";function BDp(t){let{components:n,...e}=t;return(0,s.kt)(FDp,(0,p.Z)({},ODp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}BDp.isMDXComponent=!0;const UDp={toc:[]},VDp="wrapper";function qDp(t){let{components:n,...e}=t;return(0,s.kt)(VDp,(0,p.Z)({},UDp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}qDp.isMDXComponent=!0;const jDp={toc:[]},YDp="wrapper";function QDp(t){let{components:n,...e}=t;return(0,s.kt)(YDp,(0,p.Z)({},jDp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}QDp.isMDXComponent=!0;const HDp={toc:[]},$Dp="wrapper";function KDp(t){let{components:n,...e}=t;return(0,s.kt)($Dp,(0,p.Z)({},HDp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}KDp.isMDXComponent=!0;const JDp={toc:[]},tXp="wrapper";function nXp(t){let{components:n,...e}=t;return(0,s.kt)(tXp,(0,p.Z)({},JDp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nXp.isMDXComponent=!0;const eXp={toc:[]},oXp="wrapper";function pXp(t){let{components:n,...e}=t;return(0,s.kt)(oXp,(0,p.Z)({},eXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}pXp.isMDXComponent=!0;const rXp={toc:[]},sXp="wrapper";function cXp(t){let{components:n,...e}=t;return(0,s.kt)(sXp,(0,p.Z)({},rXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cXp.isMDXComponent=!0;const iXp={toc:[]},aXp="wrapper";function lXp(t){let{components:n,...e}=t;return(0,s.kt)(aXp,(0,p.Z)({},iXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lXp.isMDXComponent=!0;const uXp={toc:[]},mXp="wrapper";function dXp(t){let{components:n,...e}=t;return(0,s.kt)(mXp,(0,p.Z)({},uXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}dXp.isMDXComponent=!0;const hXp={toc:[]},kXp="wrapper";function fXp(t){let{components:n,...e}=t;return(0,s.kt)(kXp,(0,p.Z)({},hXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}fXp.isMDXComponent=!0;const yXp={toc:[]},MXp="wrapper";function DXp(t){let{components:n,...e}=t;return(0,s.kt)(MXp,(0,p.Z)({},yXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}DXp.isMDXComponent=!0;const XXp={toc:[]},_Xp="wrapper";function wXp(t){let{components:n,...e}=t;return(0,s.kt)(_Xp,(0,p.Z)({},XXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}wXp.isMDXComponent=!0;const TXp={toc:[]},CXp="wrapper";function gXp(t){let{components:n,...e}=t;return(0,s.kt)(CXp,(0,p.Z)({},TXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}gXp.isMDXComponent=!0;const xXp={toc:[]},vXp="wrapper";function LXp(t){let{components:n,...e}=t;return(0,s.kt)(vXp,(0,p.Z)({},xXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}LXp.isMDXComponent=!0;const ZXp={toc:[]},bXp="wrapper";function NXp(t){let{components:n,...e}=t;return(0,s.kt)(bXp,(0,p.Z)({},ZXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}NXp.isMDXComponent=!0;const AXp={toc:[]},zXp="wrapper";function WXp(t){let{components:n,...e}=t;return(0,s.kt)(zXp,(0,p.Z)({},AXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}WXp.isMDXComponent=!0;const IXp={toc:[]},RXp="wrapper";function PXp(t){let{components:n,...e}=t;return(0,s.kt)(RXp,(0,p.Z)({},IXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}PXp.isMDXComponent=!0;const SXp={toc:[]},EXp="wrapper";function GXp(t){let{components:n,...e}=t;return(0,s.kt)(EXp,(0,p.Z)({},SXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}GXp.isMDXComponent=!0;const OXp={toc:[]},FXp="wrapper";function BXp(t){let{components:n,...e}=t;return(0,s.kt)(FXp,(0,p.Z)({},OXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BXp.isMDXComponent=!0;const UXp={toc:[]},VXp="wrapper";function qXp(t){let{components:n,...e}=t;return(0,s.kt)(VXp,(0,p.Z)({},UXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qXp.isMDXComponent=!0;const jXp={toc:[]},YXp="wrapper";function QXp(t){let{components:n,...e}=t;return(0,s.kt)(YXp,(0,p.Z)({},jXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}QXp.isMDXComponent=!0;const HXp={toc:[]},$Xp="wrapper";function KXp(t){let{components:n,...e}=t;return(0,s.kt)($Xp,(0,p.Z)({},HXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}KXp.isMDXComponent=!0;const JXp={toc:[]},t_p="wrapper";function n_p(t){let{components:n,...e}=t;return(0,s.kt)(t_p,(0,p.Z)({},JXp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}n_p.isMDXComponent=!0;const e_p={toc:[]},o_p="wrapper";function p_p(t){let{components:n,...e}=t;return(0,s.kt)(o_p,(0,p.Z)({},e_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}p_p.isMDXComponent=!0;const r_p={toc:[]},s_p="wrapper";function c_p(t){let{components:n,...e}=t;return(0,s.kt)(s_p,(0,p.Z)({},r_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}c_p.isMDXComponent=!0;const i_p={toc:[]},a_p="wrapper";function l_p(t){let{components:n,...e}=t;return(0,s.kt)(a_p,(0,p.Z)({},i_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}l_p.isMDXComponent=!0;const u_p={toc:[]},m_p="wrapper";function d_p(t){let{components:n,...e}=t;return(0,s.kt)(m_p,(0,p.Z)({},u_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}d_p.isMDXComponent=!0;const h_p={toc:[]},k_p="wrapper";function f_p(t){let{components:n,...e}=t;return(0,s.kt)(k_p,(0,p.Z)({},h_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}f_p.isMDXComponent=!0;const y_p={toc:[]},M_p="wrapper";function D_p(t){let{components:n,...e}=t;return(0,s.kt)(M_p,(0,p.Z)({},y_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}D_p.isMDXComponent=!0;const X_p={toc:[]},__p="wrapper";function w_p(t){let{components:n,...e}=t;return(0,s.kt)(__p,(0,p.Z)({},X_p,e,{components:n,mdxType:"MDXLayout"}))}w_p.isMDXComponent=!0;const T_p={toc:[]},C_p="wrapper";function g_p(t){let{components:n,...e}=t;return(0,s.kt)(C_p,(0,p.Z)({},T_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}g_p.isMDXComponent=!0;const x_p={toc:[]},v_p="wrapper";function L_p(t){let{components:n,...e}=t;return(0,s.kt)(v_p,(0,p.Z)({},x_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}L_p.isMDXComponent=!0;const Z_p={toc:[]},b_p="wrapper";function N_p(t){let{components:n,...e}=t;return(0,s.kt)(b_p,(0,p.Z)({},Z_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}N_p.isMDXComponent=!0;const A_p={toc:[]},z_p="wrapper";function W_p(t){let{components:n,...e}=t;return(0,s.kt)(z_p,(0,p.Z)({},A_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}W_p.isMDXComponent=!0;const I_p={toc:[]},R_p="wrapper";function P_p(t){let{components:n,...e}=t;return(0,s.kt)(R_p,(0,p.Z)({},I_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}P_p.isMDXComponent=!0;const S_p={toc:[]},E_p="wrapper";function G_p(t){let{components:n,...e}=t;return(0,s.kt)(E_p,(0,p.Z)({},S_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}G_p.isMDXComponent=!0;const O_p={toc:[]},F_p="wrapper";function B_p(t){let{components:n,...e}=t;return(0,s.kt)(F_p,(0,p.Z)({},O_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}B_p.isMDXComponent=!0;const U_p={toc:[]},V_p="wrapper";function q_p(t){let{components:n,...e}=t;return(0,s.kt)(V_p,(0,p.Z)({},U_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}q_p.isMDXComponent=!0;const j_p={toc:[]},Y_p="wrapper";function Q_p(t){let{components:n,...e}=t;return(0,s.kt)(Y_p,(0,p.Z)({},j_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Q_p.isMDXComponent=!0;const H_p={toc:[]},$_p="wrapper";function K_p(t){let{components:n,...e}=t;return(0,s.kt)($_p,(0,p.Z)({},H_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}K_p.isMDXComponent=!0;const J_p={toc:[]},twp="wrapper";function nwp(t){let{components:n,...e}=t;return(0,s.kt)(twp,(0,p.Z)({},J_p,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nwp.isMDXComponent=!0;const ewp={toc:[]},owp="wrapper";function pwp(t){let{components:n,...e}=t;return(0,s.kt)(owp,(0,p.Z)({},ewp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}pwp.isMDXComponent=!0;const rwp={toc:[]},swp="wrapper";function cwp(t){let{components:n,...e}=t;return(0,s.kt)(swp,(0,p.Z)({},rwp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represent SVG document that contains SVG shapes.\nThis only used single time because ",(0,s.kt)("inlineCode",{parentName:"p"},"nodes")," have reference to parent SVG renderer."))}cwp.isMDXComponent=!0;const iwp={toc:[]},awp="wrapper";function lwp(t){let{components:n,...e}=t;return(0,s.kt)(awp,(0,p.Z)({},iwp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Data of SVGDocument.\nThis can used many times because it do not reference parent SVG.\nThis must build into SVGDocument"))}lwp.isMDXComponent=!0;const uwp={toc:[]},mwp="wrapper";function dwp(t){let{components:n,...e}=t;return(0,s.kt)(mwp,(0,p.Z)({},uwp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dwp.isMDXComponent=!0;const hwp={toc:[]},kwp="wrapper";function fwp(t){let{components:n,...e}=t;return(0,s.kt)(kwp,(0,p.Z)({},hwp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}fwp.isMDXComponent=!0;const ywp={toc:[]},Mwp="wrapper";function Dwp(t){let{components:n,...e}=t;return(0,s.kt)(Mwp,(0,p.Z)({},ywp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Dwp.isMDXComponent=!0;const Xwp={toc:[]},_wp="wrapper";function wwp(t){let{components:n,...e}=t;return(0,s.kt)(_wp,(0,p.Z)({},Xwp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}wwp.isMDXComponent=!0;const Twp={toc:[]},Cwp="wrapper";function gwp(t){let{components:n,...e}=t;return(0,s.kt)(Cwp,(0,p.Z)({},Twp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gwp.isMDXComponent=!0;const xwp={toc:[]},vwp="wrapper";function Lwp(t){let{components:n,...e}=t;return(0,s.kt)(vwp,(0,p.Z)({},xwp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Lwp.isMDXComponent=!0;const Zwp={toc:[]},bwp="wrapper";function Nwp(t){let{components:n,...e}=t;return(0,s.kt)(bwp,(0,p.Z)({},Zwp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Nwp.isMDXComponent=!0;const Awp={toc:[]},zwp="wrapper";function Wwp(t){let{components:n,...e}=t;return(0,s.kt)(zwp,(0,p.Z)({},Awp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Wwp.isMDXComponent=!0;const Iwp={toc:[]},Rwp="wrapper";function Pwp(t){let{components:n,...e}=t;return(0,s.kt)(Rwp,(0,p.Z)({},Iwp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Pwp.isMDXComponent=!0;const Swp={toc:[]},Ewp="wrapper";function Gwp(t){let{components:n,...e}=t;return(0,s.kt)(Ewp,(0,p.Z)({},Swp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Gwp.isMDXComponent=!0;const Owp={toc:[]},Fwp="wrapper";function Bwp(t){let{components:n,...e}=t;return(0,s.kt)(Fwp,(0,p.Z)({},Owp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Bwp.isMDXComponent=!0;const Uwp={toc:[]},Vwp="wrapper";function qwp(t){let{components:n,...e}=t;return(0,s.kt)(Vwp,(0,p.Z)({},Uwp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}qwp.isMDXComponent=!0;const jwp={toc:[]},Ywp="wrapper";function Qwp(t){let{components:n,...e}=t;return(0,s.kt)(Ywp,(0,p.Z)({},jwp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Qwp.isMDXComponent=!0;const Hwp={toc:[]},$wp="wrapper";function Kwp(t){let{components:n,...e}=t;return(0,s.kt)($wp,(0,p.Z)({},Hwp,e,{components:n,mdxType:"MDXLayout"}))}Kwp.isMDXComponent=!0;const Jwp={toc:[]},tTp="wrapper";function nTp(t){let{components:n,...e}=t;return(0,s.kt)(tTp,(0,p.Z)({},Jwp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nTp.isMDXComponent=!0;const eTp={toc:[]},oTp="wrapper";function pTp(t){let{components:n,...e}=t;return(0,s.kt)(oTp,(0,p.Z)({},eTp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}pTp.isMDXComponent=!0;const rTp={toc:[]},sTp="wrapper";function cTp(t){let{components:n,...e}=t;return(0,s.kt)(sTp,(0,p.Z)({},rTp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cTp.isMDXComponent=!0;const iTp={toc:[]},aTp="wrapper";function lTp(t){let{components:n,...e}=t;return(0,s.kt)(aTp,(0,p.Z)({},iTp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}lTp.isMDXComponent=!0;const uTp={toc:[]},mTp="wrapper";function dTp(t){let{components:n,...e}=t;return(0,s.kt)(mTp,(0,p.Z)({},uTp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dTp.isMDXComponent=!0;const hTp={toc:[]},kTp="wrapper";function fTp(t){let{components:n,...e}=t;return(0,s.kt)(kTp,(0,p.Z)({},hTp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}fTp.isMDXComponent=!0;const yTp={toc:[]},MTp="wrapper";function DTp(t){let{components:n,...e}=t;return(0,s.kt)(MTp,(0,p.Z)({},yTp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represent SVG shape.\nThis only used single time because ",(0,s.kt)("inlineCode",{parentName:"p"},"node")," may have reference to parent SVG renderer."))}DTp.isMDXComponent=!0;const XTp={toc:[]},_Tp="wrapper";function wTp(t){let{components:n,...e}=t;return(0,s.kt)(_Tp,(0,p.Z)({},XTp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Data of SVGShape.\nThis can used many times  because it do not reference parent SVG.\nThis must build into SVGShape"))}wTp.isMDXComponent=!0;const TTp={toc:[]},CTp="wrapper";function gTp(t){let{components:n,...e}=t;return(0,s.kt)(CTp,(0,p.Z)({},TTp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gTp.isMDXComponent=!0;const xTp={toc:[]},vTp="wrapper";function LTp(t){let{components:n,...e}=t;return(0,s.kt)(vTp,(0,p.Z)({},xTp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}LTp.isMDXComponent=!0;const ZTp={toc:[]},bTp="wrapper";function NTp(t){let{components:n,...e}=t;return(0,s.kt)(bTp,(0,p.Z)({},ZTp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}NTp.isMDXComponent=!0;const ATp={toc:[]},zTp="wrapper";function WTp(t){let{components:n,...e}=t;return(0,s.kt)(zTp,(0,p.Z)({},ATp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}WTp.isMDXComponent=!0;const ITp={toc:[]},RTp="wrapper";function PTp(t){let{components:n,...e}=t;return(0,s.kt)(RTp,(0,p.Z)({},ITp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}PTp.isMDXComponent=!0;const STp={toc:[]},ETp="wrapper";function GTp(t){let{components:n,...e}=t;return(0,s.kt)(ETp,(0,p.Z)({},STp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}GTp.isMDXComponent=!0;const OTp={toc:[]},FTp="wrapper";function BTp(t){let{components:n,...e}=t;return(0,s.kt)(FTp,(0,p.Z)({},OTp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BTp.isMDXComponent=!0;const UTp={toc:[]},VTp="wrapper";function qTp(t){let{components:n,...e}=t;return(0,s.kt)(VTp,(0,p.Z)({},UTp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qTp.isMDXComponent=!0;const jTp={toc:[]},YTp="wrapper";function QTp(t){let{components:n,...e}=t;return(0,s.kt)(YTp,(0,p.Z)({},jTp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}QTp.isMDXComponent=!0;const HTp={toc:[]},$Tp="wrapper";function KTp(t){let{components:n,...e}=t;return(0,s.kt)($Tp,(0,p.Z)({},HTp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}KTp.isMDXComponent=!0;const JTp={toc:[]},tCp="wrapper";function nCp(t){let{components:n,...e}=t;return(0,s.kt)(tCp,(0,p.Z)({},JTp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nCp.isMDXComponent=!0;const eCp={toc:[]},oCp="wrapper";function pCp(t){let{components:n,...e}=t;return(0,s.kt)(oCp,(0,p.Z)({},eCp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pCp.isMDXComponent=!0;const rCp={toc:[]},sCp="wrapper";function cCp(t){let{components:n,...e}=t;return(0,s.kt)(sCp,(0,p.Z)({},rCp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}cCp.isMDXComponent=!0;const iCp={toc:[]},aCp="wrapper";function lCp(t){let{components:n,...e}=t;return(0,s.kt)(aCp,(0,p.Z)({},iCp,e,{components:n,mdxType:"MDXLayout"}))}lCp.isMDXComponent=!0;const uCp={toc:[]},mCp="wrapper";function dCp(t){let{components:n,...e}=t;return(0,s.kt)(mCp,(0,p.Z)({},uCp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dCp.isMDXComponent=!0;const hCp={toc:[]},kCp="wrapper";function fCp(t){let{components:n,...e}=t;return(0,s.kt)(kCp,(0,p.Z)({},hCp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}fCp.isMDXComponent=!0;const yCp={toc:[]},MCp="wrapper";function DCp(t){let{components:n,...e}=t;return(0,s.kt)(MCp,(0,p.Z)({},yCp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}DCp.isMDXComponent=!0;const XCp={toc:[]},_Cp="wrapper";function wCp(t){let{components:n,...e}=t;return(0,s.kt)(_Cp,(0,p.Z)({},XCp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wCp.isMDXComponent=!0;const TCp={toc:[]},CCp="wrapper";function gCp(t){let{components:n,...e}=t;return(0,s.kt)(CCp,(0,p.Z)({},TCp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}gCp.isMDXComponent=!0;const xCp={toc:[]},vCp="wrapper";function LCp(t){let{components:n,...e}=t;return(0,s.kt)(vCp,(0,p.Z)({},xCp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}LCp.isMDXComponent=!0;const ZCp={toc:[]},bCp="wrapper";function NCp(t){let{components:n,...e}=t;return(0,s.kt)(bCp,(0,p.Z)({},ZCp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}NCp.isMDXComponent=!0;const ACp={toc:[]},zCp="wrapper";function WCp(t){let{components:n,...e}=t;return(0,s.kt)(zCp,(0,p.Z)({},ACp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}WCp.isMDXComponent=!0;const ICp={toc:[]},RCp="wrapper";function PCp(t){let{components:n,...e}=t;return(0,s.kt)(RCp,(0,p.Z)({},ICp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}PCp.isMDXComponent=!0;const SCp={toc:[]},ECp="wrapper";function GCp(t){let{components:n,...e}=t;return(0,s.kt)(ECp,(0,p.Z)({},SCp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}GCp.isMDXComponent=!0;const OCp={toc:[]},FCp="wrapper";function BCp(t){let{components:n,...e}=t;return(0,s.kt)(FCp,(0,p.Z)({},OCp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}BCp.isMDXComponent=!0;const UCp={toc:[]},VCp="wrapper";function qCp(t){let{components:n,...e}=t;return(0,s.kt)(VCp,(0,p.Z)({},UCp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}qCp.isMDXComponent=!0;const jCp={toc:[]},YCp="wrapper";function QCp(t){let{components:n,...e}=t;return(0,s.kt)(YCp,(0,p.Z)({},jCp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}QCp.isMDXComponent=!0;const HCp={toc:[]},$Cp="wrapper";function KCp(t){let{components:n,...e}=t;return(0,s.kt)($Cp,(0,p.Z)({},HCp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}KCp.isMDXComponent=!0;const JCp={toc:[]},tgp="wrapper";function ngp(t){let{components:n,...e}=t;return(0,s.kt)(tgp,(0,p.Z)({},JCp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}ngp.isMDXComponent=!0;const egp={toc:[]},ogp="wrapper";function pgp(t){let{components:n,...e}=t;return(0,s.kt)(ogp,(0,p.Z)({},egp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}pgp.isMDXComponent=!0;const rgp={toc:[]},sgp="wrapper";function cgp(t){let{components:n,...e}=t;return(0,s.kt)(sgp,(0,p.Z)({},rgp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}cgp.isMDXComponent=!0;const igp={toc:[]},agp="wrapper";function lgp(t){let{components:n,...e}=t;return(0,s.kt)(agp,(0,p.Z)({},igp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}lgp.isMDXComponent=!0;const ugp={toc:[]},mgp="wrapper";function dgp(t){let{components:n,...e}=t;return(0,s.kt)(mgp,(0,p.Z)({},ugp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}dgp.isMDXComponent=!0;const hgp={toc:[]},kgp="wrapper";function fgp(t){let{components:n,...e}=t;return(0,s.kt)(kgp,(0,p.Z)({},hgp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}fgp.isMDXComponent=!0;const ygp={toc:[]},Mgp="wrapper";function Dgp(t){let{components:n,...e}=t;return(0,s.kt)(Mgp,(0,p.Z)({},ygp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Dgp.isMDXComponent=!0;const Xgp={toc:[]},_gp="wrapper";function wgp(t){let{components:n,...e}=t;return(0,s.kt)(_gp,(0,p.Z)({},Xgp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}wgp.isMDXComponent=!0;const Tgp={toc:[]},Cgp="wrapper";function ggp(t){let{components:n,...e}=t;return(0,s.kt)(Cgp,(0,p.Z)({},Tgp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ggp.isMDXComponent=!0;const xgp={toc:[]},vgp="wrapper";function Lgp(t){let{components:n,...e}=t;return(0,s.kt)(vgp,(0,p.Z)({},xgp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Lgp.isMDXComponent=!0;const Zgp={toc:[]},bgp="wrapper";function Ngp(t){let{components:n,...e}=t;return(0,s.kt)(bgp,(0,p.Z)({},Zgp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Ngp.isMDXComponent=!0;const Agp={toc:[]},zgp="wrapper";function Wgp(t){let{components:n,...e}=t;return(0,s.kt)(zgp,(0,p.Z)({},Agp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Wgp.isMDXComponent=!0;const Igp={toc:[]},Rgp="wrapper";function Pgp(t){let{components:n,...e}=t;return(0,s.kt)(Rgp,(0,p.Z)({},Igp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Spline.points"))}Pgp.isMDXComponent=!0;const Sgp={toc:[]},Egp="wrapper";function Ggp(t){let{components:n,...e}=t;return(0,s.kt)(Egp,(0,p.Z)({},Sgp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ggp.isMDXComponent=!0;const Ogp={toc:[]},Fgp="wrapper";function Bgp(t){let{components:n,...e}=t;return(0,s.kt)(Fgp,(0,p.Z)({},Ogp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Bgp.isMDXComponent=!0;const Ugp={toc:[]},Vgp="wrapper";function qgp(t){let{components:n,...e}=t;return(0,s.kt)(Vgp,(0,p.Z)({},Ugp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}qgp.isMDXComponent=!0;const jgp={toc:[]},Ygp="wrapper";function Qgp(t){let{components:n,...e}=t;return(0,s.kt)(Ygp,(0,p.Z)({},jgp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}Qgp.isMDXComponent=!0;const Hgp={toc:[]},$gp="wrapper";function Kgp(t){let{components:n,...e}=t;return(0,s.kt)($gp,(0,p.Z)({},Hgp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Kgp.isMDXComponent=!0;const Jgp={toc:[]},txp="wrapper";function nxp(t){let{components:n,...e}=t;return(0,s.kt)(txp,(0,p.Z)({},Jgp,e,{components:n,mdxType:"MDXLayout"}))}nxp.isMDXComponent=!0;const exp={toc:[]},oxp="wrapper";function pxp(t){let{components:n,...e}=t;return(0,s.kt)(oxp,(0,p.Z)({},exp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pxp.isMDXComponent=!0;const rxp={toc:[]},sxp="wrapper";function cxp(t){let{components:n,...e}=t;return(0,s.kt)(sxp,(0,p.Z)({},rxp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}cxp.isMDXComponent=!0;const ixp={toc:[]},axp="wrapper";function lxp(t){let{components:n,...e}=t;return(0,s.kt)(axp,(0,p.Z)({},ixp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lxp.isMDXComponent=!0;const uxp={toc:[]},mxp="wrapper";function dxp(t){let{components:n,...e}=t;return(0,s.kt)(mxp,(0,p.Z)({},uxp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}dxp.isMDXComponent=!0;const hxp={toc:[]},kxp="wrapper";function fxp(t){let{components:n,...e}=t;return(0,s.kt)(kxp,(0,p.Z)({},hxp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}fxp.isMDXComponent=!0;const yxp={toc:[]},Mxp="wrapper";function Dxp(t){let{components:n,...e}=t;return(0,s.kt)(Mxp,(0,p.Z)({},yxp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Dxp.isMDXComponent=!0;const Xxp={toc:[]},_xp="wrapper";function wxp(t){let{components:n,...e}=t;return(0,s.kt)(_xp,(0,p.Z)({},Xxp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wxp.isMDXComponent=!0;const Txp={toc:[]},Cxp="wrapper";function gxp(t){let{components:n,...e}=t;return(0,s.kt)(Cxp,(0,p.Z)({},Txp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}gxp.isMDXComponent=!0;const xxp={toc:[]},vxp="wrapper";function Lxp(t){let{components:n,...e}=t;return(0,s.kt)(vxp,(0,p.Z)({},xxp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lxp.isMDXComponent=!0;const Zxp={toc:[]},bxp="wrapper";function Nxp(t){let{components:n,...e}=t;return(0,s.kt)(bxp,(0,p.Z)({},Zxp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Nxp.isMDXComponent=!0;const Axp={toc:[]},zxp="wrapper";function Wxp(t){let{components:n,...e}=t;return(0,s.kt)(zxp,(0,p.Z)({},Axp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wxp.isMDXComponent=!0;const Ixp={toc:[]},Rxp="wrapper";function Pxp(t){let{components:n,...e}=t;return(0,s.kt)(Rxp,(0,p.Z)({},Ixp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Pxp.isMDXComponent=!0;const Sxp={toc:[]},Exp="wrapper";function Gxp(t){let{components:n,...e}=t;return(0,s.kt)(Exp,(0,p.Z)({},Sxp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Gxp.isMDXComponent=!0;const Oxp={toc:[]},Fxp="wrapper";function Bxp(t){let{components:n,...e}=t;return(0,s.kt)(Fxp,(0,p.Z)({},Oxp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Bxp.isMDXComponent=!0;const Uxp={toc:[]},Vxp="wrapper";function qxp(t){let{components:n,...e}=t;return(0,s.kt)(Vxp,(0,p.Z)({},Uxp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qxp.isMDXComponent=!0;const jxp={toc:[]},Yxp="wrapper";function Qxp(t){let{components:n,...e}=t;return(0,s.kt)(Yxp,(0,p.Z)({},jxp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Qxp.isMDXComponent=!0;const Hxp={toc:[]},$xp="wrapper";function Kxp(t){let{components:n,...e}=t;return(0,s.kt)($xp,(0,p.Z)({},Hxp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kxp.isMDXComponent=!0;const Jxp={toc:[]},tvp="wrapper";function nvp(t){let{components:n,...e}=t;return(0,s.kt)(tvp,(0,p.Z)({},Jxp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}nvp.isMDXComponent=!0;const evp={toc:[]},ovp="wrapper";function pvp(t){let{components:n,...e}=t;return(0,s.kt)(ovp,(0,p.Z)({},evp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pvp.isMDXComponent=!0;const rvp={toc:[]},svp="wrapper";function cvp(t){let{components:n,...e}=t;return(0,s.kt)(svp,(0,p.Z)({},rvp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}cvp.isMDXComponent=!0;const ivp={toc:[]},avp="wrapper";function lvp(t){let{components:n,...e}=t;return(0,s.kt)(avp,(0,p.Z)({},ivp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}lvp.isMDXComponent=!0;const uvp={toc:[]},mvp="wrapper";function dvp(t){let{components:n,...e}=t;return(0,s.kt)(mvp,(0,p.Z)({},uvp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}dvp.isMDXComponent=!0;const hvp={toc:[]},kvp="wrapper";function fvp(t){let{components:n,...e}=t;return(0,s.kt)(kvp,(0,p.Z)({},hvp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}fvp.isMDXComponent=!0;const yvp={toc:[]},Mvp="wrapper";function Dvp(t){let{components:n,...e}=t;return(0,s.kt)(Mvp,(0,p.Z)({},yvp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Dvp.isMDXComponent=!0;const Xvp={toc:[]},_vp="wrapper";function wvp(t){let{components:n,...e}=t;return(0,s.kt)(_vp,(0,p.Z)({},Xvp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}wvp.isMDXComponent=!0;const Tvp={toc:[]},Cvp="wrapper";function gvp(t){let{components:n,...e}=t;return(0,s.kt)(Cvp,(0,p.Z)({},Tvp,e,{components:n,mdxType:"MDXLayout"}))}gvp.isMDXComponent=!0;const xvp={toc:[]},vvp="wrapper";function Lvp(t){let{components:n,...e}=t;return(0,s.kt)(vvp,(0,p.Z)({},xvp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lvp.isMDXComponent=!0;const Zvp={toc:[]},bvp="wrapper";function Nvp(t){let{components:n,...e}=t;return(0,s.kt)(bvp,(0,p.Z)({},Zvp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Nvp.isMDXComponent=!0;const Avp={toc:[]},zvp="wrapper";function Wvp(t){let{components:n,...e}=t;return(0,s.kt)(zvp,(0,p.Z)({},Avp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Wvp.isMDXComponent=!0;const Ivp={toc:[]},Rvp="wrapper";function Pvp(t){let{components:n,...e}=t;return(0,s.kt)(Rvp,(0,p.Z)({},Ivp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Pvp.isMDXComponent=!0;const Svp={toc:[]},Evp="wrapper";function Gvp(t){let{components:n,...e}=t;return(0,s.kt)(Evp,(0,p.Z)({},Svp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Gvp.isMDXComponent=!0;const Ovp={toc:[]},Fvp="wrapper";function Bvp(t){let{components:n,...e}=t;return(0,s.kt)(Fvp,(0,p.Z)({},Ovp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Bvp.isMDXComponent=!0;const Uvp={toc:[]},Vvp="wrapper";function qvp(t){let{components:n,...e}=t;return(0,s.kt)(Vvp,(0,p.Z)({},Uvp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}qvp.isMDXComponent=!0;const jvp={toc:[]},Yvp="wrapper";function Qvp(t){let{components:n,...e}=t;return(0,s.kt)(Yvp,(0,p.Z)({},jvp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}Qvp.isMDXComponent=!0;const Hvp={toc:[]},$vp="wrapper";function Kvp(t){let{components:n,...e}=t;return(0,s.kt)($vp,(0,p.Z)({},Hvp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Kvp.isMDXComponent=!0;const Jvp={toc:[]},tLp="wrapper";function nLp(t){let{components:n,...e}=t;return(0,s.kt)(tLp,(0,p.Z)({},Jvp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}nLp.isMDXComponent=!0;const eLp={toc:[]},oLp="wrapper";function pLp(t){let{components:n,...e}=t;return(0,s.kt)(oLp,(0,p.Z)({},eLp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pLp.isMDXComponent=!0;const rLp={toc:[]},sLp="wrapper";function cLp(t){let{components:n,...e}=t;return(0,s.kt)(sLp,(0,p.Z)({},rLp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}cLp.isMDXComponent=!0;const iLp={toc:[]},aLp="wrapper";function lLp(t){let{components:n,...e}=t;return(0,s.kt)(aLp,(0,p.Z)({},iLp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lLp.isMDXComponent=!0;const uLp={toc:[]},mLp="wrapper";function dLp(t){let{components:n,...e}=t;return(0,s.kt)(mLp,(0,p.Z)({},uLp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}dLp.isMDXComponent=!0;const hLp={toc:[]},kLp="wrapper";function fLp(t){let{components:n,...e}=t;return(0,s.kt)(kLp,(0,p.Z)({},hLp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}fLp.isMDXComponent=!0;const yLp={toc:[]},MLp="wrapper";function DLp(t){let{components:n,...e}=t;return(0,s.kt)(MLp,(0,p.Z)({},yLp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}DLp.isMDXComponent=!0;const XLp={toc:[]},_Lp="wrapper";function wLp(t){let{components:n,...e}=t;return(0,s.kt)(_Lp,(0,p.Z)({},XLp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}wLp.isMDXComponent=!0;const TLp={toc:[]},CLp="wrapper";function gLp(t){let{components:n,...e}=t;return(0,s.kt)(CLp,(0,p.Z)({},TLp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}gLp.isMDXComponent=!0;const xLp={toc:[]},vLp="wrapper";function LLp(t){let{components:n,...e}=t;return(0,s.kt)(vLp,(0,p.Z)({},xLp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}LLp.isMDXComponent=!0;const ZLp={toc:[]},bLp="wrapper";function NLp(t){let{components:n,...e}=t;return(0,s.kt)(bLp,(0,p.Z)({},ZLp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}NLp.isMDXComponent=!0;const ALp={toc:[]},zLp="wrapper";function WLp(t){let{components:n,...e}=t;return(0,s.kt)(zLp,(0,p.Z)({},ALp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}WLp.isMDXComponent=!0;const ILp={toc:[]},RLp="wrapper";function PLp(t){let{components:n,...e}=t;return(0,s.kt)(RLp,(0,p.Z)({},ILp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}PLp.isMDXComponent=!0;const SLp={toc:[]},ELp="wrapper";function GLp(t){let{components:n,...e}=t;return(0,s.kt)(ELp,(0,p.Z)({},SLp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}GLp.isMDXComponent=!0;const OLp={toc:[]},FLp="wrapper";function BLp(t){let{components:n,...e}=t;return(0,s.kt)(FLp,(0,p.Z)({},OLp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}BLp.isMDXComponent=!0;const ULp={toc:[]},VLp="wrapper";function qLp(t){let{components:n,...e}=t;return(0,s.kt)(VLp,(0,p.Z)({},ULp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}qLp.isMDXComponent=!0;const jLp={toc:[]},YLp="wrapper";function QLp(t){let{components:n,...e}=t;return(0,s.kt)(YLp,(0,p.Z)({},jLp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}QLp.isMDXComponent=!0;const HLp={toc:[]},$Lp="wrapper";function KLp(t){let{components:n,...e}=t;return(0,s.kt)($Lp,(0,p.Z)({},HLp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KLp.isMDXComponent=!0;const JLp={toc:[]},tZp="wrapper";function nZp(t){let{components:n,...e}=t;return(0,s.kt)(tZp,(0,p.Z)({},JLp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}nZp.isMDXComponent=!0;const eZp={toc:[]},oZp="wrapper";function pZp(t){let{components:n,...e}=t;return(0,s.kt)(oZp,(0,p.Z)({},eZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}pZp.isMDXComponent=!0;const rZp={toc:[]},sZp="wrapper";function cZp(t){let{components:n,...e}=t;return(0,s.kt)(sZp,(0,p.Z)({},rZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}cZp.isMDXComponent=!0;const iZp={toc:[]},aZp="wrapper";function lZp(t){let{components:n,...e}=t;return(0,s.kt)(aZp,(0,p.Z)({},iZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}lZp.isMDXComponent=!0;const uZp={toc:[]},mZp="wrapper";function dZp(t){let{components:n,...e}=t;return(0,s.kt)(mZp,(0,p.Z)({},uZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rate at which the video plays, as multiples of the normal speed."))}dZp.isMDXComponent=!0;const hZp={toc:[]},kZp="wrapper";function fZp(t){let{components:n,...e}=t;return(0,s.kt)(kZp,(0,p.Z)({},hZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}fZp.isMDXComponent=!0;const yZp={toc:[]},MZp="wrapper";function DZp(t){let{components:n,...e}=t;return(0,s.kt)(MZp,(0,p.Z)({},yZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}DZp.isMDXComponent=!0;const XZp={toc:[]},_Zp="wrapper";function wZp(t){let{components:n,...e}=t;return(0,s.kt)(_Zp,(0,p.Z)({},XZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wZp.isMDXComponent=!0;const TZp={toc:[]},CZp="wrapper";function gZp(t){let{components:n,...e}=t;return(0,s.kt)(CZp,(0,p.Z)({},TZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}gZp.isMDXComponent=!0;const xZp={toc:[]},vZp="wrapper";function LZp(t){let{components:n,...e}=t;return(0,s.kt)(vZp,(0,p.Z)({},xZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}LZp.isMDXComponent=!0;const ZZp={toc:[]},bZp="wrapper";function NZp(t){let{components:n,...e}=t;return(0,s.kt)(bZp,(0,p.Z)({},ZZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}NZp.isMDXComponent=!0;const AZp={toc:[]},zZp="wrapper";function WZp(t){let{components:n,...e}=t;return(0,s.kt)(zZp,(0,p.Z)({},AZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}WZp.isMDXComponent=!0;const IZp={toc:[]},RZp="wrapper";function PZp(t){let{components:n,...e}=t;return(0,s.kt)(RZp,(0,p.Z)({},IZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}PZp.isMDXComponent=!0;const SZp={toc:[]},EZp="wrapper";function GZp(t){let{components:n,...e}=t;return(0,s.kt)(EZp,(0,p.Z)({},SZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}GZp.isMDXComponent=!0;const OZp={toc:[]},FZp="wrapper";function BZp(t){let{components:n,...e}=t;return(0,s.kt)(FZp,(0,p.Z)({},OZp,e,{components:n,mdxType:"MDXLayout"}))}BZp.isMDXComponent=!0;const UZp={toc:[]},VZp="wrapper";function qZp(t){let{components:n,...e}=t;return(0,s.kt)(VZp,(0,p.Z)({},UZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}qZp.isMDXComponent=!0;const jZp={toc:[]},YZp="wrapper";function QZp(t){let{components:n,...e}=t;return(0,s.kt)(YZp,(0,p.Z)({},jZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}QZp.isMDXComponent=!0;const HZp={toc:[]},$Zp="wrapper";function KZp(t){let{components:n,...e}=t;return(0,s.kt)($Zp,(0,p.Z)({},HZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}KZp.isMDXComponent=!0;const JZp={toc:[]},tbp="wrapper";function nbp(t){let{components:n,...e}=t;return(0,s.kt)(tbp,(0,p.Z)({},JZp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}nbp.isMDXComponent=!0;const ebp={toc:[]},obp="wrapper";function pbp(t){let{components:n,...e}=t;return(0,s.kt)(obp,(0,p.Z)({},ebp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}pbp.isMDXComponent=!0;const rbp={toc:[]},sbp="wrapper";function cbp(t){let{components:n,...e}=t;return(0,s.kt)(sbp,(0,p.Z)({},rbp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}cbp.isMDXComponent=!0;const ibp={toc:[]},abp="wrapper";function lbp(t){let{components:n,...e}=t;return(0,s.kt)(abp,(0,p.Z)({},ibp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}lbp.isMDXComponent=!0;const ubp={toc:[]},mbp="wrapper";function dbp(t){let{components:n,...e}=t;return(0,s.kt)(mbp,(0,p.Z)({},ubp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting time for this video in seconds."))}dbp.isMDXComponent=!0;const hbp={toc:[]},kbp="wrapper";function fbp(t){let{components:n,...e}=t;return(0,s.kt)(kbp,(0,p.Z)({},hbp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}fbp.isMDXComponent=!0;const ybp={toc:[]},Mbp="wrapper";function Dbp(t){let{components:n,...e}=t;return(0,s.kt)(Mbp,(0,p.Z)({},ybp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Dbp.isMDXComponent=!0;const Xbp={toc:[]},_bp="wrapper";function wbp(t){let{components:n,...e}=t;return(0,s.kt)(_bp,(0,p.Z)({},Xbp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wbp.isMDXComponent=!0;const Tbp={toc:[]},Cbp="wrapper";function gbp(t){let{components:n,...e}=t;return(0,s.kt)(Cbp,(0,p.Z)({},Tbp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}gbp.isMDXComponent=!0;const xbp={toc:[]},vbp="wrapper";function Lbp(t){let{components:n,...e}=t;return(0,s.kt)(vbp,(0,p.Z)({},xbp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lbp.isMDXComponent=!0;const Zbp={toc:[]},bbp="wrapper";function Nbp(t){let{components:n,...e}=t;return(0,s.kt)(bbp,(0,p.Z)({},Zbp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Nbp.isMDXComponent=!0;const Abp={toc:[]},zbp="wrapper";function Wbp(t){let{components:n,...e}=t;return(0,s.kt)(zbp,(0,p.Z)({},Abp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Wbp.isMDXComponent=!0;const Ibp={toc:[]},Rbp="wrapper";function Pbp(t){let{components:n,...e}=t;return(0,s.kt)(Rbp,(0,p.Z)({},Ibp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Pbp.isMDXComponent=!0;const Sbp={toc:[]},Ebp="wrapper";function Gbp(t){let{components:n,...e}=t;return(0,s.kt)(Ebp,(0,p.Z)({},Sbp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Gbp.isMDXComponent=!0;const Obp={toc:[]},Fbp="wrapper";function Bbp(t){let{components:n,...e}=t;return(0,s.kt)(Fbp,(0,p.Z)({},Obp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Bbp.isMDXComponent=!0;const Ubp={toc:[]},Vbp="wrapper";function qbp(t){let{components:n,...e}=t;return(0,s.kt)(Vbp,(0,p.Z)({},Ubp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qbp.isMDXComponent=!0;const jbp={toc:[]},Ybp="wrapper";function Qbp(t){let{components:n,...e}=t;return(0,s.kt)(Ybp,(0,p.Z)({},jbp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Qbp.isMDXComponent=!0;const Hbp={toc:[]},$bp="wrapper";function Kbp(t){let{components:n,...e}=t;return(0,s.kt)($bp,(0,p.Z)({},Hbp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kbp.isMDXComponent=!0;const Jbp={toc:[]},tNp="wrapper";function nNp(t){let{components:n,...e}=t;return(0,s.kt)(tNp,(0,p.Z)({},Jbp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}nNp.isMDXComponent=!0;const eNp={toc:[]},oNp="wrapper";function pNp(t){let{components:n,...e}=t;return(0,s.kt)(oNp,(0,p.Z)({},eNp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}pNp.isMDXComponent=!0;const rNp={toc:[]},sNp="wrapper";function cNp(t){let{components:n,...e}=t;return(0,s.kt)(sNp,(0,p.Z)({},rNp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}cNp.isMDXComponent=!0;const iNp={toc:[]},aNp="wrapper";function lNp(t){let{components:n,...e}=t;return(0,s.kt)(aNp,(0,p.Z)({},iNp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}lNp.isMDXComponent=!0;const uNp={toc:[]},mNp="wrapper";function dNp(t){let{components:n,...e}=t;return(0,s.kt)(mNp,(0,p.Z)({},uNp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}dNp.isMDXComponent=!0;const hNp={toc:[]},kNp="wrapper";function fNp(t){let{components:n,...e}=t;return(0,s.kt)(kNp,(0,p.Z)({},hNp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}fNp.isMDXComponent=!0;const yNp={toc:[]},MNp="wrapper";function DNp(t){let{components:n,...e}=t;return(0,s.kt)(MNp,(0,p.Z)({},yNp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}DNp.isMDXComponent=!0;const XNp={toc:[]},_Np="wrapper";function wNp(t){let{components:n,...e}=t;return(0,s.kt)(_Np,(0,p.Z)({},XNp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wNp.isMDXComponent=!0;const TNp={toc:[]},CNp="wrapper";function gNp(t){let{components:n,...e}=t;return(0,s.kt)(CNp,(0,p.Z)({},TNp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}gNp.isMDXComponent=!0;const xNp={toc:[]},vNp="wrapper";function LNp(t){let{components:n,...e}=t;return(0,s.kt)(vNp,(0,p.Z)({},xNp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}LNp.isMDXComponent=!0;const ZNp={toc:[]},bNp="wrapper";function NNp(t){let{components:n,...e}=t;return(0,s.kt)(bNp,(0,p.Z)({},ZNp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}NNp.isMDXComponent=!0;const ANp={toc:[]},zNp="wrapper";function WNp(t){let{components:n,...e}=t;return(0,s.kt)(zNp,(0,p.Z)({},ANp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WNp.isMDXComponent=!0;const INp={toc:[]},RNp="wrapper";function PNp(t){let{components:n,...e}=t;return(0,s.kt)(RNp,(0,p.Z)({},INp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}PNp.isMDXComponent=!0;const SNp={toc:[]},ENp="wrapper";function GNp(t){let{components:n,...e}=t;return(0,s.kt)(ENp,(0,p.Z)({},SNp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}GNp.isMDXComponent=!0;const ONp={toc:[]},FNp="wrapper";function BNp(t){let{components:n,...e}=t;return(0,s.kt)(FNp,(0,p.Z)({},ONp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}BNp.isMDXComponent=!0;const UNp={toc:[]},VNp="wrapper";function qNp(t){let{components:n,...e}=t;return(0,s.kt)(VNp,(0,p.Z)({},UNp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}qNp.isMDXComponent=!0;const jNp={toc:[]},YNp="wrapper";function QNp(t){let{components:n,...e}=t;return(0,s.kt)(YNp,(0,p.Z)({},jNp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}QNp.isMDXComponent=!0;const HNp={toc:[]},$Np="wrapper";function KNp(t){let{components:n,...e}=t;return(0,s.kt)($Np,(0,p.Z)({},HNp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KNp.isMDXComponent=!0;const JNp={toc:[]},tAp="wrapper";function nAp(t){let{components:n,...e}=t;return(0,s.kt)(tAp,(0,p.Z)({},JNp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}nAp.isMDXComponent=!0;const eAp={toc:[]},oAp="wrapper";function pAp(t){let{components:n,...e}=t;return(0,s.kt)(oAp,(0,p.Z)({},eAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}pAp.isMDXComponent=!0;const rAp={toc:[]},sAp="wrapper";function cAp(t){let{components:n,...e}=t;return(0,s.kt)(sAp,(0,p.Z)({},rAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}cAp.isMDXComponent=!0;const iAp={toc:[]},aAp="wrapper";function lAp(t){let{components:n,...e}=t;return(0,s.kt)(aAp,(0,p.Z)({},iAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}lAp.isMDXComponent=!0;const uAp={toc:[]},mAp="wrapper";function dAp(t){let{components:n,...e}=t;return(0,s.kt)(mAp,(0,p.Z)({},uAp,e,{components:n,mdxType:"MDXLayout"}))}dAp.isMDXComponent=!0;const hAp={toc:[]},kAp="wrapper";function fAp(t){let{components:n,...e}=t;return(0,s.kt)(kAp,(0,p.Z)({},hAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}fAp.isMDXComponent=!0;const yAp={toc:[]},MAp="wrapper";function DAp(t){let{components:n,...e}=t;return(0,s.kt)(MAp,(0,p.Z)({},yAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}DAp.isMDXComponent=!0;const XAp={toc:[]},_Ap="wrapper";function wAp(t){let{components:n,...e}=t;return(0,s.kt)(_Ap,(0,p.Z)({},XAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wAp.isMDXComponent=!0;const TAp={toc:[]},CAp="wrapper";function gAp(t){let{components:n,...e}=t;return(0,s.kt)(CAp,(0,p.Z)({},TAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}gAp.isMDXComponent=!0;const xAp={toc:[]},vAp="wrapper";function LAp(t){let{components:n,...e}=t;return(0,s.kt)(vAp,(0,p.Z)({},xAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}LAp.isMDXComponent=!0;const ZAp={toc:[]},bAp="wrapper";function NAp(t){let{components:n,...e}=t;return(0,s.kt)(bAp,(0,p.Z)({},ZAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}NAp.isMDXComponent=!0;const AAp={toc:[]},zAp="wrapper";function WAp(t){let{components:n,...e}=t;return(0,s.kt)(zAp,(0,p.Z)({},AAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}WAp.isMDXComponent=!0;const IAp={toc:[]},RAp="wrapper";function PAp(t){let{components:n,...e}=t;return(0,s.kt)(RAp,(0,p.Z)({},IAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}PAp.isMDXComponent=!0;const SAp={toc:[]},EAp="wrapper";function GAp(t){let{components:n,...e}=t;return(0,s.kt)(EAp,(0,p.Z)({},SAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}GAp.isMDXComponent=!0;const OAp={toc:[]},FAp="wrapper";function BAp(t){let{components:n,...e}=t;return(0,s.kt)(FAp,(0,p.Z)({},OAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}BAp.isMDXComponent=!0;const UAp={toc:[]},VAp="wrapper";function qAp(t){let{components:n,...e}=t;return(0,s.kt)(VAp,(0,p.Z)({},UAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qAp.isMDXComponent=!0;const jAp={toc:[]},YAp="wrapper";function QAp(t){let{components:n,...e}=t;return(0,s.kt)(YAp,(0,p.Z)({},jAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}QAp.isMDXComponent=!0;const HAp={toc:[]},$Ap="wrapper";function KAp(t){let{components:n,...e}=t;return(0,s.kt)($Ap,(0,p.Z)({},HAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}KAp.isMDXComponent=!0;const JAp={toc:[]},tzp="wrapper";function nzp(t){let{components:n,...e}=t;return(0,s.kt)(tzp,(0,p.Z)({},JAp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}nzp.isMDXComponent=!0;const ezp={toc:[]},ozp="wrapper";function pzp(t){let{components:n,...e}=t;return(0,s.kt)(ozp,(0,p.Z)({},ezp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}pzp.isMDXComponent=!0;const rzp={toc:[]},szp="wrapper";function czp(t){let{components:n,...e}=t;return(0,s.kt)(szp,(0,p.Z)({},rzp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}czp.isMDXComponent=!0;const izp={toc:[]},azp="wrapper";function lzp(t){let{components:n,...e}=t;return(0,s.kt)(azp,(0,p.Z)({},izp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}lzp.isMDXComponent=!0;const uzp={toc:[]},mzp="wrapper";function dzp(t){let{components:n,...e}=t;return(0,s.kt)(mzp,(0,p.Z)({},uzp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.kt)("p",null,"Source code liberally taken from:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}dzp.isMDXComponent=!0;const hzp={toc:[]},kzp="wrapper";function fzp(t){let{components:n,...e}=t;return(0,s.kt)(kzp,(0,p.Z)({},hzp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}fzp.isMDXComponent=!0;const yzp={toc:[]},Mzp="wrapper";function Dzp(t){let{components:n,...e}=t;return(0,s.kt)(Mzp,(0,p.Z)({},yzp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}Dzp.isMDXComponent=!0;const Xzp={toc:[]},_zp="wrapper";function wzp(t){let{components:n,...e}=t;return(0,s.kt)(_zp,(0,p.Z)({},Xzp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}wzp.isMDXComponent=!0;const Tzp={toc:[]},Czp="wrapper";function gzp(t){let{components:n,...e}=t;return(0,s.kt)(Czp,(0,p.Z)({},Tzp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}gzp.isMDXComponent=!0;const xzp={toc:[]},vzp="wrapper";function Lzp(t){let{components:n,...e}=t;return(0,s.kt)(vzp,(0,p.Z)({},xzp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}Lzp.isMDXComponent=!0;const Zzp={toc:[]},bzp="wrapper";function Nzp(t){let{components:n,...e}=t;return(0,s.kt)(bzp,(0,p.Z)({},Zzp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}Nzp.isMDXComponent=!0;const Azp={toc:[]},zzp="wrapper";function Wzp(t){let{components:n,...e}=t;return(0,s.kt)(zzp,(0,p.Z)({},Azp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}Wzp.isMDXComponent=!0;const Izp={toc:[]},Rzp="wrapper";function Pzp(t){let{components:n,...e}=t;return(0,s.kt)(Rzp,(0,p.Z)({},Izp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}Pzp.isMDXComponent=!0;const Szp={toc:[]},Ezp="wrapper";function Gzp(t){let{components:n,...e}=t;return(0,s.kt)(Ezp,(0,p.Z)({},Szp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}Gzp.isMDXComponent=!0;const Ozp={toc:[]},Fzp="wrapper";function Bzp(t){let{components:n,...e}=t;return(0,s.kt)(Fzp,(0,p.Z)({},Ozp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}Bzp.isMDXComponent=!0;const Uzp={toc:[]},Vzp="wrapper";function qzp(t){let{components:n,...e}=t;return(0,s.kt)(Vzp,(0,p.Z)({},Uzp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The degree of the polynomial"))}qzp.isMDXComponent=!0;const jzp={toc:[]},Yzp="wrapper";function Qzp(t){let{components:n,...e}=t;return(0,s.kt)(Yzp,(0,p.Z)({},jzp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the nth derivative of the polynomial."))}Qzp.isMDXComponent=!0;const Hzp={toc:[]},$zp="wrapper";function Kzp(t){let{components:n,...e}=t;return(0,s.kt)($zp,(0,p.Z)({},Hzp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of times to differentiate the polynomial."))}Kzp.isMDXComponent=!0;const Jzp={toc:[]},tWp="wrapper";function nWp(t){let{components:n,...e}=t;return(0,s.kt)(tWp,(0,p.Z)({},Jzp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given value t."))}nWp.isMDXComponent=!0;const eWp={toc:[]},oWp="wrapper";function pWp(t){let{components:n,...e}=t;return(0,s.kt)(oWp,(0,p.Z)({},eWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}pWp.isMDXComponent=!0;const rWp={toc:[]},sWp="wrapper";function cWp(t){let{components:n,...e}=t;return(0,s.kt)(sWp,(0,p.Z)({},rWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}cWp.isMDXComponent=!0;const iWp={toc:[]},aWp="wrapper";function lWp(t){let{components:n,...e}=t;return(0,s.kt)(aWp,(0,p.Z)({},iWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}lWp.isMDXComponent=!0;const uWp={toc:[]},mWp="wrapper";function dWp(t){let{components:n,...e}=t;return(0,s.kt)(mWp,(0,p.Z)({},uWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The derivative of the polynomial to sample from"))}dWp.isMDXComponent=!0;const hWp={toc:[]},kWp="wrapper";function fWp(t){let{components:n,...e}=t;return(0,s.kt)(kWp,(0,p.Z)({},hWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial."))}fWp.isMDXComponent=!0;const yWp={toc:[]},MWp="wrapper";function DWp(t){let{components:n,...e}=t;return(0,s.kt)(MWp,(0,p.Z)({},yWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}DWp.isMDXComponent=!0;const XWp={toc:[]},_Wp="wrapper";function wWp(t){let{components:n,...e}=t;return(0,s.kt)(_Wp,(0,p.Z)({},XWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the output value range within the unit interval."))}wWp.isMDXComponent=!0;const TWp={toc:[]},CWp="wrapper";function gWp(t){let{components:n,...e}=t;return(0,s.kt)(CWp,(0,p.Z)({},TWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}gWp.isMDXComponent=!0;const xWp={toc:[]},vWp="wrapper";function LWp(t){let{components:n,...e}=t;return(0,s.kt)(vWp,(0,p.Z)({},xWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}LWp.isMDXComponent=!0;const ZWp={toc:[]},bWp="wrapper";function NWp(t){let{components:n,...e}=t;return(0,s.kt)(bWp,(0,p.Z)({},ZWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}NWp.isMDXComponent=!0;const AWp={toc:[]},zWp="wrapper";function WWp(t){let{components:n,...e}=t;return(0,s.kt)(zWp,(0,p.Z)({},AWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The point at which to split the polynomial."))}WWp.isMDXComponent=!0;const IWp={toc:[]},RWp="wrapper";function PWp(t){let{components:n,...e}=t;return(0,s.kt)(RWp,(0,p.Z)({},IWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a constant polynomial"))}PWp.isMDXComponent=!0;const SWp={toc:[]},EWp="wrapper";function GWp(t){let{components:n,...e}=t;return(0,s.kt)(EWp,(0,p.Z)({},SWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}GWp.isMDXComponent=!0;const OWp={toc:[]},FWp="wrapper";function BWp(t){let{components:n,...e}=t;return(0,s.kt)(FWp,(0,p.Z)({},OWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a cubic polynomial"))}BWp.isMDXComponent=!0;const UWp={toc:[]},VWp="wrapper";function qWp(t){let{components:n,...e}=t;return(0,s.kt)(VWp,(0,p.Z)({},UWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}qWp.isMDXComponent=!0;const jWp={toc:[]},YWp="wrapper";function QWp(t){let{components:n,...e}=t;return(0,s.kt)(YWp,(0,p.Z)({},jWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}QWp.isMDXComponent=!0;const HWp={toc:[]},$Wp="wrapper";function KWp(t){let{components:n,...e}=t;return(0,s.kt)($Wp,(0,p.Z)({},HWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}KWp.isMDXComponent=!0;const JWp={toc:[]},tIp="wrapper";function nIp(t){let{components:n,...e}=t;return(0,s.kt)(tIp,(0,p.Z)({},JWp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}nIp.isMDXComponent=!0;const eIp={toc:[]},oIp="wrapper";function pIp(t){let{components:n,...e}=t;return(0,s.kt)(oIp,(0,p.Z)({},eIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a linear polynomial"))}pIp.isMDXComponent=!0;const rIp={toc:[]},sIp="wrapper";function cIp(t){let{components:n,...e}=t;return(0,s.kt)(sIp,(0,p.Z)({},rIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}cIp.isMDXComponent=!0;const iIp={toc:[]},aIp="wrapper";function lIp(t){let{components:n,...e}=t;return(0,s.kt)(aIp,(0,p.Z)({},iIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}lIp.isMDXComponent=!0;const uIp={toc:[]},mIp="wrapper";function dIp(t){let{components:n,...e}=t;return(0,s.kt)(mIp,(0,p.Z)({},uIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a quadratic polynomial"))}dIp.isMDXComponent=!0;const hIp={toc:[]},kIp="wrapper";function fIp(t){let{components:n,...e}=t;return(0,s.kt)(kIp,(0,p.Z)({},hIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}fIp.isMDXComponent=!0;const yIp={toc:[]},MIp="wrapper";function DIp(t){let{components:n,...e}=t;return(0,s.kt)(MIp,(0,p.Z)({},yIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}DIp.isMDXComponent=!0;const XIp={toc:[]},_Ip="wrapper";function wIp(t){let{components:n,...e}=t;return(0,s.kt)(_Ip,(0,p.Z)({},XIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}wIp.isMDXComponent=!0;const TIp={toc:[]},CIp="wrapper";function gIp(t){let{components:n,...e}=t;return(0,s.kt)(CIp,(0,p.Z)({},TIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}gIp.isMDXComponent=!0;const xIp={toc:[]},vIp="wrapper";function LIp(t){let{components:n,...e}=t;return(0,s.kt)(vIp,(0,p.Z)({},xIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}LIp.isMDXComponent=!0;const ZIp={toc:[]},bIp="wrapper";function NIp(t){let{components:n,...e}=t;return(0,s.kt)(bIp,(0,p.Z)({},ZIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}NIp.isMDXComponent=!0;const AIp={toc:[]},zIp="wrapper";function WIp(t){let{components:n,...e}=t;return(0,s.kt)(zIp,(0,p.Z)({},AIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}WIp.isMDXComponent=!0;const IIp={toc:[]},RIp="wrapper";function PIp(t){let{components:n,...e}=t;return(0,s.kt)(RIp,(0,p.Z)({},IIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}PIp.isMDXComponent=!0;const SIp={toc:[]},EIp="wrapper";function GIp(t){let{components:n,...e}=t;return(0,s.kt)(EIp,(0,p.Z)({},SIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}GIp.isMDXComponent=!0;const OIp={toc:[]},FIp="wrapper";function BIp(t){let{components:n,...e}=t;return(0,s.kt)(FIp,(0,p.Z)({},OIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}BIp.isMDXComponent=!0;const UIp={toc:[]},VIp="wrapper";function qIp(t){let{components:n,...e}=t;return(0,s.kt)(VIp,(0,p.Z)({},UIp,e,{components:n,mdxType:"MDXLayout"}))}qIp.isMDXComponent=!0;const jIp={toc:[]},YIp="wrapper";function QIp(t){let{components:n,...e}=t;return(0,s.kt)(YIp,(0,p.Z)({},jIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}QIp.isMDXComponent=!0;const HIp={toc:[]},$Ip="wrapper";function KIp(t){let{components:n,...e}=t;return(0,s.kt)($Ip,(0,p.Z)({},HIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The knots defining the spline"))}KIp.isMDXComponent=!0;const JIp={toc:[]},tRp="wrapper";function nRp(t){let{components:n,...e}=t;return(0,s.kt)(tRp,(0,p.Z)({},JIp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the spline should be closed or not"))}nRp.isMDXComponent=!0;const eRp={toc:[]},oRp="wrapper";function pRp(t){let{components:n,...e}=t;return(0,s.kt)(oRp,(0,p.Z)({},eRp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}pRp.isMDXComponent=!0;const rRp={toc:[]},sRp="wrapper";function cRp(t){let{components:n,...e}=t;return(0,s.kt)(sRp,(0,p.Z)({},rRp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the initial value of this signal."))}cRp.isMDXComponent=!0;const iRp={toc:[]},aRp="wrapper";function lRp(t){let{components:n,...e}=t;return(0,s.kt)(aRp,(0,p.Z)({},iRp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}lRp.isMDXComponent=!0;const uRp={toc:[]},mRp="wrapper";function dRp(t){let{components:n,...e}=t;return(0,s.kt)(mRp,(0,p.Z)({},uRp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}dRp.isMDXComponent=!0;const hRp={toc:[]},kRp="wrapper";function fRp(t){let{components:n,...e}=t;return(0,s.kt)(kRp,(0,p.Z)({},hRp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is the signal undergoing a tween?"))}fRp.isMDXComponent=!0;const yRp={toc:[]},MRp="wrapper";function DRp(t){let{components:n,...e}=t;return(0,s.kt)(MRp,(0,p.Z)({},yRp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}DRp.isMDXComponent=!0;const XRp={toc:[]},_Rp="wrapper";function wRp(t){let{components:n,...e}=t;return(0,s.kt)(_Rp,(0,p.Z)({},XRp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}wRp.isMDXComponent=!0;const TRp={toc:[]},CRp="wrapper";function gRp(t){let{components:n,...e}=t;return(0,s.kt)(CRp,(0,p.Z)({},TRp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}gRp.isMDXComponent=!0;const xRp={toc:[]},vRp="wrapper";function LRp(t){let{components:n,...e}=t;return(0,s.kt)(vRp,(0,p.Z)({},xRp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}LRp.isMDXComponent=!0;const ZRp={toc:[]},bRp="wrapper";function NRp(t){let{components:n,...e}=t;return(0,s.kt)(bRp,(0,p.Z)({},ZRp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}NRp.isMDXComponent=!0;const ARp={toc:[]},zRp="wrapper";function WRp(t){let{components:n,...e}=t;return(0,s.kt)(zRp,(0,p.Z)({},ARp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}WRp.isMDXComponent=!0;const IRp={toc:[]},RRp="wrapper";function PRp(t){let{components:n,...e}=t;return(0,s.kt)(RRp,(0,p.Z)({},IRp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}PRp.isMDXComponent=!0;const SRp={toc:[]},ERp="wrapper";function GRp(t){let{components:n,...e}=t;return(0,s.kt)(ERp,(0,p.Z)({},SRp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}GRp.isMDXComponent=!0;const ORp={toc:[]},FRp="wrapper";function BRp(t){let{components:n,...e}=t;return(0,s.kt)(FRp,(0,p.Z)({},ORp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.kt)("p",null,"By default, any property is cloneable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}BRp.isMDXComponent=!0;const URp={toc:[]},VRp="wrapper";function qRp(t){let{components:n,...e}=t;return(0,s.kt)(VRp,(0,p.Z)({},URp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}qRp.isMDXComponent=!0;const jRp={toc:[]},YRp="wrapper";function QRp(t){let{components:n,...e}=t;return(0,s.kt)(YRp,(0,p.Z)({},jRp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a cloneable property decorator."))}QRp.isMDXComponent=!0;const HRp={toc:[]},$Rp="wrapper";function KRp(t){let{components:n,...e}=t;return(0,s.kt)($Rp,(0,p.Z)({},HRp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be cloneable."))}KRp.isMDXComponent=!0;const JRp={toc:[]},tPp="wrapper";function nPp(t){let{components:n,...e}=t;return(0,s.kt)(tPp,(0,p.Z)({},JRp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}nPp.isMDXComponent=!0;const ePp={toc:[]},oPp="wrapper";function pPp(t){let{components:n,...e}=t;return(0,s.kt)(oPp,(0,p.Z)({},ePp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}pPp.isMDXComponent=!0;const rPp={toc:[]},sPp="wrapper";function cPp(t){let{components:n,...e}=t;return(0,s.kt)(sPp,(0,p.Z)({},rPp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a compound property decorator."))}cPp.isMDXComponent=!0;const iPp={toc:[]},aPp="wrapper";function lPp(t){let{components:n,...e}=t;return(0,s.kt)(aPp,(0,p.Z)({},iPp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}lPp.isMDXComponent=!0;const uPp={toc:[]},mPp="wrapper";function dPp(t){let{components:n,...e}=t;return(0,s.kt)(mPp,(0,p.Z)({},uPp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}dPp.isMDXComponent=!0;const hPp={toc:[]},kPp="wrapper";function fPp(t){let{components:n,...e}=t;return(0,s.kt)(kPp,(0,p.Z)({},hPp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a computed method decorator."))}fPp.isMDXComponent=!0;const yPp={toc:[]},MPp="wrapper";function DPp(t){let{components:n,...e}=t;return(0,s.kt)(MPp,(0,p.Z)({},yPp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the initial value of a property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}DPp.isMDXComponent=!0;const XPp={toc:[]},_Pp="wrapper";function wPp(t){let{components:n,...e}=t;return(0,s.kt)(_Pp,(0,p.Z)({},XPp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}wPp.isMDXComponent=!0;const TPp={toc:[]},CPp="wrapper";function gPp(t){let{components:n,...e}=t;return(0,s.kt)(CPp,(0,p.Z)({},TPp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an initial signal value decorator."))}gPp.isMDXComponent=!0;const xPp={toc:[]},vPp="wrapper";function LPp(t){let{components:n,...e}=t;return(0,s.kt)(vPp,(0,p.Z)({},xPp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the property."))}LPp.isMDXComponent=!0;const ZPp={toc:[]},bPp="wrapper";function NPp(t){let{components:n,...e}=t;return(0,s.kt)(bPp,(0,p.Z)({},ZPp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.kt)("p",null,"By default, any property is inspectable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}NPp.isMDXComponent=!0;const APp={toc:[]},zPp="wrapper";function WPp(t){let{components:n,...e}=t;return(0,s.kt)(zPp,(0,p.Z)({},APp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}WPp.isMDXComponent=!0;const IPp={toc:[]},RPp="wrapper";function PPp(t){let{components:n,...e}=t;return(0,s.kt)(RPp,(0,p.Z)({},IPp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an inspectable property decorator."))}PPp.isMDXComponent=!0;const SPp={toc:[]},EPp="wrapper";function GPp(t){let{components:n,...e}=t;return(0,s.kt)(EPp,(0,p.Z)({},SPp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be inspectable."))}GPp.isMDXComponent=!0;const OPp={toc:[]},FPp="wrapper";function BPp(t){let{components:n,...e}=t;return(0,s.kt)(FPp,(0,p.Z)({},OPp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}BPp.isMDXComponent=!0;const UPp={toc:[]},VPp="wrapper";function qPp(t){let{components:n,...e}=t;return(0,s.kt)(VPp,(0,p.Z)({},UPp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}qPp.isMDXComponent=!0;const jPp={toc:[]},YPp="wrapper";function QPp(t){let{components:n,...e}=t;return(0,s.kt)(YPp,(0,p.Z)({},jPp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal interpolation function decorator."))}QPp.isMDXComponent=!0;const HPp={toc:[]},$Pp="wrapper";function KPp(t){let{components:n,...e}=t;return(0,s.kt)($Pp,(0,p.Z)({},HPp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function for the property."))}KPp.isMDXComponent=!0;const JPp={toc:[]},tSp="wrapper";function nSp(t){let{components:n,...e}=t;return(0,s.kt)(tSp,(0,p.Z)({},JPp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.kt)("p",null,"If the wrapper class has a method called ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}nSp.isMDXComponent=!0;const eSp={toc:[]},oSp="wrapper";function pSp(t){let{components:n,...e}=t;return(0,s.kt)(oSp,(0,p.Z)({},eSp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}pSp.isMDXComponent=!0;const rSp={toc:[]},sSp="wrapper";function cSp(t){let{components:n,...e}=t;return(0,s.kt)(sSp,(0,p.Z)({},rSp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal parser decorator."))}cSp.isMDXComponent=!0;const iSp={toc:[]},aSp="wrapper";function lSp(t){let{components:n,...e}=t;return(0,s.kt)(aSp,(0,p.Z)({},iSp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}lSp.isMDXComponent=!0;const uSp={toc:[]},mSp="wrapper";function dSp(t){let{components:n,...e}=t;return(0,s.kt)(mSp,(0,p.Z)({},uSp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given property into a signal."),(0,s.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}dSp.isMDXComponent=!0;const hSp={toc:[]},kSp="wrapper";function fSp(t){let{components:n,...e}=t;return(0,s.kt)(kSp,(0,p.Z)({},hSp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}fSp.isMDXComponent=!0;const ySp={toc:[]},MSp="wrapper";function DSp(t){let{components:n,...e}=t;return(0,s.kt)(MSp,(0,p.Z)({},ySp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal decorator."))}DSp.isMDXComponent=!0;const XSp={toc:[]},_Sp="wrapper";function wSp(t){let{components:n,...e}=t;return(0,s.kt)(_Sp,(0,p.Z)({},XSp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}wSp.isMDXComponent=!0;const TSp={toc:[]},CSp="wrapper";function gSp(t){let{components:n,...e}=t;return(0,s.kt)(CSp,(0,p.Z)({},TSp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}gSp.isMDXComponent=!0;const xSp={toc:[]},vSp="wrapper";function LSp(t){let{components:n,...e}=t;return(0,s.kt)(vSp,(0,p.Z)({},xSp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal wrapper decorator."))}LSp.isMDXComponent=!0;const ZSp={toc:[]},bSp="wrapper";function NSp(t){let{components:n,...e}=t;return(0,s.kt)(bSp,(0,p.Z)({},ZSp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}NSp.isMDXComponent=!0;const ASp={toc:[]},zSp="wrapper";function WSp(t){let{components:n,...e}=t;return(0,s.kt)(zSp,(0,p.Z)({},ASp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unified abstraction for all CSS filters."))}WSp.isMDXComponent=!0;const ISp={toc:[]},RSp="wrapper";function PSp(t){let{components:n,...e}=t;return(0,s.kt)(RSp,(0,p.Z)({},ISp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the desired length is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}PSp.isMDXComponent=!0;const SSp={toc:[]},ESp="wrapper";function GSp(t){let{components:n,...e}=t;return(0,s.kt)(ESp,(0,p.Z)({},SSp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}GSp.isMDXComponent=!0;const OSp={toc:[]},FSp="wrapper";function BSp(t){let{components:n,...e}=t;return(0,s.kt)(FSp,(0,p.Z)({},OSp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can be either:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'"))))}BSp.isMDXComponent=!0;const USp={toc:[]},VSp="wrapper";function qSp(t){let{components:n,...e}=t;return(0,s.kt)(VSp,(0,p.Z)({},USp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length used by most layout properties."))}qSp.isMDXComponent=!0;const jSp={toc:[]},YSp="wrapper";function QSp(t){let{components:n,...e}=t;return(0,s.kt)(YSp,(0,p.Z)({},jSp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,s.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}QSp.isMDXComponent=!0;const HSp={toc:[]},$Sp="wrapper";function KSp(t){let{components:n,...e}=t;return(0,s.kt)($Sp,(0,p.Z)({},HSp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}KSp.isMDXComponent=!0;const JSp={toc:[]},tEp="wrapper";function nEp(t){let{components:n,...e}=t;return(0,s.kt)(tEp,(0,p.Z)({},JSp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in pixels."))}nEp.isMDXComponent=!0;const eEp={toc:[]},oEp="wrapper";function pEp(t){let{components:n,...e}=t;return(0,s.kt)(oEp,(0,p.Z)({},eEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}pEp.isMDXComponent=!0;const rEp={toc:[]},sEp="wrapper";function cEp(t){let{components:n,...e}=t;return(0,s.kt)(sEp,(0,p.Z)({},rEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}cEp.isMDXComponent=!0;const iEp={toc:[]},aEp="wrapper";function lEp(t){let{components:n,...e}=t;return(0,s.kt)(aEp,(0,p.Z)({},iEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}lEp.isMDXComponent=!0;const uEp={toc:[]},mEp="wrapper";function dEp(t){let{components:n,...e}=t;return(0,s.kt)(mEp,(0,p.Z)({},uEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}dEp.isMDXComponent=!0;const hEp={toc:[]},kEp="wrapper";function fEp(t){let{components:n,...e}=t;return(0,s.kt)(kEp,(0,p.Z)({},hEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}fEp.isMDXComponent=!0;const yEp={toc:[]},MEp="wrapper";function DEp(t){let{components:n,...e}=t;return(0,s.kt)(MEp,(0,p.Z)({},yEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}DEp.isMDXComponent=!0;const XEp={toc:[]},_Ep="wrapper";function wEp(t){let{components:n,...e}=t;return(0,s.kt)(_Ep,(0,p.Z)({},XEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}wEp.isMDXComponent=!0;const TEp={toc:[]},CEp="wrapper";function gEp(t){let{components:n,...e}=t;return(0,s.kt)(CEp,(0,p.Z)({},TEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in degrees."))}gEp.isMDXComponent=!0;const xEp={toc:[]},vEp="wrapper";function LEp(t){let{components:n,...e}=t;return(0,s.kt)(vEp,(0,p.Z)({},xEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}LEp.isMDXComponent=!0;const ZEp={toc:[]},bEp="wrapper";function NEp(t){let{components:n,...e}=t;return(0,s.kt)(bEp,(0,p.Z)({},ZEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}NEp.isMDXComponent=!0;const AEp={toc:[]},zEp="wrapper";function WEp(t){let{components:n,...e}=t;return(0,s.kt)(zEp,(0,p.Z)({},AEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}WEp.isMDXComponent=!0;const IEp={toc:[]},REp="wrapper";function PEp(t){let{components:n,...e}=t;return(0,s.kt)(REp,(0,p.Z)({},IEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}PEp.isMDXComponent=!0;const SEp={toc:[]},EEp="wrapper";function GEp(t){let{components:n,...e}=t;return(0,s.kt)(EEp,(0,p.Z)({},SEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}GEp.isMDXComponent=!0;const OEp={toc:[]},FEp="wrapper";function BEp(t){let{components:n,...e}=t;return(0,s.kt)(FEp,(0,p.Z)({},OEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}BEp.isMDXComponent=!0;const UEp={toc:[]},VEp="wrapper";function qEp(t){let{components:n,...e}=t;return(0,s.kt)(VEp,(0,p.Z)({},UEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}qEp.isMDXComponent=!0;const jEp={toc:[]},YEp="wrapper";function QEp(t){let{components:n,...e}=t;return(0,s.kt)(YEp,(0,p.Z)({},jEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}QEp.isMDXComponent=!0;const HEp={toc:[]},$Ep="wrapper";function KEp(t){let{components:n,...e}=t;return(0,s.kt)($Ep,(0,p.Z)({},HEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}KEp.isMDXComponent=!0;const JEp={toc:[]},tGp="wrapper";function nGp(t){let{components:n,...e}=t;return(0,s.kt)(tGp,(0,p.Z)({},JEp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}nGp.isMDXComponent=!0;const eGp={toc:[]},oGp="wrapper";function pGp(t){let{components:n,...e}=t;return(0,s.kt)(oGp,(0,p.Z)({},eGp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a predicate that checks if the given object is an instance of the\ngiven class."))}pGp.isMDXComponent=!0;const rGp={toc:[]},sGp="wrapper";function cGp(t){let{components:n,...e}=t;return(0,s.kt)(sGp,(0,p.Z)({},rGp,e,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class to check against."))}function iGp(t){let{id:n}=t;const e=o[n]??r.Fragment;return r.createElement(e,null)}cGp.isMDXComponent=!0},9322:(t,n,e)=>{e.d(n,{Z:()=>a});var o=e(8698),p=e(4237),r=e(8770),s=e(6277),c=e(2784);const i={toggle:"toggle_S_IX",collapsed:"collapsed_wdUB",collapse:"collapse_TjTN",inverse:"inverse_g6vW",clearFix:"clearFix_HQ1T"};function a(t){let{comment:n,full:e=!0}=t;const o=(0,c.useMemo)((()=>n?.blockTags?.find((t=>{let{tag:n}=t;return"@remarks"===n}))),[n]);return c.createElement(c.Fragment,null,e&&c.createElement(l,{comment:n}),c.createElement(p.Z,{id:n?.summaryId}),c.createElement(p.Z,{id:o?.contentId}),e&&c.createElement(u,{comment:n}))}function l(t){let{comment:n}=t;return(0,c.useMemo)((()=>n?.modifierTags?.includes("@experimental")),[n])?c.createElement(r.Z,null):null}function u(t){let{comment:n}=t;const[e,r]=(0,c.useState)(!0),a=(0,c.useMemo)((()=>n?.blockTags?.find((t=>{let{tag:n}=t;return"@preview"===n}))),[n]),l=(0,c.useMemo)((()=>n?.blockTags?.filter((t=>{let{tag:n}=t;return"@example"===n}))??[]),[n]),u=(0,c.useMemo)((()=>n?.blockTags?.find((t=>{let{tag:n}=t;return"@defaultValue"===n}))),[n]),m=(0,c.useMemo)((()=>n?.blockTags?.find((t=>{let{tag:n}=t;return"@deprecated"===n}))),[n]),d=(0,c.useMemo)((()=>n?.blockTags?.find((t=>{let{tag:n}=t;return"@see"===n}))),[n]);return c.createElement(c.Fragment,null,c.createElement(p.Z,{id:a?.contentId}),l.length>0&&c.createElement(c.Fragment,null,c.createElement("h4",null,c.createElement("a",{className:(0,s.Z)(i.toggle,e&&i.collapsed),onClick:t=>{t.preventDefault(),r(!e)},href:"#"},"Examples")),c.createElement(o.z,{lazy:!0,as:"div",collapsed:e},c.createElement("div",{className:i.collapse},l.map((t=>c.createElement(p.Z,{key:t.contentId,id:t.contentId})))),c.createElement("div",{className:i.clearFix})),c.createElement("div",{className:(0,s.Z)(i.clearFix,i.inverse)})),u&&c.createElement(c.Fragment,null,"Default Value:"," ",c.createElement("code",null,u.content.map((t=>t.text)).join(""))),m&&c.createElement(c.Fragment,null,c.createElement("h4",null,"Deprecated"),c.createElement(p.Z,{id:m.contentId})),d&&c.createElement(c.Fragment,null,c.createElement("h4",null,"See also"),c.createElement(p.Z,{id:d.contentId})))}},2830:(t,n,e)=>{e.d(n,{Z:()=>wt});var o=e(8569),p=e(6835),r=e(7896),s=e(2784);function c(t){let{width:n=24,height:e=24,...o}=t;return s.createElement("svg",(0,r.Z)({width:n,height:e,"aria-hidden":"true",viewBox:"0 0 24 24"},o),s.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}const i={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var a=e(68),l=e(6277);function u(t){let{children:n,highlight:e,onClick:r,link:u}=t;const m=(0,p.F)(),d=(0,a.s2)();return s.createElement("div",{className:(0,l.Z)(o.Z.codeBlockContent,i.codeBlock,e&&i.highlight,r&&i.pointer)},s.createElement("pre",{onClick:r,onKeyDown:t=>{"Enter"===t.key&&r?.()},tabIndex:0,ref:m.codeBlockRef,className:(0,l.Z)(o.Z.codeBlock,"thin-scrollbar")},s.createElement("code",{className:o.Z.codeBlockLines,style:d},n)),u&&s.createElement("div",{className:o.Z.buttonGroup},s.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(u,"_blank")}},s.createElement(c,{width:18,height:18}))))}var m=e(9318);function d(t){let{children:n}=t;return s.createElement(m.Z,{as:"div",className:(0,l.Z)(i.codeBlockContainer,"language-typescript")},n)}function h(t){let{children:n}=t;const e=(0,s.useRef)();return(0,s.useLayoutEffect)((()=>{if(!e.current)return;const t=e.current.closest("pre");if(t.scrollWidth>t.clientWidth){const n=Array.from(e.current.querySelectorAll(`.${i.elements}`)).sort(((t,n)=>function(t,n){return t>n?1:t<n?-1:0}(n.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&n.length>0;)n.shift().classList.add(i.wrap)}})),s.createElement(s.Fragment,null,n&&s.createElement("span",{ref:e,className:(0,l.Z)(i.line,"token-line")},n),s.createElement("br",null))}var k=e(9322),f=e(7390);function y(t){let{width:n=24,height:e=24,...o}=t;return s.createElement("svg",(0,r.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},o),s.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}var M=e(7708);const D={header:"header_nSmr",filters:"filters_z1iC",icon:"icon_ROIU"};function X(){const t=(0,s.useRef)(null),[n,e]=(0,s.useState)(!1),[o,p]=(0,M.mN)();return(0,s.useEffect)((()=>{const n=n=>{t.current&&!t.current.contains(n.target)&&e(!1)};return document.addEventListener("mousedown",n),document.addEventListener("touchstart",n),()=>{document.removeEventListener("mousedown",n),document.removeEventListener("touchstart",n)}}),[t]),s.createElement(s.Fragment,null,s.createElement("div",{ref:t,className:(0,l.Z)("dropdown dropdown--right margin-bottom--md",n&&"dropdown--show")},s.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),e(!n)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),e(!n))}},"Filters",s.createElement(y,{className:D.icon})),s.createElement("ul",{className:"dropdown__menu"},s.createElement("li",null,s.createElement("label",{htmlFor:"private",className:(0,l.Z)("dropdown__link",o.private&&"dropdown__link--active")},s.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:o.private,onChange:t=>{p({...o,private:t.target.checked})}}),"Protected members")),s.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&e(!1)}},s.createElement("label",{htmlFor:"inherited",className:(0,l.Z)("dropdown__link",o.inherited&&"dropdown__link--active")},s.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:o.inherited,onChange:t=>{p({...o,inherited:t.target.checked})}}),"Inherited members")))))}function _(t){let{children:n,kind:e}=t;return e===f.W.Class||e===f.W.Interface?s.createElement("div",{className:(0,l.Z)("row",D.header)},s.createElement("div",{className:(0,l.Z)("col",D.filters)},s.createElement(X,null)),s.createElement("div",{className:"col"},n)):s.createElement(s.Fragment,null,n)}var w=e(3181),T=e(9817);function C(t){let{children:n,type:e,to:o,id:p,tooltip:c}=t;const i=(0,a.Ld)(e);return o?s.createElement(T.Z,(0,r.Z)({id:p,to:o,"data-tooltip":c},i),n):s.createElement("span",(0,r.Z)({id:p},i),n)}let g=function(t){return t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses",t}({}),x=function(t){return t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & ",t}({});const v={[g.None]:i.none,[g.Angle]:i.angle,[g.Curly]:i.curly,[g.Square]:i.square,[g.Parentheses]:i.parentheses};function L(t){let{children:n,type:e,separator:o=x.Comma}=t;return s.createElement("span",{className:(0,l.Z)(i.list,v[e??g.None])},s.createElement("span",{className:(0,l.Z)(i.elements,o!==x.Comma&&i.left)},(Array.isArray(n)?n:[n]).flatMap(((t,n)=>s.createElement("span",{"data-separator":o,key:n,className:i.element},t)))))}function Z(t){let{type:n}=t;return s.createElement(s.Fragment,null,s.createElement(ot,{type:n.elementType}),"[]")}function b(t){let{type:n}=t;return s.createElement(s.Fragment,null,s.createElement(ot,{type:n.checkType}),s.createElement(C,{type:"keyword"}," extends "),s.createElement(ot,{type:n.extendsType})," ? ",s.createElement(ot,{type:n.trueType})," : ",s.createElement(ot,{type:n.falseType}))}function N(t){let{type:n}=t;return s.createElement(s.Fragment,null,s.createElement(ot,{type:n.objectType}),"[",s.createElement(ot,{type:n.indexType}),"]")}function A(t){let{type:n}=t;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"infer "),s.createElement(C,{type:"constant"},n.name))}function z(t){let{type:n}=t;return s.createElement(L,{type:g.Parentheses,separator:x.Ampersand},n.types.map(((t,n)=>s.createElement(ot,{key:n,type:t}))))}function W(t){let{type:n}=t;return s.createElement(C,{type:"keyword"},n.name)}function I(t){let{type:n}=t;const[e,o]=(0,s.useMemo)((()=>{if(null===n.value)return["null","keyword"];switch(typeof n.value){case"object":return[(n.value.negative?"-":"")+n.value.value,"number"];case"boolean":return[n.value,"keyword"];case"number":return[n.value,"number"];case"string":return[`'${n.value}'`,"string"];default:return[n.value,"constant"]}}),[n.value]);return s.createElement(C,{type:o},e)}function R(t){let{type:n}=t;return s.createElement(s.Fragment,null,s.createElement(L,{type:g.Curly},s.createElement(s.Fragment,null,"[",s.createElement(C,{type:"class"},n.parameter),s.createElement(C,{type:"keyword"}," in "),s.createElement(ot,{type:n.parameterType}),"]: ",s.createElement(ot,{type:n.templateType}))))}function P(t){let{type:n}=t;return s.createElement(s.Fragment,null,n.name,": ",s.createElement(ot,{type:n.element}))}function S(t){let{type:n}=t;return n.asserts?s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"asserts "),s.createElement(C,null,n.name," ")):s.createElement(s.Fragment,null,s.createElement(C,null,n.name," "),s.createElement(C,{type:"keyword"},"is "),s.createElement(ot,{type:n.targetType}))}function E(t){let{type:n}=t;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"typeof "),s.createElement(ot,{type:n.queryType}))}function G(t){let{flags:n,explicitAccessModifier:e}=t;const o=[];return n?.isAbstract&&o.push("abstract"),n?.isStatic&&o.push("static"),n?.isConst&&o.push("const"),n?.isReadonly&&o.push("readonly"),n?.isPrivate&&o.push("private"),n?.isProtected&&o.push("protected"),(n?.isPublic||e&&!n?.isProtected&&!n?.isPrivate)&&o.push("public"),s.createElement(s.Fragment,null,o.map((t=>s.createElement(C,{key:t,type:"keyword"},t," "))))}function O(t){let{reflection:n}=t;return s.createElement(s.Fragment,null,s.createElement(G,{flags:n.flags}),n.varianceModifier&&s.createElement(C,{type:"keyword"},n.varianceModifier," "),s.createElement(C,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"class-name"},n.name),n.type&&s.createElement(s.Fragment,null," extends ",s.createElement(ot,{type:n.type})),n.default&&s.createElement(s.Fragment,null," = ",s.createElement(ot,{type:n.default})))}var F=e(8617);const B={[f.W.Namespace]:"namespace",[f.W.Enum]:"enum",[f.W.Class]:"class",[f.W.Interface]:"interface"};function U(t){let{reflection:n}=t;const e=(0,F.in)();return s.createElement(s.Fragment,null,s.createElement(G,{flags:n.flags}),s.createElement(C,{type:"keyword"},B[n.kind]," "),s.createElement(C,{type:"class-name"},n.name),!!n.typeParameters?.length&&s.createElement(L,{type:g.Angle},n.typeParameters.map((t=>s.createElement(O,{key:t.id,reflection:e(t)}))))," ",!!n.extendedTypes?.length&&s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"extends "),s.createElement(L,null,n.extendedTypes.map(((t,n)=>s.createElement(ot,{key:n,type:t}))))),!!n.implementedTypes?.length&&s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"implements "),s.createElement(L,null,n.implementedTypes.map(((t,n)=>s.createElement(ot,{key:n,type:t}))))))}function V(t){let{reflection:n}=t;const e="__namedParameters"===n.name?"{...}":n.name;return s.createElement(s.Fragment,null,s.createElement(G,{flags:n.flags}),n.flags.isRest&&"...",s.createElement(C,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"plain"},e),n.flags.isOptional&&"?",": ",n.type&&s.createElement(ot,{type:n.type}),n.defaultValue&&s.createElement(s.Fragment,null," = ",s.createElement(C,{type:"plain"},n.defaultValue)))}function q(t){let{reflection:n,flags:e}=t;const o=(0,F.in)(),p="__type"===n.name;return s.createElement(s.Fragment,null,s.createElement(G,{flags:e??n.flags,explicitAccessModifier:!p}),n.kind===f.W.GetSignature&&s.createElement(C,{type:"keyword"},"get "),n.kind===f.W.SetSignature&&s.createElement(C,{type:"keyword"},"set "),n.overwrites&&s.createElement(s.Fragment,null,s.createElement(C,{to:n.overwrites.externalUrl??(0,F.Gr)(o(n.overwrites.id)),type:"keyword"},"override")," "),n.kind===f.W.ConstructorSignature?s.createElement(s.Fragment,null,s.createElement(C,{to:"#",type:"keyword"},"new")," ",s.createElement(C,{type:"plain"},n.type.name)):p?"":s.createElement(C,{type:"function"},n.name),!!n.typeParameter?.length&&s.createElement(L,{type:g.Angle},n.typeParameter.map((t=>s.createElement(O,{key:t.id,reflection:o(t)})))),n.parameters?.length?s.createElement(L,{type:g.Parentheses},n.parameters.map((t=>s.createElement(V,{key:t,reflection:o(t)})))):"()",n.type&&s.createElement(s.Fragment,null,p?" => ":": ",s.createElement(ot,{type:n.type})))}function j(t){let{reflection:n}=t;const e=n.signatures?.[0]??n.getSignature??n.setSignature??n.indexSignature;return s.createElement(q,{reflection:e})}function Y(t){let{reflection:n}=t;return s.createElement(V,{reflection:n})}function Q(t){let{reflection:n}=t;const e=(0,F.in)();return s.createElement(s.Fragment,null,s.createElement(G,{flags:n.flags}),s.createElement(C,{type:"keyword"},"type "),s.createElement(C,{type:"class-name"},n.name),n.typeParameters&&s.createElement(L,{type:g.Angle},n.typeParameters.map((t=>s.createElement(O,{key:t.id,reflection:e(t)}))))," = ",s.createElement(ot,{type:n.type}))}function H(t){let{reflection:n}=t;const e=(0,F.in)();return n.signatures?s.createElement(q,{reflection:n.signatures[0]}):n.children?s.createElement(L,{type:g.Curly},n.children.map((t=>s.createElement($,{key:t.id,reflection:e(t)})))):s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"unknown"))}function $(t){let{reflection:n}=t;const e=(0,s.useMemo)((()=>{switch(n.kind){case f.W.Project:case f.W.Module:case f.W.EnumMember:case f.W.Variable:case f.W.Function:break;case f.W.Namespace:case f.W.Enum:case f.W.Class:case f.W.Interface:return U;case f.W.Constructor:return q;case f.W.Property:return Y;case f.W.Method:return j;case f.W.CallSignature:case f.W.IndexSignature:case f.W.ConstructorSignature:case f.W.Parameter:break;case f.W.TypeLiteral:return H;case f.W.TypeParameter:return O;case f.W.Accessor:case f.W.GetSignature:case f.W.SetSignature:case f.W.ObjectLiteral:break;case f.W.TypeAlias:return Q;case f.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.id]);return s.createElement(e,{reflection:n})}function K(t){let{type:n}=t;const e=(0,F.in)();return s.createElement($,{reflection:e(n.declaration)})}function J(t){let{type:n}=t;return s.createElement(s.Fragment,null,s.createElement(C,{type:"string"},"`",n.head),n.tail.map(((t,n)=>{let[e,o]=t;return s.createElement(s.Fragment,null,"${",s.createElement(ot,{key:n,type:e}),"}",s.createElement(C,{type:"string"},o))})),s.createElement(C,{type:"string"},"`"))}function tt(t){let{type:n}=t;return n.elements?s.createElement(L,{type:g.Square},n.elements.map(((t,n)=>s.createElement(ot,{key:n,type:t})))):s.createElement(s.Fragment,null,"[]")}function nt(t){let{type:n}=t;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},n.operator," "),s.createElement(ot,{type:n.target}))}function et(t){let{type:n}=t;return s.createElement(L,{type:g.Parentheses,separator:x.Pipe},n.types.map(((t,n)=>s.createElement(ot,{key:n,type:t}))))}function ot(t){const n=(0,s.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return nt;case"conditional":return b;case"reflection":return K;case"query":return E;case"named-tuple-member":return P;case"union":return et;case"intrinsic":return W;case"literal":return I;case"reference":return pt;case"predicate":return S;case"tuple":return tt;case"array":return Z;case"intersection":return z;case"inferred":return A;case"mapped":return R;case"template-literal":return J;case"indexedAccess":return N}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return s.createElement(n,t)}function pt(t){let{type:n}=t;const e=(0,F.RU)(n.project),o=e?.[n.id],p=n.externalUrl??(0,F.Gr)(o);return s.createElement(s.Fragment,null,s.createElement(C,{to:p,type:p?"class-name":"constant",tooltip:!0},n.name),!!n.typeArguments?.length&&s.createElement(L,{type:g.Angle},n.typeArguments.map(((t,n)=>s.createElement(ot,{key:n,type:t})))))}function rt(t){let{group:n}=t;return"Constructors"===n.title&&0===n.external.length&&1===n.nested.length?s.createElement(wt,{reflection:n.nested[0]}):s.createElement(s.Fragment,null,n.external.length>0&&s.createElement("ul",null,n.external.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(pt,{type:t})))))),n.nested.length>0&&n.nested.map(((t,n)=>s.createElement(s.Fragment,{key:t.id},n>0&&s.createElement("hr",null),s.createElement(wt,{reflection:t})))))}var st=e(3851),ct=e(2009),it=e(7336);function at(t){let{group:n,project:e}=t;const o=(0,w.TH)(),p=(0,F.RU)(e),r=o.hash.split("-")[0].slice(1),[c]=(0,M.mN)(),i=(0,s.useMemo)((()=>(n.categories??[n]).map((t=>function(t,n,e){const o=[],p=[],r=[];for(const s of t.children){const t=n[s];t&&(0,M.It)(e,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,p,c))).filter((t=>!!t))),[n,p,c]);return(0,s.useEffect)((()=>{if(1===i.length)return;const t=o.hash.split("-")[0].slice(1);for(const n of i)if(n.anchors.includes(t))return}),[o.hash,i]),0===i.length?s.createElement(s.Fragment,null):s.createElement(s.Fragment,null,s.createElement(st.Z,{as:"h2",id:n.title},n.title),i.length>1?s.createElement(it.Z,{groupId:n.title},i.map((t=>s.createElement(ct.Z,{default:t.anchors.includes(r),value:t.title,label:t.title,className:"margin-top--lg"},s.createElement(rt,{group:t}))))):s.createElement(rt,{group:i[0]}))}var lt=e(4237);function ut(t){let{parameters:n}=t;const e=(0,F.in)(),o=(0,s.useMemo)((()=>n?.map(e)),[n]);return o?.length?s.createElement(s.Fragment,null,s.createElement("h4",null,"Parameters"),s.createElement("ul",null,o.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(V,{reflection:t})),s.createElement(lt.Z,{id:t.comment?.summaryId})))))):s.createElement(s.Fragment,null)}function mt(t){let{parameters:n}=t;const e=(0,F.in)(),o=(0,s.useMemo)((()=>n?.map(e)),[n]);return o?.length?s.createElement(s.Fragment,null,s.createElement("h4",null,"Type Parameters"),s.createElement("ul",null,o.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(O,{reflection:t})),s.createElement(lt.Z,{id:t.comment?.summaryId})))))):s.createElement(s.Fragment,null)}function dt(t){let{signatures:n,flags:e,source:o}=t;const p=(0,F.in)(),r=(0,s.useMemo)((()=>n.map(p)),[n]),[c,i]=(0,s.useState)(r[0]);return s.createElement(s.Fragment,null,s.createElement(d,null,r.map((t=>s.createElement(u,{link:o?.url,key:t.id,highlight:n.length>1&&t.id===c.id,onClick:n.length>1?()=>i(t):void 0},s.createElement(h,null,s.createElement(q,{reflection:t,flags:e})))))),s.createElement(k.Z,{comment:c.comment}),s.createElement(mt,{parameters:c.typeParameter}),s.createElement(ut,{parameters:c.parameters}))}function ht(t){let{reflection:n}=t;return s.createElement(s.Fragment,null,s.createElement(d,null,s.createElement(u,{link:n.sources?.[0]?.url},s.createElement(h,null,s.createElement($,{reflection:n})))),s.createElement(_,{kind:n.kind},s.createElement(k.Z,{comment:n.comment})),s.createElement(mt,{parameters:n.typeParameters}),n.implementedBy?.length&&s.createElement(s.Fragment,null,s.createElement("h4",null,"Implemented by"),s.createElement("ul",null,n.implementedBy.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(pt,{type:t}))))))),n.extendedBy?.length&&s.createElement(s.Fragment,null,s.createElement("h4",null,"Extended by"),s.createElement("ul",null,n.extendedBy.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(pt,{type:t}))))))),n.signatures&&s.createElement(s.Fragment,null,s.createElement("h2",null,"Callable"),s.createElement(dt,{signatures:n.signatures})),n.groups?.map((t=>s.createElement(at,{group:t,key:t.title,project:n.project}))))}function kt(t){let{reflection:n,headless:e}=t;const o=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((t=>!!t));return s.createElement(s.Fragment,null,!e&&(n.hasOwnPage?s.createElement("h1",null,n.name):s.createElement(st.Z,{as:"h3",id:n.anchor},s.createElement("code",null,n.name))),s.createElement(dt,{signatures:o,flags:n.flags,source:n.sources?.[0]}),n.inheritedFrom&&s.createElement("small",null,"Inherited from"," ",s.createElement("code",null,s.createElement(pt,{type:n.inheritedFrom}))),n.overwrites&&s.createElement("small",null,"Overwrites"," ",s.createElement("code",null,s.createElement(pt,{type:n.overwrites}))))}var ft=e(6109);function yt(t){let{reflection:n}=t;return s.createElement(s.Fragment,null,s.createElement(ft.Z,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),s.createElement(_,{kind:n.kind},s.createElement(k.Z,{comment:n.comment})),n.groups?.map((t=>s.createElement(at,{group:t,key:t.title,project:n.project}))))}const Mt={cardContainer:"cardContainer_ybwo",cardTitle:"cardTitle_Ehd1",cardDescription:"cardDescription_b6wr"};function Dt(t){let{reflection:n}=t;const e=(0,F.RU)(n.project),o=n.groups[0].children.map((t=>e[t])).filter((t=>!!t));return s.createElement("article",{className:"margin-top--lg"},s.createElement("section",{className:(0,l.Z)("row")},o.map((t=>s.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},s.createElement(T.Z,{href:t.href,className:(0,l.Z)("card padding--lg",Mt.cardContainer)},s.createElement("h2",{className:(0,l.Z)("text--truncate",Mt.cardTitle)},s.createElement("code",null,t.name)),s.createElement("div",{className:(0,l.Z)("text--truncate",Mt.cardDescription)},t.comment?.summaryText??"\xa0")))))))}function Xt(t){let{reflection:n,headless:e}=t;return s.createElement(s.Fragment,null,!e&&(n.hasOwnPage?s.createElement("h1",null,n.name):s.createElement(st.Z,{as:"h3",id:n.anchor},s.createElement("code",null,n.name))),s.createElement(d,null,s.createElement(u,{link:n.sources?.[0]?.url},s.createElement(h,null,s.createElement(Y,{reflection:n})))),s.createElement(k.Z,{comment:n.comment}),n.inheritedFrom&&s.createElement("small",null,"Inherited from"," ",s.createElement("code",null,s.createElement(pt,{type:n.inheritedFrom}))))}function _t(t){let{reflection:n}=t;const e=(0,F.RU)(n.project);return s.createElement(s.Fragment,null,s.createElement(st.Z,{as:"h3",id:n.anchor},s.createElement("code",null,n.name)),s.createElement(d,null,s.createElement(u,{link:n.sources?.[0]?.url},s.createElement(h,null,s.createElement($,{reflection:n})))),s.createElement(k.Z,{comment:n.comment}),s.createElement(mt,{parameters:n.typeParameters}),n.signatures&&s.createElement(s.Fragment,null,s.createElement("h2",null,"Callable"),s.createElement(dt,{signatures:n.signatures})),n.groups?.map((t=>s.createElement(s.Fragment,{key:t.title},s.createElement("h2",null,t.title),t.children.map((t=>e[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>s.createElement(wt,{key:t.id,reflection:t})))))))}function wt(t){let{reflection:n,headless:e=!1}=t;const o=(0,s.useMemo)((()=>{switch(n.kind){case f.W.Project:return Dt;case f.W.Module:return yt;case f.W.Namespace:case f.W.Enum:case f.W.Class:case f.W.Interface:return ht;case f.W.Function:case f.W.Accessor:case f.W.Constructor:case f.W.Method:return kt;case f.W.Variable:case f.W.Property:case f.W.EnumMember:return Xt;case f.W.CallSignature:case f.W.IndexSignature:case f.W.ConstructorSignature:case f.W.Parameter:case f.W.TypeLiteral:case f.W.TypeParameter:case f.W.GetSignature:case f.W.SetSignature:case f.W.ObjectLiteral:break;case f.W.TypeAlias:return _t;case f.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.kind]);return s.createElement(o,{reflection:n,headless:e})}},7390:(t,n,e)=>{e.d(n,{W:()=>o});let o=function(t){return t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference",t}({})},8770:(t,n,e)=>{e.d(n,{Z:()=>s});var o=e(9817),p=e(6047),r=e(2784);function s(){return r.createElement(p.Z,{type:"experimental"},"This is an ",r.createElement(o.Z,{to:"/docs/experimental"},"experimental feature"),". The behavior and API may change drastically between minor releases.")}},8617:(t,n,e)=>{e.d(n,{Gr:()=>a,RU:()=>s,gs:()=>r,in:()=>c,rG:()=>i});var o=e(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:n,lookup:e,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:e,urlLookup:r}},n)}function s(t){const{lookup:n}=(0,o.useContext)(p);return n[t]}function c(){const{lookup:t}=(0,o.useContext)(p);return n=>{if("number"==typeof n?.project)return t[n.project][n.id]}}function i(){const{urlLookup:t,lookup:n}=(0,o.useContext)(p);return e=>{const o=t[e];return o?n[o.projectId]?.[o.id]??null:null}}function a(t){if(t)return t.href}},68:(t,n,e)=>{e.d(n,{Ld:()=>c,Y0:()=>s,s2:()=>i});var o=e(822),p=e(2784);const r=p.createContext(null);function s(t){let{children:n}=t;const e=(0,o.p)(),s=(0,p.useMemo)((()=>function(t,n){const{plain:e}=t,o=Object.create(null),p=t.styles.reduce(((t,e)=>{const{languages:o,style:p}=e;return o&&!o.includes(n)||e.types.forEach((n=>{t[n]={...t[n],...p}})),t}),o);return p.root=e,p.plain={...e,backgroundColor:null},p}(e,"typescript")),[e]);return p.createElement(r.Provider,{value:s},n)}function c(t){void 0===t&&(t="plain");const n=(0,p.useContext)(r);return{className:`token ${t}`,style:n[t]??n.plain}}function i(t){void 0===t&&(t="plain");const n=(0,p.useContext)(r);return n[t]??n.plain}},7708:(t,n,e)=>{e.d(n,{It:()=>m,Wy:()=>l,mN:()=>u});var o=e(1263),p=e(9741),r=e(2784);const s="api-filters",c=o.Z.canUseDOM?localStorage.getItem(s):null,i=c?JSON.parse(c):{inherited:!0,private:!1},a=r.createContext([i,()=>{}]);function l(t){let{children:n}=t;const[e,o]=(0,r.useState)(i),c=(0,p.Z)();return r.createElement(a.Provider,{value:[e,t=>{c&&localStorage.setItem(s,JSON.stringify(t)),o(t)}]},n)}function u(){return(0,r.useContext)(a)}function m(t,n){const e=n.flags?.isPrivate||n.flags?.isProtected;if(!t.private&&e)return!1;const o=!!n.inheritedFrom;return!(!t.inherited&&o)}},6047:(t,n,e)=>{e.d(n,{Z:()=>m});var o=e(7896),p=e(8046),r=e(2784);function s(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"}))}function c(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"}))}function i(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}))}function a(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"}))}var l=e(9055);const u={icon:"icon_Fw4I"};function m(t){let{title:n,type:e,...m}=t;const d=(0,r.useMemo)((()=>{switch(e){case"tip":return i;case"caution":return a;case"danger":return s;case"experimental":return p.Z;default:return c}}),[e]);return"experimental"===e&&(n??="Experimental",e="caution"),r.createElement(r.Fragment,null,r.createElement(l.Z,(0,o.Z)({icon:r.createElement(d,{className:u.icon}),title:n,type:e},m)))}},5192:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>u});var o=e(7896),p=(e(2784),e(876)),r=e(2072),s=e(2665);const c={sidebar_position:10,slug:"/transitions"},i="Transitions",a={unversionedId:"getting-started/transitions",id:"getting-started/transitions",title:"Transitions",description:"Transitions allow you to customize the way scenes transition from one into",source:"@site/docs/getting-started/transitions.mdx",sourceDirName:"getting-started",slug:"/transitions",permalink:"/docs/transitions",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/transitions.mdx",tags:[],version:"current",lastUpdatedBy:"Ashish Baravaliya",sidebarPosition:10,frontMatter:{sidebar_position:10,slug:"/transitions"},sidebar:"docs",previous:{title:"Time Events",permalink:"/docs/time-events"},next:{title:"Logging",permalink:"/docs/logging"}},l={},u=[{value:"Before we start",id:"before-we-start",level:2},{value:"Pre-made transitions",id:"pre-made-transitions",level:2},{value:"<code>slideTransition</code>",id:"slidetransition",level:3},{value:"<code>zoomInTransition</code>",id:"zoomintransition",level:3},{value:"<code>zoomOutTransition</code>",id:"zoomouttransition",level:3},{value:"<code>fadeTransition</code>",id:"fadetransition",level:3},{value:"Custom transitions",id:"custom-transitions",level:2},{value:"Animate when transitioning",id:"animate-when-transitioning",level:2}],m={toc:u},d="wrapper";function h(t){let{components:n,...e}=t;return(0,p.kt)(d,(0,o.Z)({},m,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"transitions"},"Transitions"),(0,p.kt)("p",null,"Transitions allow you to customize the way scenes transition from one into\nanother. A transition is an animation performed at the beginning of the scene.\nIt can modify the context of both the current and the previous scene."),(0,p.kt)("h2",{id:"before-we-start"},"Before we start"),(0,p.kt)("div",{className:"row"},(0,p.kt)("div",{className:"col"},(0,p.kt)("p",null,"Make sure your project contains at least two scenes. In this example, we've\nprepared ",(0,p.kt)("inlineCode",{parentName:"p"},"firstScene.tsx")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"secondScene.tsx"),", and configured our project to\ndisplay one after the other. We'll be setting up our transitions in the second\nscene."),(0,p.kt)("p",null,"Make sure to put something different in both scenes to easier see the\ntransitions.")),(0,p.kt)("div",{className:"col"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre"},"my-animation/\n\u2514\u2500 src/\n   \u251c\u2500 scenes/\n   \u2502  \u251c\u2500 firstScene.tsx\n   \u2502  \u2514\u2500 secondScene.tsx\n   \u2514\u2500 project.ts\n")))),(0,p.kt)("h2",{id:"pre-made-transitions"},"Pre-made transitions"),(0,p.kt)("p",null,"Motion Canvas comes with a set of common transitions in a form of easy-to-use\ngenerators. To use them, ",(0,p.kt)("inlineCode",{parentName:"p"},"yield*")," the transition generator at the beginning of\nthe new scene:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/scenes/secondScene.tsx"',title:'"src/scenes/secondScene.tsx"'},"export default makeScene2D(function* (view) {\n  // set up the scene:\n  view.add(/* your nodes here */);\n\n  // perform a slide transition to the left:\n  yield* slideTransition(Direction.Left);\n\n  // proceed with the animation\n  yield* waitFor(3);\n});\n")),(0,p.kt)(s.Z,{small:!0,name:"transitions",link:"transitions-second",mdxType:"AnimationPlayer"}),(0,p.kt)("admonition",{type:"caution"},(0,p.kt)("p",{parentName:"admonition"},"Make sure to add nodes to the view before yielding the transition generator.\nOtherwise, your scene will remain empty until the transition ends.")),(0,p.kt)("p",null,"All available transitions are listed below:"),(0,p.kt)("h3",{id:"slidetransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"slideTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#slideTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"zoomintransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"zoomInTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#zoomInTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"zoomouttransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"zoomOutTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#zoomOutTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"fadetransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"fadeTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#fadeTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"custom-transitions"},"Custom transitions"),(0,p.kt)("p",null,"You can use the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/transitions#useTransition"},(0,p.kt)("inlineCode",{parentName:"a"},"useTransition"))," function\nto implement custom transitions. It allows you to specify two callbacks that\nwill modify the contexts of the current and previous scene respectively. The\nvalue it returns is a callback that you need to call once you finish the\ntransition."),(0,p.kt)("p",null,"The transition template looks as follows:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// set up the transition\nconst endTransition = useTransition(\n  currentContext => {\n    // modify the context of the current scene\n  },\n  previousContext => {\n    // modify the context of the previous scene\n  },\n);\n\n// perform animations\n\n// finish the transition\nendTransition();\n")),(0,p.kt)("p",null,"Here's how you could implement a simple slide transition:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"export function* slideTransition(\n  direction: Direction = Direction.Top,\n  duration = 0.6,\n): ThreadGenerator {\n  const size = useScene().getSize();\n  const position = size.getOriginOffset(direction).scale(2);\n  const previousPosition = Vector2.createSignal();\n  const currentPosition = Vector2.createSignal(position);\n\n  // set up the transition\n  const endTransition = useTransition(\n    // modify the context of the current scene\n    ctx => ctx.translate(currentPosition.x(), currentPosition.y()),\n    // modify the context of the previous scene\n    ctx => ctx.translate(previousPosition.x(), previousPosition.y()),\n  );\n\n  // perform animations\n  yield* all(\n    previousPosition(position.scale(-1), duration),\n    currentPosition(Vector2.zero, duration),\n  );\n\n  // finish the transition\n  endTransition();\n}\n")),(0,p.kt)("h2",{id:"animate-when-transitioning"},"Animate when transitioning"),(0,p.kt)("p",null,"By default, Motion Canvas will transition to the next scene once the generator\nof the current scene has reached the end. In this case, the scene will freeze\nfor the duration of the transition. You can use the\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#finishScene"},(0,p.kt)("inlineCode",{parentName:"a"},"finishScene"))," function to trigger the transition\nearly, allowing the animation to continue while transitioning:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"export default makeScene2D(function* (view) {\n  yield* animationOne();\n  // trigger the transition early:\n  finishScene();\n  // continue animating:\n  yield* animationTwo();\n});\n")))}h.isMDXComponent=!0}}]);