"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[2474],{876:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var a=t(2784);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),l=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=l(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),d=l(t),m=r,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return t?a.createElement(h,i(i({ref:n},p),{},{components:t})):a.createElement(h,i({ref:n},p))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c[d]="string"==typeof e?e:r,i[1]=c;for(var l=2;l<o;l++)i[l]=t[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},390:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var a=t(7896),r=(t(2784),t(876));const o={slug:"/spawners"},i="Spawners",c={unversionedId:"advanced/spawners",id:"advanced/spawners",title:"Spawners",description:"Sometimes we want the children of a given node to be reactive. In other words,",source:"@site/docs/advanced/spawners.mdx",sourceDirName:"advanced",slug:"/spawners",permalink:"/docs/spawners",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/advanced/spawners.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",frontMatter:{slug:"/spawners"},sidebar:"docs",previous:{title:"Random values",permalink:"/docs/random-values"}},s={},l=[],p={toc:l};function d(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"spawners"},"Spawners"),(0,r.kt)("p",null,"Sometimes we want the children of a given node to be reactive. In other words,\nwe want them to change according to some external state. Consider the following\nexample:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const count = createSignal(10);\n\nview.add(\n  <Layout layout>\n    {range(count()).map(() => (\n      <Circle width={32} height={32} fill={'white'} />\n    ))}\n  </Layout>,\n);\n")),(0,r.kt)("p",null,"We first create the ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," signal and then use its value to generate N number\nof circles."),(0,r.kt)("p",null,"This example is not reactive - changing the ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," signal won't change the\nnumber of circles inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"Layout")," node. We can fix that with the use of the\n",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#spawner"},(0,r.kt)("inlineCode",{parentName:"a"},"spawner"))," property:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const count = createSignal(10);\n\nview.add(\n  <Layout\n    layout\n    spawner={() =>\n      range(count()).map(() => <Circle width={32} height={32} fill={'white'} />)\n    }\n  />,\n);\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"spawner")," accepts a function that returns an array of nodes. These nodes will\nbecome the new children of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Layout")," node. We can now animate our ",(0,r.kt)("inlineCode",{parentName:"p"},"count"),"\nsignal to check if it works:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield * count(5, 2);\n")),(0,r.kt)("p",null,"It's important to remember that (like most Node properties) ",(0,r.kt)("inlineCode",{parentName:"p"},"spawner")," is a\nsignal. The function we pass to it will be invoked each time any of its\ndependencies change. If the spawner happens to generate a large number of nodes\nand its dependencies change every frame, it may drastically reduce the\nplayback's performance. To counteract this, we can use an object pool that will\nlet us reuse the same nodes instead of recreating them each time:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const count = createSignal(10);\n\nconst pool = range(64).map(i => (\n  <Circle x={i * 32} width={32} height={32} fill={'lightseagreen'} />\n));\n\nconst layout = createRef<Layout>();\nview.add(<Layout layout ref={layout} spawner={() => pool.slice(0, count())} />);\n")),(0,r.kt)("p",null,"Apart from the spawner function, the pool should never be accessed directly. Use\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"children()")," signal of the parent object to get references to the spawned\nobjects:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// ... continuing from above ...\nlet spawnedCircles = layout().children() as Circle[];\nyield *\n  all(\n    ...spawnedCircles.map(function* (circle) {\n      yield* circle.scale(1.5, 1).to(1, 1);\n    }),\n  );\n")),(0,r.kt)("p",null,"Be aware that the references returned by a call to ",(0,r.kt)("inlineCode",{parentName:"p"},"children()")," may be\ninvalidated when the number of spawned objects changes, and accessing the\ninvalidated objects may cause undefined behavior. Try not to save references to\nspawned objects for too long, and use ",(0,r.kt)("inlineCode",{parentName:"p"},"children()")," wherever possible to get the\nupdated list of spawned objects."))}d.isMDXComponent=!0}}]);