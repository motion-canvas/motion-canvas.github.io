"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3805],{876:(t,e,n)=>{n.d(e,{Zo:()=>l,kt:()=>h});var o=n(2784);function p(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){p(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function c(t,e){if(null==t)return{};var n,o,p=function(t,e){if(null==t)return{};var n,o,p={},r=Object.keys(t);for(o=0;o<r.length;o++)n=r[o],e.indexOf(n)>=0||(p[n]=t[n]);return p}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)n=r[o],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(p[n]=t[n])}return p}var i=o.createContext({}),a=function(t){var e=o.useContext(i),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},l=function(t){var e=a(t.components);return o.createElement(i.Provider,{value:e},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var e=t.children;return o.createElement(o.Fragment,{},e)}},d=o.forwardRef((function(t,e){var n=t.components,p=t.mdxType,r=t.originalType,i=t.parentName,l=c(t,["components","mdxType","originalType","parentName"]),u=a(n),d=p,h=u["".concat(i,".").concat(d)]||u[d]||m[d]||r;return n?o.createElement(h,s(s({ref:e},l),{},{components:n})):o.createElement(h,s({ref:e},l))}));function h(t,e){var n=arguments,p=e&&e.mdxType;if("string"==typeof t||p){var r=n.length,s=new Array(r);s[0]=d;var c={};for(var i in e)hasOwnProperty.call(e,i)&&(c[i]=e[i]);c.originalType=t,c[u]="string"==typeof t?t:p,s[1]=c;for(var a=2;a<r;a++)s[a]=n[a];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3851:(t,e,n)=>{n.d(e,{Z:()=>u});var o=n(7896),p=n(2784),r=n(6277),s=n(1077),c=n(7683),i=n(9817);const a="anchorWithStickyNavbar_fF9Z",l="anchorWithHideOnScrollNavbar_Yh18";function u(t){let{as:e,id:n,...u}=t;const{navbar:{hideOnScroll:m}}=(0,c.L)();if("h1"===e||!n)return p.createElement(e,(0,o.Z)({},u,{id:void 0}));const d=(0,s.I)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:"string"==typeof u.children?u.children:n});return p.createElement(e,(0,o.Z)({},u,{className:(0,r.Z)("anchor",m?l:a,u.className),id:n}),u.children,p.createElement(i.Z,{className:"hash-link",to:`#${n}`,"aria-label":d,title:d},"\u200b"))}},2665:(t,e,n)=>{n.d(e,{Z:()=>f});var o=n(2784);const p="container_lQCo",r="small_As57",s="banner_A4QS",c="player_tELG",i="link_BTzN",a="icon_wSGd";var l=n(7896);function u(t){let{width:e=24,height:n=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},p),o.createElement("path",{d:"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z",fill:"currentColor"}))}var m=n(9817),d=n(6277);function h(t){let{name:e}=t;const n=`https://github.com/motion-canvas/motion-canvas/blob/main/packages/examples/src/scenes/${e}.tsx`;return o.createElement(m.Z,{to:n,className:(0,d.Z)("padding--sm",i)},o.createElement("span",null,"View source code"),o.createElement(u,{className:a}))}function f(t){let{name:e,banner:n,small:i,link:a}=t;return o.createElement("div",{className:(0,d.Z)(p,n&&s,i&&r)},o.createElement("motion-canvas-player",{class:c,src:`/examples/${e}.js`,auto:n}),o.createElement(h,{name:a||e}))}n(1263).Z.canUseDOM&&n.e(7067).then(n.bind(n,7067))},2072:(t,e,n)=>{n.d(e,{Z:()=>s});var o=n(2784),p=n(8617),r=n(1930);function s(t){let{url:e}=t;const n=(0,p.rG)()(e);return o.createElement(r.Z,{reflection:n,headless:!0})}},6879:(t,e,n)=>{n.d(e,{Z:()=>Can});var o={};n.r(o),n.d(o,{content_0_0:()=>i,content_0_10:()=>w,content_0_100:()=>te,content_0_1000:()=>Oy,content_0_1002:()=>By,content_0_1004:()=>Vy,content_0_1006:()=>Fy,content_0_1008:()=>jy,content_0_1010:()=>Hy,content_0_1012:()=>$y,content_0_1014:()=>Jy,content_0_1016:()=>ew,content_0_1018:()=>ow,content_0_102:()=>ne,content_0_1020:()=>rw,content_0_1022:()=>cw,content_0_1024:()=>aw,content_0_1026:()=>uw,content_0_1028:()=>dw,content_0_1030:()=>fw,content_0_1032:()=>yw,content_0_1034:()=>Dw,content_0_1036:()=>Xw,content_0_1038:()=>gw,content_0_104:()=>pe,content_0_1040:()=>Cw,content_0_1042:()=>vw,content_0_1044:()=>Zw,content_0_1046:()=>Nw,content_0_1048:()=>Aw,content_0_1050:()=>Iw,content_0_1052:()=>Pw,content_0_1054:()=>Ow,content_0_1056:()=>Bw,content_0_1058:()=>Vw,content_0_106:()=>se,content_0_1060:()=>Fw,content_0_1062:()=>jw,content_0_1064:()=>Hw,content_0_1066:()=>$w,content_0_1068:()=>Jw,content_0_1070:()=>eD,content_0_1072:()=>oD,content_0_1074:()=>rD,content_0_1076:()=>cD,content_0_1078:()=>aD,content_0_108:()=>ie,content_0_1080:()=>uD,content_0_1082:()=>dD,content_0_1084:()=>fD,content_0_1086:()=>yD,content_0_1088:()=>DD,content_0_1090:()=>XD,content_0_1092:()=>gD,content_0_1094:()=>CD,content_0_1096:()=>vD,content_0_1098:()=>ZD,content_0_110:()=>le,content_0_1100:()=>ND,content_0_1102:()=>AD,content_0_1104:()=>ID,content_0_1106:()=>PD,content_0_1108:()=>OD,content_0_1110:()=>BD,content_0_1112:()=>VD,content_0_1114:()=>FD,content_0_1116:()=>jD,content_0_1118:()=>HD,content_0_112:()=>me,content_0_1120:()=>$D,content_0_1122:()=>JD,content_0_1124:()=>eM,content_0_1126:()=>oM,content_0_1128:()=>rM,content_0_1130:()=>cM,content_0_1132:()=>aM,content_0_1134:()=>uM,content_0_1136:()=>dM,content_0_1138:()=>fM,content_0_114:()=>he,content_0_1140:()=>yM,content_0_1142:()=>DM,content_0_1144:()=>XM,content_0_1146:()=>gM,content_0_1148:()=>CM,content_0_1150:()=>vM,content_0_1152:()=>ZM,content_0_1154:()=>NM,content_0_1156:()=>AM,content_0_1158:()=>IM,content_0_116:()=>ke,content_0_1160:()=>PM,content_0_1162:()=>OM,content_0_1164:()=>BM,content_0_1166:()=>VM,content_0_1168:()=>FM,content_0_1170:()=>jM,content_0_1172:()=>HM,content_0_1174:()=>$M,content_0_1176:()=>JM,content_0_1178:()=>eX,content_0_118:()=>we,content_0_1180:()=>oX,content_0_1182:()=>rX,content_0_1184:()=>cX,content_0_1186:()=>aX,content_0_1188:()=>uX,content_0_1190:()=>dX,content_0_1192:()=>fX,content_0_1194:()=>yX,content_0_1196:()=>DX,content_0_1198:()=>XX,content_0_12:()=>M,content_0_120:()=>Me,content_0_1200:()=>gX,content_0_1202:()=>CX,content_0_1204:()=>vX,content_0_1206:()=>ZX,content_0_1208:()=>NX,content_0_1210:()=>AX,content_0_1212:()=>IX,content_0_1214:()=>PX,content_0_1216:()=>OX,content_0_1218:()=>BX,content_0_122:()=>_e,content_0_1220:()=>VX,content_0_1222:()=>FX,content_0_1224:()=>jX,content_0_1226:()=>HX,content_0_1228:()=>$X,content_0_1230:()=>JX,content_0_1232:()=>e_,content_0_1234:()=>o_,content_0_1236:()=>r_,content_0_1238:()=>c_,content_0_124:()=>Te,content_0_1240:()=>a_,content_0_1242:()=>u_,content_0_1244:()=>d_,content_0_1246:()=>f_,content_0_1248:()=>y_,content_0_1250:()=>D_,content_0_1252:()=>X_,content_0_1254:()=>g_,content_0_1256:()=>C_,content_0_1258:()=>v_,content_0_126:()=>xe,content_0_1260:()=>Z_,content_0_1262:()=>N_,content_0_1264:()=>A_,content_0_1266:()=>I_,content_0_1268:()=>P_,content_0_1270:()=>O_,content_0_1272:()=>B_,content_0_1274:()=>V_,content_0_1276:()=>F_,content_0_1278:()=>j_,content_0_128:()=>Le,content_0_1280:()=>H_,content_0_1282:()=>$_,content_0_1284:()=>J_,content_0_1286:()=>eg,content_0_1288:()=>og,content_0_1290:()=>rg,content_0_1292:()=>cg,content_0_1294:()=>ag,content_0_1296:()=>ug,content_0_1298:()=>dg,content_0_130:()=>be,content_0_1300:()=>fg,content_0_1302:()=>yg,content_0_1304:()=>Dg,content_0_1306:()=>Xg,content_0_1308:()=>gg,content_0_1310:()=>Cg,content_0_1312:()=>vg,content_0_1314:()=>Zg,content_0_1316:()=>Ng,content_0_1318:()=>Ag,content_0_132:()=>ze,content_0_1320:()=>Ig,content_0_1322:()=>Pg,content_0_1324:()=>Og,content_0_1326:()=>Bg,content_0_1328:()=>Vg,content_0_1330:()=>Fg,content_0_1332:()=>jg,content_0_1334:()=>Hg,content_0_1336:()=>$g,content_0_1338:()=>Jg,content_0_134:()=>We,content_0_1340:()=>eT,content_0_1342:()=>oT,content_0_1344:()=>rT,content_0_1346:()=>cT,content_0_1348:()=>aT,content_0_1350:()=>uT,content_0_1352:()=>dT,content_0_1354:()=>fT,content_0_1356:()=>yT,content_0_1358:()=>DT,content_0_136:()=>Re,content_0_1360:()=>XT,content_0_1362:()=>gT,content_0_1364:()=>CT,content_0_1366:()=>vT,content_0_1368:()=>ZT,content_0_1370:()=>NT,content_0_1372:()=>AT,content_0_1374:()=>IT,content_0_1376:()=>PT,content_0_1378:()=>OT,content_0_138:()=>Se,content_0_1380:()=>BT,content_0_1382:()=>VT,content_0_1384:()=>FT,content_0_1386:()=>jT,content_0_1388:()=>HT,content_0_1390:()=>$T,content_0_1392:()=>JT,content_0_1394:()=>eC,content_0_1396:()=>oC,content_0_1398:()=>rC,content_0_14:()=>_,content_0_140:()=>Ee,content_0_1400:()=>cC,content_0_1402:()=>aC,content_0_1404:()=>uC,content_0_1406:()=>dC,content_0_1408:()=>fC,content_0_1410:()=>yC,content_0_1412:()=>DC,content_0_1414:()=>XC,content_0_1416:()=>gC,content_0_1418:()=>CC,content_0_142:()=>Ge,content_0_1420:()=>vC,content_0_1422:()=>ZC,content_0_1424:()=>NC,content_0_1426:()=>AC,content_0_1428:()=>IC,content_0_1430:()=>PC,content_0_1432:()=>OC,content_0_1434:()=>BC,content_0_1436:()=>VC,content_0_1438:()=>FC,content_0_144:()=>Ue,content_0_1440:()=>jC,content_0_1442:()=>HC,content_0_1444:()=>$C,content_0_1446:()=>JC,content_0_1448:()=>ex,content_0_1450:()=>ox,content_0_1452:()=>rx,content_0_1454:()=>cx,content_0_1456:()=>ax,content_0_1458:()=>ux,content_0_146:()=>qe,content_0_1460:()=>dx,content_0_1462:()=>fx,content_0_1464:()=>yx,content_0_1466:()=>Dx,content_0_1468:()=>Xx,content_0_1470:()=>gx,content_0_1472:()=>Cx,content_0_1474:()=>vx,content_0_1476:()=>Zx,content_0_1478:()=>Nx,content_0_148:()=>Ye,content_0_1480:()=>Ax,content_0_1482:()=>Ix,content_0_1484:()=>Px,content_0_1486:()=>Ox,content_0_1488:()=>Bx,content_0_1490:()=>Vx,content_0_1492:()=>Fx,content_0_1494:()=>jx,content_0_1496:()=>Hx,content_0_1498:()=>$x,content_0_150:()=>Qe,content_0_1500:()=>Jx,content_0_1502:()=>ev,content_0_1504:()=>ov,content_0_1506:()=>rv,content_0_1508:()=>cv,content_0_1510:()=>av,content_0_1512:()=>uv,content_0_1514:()=>dv,content_0_1516:()=>fv,content_0_1518:()=>yv,content_0_152:()=>Ke,content_0_1520:()=>Dv,content_0_1522:()=>Xv,content_0_1524:()=>gv,content_0_1526:()=>Cv,content_0_1528:()=>vv,content_0_1530:()=>Zv,content_0_1532:()=>Nv,content_0_1534:()=>Av,content_0_1536:()=>Iv,content_0_1538:()=>Pv,content_0_154:()=>tn,content_0_1540:()=>Ov,content_0_1542:()=>Bv,content_0_1544:()=>Vv,content_0_1546:()=>Fv,content_0_1548:()=>jv,content_0_1550:()=>Hv,content_0_1552:()=>$v,content_0_1554:()=>Jv,content_0_1556:()=>eL,content_0_1558:()=>oL,content_0_156:()=>nn,content_0_1560:()=>rL,content_0_1562:()=>cL,content_0_1564:()=>aL,content_0_1566:()=>uL,content_0_1568:()=>dL,content_0_1570:()=>fL,content_0_1572:()=>yL,content_0_1574:()=>DL,content_0_1576:()=>XL,content_0_1578:()=>gL,content_0_158:()=>pn,content_0_1580:()=>CL,content_0_1582:()=>vL,content_0_1584:()=>ZL,content_0_1586:()=>NL,content_0_1588:()=>AL,content_0_1590:()=>IL,content_0_1592:()=>PL,content_0_1594:()=>OL,content_0_1596:()=>BL,content_0_1598:()=>VL,content_0_16:()=>T,content_0_160:()=>sn,content_0_1600:()=>FL,content_0_1602:()=>jL,content_0_1604:()=>HL,content_0_1606:()=>$L,content_0_1608:()=>JL,content_0_1610:()=>eZ,content_0_1612:()=>oZ,content_0_1614:()=>rZ,content_0_1616:()=>cZ,content_0_1618:()=>aZ,content_0_162:()=>an,content_0_1620:()=>uZ,content_0_1622:()=>dZ,content_0_1624:()=>fZ,content_0_1626:()=>yZ,content_0_1628:()=>DZ,content_0_1630:()=>XZ,content_0_1632:()=>gZ,content_0_1634:()=>CZ,content_0_1636:()=>vZ,content_0_1638:()=>ZZ,content_0_164:()=>un,content_0_1640:()=>NZ,content_0_1642:()=>AZ,content_0_1644:()=>IZ,content_0_1646:()=>PZ,content_0_1648:()=>OZ,content_0_1650:()=>BZ,content_0_1652:()=>VZ,content_0_1654:()=>FZ,content_0_1656:()=>jZ,content_0_1658:()=>HZ,content_0_166:()=>dn,content_0_1660:()=>$Z,content_0_1662:()=>JZ,content_0_1664:()=>eb,content_0_1666:()=>ob,content_0_1668:()=>rb,content_0_1670:()=>cb,content_0_1672:()=>ab,content_0_1674:()=>ub,content_0_1676:()=>db,content_0_1678:()=>fb,content_0_168:()=>fn,content_0_1680:()=>yb,content_0_170:()=>yn,content_0_172:()=>Dn,content_0_174:()=>Xn,content_0_176:()=>gn,content_0_178:()=>Cn,content_0_18:()=>x,content_0_180:()=>vn,content_0_182:()=>Zn,content_0_184:()=>Nn,content_0_186:()=>An,content_0_188:()=>In,content_0_190:()=>Pn,content_0_192:()=>On,content_0_194:()=>Bn,content_0_196:()=>Vn,content_0_198:()=>Fn,content_0_2:()=>l,content_0_20:()=>L,content_0_200:()=>jn,content_0_202:()=>Hn,content_0_204:()=>$n,content_0_206:()=>Jn,content_0_208:()=>eo,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>co,content_0_216:()=>ao,content_0_218:()=>uo,content_0_22:()=>b,content_0_220:()=>ho,content_0_222:()=>ko,content_0_224:()=>wo,content_0_226:()=>Mo,content_0_228:()=>_o,content_0_230:()=>To,content_0_232:()=>xo,content_0_234:()=>Lo,content_0_236:()=>bo,content_0_238:()=>zo,content_0_24:()=>z,content_0_240:()=>Wo,content_0_242:()=>Ro,content_0_244:()=>So,content_0_246:()=>Eo,content_0_248:()=>Go,content_0_250:()=>Uo,content_0_252:()=>qo,content_0_254:()=>Yo,content_0_256:()=>Qo,content_0_258:()=>Ko,content_0_26:()=>W,content_0_260:()=>tp,content_0_262:()=>np,content_0_264:()=>pp,content_0_266:()=>sp,content_0_268:()=>ip,content_0_270:()=>lp,content_0_272:()=>mp,content_0_274:()=>hp,content_0_276:()=>kp,content_0_278:()=>wp,content_0_28:()=>R,content_0_280:()=>Mp,content_0_282:()=>_p,content_0_284:()=>Tp,content_0_286:()=>xp,content_0_288:()=>Lp,content_0_290:()=>bp,content_0_292:()=>zp,content_0_294:()=>Wp,content_0_296:()=>Rp,content_0_298:()=>Sp,content_0_30:()=>S,content_0_300:()=>Ep,content_0_302:()=>Gp,content_0_304:()=>Up,content_0_306:()=>qp,content_0_308:()=>Yp,content_0_310:()=>Qp,content_0_312:()=>Kp,content_0_314:()=>tr,content_0_316:()=>nr,content_0_318:()=>pr,content_0_32:()=>E,content_0_320:()=>sr,content_0_322:()=>ir,content_0_324:()=>lr,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>kr,content_0_332:()=>wr,content_0_334:()=>Mr,content_0_336:()=>_r,content_0_338:()=>Tr,content_0_34:()=>G,content_0_340:()=>xr,content_0_342:()=>Lr,content_0_344:()=>br,content_0_346:()=>zr,content_0_348:()=>Wr,content_0_350:()=>Rr,content_0_352:()=>Sr,content_0_354:()=>Er,content_0_356:()=>Gr,content_0_358:()=>Ur,content_0_36:()=>U,content_0_360:()=>qr,content_0_362:()=>Yr,content_0_364:()=>Qr,content_0_366:()=>Kr,content_0_368:()=>ts,content_0_370:()=>ns,content_0_372:()=>ps,content_0_374:()=>ss,content_0_376:()=>is,content_0_378:()=>ls,content_0_38:()=>q,content_0_380:()=>ms,content_0_382:()=>hs,content_0_384:()=>ks,content_0_386:()=>ws,content_0_388:()=>Ms,content_0_390:()=>_s,content_0_392:()=>Ts,content_0_394:()=>xs,content_0_396:()=>Ls,content_0_398:()=>bs,content_0_4:()=>m,content_0_40:()=>Y,content_0_400:()=>zs,content_0_402:()=>Ws,content_0_404:()=>Rs,content_0_406:()=>Ss,content_0_408:()=>Es,content_0_410:()=>Gs,content_0_412:()=>Us,content_0_414:()=>qs,content_0_416:()=>Ys,content_0_418:()=>Qs,content_0_42:()=>Q,content_0_420:()=>Ks,content_0_422:()=>tc,content_0_424:()=>nc,content_0_426:()=>pc,content_0_428:()=>sc,content_0_430:()=>ic,content_0_432:()=>lc,content_0_434:()=>mc,content_0_436:()=>hc,content_0_438:()=>kc,content_0_44:()=>K,content_0_440:()=>wc,content_0_442:()=>Mc,content_0_444:()=>_c,content_0_446:()=>Tc,content_0_448:()=>xc,content_0_450:()=>Lc,content_0_452:()=>bc,content_0_454:()=>zc,content_0_456:()=>Wc,content_0_458:()=>Rc,content_0_46:()=>tt,content_0_460:()=>Sc,content_0_462:()=>Ec,content_0_464:()=>Gc,content_0_466:()=>Uc,content_0_468:()=>qc,content_0_470:()=>Yc,content_0_472:()=>Qc,content_0_474:()=>Kc,content_0_476:()=>ti,content_0_478:()=>ni,content_0_48:()=>nt,content_0_480:()=>pi,content_0_482:()=>si,content_0_484:()=>ii,content_0_486:()=>li,content_0_488:()=>mi,content_0_490:()=>hi,content_0_492:()=>ki,content_0_494:()=>wi,content_0_496:()=>Mi,content_0_498:()=>_i,content_0_50:()=>pt,content_0_500:()=>Ti,content_0_502:()=>xi,content_0_504:()=>Li,content_0_506:()=>bi,content_0_508:()=>zi,content_0_510:()=>Wi,content_0_512:()=>Ri,content_0_514:()=>Si,content_0_516:()=>Ei,content_0_518:()=>Gi,content_0_52:()=>st,content_0_520:()=>Ui,content_0_522:()=>qi,content_0_524:()=>Yi,content_0_526:()=>Qi,content_0_528:()=>Ki,content_0_530:()=>ta,content_0_532:()=>na,content_0_534:()=>pa,content_0_536:()=>sa,content_0_538:()=>ia,content_0_54:()=>it,content_0_540:()=>la,content_0_542:()=>ma,content_0_544:()=>ha,content_0_546:()=>ka,content_0_548:()=>wa,content_0_550:()=>Ma,content_0_552:()=>_a,content_0_554:()=>Ta,content_0_556:()=>xa,content_0_558:()=>La,content_0_56:()=>lt,content_0_560:()=>ba,content_0_562:()=>za,content_0_564:()=>Wa,content_0_566:()=>Ra,content_0_568:()=>Sa,content_0_570:()=>Ea,content_0_572:()=>Ga,content_0_574:()=>Ua,content_0_576:()=>qa,content_0_578:()=>Ya,content_0_58:()=>mt,content_0_580:()=>Qa,content_0_582:()=>Ka,content_0_584:()=>tl,content_0_586:()=>nl,content_0_588:()=>pl,content_0_590:()=>sl,content_0_592:()=>il,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>kl,content_0_602:()=>wl,content_0_604:()=>Ml,content_0_606:()=>_l,content_0_608:()=>Tl,content_0_610:()=>xl,content_0_612:()=>Ll,content_0_614:()=>bl,content_0_616:()=>zl,content_0_618:()=>Wl,content_0_62:()=>kt,content_0_620:()=>Rl,content_0_622:()=>Sl,content_0_624:()=>El,content_0_626:()=>Gl,content_0_628:()=>Ul,content_0_630:()=>ql,content_0_632:()=>Yl,content_0_634:()=>Ql,content_0_636:()=>Kl,content_0_638:()=>tu,content_0_64:()=>wt,content_0_640:()=>nu,content_0_642:()=>pu,content_0_644:()=>su,content_0_646:()=>iu,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>ku,content_0_656:()=>wu,content_0_658:()=>Mu,content_0_66:()=>Mt,content_0_660:()=>_u,content_0_662:()=>Tu,content_0_664:()=>xu,content_0_666:()=>Lu,content_0_668:()=>bu,content_0_670:()=>zu,content_0_672:()=>Wu,content_0_674:()=>Ru,content_0_676:()=>Su,content_0_678:()=>Eu,content_0_68:()=>_t,content_0_680:()=>Gu,content_0_682:()=>Uu,content_0_684:()=>qu,content_0_686:()=>Yu,content_0_688:()=>Qu,content_0_690:()=>Ku,content_0_692:()=>tm,content_0_694:()=>nm,content_0_696:()=>pm,content_0_698:()=>sm,content_0_70:()=>Tt,content_0_700:()=>im,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>km,content_0_710:()=>wm,content_0_712:()=>Mm,content_0_714:()=>_m,content_0_716:()=>Tm,content_0_718:()=>xm,content_0_72:()=>xt,content_0_720:()=>Lm,content_0_722:()=>bm,content_0_724:()=>zm,content_0_726:()=>Wm,content_0_728:()=>Rm,content_0_730:()=>Sm,content_0_732:()=>Em,content_0_734:()=>Gm,content_0_736:()=>Um,content_0_738:()=>qm,content_0_74:()=>Lt,content_0_740:()=>Ym,content_0_742:()=>Qm,content_0_744:()=>Km,content_0_746:()=>td,content_0_748:()=>nd,content_0_750:()=>pd,content_0_752:()=>sd,content_0_754:()=>id,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>bt,content_0_760:()=>hd,content_0_762:()=>kd,content_0_764:()=>wd,content_0_766:()=>Md,content_0_768:()=>_d,content_0_770:()=>Td,content_0_772:()=>xd,content_0_774:()=>Ld,content_0_776:()=>bd,content_0_778:()=>zd,content_0_78:()=>zt,content_0_780:()=>Wd,content_0_782:()=>Rd,content_0_784:()=>Sd,content_0_786:()=>Ed,content_0_788:()=>Gd,content_0_790:()=>Ud,content_0_792:()=>qd,content_0_794:()=>Yd,content_0_796:()=>Qd,content_0_798:()=>Kd,content_0_8:()=>k,content_0_80:()=>Wt,content_0_800:()=>th,content_0_802:()=>nh,content_0_804:()=>ph,content_0_806:()=>sh,content_0_808:()=>ih,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>kh,content_0_818:()=>wh,content_0_82:()=>Rt,content_0_820:()=>Mh,content_0_822:()=>_h,content_0_824:()=>Th,content_0_826:()=>xh,content_0_828:()=>Lh,content_0_830:()=>bh,content_0_832:()=>zh,content_0_834:()=>Wh,content_0_836:()=>Rh,content_0_838:()=>Sh,content_0_84:()=>St,content_0_840:()=>Eh,content_0_842:()=>Gh,content_0_844:()=>Uh,content_0_846:()=>qh,content_0_848:()=>Yh,content_0_850:()=>Qh,content_0_852:()=>Kh,content_0_854:()=>tf,content_0_856:()=>nf,content_0_858:()=>pf,content_0_86:()=>Et,content_0_860:()=>sf,content_0_862:()=>af,content_0_864:()=>uf,content_0_866:()=>df,content_0_868:()=>ff,content_0_870:()=>yf,content_0_872:()=>Df,content_0_874:()=>Xf,content_0_876:()=>gf,content_0_878:()=>Cf,content_0_88:()=>Gt,content_0_880:()=>vf,content_0_882:()=>Zf,content_0_884:()=>Nf,content_0_886:()=>Af,content_0_888:()=>If,content_0_890:()=>Pf,content_0_892:()=>Of,content_0_894:()=>Bf,content_0_896:()=>Vf,content_0_898:()=>Ff,content_0_90:()=>Ut,content_0_900:()=>jf,content_0_902:()=>Hf,content_0_904:()=>$f,content_0_906:()=>Jf,content_0_908:()=>ek,content_0_910:()=>ok,content_0_912:()=>rk,content_0_914:()=>ck,content_0_916:()=>ak,content_0_918:()=>uk,content_0_92:()=>qt,content_0_920:()=>dk,content_0_922:()=>fk,content_0_924:()=>yk,content_0_926:()=>Dk,content_0_928:()=>Xk,content_0_930:()=>gk,content_0_932:()=>Ck,content_0_934:()=>vk,content_0_936:()=>Zk,content_0_938:()=>Nk,content_0_94:()=>Yt,content_0_940:()=>Ak,content_0_942:()=>Ik,content_0_944:()=>Pk,content_0_946:()=>Ok,content_0_948:()=>Bk,content_0_950:()=>Vk,content_0_952:()=>Fk,content_0_954:()=>jk,content_0_956:()=>Hk,content_0_958:()=>$k,content_0_96:()=>Qt,content_0_960:()=>Jk,content_0_962:()=>ey,content_0_964:()=>oy,content_0_966:()=>ry,content_0_968:()=>cy,content_0_970:()=>ay,content_0_972:()=>uy,content_0_974:()=>dy,content_0_976:()=>fy,content_0_978:()=>yy,content_0_98:()=>Kt,content_0_980:()=>Dy,content_0_982:()=>Xy,content_0_984:()=>gy,content_0_986:()=>Cy,content_0_988:()=>vy,content_0_990:()=>Zy,content_0_992:()=>Ny,content_0_994:()=>Ay,content_0_996:()=>Iy,content_0_998:()=>Py,content_3562_0:()=>Db,content_3562_10:()=>Zb,content_3562_100:()=>uz,content_3562_1000:()=>jY,content_3562_1002:()=>HY,content_3562_1004:()=>$Y,content_3562_1006:()=>JY,content_3562_1008:()=>eH,content_3562_1010:()=>oH,content_3562_1012:()=>rH,content_3562_1014:()=>cH,content_3562_1016:()=>aH,content_3562_1018:()=>uH,content_3562_102:()=>dz,content_3562_1020:()=>dH,content_3562_1022:()=>fH,content_3562_1024:()=>yH,content_3562_1026:()=>DH,content_3562_1028:()=>XH,content_3562_1030:()=>gH,content_3562_1032:()=>CH,content_3562_1034:()=>vH,content_3562_1036:()=>ZH,content_3562_1038:()=>NH,content_3562_104:()=>fz,content_3562_1040:()=>AH,content_3562_1042:()=>IH,content_3562_1044:()=>PH,content_3562_1046:()=>OH,content_3562_1048:()=>BH,content_3562_1050:()=>VH,content_3562_1052:()=>FH,content_3562_1054:()=>jH,content_3562_1056:()=>HH,content_3562_1058:()=>$H,content_3562_106:()=>yz,content_3562_1060:()=>JH,content_3562_1062:()=>eQ,content_3562_1064:()=>oQ,content_3562_1066:()=>rQ,content_3562_1068:()=>cQ,content_3562_1070:()=>aQ,content_3562_1072:()=>uQ,content_3562_1074:()=>dQ,content_3562_1076:()=>fQ,content_3562_1078:()=>yQ,content_3562_108:()=>Dz,content_3562_1080:()=>DQ,content_3562_1082:()=>XQ,content_3562_1084:()=>gQ,content_3562_1086:()=>CQ,content_3562_1088:()=>vQ,content_3562_1090:()=>ZQ,content_3562_1092:()=>NQ,content_3562_1094:()=>AQ,content_3562_1096:()=>IQ,content_3562_1098:()=>PQ,content_3562_110:()=>Xz,content_3562_1100:()=>OQ,content_3562_1102:()=>BQ,content_3562_1104:()=>VQ,content_3562_1106:()=>FQ,content_3562_1108:()=>jQ,content_3562_1110:()=>HQ,content_3562_1112:()=>$Q,content_3562_1114:()=>JQ,content_3562_1116:()=>e$,content_3562_1118:()=>o$,content_3562_112:()=>gz,content_3562_1120:()=>r$,content_3562_1122:()=>c$,content_3562_1124:()=>a$,content_3562_1126:()=>u$,content_3562_1128:()=>d$,content_3562_1130:()=>f$,content_3562_1132:()=>y$,content_3562_1134:()=>D$,content_3562_1136:()=>X$,content_3562_1138:()=>g$,content_3562_114:()=>Cz,content_3562_1140:()=>C$,content_3562_1142:()=>v$,content_3562_1144:()=>Z$,content_3562_1146:()=>N$,content_3562_1148:()=>A$,content_3562_1150:()=>I$,content_3562_1152:()=>P$,content_3562_1154:()=>O$,content_3562_1156:()=>B$,content_3562_1158:()=>V$,content_3562_116:()=>vz,content_3562_1160:()=>F$,content_3562_1162:()=>j$,content_3562_1164:()=>H$,content_3562_1166:()=>$$,content_3562_1168:()=>J$,content_3562_1170:()=>eK,content_3562_1172:()=>oK,content_3562_1174:()=>rK,content_3562_1176:()=>cK,content_3562_1178:()=>aK,content_3562_118:()=>Zz,content_3562_1180:()=>uK,content_3562_1182:()=>dK,content_3562_1184:()=>fK,content_3562_1186:()=>yK,content_3562_1188:()=>DK,content_3562_1190:()=>XK,content_3562_1192:()=>gK,content_3562_1194:()=>CK,content_3562_1196:()=>vK,content_3562_1198:()=>ZK,content_3562_12:()=>Nb,content_3562_120:()=>Nz,content_3562_1200:()=>NK,content_3562_1202:()=>AK,content_3562_1204:()=>IK,content_3562_1206:()=>PK,content_3562_1208:()=>OK,content_3562_1210:()=>BK,content_3562_1212:()=>VK,content_3562_1214:()=>FK,content_3562_1216:()=>jK,content_3562_1218:()=>HK,content_3562_122:()=>Az,content_3562_1220:()=>$K,content_3562_1222:()=>JK,content_3562_1224:()=>eJ,content_3562_1226:()=>oJ,content_3562_1228:()=>rJ,content_3562_1230:()=>cJ,content_3562_1232:()=>aJ,content_3562_1234:()=>uJ,content_3562_1236:()=>dJ,content_3562_1238:()=>fJ,content_3562_124:()=>Iz,content_3562_1240:()=>yJ,content_3562_1242:()=>DJ,content_3562_1244:()=>XJ,content_3562_1246:()=>gJ,content_3562_1248:()=>CJ,content_3562_1250:()=>vJ,content_3562_1252:()=>ZJ,content_3562_1254:()=>NJ,content_3562_1256:()=>AJ,content_3562_1258:()=>IJ,content_3562_126:()=>Pz,content_3562_1260:()=>PJ,content_3562_1262:()=>OJ,content_3562_1264:()=>BJ,content_3562_1266:()=>VJ,content_3562_1268:()=>FJ,content_3562_1270:()=>jJ,content_3562_1272:()=>HJ,content_3562_1274:()=>$J,content_3562_1276:()=>JJ,content_3562_1278:()=>e0,content_3562_128:()=>Oz,content_3562_1280:()=>o0,content_3562_1282:()=>r0,content_3562_1284:()=>c0,content_3562_1286:()=>a0,content_3562_1288:()=>u0,content_3562_1290:()=>d0,content_3562_1292:()=>f0,content_3562_1294:()=>y0,content_3562_1296:()=>D0,content_3562_1298:()=>X0,content_3562_130:()=>Bz,content_3562_1300:()=>g0,content_3562_1302:()=>C0,content_3562_1304:()=>v0,content_3562_1306:()=>Z0,content_3562_1308:()=>N0,content_3562_1310:()=>A0,content_3562_1312:()=>I0,content_3562_1314:()=>P0,content_3562_1316:()=>O0,content_3562_1318:()=>B0,content_3562_132:()=>Vz,content_3562_1320:()=>V0,content_3562_1322:()=>F0,content_3562_1324:()=>j0,content_3562_1326:()=>H0,content_3562_1328:()=>$0,content_3562_1330:()=>J0,content_3562_1332:()=>e2,content_3562_1334:()=>o2,content_3562_1336:()=>r2,content_3562_1338:()=>c2,content_3562_134:()=>Fz,content_3562_1340:()=>a2,content_3562_1342:()=>u2,content_3562_1344:()=>d2,content_3562_1346:()=>f2,content_3562_1348:()=>y2,content_3562_1350:()=>D2,content_3562_1352:()=>X2,content_3562_1354:()=>g2,content_3562_1356:()=>C2,content_3562_1358:()=>v2,content_3562_136:()=>jz,content_3562_1360:()=>Z2,content_3562_1362:()=>N2,content_3562_1364:()=>A2,content_3562_1366:()=>I2,content_3562_1368:()=>P2,content_3562_1370:()=>O2,content_3562_1372:()=>B2,content_3562_1374:()=>V2,content_3562_1376:()=>F2,content_3562_1378:()=>j2,content_3562_138:()=>Hz,content_3562_1380:()=>H2,content_3562_1382:()=>$2,content_3562_1384:()=>J2,content_3562_1386:()=>e6,content_3562_1388:()=>o6,content_3562_1390:()=>r6,content_3562_1392:()=>c6,content_3562_1394:()=>a6,content_3562_1396:()=>u6,content_3562_1398:()=>d6,content_3562_14:()=>Ab,content_3562_140:()=>$z,content_3562_1400:()=>f6,content_3562_1402:()=>y6,content_3562_1404:()=>D6,content_3562_1406:()=>X6,content_3562_1408:()=>g6,content_3562_1410:()=>C6,content_3562_1412:()=>v6,content_3562_1414:()=>Z6,content_3562_1416:()=>N6,content_3562_1418:()=>A6,content_3562_142:()=>Jz,content_3562_1420:()=>I6,content_3562_1422:()=>P6,content_3562_1424:()=>O6,content_3562_1426:()=>B6,content_3562_1428:()=>V6,content_3562_1430:()=>F6,content_3562_1432:()=>j6,content_3562_1434:()=>H6,content_3562_1436:()=>$6,content_3562_1438:()=>J6,content_3562_144:()=>eA,content_3562_1440:()=>e3,content_3562_1442:()=>o3,content_3562_1444:()=>r3,content_3562_1446:()=>c3,content_3562_1448:()=>a3,content_3562_1450:()=>u3,content_3562_1452:()=>d3,content_3562_1454:()=>f3,content_3562_1456:()=>y3,content_3562_1458:()=>D3,content_3562_146:()=>oA,content_3562_1460:()=>X3,content_3562_1462:()=>g3,content_3562_1464:()=>C3,content_3562_1466:()=>v3,content_3562_1468:()=>Z3,content_3562_1470:()=>N3,content_3562_1472:()=>A3,content_3562_1474:()=>I3,content_3562_1476:()=>P3,content_3562_1478:()=>O3,content_3562_148:()=>rA,content_3562_1480:()=>B3,content_3562_1482:()=>V3,content_3562_1484:()=>F3,content_3562_1486:()=>j3,content_3562_1488:()=>H3,content_3562_1490:()=>$3,content_3562_1492:()=>J3,content_3562_1494:()=>e5,content_3562_1496:()=>o5,content_3562_1498:()=>r5,content_3562_150:()=>cA,content_3562_1500:()=>c5,content_3562_1502:()=>a5,content_3562_1504:()=>u5,content_3562_1506:()=>d5,content_3562_1508:()=>f5,content_3562_1510:()=>y5,content_3562_1512:()=>D5,content_3562_1514:()=>X5,content_3562_1516:()=>g5,content_3562_1518:()=>C5,content_3562_152:()=>aA,content_3562_1520:()=>v5,content_3562_1522:()=>Z5,content_3562_1524:()=>N5,content_3562_1526:()=>A5,content_3562_1528:()=>I5,content_3562_1530:()=>P5,content_3562_1532:()=>O5,content_3562_1534:()=>B5,content_3562_1536:()=>V5,content_3562_1538:()=>F5,content_3562_154:()=>uA,content_3562_1540:()=>j5,content_3562_1542:()=>H5,content_3562_1544:()=>$5,content_3562_1546:()=>J5,content_3562_1548:()=>e1,content_3562_1550:()=>o1,content_3562_1552:()=>r1,content_3562_1554:()=>c1,content_3562_1556:()=>a1,content_3562_1558:()=>u1,content_3562_156:()=>dA,content_3562_1560:()=>d1,content_3562_1562:()=>f1,content_3562_1564:()=>y1,content_3562_1566:()=>D1,content_3562_1568:()=>X1,content_3562_1570:()=>g1,content_3562_1572:()=>C1,content_3562_1574:()=>v1,content_3562_1576:()=>Z1,content_3562_1578:()=>N1,content_3562_158:()=>fA,content_3562_1580:()=>A1,content_3562_1582:()=>I1,content_3562_1584:()=>P1,content_3562_1586:()=>O1,content_3562_1588:()=>B1,content_3562_1590:()=>V1,content_3562_1592:()=>F1,content_3562_1594:()=>j1,content_3562_1596:()=>H1,content_3562_1598:()=>$1,content_3562_16:()=>Ib,content_3562_160:()=>yA,content_3562_1600:()=>J1,content_3562_1602:()=>e4,content_3562_1604:()=>o4,content_3562_1606:()=>r4,content_3562_1608:()=>c4,content_3562_1610:()=>a4,content_3562_1612:()=>u4,content_3562_1614:()=>d4,content_3562_1616:()=>f4,content_3562_1618:()=>y4,content_3562_162:()=>DA,content_3562_1620:()=>D4,content_3562_1622:()=>X4,content_3562_1624:()=>g4,content_3562_1626:()=>C4,content_3562_1628:()=>v4,content_3562_1630:()=>Z4,content_3562_1632:()=>N4,content_3562_1634:()=>A4,content_3562_1636:()=>I4,content_3562_1638:()=>P4,content_3562_164:()=>XA,content_3562_1640:()=>O4,content_3562_1642:()=>B4,content_3562_1644:()=>V4,content_3562_1646:()=>F4,content_3562_1648:()=>j4,content_3562_1650:()=>H4,content_3562_1652:()=>$4,content_3562_1654:()=>J4,content_3562_1656:()=>e8,content_3562_1658:()=>o8,content_3562_166:()=>gA,content_3562_1660:()=>r8,content_3562_1662:()=>c8,content_3562_1664:()=>a8,content_3562_1666:()=>u8,content_3562_1668:()=>d8,content_3562_1670:()=>f8,content_3562_1672:()=>y8,content_3562_1674:()=>D8,content_3562_1676:()=>X8,content_3562_1678:()=>g8,content_3562_168:()=>CA,content_3562_1680:()=>C8,content_3562_1682:()=>v8,content_3562_1684:()=>Z8,content_3562_1686:()=>N8,content_3562_1688:()=>A8,content_3562_1690:()=>I8,content_3562_1692:()=>P8,content_3562_1694:()=>O8,content_3562_1696:()=>B8,content_3562_1698:()=>V8,content_3562_170:()=>vA,content_3562_1700:()=>F8,content_3562_1702:()=>j8,content_3562_1704:()=>H8,content_3562_1706:()=>$8,content_3562_1708:()=>J8,content_3562_1710:()=>e7,content_3562_1712:()=>o7,content_3562_1714:()=>r7,content_3562_1716:()=>c7,content_3562_1718:()=>a7,content_3562_172:()=>ZA,content_3562_1720:()=>u7,content_3562_1722:()=>d7,content_3562_1724:()=>f7,content_3562_1726:()=>y7,content_3562_1728:()=>D7,content_3562_1730:()=>X7,content_3562_1732:()=>g7,content_3562_1734:()=>C7,content_3562_1736:()=>v7,content_3562_1738:()=>Z7,content_3562_174:()=>NA,content_3562_1740:()=>N7,content_3562_1742:()=>A7,content_3562_1744:()=>I7,content_3562_1746:()=>P7,content_3562_1748:()=>O7,content_3562_1750:()=>B7,content_3562_1752:()=>V7,content_3562_1754:()=>F7,content_3562_1756:()=>j7,content_3562_1758:()=>H7,content_3562_176:()=>AA,content_3562_1760:()=>$7,content_3562_1762:()=>J7,content_3562_1764:()=>e9,content_3562_1766:()=>o9,content_3562_1768:()=>r9,content_3562_1770:()=>c9,content_3562_1772:()=>a9,content_3562_1774:()=>u9,content_3562_1776:()=>d9,content_3562_1778:()=>f9,content_3562_178:()=>IA,content_3562_1780:()=>y9,content_3562_1782:()=>D9,content_3562_1784:()=>X9,content_3562_1786:()=>g9,content_3562_1788:()=>C9,content_3562_1790:()=>v9,content_3562_1792:()=>Z9,content_3562_1794:()=>N9,content_3562_1796:()=>A9,content_3562_1798:()=>I9,content_3562_18:()=>Pb,content_3562_180:()=>PA,content_3562_1800:()=>P9,content_3562_1802:()=>O9,content_3562_1804:()=>B9,content_3562_1806:()=>V9,content_3562_1808:()=>F9,content_3562_1810:()=>j9,content_3562_1812:()=>H9,content_3562_1814:()=>$9,content_3562_1816:()=>J9,content_3562_1818:()=>ett,content_3562_182:()=>OA,content_3562_1820:()=>ott,content_3562_1822:()=>rtt,content_3562_1824:()=>ctt,content_3562_1826:()=>att,content_3562_1828:()=>utt,content_3562_1830:()=>dtt,content_3562_1832:()=>ftt,content_3562_1834:()=>ytt,content_3562_1836:()=>Dtt,content_3562_1838:()=>Xtt,content_3562_184:()=>BA,content_3562_1840:()=>gtt,content_3562_1842:()=>Ctt,content_3562_1844:()=>vtt,content_3562_1846:()=>Ztt,content_3562_1848:()=>Ntt,content_3562_1850:()=>Att,content_3562_1852:()=>Itt,content_3562_1854:()=>Ptt,content_3562_1856:()=>Ott,content_3562_1858:()=>Btt,content_3562_186:()=>VA,content_3562_1860:()=>Vtt,content_3562_1862:()=>Ftt,content_3562_1864:()=>jtt,content_3562_1866:()=>Htt,content_3562_1868:()=>$tt,content_3562_1870:()=>Jtt,content_3562_1872:()=>eet,content_3562_1874:()=>oet,content_3562_1876:()=>ret,content_3562_1878:()=>cet,content_3562_188:()=>FA,content_3562_1880:()=>aet,content_3562_1882:()=>met,content_3562_1884:()=>het,content_3562_1886:()=>ket,content_3562_1888:()=>wet,content_3562_1890:()=>Met,content_3562_1892:()=>_et,content_3562_1894:()=>Tet,content_3562_1896:()=>xet,content_3562_1898:()=>Let,content_3562_190:()=>jA,content_3562_1900:()=>bet,content_3562_1902:()=>zet,content_3562_1904:()=>Wet,content_3562_1906:()=>Ret,content_3562_1908:()=>Set,content_3562_1910:()=>Eet,content_3562_1912:()=>Get,content_3562_1914:()=>Uet,content_3562_1916:()=>qet,content_3562_1918:()=>Yet,content_3562_192:()=>HA,content_3562_1920:()=>Qet,content_3562_1922:()=>Ket,content_3562_1924:()=>tnt,content_3562_1926:()=>nnt,content_3562_1928:()=>pnt,content_3562_1930:()=>snt,content_3562_1932:()=>int,content_3562_1934:()=>lnt,content_3562_1936:()=>mnt,content_3562_1938:()=>hnt,content_3562_194:()=>$A,content_3562_1940:()=>knt,content_3562_1942:()=>wnt,content_3562_1944:()=>Mnt,content_3562_1946:()=>_nt,content_3562_1948:()=>Tnt,content_3562_1950:()=>xnt,content_3562_1952:()=>Lnt,content_3562_1954:()=>bnt,content_3562_1956:()=>znt,content_3562_1958:()=>Wnt,content_3562_196:()=>JA,content_3562_1960:()=>Rnt,content_3562_1962:()=>Snt,content_3562_1964:()=>Ent,content_3562_1966:()=>Gnt,content_3562_1968:()=>Unt,content_3562_1970:()=>qnt,content_3562_1972:()=>Ynt,content_3562_1974:()=>Qnt,content_3562_1976:()=>Knt,content_3562_1978:()=>tot,content_3562_198:()=>eW,content_3562_1980:()=>not,content_3562_1982:()=>pot,content_3562_1984:()=>sot,content_3562_1986:()=>iot,content_3562_1988:()=>lot,content_3562_1990:()=>mot,content_3562_1992:()=>hot,content_3562_1994:()=>kot,content_3562_1996:()=>wot,content_3562_1998:()=>Mot,content_3562_2:()=>Xb,content_3562_20:()=>Ob,content_3562_200:()=>oW,content_3562_2000:()=>_ot,content_3562_2002:()=>Tot,content_3562_2004:()=>xot,content_3562_2006:()=>Lot,content_3562_2008:()=>bot,content_3562_2010:()=>zot,content_3562_2012:()=>Wot,content_3562_2014:()=>Rot,content_3562_2016:()=>Sot,content_3562_2018:()=>Eot,content_3562_202:()=>rW,content_3562_2020:()=>Got,content_3562_2022:()=>Uot,content_3562_2024:()=>qot,content_3562_2026:()=>Yot,content_3562_2028:()=>Qot,content_3562_2030:()=>Kot,content_3562_2032:()=>tpt,content_3562_2034:()=>npt,content_3562_2036:()=>ppt,content_3562_2038:()=>spt,content_3562_204:()=>cW,content_3562_2040:()=>ipt,content_3562_2042:()=>lpt,content_3562_2044:()=>mpt,content_3562_2046:()=>hpt,content_3562_2048:()=>kpt,content_3562_2050:()=>wpt,content_3562_2052:()=>Mpt,content_3562_2054:()=>_pt,content_3562_2056:()=>Tpt,content_3562_2058:()=>xpt,content_3562_206:()=>aW,content_3562_2060:()=>Lpt,content_3562_2062:()=>bpt,content_3562_2064:()=>zpt,content_3562_2066:()=>Wpt,content_3562_2068:()=>Rpt,content_3562_2070:()=>Spt,content_3562_2072:()=>Ept,content_3562_2074:()=>Gpt,content_3562_2076:()=>Upt,content_3562_2078:()=>qpt,content_3562_208:()=>uW,content_3562_2080:()=>Ypt,content_3562_2082:()=>Qpt,content_3562_2084:()=>Kpt,content_3562_2086:()=>trt,content_3562_2088:()=>nrt,content_3562_2090:()=>prt,content_3562_2092:()=>srt,content_3562_2094:()=>irt,content_3562_2096:()=>lrt,content_3562_2098:()=>mrt,content_3562_210:()=>dW,content_3562_2100:()=>hrt,content_3562_2102:()=>krt,content_3562_2104:()=>wrt,content_3562_2106:()=>Mrt,content_3562_2108:()=>_rt,content_3562_2110:()=>Trt,content_3562_2112:()=>xrt,content_3562_2114:()=>Lrt,content_3562_2116:()=>brt,content_3562_2118:()=>zrt,content_3562_212:()=>fW,content_3562_2120:()=>Wrt,content_3562_2122:()=>Rrt,content_3562_2124:()=>Srt,content_3562_2126:()=>Ert,content_3562_2128:()=>Grt,content_3562_2130:()=>Urt,content_3562_2132:()=>qrt,content_3562_2134:()=>Yrt,content_3562_2136:()=>Qrt,content_3562_2138:()=>Krt,content_3562_214:()=>yW,content_3562_2140:()=>tst,content_3562_2142:()=>nst,content_3562_2144:()=>pst,content_3562_2146:()=>sst,content_3562_2148:()=>ist,content_3562_2150:()=>lst,content_3562_2152:()=>mst,content_3562_2154:()=>hst,content_3562_2156:()=>kst,content_3562_2158:()=>wst,content_3562_216:()=>DW,content_3562_2160:()=>Mst,content_3562_2162:()=>_st,content_3562_2164:()=>Tst,content_3562_2166:()=>xst,content_3562_2168:()=>Lst,content_3562_2170:()=>bst,content_3562_2172:()=>zst,content_3562_2174:()=>Wst,content_3562_2176:()=>Rst,content_3562_2178:()=>Sst,content_3562_218:()=>XW,content_3562_2180:()=>Est,content_3562_2182:()=>Gst,content_3562_2184:()=>Ust,content_3562_2186:()=>qst,content_3562_2188:()=>Yst,content_3562_2190:()=>Qst,content_3562_2192:()=>Kst,content_3562_2194:()=>tct,content_3562_2196:()=>nct,content_3562_2198:()=>pct,content_3562_22:()=>Bb,content_3562_220:()=>gW,content_3562_2200:()=>sct,content_3562_2202:()=>ict,content_3562_2204:()=>lct,content_3562_2206:()=>mct,content_3562_2208:()=>hct,content_3562_2210:()=>kct,content_3562_2212:()=>wct,content_3562_2214:()=>Mct,content_3562_2216:()=>_ct,content_3562_2218:()=>Tct,content_3562_222:()=>CW,content_3562_2220:()=>xct,content_3562_2222:()=>Lct,content_3562_2224:()=>bct,content_3562_2226:()=>zct,content_3562_2228:()=>Wct,content_3562_2230:()=>Rct,content_3562_2232:()=>Sct,content_3562_2234:()=>Ect,content_3562_2236:()=>Gct,content_3562_2238:()=>Uct,content_3562_224:()=>vW,content_3562_2240:()=>qct,content_3562_2242:()=>Yct,content_3562_2244:()=>Qct,content_3562_2246:()=>Kct,content_3562_2248:()=>tit,content_3562_2250:()=>nit,content_3562_2252:()=>pit,content_3562_2254:()=>sit,content_3562_2256:()=>iit,content_3562_2258:()=>lit,content_3562_226:()=>ZW,content_3562_2260:()=>mit,content_3562_2262:()=>hit,content_3562_2264:()=>kit,content_3562_2266:()=>wit,content_3562_2268:()=>Mit,content_3562_2270:()=>_it,content_3562_2272:()=>Tit,content_3562_2274:()=>xit,content_3562_2276:()=>Lit,content_3562_2278:()=>bit,content_3562_228:()=>NW,content_3562_2280:()=>zit,content_3562_2282:()=>Wit,content_3562_2284:()=>Rit,content_3562_2286:()=>Sit,content_3562_2288:()=>Eit,content_3562_2290:()=>Git,content_3562_2292:()=>Uit,content_3562_2294:()=>qit,content_3562_2296:()=>Yit,content_3562_2298:()=>Qit,content_3562_230:()=>AW,content_3562_2300:()=>Kit,content_3562_2302:()=>tat,content_3562_2304:()=>nat,content_3562_2306:()=>pat,content_3562_2308:()=>sat,content_3562_2310:()=>iat,content_3562_2312:()=>lat,content_3562_2314:()=>mat,content_3562_2316:()=>hat,content_3562_2318:()=>kat,content_3562_232:()=>IW,content_3562_2320:()=>wat,content_3562_2322:()=>Mat,content_3562_2324:()=>_at,content_3562_2326:()=>Tat,content_3562_2328:()=>xat,content_3562_2330:()=>Lat,content_3562_2332:()=>bat,content_3562_2334:()=>zat,content_3562_2336:()=>Wat,content_3562_2338:()=>Rat,content_3562_234:()=>PW,content_3562_2340:()=>Sat,content_3562_2342:()=>Eat,content_3562_2344:()=>Gat,content_3562_2346:()=>Uat,content_3562_2348:()=>qat,content_3562_2350:()=>Yat,content_3562_2352:()=>Qat,content_3562_2354:()=>Kat,content_3562_2356:()=>tlt,content_3562_2358:()=>nlt,content_3562_236:()=>OW,content_3562_2360:()=>plt,content_3562_2362:()=>slt,content_3562_2364:()=>ilt,content_3562_2366:()=>llt,content_3562_2368:()=>mlt,content_3562_2370:()=>hlt,content_3562_2372:()=>klt,content_3562_2374:()=>wlt,content_3562_2376:()=>Mlt,content_3562_2378:()=>_lt,content_3562_238:()=>BW,content_3562_2380:()=>Tlt,content_3562_2382:()=>xlt,content_3562_2384:()=>Llt,content_3562_2386:()=>blt,content_3562_2388:()=>zlt,content_3562_2390:()=>Wlt,content_3562_2392:()=>Rlt,content_3562_2394:()=>Slt,content_3562_2396:()=>Elt,content_3562_2398:()=>Glt,content_3562_24:()=>Vb,content_3562_240:()=>VW,content_3562_2400:()=>Ult,content_3562_2402:()=>qlt,content_3562_2404:()=>Ylt,content_3562_2406:()=>Qlt,content_3562_2408:()=>Klt,content_3562_2410:()=>tut,content_3562_2412:()=>nut,content_3562_2414:()=>put,content_3562_2416:()=>sut,content_3562_2418:()=>iut,content_3562_242:()=>FW,content_3562_2420:()=>lut,content_3562_2422:()=>mut,content_3562_2424:()=>hut,content_3562_2426:()=>kut,content_3562_2428:()=>wut,content_3562_2430:()=>Mut,content_3562_2432:()=>_ut,content_3562_2434:()=>Tut,content_3562_2436:()=>xut,content_3562_2438:()=>Lut,content_3562_244:()=>jW,content_3562_2440:()=>but,content_3562_2442:()=>zut,content_3562_2444:()=>Wut,content_3562_2446:()=>Rut,content_3562_2448:()=>Sut,content_3562_2450:()=>Eut,content_3562_2452:()=>Gut,content_3562_2454:()=>Uut,content_3562_2456:()=>qut,content_3562_2458:()=>Yut,content_3562_246:()=>HW,content_3562_2460:()=>Qut,content_3562_2462:()=>Kut,content_3562_2464:()=>tmt,content_3562_2466:()=>nmt,content_3562_2468:()=>pmt,content_3562_2470:()=>smt,content_3562_2472:()=>imt,content_3562_2474:()=>lmt,content_3562_2476:()=>mmt,content_3562_2478:()=>hmt,content_3562_248:()=>$W,content_3562_2480:()=>kmt,content_3562_2482:()=>wmt,content_3562_2484:()=>Mmt,content_3562_2486:()=>_mt,content_3562_2488:()=>Tmt,content_3562_2490:()=>xmt,content_3562_2492:()=>Lmt,content_3562_2494:()=>bmt,content_3562_2496:()=>zmt,content_3562_2498:()=>Wmt,content_3562_250:()=>JW,content_3562_2500:()=>Rmt,content_3562_2502:()=>Smt,content_3562_2504:()=>Emt,content_3562_2506:()=>Gmt,content_3562_2508:()=>Umt,content_3562_2510:()=>qmt,content_3562_2512:()=>Ymt,content_3562_2514:()=>Qmt,content_3562_2516:()=>Kmt,content_3562_2518:()=>tdt,content_3562_252:()=>eI,content_3562_2520:()=>ndt,content_3562_2522:()=>pdt,content_3562_2524:()=>sdt,content_3562_2526:()=>idt,content_3562_2528:()=>ldt,content_3562_2530:()=>mdt,content_3562_2532:()=>hdt,content_3562_2534:()=>kdt,content_3562_2536:()=>wdt,content_3562_2538:()=>Mdt,content_3562_254:()=>oI,content_3562_2540:()=>_dt,content_3562_2542:()=>Tdt,content_3562_2544:()=>xdt,content_3562_2546:()=>Ldt,content_3562_2548:()=>bdt,content_3562_2550:()=>zdt,content_3562_2552:()=>Wdt,content_3562_2554:()=>Rdt,content_3562_2556:()=>Sdt,content_3562_2558:()=>Edt,content_3562_256:()=>rI,content_3562_2560:()=>Gdt,content_3562_2562:()=>Udt,content_3562_2564:()=>qdt,content_3562_2566:()=>Ydt,content_3562_2568:()=>Qdt,content_3562_2570:()=>Kdt,content_3562_2572:()=>tht,content_3562_2574:()=>nht,content_3562_2576:()=>pht,content_3562_2578:()=>sht,content_3562_258:()=>cI,content_3562_2580:()=>iht,content_3562_2582:()=>lht,content_3562_2584:()=>mht,content_3562_2586:()=>hht,content_3562_2588:()=>kht,content_3562_2590:()=>wht,content_3562_2592:()=>Mht,content_3562_2594:()=>_ht,content_3562_2596:()=>Tht,content_3562_2598:()=>xht,content_3562_26:()=>Fb,content_3562_260:()=>aI,content_3562_2600:()=>Lht,content_3562_2602:()=>bht,content_3562_2604:()=>zht,content_3562_2606:()=>Wht,content_3562_2608:()=>Rht,content_3562_2610:()=>Sht,content_3562_2612:()=>Eht,content_3562_2614:()=>Ght,content_3562_2616:()=>Uht,content_3562_2618:()=>qht,content_3562_262:()=>uI,content_3562_2620:()=>Yht,content_3562_2622:()=>Qht,content_3562_2624:()=>Kht,content_3562_2626:()=>tft,content_3562_2628:()=>nft,content_3562_2630:()=>pft,content_3562_2632:()=>sft,content_3562_2634:()=>ift,content_3562_2636:()=>lft,content_3562_2638:()=>mft,content_3562_264:()=>dI,content_3562_2640:()=>hft,content_3562_2642:()=>kft,content_3562_2644:()=>wft,content_3562_2646:()=>Mft,content_3562_2648:()=>_ft,content_3562_2650:()=>Tft,content_3562_2652:()=>xft,content_3562_2654:()=>Lft,content_3562_2656:()=>bft,content_3562_2658:()=>zft,content_3562_266:()=>fI,content_3562_2660:()=>Wft,content_3562_2662:()=>Rft,content_3562_2664:()=>Sft,content_3562_2666:()=>Eft,content_3562_2668:()=>Gft,content_3562_2670:()=>Uft,content_3562_2672:()=>qft,content_3562_2674:()=>Yft,content_3562_2676:()=>Qft,content_3562_2678:()=>Kft,content_3562_268:()=>yI,content_3562_2680:()=>tkt,content_3562_2682:()=>nkt,content_3562_2684:()=>pkt,content_3562_2686:()=>skt,content_3562_2688:()=>ikt,content_3562_2690:()=>lkt,content_3562_2692:()=>mkt,content_3562_2694:()=>hkt,content_3562_2696:()=>kkt,content_3562_2698:()=>wkt,content_3562_270:()=>DI,content_3562_2700:()=>Mkt,content_3562_2702:()=>_kt,content_3562_2704:()=>Tkt,content_3562_2706:()=>xkt,content_3562_2708:()=>Lkt,content_3562_2710:()=>bkt,content_3562_2712:()=>zkt,content_3562_2714:()=>Wkt,content_3562_2716:()=>Rkt,content_3562_2718:()=>Skt,content_3562_272:()=>XI,content_3562_2720:()=>Ekt,content_3562_2722:()=>Gkt,content_3562_2724:()=>Ukt,content_3562_2726:()=>qkt,content_3562_2728:()=>Ykt,content_3562_2730:()=>Qkt,content_3562_2732:()=>Kkt,content_3562_2734:()=>tyt,content_3562_2736:()=>nyt,content_3562_2738:()=>pyt,content_3562_274:()=>gI,content_3562_2740:()=>syt,content_3562_2742:()=>iyt,content_3562_2744:()=>lyt,content_3562_2746:()=>myt,content_3562_2748:()=>hyt,content_3562_2750:()=>kyt,content_3562_2752:()=>wyt,content_3562_2754:()=>Myt,content_3562_2756:()=>_yt,content_3562_2758:()=>Tyt,content_3562_276:()=>CI,content_3562_2760:()=>xyt,content_3562_2762:()=>Lyt,content_3562_2764:()=>byt,content_3562_2766:()=>zyt,content_3562_2768:()=>Wyt,content_3562_2770:()=>Ryt,content_3562_2772:()=>Syt,content_3562_2774:()=>Eyt,content_3562_2776:()=>Gyt,content_3562_2778:()=>Uyt,content_3562_278:()=>vI,content_3562_2780:()=>qyt,content_3562_2782:()=>Yyt,content_3562_2784:()=>Qyt,content_3562_2786:()=>Kyt,content_3562_2788:()=>twt,content_3562_2790:()=>nwt,content_3562_2792:()=>pwt,content_3562_2794:()=>swt,content_3562_2796:()=>iwt,content_3562_2798:()=>lwt,content_3562_28:()=>jb,content_3562_280:()=>ZI,content_3562_2800:()=>mwt,content_3562_2802:()=>hwt,content_3562_2804:()=>kwt,content_3562_2806:()=>wwt,content_3562_2808:()=>Mwt,content_3562_2810:()=>_wt,content_3562_2812:()=>Twt,content_3562_2814:()=>xwt,content_3562_2816:()=>Lwt,content_3562_2818:()=>bwt,content_3562_282:()=>NI,content_3562_2820:()=>zwt,content_3562_2822:()=>Wwt,content_3562_2824:()=>Rwt,content_3562_2826:()=>Swt,content_3562_2828:()=>Ewt,content_3562_2830:()=>Gwt,content_3562_2832:()=>Uwt,content_3562_2834:()=>qwt,content_3562_2836:()=>Ywt,content_3562_2838:()=>Qwt,content_3562_284:()=>AI,content_3562_2840:()=>Kwt,content_3562_2842:()=>tDt,content_3562_2844:()=>nDt,content_3562_2846:()=>pDt,content_3562_2848:()=>sDt,content_3562_2850:()=>iDt,content_3562_2852:()=>lDt,content_3562_2854:()=>mDt,content_3562_2856:()=>hDt,content_3562_2858:()=>kDt,content_3562_286:()=>II,content_3562_2860:()=>wDt,content_3562_2862:()=>MDt,content_3562_2864:()=>_Dt,content_3562_2866:()=>TDt,content_3562_2868:()=>xDt,content_3562_2870:()=>LDt,content_3562_2872:()=>bDt,content_3562_2874:()=>zDt,content_3562_2876:()=>WDt,content_3562_2878:()=>RDt,content_3562_288:()=>PI,content_3562_2880:()=>SDt,content_3562_2882:()=>EDt,content_3562_2884:()=>GDt,content_3562_2886:()=>UDt,content_3562_2888:()=>qDt,content_3562_2890:()=>YDt,content_3562_2892:()=>QDt,content_3562_2894:()=>KDt,content_3562_2896:()=>tMt,content_3562_2898:()=>nMt,content_3562_290:()=>OI,content_3562_2900:()=>pMt,content_3562_2902:()=>sMt,content_3562_2904:()=>iMt,content_3562_2906:()=>lMt,content_3562_2908:()=>mMt,content_3562_2910:()=>hMt,content_3562_2912:()=>kMt,content_3562_2914:()=>wMt,content_3562_2916:()=>MMt,content_3562_2918:()=>_Mt,content_3562_292:()=>BI,content_3562_2920:()=>TMt,content_3562_2922:()=>xMt,content_3562_2924:()=>LMt,content_3562_2926:()=>bMt,content_3562_2928:()=>zMt,content_3562_2930:()=>WMt,content_3562_2932:()=>RMt,content_3562_2934:()=>SMt,content_3562_2936:()=>EMt,content_3562_2938:()=>GMt,content_3562_294:()=>VI,content_3562_2940:()=>UMt,content_3562_2942:()=>qMt,content_3562_2944:()=>YMt,content_3562_2946:()=>QMt,content_3562_2948:()=>KMt,content_3562_2950:()=>tXt,content_3562_2952:()=>nXt,content_3562_2954:()=>pXt,content_3562_2956:()=>sXt,content_3562_2958:()=>iXt,content_3562_296:()=>FI,content_3562_2960:()=>lXt,content_3562_2962:()=>mXt,content_3562_2964:()=>hXt,content_3562_2966:()=>kXt,content_3562_2968:()=>wXt,content_3562_2970:()=>MXt,content_3562_2972:()=>_Xt,content_3562_2974:()=>TXt,content_3562_2976:()=>xXt,content_3562_2978:()=>LXt,content_3562_298:()=>jI,content_3562_2980:()=>bXt,content_3562_2982:()=>zXt,content_3562_2984:()=>WXt,content_3562_2986:()=>RXt,content_3562_2988:()=>SXt,content_3562_2990:()=>EXt,content_3562_2992:()=>GXt,content_3562_2994:()=>UXt,content_3562_2996:()=>qXt,content_3562_2998:()=>YXt,content_3562_30:()=>Hb,content_3562_300:()=>HI,content_3562_3000:()=>QXt,content_3562_3002:()=>KXt,content_3562_3004:()=>t_t,content_3562_3006:()=>n_t,content_3562_3008:()=>p_t,content_3562_3010:()=>s_t,content_3562_3012:()=>i_t,content_3562_3014:()=>l_t,content_3562_3016:()=>m_t,content_3562_3018:()=>h_t,content_3562_302:()=>$I,content_3562_3020:()=>k_t,content_3562_3022:()=>w_t,content_3562_3024:()=>M_t,content_3562_3026:()=>__t,content_3562_3028:()=>T_t,content_3562_3030:()=>x_t,content_3562_3032:()=>L_t,content_3562_3034:()=>b_t,content_3562_3036:()=>z_t,content_3562_3038:()=>W_t,content_3562_304:()=>JI,content_3562_3040:()=>R_t,content_3562_3042:()=>S_t,content_3562_3044:()=>E_t,content_3562_3046:()=>G_t,content_3562_3048:()=>U_t,content_3562_3050:()=>q_t,content_3562_3052:()=>Y_t,content_3562_3054:()=>Q_t,content_3562_3056:()=>K_t,content_3562_3058:()=>tgt,content_3562_306:()=>eR,content_3562_3060:()=>ngt,content_3562_3062:()=>pgt,content_3562_3064:()=>sgt,content_3562_3066:()=>igt,content_3562_3068:()=>lgt,content_3562_3070:()=>mgt,content_3562_3072:()=>hgt,content_3562_3074:()=>kgt,content_3562_3076:()=>wgt,content_3562_3078:()=>Mgt,content_3562_308:()=>oR,content_3562_3080:()=>_gt,content_3562_3082:()=>Tgt,content_3562_3084:()=>xgt,content_3562_3086:()=>Lgt,content_3562_3088:()=>bgt,content_3562_3090:()=>zgt,content_3562_3092:()=>Wgt,content_3562_3094:()=>Rgt,content_3562_3096:()=>Sgt,content_3562_3098:()=>Egt,content_3562_310:()=>rR,content_3562_3100:()=>Ggt,content_3562_3102:()=>Ugt,content_3562_3104:()=>qgt,content_3562_3106:()=>Ygt,content_3562_3108:()=>Qgt,content_3562_3110:()=>Kgt,content_3562_3112:()=>tTt,content_3562_3114:()=>nTt,content_3562_3116:()=>pTt,content_3562_3118:()=>sTt,content_3562_312:()=>cR,content_3562_3120:()=>iTt,content_3562_3122:()=>lTt,content_3562_3124:()=>mTt,content_3562_3126:()=>hTt,content_3562_3128:()=>kTt,content_3562_3130:()=>wTt,content_3562_3132:()=>MTt,content_3562_3134:()=>_Tt,content_3562_3136:()=>TTt,content_3562_3138:()=>xTt,content_3562_314:()=>aR,content_3562_3140:()=>LTt,content_3562_3142:()=>bTt,content_3562_3144:()=>zTt,content_3562_3146:()=>WTt,content_3562_3148:()=>RTt,content_3562_3150:()=>STt,content_3562_3152:()=>ETt,content_3562_3154:()=>GTt,content_3562_3156:()=>UTt,content_3562_3158:()=>qTt,content_3562_316:()=>uR,content_3562_3160:()=>YTt,content_3562_3162:()=>QTt,content_3562_3164:()=>KTt,content_3562_3166:()=>tCt,content_3562_3168:()=>nCt,content_3562_3170:()=>pCt,content_3562_3172:()=>sCt,content_3562_3174:()=>iCt,content_3562_3176:()=>lCt,content_3562_3178:()=>mCt,content_3562_318:()=>dR,content_3562_3180:()=>hCt,content_3562_3182:()=>kCt,content_3562_3184:()=>wCt,content_3562_3186:()=>MCt,content_3562_3188:()=>_Ct,content_3562_3190:()=>TCt,content_3562_3192:()=>xCt,content_3562_3194:()=>LCt,content_3562_3196:()=>bCt,content_3562_3198:()=>zCt,content_3562_32:()=>$b,content_3562_320:()=>fR,content_3562_3200:()=>WCt,content_3562_3202:()=>RCt,content_3562_3204:()=>SCt,content_3562_3206:()=>ECt,content_3562_3208:()=>GCt,content_3562_3210:()=>UCt,content_3562_3212:()=>qCt,content_3562_3214:()=>YCt,content_3562_3216:()=>QCt,content_3562_3218:()=>KCt,content_3562_322:()=>yR,content_3562_3220:()=>txt,content_3562_3222:()=>nxt,content_3562_3224:()=>pxt,content_3562_3226:()=>sxt,content_3562_3228:()=>ixt,content_3562_3230:()=>lxt,content_3562_3232:()=>mxt,content_3562_3234:()=>hxt,content_3562_3236:()=>kxt,content_3562_3238:()=>wxt,content_3562_324:()=>DR,content_3562_3240:()=>Mxt,content_3562_3242:()=>_xt,content_3562_3244:()=>Txt,content_3562_3246:()=>xxt,content_3562_3248:()=>Lxt,content_3562_3250:()=>bxt,content_3562_3252:()=>zxt,content_3562_3254:()=>Wxt,content_3562_3256:()=>Rxt,content_3562_3258:()=>Sxt,content_3562_326:()=>XR,content_3562_3260:()=>Ext,content_3562_3262:()=>Gxt,content_3562_3264:()=>Uxt,content_3562_3266:()=>qxt,content_3562_3268:()=>Yxt,content_3562_3270:()=>Qxt,content_3562_3272:()=>Kxt,content_3562_3274:()=>tvt,content_3562_3276:()=>nvt,content_3562_3278:()=>pvt,content_3562_328:()=>gR,content_3562_3280:()=>svt,content_3562_3282:()=>ivt,content_3562_3284:()=>lvt,content_3562_3286:()=>mvt,content_3562_3288:()=>hvt,content_3562_3290:()=>kvt,content_3562_3292:()=>wvt,content_3562_3294:()=>Mvt,content_3562_3296:()=>_vt,content_3562_3298:()=>Tvt,content_3562_330:()=>CR,content_3562_3300:()=>xvt,content_3562_3302:()=>Lvt,content_3562_3304:()=>bvt,content_3562_3306:()=>zvt,content_3562_3308:()=>Wvt,content_3562_3310:()=>Rvt,content_3562_3312:()=>Svt,content_3562_3314:()=>Evt,content_3562_3316:()=>Gvt,content_3562_3318:()=>Uvt,content_3562_332:()=>vR,content_3562_3320:()=>qvt,content_3562_3322:()=>Yvt,content_3562_3324:()=>Qvt,content_3562_3326:()=>Kvt,content_3562_3328:()=>tLt,content_3562_3330:()=>nLt,content_3562_3332:()=>pLt,content_3562_3334:()=>sLt,content_3562_3336:()=>iLt,content_3562_3338:()=>lLt,content_3562_334:()=>ZR,content_3562_3340:()=>mLt,content_3562_3342:()=>hLt,content_3562_3344:()=>kLt,content_3562_3346:()=>wLt,content_3562_3348:()=>MLt,content_3562_3350:()=>_Lt,content_3562_3352:()=>TLt,content_3562_3354:()=>xLt,content_3562_3356:()=>LLt,content_3562_3358:()=>bLt,content_3562_336:()=>NR,content_3562_3360:()=>zLt,content_3562_3362:()=>WLt,content_3562_3364:()=>RLt,content_3562_3366:()=>SLt,content_3562_3368:()=>ELt,content_3562_3370:()=>GLt,content_3562_3372:()=>ULt,content_3562_3374:()=>qLt,content_3562_3376:()=>YLt,content_3562_3378:()=>QLt,content_3562_338:()=>AR,content_3562_3380:()=>KLt,content_3562_3382:()=>tZt,content_3562_3384:()=>nZt,content_3562_3386:()=>pZt,content_3562_3388:()=>sZt,content_3562_3390:()=>iZt,content_3562_3392:()=>lZt,content_3562_3394:()=>mZt,content_3562_3396:()=>hZt,content_3562_3398:()=>kZt,content_3562_34:()=>Jb,content_3562_340:()=>IR,content_3562_3400:()=>wZt,content_3562_3402:()=>MZt,content_3562_3404:()=>_Zt,content_3562_3406:()=>TZt,content_3562_3408:()=>xZt,content_3562_3410:()=>LZt,content_3562_3412:()=>bZt,content_3562_3414:()=>zZt,content_3562_3416:()=>WZt,content_3562_3418:()=>RZt,content_3562_342:()=>PR,content_3562_3420:()=>SZt,content_3562_3422:()=>EZt,content_3562_3424:()=>GZt,content_3562_3426:()=>UZt,content_3562_3428:()=>qZt,content_3562_3430:()=>YZt,content_3562_3432:()=>QZt,content_3562_3434:()=>KZt,content_3562_3436:()=>tbt,content_3562_3438:()=>nbt,content_3562_344:()=>OR,content_3562_3440:()=>pbt,content_3562_3442:()=>sbt,content_3562_3444:()=>ibt,content_3562_3446:()=>lbt,content_3562_3448:()=>mbt,content_3562_3450:()=>hbt,content_3562_3452:()=>kbt,content_3562_3454:()=>wbt,content_3562_3456:()=>Mbt,content_3562_3458:()=>_bt,content_3562_346:()=>BR,content_3562_3460:()=>Tbt,content_3562_3462:()=>xbt,content_3562_3464:()=>Lbt,content_3562_3466:()=>bbt,content_3562_3468:()=>zbt,content_3562_3470:()=>Wbt,content_3562_3472:()=>Rbt,content_3562_3474:()=>Sbt,content_3562_3476:()=>Ebt,content_3562_3478:()=>Gbt,content_3562_348:()=>VR,content_3562_3480:()=>Ubt,content_3562_3482:()=>qbt,content_3562_3484:()=>Ybt,content_3562_3486:()=>Qbt,content_3562_3488:()=>Kbt,content_3562_3490:()=>tNt,content_3562_3492:()=>nNt,content_3562_3494:()=>pNt,content_3562_3496:()=>sNt,content_3562_3498:()=>iNt,content_3562_350:()=>FR,content_3562_3500:()=>lNt,content_3562_3502:()=>mNt,content_3562_3504:()=>hNt,content_3562_3506:()=>kNt,content_3562_3508:()=>wNt,content_3562_3510:()=>MNt,content_3562_3512:()=>_Nt,content_3562_3514:()=>TNt,content_3562_3516:()=>xNt,content_3562_3518:()=>LNt,content_3562_352:()=>jR,content_3562_3520:()=>bNt,content_3562_3522:()=>zNt,content_3562_3524:()=>WNt,content_3562_3526:()=>RNt,content_3562_3528:()=>SNt,content_3562_3530:()=>ENt,content_3562_3532:()=>GNt,content_3562_3534:()=>UNt,content_3562_3536:()=>qNt,content_3562_3538:()=>YNt,content_3562_354:()=>HR,content_3562_3540:()=>QNt,content_3562_3542:()=>KNt,content_3562_3544:()=>tzt,content_3562_3546:()=>nzt,content_3562_3548:()=>pzt,content_3562_3550:()=>szt,content_3562_3552:()=>izt,content_3562_3554:()=>lzt,content_3562_3556:()=>mzt,content_3562_3558:()=>hzt,content_3562_356:()=>$R,content_3562_3560:()=>kzt,content_3562_3562:()=>wzt,content_3562_3564:()=>Mzt,content_3562_3566:()=>_zt,content_3562_3568:()=>Tzt,content_3562_3570:()=>xzt,content_3562_3572:()=>Lzt,content_3562_3574:()=>bzt,content_3562_3576:()=>zzt,content_3562_3578:()=>Wzt,content_3562_358:()=>JR,content_3562_3580:()=>Rzt,content_3562_3582:()=>Szt,content_3562_3584:()=>Ezt,content_3562_3586:()=>Gzt,content_3562_3588:()=>Uzt,content_3562_3590:()=>qzt,content_3562_3592:()=>Yzt,content_3562_3594:()=>Qzt,content_3562_3596:()=>Kzt,content_3562_3598:()=>tAt,content_3562_36:()=>eN,content_3562_360:()=>eP,content_3562_3600:()=>nAt,content_3562_3602:()=>pAt,content_3562_3604:()=>sAt,content_3562_3606:()=>iAt,content_3562_3608:()=>lAt,content_3562_3610:()=>mAt,content_3562_3612:()=>hAt,content_3562_3614:()=>kAt,content_3562_3616:()=>wAt,content_3562_3618:()=>MAt,content_3562_362:()=>oP,content_3562_3620:()=>_At,content_3562_3622:()=>TAt,content_3562_3624:()=>xAt,content_3562_3626:()=>LAt,content_3562_3628:()=>bAt,content_3562_3630:()=>zAt,content_3562_3632:()=>WAt,content_3562_3634:()=>RAt,content_3562_3636:()=>SAt,content_3562_3638:()=>EAt,content_3562_364:()=>rP,content_3562_3640:()=>GAt,content_3562_3642:()=>UAt,content_3562_3644:()=>qAt,content_3562_3646:()=>YAt,content_3562_3648:()=>QAt,content_3562_3650:()=>KAt,content_3562_3652:()=>tWt,content_3562_3654:()=>nWt,content_3562_3656:()=>pWt,content_3562_3658:()=>sWt,content_3562_366:()=>cP,content_3562_3660:()=>iWt,content_3562_3662:()=>lWt,content_3562_3664:()=>mWt,content_3562_3666:()=>hWt,content_3562_3668:()=>kWt,content_3562_3670:()=>wWt,content_3562_3672:()=>MWt,content_3562_3674:()=>_Wt,content_3562_3676:()=>TWt,content_3562_3678:()=>xWt,content_3562_368:()=>aP,content_3562_3680:()=>LWt,content_3562_3682:()=>bWt,content_3562_3684:()=>zWt,content_3562_3686:()=>WWt,content_3562_3688:()=>RWt,content_3562_3690:()=>SWt,content_3562_3692:()=>EWt,content_3562_3694:()=>GWt,content_3562_3696:()=>UWt,content_3562_3698:()=>qWt,content_3562_370:()=>uP,content_3562_3700:()=>YWt,content_3562_3702:()=>QWt,content_3562_3704:()=>KWt,content_3562_3706:()=>tIt,content_3562_3708:()=>nIt,content_3562_3710:()=>pIt,content_3562_3712:()=>sIt,content_3562_3714:()=>iIt,content_3562_3716:()=>lIt,content_3562_3718:()=>mIt,content_3562_372:()=>dP,content_3562_3720:()=>hIt,content_3562_3722:()=>kIt,content_3562_3724:()=>wIt,content_3562_3726:()=>MIt,content_3562_3728:()=>_It,content_3562_3730:()=>TIt,content_3562_3732:()=>xIt,content_3562_3734:()=>LIt,content_3562_3736:()=>bIt,content_3562_3738:()=>zIt,content_3562_374:()=>fP,content_3562_3740:()=>WIt,content_3562_3742:()=>RIt,content_3562_3744:()=>SIt,content_3562_3746:()=>EIt,content_3562_3748:()=>GIt,content_3562_3750:()=>UIt,content_3562_3752:()=>qIt,content_3562_3754:()=>YIt,content_3562_3756:()=>QIt,content_3562_3758:()=>KIt,content_3562_376:()=>yP,content_3562_3760:()=>tRt,content_3562_3762:()=>nRt,content_3562_3764:()=>pRt,content_3562_3766:()=>sRt,content_3562_3768:()=>iRt,content_3562_3770:()=>lRt,content_3562_3772:()=>mRt,content_3562_3774:()=>hRt,content_3562_3776:()=>kRt,content_3562_3778:()=>wRt,content_3562_378:()=>DP,content_3562_3780:()=>MRt,content_3562_3782:()=>_Rt,content_3562_3784:()=>TRt,content_3562_3786:()=>xRt,content_3562_3788:()=>LRt,content_3562_3790:()=>bRt,content_3562_3792:()=>zRt,content_3562_3794:()=>WRt,content_3562_3796:()=>RRt,content_3562_3798:()=>SRt,content_3562_38:()=>oN,content_3562_380:()=>XP,content_3562_3800:()=>ERt,content_3562_3802:()=>GRt,content_3562_3804:()=>URt,content_3562_3806:()=>qRt,content_3562_3808:()=>YRt,content_3562_3810:()=>QRt,content_3562_3812:()=>KRt,content_3562_3814:()=>tPt,content_3562_3816:()=>nPt,content_3562_3818:()=>pPt,content_3562_382:()=>gP,content_3562_3820:()=>sPt,content_3562_3822:()=>iPt,content_3562_3824:()=>lPt,content_3562_3826:()=>mPt,content_3562_3828:()=>hPt,content_3562_3830:()=>kPt,content_3562_3832:()=>wPt,content_3562_3834:()=>MPt,content_3562_3836:()=>_Pt,content_3562_3838:()=>TPt,content_3562_384:()=>CP,content_3562_3840:()=>xPt,content_3562_3842:()=>LPt,content_3562_3844:()=>bPt,content_3562_3846:()=>zPt,content_3562_3848:()=>WPt,content_3562_3850:()=>RPt,content_3562_3852:()=>SPt,content_3562_3854:()=>EPt,content_3562_3856:()=>GPt,content_3562_3858:()=>UPt,content_3562_386:()=>vP,content_3562_3860:()=>qPt,content_3562_3862:()=>YPt,content_3562_3864:()=>QPt,content_3562_3866:()=>KPt,content_3562_3868:()=>tSt,content_3562_3870:()=>nSt,content_3562_3872:()=>pSt,content_3562_3874:()=>sSt,content_3562_3876:()=>iSt,content_3562_3878:()=>lSt,content_3562_388:()=>ZP,content_3562_3880:()=>mSt,content_3562_3882:()=>hSt,content_3562_3884:()=>kSt,content_3562_3886:()=>wSt,content_3562_3888:()=>MSt,content_3562_3890:()=>_St,content_3562_3892:()=>TSt,content_3562_3894:()=>xSt,content_3562_3896:()=>LSt,content_3562_3898:()=>bSt,content_3562_390:()=>NP,content_3562_3900:()=>zSt,content_3562_3902:()=>WSt,content_3562_3904:()=>RSt,content_3562_3906:()=>SSt,content_3562_3908:()=>ESt,content_3562_3910:()=>GSt,content_3562_3912:()=>USt,content_3562_3914:()=>qSt,content_3562_3916:()=>YSt,content_3562_3918:()=>QSt,content_3562_392:()=>AP,content_3562_3920:()=>KSt,content_3562_3922:()=>tOt,content_3562_3924:()=>nOt,content_3562_3926:()=>pOt,content_3562_3928:()=>sOt,content_3562_3930:()=>iOt,content_3562_3932:()=>lOt,content_3562_3934:()=>mOt,content_3562_3936:()=>hOt,content_3562_3938:()=>kOt,content_3562_394:()=>IP,content_3562_3940:()=>wOt,content_3562_3942:()=>MOt,content_3562_3944:()=>_Ot,content_3562_3946:()=>TOt,content_3562_3948:()=>xOt,content_3562_3950:()=>LOt,content_3562_3952:()=>bOt,content_3562_3954:()=>zOt,content_3562_3956:()=>WOt,content_3562_3958:()=>ROt,content_3562_396:()=>PP,content_3562_3960:()=>SOt,content_3562_3962:()=>EOt,content_3562_3964:()=>GOt,content_3562_3966:()=>UOt,content_3562_3968:()=>qOt,content_3562_3970:()=>YOt,content_3562_3972:()=>QOt,content_3562_3974:()=>KOt,content_3562_3976:()=>tEt,content_3562_3978:()=>nEt,content_3562_398:()=>OP,content_3562_3980:()=>pEt,content_3562_3982:()=>sEt,content_3562_3984:()=>iEt,content_3562_3986:()=>lEt,content_3562_3988:()=>mEt,content_3562_3990:()=>hEt,content_3562_3992:()=>kEt,content_3562_3994:()=>wEt,content_3562_3996:()=>MEt,content_3562_3998:()=>_Et,content_3562_4:()=>gb,content_3562_40:()=>rN,content_3562_400:()=>BP,content_3562_4000:()=>TEt,content_3562_4002:()=>xEt,content_3562_4004:()=>LEt,content_3562_4006:()=>bEt,content_3562_4008:()=>zEt,content_3562_4010:()=>WEt,content_3562_4012:()=>REt,content_3562_4014:()=>SEt,content_3562_4016:()=>EEt,content_3562_4018:()=>GEt,content_3562_402:()=>VP,content_3562_4020:()=>UEt,content_3562_4022:()=>qEt,content_3562_4024:()=>YEt,content_3562_4026:()=>QEt,content_3562_4028:()=>KEt,content_3562_4030:()=>tBt,content_3562_4032:()=>nBt,content_3562_4034:()=>pBt,content_3562_4036:()=>sBt,content_3562_4038:()=>iBt,content_3562_404:()=>FP,content_3562_4040:()=>lBt,content_3562_4042:()=>mBt,content_3562_4044:()=>hBt,content_3562_4046:()=>kBt,content_3562_4048:()=>wBt,content_3562_4050:()=>MBt,content_3562_4052:()=>_Bt,content_3562_4054:()=>TBt,content_3562_4056:()=>xBt,content_3562_4058:()=>LBt,content_3562_406:()=>jP,content_3562_4060:()=>bBt,content_3562_4062:()=>zBt,content_3562_4064:()=>WBt,content_3562_4066:()=>RBt,content_3562_4068:()=>SBt,content_3562_4070:()=>EBt,content_3562_4072:()=>GBt,content_3562_4074:()=>UBt,content_3562_4076:()=>qBt,content_3562_4078:()=>YBt,content_3562_408:()=>HP,content_3562_4080:()=>QBt,content_3562_4082:()=>KBt,content_3562_4084:()=>tGt,content_3562_4086:()=>nGt,content_3562_4088:()=>pGt,content_3562_4090:()=>sGt,content_3562_4092:()=>iGt,content_3562_4094:()=>lGt,content_3562_4096:()=>mGt,content_3562_4098:()=>hGt,content_3562_410:()=>$P,content_3562_4100:()=>kGt,content_3562_4102:()=>wGt,content_3562_4104:()=>MGt,content_3562_4106:()=>_Gt,content_3562_4108:()=>TGt,content_3562_4110:()=>xGt,content_3562_4112:()=>LGt,content_3562_4114:()=>bGt,content_3562_4116:()=>zGt,content_3562_4118:()=>WGt,content_3562_412:()=>JP,content_3562_4120:()=>RGt,content_3562_4122:()=>SGt,content_3562_4124:()=>EGt,content_3562_4126:()=>GGt,content_3562_4128:()=>UGt,content_3562_4130:()=>qGt,content_3562_4132:()=>YGt,content_3562_4134:()=>QGt,content_3562_4136:()=>KGt,content_3562_4138:()=>tVt,content_3562_414:()=>eS,content_3562_4140:()=>nVt,content_3562_4142:()=>pVt,content_3562_4144:()=>sVt,content_3562_4146:()=>iVt,content_3562_4148:()=>lVt,content_3562_4150:()=>mVt,content_3562_4152:()=>hVt,content_3562_4154:()=>kVt,content_3562_4156:()=>wVt,content_3562_4158:()=>MVt,content_3562_416:()=>oS,content_3562_4160:()=>_Vt,content_3562_4162:()=>TVt,content_3562_4164:()=>xVt,content_3562_4166:()=>LVt,content_3562_4168:()=>bVt,content_3562_4170:()=>zVt,content_3562_4172:()=>WVt,content_3562_4174:()=>RVt,content_3562_4176:()=>SVt,content_3562_4178:()=>EVt,content_3562_418:()=>rS,content_3562_4180:()=>GVt,content_3562_4182:()=>UVt,content_3562_4184:()=>qVt,content_3562_4186:()=>YVt,content_3562_4188:()=>QVt,content_3562_4190:()=>KVt,content_3562_4192:()=>tUt,content_3562_4194:()=>nUt,content_3562_4196:()=>pUt,content_3562_4198:()=>sUt,content_3562_42:()=>cN,content_3562_420:()=>cS,content_3562_4200:()=>iUt,content_3562_4202:()=>lUt,content_3562_4204:()=>mUt,content_3562_4206:()=>hUt,content_3562_4208:()=>kUt,content_3562_4210:()=>wUt,content_3562_4212:()=>MUt,content_3562_4214:()=>_Ut,content_3562_4216:()=>TUt,content_3562_4218:()=>xUt,content_3562_422:()=>aS,content_3562_4220:()=>LUt,content_3562_4222:()=>bUt,content_3562_4224:()=>zUt,content_3562_4226:()=>WUt,content_3562_4228:()=>RUt,content_3562_4230:()=>SUt,content_3562_4232:()=>EUt,content_3562_4234:()=>GUt,content_3562_4236:()=>UUt,content_3562_4238:()=>qUt,content_3562_424:()=>uS,content_3562_4240:()=>YUt,content_3562_4242:()=>QUt,content_3562_4244:()=>KUt,content_3562_4246:()=>tFt,content_3562_4248:()=>nFt,content_3562_4250:()=>pFt,content_3562_4252:()=>sFt,content_3562_4254:()=>iFt,content_3562_4256:()=>lFt,content_3562_4258:()=>mFt,content_3562_426:()=>dS,content_3562_4260:()=>hFt,content_3562_4262:()=>kFt,content_3562_4264:()=>wFt,content_3562_4266:()=>MFt,content_3562_4268:()=>_Ft,content_3562_4270:()=>TFt,content_3562_4272:()=>xFt,content_3562_4274:()=>LFt,content_3562_4276:()=>bFt,content_3562_4278:()=>zFt,content_3562_428:()=>fS,content_3562_4280:()=>WFt,content_3562_4282:()=>RFt,content_3562_4284:()=>SFt,content_3562_4286:()=>EFt,content_3562_4288:()=>GFt,content_3562_4290:()=>UFt,content_3562_4292:()=>qFt,content_3562_4294:()=>YFt,content_3562_4296:()=>QFt,content_3562_4298:()=>KFt,content_3562_430:()=>yS,content_3562_4300:()=>tqt,content_3562_4302:()=>nqt,content_3562_4304:()=>pqt,content_3562_4306:()=>sqt,content_3562_4308:()=>iqt,content_3562_4310:()=>lqt,content_3562_4312:()=>mqt,content_3562_4314:()=>hqt,content_3562_4316:()=>kqt,content_3562_4318:()=>wqt,content_3562_432:()=>DS,content_3562_4320:()=>Mqt,content_3562_4322:()=>_qt,content_3562_4324:()=>Tqt,content_3562_4326:()=>xqt,content_3562_4328:()=>Lqt,content_3562_4330:()=>bqt,content_3562_4332:()=>zqt,content_3562_4334:()=>Wqt,content_3562_4336:()=>Rqt,content_3562_4338:()=>Sqt,content_3562_434:()=>XS,content_3562_4340:()=>Eqt,content_3562_4342:()=>Gqt,content_3562_4344:()=>Uqt,content_3562_4346:()=>qqt,content_3562_4348:()=>Yqt,content_3562_4350:()=>Qqt,content_3562_4352:()=>Kqt,content_3562_4354:()=>tjt,content_3562_4356:()=>njt,content_3562_4358:()=>pjt,content_3562_436:()=>gS,content_3562_4360:()=>sjt,content_3562_4362:()=>ijt,content_3562_4364:()=>ljt,content_3562_4366:()=>mjt,content_3562_4368:()=>hjt,content_3562_4370:()=>kjt,content_3562_4372:()=>wjt,content_3562_4374:()=>Mjt,content_3562_4376:()=>_jt,content_3562_4378:()=>Tjt,content_3562_438:()=>CS,content_3562_4380:()=>xjt,content_3562_4382:()=>Ljt,content_3562_4384:()=>bjt,content_3562_4386:()=>zjt,content_3562_4388:()=>Wjt,content_3562_4390:()=>Rjt,content_3562_4392:()=>Sjt,content_3562_4394:()=>Ejt,content_3562_4396:()=>Gjt,content_3562_4398:()=>Ujt,content_3562_44:()=>aN,content_3562_440:()=>vS,content_3562_4400:()=>qjt,content_3562_4402:()=>Yjt,content_3562_4404:()=>Qjt,content_3562_4406:()=>Kjt,content_3562_4408:()=>tYt,content_3562_4410:()=>nYt,content_3562_4412:()=>pYt,content_3562_4414:()=>sYt,content_3562_4416:()=>iYt,content_3562_4418:()=>lYt,content_3562_442:()=>ZS,content_3562_4420:()=>mYt,content_3562_4422:()=>hYt,content_3562_4424:()=>kYt,content_3562_4426:()=>wYt,content_3562_4428:()=>MYt,content_3562_4430:()=>_Yt,content_3562_4432:()=>TYt,content_3562_4434:()=>xYt,content_3562_4436:()=>LYt,content_3562_4438:()=>bYt,content_3562_444:()=>NS,content_3562_4440:()=>zYt,content_3562_4442:()=>WYt,content_3562_4444:()=>RYt,content_3562_4446:()=>SYt,content_3562_4448:()=>EYt,content_3562_4450:()=>GYt,content_3562_4452:()=>UYt,content_3562_4454:()=>qYt,content_3562_4456:()=>YYt,content_3562_4458:()=>QYt,content_3562_446:()=>AS,content_3562_4460:()=>KYt,content_3562_4462:()=>tHt,content_3562_4464:()=>nHt,content_3562_4466:()=>pHt,content_3562_4468:()=>sHt,content_3562_4470:()=>iHt,content_3562_4472:()=>lHt,content_3562_4474:()=>mHt,content_3562_4476:()=>hHt,content_3562_4478:()=>kHt,content_3562_448:()=>IS,content_3562_4480:()=>wHt,content_3562_4482:()=>MHt,content_3562_4484:()=>_Ht,content_3562_4486:()=>THt,content_3562_4488:()=>xHt,content_3562_4490:()=>LHt,content_3562_4492:()=>bHt,content_3562_4494:()=>zHt,content_3562_4496:()=>WHt,content_3562_4498:()=>RHt,content_3562_450:()=>PS,content_3562_4500:()=>SHt,content_3562_4502:()=>EHt,content_3562_4504:()=>GHt,content_3562_4506:()=>UHt,content_3562_4508:()=>qHt,content_3562_4510:()=>YHt,content_3562_4512:()=>QHt,content_3562_4514:()=>KHt,content_3562_4516:()=>tQt,content_3562_4518:()=>nQt,content_3562_452:()=>OS,content_3562_4520:()=>pQt,content_3562_4522:()=>sQt,content_3562_4524:()=>iQt,content_3562_4526:()=>lQt,content_3562_4528:()=>mQt,content_3562_4530:()=>hQt,content_3562_4532:()=>kQt,content_3562_4534:()=>wQt,content_3562_4536:()=>MQt,content_3562_4538:()=>_Qt,content_3562_454:()=>BS,content_3562_4540:()=>TQt,content_3562_4542:()=>xQt,content_3562_4544:()=>LQt,content_3562_4546:()=>bQt,content_3562_4548:()=>zQt,content_3562_4550:()=>WQt,content_3562_4552:()=>RQt,content_3562_4554:()=>SQt,content_3562_4556:()=>EQt,content_3562_4558:()=>GQt,content_3562_456:()=>VS,content_3562_4560:()=>UQt,content_3562_4562:()=>qQt,content_3562_4564:()=>YQt,content_3562_4566:()=>QQt,content_3562_4568:()=>KQt,content_3562_4570:()=>t$t,content_3562_4572:()=>n$t,content_3562_4574:()=>p$t,content_3562_4576:()=>s$t,content_3562_4578:()=>i$t,content_3562_458:()=>FS,content_3562_4580:()=>l$t,content_3562_4582:()=>m$t,content_3562_4584:()=>h$t,content_3562_4586:()=>k$t,content_3562_4588:()=>w$t,content_3562_4590:()=>M$t,content_3562_4592:()=>_$t,content_3562_4594:()=>T$t,content_3562_4596:()=>x$t,content_3562_4598:()=>L$t,content_3562_46:()=>uN,content_3562_460:()=>jS,content_3562_4600:()=>b$t,content_3562_4602:()=>z$t,content_3562_4604:()=>W$t,content_3562_4606:()=>R$t,content_3562_4608:()=>S$t,content_3562_4610:()=>E$t,content_3562_4612:()=>G$t,content_3562_4614:()=>U$t,content_3562_4616:()=>q$t,content_3562_4618:()=>Y$t,content_3562_462:()=>HS,content_3562_4620:()=>Q$t,content_3562_4622:()=>K$t,content_3562_4624:()=>tKt,content_3562_4626:()=>nKt,content_3562_4628:()=>pKt,content_3562_4630:()=>sKt,content_3562_4632:()=>iKt,content_3562_4634:()=>lKt,content_3562_4636:()=>mKt,content_3562_4638:()=>hKt,content_3562_464:()=>$S,content_3562_4640:()=>kKt,content_3562_4642:()=>wKt,content_3562_4644:()=>MKt,content_3562_4646:()=>_Kt,content_3562_4648:()=>TKt,content_3562_4650:()=>xKt,content_3562_4652:()=>LKt,content_3562_4654:()=>bKt,content_3562_4656:()=>zKt,content_3562_4658:()=>WKt,content_3562_466:()=>JS,content_3562_4660:()=>RKt,content_3562_4662:()=>SKt,content_3562_4664:()=>EKt,content_3562_4666:()=>GKt,content_3562_4668:()=>UKt,content_3562_4670:()=>qKt,content_3562_4672:()=>YKt,content_3562_4674:()=>QKt,content_3562_4676:()=>KKt,content_3562_4678:()=>tJt,content_3562_468:()=>eO,content_3562_4680:()=>nJt,content_3562_4682:()=>pJt,content_3562_4684:()=>sJt,content_3562_4686:()=>iJt,content_3562_4688:()=>lJt,content_3562_4690:()=>mJt,content_3562_4692:()=>hJt,content_3562_4694:()=>kJt,content_3562_4696:()=>wJt,content_3562_4698:()=>MJt,content_3562_470:()=>oO,content_3562_4700:()=>_Jt,content_3562_4702:()=>TJt,content_3562_4704:()=>xJt,content_3562_4706:()=>LJt,content_3562_4708:()=>bJt,content_3562_4710:()=>zJt,content_3562_4712:()=>WJt,content_3562_4714:()=>RJt,content_3562_4716:()=>SJt,content_3562_4718:()=>EJt,content_3562_472:()=>rO,content_3562_4720:()=>GJt,content_3562_4722:()=>UJt,content_3562_4724:()=>qJt,content_3562_4726:()=>YJt,content_3562_4728:()=>QJt,content_3562_4730:()=>KJt,content_3562_4732:()=>t0t,content_3562_4734:()=>n0t,content_3562_4736:()=>p0t,content_3562_4738:()=>s0t,content_3562_474:()=>cO,content_3562_4740:()=>i0t,content_3562_4742:()=>l0t,content_3562_4744:()=>m0t,content_3562_4746:()=>h0t,content_3562_4748:()=>k0t,content_3562_4750:()=>w0t,content_3562_4752:()=>M0t,content_3562_4754:()=>_0t,content_3562_4756:()=>T0t,content_3562_4758:()=>x0t,content_3562_476:()=>aO,content_3562_4760:()=>L0t,content_3562_4762:()=>b0t,content_3562_4764:()=>z0t,content_3562_4766:()=>W0t,content_3562_4768:()=>R0t,content_3562_4770:()=>S0t,content_3562_4772:()=>E0t,content_3562_4774:()=>G0t,content_3562_4776:()=>U0t,content_3562_4778:()=>q0t,content_3562_478:()=>uO,content_3562_4780:()=>Y0t,content_3562_4782:()=>Q0t,content_3562_4784:()=>K0t,content_3562_4786:()=>t2t,content_3562_4788:()=>n2t,content_3562_4790:()=>p2t,content_3562_4792:()=>s2t,content_3562_4794:()=>i2t,content_3562_4796:()=>l2t,content_3562_4798:()=>m2t,content_3562_48:()=>dN,content_3562_480:()=>dO,content_3562_4800:()=>h2t,content_3562_4802:()=>k2t,content_3562_4804:()=>w2t,content_3562_4806:()=>M2t,content_3562_4808:()=>_2t,content_3562_4810:()=>T2t,content_3562_4812:()=>x2t,content_3562_4814:()=>L2t,content_3562_4816:()=>b2t,content_3562_4818:()=>z2t,content_3562_482:()=>fO,content_3562_4820:()=>W2t,content_3562_4822:()=>R2t,content_3562_4824:()=>S2t,content_3562_4826:()=>E2t,content_3562_4828:()=>G2t,content_3562_4830:()=>U2t,content_3562_4832:()=>q2t,content_3562_4834:()=>Y2t,content_3562_4836:()=>Q2t,content_3562_4838:()=>K2t,content_3562_484:()=>yO,content_3562_4840:()=>t6t,content_3562_4842:()=>n6t,content_3562_4844:()=>p6t,content_3562_4846:()=>s6t,content_3562_4848:()=>i6t,content_3562_4850:()=>l6t,content_3562_4852:()=>m6t,content_3562_4854:()=>h6t,content_3562_4856:()=>k6t,content_3562_4858:()=>w6t,content_3562_486:()=>DO,content_3562_4860:()=>M6t,content_3562_4862:()=>_6t,content_3562_4864:()=>T6t,content_3562_4866:()=>x6t,content_3562_4868:()=>L6t,content_3562_4870:()=>b6t,content_3562_4872:()=>z6t,content_3562_4874:()=>W6t,content_3562_4876:()=>R6t,content_3562_4878:()=>S6t,content_3562_488:()=>XO,content_3562_4880:()=>E6t,content_3562_4882:()=>G6t,content_3562_4884:()=>U6t,content_3562_4886:()=>q6t,content_3562_4888:()=>Y6t,content_3562_4890:()=>Q6t,content_3562_4892:()=>K6t,content_3562_4894:()=>t3t,content_3562_4896:()=>n3t,content_3562_4898:()=>p3t,content_3562_490:()=>gO,content_3562_4900:()=>s3t,content_3562_4902:()=>i3t,content_3562_4904:()=>l3t,content_3562_4906:()=>m3t,content_3562_4908:()=>h3t,content_3562_4910:()=>k3t,content_3562_4912:()=>w3t,content_3562_4914:()=>M3t,content_3562_4916:()=>_3t,content_3562_4918:()=>T3t,content_3562_492:()=>CO,content_3562_4920:()=>x3t,content_3562_4922:()=>L3t,content_3562_4924:()=>b3t,content_3562_4926:()=>z3t,content_3562_4928:()=>W3t,content_3562_4930:()=>R3t,content_3562_4932:()=>S3t,content_3562_4934:()=>E3t,content_3562_4936:()=>G3t,content_3562_4938:()=>U3t,content_3562_494:()=>vO,content_3562_4940:()=>q3t,content_3562_4942:()=>Y3t,content_3562_4944:()=>Q3t,content_3562_4946:()=>K3t,content_3562_4948:()=>t5t,content_3562_4950:()=>n5t,content_3562_4952:()=>p5t,content_3562_4954:()=>s5t,content_3562_4956:()=>i5t,content_3562_4958:()=>l5t,content_3562_496:()=>ZO,content_3562_4960:()=>m5t,content_3562_4962:()=>h5t,content_3562_4964:()=>k5t,content_3562_4966:()=>w5t,content_3562_4968:()=>M5t,content_3562_4970:()=>_5t,content_3562_4972:()=>T5t,content_3562_4974:()=>x5t,content_3562_4976:()=>L5t,content_3562_4978:()=>b5t,content_3562_498:()=>NO,content_3562_4980:()=>z5t,content_3562_4982:()=>W5t,content_3562_4984:()=>R5t,content_3562_4986:()=>S5t,content_3562_4988:()=>E5t,content_3562_4990:()=>G5t,content_3562_4992:()=>U5t,content_3562_4994:()=>q5t,content_3562_4996:()=>Y5t,content_3562_4998:()=>Q5t,content_3562_50:()=>fN,content_3562_500:()=>AO,content_3562_5000:()=>K5t,content_3562_5002:()=>t1t,content_3562_5004:()=>n1t,content_3562_5006:()=>p1t,content_3562_5008:()=>s1t,content_3562_5010:()=>i1t,content_3562_5012:()=>l1t,content_3562_5014:()=>m1t,content_3562_5016:()=>h1t,content_3562_5018:()=>k1t,content_3562_502:()=>IO,content_3562_5020:()=>w1t,content_3562_5022:()=>M1t,content_3562_5024:()=>_1t,content_3562_5026:()=>T1t,content_3562_5028:()=>x1t,content_3562_5030:()=>L1t,content_3562_5032:()=>b1t,content_3562_5034:()=>z1t,content_3562_5036:()=>W1t,content_3562_5038:()=>R1t,content_3562_504:()=>PO,content_3562_5040:()=>S1t,content_3562_5042:()=>E1t,content_3562_5044:()=>G1t,content_3562_5046:()=>U1t,content_3562_5048:()=>q1t,content_3562_5050:()=>Y1t,content_3562_5052:()=>Q1t,content_3562_5054:()=>K1t,content_3562_5056:()=>t4t,content_3562_5058:()=>n4t,content_3562_506:()=>OO,content_3562_5060:()=>p4t,content_3562_5062:()=>s4t,content_3562_5064:()=>i4t,content_3562_5066:()=>l4t,content_3562_5068:()=>m4t,content_3562_5070:()=>h4t,content_3562_5072:()=>k4t,content_3562_5074:()=>w4t,content_3562_5076:()=>M4t,content_3562_5078:()=>_4t,content_3562_508:()=>BO,content_3562_5080:()=>T4t,content_3562_5082:()=>x4t,content_3562_5084:()=>L4t,content_3562_5086:()=>b4t,content_3562_5088:()=>z4t,content_3562_5090:()=>W4t,content_3562_5092:()=>R4t,content_3562_5094:()=>S4t,content_3562_5096:()=>E4t,content_3562_5098:()=>G4t,content_3562_510:()=>VO,content_3562_5100:()=>U4t,content_3562_5102:()=>q4t,content_3562_5104:()=>Y4t,content_3562_5106:()=>Q4t,content_3562_5108:()=>K4t,content_3562_5110:()=>t8t,content_3562_5112:()=>n8t,content_3562_5114:()=>p8t,content_3562_5116:()=>s8t,content_3562_5118:()=>i8t,content_3562_512:()=>FO,content_3562_5120:()=>l8t,content_3562_5122:()=>m8t,content_3562_5124:()=>h8t,content_3562_5126:()=>k8t,content_3562_5128:()=>w8t,content_3562_5130:()=>M8t,content_3562_5132:()=>_8t,content_3562_5134:()=>T8t,content_3562_5136:()=>x8t,content_3562_5138:()=>L8t,content_3562_514:()=>jO,content_3562_5140:()=>b8t,content_3562_5142:()=>z8t,content_3562_5144:()=>W8t,content_3562_5146:()=>R8t,content_3562_5148:()=>S8t,content_3562_5150:()=>E8t,content_3562_5152:()=>G8t,content_3562_5154:()=>U8t,content_3562_5156:()=>q8t,content_3562_5158:()=>Y8t,content_3562_516:()=>HO,content_3562_5160:()=>Q8t,content_3562_5162:()=>K8t,content_3562_5164:()=>t7t,content_3562_5166:()=>n7t,content_3562_5168:()=>p7t,content_3562_5170:()=>s7t,content_3562_5172:()=>i7t,content_3562_5174:()=>l7t,content_3562_5176:()=>m7t,content_3562_5178:()=>h7t,content_3562_518:()=>$O,content_3562_5180:()=>k7t,content_3562_5182:()=>w7t,content_3562_5184:()=>M7t,content_3562_5186:()=>_7t,content_3562_5188:()=>T7t,content_3562_5190:()=>x7t,content_3562_5192:()=>L7t,content_3562_5194:()=>b7t,content_3562_5196:()=>z7t,content_3562_5198:()=>W7t,content_3562_52:()=>yN,content_3562_520:()=>JO,content_3562_5200:()=>R7t,content_3562_5202:()=>S7t,content_3562_5204:()=>E7t,content_3562_5206:()=>G7t,content_3562_5208:()=>U7t,content_3562_5210:()=>q7t,content_3562_5212:()=>Y7t,content_3562_5214:()=>Q7t,content_3562_5216:()=>K7t,content_3562_5218:()=>t9t,content_3562_522:()=>eE,content_3562_5220:()=>n9t,content_3562_5222:()=>p9t,content_3562_5224:()=>s9t,content_3562_5226:()=>i9t,content_3562_5228:()=>l9t,content_3562_5230:()=>m9t,content_3562_5232:()=>h9t,content_3562_5234:()=>k9t,content_3562_5236:()=>w9t,content_3562_5238:()=>M9t,content_3562_524:()=>oE,content_3562_5240:()=>_9t,content_3562_5242:()=>T9t,content_3562_5244:()=>x9t,content_3562_5246:()=>L9t,content_3562_5248:()=>b9t,content_3562_5250:()=>z9t,content_3562_5252:()=>W9t,content_3562_5254:()=>R9t,content_3562_5256:()=>S9t,content_3562_5258:()=>E9t,content_3562_526:()=>rE,content_3562_5260:()=>G9t,content_3562_5262:()=>U9t,content_3562_5264:()=>q9t,content_3562_5266:()=>Y9t,content_3562_5268:()=>Q9t,content_3562_5270:()=>K9t,content_3562_5272:()=>tte,content_3562_5274:()=>nte,content_3562_5276:()=>pte,content_3562_5278:()=>ste,content_3562_528:()=>cE,content_3562_5280:()=>ite,content_3562_5282:()=>lte,content_3562_5284:()=>mte,content_3562_5286:()=>hte,content_3562_5288:()=>kte,content_3562_5290:()=>wte,content_3562_5292:()=>Mte,content_3562_5294:()=>_te,content_3562_5296:()=>Tte,content_3562_5298:()=>xte,content_3562_530:()=>aE,content_3562_5300:()=>Lte,content_3562_5302:()=>bte,content_3562_5304:()=>zte,content_3562_5306:()=>Wte,content_3562_5308:()=>Rte,content_3562_5310:()=>Ste,content_3562_5312:()=>Ete,content_3562_5314:()=>Gte,content_3562_5316:()=>Ute,content_3562_5318:()=>qte,content_3562_532:()=>uE,content_3562_5320:()=>Yte,content_3562_5322:()=>Qte,content_3562_5324:()=>Kte,content_3562_5326:()=>tee,content_3562_5328:()=>nee,content_3562_5330:()=>pee,content_3562_5332:()=>see,content_3562_5334:()=>iee,content_3562_5336:()=>lee,content_3562_5338:()=>mee,content_3562_534:()=>dE,content_3562_5340:()=>hee,content_3562_5342:()=>kee,content_3562_5344:()=>wee,content_3562_5346:()=>Mee,content_3562_5348:()=>_ee,content_3562_5350:()=>Tee,content_3562_5352:()=>xee,content_3562_5354:()=>Lee,content_3562_5356:()=>bee,content_3562_5358:()=>zee,content_3562_536:()=>fE,content_3562_5360:()=>Wee,content_3562_5362:()=>Ree,content_3562_5364:()=>See,content_3562_5366:()=>Eee,content_3562_5368:()=>Gee,content_3562_5370:()=>Uee,content_3562_5372:()=>qee,content_3562_5374:()=>Yee,content_3562_5376:()=>Qee,content_3562_5378:()=>Kee,content_3562_538:()=>yE,content_3562_5380:()=>tne,content_3562_5382:()=>nne,content_3562_5384:()=>pne,content_3562_5386:()=>sne,content_3562_5388:()=>ine,content_3562_5390:()=>lne,content_3562_5392:()=>mne,content_3562_5394:()=>hne,content_3562_5396:()=>kne,content_3562_5398:()=>wne,content_3562_54:()=>DN,content_3562_540:()=>DE,content_3562_5400:()=>Mne,content_3562_5402:()=>_ne,content_3562_5404:()=>Tne,content_3562_5406:()=>xne,content_3562_5408:()=>Lne,content_3562_5410:()=>bne,content_3562_5412:()=>zne,content_3562_5414:()=>Wne,content_3562_5416:()=>Rne,content_3562_5418:()=>Sne,content_3562_542:()=>XE,content_3562_5420:()=>Ene,content_3562_5422:()=>Gne,content_3562_5424:()=>Une,content_3562_5426:()=>qne,content_3562_5428:()=>Yne,content_3562_5430:()=>Qne,content_3562_5432:()=>Kne,content_3562_5434:()=>toe,content_3562_5436:()=>noe,content_3562_5438:()=>poe,content_3562_544:()=>gE,content_3562_5440:()=>soe,content_3562_5442:()=>ioe,content_3562_5444:()=>loe,content_3562_5446:()=>moe,content_3562_5448:()=>hoe,content_3562_5450:()=>koe,content_3562_5452:()=>woe,content_3562_5454:()=>Moe,content_3562_5456:()=>_oe,content_3562_5458:()=>Toe,content_3562_546:()=>CE,content_3562_5460:()=>xoe,content_3562_5462:()=>Loe,content_3562_5464:()=>boe,content_3562_5466:()=>zoe,content_3562_5468:()=>Woe,content_3562_5470:()=>Roe,content_3562_5472:()=>Soe,content_3562_5474:()=>Eoe,content_3562_5476:()=>Goe,content_3562_5478:()=>Uoe,content_3562_548:()=>vE,content_3562_5480:()=>qoe,content_3562_5482:()=>Yoe,content_3562_5484:()=>Qoe,content_3562_5486:()=>Koe,content_3562_5488:()=>tpe,content_3562_5490:()=>npe,content_3562_5492:()=>ppe,content_3562_5494:()=>spe,content_3562_5496:()=>ipe,content_3562_5498:()=>lpe,content_3562_550:()=>ZE,content_3562_5500:()=>mpe,content_3562_5502:()=>hpe,content_3562_5504:()=>kpe,content_3562_5506:()=>wpe,content_3562_5508:()=>Mpe,content_3562_5510:()=>_pe,content_3562_5512:()=>Tpe,content_3562_5514:()=>xpe,content_3562_5516:()=>Lpe,content_3562_5518:()=>bpe,content_3562_552:()=>NE,content_3562_5520:()=>zpe,content_3562_5522:()=>Wpe,content_3562_5524:()=>Rpe,content_3562_5526:()=>Spe,content_3562_5528:()=>Epe,content_3562_5530:()=>Gpe,content_3562_5532:()=>Upe,content_3562_5534:()=>qpe,content_3562_5536:()=>Ype,content_3562_5538:()=>Qpe,content_3562_554:()=>AE,content_3562_5540:()=>Kpe,content_3562_5542:()=>tre,content_3562_5544:()=>nre,content_3562_5546:()=>pre,content_3562_5548:()=>sre,content_3562_5550:()=>ire,content_3562_5552:()=>lre,content_3562_5554:()=>mre,content_3562_5556:()=>hre,content_3562_5558:()=>kre,content_3562_556:()=>IE,content_3562_5560:()=>wre,content_3562_5562:()=>Mre,content_3562_5564:()=>_re,content_3562_5566:()=>Tre,content_3562_5568:()=>xre,content_3562_5570:()=>Lre,content_3562_5572:()=>bre,content_3562_5574:()=>zre,content_3562_5576:()=>Wre,content_3562_5578:()=>Rre,content_3562_558:()=>PE,content_3562_5580:()=>Sre,content_3562_5582:()=>Ere,content_3562_5584:()=>Gre,content_3562_5586:()=>Ure,content_3562_5588:()=>qre,content_3562_5590:()=>Yre,content_3562_5592:()=>Qre,content_3562_5594:()=>Kre,content_3562_5596:()=>tse,content_3562_5598:()=>nse,content_3562_56:()=>XN,content_3562_560:()=>OE,content_3562_5600:()=>pse,content_3562_5602:()=>sse,content_3562_5604:()=>ise,content_3562_5606:()=>lse,content_3562_5608:()=>mse,content_3562_5610:()=>hse,content_3562_5612:()=>kse,content_3562_5614:()=>wse,content_3562_5616:()=>Mse,content_3562_5618:()=>_se,content_3562_562:()=>BE,content_3562_5620:()=>Tse,content_3562_5622:()=>xse,content_3562_5624:()=>Lse,content_3562_5626:()=>bse,content_3562_5628:()=>zse,content_3562_5630:()=>Wse,content_3562_5632:()=>Rse,content_3562_5634:()=>Sse,content_3562_5636:()=>Ese,content_3562_5638:()=>Gse,content_3562_564:()=>VE,content_3562_5640:()=>Use,content_3562_5642:()=>qse,content_3562_5644:()=>Yse,content_3562_5646:()=>Qse,content_3562_5648:()=>Kse,content_3562_5650:()=>tce,content_3562_5652:()=>nce,content_3562_5654:()=>pce,content_3562_5656:()=>sce,content_3562_5658:()=>ice,content_3562_566:()=>FE,content_3562_5660:()=>lce,content_3562_5662:()=>mce,content_3562_5664:()=>hce,content_3562_5666:()=>kce,content_3562_5668:()=>wce,content_3562_5670:()=>Mce,content_3562_5672:()=>_ce,content_3562_5674:()=>Tce,content_3562_5676:()=>xce,content_3562_5678:()=>Lce,content_3562_568:()=>jE,content_3562_5680:()=>bce,content_3562_5682:()=>zce,content_3562_5684:()=>Wce,content_3562_5686:()=>Rce,content_3562_5688:()=>Sce,content_3562_5690:()=>Ece,content_3562_5692:()=>Gce,content_3562_5694:()=>Uce,content_3562_5696:()=>qce,content_3562_5698:()=>Yce,content_3562_570:()=>HE,content_3562_5700:()=>Qce,content_3562_5702:()=>Kce,content_3562_5704:()=>tie,content_3562_5706:()=>nie,content_3562_5708:()=>pie,content_3562_5710:()=>sie,content_3562_5712:()=>iie,content_3562_5714:()=>lie,content_3562_5716:()=>mie,content_3562_5718:()=>hie,content_3562_572:()=>$E,content_3562_5720:()=>kie,content_3562_5722:()=>wie,content_3562_5724:()=>Mie,content_3562_5726:()=>_ie,content_3562_5728:()=>Tie,content_3562_5730:()=>xie,content_3562_5732:()=>Lie,content_3562_5734:()=>bie,content_3562_5736:()=>zie,content_3562_5738:()=>Wie,content_3562_574:()=>JE,content_3562_5740:()=>Rie,content_3562_5742:()=>Sie,content_3562_5744:()=>Eie,content_3562_5746:()=>Gie,content_3562_5748:()=>Uie,content_3562_5750:()=>qie,content_3562_5752:()=>Yie,content_3562_5754:()=>Qie,content_3562_5756:()=>Kie,content_3562_5758:()=>tae,content_3562_576:()=>eB,content_3562_5760:()=>nae,content_3562_5762:()=>pae,content_3562_5764:()=>sae,content_3562_5766:()=>iae,content_3562_5768:()=>lae,content_3562_5770:()=>mae,content_3562_5772:()=>hae,content_3562_5774:()=>kae,content_3562_5776:()=>wae,content_3562_5778:()=>Mae,content_3562_578:()=>oB,content_3562_5780:()=>_ae,content_3562_5782:()=>Tae,content_3562_5784:()=>xae,content_3562_5786:()=>Lae,content_3562_5788:()=>bae,content_3562_5790:()=>zae,content_3562_5792:()=>Wae,content_3562_5794:()=>Rae,content_3562_5796:()=>Sae,content_3562_5798:()=>Eae,content_3562_58:()=>gN,content_3562_580:()=>rB,content_3562_5800:()=>Gae,content_3562_5802:()=>Uae,content_3562_5804:()=>qae,content_3562_5806:()=>Yae,content_3562_5808:()=>Qae,content_3562_5810:()=>Kae,content_3562_5812:()=>tle,content_3562_5814:()=>nle,content_3562_5816:()=>ple,content_3562_5818:()=>sle,content_3562_582:()=>cB,content_3562_5820:()=>ile,content_3562_5822:()=>lle,content_3562_5824:()=>mle,content_3562_5826:()=>hle,content_3562_5828:()=>kle,content_3562_5830:()=>wle,content_3562_5832:()=>Mle,content_3562_5834:()=>_le,content_3562_5836:()=>Tle,content_3562_5838:()=>xle,content_3562_584:()=>aB,content_3562_5840:()=>Lle,content_3562_5842:()=>ble,content_3562_5844:()=>zle,content_3562_5846:()=>Wle,content_3562_5848:()=>Rle,content_3562_5850:()=>Sle,content_3562_5852:()=>Ele,content_3562_5854:()=>Gle,content_3562_5856:()=>Ule,content_3562_5858:()=>qle,content_3562_586:()=>uB,content_3562_5860:()=>Yle,content_3562_5862:()=>Qle,content_3562_5864:()=>Kle,content_3562_5866:()=>tue,content_3562_5868:()=>nue,content_3562_5870:()=>pue,content_3562_5872:()=>sue,content_3562_5874:()=>iue,content_3562_5876:()=>lue,content_3562_5878:()=>mue,content_3562_588:()=>dB,content_3562_5880:()=>hue,content_3562_5882:()=>kue,content_3562_5884:()=>wue,content_3562_5886:()=>Mue,content_3562_5888:()=>_ue,content_3562_5890:()=>Tue,content_3562_5892:()=>xue,content_3562_5894:()=>Lue,content_3562_5896:()=>bue,content_3562_5898:()=>zue,content_3562_590:()=>fB,content_3562_5900:()=>Wue,content_3562_5902:()=>Rue,content_3562_5904:()=>Sue,content_3562_5906:()=>Eue,content_3562_5908:()=>Gue,content_3562_5910:()=>Uue,content_3562_5912:()=>que,content_3562_5914:()=>Yue,content_3562_5916:()=>Que,content_3562_5918:()=>Kue,content_3562_592:()=>yB,content_3562_5920:()=>tme,content_3562_5922:()=>nme,content_3562_5924:()=>pme,content_3562_5926:()=>sme,content_3562_5928:()=>ime,content_3562_5930:()=>lme,content_3562_5932:()=>mme,content_3562_5934:()=>hme,content_3562_5936:()=>kme,content_3562_5938:()=>wme,content_3562_594:()=>DB,content_3562_5940:()=>Mme,content_3562_5942:()=>_me,content_3562_5944:()=>Tme,content_3562_5946:()=>xme,content_3562_5948:()=>Lme,content_3562_5950:()=>bme,content_3562_5952:()=>zme,content_3562_5954:()=>Wme,content_3562_5956:()=>Rme,content_3562_5958:()=>Sme,content_3562_596:()=>XB,content_3562_5960:()=>Eme,content_3562_5962:()=>Gme,content_3562_5964:()=>Ume,content_3562_5966:()=>qme,content_3562_5968:()=>Yme,content_3562_5970:()=>Qme,content_3562_5972:()=>Kme,content_3562_5974:()=>tde,content_3562_5976:()=>nde,content_3562_5978:()=>pde,content_3562_598:()=>gB,content_3562_5980:()=>sde,content_3562_5982:()=>ide,content_3562_5984:()=>lde,content_3562_5986:()=>mde,content_3562_5988:()=>hde,content_3562_5990:()=>kde,content_3562_5992:()=>wde,content_3562_5994:()=>Mde,content_3562_5996:()=>_de,content_3562_5998:()=>Tde,content_3562_6:()=>Cb,content_3562_60:()=>CN,content_3562_600:()=>CB,content_3562_6000:()=>xde,content_3562_6002:()=>Lde,content_3562_6004:()=>bde,content_3562_6006:()=>zde,content_3562_6008:()=>Wde,content_3562_6010:()=>Rde,content_3562_6012:()=>Sde,content_3562_6014:()=>Ede,content_3562_6016:()=>Gde,content_3562_6018:()=>Ude,content_3562_602:()=>vB,content_3562_6020:()=>qde,content_3562_6022:()=>Yde,content_3562_6024:()=>Qde,content_3562_6026:()=>Kde,content_3562_6028:()=>the,content_3562_6030:()=>nhe,content_3562_6032:()=>phe,content_3562_6034:()=>she,content_3562_6036:()=>ihe,content_3562_6038:()=>lhe,content_3562_604:()=>ZB,content_3562_6040:()=>mhe,content_3562_6042:()=>hhe,content_3562_6044:()=>khe,content_3562_6046:()=>whe,content_3562_6048:()=>Mhe,content_3562_6050:()=>_he,content_3562_6052:()=>The,content_3562_6054:()=>xhe,content_3562_6056:()=>Lhe,content_3562_6058:()=>bhe,content_3562_606:()=>NB,content_3562_6060:()=>zhe,content_3562_6062:()=>Whe,content_3562_6064:()=>Rhe,content_3562_6066:()=>She,content_3562_6068:()=>Ehe,content_3562_6070:()=>Ghe,content_3562_6072:()=>Uhe,content_3562_6074:()=>qhe,content_3562_6076:()=>Yhe,content_3562_6078:()=>Qhe,content_3562_608:()=>AB,content_3562_6080:()=>Khe,content_3562_6082:()=>tfe,content_3562_6084:()=>nfe,content_3562_6086:()=>pfe,content_3562_6088:()=>sfe,content_3562_6090:()=>ife,content_3562_6092:()=>lfe,content_3562_6094:()=>mfe,content_3562_6096:()=>hfe,content_3562_6098:()=>kfe,content_3562_610:()=>IB,content_3562_6100:()=>wfe,content_3562_6102:()=>Mfe,content_3562_6104:()=>_fe,content_3562_6106:()=>Tfe,content_3562_6108:()=>xfe,content_3562_6110:()=>Lfe,content_3562_6112:()=>bfe,content_3562_6114:()=>zfe,content_3562_6116:()=>Wfe,content_3562_6118:()=>Rfe,content_3562_612:()=>PB,content_3562_6120:()=>Sfe,content_3562_6122:()=>Efe,content_3562_6124:()=>Gfe,content_3562_6126:()=>Ufe,content_3562_6128:()=>qfe,content_3562_6130:()=>Yfe,content_3562_6132:()=>Qfe,content_3562_6134:()=>Kfe,content_3562_6136:()=>tke,content_3562_6138:()=>nke,content_3562_614:()=>OB,content_3562_6140:()=>pke,content_3562_6142:()=>ske,content_3562_6144:()=>ike,content_3562_6146:()=>lke,content_3562_6148:()=>mke,content_3562_6150:()=>hke,content_3562_6152:()=>kke,content_3562_6154:()=>wke,content_3562_6156:()=>Mke,content_3562_6158:()=>_ke,content_3562_616:()=>BB,content_3562_6160:()=>Tke,content_3562_6162:()=>xke,content_3562_6164:()=>Lke,content_3562_6166:()=>bke,content_3562_6168:()=>zke,content_3562_6170:()=>Wke,content_3562_6172:()=>Rke,content_3562_6174:()=>Ske,content_3562_6176:()=>Eke,content_3562_6178:()=>Gke,content_3562_618:()=>VB,content_3562_6180:()=>Uke,content_3562_6182:()=>qke,content_3562_6184:()=>Yke,content_3562_6186:()=>Qke,content_3562_6188:()=>Kke,content_3562_6190:()=>tye,content_3562_6192:()=>nye,content_3562_6194:()=>pye,content_3562_6196:()=>sye,content_3562_6198:()=>iye,content_3562_62:()=>vN,content_3562_620:()=>FB,content_3562_6200:()=>lye,content_3562_6202:()=>mye,content_3562_6204:()=>hye,content_3562_6206:()=>kye,content_3562_6208:()=>wye,content_3562_6210:()=>Mye,content_3562_6212:()=>_ye,content_3562_6214:()=>Tye,content_3562_6216:()=>xye,content_3562_6218:()=>Lye,content_3562_622:()=>jB,content_3562_6220:()=>bye,content_3562_6222:()=>zye,content_3562_6224:()=>Wye,content_3562_6226:()=>Rye,content_3562_6228:()=>Sye,content_3562_6230:()=>Eye,content_3562_6232:()=>Gye,content_3562_6234:()=>Uye,content_3562_6236:()=>qye,content_3562_6238:()=>Yye,content_3562_624:()=>HB,content_3562_6240:()=>Qye,content_3562_6242:()=>Kye,content_3562_6244:()=>twe,content_3562_6246:()=>nwe,content_3562_6248:()=>pwe,content_3562_6250:()=>swe,content_3562_6252:()=>iwe,content_3562_6254:()=>lwe,content_3562_6256:()=>mwe,content_3562_6258:()=>hwe,content_3562_626:()=>$B,content_3562_6260:()=>kwe,content_3562_6262:()=>wwe,content_3562_6264:()=>Mwe,content_3562_6266:()=>_we,content_3562_6268:()=>Twe,content_3562_6270:()=>xwe,content_3562_6272:()=>Lwe,content_3562_6274:()=>bwe,content_3562_6276:()=>zwe,content_3562_6278:()=>Wwe,content_3562_628:()=>JB,content_3562_6280:()=>Rwe,content_3562_6282:()=>Swe,content_3562_6284:()=>Ewe,content_3562_6286:()=>Gwe,content_3562_6288:()=>Uwe,content_3562_6290:()=>qwe,content_3562_6292:()=>Ywe,content_3562_6294:()=>Qwe,content_3562_6296:()=>Kwe,content_3562_6298:()=>tDe,content_3562_630:()=>eG,content_3562_6300:()=>nDe,content_3562_6302:()=>pDe,content_3562_6304:()=>sDe,content_3562_6306:()=>iDe,content_3562_6308:()=>lDe,content_3562_6310:()=>mDe,content_3562_6312:()=>hDe,content_3562_6314:()=>kDe,content_3562_6316:()=>wDe,content_3562_6318:()=>MDe,content_3562_632:()=>oG,content_3562_6320:()=>_De,content_3562_6322:()=>TDe,content_3562_6324:()=>xDe,content_3562_6326:()=>LDe,content_3562_6328:()=>bDe,content_3562_6330:()=>zDe,content_3562_6332:()=>WDe,content_3562_6334:()=>RDe,content_3562_6336:()=>SDe,content_3562_6338:()=>EDe,content_3562_634:()=>rG,content_3562_6340:()=>GDe,content_3562_6342:()=>UDe,content_3562_6344:()=>qDe,content_3562_6346:()=>YDe,content_3562_6348:()=>QDe,content_3562_6350:()=>KDe,content_3562_6352:()=>tMe,content_3562_6354:()=>nMe,content_3562_6356:()=>pMe,content_3562_6358:()=>sMe,content_3562_636:()=>cG,content_3562_6360:()=>iMe,content_3562_6362:()=>lMe,content_3562_6364:()=>mMe,content_3562_6366:()=>hMe,content_3562_6368:()=>kMe,content_3562_6370:()=>wMe,content_3562_6372:()=>MMe,content_3562_6374:()=>_Me,content_3562_6376:()=>TMe,content_3562_6378:()=>xMe,content_3562_638:()=>aG,content_3562_6380:()=>LMe,content_3562_6382:()=>bMe,content_3562_6384:()=>zMe,content_3562_6386:()=>WMe,content_3562_6388:()=>RMe,content_3562_6390:()=>SMe,content_3562_6392:()=>EMe,content_3562_6394:()=>GMe,content_3562_6396:()=>UMe,content_3562_6398:()=>qMe,content_3562_64:()=>ZN,content_3562_640:()=>uG,content_3562_6400:()=>YMe,content_3562_6402:()=>QMe,content_3562_6404:()=>KMe,content_3562_6406:()=>tXe,content_3562_6408:()=>nXe,content_3562_6410:()=>pXe,content_3562_6412:()=>sXe,content_3562_6414:()=>iXe,content_3562_6416:()=>lXe,content_3562_6418:()=>mXe,content_3562_642:()=>dG,content_3562_6420:()=>hXe,content_3562_6422:()=>kXe,content_3562_6424:()=>wXe,content_3562_6426:()=>MXe,content_3562_6428:()=>_Xe,content_3562_6430:()=>TXe,content_3562_6432:()=>xXe,content_3562_6434:()=>LXe,content_3562_6436:()=>bXe,content_3562_6438:()=>zXe,content_3562_644:()=>fG,content_3562_6440:()=>WXe,content_3562_6442:()=>RXe,content_3562_6444:()=>SXe,content_3562_6446:()=>EXe,content_3562_6448:()=>GXe,content_3562_6450:()=>UXe,content_3562_6452:()=>qXe,content_3562_6454:()=>YXe,content_3562_6456:()=>QXe,content_3562_6458:()=>KXe,content_3562_646:()=>yG,content_3562_6460:()=>t_e,content_3562_6462:()=>n_e,content_3562_6464:()=>p_e,content_3562_6466:()=>s_e,content_3562_6468:()=>i_e,content_3562_6470:()=>l_e,content_3562_6472:()=>m_e,content_3562_6474:()=>h_e,content_3562_6476:()=>k_e,content_3562_6478:()=>w_e,content_3562_648:()=>DG,content_3562_6480:()=>M_e,content_3562_6482:()=>__e,content_3562_6484:()=>T_e,content_3562_6486:()=>x_e,content_3562_6488:()=>L_e,content_3562_6490:()=>b_e,content_3562_6492:()=>z_e,content_3562_6494:()=>W_e,content_3562_6496:()=>R_e,content_3562_6498:()=>S_e,content_3562_650:()=>XG,content_3562_6500:()=>E_e,content_3562_6502:()=>G_e,content_3562_6504:()=>U_e,content_3562_6506:()=>q_e,content_3562_6508:()=>Y_e,content_3562_6510:()=>Q_e,content_3562_6512:()=>K_e,content_3562_6514:()=>tge,content_3562_6516:()=>nge,content_3562_6518:()=>pge,content_3562_652:()=>gG,content_3562_6520:()=>sge,content_3562_6522:()=>ige,content_3562_6524:()=>lge,content_3562_6526:()=>mge,content_3562_6528:()=>hge,content_3562_6530:()=>kge,content_3562_6532:()=>wge,content_3562_6534:()=>Mge,content_3562_6536:()=>_ge,content_3562_6538:()=>Tge,content_3562_654:()=>CG,content_3562_6540:()=>xge,content_3562_6542:()=>Lge,content_3562_6544:()=>bge,content_3562_6546:()=>zge,content_3562_6548:()=>Wge,content_3562_6550:()=>Rge,content_3562_6552:()=>Sge,content_3562_6554:()=>Ege,content_3562_6556:()=>Gge,content_3562_6558:()=>Uge,content_3562_656:()=>vG,content_3562_6560:()=>qge,content_3562_6562:()=>Yge,content_3562_6564:()=>Qge,content_3562_6566:()=>Kge,content_3562_6568:()=>tTe,content_3562_6570:()=>nTe,content_3562_6572:()=>pTe,content_3562_6574:()=>sTe,content_3562_6576:()=>iTe,content_3562_6578:()=>lTe,content_3562_658:()=>ZG,content_3562_6580:()=>mTe,content_3562_6582:()=>hTe,content_3562_6584:()=>kTe,content_3562_6586:()=>wTe,content_3562_6588:()=>MTe,content_3562_6590:()=>_Te,content_3562_6592:()=>TTe,content_3562_6594:()=>xTe,content_3562_6596:()=>LTe,content_3562_6598:()=>bTe,content_3562_66:()=>NN,content_3562_660:()=>NG,content_3562_6600:()=>zTe,content_3562_6602:()=>WTe,content_3562_6604:()=>RTe,content_3562_6606:()=>STe,content_3562_6608:()=>ETe,content_3562_6610:()=>GTe,content_3562_6612:()=>UTe,content_3562_6614:()=>qTe,content_3562_6616:()=>YTe,content_3562_6618:()=>QTe,content_3562_662:()=>AG,content_3562_6620:()=>KTe,content_3562_6622:()=>tCe,content_3562_6624:()=>nCe,content_3562_6626:()=>pCe,content_3562_6628:()=>sCe,content_3562_6630:()=>iCe,content_3562_6632:()=>lCe,content_3562_6634:()=>mCe,content_3562_6636:()=>hCe,content_3562_6638:()=>kCe,content_3562_664:()=>IG,content_3562_6640:()=>wCe,content_3562_6642:()=>MCe,content_3562_6644:()=>_Ce,content_3562_6646:()=>TCe,content_3562_6648:()=>xCe,content_3562_6650:()=>LCe,content_3562_6652:()=>bCe,content_3562_6654:()=>zCe,content_3562_6656:()=>WCe,content_3562_6658:()=>RCe,content_3562_666:()=>PG,content_3562_6660:()=>SCe,content_3562_6662:()=>ECe,content_3562_6664:()=>GCe,content_3562_6666:()=>UCe,content_3562_6668:()=>qCe,content_3562_6670:()=>YCe,content_3562_6672:()=>QCe,content_3562_6674:()=>KCe,content_3562_6676:()=>txe,content_3562_6678:()=>nxe,content_3562_668:()=>OG,content_3562_6680:()=>pxe,content_3562_6682:()=>sxe,content_3562_6684:()=>ixe,content_3562_6686:()=>lxe,content_3562_6688:()=>mxe,content_3562_6690:()=>hxe,content_3562_6692:()=>kxe,content_3562_6694:()=>wxe,content_3562_6696:()=>Mxe,content_3562_6698:()=>_xe,content_3562_670:()=>BG,content_3562_6700:()=>Txe,content_3562_6702:()=>xxe,content_3562_6704:()=>Lxe,content_3562_6706:()=>bxe,content_3562_6708:()=>zxe,content_3562_6710:()=>Wxe,content_3562_6712:()=>Rxe,content_3562_6714:()=>Sxe,content_3562_6716:()=>Exe,content_3562_6718:()=>Gxe,content_3562_672:()=>VG,content_3562_6720:()=>Uxe,content_3562_6722:()=>qxe,content_3562_6724:()=>Yxe,content_3562_6726:()=>Qxe,content_3562_6728:()=>Kxe,content_3562_6730:()=>tve,content_3562_6732:()=>nve,content_3562_6734:()=>pve,content_3562_6736:()=>sve,content_3562_6738:()=>ive,content_3562_674:()=>FG,content_3562_6740:()=>lve,content_3562_6742:()=>mve,content_3562_6744:()=>hve,content_3562_6746:()=>kve,content_3562_6748:()=>wve,content_3562_6750:()=>Mve,content_3562_6752:()=>_ve,content_3562_6754:()=>Tve,content_3562_6756:()=>xve,content_3562_6758:()=>Lve,content_3562_676:()=>jG,content_3562_6760:()=>bve,content_3562_6762:()=>zve,content_3562_6764:()=>Wve,content_3562_6766:()=>Rve,content_3562_6768:()=>Sve,content_3562_6770:()=>Eve,content_3562_6772:()=>Gve,content_3562_6774:()=>Uve,content_3562_6776:()=>qve,content_3562_6778:()=>Yve,content_3562_678:()=>HG,content_3562_6780:()=>Qve,content_3562_6782:()=>Kve,content_3562_6784:()=>tLe,content_3562_6786:()=>nLe,content_3562_6788:()=>pLe,content_3562_6790:()=>sLe,content_3562_6792:()=>iLe,content_3562_6794:()=>lLe,content_3562_6796:()=>mLe,content_3562_6798:()=>hLe,content_3562_68:()=>AN,content_3562_680:()=>$G,content_3562_6800:()=>kLe,content_3562_6802:()=>wLe,content_3562_6804:()=>MLe,content_3562_6806:()=>_Le,content_3562_6808:()=>TLe,content_3562_6810:()=>xLe,content_3562_6812:()=>LLe,content_3562_6814:()=>bLe,content_3562_6816:()=>zLe,content_3562_6818:()=>WLe,content_3562_682:()=>JG,content_3562_6820:()=>RLe,content_3562_6822:()=>SLe,content_3562_6824:()=>ELe,content_3562_6826:()=>GLe,content_3562_6828:()=>ULe,content_3562_6830:()=>qLe,content_3562_6832:()=>YLe,content_3562_6834:()=>QLe,content_3562_6836:()=>KLe,content_3562_6838:()=>tZe,content_3562_684:()=>eV,content_3562_6840:()=>nZe,content_3562_6842:()=>pZe,content_3562_6844:()=>sZe,content_3562_6846:()=>iZe,content_3562_6848:()=>lZe,content_3562_6850:()=>mZe,content_3562_6852:()=>hZe,content_3562_6854:()=>kZe,content_3562_6856:()=>wZe,content_3562_6858:()=>MZe,content_3562_686:()=>oV,content_3562_6860:()=>_Ze,content_3562_6862:()=>TZe,content_3562_6864:()=>xZe,content_3562_6866:()=>LZe,content_3562_6868:()=>bZe,content_3562_6870:()=>zZe,content_3562_6872:()=>WZe,content_3562_6874:()=>RZe,content_3562_6876:()=>SZe,content_3562_6878:()=>EZe,content_3562_688:()=>rV,content_3562_6880:()=>GZe,content_3562_6882:()=>UZe,content_3562_6884:()=>qZe,content_3562_6886:()=>YZe,content_3562_6888:()=>QZe,content_3562_6890:()=>KZe,content_3562_6892:()=>tbe,content_3562_6894:()=>nbe,content_3562_6896:()=>pbe,content_3562_6898:()=>sbe,content_3562_690:()=>cV,content_3562_6900:()=>ibe,content_3562_6902:()=>lbe,content_3562_6904:()=>mbe,content_3562_6906:()=>hbe,content_3562_6908:()=>kbe,content_3562_6910:()=>wbe,content_3562_6912:()=>Mbe,content_3562_6914:()=>_be,content_3562_6916:()=>Tbe,content_3562_6918:()=>xbe,content_3562_692:()=>aV,content_3562_6920:()=>Lbe,content_3562_6922:()=>bbe,content_3562_6924:()=>zbe,content_3562_6926:()=>Wbe,content_3562_6928:()=>Rbe,content_3562_6930:()=>Sbe,content_3562_6932:()=>Ebe,content_3562_6934:()=>Gbe,content_3562_6936:()=>Ube,content_3562_6938:()=>qbe,content_3562_694:()=>uV,content_3562_6940:()=>Ybe,content_3562_6942:()=>Qbe,content_3562_6944:()=>Kbe,content_3562_6946:()=>tNe,content_3562_6948:()=>nNe,content_3562_6950:()=>pNe,content_3562_6952:()=>sNe,content_3562_6954:()=>iNe,content_3562_6956:()=>lNe,content_3562_6958:()=>mNe,content_3562_696:()=>dV,content_3562_6960:()=>hNe,content_3562_6962:()=>kNe,content_3562_6964:()=>wNe,content_3562_6966:()=>MNe,content_3562_6968:()=>_Ne,content_3562_6970:()=>TNe,content_3562_6972:()=>xNe,content_3562_6974:()=>LNe,content_3562_6976:()=>bNe,content_3562_6978:()=>zNe,content_3562_698:()=>fV,content_3562_6980:()=>WNe,content_3562_6982:()=>RNe,content_3562_6984:()=>SNe,content_3562_6986:()=>ENe,content_3562_6988:()=>GNe,content_3562_6990:()=>UNe,content_3562_6992:()=>qNe,content_3562_6994:()=>YNe,content_3562_6996:()=>QNe,content_3562_6998:()=>KNe,content_3562_70:()=>IN,content_3562_700:()=>yV,content_3562_7000:()=>tze,content_3562_7002:()=>nze,content_3562_7004:()=>pze,content_3562_7006:()=>sze,content_3562_7008:()=>ize,content_3562_7010:()=>lze,content_3562_7012:()=>mze,content_3562_7014:()=>hze,content_3562_7016:()=>kze,content_3562_7018:()=>wze,content_3562_702:()=>DV,content_3562_7020:()=>Mze,content_3562_7022:()=>_ze,content_3562_7024:()=>Tze,content_3562_7026:()=>xze,content_3562_7028:()=>Lze,content_3562_7030:()=>bze,content_3562_7032:()=>zze,content_3562_7034:()=>Wze,content_3562_7036:()=>Rze,content_3562_7038:()=>Sze,content_3562_704:()=>XV,content_3562_7040:()=>Eze,content_3562_7042:()=>Gze,content_3562_7044:()=>Uze,content_3562_7046:()=>qze,content_3562_7048:()=>Yze,content_3562_7050:()=>Qze,content_3562_7052:()=>Kze,content_3562_7054:()=>tAe,content_3562_7056:()=>nAe,content_3562_7058:()=>pAe,content_3562_706:()=>gV,content_3562_7060:()=>sAe,content_3562_7062:()=>iAe,content_3562_7064:()=>lAe,content_3562_7066:()=>mAe,content_3562_7068:()=>hAe,content_3562_7070:()=>kAe,content_3562_7072:()=>wAe,content_3562_7074:()=>MAe,content_3562_7076:()=>_Ae,content_3562_7078:()=>TAe,content_3562_708:()=>CV,content_3562_7080:()=>xAe,content_3562_7082:()=>LAe,content_3562_7084:()=>bAe,content_3562_7086:()=>zAe,content_3562_7088:()=>WAe,content_3562_7090:()=>RAe,content_3562_7092:()=>SAe,content_3562_7094:()=>EAe,content_3562_7096:()=>GAe,content_3562_7098:()=>UAe,content_3562_710:()=>vV,content_3562_7100:()=>qAe,content_3562_7102:()=>YAe,content_3562_7104:()=>QAe,content_3562_7106:()=>KAe,content_3562_7108:()=>tWe,content_3562_7110:()=>nWe,content_3562_7112:()=>pWe,content_3562_7114:()=>sWe,content_3562_7116:()=>iWe,content_3562_7118:()=>lWe,content_3562_712:()=>ZV,content_3562_7120:()=>mWe,content_3562_7122:()=>hWe,content_3562_7124:()=>kWe,content_3562_7126:()=>wWe,content_3562_7128:()=>MWe,content_3562_7130:()=>_We,content_3562_7132:()=>TWe,content_3562_7134:()=>xWe,content_3562_7136:()=>LWe,content_3562_7138:()=>bWe,content_3562_714:()=>NV,content_3562_7140:()=>zWe,content_3562_7142:()=>WWe,content_3562_7144:()=>RWe,content_3562_7146:()=>SWe,content_3562_7148:()=>EWe,content_3562_7150:()=>GWe,content_3562_7152:()=>UWe,content_3562_7154:()=>qWe,content_3562_7156:()=>YWe,content_3562_7158:()=>QWe,content_3562_716:()=>AV,content_3562_7160:()=>KWe,content_3562_7162:()=>tIe,content_3562_7164:()=>nIe,content_3562_7166:()=>pIe,content_3562_7168:()=>sIe,content_3562_7170:()=>iIe,content_3562_7172:()=>lIe,content_3562_7174:()=>mIe,content_3562_7176:()=>hIe,content_3562_7178:()=>kIe,content_3562_718:()=>IV,content_3562_7180:()=>wIe,content_3562_7182:()=>MIe,content_3562_7184:()=>_Ie,content_3562_7186:()=>TIe,content_3562_7188:()=>xIe,content_3562_7190:()=>LIe,content_3562_7192:()=>bIe,content_3562_7194:()=>zIe,content_3562_7196:()=>WIe,content_3562_7198:()=>RIe,content_3562_72:()=>PN,content_3562_720:()=>PV,content_3562_7200:()=>SIe,content_3562_7202:()=>EIe,content_3562_7204:()=>GIe,content_3562_7206:()=>UIe,content_3562_7208:()=>qIe,content_3562_7210:()=>YIe,content_3562_7212:()=>QIe,content_3562_7214:()=>KIe,content_3562_7216:()=>tRe,content_3562_7218:()=>nRe,content_3562_722:()=>OV,content_3562_7220:()=>pRe,content_3562_7222:()=>sRe,content_3562_7224:()=>iRe,content_3562_7226:()=>lRe,content_3562_7228:()=>mRe,content_3562_7230:()=>hRe,content_3562_7232:()=>kRe,content_3562_7234:()=>wRe,content_3562_7236:()=>MRe,content_3562_7238:()=>_Re,content_3562_724:()=>BV,content_3562_7240:()=>TRe,content_3562_7242:()=>xRe,content_3562_7244:()=>LRe,content_3562_7246:()=>bRe,content_3562_7248:()=>zRe,content_3562_7250:()=>WRe,content_3562_7252:()=>RRe,content_3562_7254:()=>SRe,content_3562_7256:()=>ERe,content_3562_7258:()=>GRe,content_3562_726:()=>VV,content_3562_7260:()=>URe,content_3562_7262:()=>qRe,content_3562_7264:()=>YRe,content_3562_7266:()=>QRe,content_3562_7268:()=>KRe,content_3562_7270:()=>tPe,content_3562_7272:()=>nPe,content_3562_7274:()=>pPe,content_3562_7276:()=>sPe,content_3562_7278:()=>iPe,content_3562_728:()=>FV,content_3562_7280:()=>lPe,content_3562_7282:()=>mPe,content_3562_7284:()=>hPe,content_3562_7286:()=>kPe,content_3562_7288:()=>wPe,content_3562_7290:()=>MPe,content_3562_7292:()=>_Pe,content_3562_7294:()=>TPe,content_3562_7296:()=>xPe,content_3562_7298:()=>LPe,content_3562_730:()=>jV,content_3562_7300:()=>bPe,content_3562_7302:()=>zPe,content_3562_7304:()=>WPe,content_3562_7306:()=>RPe,content_3562_7308:()=>SPe,content_3562_7310:()=>EPe,content_3562_7312:()=>GPe,content_3562_7314:()=>UPe,content_3562_7316:()=>qPe,content_3562_7318:()=>YPe,content_3562_732:()=>HV,content_3562_7320:()=>QPe,content_3562_7322:()=>KPe,content_3562_7324:()=>tSe,content_3562_7326:()=>nSe,content_3562_7328:()=>pSe,content_3562_7330:()=>sSe,content_3562_7332:()=>iSe,content_3562_7334:()=>lSe,content_3562_7336:()=>mSe,content_3562_7338:()=>hSe,content_3562_734:()=>$V,content_3562_7340:()=>kSe,content_3562_7342:()=>wSe,content_3562_7344:()=>MSe,content_3562_7346:()=>_Se,content_3562_7348:()=>TSe,content_3562_7350:()=>xSe,content_3562_7352:()=>LSe,content_3562_7354:()=>bSe,content_3562_7356:()=>zSe,content_3562_7358:()=>WSe,content_3562_736:()=>JV,content_3562_7360:()=>RSe,content_3562_7362:()=>SSe,content_3562_7364:()=>ESe,content_3562_7366:()=>GSe,content_3562_7368:()=>USe,content_3562_7370:()=>qSe,content_3562_7372:()=>YSe,content_3562_7374:()=>QSe,content_3562_7376:()=>KSe,content_3562_7378:()=>tOe,content_3562_738:()=>eU,content_3562_7380:()=>nOe,content_3562_7382:()=>pOe,content_3562_7384:()=>sOe,content_3562_7386:()=>iOe,content_3562_7388:()=>lOe,content_3562_7390:()=>mOe,content_3562_7392:()=>hOe,content_3562_7394:()=>kOe,content_3562_7396:()=>wOe,content_3562_7398:()=>MOe,content_3562_74:()=>ON,content_3562_740:()=>oU,content_3562_7400:()=>_Oe,content_3562_7402:()=>TOe,content_3562_7404:()=>xOe,content_3562_7406:()=>LOe,content_3562_7408:()=>bOe,content_3562_7410:()=>zOe,content_3562_7412:()=>WOe,content_3562_7414:()=>ROe,content_3562_7416:()=>SOe,content_3562_7418:()=>EOe,content_3562_742:()=>rU,content_3562_7420:()=>GOe,content_3562_7422:()=>UOe,content_3562_7424:()=>qOe,content_3562_7426:()=>YOe,content_3562_7428:()=>QOe,content_3562_7430:()=>KOe,content_3562_7432:()=>tEe,content_3562_7434:()=>nEe,content_3562_7436:()=>pEe,content_3562_7438:()=>sEe,content_3562_744:()=>cU,content_3562_7440:()=>iEe,content_3562_7442:()=>lEe,content_3562_7444:()=>mEe,content_3562_7446:()=>hEe,content_3562_7448:()=>kEe,content_3562_7450:()=>wEe,content_3562_7452:()=>MEe,content_3562_7454:()=>_Ee,content_3562_7456:()=>TEe,content_3562_7458:()=>xEe,content_3562_746:()=>aU,content_3562_7460:()=>LEe,content_3562_7462:()=>bEe,content_3562_7464:()=>zEe,content_3562_7466:()=>WEe,content_3562_7468:()=>REe,content_3562_7470:()=>SEe,content_3562_7472:()=>EEe,content_3562_7474:()=>GEe,content_3562_7476:()=>UEe,content_3562_7478:()=>qEe,content_3562_748:()=>uU,content_3562_7480:()=>YEe,content_3562_7482:()=>QEe,content_3562_7484:()=>KEe,content_3562_7486:()=>tBe,content_3562_7488:()=>nBe,content_3562_7490:()=>pBe,content_3562_7492:()=>sBe,content_3562_7494:()=>iBe,content_3562_7496:()=>lBe,content_3562_7498:()=>mBe,content_3562_750:()=>dU,content_3562_7500:()=>hBe,content_3562_7502:()=>kBe,content_3562_7504:()=>wBe,content_3562_7506:()=>MBe,content_3562_7508:()=>_Be,content_3562_7510:()=>TBe,content_3562_7512:()=>xBe,content_3562_7514:()=>LBe,content_3562_7516:()=>bBe,content_3562_7518:()=>zBe,content_3562_752:()=>fU,content_3562_7520:()=>WBe,content_3562_7522:()=>RBe,content_3562_7524:()=>SBe,content_3562_7526:()=>EBe,content_3562_7528:()=>GBe,content_3562_7530:()=>UBe,content_3562_7532:()=>qBe,content_3562_7534:()=>YBe,content_3562_7536:()=>QBe,content_3562_7538:()=>KBe,content_3562_754:()=>yU,content_3562_7540:()=>tGe,content_3562_7542:()=>nGe,content_3562_7544:()=>pGe,content_3562_7546:()=>sGe,content_3562_7548:()=>iGe,content_3562_7550:()=>lGe,content_3562_7552:()=>mGe,content_3562_7554:()=>hGe,content_3562_7556:()=>kGe,content_3562_7558:()=>wGe,content_3562_756:()=>DU,content_3562_7560:()=>MGe,content_3562_7562:()=>_Ge,content_3562_7564:()=>TGe,content_3562_7566:()=>xGe,content_3562_7568:()=>LGe,content_3562_7570:()=>bGe,content_3562_7572:()=>zGe,content_3562_7574:()=>WGe,content_3562_7576:()=>RGe,content_3562_7578:()=>SGe,content_3562_758:()=>XU,content_3562_7580:()=>EGe,content_3562_7582:()=>GGe,content_3562_7584:()=>UGe,content_3562_7586:()=>qGe,content_3562_7588:()=>YGe,content_3562_7590:()=>QGe,content_3562_7592:()=>KGe,content_3562_7594:()=>tVe,content_3562_7596:()=>nVe,content_3562_7598:()=>pVe,content_3562_76:()=>BN,content_3562_760:()=>gU,content_3562_7600:()=>sVe,content_3562_7602:()=>iVe,content_3562_7604:()=>lVe,content_3562_7606:()=>mVe,content_3562_7608:()=>hVe,content_3562_7610:()=>kVe,content_3562_7612:()=>wVe,content_3562_7614:()=>MVe,content_3562_7616:()=>_Ve,content_3562_7618:()=>TVe,content_3562_762:()=>CU,content_3562_7620:()=>xVe,content_3562_7622:()=>LVe,content_3562_7624:()=>bVe,content_3562_7626:()=>zVe,content_3562_7628:()=>WVe,content_3562_7630:()=>RVe,content_3562_7632:()=>SVe,content_3562_7634:()=>EVe,content_3562_7636:()=>GVe,content_3562_7638:()=>UVe,content_3562_764:()=>vU,content_3562_7640:()=>qVe,content_3562_7642:()=>YVe,content_3562_7644:()=>QVe,content_3562_7646:()=>KVe,content_3562_7648:()=>tUe,content_3562_7650:()=>nUe,content_3562_7652:()=>pUe,content_3562_7654:()=>sUe,content_3562_7656:()=>iUe,content_3562_7658:()=>lUe,content_3562_766:()=>ZU,content_3562_7660:()=>mUe,content_3562_7662:()=>hUe,content_3562_7664:()=>kUe,content_3562_7666:()=>wUe,content_3562_7668:()=>MUe,content_3562_7670:()=>_Ue,content_3562_7672:()=>TUe,content_3562_7674:()=>xUe,content_3562_7676:()=>LUe,content_3562_7678:()=>bUe,content_3562_768:()=>NU,content_3562_7680:()=>zUe,content_3562_7682:()=>WUe,content_3562_7684:()=>RUe,content_3562_7686:()=>SUe,content_3562_7688:()=>EUe,content_3562_7690:()=>GUe,content_3562_7692:()=>UUe,content_3562_7694:()=>qUe,content_3562_7696:()=>YUe,content_3562_7698:()=>QUe,content_3562_770:()=>AU,content_3562_7700:()=>KUe,content_3562_7702:()=>tFe,content_3562_7704:()=>nFe,content_3562_7706:()=>pFe,content_3562_7708:()=>sFe,content_3562_7710:()=>iFe,content_3562_7712:()=>lFe,content_3562_7714:()=>mFe,content_3562_7716:()=>hFe,content_3562_7718:()=>kFe,content_3562_772:()=>IU,content_3562_7720:()=>wFe,content_3562_7722:()=>MFe,content_3562_7724:()=>_Fe,content_3562_7726:()=>TFe,content_3562_7728:()=>xFe,content_3562_7730:()=>LFe,content_3562_7732:()=>bFe,content_3562_7734:()=>zFe,content_3562_7736:()=>WFe,content_3562_7738:()=>RFe,content_3562_774:()=>PU,content_3562_7740:()=>SFe,content_3562_7742:()=>EFe,content_3562_7744:()=>GFe,content_3562_7746:()=>UFe,content_3562_7748:()=>qFe,content_3562_7750:()=>YFe,content_3562_7752:()=>QFe,content_3562_7754:()=>KFe,content_3562_7756:()=>tqe,content_3562_7758:()=>nqe,content_3562_776:()=>OU,content_3562_7760:()=>pqe,content_3562_7762:()=>sqe,content_3562_7764:()=>iqe,content_3562_7766:()=>lqe,content_3562_7768:()=>mqe,content_3562_7770:()=>hqe,content_3562_7772:()=>kqe,content_3562_7774:()=>wqe,content_3562_7776:()=>Mqe,content_3562_7778:()=>_qe,content_3562_778:()=>BU,content_3562_7780:()=>Tqe,content_3562_7782:()=>xqe,content_3562_7784:()=>Lqe,content_3562_7786:()=>bqe,content_3562_7788:()=>zqe,content_3562_7790:()=>Wqe,content_3562_7792:()=>Rqe,content_3562_7794:()=>Sqe,content_3562_7796:()=>Eqe,content_3562_7798:()=>Gqe,content_3562_78:()=>VN,content_3562_780:()=>VU,content_3562_7800:()=>Uqe,content_3562_7802:()=>qqe,content_3562_7804:()=>Yqe,content_3562_7806:()=>Qqe,content_3562_7808:()=>Kqe,content_3562_7810:()=>tje,content_3562_7812:()=>nje,content_3562_7814:()=>pje,content_3562_7816:()=>sje,content_3562_7818:()=>ije,content_3562_782:()=>FU,content_3562_7820:()=>lje,content_3562_7822:()=>mje,content_3562_7824:()=>hje,content_3562_7826:()=>kje,content_3562_7828:()=>wje,content_3562_7830:()=>Mje,content_3562_7832:()=>_je,content_3562_7834:()=>Tje,content_3562_7836:()=>xje,content_3562_7838:()=>Lje,content_3562_784:()=>jU,content_3562_7840:()=>bje,content_3562_7842:()=>zje,content_3562_7844:()=>Wje,content_3562_7846:()=>Rje,content_3562_7848:()=>Sje,content_3562_7850:()=>Eje,content_3562_7852:()=>Gje,content_3562_7854:()=>Uje,content_3562_7856:()=>qje,content_3562_7858:()=>Yje,content_3562_786:()=>HU,content_3562_7860:()=>Qje,content_3562_7862:()=>Kje,content_3562_7864:()=>tYe,content_3562_7866:()=>nYe,content_3562_7868:()=>pYe,content_3562_7870:()=>sYe,content_3562_7872:()=>iYe,content_3562_7874:()=>lYe,content_3562_7876:()=>mYe,content_3562_7878:()=>hYe,content_3562_788:()=>$U,content_3562_7880:()=>kYe,content_3562_7882:()=>wYe,content_3562_7884:()=>MYe,content_3562_7886:()=>_Ye,content_3562_7888:()=>TYe,content_3562_7890:()=>xYe,content_3562_7892:()=>LYe,content_3562_7894:()=>bYe,content_3562_7896:()=>zYe,content_3562_7898:()=>WYe,content_3562_790:()=>JU,content_3562_7900:()=>RYe,content_3562_7902:()=>SYe,content_3562_7904:()=>EYe,content_3562_7906:()=>GYe,content_3562_7908:()=>UYe,content_3562_7910:()=>qYe,content_3562_7912:()=>YYe,content_3562_7914:()=>QYe,content_3562_7916:()=>KYe,content_3562_7918:()=>tHe,content_3562_792:()=>eF,content_3562_7920:()=>nHe,content_3562_7922:()=>pHe,content_3562_7924:()=>sHe,content_3562_7926:()=>iHe,content_3562_7928:()=>lHe,content_3562_7930:()=>mHe,content_3562_7932:()=>hHe,content_3562_7934:()=>kHe,content_3562_7936:()=>wHe,content_3562_7938:()=>MHe,content_3562_794:()=>oF,content_3562_7940:()=>_He,content_3562_7942:()=>THe,content_3562_7944:()=>xHe,content_3562_7946:()=>LHe,content_3562_7948:()=>bHe,content_3562_7950:()=>zHe,content_3562_7952:()=>WHe,content_3562_7954:()=>RHe,content_3562_7956:()=>SHe,content_3562_7958:()=>EHe,content_3562_796:()=>rF,content_3562_7960:()=>GHe,content_3562_7962:()=>UHe,content_3562_7964:()=>qHe,content_3562_7966:()=>YHe,content_3562_7968:()=>QHe,content_3562_7970:()=>KHe,content_3562_7972:()=>tQe,content_3562_7974:()=>nQe,content_3562_7976:()=>pQe,content_3562_7978:()=>sQe,content_3562_798:()=>cF,content_3562_7980:()=>iQe,content_3562_7982:()=>lQe,content_3562_7984:()=>mQe,content_3562_7986:()=>hQe,content_3562_7988:()=>kQe,content_3562_7990:()=>wQe,content_3562_7992:()=>MQe,content_3562_7994:()=>_Qe,content_3562_7996:()=>TQe,content_3562_7998:()=>xQe,content_3562_8:()=>vb,content_3562_80:()=>FN,content_3562_800:()=>aF,content_3562_8000:()=>LQe,content_3562_8002:()=>bQe,content_3562_8004:()=>zQe,content_3562_8006:()=>WQe,content_3562_8008:()=>RQe,content_3562_8010:()=>SQe,content_3562_8012:()=>EQe,content_3562_8014:()=>GQe,content_3562_8016:()=>UQe,content_3562_8018:()=>qQe,content_3562_802:()=>uF,content_3562_8020:()=>YQe,content_3562_8022:()=>QQe,content_3562_8024:()=>KQe,content_3562_8026:()=>t$e,content_3562_8028:()=>n$e,content_3562_8030:()=>p$e,content_3562_8032:()=>s$e,content_3562_8034:()=>i$e,content_3562_8036:()=>l$e,content_3562_8038:()=>m$e,content_3562_804:()=>dF,content_3562_8040:()=>h$e,content_3562_8042:()=>k$e,content_3562_8044:()=>w$e,content_3562_8046:()=>M$e,content_3562_8048:()=>_$e,content_3562_8050:()=>T$e,content_3562_8052:()=>x$e,content_3562_8054:()=>L$e,content_3562_8056:()=>b$e,content_3562_8058:()=>z$e,content_3562_806:()=>fF,content_3562_8060:()=>W$e,content_3562_8062:()=>R$e,content_3562_8064:()=>S$e,content_3562_8066:()=>E$e,content_3562_8068:()=>G$e,content_3562_8070:()=>U$e,content_3562_8072:()=>q$e,content_3562_8074:()=>Y$e,content_3562_8076:()=>Q$e,content_3562_8078:()=>K$e,content_3562_808:()=>yF,content_3562_8080:()=>tKe,content_3562_8082:()=>nKe,content_3562_8084:()=>pKe,content_3562_8086:()=>sKe,content_3562_8088:()=>iKe,content_3562_8090:()=>lKe,content_3562_8092:()=>mKe,content_3562_8094:()=>hKe,content_3562_8096:()=>kKe,content_3562_8098:()=>wKe,content_3562_810:()=>DF,content_3562_8100:()=>MKe,content_3562_8102:()=>_Ke,content_3562_8104:()=>TKe,content_3562_8106:()=>xKe,content_3562_8108:()=>LKe,content_3562_8110:()=>bKe,content_3562_8112:()=>zKe,content_3562_8114:()=>WKe,content_3562_8116:()=>RKe,content_3562_8118:()=>SKe,content_3562_812:()=>XF,content_3562_8120:()=>EKe,content_3562_8122:()=>GKe,content_3562_8124:()=>UKe,content_3562_8126:()=>qKe,content_3562_8128:()=>YKe,content_3562_8130:()=>QKe,content_3562_8132:()=>KKe,content_3562_8134:()=>tJe,content_3562_8136:()=>nJe,content_3562_8138:()=>pJe,content_3562_814:()=>gF,content_3562_8140:()=>sJe,content_3562_8142:()=>iJe,content_3562_8144:()=>lJe,content_3562_8146:()=>mJe,content_3562_8148:()=>hJe,content_3562_8150:()=>kJe,content_3562_8152:()=>wJe,content_3562_8154:()=>MJe,content_3562_8156:()=>_Je,content_3562_8158:()=>TJe,content_3562_816:()=>CF,content_3562_8160:()=>xJe,content_3562_8162:()=>LJe,content_3562_8164:()=>bJe,content_3562_8166:()=>zJe,content_3562_8168:()=>WJe,content_3562_8170:()=>RJe,content_3562_8172:()=>SJe,content_3562_8174:()=>EJe,content_3562_8176:()=>GJe,content_3562_8178:()=>UJe,content_3562_818:()=>vF,content_3562_8180:()=>qJe,content_3562_8182:()=>YJe,content_3562_8184:()=>QJe,content_3562_8186:()=>KJe,content_3562_8188:()=>t0e,content_3562_8190:()=>n0e,content_3562_8192:()=>p0e,content_3562_8194:()=>s0e,content_3562_8196:()=>i0e,content_3562_8198:()=>l0e,content_3562_82:()=>jN,content_3562_820:()=>ZF,content_3562_8200:()=>m0e,content_3562_8202:()=>h0e,content_3562_8204:()=>k0e,content_3562_8206:()=>w0e,content_3562_8208:()=>M0e,content_3562_8210:()=>_0e,content_3562_8212:()=>T0e,content_3562_8214:()=>x0e,content_3562_8216:()=>L0e,content_3562_8218:()=>b0e,content_3562_822:()=>NF,content_3562_8220:()=>z0e,content_3562_8222:()=>W0e,content_3562_8224:()=>R0e,content_3562_8226:()=>S0e,content_3562_8228:()=>E0e,content_3562_8230:()=>G0e,content_3562_8232:()=>U0e,content_3562_8234:()=>q0e,content_3562_8236:()=>Y0e,content_3562_8238:()=>Q0e,content_3562_824:()=>AF,content_3562_8240:()=>K0e,content_3562_8242:()=>t2e,content_3562_8244:()=>n2e,content_3562_8246:()=>p2e,content_3562_8248:()=>s2e,content_3562_8250:()=>i2e,content_3562_8252:()=>l2e,content_3562_8254:()=>m2e,content_3562_8256:()=>h2e,content_3562_8258:()=>k2e,content_3562_826:()=>IF,content_3562_8260:()=>w2e,content_3562_8262:()=>M2e,content_3562_8264:()=>_2e,content_3562_8266:()=>T2e,content_3562_8268:()=>x2e,content_3562_8270:()=>L2e,content_3562_8272:()=>b2e,content_3562_8274:()=>z2e,content_3562_8276:()=>W2e,content_3562_8278:()=>R2e,content_3562_828:()=>PF,content_3562_8280:()=>S2e,content_3562_8282:()=>E2e,content_3562_8284:()=>G2e,content_3562_8286:()=>U2e,content_3562_8288:()=>q2e,content_3562_8290:()=>Y2e,content_3562_8292:()=>Q2e,content_3562_8294:()=>K2e,content_3562_8296:()=>t6e,content_3562_8298:()=>n6e,content_3562_830:()=>OF,content_3562_8300:()=>p6e,content_3562_8302:()=>s6e,content_3562_8304:()=>i6e,content_3562_8306:()=>l6e,content_3562_8308:()=>m6e,content_3562_8310:()=>h6e,content_3562_8312:()=>k6e,content_3562_8314:()=>w6e,content_3562_8316:()=>M6e,content_3562_8318:()=>_6e,content_3562_832:()=>BF,content_3562_8320:()=>T6e,content_3562_8322:()=>x6e,content_3562_8324:()=>L6e,content_3562_8326:()=>b6e,content_3562_8328:()=>z6e,content_3562_8330:()=>W6e,content_3562_8332:()=>R6e,content_3562_8334:()=>S6e,content_3562_8336:()=>E6e,content_3562_8338:()=>G6e,content_3562_834:()=>VF,content_3562_8340:()=>U6e,content_3562_8342:()=>q6e,content_3562_8344:()=>Y6e,content_3562_8346:()=>Q6e,content_3562_8348:()=>K6e,content_3562_8350:()=>t3e,content_3562_8352:()=>n3e,content_3562_8354:()=>p3e,content_3562_8356:()=>s3e,content_3562_8358:()=>i3e,content_3562_836:()=>FF,content_3562_8360:()=>l3e,content_3562_8362:()=>m3e,content_3562_8364:()=>h3e,content_3562_8366:()=>k3e,content_3562_8368:()=>w3e,content_3562_8370:()=>M3e,content_3562_8372:()=>_3e,content_3562_8374:()=>T3e,content_3562_8376:()=>x3e,content_3562_8378:()=>L3e,content_3562_838:()=>jF,content_3562_8380:()=>b3e,content_3562_8382:()=>z3e,content_3562_8384:()=>W3e,content_3562_8386:()=>R3e,content_3562_8388:()=>S3e,content_3562_8390:()=>E3e,content_3562_8392:()=>G3e,content_3562_8394:()=>U3e,content_3562_8396:()=>q3e,content_3562_8398:()=>Y3e,content_3562_84:()=>HN,content_3562_840:()=>HF,content_3562_8400:()=>Q3e,content_3562_8402:()=>K3e,content_3562_8404:()=>t5e,content_3562_8406:()=>n5e,content_3562_8408:()=>p5e,content_3562_8410:()=>s5e,content_3562_8412:()=>i5e,content_3562_8414:()=>l5e,content_3562_8416:()=>m5e,content_3562_8418:()=>h5e,content_3562_842:()=>$F,content_3562_8420:()=>k5e,content_3562_8422:()=>w5e,content_3562_8424:()=>M5e,content_3562_8426:()=>_5e,content_3562_8428:()=>T5e,content_3562_8430:()=>x5e,content_3562_8432:()=>L5e,content_3562_8434:()=>b5e,content_3562_8436:()=>z5e,content_3562_8438:()=>W5e,content_3562_844:()=>JF,content_3562_8440:()=>R5e,content_3562_8442:()=>S5e,content_3562_8444:()=>E5e,content_3562_8446:()=>G5e,content_3562_8448:()=>U5e,content_3562_8450:()=>q5e,content_3562_8452:()=>Y5e,content_3562_8454:()=>Q5e,content_3562_8456:()=>K5e,content_3562_8458:()=>t1e,content_3562_846:()=>eq,content_3562_8460:()=>n1e,content_3562_8462:()=>p1e,content_3562_8464:()=>s1e,content_3562_8466:()=>i1e,content_3562_8468:()=>l1e,content_3562_8470:()=>m1e,content_3562_8472:()=>h1e,content_3562_8474:()=>k1e,content_3562_8476:()=>w1e,content_3562_8478:()=>M1e,content_3562_848:()=>oq,content_3562_8480:()=>_1e,content_3562_8482:()=>T1e,content_3562_8484:()=>x1e,content_3562_8486:()=>L1e,content_3562_8488:()=>b1e,content_3562_8490:()=>z1e,content_3562_8492:()=>W1e,content_3562_8494:()=>R1e,content_3562_8496:()=>S1e,content_3562_8498:()=>E1e,content_3562_850:()=>rq,content_3562_8500:()=>G1e,content_3562_8502:()=>U1e,content_3562_8504:()=>q1e,content_3562_8506:()=>Y1e,content_3562_8508:()=>Q1e,content_3562_8510:()=>K1e,content_3562_8512:()=>t4e,content_3562_8514:()=>n4e,content_3562_8516:()=>p4e,content_3562_8518:()=>s4e,content_3562_852:()=>cq,content_3562_8520:()=>i4e,content_3562_8522:()=>l4e,content_3562_8524:()=>m4e,content_3562_8526:()=>h4e,content_3562_8528:()=>k4e,content_3562_8530:()=>w4e,content_3562_8532:()=>M4e,content_3562_8534:()=>_4e,content_3562_8536:()=>T4e,content_3562_8538:()=>x4e,content_3562_854:()=>aq,content_3562_8540:()=>L4e,content_3562_8542:()=>b4e,content_3562_8544:()=>z4e,content_3562_8546:()=>W4e,content_3562_8548:()=>R4e,content_3562_8550:()=>S4e,content_3562_8552:()=>E4e,content_3562_8554:()=>G4e,content_3562_8556:()=>U4e,content_3562_8558:()=>q4e,content_3562_856:()=>uq,content_3562_8560:()=>Y4e,content_3562_8562:()=>Q4e,content_3562_8564:()=>K4e,content_3562_8566:()=>t8e,content_3562_8568:()=>n8e,content_3562_8570:()=>p8e,content_3562_8572:()=>s8e,content_3562_8574:()=>i8e,content_3562_8576:()=>l8e,content_3562_8578:()=>m8e,content_3562_858:()=>dq,content_3562_8580:()=>h8e,content_3562_8582:()=>k8e,content_3562_8584:()=>w8e,content_3562_8586:()=>M8e,content_3562_8588:()=>_8e,content_3562_8590:()=>T8e,content_3562_8592:()=>x8e,content_3562_8594:()=>L8e,content_3562_8596:()=>b8e,content_3562_8598:()=>z8e,content_3562_86:()=>$N,content_3562_860:()=>fq,content_3562_8600:()=>W8e,content_3562_8602:()=>R8e,content_3562_8604:()=>S8e,content_3562_8606:()=>E8e,content_3562_8608:()=>G8e,content_3562_8610:()=>U8e,content_3562_8612:()=>q8e,content_3562_8614:()=>Y8e,content_3562_8616:()=>Q8e,content_3562_8618:()=>K8e,content_3562_862:()=>yq,content_3562_8620:()=>t7e,content_3562_8622:()=>n7e,content_3562_8624:()=>p7e,content_3562_8626:()=>s7e,content_3562_8628:()=>i7e,content_3562_8630:()=>l7e,content_3562_8632:()=>m7e,content_3562_8634:()=>h7e,content_3562_8636:()=>k7e,content_3562_8638:()=>w7e,content_3562_864:()=>Dq,content_3562_8640:()=>M7e,content_3562_8642:()=>_7e,content_3562_8644:()=>T7e,content_3562_8646:()=>x7e,content_3562_8648:()=>L7e,content_3562_8650:()=>b7e,content_3562_8652:()=>z7e,content_3562_8654:()=>W7e,content_3562_8656:()=>R7e,content_3562_8658:()=>S7e,content_3562_866:()=>Xq,content_3562_8660:()=>E7e,content_3562_8662:()=>G7e,content_3562_8664:()=>U7e,content_3562_8666:()=>q7e,content_3562_8668:()=>Y7e,content_3562_8670:()=>Q7e,content_3562_8672:()=>K7e,content_3562_8674:()=>t9e,content_3562_8676:()=>n9e,content_3562_8678:()=>p9e,content_3562_868:()=>gq,content_3562_8680:()=>s9e,content_3562_8682:()=>i9e,content_3562_8684:()=>l9e,content_3562_8686:()=>m9e,content_3562_8688:()=>h9e,content_3562_8690:()=>k9e,content_3562_8692:()=>w9e,content_3562_8694:()=>M9e,content_3562_8696:()=>_9e,content_3562_8698:()=>T9e,content_3562_870:()=>Cq,content_3562_8700:()=>x9e,content_3562_8702:()=>L9e,content_3562_8704:()=>b9e,content_3562_8706:()=>z9e,content_3562_8708:()=>W9e,content_3562_8710:()=>R9e,content_3562_8712:()=>S9e,content_3562_8714:()=>E9e,content_3562_8716:()=>G9e,content_3562_8718:()=>U9e,content_3562_872:()=>vq,content_3562_8720:()=>q9e,content_3562_8722:()=>Y9e,content_3562_8724:()=>Q9e,content_3562_8726:()=>K9e,content_3562_8728:()=>ttn,content_3562_8730:()=>ntn,content_3562_8732:()=>ptn,content_3562_8734:()=>stn,content_3562_8736:()=>itn,content_3562_8738:()=>ltn,content_3562_874:()=>Zq,content_3562_8740:()=>mtn,content_3562_8742:()=>htn,content_3562_8744:()=>ktn,content_3562_8746:()=>wtn,content_3562_8748:()=>Mtn,content_3562_8750:()=>_tn,content_3562_8752:()=>Ttn,content_3562_8754:()=>xtn,content_3562_8756:()=>Ltn,content_3562_8758:()=>btn,content_3562_876:()=>Nq,content_3562_8760:()=>ztn,content_3562_8762:()=>Wtn,content_3562_8764:()=>Rtn,content_3562_8766:()=>Stn,content_3562_8768:()=>Etn,content_3562_8770:()=>Gtn,content_3562_8772:()=>Utn,content_3562_8774:()=>qtn,content_3562_8776:()=>Ytn,content_3562_8778:()=>Qtn,content_3562_878:()=>Aq,content_3562_8780:()=>Ktn,content_3562_8782:()=>ten,content_3562_8784:()=>nen,content_3562_8786:()=>pen,content_3562_8788:()=>sen,content_3562_8790:()=>ien,content_3562_8792:()=>len,content_3562_8794:()=>men,content_3562_8796:()=>hen,content_3562_8798:()=>ken,content_3562_88:()=>JN,content_3562_880:()=>Iq,content_3562_8800:()=>wen,content_3562_8802:()=>Men,content_3562_8804:()=>_en,content_3562_8806:()=>Ten,content_3562_8808:()=>xen,content_3562_8810:()=>Len,content_3562_8812:()=>ben,content_3562_8814:()=>zen,content_3562_8816:()=>Wen,content_3562_8818:()=>Ren,content_3562_882:()=>Pq,content_3562_8820:()=>Sen,content_3562_8822:()=>Een,content_3562_8824:()=>Gen,content_3562_8826:()=>Uen,content_3562_8828:()=>qen,content_3562_8830:()=>Yen,content_3562_8832:()=>Qen,content_3562_8834:()=>Ken,content_3562_8836:()=>tnn,content_3562_8838:()=>nnn,content_3562_884:()=>Oq,content_3562_8840:()=>pnn,content_3562_8842:()=>snn,content_3562_8844:()=>inn,content_3562_8846:()=>lnn,content_3562_8848:()=>mnn,content_3562_8850:()=>hnn,content_3562_8852:()=>knn,content_3562_8854:()=>wnn,content_3562_8856:()=>Mnn,content_3562_8858:()=>_nn,content_3562_886:()=>Bq,content_3562_8860:()=>Tnn,content_3562_8862:()=>xnn,content_3562_8864:()=>Lnn,content_3562_8866:()=>bnn,content_3562_8868:()=>znn,content_3562_8870:()=>Wnn,content_3562_8872:()=>Rnn,content_3562_8874:()=>Snn,content_3562_8876:()=>Enn,content_3562_8878:()=>Gnn,content_3562_888:()=>Vq,content_3562_8880:()=>Unn,content_3562_8882:()=>qnn,content_3562_8884:()=>Ynn,content_3562_8886:()=>Qnn,content_3562_8888:()=>Knn,content_3562_8890:()=>ton,content_3562_8892:()=>non,content_3562_8894:()=>pon,content_3562_8896:()=>son,content_3562_8898:()=>ion,content_3562_890:()=>Fq,content_3562_8900:()=>lon,content_3562_8902:()=>mon,content_3562_8904:()=>hon,content_3562_8906:()=>kon,content_3562_8908:()=>won,content_3562_8910:()=>Mon,content_3562_8912:()=>_on,content_3562_8914:()=>Ton,content_3562_8916:()=>xon,content_3562_8918:()=>Lon,content_3562_892:()=>jq,content_3562_8920:()=>bon,content_3562_8922:()=>zon,content_3562_8924:()=>Won,content_3562_8926:()=>Ron,content_3562_8928:()=>Son,content_3562_8930:()=>Eon,content_3562_8932:()=>Gon,content_3562_8934:()=>Uon,content_3562_8936:()=>qon,content_3562_8938:()=>Yon,content_3562_894:()=>Hq,content_3562_8940:()=>Qon,content_3562_8942:()=>Kon,content_3562_8944:()=>tpn,content_3562_8946:()=>npn,content_3562_8948:()=>ppn,content_3562_8950:()=>spn,content_3562_8952:()=>ipn,content_3562_8954:()=>lpn,content_3562_8956:()=>mpn,content_3562_8958:()=>hpn,content_3562_896:()=>$q,content_3562_8960:()=>kpn,content_3562_8962:()=>wpn,content_3562_8964:()=>Mpn,content_3562_8966:()=>_pn,content_3562_8968:()=>Tpn,content_3562_8970:()=>xpn,content_3562_8972:()=>Lpn,content_3562_8974:()=>bpn,content_3562_8976:()=>zpn,content_3562_8978:()=>Wpn,content_3562_898:()=>Jq,content_3562_8980:()=>Rpn,content_3562_8982:()=>Spn,content_3562_8984:()=>Epn,content_3562_8986:()=>Gpn,content_3562_8988:()=>Upn,content_3562_8990:()=>qpn,content_3562_8992:()=>Ypn,content_3562_8994:()=>Qpn,content_3562_8996:()=>Kpn,content_3562_8998:()=>trn,content_3562_90:()=>ez,content_3562_900:()=>ej,content_3562_9000:()=>nrn,content_3562_9002:()=>prn,content_3562_9004:()=>srn,content_3562_9006:()=>irn,content_3562_9008:()=>lrn,content_3562_9010:()=>mrn,content_3562_9012:()=>hrn,content_3562_9014:()=>krn,content_3562_9016:()=>wrn,content_3562_9018:()=>Mrn,content_3562_902:()=>oj,content_3562_9020:()=>_rn,content_3562_9022:()=>Trn,content_3562_9024:()=>xrn,content_3562_9026:()=>Lrn,content_3562_9028:()=>brn,content_3562_9030:()=>zrn,content_3562_9032:()=>Wrn,content_3562_9034:()=>Rrn,content_3562_9036:()=>Srn,content_3562_9038:()=>Ern,content_3562_904:()=>rj,content_3562_9040:()=>Grn,content_3562_9042:()=>Urn,content_3562_9044:()=>qrn,content_3562_9046:()=>Yrn,content_3562_9048:()=>Qrn,content_3562_9050:()=>Krn,content_3562_9052:()=>tsn,content_3562_9054:()=>nsn,content_3562_9056:()=>psn,content_3562_9058:()=>ssn,content_3562_906:()=>cj,content_3562_9060:()=>isn,content_3562_9062:()=>lsn,content_3562_9064:()=>msn,content_3562_9066:()=>hsn,content_3562_9068:()=>ksn,content_3562_9070:()=>wsn,content_3562_9072:()=>Msn,content_3562_9074:()=>_sn,content_3562_9076:()=>Tsn,content_3562_9078:()=>xsn,content_3562_908:()=>aj,content_3562_9080:()=>Lsn,content_3562_9082:()=>bsn,content_3562_9084:()=>zsn,content_3562_9086:()=>Wsn,content_3562_9088:()=>Rsn,content_3562_9090:()=>Ssn,content_3562_9092:()=>Esn,content_3562_9094:()=>Gsn,content_3562_9096:()=>Usn,content_3562_9098:()=>qsn,content_3562_910:()=>uj,content_3562_9100:()=>Ysn,content_3562_9102:()=>Qsn,content_3562_9104:()=>Ksn,content_3562_9106:()=>tcn,content_3562_9108:()=>ncn,content_3562_9110:()=>pcn,content_3562_9112:()=>scn,content_3562_9114:()=>icn,content_3562_9116:()=>lcn,content_3562_9118:()=>mcn,content_3562_912:()=>dj,content_3562_9120:()=>hcn,content_3562_9122:()=>kcn,content_3562_9124:()=>wcn,content_3562_9126:()=>Mcn,content_3562_9128:()=>_cn,content_3562_9130:()=>Tcn,content_3562_9132:()=>xcn,content_3562_9134:()=>Lcn,content_3562_9136:()=>bcn,content_3562_9138:()=>zcn,content_3562_914:()=>fj,content_3562_9140:()=>Wcn,content_3562_9142:()=>Rcn,content_3562_9144:()=>Scn,content_3562_9146:()=>Ecn,content_3562_9148:()=>Gcn,content_3562_9150:()=>Ucn,content_3562_9152:()=>qcn,content_3562_9154:()=>Ycn,content_3562_9156:()=>Qcn,content_3562_9158:()=>Kcn,content_3562_916:()=>yj,content_3562_9160:()=>tin,content_3562_9162:()=>nin,content_3562_9164:()=>pin,content_3562_9166:()=>sin,content_3562_9168:()=>iin,content_3562_9170:()=>lin,content_3562_9172:()=>min,content_3562_9174:()=>hin,content_3562_9176:()=>kin,content_3562_9178:()=>win,content_3562_918:()=>Dj,content_3562_9180:()=>Min,content_3562_9182:()=>_in,content_3562_9184:()=>Tin,content_3562_9186:()=>xin,content_3562_9188:()=>Lin,content_3562_9190:()=>bin,content_3562_9192:()=>zin,content_3562_9194:()=>Win,content_3562_9196:()=>Rin,content_3562_9198:()=>Sin,content_3562_92:()=>oz,content_3562_920:()=>Xj,content_3562_9200:()=>Ein,content_3562_9202:()=>Gin,content_3562_9204:()=>Uin,content_3562_9206:()=>qin,content_3562_9208:()=>Yin,content_3562_9210:()=>Qin,content_3562_9212:()=>Kin,content_3562_9214:()=>tan,content_3562_9216:()=>nan,content_3562_9218:()=>pan,content_3562_922:()=>gj,content_3562_9220:()=>san,content_3562_9222:()=>ian,content_3562_9224:()=>lan,content_3562_9226:()=>man,content_3562_9228:()=>han,content_3562_9230:()=>kan,content_3562_9232:()=>wan,content_3562_9234:()=>Man,content_3562_9236:()=>_an,content_3562_9238:()=>Tan,content_3562_924:()=>Cj,content_3562_926:()=>vj,content_3562_928:()=>Zj,content_3562_930:()=>Nj,content_3562_932:()=>Aj,content_3562_934:()=>Ij,content_3562_936:()=>Pj,content_3562_938:()=>Oj,content_3562_94:()=>rz,content_3562_940:()=>Bj,content_3562_942:()=>Vj,content_3562_944:()=>Fj,content_3562_946:()=>jj,content_3562_948:()=>Hj,content_3562_950:()=>$j,content_3562_952:()=>Jj,content_3562_954:()=>eY,content_3562_956:()=>oY,content_3562_958:()=>rY,content_3562_96:()=>cz,content_3562_960:()=>cY,content_3562_962:()=>aY,content_3562_964:()=>uY,content_3562_966:()=>dY,content_3562_968:()=>fY,content_3562_970:()=>yY,content_3562_972:()=>DY,content_3562_974:()=>XY,content_3562_976:()=>gY,content_3562_978:()=>CY,content_3562_98:()=>az,content_3562_980:()=>vY,content_3562_982:()=>ZY,content_3562_984:()=>NY,content_3562_986:()=>AY,content_3562_988:()=>IY,content_3562_990:()=>PY,content_3562_992:()=>OY,content_3562_994:()=>BY,content_3562_996:()=>VY,content_3562_998:()=>FY});var p=n(2784),r=n(7896),s=n(876);const c={toc:[]};function i(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Main Motion Canvas classes."))}i.isMDXComponent=!0;const a={toc:[]};function l(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when a new message is logged."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A read-only representation of the playback."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert frames to seconds using the current framerate."))}h.isMDXComponent=!0;const f={toc:[]};function k(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frames to convert."))}k.isMDXComponent=!0;const y={toc:[]};function w(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert seconds to frames using the current framerate."))}w.isMDXComponent=!0;const D={toc:[]};function M(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seconds to convert."))}M.isMDXComponent=!0;const X={toc:[]};function _(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class builds on top of the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to provide a simple\ninterface similar to other media players. It plays through the animation\nusing a real-time update loop and optionally synchronises it with audio."))}_.isMDXComponent=!0;const g={toc:[]};function T(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player logic used by the editor and embeddable player."))}T.isMDXComponent=!0;const C={toc:[]};function x(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to provide visual feedback."))}x.isMDXComponent=!0;const v={toc:[]};function L(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered right after recalculation finishes."))}L.isMDXComponent=!0;const Z={toc:[]};function b(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Player does not perform any rendering on its own. For the animation to be\nvisible, another class must subscribe to this event and perform the\nrendering itself. ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Stage"},(0,s.kt)("inlineCode",{parentName:"a"},"Stage"))," can be used to display the animation."))}b.isMDXComponent=!0;const N={toc:[]};function z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered during each iteration of the update loop when the frame is ready\nto be rendered."))}z.isMDXComponent=!0;const A={toc:[]};function W(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A player needs to be active in order for the update loop to run. Each\nplayer is active by default."))}W.isMDXComponent=!0;const I={toc:[]};function R(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Activate the player."))}R.isMDXComponent=!0;const P={toc:[]};function S(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivating the player prevents its update loop from running. This should\nbe done before disposing the player, to prevent it from running in the\nbackground."),(0,s.kt)("p",null,"Just pausing the player does not stop the loop."))}S.isMDXComponent=!0;const O={toc:[]};function E(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivate the player."))}E.isMDXComponent=!0;const B={toc:[]};function G(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing presentation process."))}G.isMDXComponent=!0;const V={toc:[]};function U(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Present the animation."))}U.isMDXComponent=!0;const F={toc:[]};function q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presentation settings."))}q.isMDXComponent=!0;const j={toc:[]};function Y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Resume the presentation if waiting for the next slide."))}Y.isMDXComponent=!0;const H={toc:[]};function Q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Q.isMDXComponent=!0;const $={toc:[]};function K(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}K.isMDXComponent=!0;const J={toc:[]};function tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tt.isMDXComponent=!0;const et={toc:[]};function nt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}nt.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}pt.isMDXComponent=!0;const rt={toc:[]};function st(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}st.isMDXComponent=!0;const ct={toc:[]};function it(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}it.isMDXComponent=!0;const at={toc:[]};function lt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},at,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}ht.isMDXComponent=!0;const ft={toc:[]};function kt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}kt.isMDXComponent=!0;const yt={toc:[]};function wt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}wt.isMDXComponent=!0;const Dt={toc:[]};function Mt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Mt.isMDXComponent=!0;const Xt={toc:[]};function _t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}_t.isMDXComponent=!0;const gt={toc:[]};function Tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class uses the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to render animations. In contrast to a\nplayer, a renderer does not use an update loop. It plays through the\nanimation as fast as it can, occasionally pausing to keep the UI responsive."),(0,s.kt)("p",null,"The actual exporting is outsourced to an ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Exporter"},(0,s.kt)("inlineCode",{parentName:"a"},"Exporter")),"."))}Tt.isMDXComponent=!0;const Ct={toc:[]};function xt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering logic used by the editor to export animations."))}xt.isMDXComponent=!0;const vt={toc:[]};function Lt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing render process."))}Lt.isMDXComponent=!0;const Zt={toc:[]};function bt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the animation using the provided settings."))}bt.isMDXComponent=!0;const Nt={toc:[]};function zt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}zt.isMDXComponent=!0;const At={toc:[]};function Wt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},At,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method always uses the default ",(0,s.kt)("inlineCode",{parentName:"p"},"ImageExporter"),"."))}Wt.isMDXComponent=!0;const It={toc:[]};function Rt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},It,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export an individual frame."))}Rt.isMDXComponent=!0;const Pt={toc:[]};function St(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}St.isMDXComponent=!0;const Ot={toc:[]};function Et(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timestamp to export."))}Et.isMDXComponent=!0;const Bt={toc:[]};function Gt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Manages canvases on which an animation can be displayed."))}Gt.isMDXComponent=!0;const Vt={toc:[]};function Ut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for implementing custom exporters."))}Ut.isMDXComponent=!0;const Ft={toc:[]};function qt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called at the beginning of the rendering process, before anything else has\nbeen set up. The returned value can be used to override the rendering\nsettings provided by the user."))}qt.isMDXComponent=!0;const jt={toc:[]};function Yt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the rendering configuration."))}Yt.isMDXComponent=!0;const Ht={toc:[]};function Qt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called each time after a frame is rendered."))}Qt.isMDXComponent=!0;const $t={toc:[]};function Kt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export a frame."))}Kt.isMDXComponent=!0;const Jt={toc:[]};function te(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A canvas containing the rendered frame."))}te.isMDXComponent=!0;const ee={toc:[]};function ne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number."))}ne.isMDXComponent=!0;const oe={toc:[]};function pe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number within the scene."))}pe.isMDXComponent=!0;const re={toc:[]};function se(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the scene with which the frame is associated."))}se.isMDXComponent=!0;const ce={toc:[]};function ie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An abort signal triggered if the user aborts the rendering."))}ie.isMDXComponent=!0;const ae={toc:[]};function le(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.kt)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.kt)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}le.isMDXComponent=!0;const ue={toc:[]};function me(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Begin the rendering process."))}me.isMDXComponent=!0;const de={toc:[]};function he(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},de,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Can be used to finalize the exporting and perform any necessary\nclean-up."))}he.isMDXComponent=!0;const fe={toc:[]};function ke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Finish the rendering process."))}ke.isMDXComponent=!0;const ye={toc:[]};function we(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The result of the rendering."))}we.isMDXComponent=!0;const De={toc:[]};function Me(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},De,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The static interface for exporters."))}Me.isMDXComponent=!0;const Xe={toc:[]};function _e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This name will be displayed in the editor."))}_e.isMDXComponent=!0;const ge={toc:[]};function Te(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this exporter."))}Te.isMDXComponent=!0;const Ce={toc:[]};function xe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This identifier will be used to store the settings of this exporter.\nIt's recommended to prepend it with the name of the package to avoid\ncollisions."))}xe.isMDXComponent=!0;const ve={toc:[]};function Le(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The unique identifier of this exporter."))}Le.isMDXComponent=!0;const Ze={toc:[]};function be(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A new exporter is created whenever the user starts a new rendering process."))}be.isMDXComponent=!0;const Ne={toc:[]};function ze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this exporter."))}ze.isMDXComponent=!0;const Ae={toc:[]};function We(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current project."))}We.isMDXComponent=!0;const Ie={toc:[]};function Re(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}Re.isMDXComponent=!0;const Pe={toc:[]};function Se(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a meta field representing the options of this exporter."))}Se.isMDXComponent=!0;const Oe={toc:[]};function Ee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configure the offset in the Video Settings tab of th editor."))}Ee.isMDXComponent=!0;const Be={toc:[]};function Ge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Be,n,{components:e,mdxType:"MDXLayout"}))}Ge.isMDXComponent=!0;const Ve={toc:[]};function Ue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the settings metadata."))}Ue.isMDXComponent=!0;const Fe={toc:[]};function qe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the settings metadata."))}qe.isMDXComponent=!0;const je={toc:[]};function Ye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Property decorators."))}Ye.isMDXComponent=!0;const He={toc:[]};function Qe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},He,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}Qe.isMDXComponent=!0;const $e={toc:[]};function Ke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a lazy decorator."))}Ke.isMDXComponent=!0;const Je={toc:[]};function tn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the value of this property."))}tn.isMDXComponent=!0;const en={toc:[]};function nn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},en,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscriptions and triggering of events."))}nn.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},on,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}pn.isMDXComponent=!0;const rn={toc:[]};function sn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}sn.isMDXComponent=!0;const cn={toc:[]};function an(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches an asynchronous ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}dn.isMDXComponent=!0;const hn={toc:[]};function fn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}fn.isMDXComponent=!0;const kn={toc:[]};function yn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}yn.isMDXComponent=!0;const wn={toc:[]};function Dn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Dn.isMDXComponent=!0;const Mn={toc:[]};function Xn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Xn.isMDXComponent=!0;const _n={toc:[]};function gn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}gn.isMDXComponent=!0;const Tn={toc:[]};function Cn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}Cn.isMDXComponent=!0;const xn={toc:[]};function vn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}vn.isMDXComponent=!0;const Ln={toc:[]};function Zn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Zn.isMDXComponent=!0;const bn={toc:[]};function Nn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Nn.isMDXComponent=!0;const zn={toc:[]};function An(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}An.isMDXComponent=!0;const Wn={toc:[]};function In(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}In.isMDXComponent=!0;const Rn={toc:[]};function Pn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Pn.isMDXComponent=!0;const Sn={toc:[]};function On(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}On.isMDXComponent=!0;const En={toc:[]};function Bn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},En,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value argument to subscribers."))}Bn.isMDXComponent=!0;const Gn={toc:[]};function Vn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A base for dispatching ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Vn.isMDXComponent=!0;const Un={toc:[]};function Fn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Un,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Fn.isMDXComponent=!0;const qn={toc:[]};function jn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}jn.isMDXComponent=!0;const Yn={toc:[]};function Hn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Hn.isMDXComponent=!0;const Qn={toc:[]};function $n(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}$n.isMDXComponent=!0;const Kn={toc:[]};function Jn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Jn.isMDXComponent=!0;const to={toc:[]};function eo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},to,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}eo.isMDXComponent=!0;const no={toc:[]};function oo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},no,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}oo.isMDXComponent=!0;const po={toc:[]};function ro(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},po,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}ro.isMDXComponent=!0;const so={toc:[]};function co(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},so,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}co.isMDXComponent=!0;const io={toc:[]};function ao(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},io,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}ao.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}ho.isMDXComponent=!0;const fo={toc:[]};function ko(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Are subscribers being notified?"))}ko.isMDXComponent=!0;const yo={toc:[]};function wo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Notify all current and future subscribers."))}wo.isMDXComponent=!0;const Do={toc:[]};function Mo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Do,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Stop notifying future subscribers."))}Mo.isMDXComponent=!0;const Xo={toc:[]};function _o(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}_o.isMDXComponent=!0;const go={toc:[]};function To(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},go,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}To.isMDXComponent=!0;const Co={toc:[]};function xo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Co,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}xo.isMDXComponent=!0;const vo={toc:[]};function Lo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Lo.isMDXComponent=!0;const Zo={toc:[]};function bo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}bo.isMDXComponent=!0;const No={toc:[]};function zo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},No,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}zo.isMDXComponent=!0;const Ao={toc:[]};function Wo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Wo.isMDXComponent=!0;const Io={toc:[]};function Ro(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Io,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Ro.isMDXComponent=!0;const Po={toc:[]};function So(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Po,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}So.isMDXComponent=!0;const Oo={toc:[]};function Eo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Eo.isMDXComponent=!0;const Bo={toc:[]};function Go(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Go.isMDXComponent=!0;const Vo={toc:[]};function Uo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Uo.isMDXComponent=!0;const Fo={toc:[]};function qo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}qo.isMDXComponent=!0;const jo={toc:[]};function Yo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}Yo.isMDXComponent=!0;const Ho={toc:[]};function Qo(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Qo.isMDXComponent=!0;const $o={toc:[]};function Ko(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}Ko.isMDXComponent=!0;const Jo={toc:[]};function tp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}tp.isMDXComponent=!0;const ep={toc:[]};function np(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}np.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},op,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}pp.isMDXComponent=!0;const rp={toc:[]};function sp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}sp.isMDXComponent=!0;const cp={toc:[]};function ip(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}ip.isMDXComponent=!0;const ap={toc:[]};function lp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},up,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}hp.isMDXComponent=!0;const fp={toc:[]};function kp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}kp.isMDXComponent=!0;const yp={toc:[]};function wp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}wp.isMDXComponent=!0;const Dp={toc:[]};function Mp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}Mp.isMDXComponent=!0;const Xp={toc:[]};function _p(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}_p.isMDXComponent=!0;const gp={toc:[]};function Tp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Tp.isMDXComponent=!0;const Cp={toc:[]};function xp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value."))}xp.isMDXComponent=!0;const vp={toc:[]};function Lp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}Lp.isMDXComponent=!0;const Zp={toc:[]};function bp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Setting the value will immediately notify all subscribers."))}bp.isMDXComponent=!0;const Np={toc:[]};function zp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Np,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value of this dispatcher."))}zp.isMDXComponent=!0;const Ap={toc:[]};function Wp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Wp.isMDXComponent=!0;const Ip={toc:[]};function Rp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Rp.isMDXComponent=!0;const Pp={toc:[]};function Sp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}Sp.isMDXComponent=!0;const Op={toc:[]};function Ep(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Op,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ep.isMDXComponent=!0;const Bp={toc:[]};function Gp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Gp.isMDXComponent=!0;const Vp={toc:[]};function Up(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Up.isMDXComponent=!0;const Fp={toc:[]};function qp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}qp.isMDXComponent=!0;const jp={toc:[]};function Yp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Yp.isMDXComponent=!0;const Hp={toc:[]};function Qp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Qp.isMDXComponent=!0;const $p={toc:[]};function Kp(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Kp.isMDXComponent=!0;const Jp={toc:[]};function tr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}tr.isMDXComponent=!0;const er={toc:[]};function nr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},er,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}nr.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},or,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}pr.isMDXComponent=!0;const rr={toc:[]};function sr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}sr.isMDXComponent=!0;const cr={toc:[]};function ir(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}ir.isMDXComponent=!0;const ar={toc:[]};function lr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ur,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}hr.isMDXComponent=!0;const fr={toc:[]};function kr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of times the timer has ticked."))}kr.isMDXComponent=!0;const yr={toc:[]};function wr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator responsible for running this timer."))}wr.isMDXComponent=!0;const Dr={toc:[]};function Mr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the timer ticks."))}Mr.isMDXComponent=!0;const Xr={toc:[]};function _r(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current iteration index."))}_r.isMDXComponent=!0;const gr={toc:[]};function Tr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Tr.isMDXComponent=!0;const Cr={toc:[]};function xr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}xr.isMDXComponent=!0;const vr={toc:[]};function Lr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Lr.isMDXComponent=!0;const Zr={toc:[]};function br(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}br.isMDXComponent=!0;const Nr={toc:[]};function zr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}zr.isMDXComponent=!0;const Ar={toc:[]};function Wr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Wr.isMDXComponent=!0;const Ir={toc:[]};function Rr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Rr.isMDXComponent=!0;const Pr={toc:[]};function Sr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run tasks one after another."))}Sr.isMDXComponent=!0;const Or={toc:[]};function Er(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Or,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Er.isMDXComponent=!0;const Br={toc:[]};function Gr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Br,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}Gr.isMDXComponent=!0;const Vr={toc:[]};function Ur(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Ur.isMDXComponent=!0;const Fr={toc:[]};function qr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay in seconds"))}qr.isMDXComponent=!0;const jr={toc:[]};function Yr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task or callback to run after the delay."))}Yr.isMDXComponent=!0;const Hr={toc:[]};function Qr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}Qr.isMDXComponent=!0;const $r={toc:[]};function Kr(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Call the given callback every N seconds."))}Kr.isMDXComponent=!0;const Jr={toc:[]};function ts(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interval between subsequent calls."))}ts.isMDXComponent=!0;const es={toc:[]};function ns(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},es,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to be called."))}ns.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},os,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each iteration waits until the previous one is completed."))}ps.isMDXComponent=!0;const rs={toc:[]};function ss(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}ss.isMDXComponent=!0;const cs={toc:[]};function is(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator N times."))}is.isMDXComponent=!0;const as={toc:[]};function ls(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},as,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of iterations."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},us,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ds,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}hs.isMDXComponent=!0;const fs={toc:[]};function ks(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}ks.isMDXComponent=!0;const ys={toc:[]};function ws(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ys,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop for the given amount of time."))}ws.isMDXComponent=!0;const Ds={toc:[]};function Ms(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ds,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration in seconds."))}Ms.isMDXComponent=!0;const Xs={toc:[]};function _s(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}_s.isMDXComponent=!0;const gs={toc:[]};function Ts(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Ts.isMDXComponent=!0;const Cs={toc:[]};function xs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}xs.isMDXComponent=!0;const vs={toc:[]};function Ls(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop until the given time event."))}Ls.isMDXComponent=!0;const Zs={toc:[]};function bs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The event."))}bs.isMDXComponent=!0;const Ns={toc:[]};function zs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ns,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}zs.isMDXComponent=!0;const As={toc:[]};function Ws(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},As,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Do nothing."))}Ws.isMDXComponent=!0;const Is={toc:[]};function Rs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Is,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Rs.isMDXComponent=!0;const Ps={toc:[]};function Ss(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ps,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Ss.isMDXComponent=!0;const Os={toc:[]};function Es(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Os,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Es.isMDXComponent=!0;const Bs={toc:[]};function Gs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Gs.isMDXComponent=!0;const Vs={toc:[]};function Us(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Us.isMDXComponent=!0;const Fs={toc:[]};function qs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional name used when displaying this generator in the UI."))}qs.isMDXComponent=!0;const js={toc:[]};function Ys(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},js,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Ys.isMDXComponent=!0;const Hs={toc:[]};function Qs(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Qs.isMDXComponent=!0;const $s={toc:[]};function Ks(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$s,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Ks.isMDXComponent=!0;const Js={toc:[]};function tc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Js,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Start all tasks one after another with a constant delay between."))}tc.isMDXComponent=!0;const ec={toc:[]};function nc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ec,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay between each of the tasks."))}nc.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to be run in a sequence."))}pc.isMDXComponent=!0;const rc={toc:[]};function sc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}sc.isMDXComponent=!0;const cc={toc:[]};function ic(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the given amount of time."))}ic.isMDXComponent=!0;const ac={toc:[]};function lc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ac,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The relative time in seconds."))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}hc.isMDXComponent=!0;const fc={toc:[]};function kc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}kc.isMDXComponent=!0;const yc={toc:[]};function wc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the given time event."))}wc.isMDXComponent=!0;const Dc={toc:[]};function Mc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the time event."))}Mc.isMDXComponent=!0;const Xc={toc:[]};function _c(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}_c.isMDXComponent=!0;const gc={toc:[]};function Tc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multi-media management."))}Tc.isMDXComponent=!0;const Cc={toc:[]};function xc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}xc.isMDXComponent=!0;const vc={toc:[]};function Lc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause/resume the audio."))}Lc.isMDXComponent=!0;const Zc={toc:[]};function bc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the audio should be paused or resumed."))}bc.isMDXComponent=!0;const Nc={toc:[]};function zc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The absolute biggest value from the peaks array."))}zc.isMDXComponent=!0;const Ac={toc:[]};function Wc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ac,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of samples taken."))}Wc.isMDXComponent=!0;const Ic={toc:[]};function Rc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ic,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Rc.isMDXComponent=!0;const Pc={toc:[]};function Sc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Samples per seconds."))}Sc.isMDXComponent=!0;const Oc={toc:[]};function Ec(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime representation of meta files."))}Ec.isMDXComponent=!0;const Bc={toc:[]};function Gc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a boolean value stored in a meta file."))}Gc.isMDXComponent=!0;const Vc={toc:[]};function Uc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Uc.isMDXComponent=!0;const Fc={toc:[]};function qc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}qc.isMDXComponent=!0;const jc={toc:[]};function Yc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Yc.isMDXComponent=!0;const Hc={toc:[]};function Qc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Qc.isMDXComponent=!0;const $c={toc:[]};function Kc(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Kc.isMDXComponent=!0;const Jc={toc:[]};function ti(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}ti.isMDXComponent=!0;const ei={toc:[]};function ni(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ei,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}ni.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}pi.isMDXComponent=!0;const ri={toc:[]};function si(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ri,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}si.isMDXComponent=!0;const ci={toc:[]};function ii(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ci,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}ii.isMDXComponent=!0;const ai={toc:[]};function li(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ai,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ui,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},di,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}hi.isMDXComponent=!0;const fi={toc:[]};function ki(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}ki.isMDXComponent=!0;const yi={toc:[]};function wi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}wi.isMDXComponent=!0;const Di={toc:[]};function Mi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Di,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Mi.isMDXComponent=!0;const Xi={toc:[]};function _i(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}_i.isMDXComponent=!0;const gi={toc:[]};function Ti(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Ti.isMDXComponent=!0;const Ci={toc:[]};function xi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ci,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}xi.isMDXComponent=!0;const vi={toc:[]};function Li(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Li.isMDXComponent=!0;const Zi={toc:[]};function bi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color stored in a meta file."))}bi.isMDXComponent=!0;const Ni={toc:[]};function zi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ni,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zi.isMDXComponent=!0;const Ai={toc:[]};function Wi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ai,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Wi.isMDXComponent=!0;const Ii={toc:[]};function Ri(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ii,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Ri.isMDXComponent=!0;const Pi={toc:[]};function Si(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Si.isMDXComponent=!0;const Oi={toc:[]};function Ei(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Ei.isMDXComponent=!0;const Bi={toc:[]};function Gi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Gi.isMDXComponent=!0;const Vi={toc:[]};function Ui(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Ui.isMDXComponent=!0;const Fi={toc:[]};function qi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}qi.isMDXComponent=!0;const ji={toc:[]};function Yi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ji,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Yi.isMDXComponent=!0;const Hi={toc:[]};function Qi(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Qi.isMDXComponent=!0;const $i={toc:[]};function Ki(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$i,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ki.isMDXComponent=!0;const Ji={toc:[]};function ta(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ji,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}ta.isMDXComponent=!0;const ea={toc:[]};function na(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ea,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}na.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}pa.isMDXComponent=!0;const ra={toc:[]};function sa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ra,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}sa.isMDXComponent=!0;const ca={toc:[]};function ia(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ca,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}ia.isMDXComponent=!0;const aa={toc:[]};function la(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ua,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},da,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ha.isMDXComponent=!0;const fa={toc:[]};function ka(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}ka.isMDXComponent=!0;const ya={toc:[]};function wa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ya,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an enum value stored in a meta file."))}wa.isMDXComponent=!0;const Da={toc:[]};function Ma(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Da,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Ma.isMDXComponent=!0;const Xa={toc:[]};function _a(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}_a.isMDXComponent=!0;const ga={toc:[]};function Ta(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ga,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Ta.isMDXComponent=!0;const Ca={toc:[]};function xa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ca,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}xa.isMDXComponent=!0;const va={toc:[]};function La(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},va,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}La.isMDXComponent=!0;const Za={toc:[]};function ba(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Za,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}ba.isMDXComponent=!0;const Na={toc:[]};function za(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Na,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}za.isMDXComponent=!0;const Aa={toc:[]};function Wa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Wa.isMDXComponent=!0;const Ia={toc:[]};function Ra(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ia,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ra.isMDXComponent=!0;const Pa={toc:[]};function Sa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Sa.isMDXComponent=!0;const Oa={toc:[]};function Ea(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Ea.isMDXComponent=!0;const Ba={toc:[]};function Ga(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ba,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Ga.isMDXComponent=!0;const Va={toc:[]};function Ua(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Va,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Ua.isMDXComponent=!0;const Fa={toc:[]};function qa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}qa.isMDXComponent=!0;const ja={toc:[]};function Ya(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ja,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Ya.isMDXComponent=!0;const Ha={toc:[]};function Qa(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ha,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Qa.isMDXComponent=!0;const $a={toc:[]};function Ka(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Ka.isMDXComponent=!0;const Ja={toc:[]};function tl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ja,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}tl.isMDXComponent=!0;const el={toc:[]};function nl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},el,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the exporter configuration."))}nl.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ol,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}pl.isMDXComponent=!0;const rl={toc:[]};function sl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}sl.isMDXComponent=!0;const cl={toc:[]};function il(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}il.isMDXComponent=!0;const al={toc:[]};function ll(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},al,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ul,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}hl.isMDXComponent=!0;const fl={toc:[]};function kl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}kl.isMDXComponent=!0;const yl={toc:[]};function wl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}wl.isMDXComponent=!0;const Dl={toc:[]};function Ml(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Ml.isMDXComponent=!0;const Xl={toc:[]};function _l(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}_l.isMDXComponent=!0;const gl={toc:[]};function Tl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Tl.isMDXComponent=!0;const Cl={toc:[]};function xl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}xl.isMDXComponent=!0;const vl={toc:[]};function Ll(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Ll.isMDXComponent=!0;const Zl={toc:[]};function bl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}bl.isMDXComponent=!0;const Nl={toc:[]};function zl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}zl.isMDXComponent=!0;const Al={toc:[]};function Wl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Al,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Wl.isMDXComponent=!0;const Il={toc:[]};function Rl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Il,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Rl.isMDXComponent=!0;const Pl={toc:[]};function Sl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Sl.isMDXComponent=!0;const Ol={toc:[]};function El(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ol,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}El.isMDXComponent=!0;const Bl={toc:[]};function Gl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an entry in the meta file."))}Gl.isMDXComponent=!0;const Vl={toc:[]};function Ul(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Ul.isMDXComponent=!0;const Fl={toc:[]};function ql(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}ql.isMDXComponent=!0;const jl={toc:[]};function Yl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Yl.isMDXComponent=!0;const Hl={toc:[]};function Ql(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Ql.isMDXComponent=!0;const $l={toc:[]};function Kl(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$l,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Kl.isMDXComponent=!0;const Jl={toc:[]};function tu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tu.isMDXComponent=!0;const eu={toc:[]};function nu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}nu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ou,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}pu.isMDXComponent=!0;const ru={toc:[]};function su(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ru,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}su.isMDXComponent=!0;const cu={toc:[]};function iu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}iu.isMDXComponent=!0;const au={toc:[]};function lu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},au,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},du,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}hu.isMDXComponent=!0;const fu={toc:[]};function ku(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}ku.isMDXComponent=!0;const yu={toc:[]};function wu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}wu.isMDXComponent=!0;const Du={toc:[]};function Mu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Du,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Mu.isMDXComponent=!0;const Xu={toc:[]};function _u(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}_u.isMDXComponent=!0;const gu={toc:[]};function Tu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Tu.isMDXComponent=!0;const Cu={toc:[]};function xu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}xu.isMDXComponent=!0;const vu={toc:[]};function Lu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Lu.isMDXComponent=!0;const Zu={toc:[]};function bu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type used to store this field in the meta\nfile."))}bu.isMDXComponent=!0;const Nu={toc:[]};function zu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime type of this field."))}zu.isMDXComponent=!0;const Au={toc:[]};function Wu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Au,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a number stored in a meta file."))}Wu.isMDXComponent=!0;const Iu={toc:[]};function Ru(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Ru.isMDXComponent=!0;const Pu={toc:[]};function Su(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Su.isMDXComponent=!0;const Ou={toc:[]};function Eu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ou,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Eu.isMDXComponent=!0;const Bu={toc:[]};function Gu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Gu.isMDXComponent=!0;const Vu={toc:[]};function Uu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Uu.isMDXComponent=!0;const Fu={toc:[]};function qu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}qu.isMDXComponent=!0;const ju={toc:[]};function Yu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ju,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Yu.isMDXComponent=!0;const Hu={toc:[]};function Qu(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Qu.isMDXComponent=!0;const $u={toc:[]};function Ku(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Ku.isMDXComponent=!0;const Ju={toc:[]};function tm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ju,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}tm.isMDXComponent=!0;const em={toc:[]};function nm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},em,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}nm.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},om,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}pm.isMDXComponent=!0;const rm={toc:[]};function sm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}sm.isMDXComponent=!0;const cm={toc:[]};function im(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}im.isMDXComponent=!0;const am={toc:[]};function lm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},am,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},um,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}hm.isMDXComponent=!0;const fm={toc:[]};function km(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}km.isMDXComponent=!0;const ym={toc:[]};function wm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ym,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}wm.isMDXComponent=!0;const Dm={toc:[]};function Mm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Mm.isMDXComponent=!0;const Xm={toc:[]};function _m(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Range is an array with two elements denoting the beginning and end of a\nrange, respectively."))}_m.isMDXComponent=!0;const gm={toc:[]};function Tm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a range stored in a meta file."))}Tm.isMDXComponent=!0;const Cm={toc:[]};function xm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}xm.isMDXComponent=!0;const vm={toc:[]};function Lm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Lm.isMDXComponent=!0;const Zm={toc:[]};function bm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bm.isMDXComponent=!0;const Nm={toc:[]};function zm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zm.isMDXComponent=!0;const Am={toc:[]};function Wm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Am,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Wm.isMDXComponent=!0;const Im={toc:[]};function Rm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Im,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Rm.isMDXComponent=!0;const Pm={toc:[]};function Sm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Sm.isMDXComponent=!0;const Om={toc:[]};function Em(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Om,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Em.isMDXComponent=!0;const Bm={toc:[]};function Gm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Gm.isMDXComponent=!0;const Vm={toc:[]};function Um(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Um.isMDXComponent=!0;const Fm={toc:[]};function qm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}qm.isMDXComponent=!0;const jm={toc:[]};function Ym(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Ym.isMDXComponent=!0;const Hm={toc:[]};function Qm(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Qm.isMDXComponent=!0;const $m={toc:[]};function Km(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$m,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Km.isMDXComponent=!0;const Jm={toc:[]};function td(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}td.isMDXComponent=!0;const ed={toc:[]};function nd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ed,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}nd.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},od,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}pd.isMDXComponent=!0;const rd={toc:[]};function sd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sd.isMDXComponent=!0;const cd={toc:[]};function id(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}id.isMDXComponent=!0;const ad={toc:[]};function ld(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ad,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ud,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This helper method applies additional validation to the range, preventing\nit from overflowing the timeline."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given range from frames to seconds and update this field."))}hd.isMDXComponent=!0;const fd={toc:[]};function kd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The beginning of the range."))}kd.isMDXComponent=!0;const yd={toc:[]};function wd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}wd.isMDXComponent=!0;const Dd={toc:[]};function Md(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current duration in frames."))}Md.isMDXComponent=!0;const Xd={toc:[]};function _d(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current framerate."))}_d.isMDXComponent=!0;const gd={toc:[]};function Td(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a string stored in a meta file."))}Td.isMDXComponent=!0;const Cd={toc:[]};function xd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}xd.isMDXComponent=!0;const vd={toc:[]};function Ld(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Ld.isMDXComponent=!0;const Zd={toc:[]};function bd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}bd.isMDXComponent=!0;const Nd={toc:[]};function zd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}zd.isMDXComponent=!0;const Ad={toc:[]};function Wd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ad,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Wd.isMDXComponent=!0;const Id={toc:[]};function Rd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Id,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Rd.isMDXComponent=!0;const Pd={toc:[]};function Sd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Sd.isMDXComponent=!0;const Od={toc:[]};function Ed(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Od,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Ed.isMDXComponent=!0;const Bd={toc:[]};function Gd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Gd.isMDXComponent=!0;const Vd={toc:[]};function Ud(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Ud.isMDXComponent=!0;const Fd={toc:[]};function qd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}qd.isMDXComponent=!0;const jd={toc:[]};function Yd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Yd.isMDXComponent=!0;const Hd={toc:[]};function Qd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Qd.isMDXComponent=!0;const $d={toc:[]};function Kd(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Kd.isMDXComponent=!0;const Jd={toc:[]};function th(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}th.isMDXComponent=!0;const eh={toc:[]};function nh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}nh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}ph.isMDXComponent=!0;const rh={toc:[]};function sh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}sh.isMDXComponent=!0;const ch={toc:[]};function ih(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ch,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ih.isMDXComponent=!0;const ah={toc:[]};function lh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ah,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector stored in a meta file."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}hh.isMDXComponent=!0;const fh={toc:[]};function kh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}kh.isMDXComponent=!0;const yh={toc:[]};function wh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}wh.isMDXComponent=!0;const Dh={toc:[]};function Mh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Mh.isMDXComponent=!0;const Xh={toc:[]};function _h(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}_h.isMDXComponent=!0;const gh={toc:[]};function Th(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Th.isMDXComponent=!0;const Ch={toc:[]};function xh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ch,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}xh.isMDXComponent=!0;const vh={toc:[]};function Lh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Lh.isMDXComponent=!0;const Zh={toc:[]};function bh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}bh.isMDXComponent=!0;const Nh={toc:[]};function zh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}zh.isMDXComponent=!0;const Ah={toc:[]};function Wh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ah,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Wh.isMDXComponent=!0;const Ih={toc:[]};function Rh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ih,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Rh.isMDXComponent=!0;const Ph={toc:[]};function Sh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ph,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Sh.isMDXComponent=!0;const Oh={toc:[]};function Eh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Eh.isMDXComponent=!0;const Bh={toc:[]};function Gh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Gh.isMDXComponent=!0;const Vh={toc:[]};function Uh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Uh.isMDXComponent=!0;const Fh={toc:[]};function qh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}qh.isMDXComponent=!0;const jh={toc:[]};function Yh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Yh.isMDXComponent=!0;const Hh={toc:[]};function Qh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}Qh.isMDXComponent=!0;const $h={toc:[]};function Kh(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$h,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Kh.isMDXComponent=!0;const Jh={toc:[]};function tf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}tf.isMDXComponent=!0;const ef={toc:[]};function nf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ef,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}nf.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},of,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a runtime Motion Canvas plugin."))}pf.isMDXComponent=!0;const rf={toc:[]};function sf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide custom exporters for the project."))}sf.isMDXComponent=!0;const cf={toc:[]};function af(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the player instance right after it is initialized."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player instance."))}df.isMDXComponent=!0;const hf={toc:[]};function ff(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the presenter instance right after it is initialized."))}ff.isMDXComponent=!0;const kf={toc:[]};function yf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presenter instance."))}yf.isMDXComponent=!0;const wf={toc:[]};function Df(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the project instance right after it is initialized."))}Df.isMDXComponent=!0;const Mf={toc:[]};function Xf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}Xf.isMDXComponent=!0;const _f={toc:[]};function gf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_f,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the renderer instance right after it is initialized."))}gf.isMDXComponent=!0;const Tf={toc:[]};function Cf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The renderer instance."))}Cf.isMDXComponent=!0;const xf={toc:[]};function vf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Modify the project settings before the project is initialized."))}vf.isMDXComponent=!0;const Lf={toc:[]};function Zf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project settings."))}Zf.isMDXComponent=!0;const bf={toc:[]};function Nf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makePlugin({\n  name: 'my-custom-plugin',\n});\n")))}Nf.isMDXComponent=!0;const zf={toc:[]};function Af(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper function for exporting Motion Canvas plugins."))}Af.isMDXComponent=!0;const Wf={toc:[]};function If(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The plugin configuration."))}If.isMDXComponent=!0;const Rf={toc:[]};function Pf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abstract scene representations and related utilities."))}Pf.isMDXComponent=!0;const Sf={toc:[]};function Of(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Signifies the various stages of a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}Of.isMDXComponent=!0;const Ef={toc:[]};function Bf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ef,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs after a render ends."))}Bf.isMDXComponent=!0;const Gf={toc:[]};function Vf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}Vf.isMDXComponent=!0;const Uf={toc:[]};function Ff(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Ff.isMDXComponent=!0;const qf={toc:[]};function jf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}jf.isMDXComponent=!0;const Yf={toc:[]};function Hf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes the state of a scene."))}Hf.isMDXComponent=!0;const Qf={toc:[]};function $f(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}$f.isMDXComponent=!0;const Kf={toc:[]};function Jf(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished transitioning in."))}Jf.isMDXComponent=!0;const tk={toc:[]};function ek(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}ek.isMDXComponent=!0;const nk={toc:[]};function ok(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene is ready to transition out."))}ok.isMDXComponent=!0;const pk={toc:[]};function rk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoking ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}rk.isMDXComponent=!0;const sk={toc:[]};function ck(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished."))}ck.isMDXComponent=!0;const ik={toc:[]};function ak(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ik,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has just been created/reset."))}ak.isMDXComponent=!0;const lk={toc:[]};function uk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The default implementation of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.kt)("p",null,"Uses generators to control the animation."))}uk.isMDXComponent=!0;const mk={toc:[]};function dk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}dk.isMDXComponent=!0;const hk={toc:[]};function fk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}fk.isMDXComponent=!0;const kk={toc:[]};function yk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}yk.isMDXComponent=!0;const wk={toc:[]};function Dk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Dk.isMDXComponent=!0;const Mk={toc:[]};function Xk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Xk.isMDXComponent=!0;const _k={toc:[]};function gk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_k,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}gk.isMDXComponent=!0;const Tk={toc:[]};function Ck(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}Ck.isMDXComponent=!0;const xk={toc:[]};function vk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}vk.isMDXComponent=!0;const Lk={toc:[]};function Zk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}Zk.isMDXComponent=!0;const bk={toc:[]};function Nk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}Nk.isMDXComponent=!0;const zk={toc:[]};function Ak(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Ak.isMDXComponent=!0;const Wk={toc:[]};function Ik(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}Ik.isMDXComponent=!0;const Rk={toc:[]};function Pk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}Pk.isMDXComponent=!0;const Sk={toc:[]};function Ok(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Ok.isMDXComponent=!0;const Ek={toc:[]};function Bk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ek,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Bk.isMDXComponent=!0;const Gk={toc:[]};function Vk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Vk.isMDXComponent=!0;const Uk={toc:[]};function Fk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}Fk.isMDXComponent=!0;const qk={toc:[]};function jk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}jk.isMDXComponent=!0;const Yk={toc:[]};function Hk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}Hk.isMDXComponent=!0;const Qk={toc:[]};function $k(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}$k.isMDXComponent=!0;const Kk={toc:[]};function Jk(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}Jk.isMDXComponent=!0;const ty={toc:[]};function ey(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ty,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}ey.isMDXComponent=!0;const ny={toc:[]};function oy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ny,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}oy.isMDXComponent=!0;const py={toc:[]};function ry(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},py,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}ry.isMDXComponent=!0;const sy={toc:[]};function cy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}cy.isMDXComponent=!0;const iy={toc:[]};function ay(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}ay.isMDXComponent=!0;const ly={toc:[]};function uy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ly,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}uy.isMDXComponent=!0;const my={toc:[]};function dy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},my,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}dy.isMDXComponent=!0;const hy={toc:[]};function fy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}fy.isMDXComponent=!0;const ky={toc:[]};function yy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ky,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}yy.isMDXComponent=!0;const wy={toc:[]};function Dy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}Dy.isMDXComponent=!0;const My={toc:[]};function Xy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},My,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}Xy.isMDXComponent=!0;const _y={toc:[]};function gy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_y,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}gy.isMDXComponent=!0;const Ty={toc:[]};function Cy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ty,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}Cy.isMDXComponent=!0;const xy={toc:[]};function vy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}vy.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ly,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}Zy.isMDXComponent=!0;const by={toc:[]};function Ny(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},by,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Lifecycle events for ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Ny.isMDXComponent=!0;const zy={toc:[]};function Ay(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A random number generator based on\n",(0,s.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Ay.isMDXComponent=!0;const Wy={toc:[]};function Iy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random floats in the given range."))}Iy.isMDXComponent=!0;const Ry={toc:[]};function Py(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ry,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."))}Py.isMDXComponent=!0;const Sy={toc:[]};function Oy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}Oy.isMDXComponent=!0;const Ey={toc:[]};function By(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ey,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}By.isMDXComponent=!0;const Gy={toc:[]};function Vy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a random float from a gaussian distribution."))}Vy.isMDXComponent=!0;const Uy={toc:[]};function Fy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The mean of the distribution."))}Fy.isMDXComponent=!0;const qy={toc:[]};function jy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The standard deviation of the distribution."))}jy.isMDXComponent=!0;const Yy={toc:[]};function Hy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random integers in the given range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"}),(0,s.kt)("li",{parentName:"ul"})))}Hy.isMDXComponent=!0;const Qy={toc:[]};function $y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}$y.isMDXComponent=!0;const Ky={toc:[]};function Jy(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ky,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}Jy.isMDXComponent=!0;const tw={toc:[]};function ew(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}ew.isMDXComponent=!0;const nw={toc:[]};function ow(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random float in the given range."))}ow.isMDXComponent=!0;const pw={toc:[]};function rw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}rw.isMDXComponent=!0;const sw={toc:[]};function cw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}cw.isMDXComponent=!0;const iw={toc:[]};function aw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random integer in the given range."))}aw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}dw.isMDXComponent=!0;const hw={toc:[]};function fw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a new independent generator."))}fw.isMDXComponent=!0;const kw={toc:[]};function yw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}yw.isMDXComponent=!0;const ww={toc:[]};function Dw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ww,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the variable."))}Dw.isMDXComponent=!0;const Mw={toc:[]};function Xw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}Xw.isMDXComponent=!0;const _w={toc:[]};function gw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_w,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}gw.isMDXComponent=!0;const Tw={toc:[]};function Cw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset all stored signals."))}Cw.isMDXComponent=!0;const xw={toc:[]};function vw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update all signals with new project variable values."))}vw.isMDXComponent=!0;const Lw={toc:[]};function Zw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes cached information about the timing of a scene."))}Zw.isMDXComponent=!0;const bw={toc:[]};function Nw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a complete scene together with the meta file."))}Nw.isMDXComponent=!0;const zw={toc:[]};function Aw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}Aw.isMDXComponent=!0;const Ww={toc:[]};function Iw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ww,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}Iw.isMDXComponent=!0;const Rw={toc:[]};function Pw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}Pw.isMDXComponent=!0;const Sw={toc:[]};function Ow(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}Ow.isMDXComponent=!0;const Ew={toc:[]};function Bw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ew,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Bw.isMDXComponent=!0;const Gw={toc:[]};function Vw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Vw.isMDXComponent=!0;const Uw={toc:[]};function Fw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for the inspected element."))}Fw.isMDXComponent=!0;const qw={toc:[]};function jw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element for which to draw an overlay."))}jw.isMDXComponent=!0;const Yw={toc:[]};function Hw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Hw.isMDXComponent=!0;const Qw={toc:[]};function $w(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$w.isMDXComponent=!0;const Kw={toc:[]};function Jw(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}Jw.isMDXComponent=!0;const tD={toc:[]};function eD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the attributes of the inspected element."))}eD.isMDXComponent=!0;const nD={toc:[]};function oD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to inspect."))}oD.isMDXComponent=!0;const pD={toc:[]};function rD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a possible element to inspect at a given position."))}rD.isMDXComponent=!0;const sD={toc:[]};function cD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}cD.isMDXComponent=!0;const iD={toc:[]};function aD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}aD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transform the absolute mouse coordinates into the scene's coordinate system."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}dD.isMDXComponent=!0;const hD={toc:[]};function fD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}fD.isMDXComponent=!0;const kD={toc:[]};function yD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}yD.isMDXComponent=!0;const wD={toc:[]};function DD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the inspected element is still valid."))}DD.isMDXComponent=!0;const MD={toc:[]};function XD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to validate."))}XD.isMDXComponent=!0;const _D={toc:[]};function gD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_D,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}gD.isMDXComponent=!0;const TD={toc:[]};function CD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for scenes."))}CD.isMDXComponent=!0;const xD={toc:[]};function vD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}vD.isMDXComponent=!0;const LD={toc:[]};function ZD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}ZD.isMDXComponent=!0;const bD={toc:[]};function ND(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}ND.isMDXComponent=!0;const zD={toc:[]};function AD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}AD.isMDXComponent=!0;const WD={toc:[]};function ID(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}ID.isMDXComponent=!0;const RD={toc:[]};function PD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}PD.isMDXComponent=!0;const SD={toc:[]};function OD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}OD.isMDXComponent=!0;const ED={toc:[]};function BD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ED,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}BD.isMDXComponent=!0;const GD={toc:[]};function VD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}VD.isMDXComponent=!0;const UD={toc:[]};function FD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}FD.isMDXComponent=!0;const qD={toc:[]};function jD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}jD.isMDXComponent=!0;const YD={toc:[]};function HD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}HD.isMDXComponent=!0;const QD={toc:[]};function $D(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}$D.isMDXComponent=!0;const KD={toc:[]};function JD(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}JD.isMDXComponent=!0;const tM={toc:[]};function eM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}eM.isMDXComponent=!0;const nM={toc:[]};function oM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}oM.isMDXComponent=!0;const pM={toc:[]};function rM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}rM.isMDXComponent=!0;const sM={toc:[]};function cM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}cM.isMDXComponent=!0;const iM={toc:[]};function aM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."),(0,s.kt)("p",null,"Usually return ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}aM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}dM.isMDXComponent=!0;const hM={toc:[]};function fM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}fM.isMDXComponent=!0;const kM={toc:[]};function yM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}yM.isMDXComponent=!0;const wM={toc:[]};function DM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}DM.isMDXComponent=!0;const MM={toc:[]};function XM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}XM.isMDXComponent=!0;const _M={toc:[]};function gM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_M,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}gM.isMDXComponent=!0;const TM={toc:[]};function CM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}CM.isMDXComponent=!0;const xM={toc:[]};function vM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}vM.isMDXComponent=!0;const LM={toc:[]};function ZM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}ZM.isMDXComponent=!0;const bM={toc:[]};function NM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}NM.isMDXComponent=!0;const zM={toc:[]};function AM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}AM.isMDXComponent=!0;const WM={toc:[]};function IM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}IM.isMDXComponent=!0;const RM={toc:[]};function PM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}PM.isMDXComponent=!0;const SM={toc:[]};function OM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each class implementing the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}OM.isMDXComponent=!0;const EM={toc:[]};function BM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constructor used when creating new scenes."))}BM.isMDXComponent=!0;const GM={toc:[]};function VM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.kt)("inlineCode",{parentName:"a"},"config")),"."))}VM.isMDXComponent=!0;const UM={toc:[]};function FM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a scene exposed by scene files."))}FM.isMDXComponent=!0;const qM={toc:[]};function jM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}jM.isMDXComponent=!0;const YM={toc:[]};function HM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}HM.isMDXComponent=!0;const QM={toc:[]};function $M(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}$M.isMDXComponent=!0;const KM={toc:[]};function JM(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}JM.isMDXComponent=!0;const tX={toc:[]};function eX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A part of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}eX.isMDXComponent=!0;const nX={toc:[]};function oX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}oX.isMDXComponent=!0;const pX={toc:[]};function rX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}rX.isMDXComponent=!0;const sX={toc:[]};function cX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}cX.isMDXComponent=!0;const iX={toc:[]};function aX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}aX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents attributes of an inspected element."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}dX.isMDXComponent=!0;const hX={toc:[]};function fX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an element to inspect."))}fX.isMDXComponent=!0;const kX={toc:[]};function yX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the scene metadata."))}yX.isMDXComponent=!0;const wX={toc:[]};function DX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the scene metadata."))}DX.isMDXComponent=!0;const MX={toc:[]};function XX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}XX.isMDXComponent=!0;const _X={toc:[]};function gX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_X,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}gX.isMDXComponent=!0;const TX={toc:[]};function CX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}CX.isMDXComponent=!0;const xX={toc:[]};function vX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}vX.isMDXComponent=!0;const LX={toc:[]};function ZX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}ZX.isMDXComponent=!0;const bX={toc:[]};function NX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}NX.isMDXComponent=!0;const zX={toc:[]};function AX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}AX.isMDXComponent=!0;const WX={toc:[]};function IX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}IX.isMDXComponent=!0;const RX={toc:[]};function PX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}PX.isMDXComponent=!0;const SX={toc:[]};function OX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}OX.isMDXComponent=!0;const EX={toc:[]};function BX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}BX.isMDXComponent=!0;const GX={toc:[]};function VX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}VX.isMDXComponent=!0;const UX={toc:[]};function FX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}FX.isMDXComponent=!0;const qX={toc:[]};function jX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}jX.isMDXComponent=!0;const YX={toc:[]};function HX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}HX.isMDXComponent=!0;const QX={toc:[]};function $X(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}$X.isMDXComponent=!0;const KX={toc:[]};function JX(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}JX.isMDXComponent=!0;const t_={toc:[]};function e_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}e_.isMDXComponent=!0;const n_={toc:[]};function o_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}o_.isMDXComponent=!0;const p_={toc:[]};function r_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}r_.isMDXComponent=!0;const s_={toc:[]};function c_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}c_.isMDXComponent=!0;const i_={toc:[]};function a_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}a_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}d_.isMDXComponent=!0;const h_={toc:[]};function f_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}f_.isMDXComponent=!0;const k_={toc:[]};function y_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween back to the original value."))}y_.isMDXComponent=!0;const w_={toc:[]};function D_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}D_.isMDXComponent=!0;const M_={toc:[]};function X_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function of the tween."))}X_.isMDXComponent=!0;const __={toc:[]};function g_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},__,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function of the tween."))}g_.isMDXComponent=!0;const T_={toc:[]};function C_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback."))}C_.isMDXComponent=!0;const x_={toc:[]};function v_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}v_.isMDXComponent=!0;const L_={toc:[]};function Z_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given task."))}Z_.isMDXComponent=!0;const b_={toc:[]};function N_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator to run."))}N_.isMDXComponent=!0;const z_={toc:[]};function A_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween to the specified value."))}A_.isMDXComponent=!0;const W_={toc:[]};function I_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the specified duration."))}I_.isMDXComponent=!0;const R_={toc:[]};function P_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration to wait."))}P_.isMDXComponent=!0;const S_={toc:[]};function O_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread management."))}O_.isMDXComponent=!0;const E_={toc:[]};function B_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}B_.isMDXComponent=!0;const G_={toc:[]};function V_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A class representing an individual thread."))}V_.isMDXComponent=!0;const U_={toc:[]};function F_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}F_.isMDXComponent=!0;const q_={toc:[]};function j_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}j_.isMDXComponent=!0;const Y_={toc:[]};function H_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}H_.isMDXComponent=!0;const Q_={toc:[]};function $_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current time of this thread."))}$_.isMDXComponent=!0;const K_={toc:[]};function J_(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The next value to be passed to the wrapped generator."))}J_.isMDXComponent=!0;const tg={toc:[]};function eg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}eg.isMDXComponent=!0;const ng={toc:[]};function og(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ng,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}og.isMDXComponent=!0;const pg={toc:[]};function rg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The fixed time of this thread."))}rg.isMDXComponent=!0;const sg={toc:[]};function cg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress the wrapped generator once."))}cg.isMDXComponent=!0;const ig={toc:[]};function ag(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ig,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the thread for the next update cycle."))}ag.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delta time of the next cycle."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a normal function that returns a generator."))}dg.isMDXComponent=!0;const hg={toc:[]};function fg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.kt)("p",null,"Progress to the next frame:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.kt)("p",null,"Run another generator synchronously:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.kt)("p",null,"Run another generator concurrently:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.kt)("p",null,"Await a Promise:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}fg.isMDXComponent=!0;const kg={toc:[]};function yg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}yg.isMDXComponent=!0;const wg={toc:[]};function Dg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Cancel all listed tasks."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Dg.isMDXComponent=!0;const Mg={toc:[]};function Xg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to cancel."))}Xg.isMDXComponent=!0;const _g={toc:[]};function gg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_g,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}gg.isMDXComponent=!0;const Tg={toc:[]};function Cg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}Cg.isMDXComponent=!0;const xg={toc:[]};function vg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}vg.isMDXComponent=!0;const Lg={toc:[]};function Zg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible thread ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Zg.isMDXComponent=!0;const bg={toc:[]};function Ng(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}Ng.isMDXComponent=!0;const zg={toc:[]};function Ag(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}Ag.isMDXComponent=!0;const Wg={toc:[]};function Ig(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Ig.isMDXComponent=!0;const Rg={toc:[]};function Pg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}Pg.isMDXComponent=!0;const Sg={toc:[]};function Og(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until listed tasks are finished."))}Og.isMDXComponent=!0;const Eg={toc:[]};function Bg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}Bg.isMDXComponent=!0;const Gg={toc:[]};function Vg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}Vg.isMDXComponent=!0;const Ug={toc:[]};function Fg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ug,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"From the perspective of the external generator, ",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}Fg.isMDXComponent=!0;const qg={toc:[]};function jg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}jg.isMDXComponent=!0;const Yg={toc:[]};function Hg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a context in which generators can be run concurrently."))}Hg.isMDXComponent=!0;const Qg={toc:[]};function $g(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the generator to run."))}$g.isMDXComponent=!0;const Kg={toc:[]};function Jg(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}Jg.isMDXComponent=!0;const tT={toc:[]};function eT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transitions between scenes."))}eT.isMDXComponent=!0;const nT={toc:[]};function oT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that fades between the scenes."))}oT.isMDXComponent=!0;const pT={toc:[]};function rT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}rT.isMDXComponent=!0;const sT={toc:[]};function cT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene in the given direction."))}cT.isMDXComponent=!0;const iT={toc:[]};function aT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The direction in which to slide."))}aT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene towards the given origin."))}dT.isMDXComponent=!0;const hT={toc:[]};function fT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin towards which to slide."))}fT.isMDXComponent=!0;const kT={toc:[]};function yT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}yT.isMDXComponent=!0;const wT={toc:[]};function DT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}DT.isMDXComponent=!0;const MT={toc:[]};function XT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the current scene is rendered."))}XT.isMDXComponent=!0;const _T={toc:[]};function gT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_T,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the previous scene is rendered."))}gT.isMDXComponent=!0;const TT={toc:[]};function CT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}CT.isMDXComponent=!0;const xT={toc:[]};function vT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area on which to zoom in."))}vT.isMDXComponent=!0;const LT={toc:[]};function ZT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}ZT.isMDXComponent=!0;const bT={toc:[]};function NT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}NT.isMDXComponent=!0;const zT={toc:[]};function AT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area from which to zoom out."))}AT.isMDXComponent=!0;const WT={toc:[]};function IT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}IT.isMDXComponent=!0;const RT={toc:[]};function PT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolation and timing of tweens."))}PT.isMDXComponent=!0;const ST={toc:[]};function OT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ST,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any old key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"})))}OT.isMDXComponent=!0;const ET={toc:[]};function BT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ET,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}BT.isMDXComponent=!0;const GT={toc:[]};function VT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}VT.isMDXComponent=!0;const UT={toc:[]};function FT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}FT.isMDXComponent=!0;const qT={toc:[]};function jT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}jT.isMDXComponent=!0;const YT={toc:[]};function HT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}HT.isMDXComponent=!0;const QT={toc:[]};function $T(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}$T.isMDXComponent=!0;const KT={toc:[]};function JT(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}JT.isMDXComponent=!0;const tC={toc:[]};function eC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}eC.isMDXComponent=!0;const nC={toc:[]};function oC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}oC.isMDXComponent=!0;const pC={toc:[]};function rC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}rC.isMDXComponent=!0;const sC={toc:[]};function cC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Complex types used in animations."))}cC.isMDXComponent=!0;const iC={toc:[]};function aC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}aC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the determinant of the matrix."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}dC.isMDXComponent=!0;const hC={toc:[]};function fC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}fC.isMDXComponent=!0;const kC={toc:[]};function yC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the inverse of the matrix."))}yC.isMDXComponent=!0;const wC={toc:[]};function DC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}DC.isMDXComponent=!0;const MC={toc:[]};function XC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}XC.isMDXComponent=!0;const _C={toc:[]};function gC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_C,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the provided matrix to this matrix."))}gC.isMDXComponent=!0;const TC={toc:[]};function CC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to add"))}CC.isMDXComponent=!0;const xC={toc:[]};function vC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}vC.isMDXComponent=!0;const LC={toc:[]};function ZC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}ZC.isMDXComponent=!0;const bC={toc:[]};function NC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the component vector to retrieve."))}NC.isMDXComponent=!0;const zC={toc:[]};function AC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}AC.isMDXComponent=!0;const WC={toc:[]};function IC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}IC.isMDXComponent=!0;const RC={toc:[]};function PC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}PC.isMDXComponent=!0;const SC={toc:[]};function OC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to multiply with"))}OC.isMDXComponent=!0;const EC={toc:[]};function BC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}BC.isMDXComponent=!0;const GC={toc:[]};function VC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}VC.isMDXComponent=!0;const UC={toc:[]};function FC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to scale each term"))}FC.isMDXComponent=!0;const qC={toc:[]};function jC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}jC.isMDXComponent=!0;const YC={toc:[]};function HC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}HC.isMDXComponent=!0;const QC={toc:[]};function $C(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}$C.isMDXComponent=!0;const KC={toc:[]};function JC(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate the matrix."))}JC.isMDXComponent=!0;const tx={toc:[]};function ex(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the angle is provided in degrees."))}ex.isMDXComponent=!0;const nx={toc:[]};function ox(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}ox.isMDXComponent=!0;const px={toc:[]};function rx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},px,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}rx.isMDXComponent=!0;const sx={toc:[]};function cx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the row to retrieve."))}cx.isMDXComponent=!0;const ix={toc:[]};function ax(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ix,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}ax.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scale the x and y component vectors of the matrix."))}dx.isMDXComponent=!0;const hx={toc:[]};function fx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The factor by which to scale the matrix"))}fx.isMDXComponent=!0;const kx={toc:[]};function yx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}yx.isMDXComponent=!0;const wx={toc:[]};function Dx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}Dx.isMDXComponent=!0;const Mx={toc:[]};function Xx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subtract the provided matrix from this matrix."))}Xx.isMDXComponent=!0;const _x={toc:[]};function gx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_x,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to subract"))}gx.isMDXComponent=!0;const Tx={toc:[]};function Cx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Cx.isMDXComponent=!0;const xx={toc:[]};function vx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}vx.isMDXComponent=!0;const Lx={toc:[]};function Zx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}Zx.isMDXComponent=!0;const bx={toc:[]};function Nx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector by which to translate the matrix"))}Nx.isMDXComponent=!0;const zx={toc:[]};function Ax(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector."))}Ax.isMDXComponent=!0;const Wx={toc:[]};function Ix(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}Ix.isMDXComponent=!0;const Rx={toc:[]};function Px(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}Px.isMDXComponent=!0;const Sx={toc:[]};function Ox(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}Ox.isMDXComponent=!0;const Ex={toc:[]};function Bx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ex,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}Bx.isMDXComponent=!0;const Gx={toc:[]};function Vx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are equal to each other."))}Vx.isMDXComponent=!0;const Ux={toc:[]};function Fx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ux,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}Fx.isMDXComponent=!0;const qx={toc:[]};function jx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The allowed error threshold when comparing the vectors."))}jx.isMDXComponent=!0;const Yx={toc:[]};function Hx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}Hx.isMDXComponent=!0;const Qx={toc:[]};function $x(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are exactly equal to each other."))}$x.isMDXComponent=!0;const Kx={toc:[]};function Jx(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}Jx.isMDXComponent=!0;const tv={toc:[]};function ev(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotates the vector around a point by the provided angle."))}ev.isMDXComponent=!0;const nv={toc:[]};function ov(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate in degrees."))}ov.isMDXComponent=!0;const pv={toc:[]};function rv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}rv.isMDXComponent=!0;const sv={toc:[]};function cv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Helper function to create a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#static-polarLerp"},(0,s.kt)("inlineCode",{parentName:"a"},"polarLerp"))," interpolation\nfunction with additional parameters."))}cv.isMDXComponent=!0;const iv={toc:[]};function av(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the point should get rotated\ncounterclockwise."))}av.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}dv.isMDXComponent=!0;const hv={toc:[]};function fv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}fv.isMDXComponent=!0;const kv={toc:[]};function yv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}yv.isMDXComponent=!0;const wv={toc:[]};function Dv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}Dv.isMDXComponent=!0;const Mv={toc:[]};function Xv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This function is useful when used in conjunction with ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"rotate"))," to\nanimate an object's position on a circular arc (see examples)."))}Xv.isMDXComponent=!0;const _v={toc:[]};function gv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_v,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Animating an object in a circle around the origin"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.polarLerp\n);\n")))}gv.isMDXComponent=!0;const Tv={toc:[]};function Cv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotating an object around the point ",(0,s.kt)("inlineCode",{parentName:"p"},"[-200, 100]")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180, [-200, 100]),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(false, [-200, 100]),\n);\n")))}Cv.isMDXComponent=!0;const xv={toc:[]};function vv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotating an object counterclockwise around the origin"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(true),\n);\n")))}vv.isMDXComponent=!0;const Lv={toc:[]};function Zv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolates between two vectors on the polar plane by interpolating\nthe angles and magnitudes of the vectors individually."))}Zv.isMDXComponent=!0;const bv={toc:[]};function Nv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting vector."))}Nv.isMDXComponent=!0;const zv={toc:[]};function Av(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The target vector."))}Av.isMDXComponent=!0;const Wv={toc:[]};function Iv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t-value of the interpolation."))}Iv.isMDXComponent=!0;const Rv={toc:[]};function Pv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the vector should get rotated\ncounterclockwise. Defaults to ",(0,s.kt)("inlineCode",{parentName:"p"},"false"),"."))}Pv.isMDXComponent=!0;const Sv={toc:[]};function Ov(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}Ov.isMDXComponent=!0;const Ev={toc:[]};function Bv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ev,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}Bv.isMDXComponent=!0;const Gv={toc:[]};function Vv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}Vv.isMDXComponent=!0;const Uv={toc:[]};function Fv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}Fv.isMDXComponent=!0;const qv={toc:[]};function jv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same class as the one created by\n",(0,s.kt)("a",{parentName:"p",href:"https://gka.github.io/chroma.js/"},(0,s.kt)("inlineCode",{parentName:"a"},"chroma.js")),". Check out their\ndocumentation for more information on how to use it."))}jv.isMDXComponent=!0;const Yv={toc:[]};function Hv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color."))}Hv.isMDXComponent=!0;const Qv={toc:[]};function $v(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}$v.isMDXComponent=!0;const Kv={toc:[]};function Jv(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given origin to a vector representing its offset."))}Jv.isMDXComponent=!0;const tL={toc:[]};function eL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin to convert."))}eL.isMDXComponent=!0;const nL={toc:[]};function oL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"General utilities and helper functions."))}oL.isMDXComponent=!0;const pL={toc:[]};function rL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}rL.isMDXComponent=!0;const sL={toc:[]};function cL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}cL.isMDXComponent=!0;const iL={toc:[]};function aL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}aL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of the transformed references."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Maps the references in this group to a new array."))}dL.isMDXComponent=!0;const hL={toc:[]};function fL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to transform each reference."))}fL.isMDXComponent=!0;const kL={toc:[]};function yL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}yL.isMDXComponent=!0;const wL={toc:[]};function DL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting degrees to radians"))}DL.isMDXComponent=!0;const ML={toc:[]};function XL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ML,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}XL.isMDXComponent=!0;const _L={toc:[]};function gL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_L,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting radians to degrees"))}gL.isMDXComponent=!0;const TL={toc:[]};function CL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned object is both an array and a reference that can be passed\ndirectly to the ",(0,s.kt)("inlineCode",{parentName:"p"},"ref")," property of a node."))}CL.isMDXComponent=!0;const xL={toc:[]};function vL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefArray<Txt>();\n\nview.add(['A', 'B'].map(text => <Txt ref={labels}>{text}</Txt>));\nview.add(<Txt ref={labels}>C</Txt>);\n\n// accessing the references individually:\nyield* labels[0].text('A changes', 0.3);\nyield* labels[1].text('B changes', 0.3);\nyield* labels[2].text('C changes', 0.3);\n\n// accessing all references at once:\nyield* all(...labels.map(label => label.fill('white', 0.3)));\n")))}vL.isMDXComponent=!0;const LL={toc:[]};function ZL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array of references."))}ZL.isMDXComponent=!0;const bL={toc:[]};function NL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned object lets you easily create multiple references to the same\ntype without initializing them individually."),(0,s.kt)("p",null,"You can retrieve references by accessing the object's properties. If the\nreference for a given property does not exist, it will be created\nautomatically."))}NL.isMDXComponent=!0;const zL={toc:[]};function AL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefMap<Txt>();\n\nview.add(\n  <>\n    <Txt ref={labels.a}>A</Txt>\n    <Txt ref={labels.b}>B</Txt>\n    <Txt ref={labels.c}>C</Txt>\n  </>,\n);\n\n// accessing the references individually:\nyield* labels.a().text('A changes', 0.3);\nyield* labels.b().text('B changes', 0.3);\nyield* labels.c().text('C changes', 0.3);\n\n// checking if the given reference exists:\nif ('d' in labels) {\n  yield* labels.d().text('D changes', 0.3);\n}\n\n// accessing all references at once:\nyield* all(...labels.mapRefs(label => label.fill('white', 0.3)));\n")))}AL.isMDXComponent=!0;const WL={toc:[]};function IL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a group of references."))}IL.isMDXComponent=!0;const RL={toc:[]};function PL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is a shortcut for calling ",(0,s.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}PL.isMDXComponent=!0;const SL={toc:[]};function OL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}OL.isMDXComponent=!0;const EL={toc:[]};function BL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Logs a debug message with an arbitrary payload."))}BL.isMDXComponent=!0;const GL={toc:[]};function VL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The payload to log"))}VL.isMDXComponent=!0;const UL={toc:[]};function FL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the given function as deprecated."))}FL.isMDXComponent=!0;const qL={toc:[]};function jL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to deprecate."))}jL.isMDXComponent=!0;const YL={toc:[]};function HL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log message."))}HL.isMDXComponent=!0;const QL={toc:[]};function $L(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The optional log remarks."))}$L.isMDXComponent=!0;const KL={toc:[]};function JL(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}JL.isMDXComponent=!0;const tZ={toc:[]};function eZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the current scene as ready to transition out."))}eZ.isMDXComponent=!0;const nZ={toc:[]};function oZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function rZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}rZ.isMDXComponent=!0;const sZ={toc:[]};function cZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}cZ.isMDXComponent=!0;const iZ={toc:[]};function aZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}aZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The length of the array."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}dZ.isMDXComponent=!0;const hZ={toc:[]};function fZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}fZ.isMDXComponent=!0;const kZ={toc:[]};function yZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}yZ.isMDXComponent=!0;const wZ={toc:[]};function DZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}DZ.isMDXComponent=!0;const MZ={toc:[]};function XZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}XZ.isMDXComponent=!0;const _Z={toc:[]};function gZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Z,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}gZ.isMDXComponent=!0;const TZ={toc:[]};function CZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}CZ.isMDXComponent=!0;const xZ={toc:[]};function vZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}vZ.isMDXComponent=!0;const LZ={toc:[]};function ZZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to increment or decrement."))}ZZ.isMDXComponent=!0;const bZ={toc:[]};function NZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}NZ.isMDXComponent=!0;const zZ={toc:[]};function AZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context before render."))}AZ.isMDXComponent=!0;const WZ={toc:[]};function IZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}IZ.isMDXComponent=!0;const RZ={toc:[]};function PZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context after render."))}PZ.isMDXComponent=!0;const SZ={toc:[]};function OZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}OZ.isMDXComponent=!0;const EZ={toc:[]};function BZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}BZ.isMDXComponent=!0;const GZ={toc:[]};function VZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the event in seconds."))}VZ.isMDXComponent=!0;const UZ={toc:[]};function FZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Register a time event and get its duration in seconds."))}FZ.isMDXComponent=!0;const qZ={toc:[]};function jZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the event."))}jZ.isMDXComponent=!0;const YZ={toc:[]};function HZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the playback status."))}HZ.isMDXComponent=!0;const QZ={toc:[]};function $Z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the current scene."))}$Z.isMDXComponent=!0;const KZ={toc:[]};function JZ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the given seed."))}JZ.isMDXComponent=!0;const tb={toc:[]};function eb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seed for the generator."))}eb.isMDXComponent=!0;const nb={toc:[]};function ob(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}ob.isMDXComponent=!0;const pb={toc:[]};function rb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current scene."))}rb.isMDXComponent=!0;const sb={toc:[]};function cb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current thread."))}cb.isMDXComponent=!0;const ib={toc:[]};function ab(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ib,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}ab.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real time since the start of the animation."))}db.isMDXComponent=!0;const hb={toc:[]};function fb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This rewrites a remote url like ",(0,s.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}fb.isMDXComponent=!0;const kb={toc:[]};function yb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Route the given url through a local proxy."))}yb.isMDXComponent=!0;const wb={toc:[]};function Db(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Db.isMDXComponent=!0;const Mb={toc:[]};function Xb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Xb.isMDXComponent=!0;const _b={toc:[]};function gb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_b,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}gb.isMDXComponent=!0;const Tb={toc:[]};function Cb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Cb.isMDXComponent=!0;const xb={toc:[]};function vb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}vb.isMDXComponent=!0;const Lb={toc:[]};function Zb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Zb.isMDXComponent=!0;const bb={toc:[]};function Nb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Nb.isMDXComponent=!0;const zb={toc:[]};function Ab(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Ab.isMDXComponent=!0;const Wb={toc:[]};function Ib(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Ib.isMDXComponent=!0;const Rb={toc:[]};function Pb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Pb.isMDXComponent=!0;const Sb={toc:[]};function Ob(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Ob.isMDXComponent=!0;const Eb={toc:[]};function Bb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Bb.isMDXComponent=!0;const Gb={toc:[]};function Vb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Vb.isMDXComponent=!0;const Ub={toc:[]};function Fb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ub,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Fb.isMDXComponent=!0;const qb={toc:[]};function jb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}jb.isMDXComponent=!0;const Yb={toc:[]};function Hb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Hb.isMDXComponent=!0;const Qb={toc:[]};function $b(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}$b.isMDXComponent=!0;const Kb={toc:[]};function Jb(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Jb.isMDXComponent=!0;const tN={toc:[]};function eN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}eN.isMDXComponent=!0;const nN={toc:[]};function oN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}oN.isMDXComponent=!0;const pN={toc:[]};function rN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}rN.isMDXComponent=!0;const sN={toc:[]};function cN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}cN.isMDXComponent=!0;const iN={toc:[]};function aN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}aN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}dN.isMDXComponent=!0;const hN={toc:[]};function fN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}fN.isMDXComponent=!0;const kN={toc:[]};function yN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}yN.isMDXComponent=!0;const wN={toc:[]};function DN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}DN.isMDXComponent=!0;const MN={toc:[]};function XN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}XN.isMDXComponent=!0;const _N={toc:[]};function gN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_N,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}gN.isMDXComponent=!0;const TN={toc:[]};function CN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}CN.isMDXComponent=!0;const xN={toc:[]};function vN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}vN.isMDXComponent=!0;const LN={toc:[]};function ZN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}ZN.isMDXComponent=!0;const bN={toc:[]};function NN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}NN.isMDXComponent=!0;const zN={toc:[]};function AN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}AN.isMDXComponent=!0;const WN={toc:[]};function IN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}IN.isMDXComponent=!0;const RN={toc:[]};function PN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}PN.isMDXComponent=!0;const SN={toc:[]};function ON(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}ON.isMDXComponent=!0;const EN={toc:[]};function BN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}BN.isMDXComponent=!0;const GN={toc:[]};function VN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}VN.isMDXComponent=!0;const UN={toc:[]};function FN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}FN.isMDXComponent=!0;const qN={toc:[]};function jN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}jN.isMDXComponent=!0;const YN={toc:[]};function HN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}HN.isMDXComponent=!0;const QN={toc:[]};function $N(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}$N.isMDXComponent=!0;const KN={toc:[]};function JN(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}JN.isMDXComponent=!0;const tz={toc:[]};function ez(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}ez.isMDXComponent=!0;const nz={toc:[]};function oz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}oz.isMDXComponent=!0;const pz={toc:[]};function rz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}rz.isMDXComponent=!0;const sz={toc:[]};function cz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}cz.isMDXComponent=!0;const iz={toc:[]};function az(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}az.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}dz.isMDXComponent=!0;const hz={toc:[]};function fz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}fz.isMDXComponent=!0;const kz={toc:[]};function yz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}yz.isMDXComponent=!0;const wz={toc:[]};function Dz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Dz.isMDXComponent=!0;const Mz={toc:[]};function Xz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Xz.isMDXComponent=!0;const _z={toc:[]};function gz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_z,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}gz.isMDXComponent=!0;const Tz={toc:[]};function Cz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Cz.isMDXComponent=!0;const xz={toc:[]};function vz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}vz.isMDXComponent=!0;const Lz={toc:[]};function Zz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Zz.isMDXComponent=!0;const bz={toc:[]};function Nz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Nz.isMDXComponent=!0;const zz={toc:[]};function Az(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Az.isMDXComponent=!0;const Wz={toc:[]};function Iz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Iz.isMDXComponent=!0;const Rz={toc:[]};function Pz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Pz.isMDXComponent=!0;const Sz={toc:[]};function Oz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Oz.isMDXComponent=!0;const Ez={toc:[]};function Bz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ez,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Bz.isMDXComponent=!0;const Gz={toc:[]};function Vz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Vz.isMDXComponent=!0;const Uz={toc:[]};function Fz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Fz.isMDXComponent=!0;const qz={toc:[]};function jz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}jz.isMDXComponent=!0;const Yz={toc:[]};function Hz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Hz.isMDXComponent=!0;const Qz={toc:[]};function $z(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}$z.isMDXComponent=!0;const Kz={toc:[]};function Jz(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Jz.isMDXComponent=!0;const tA={toc:[]};function eA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}eA.isMDXComponent=!0;const nA={toc:[]};function oA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}oA.isMDXComponent=!0;const pA={toc:[]};function rA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}rA.isMDXComponent=!0;const sA={toc:[]};function cA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}cA.isMDXComponent=!0;const iA={toc:[]};function aA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}aA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}dA.isMDXComponent=!0;const hA={toc:[]};function fA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}fA.isMDXComponent=!0;const kA={toc:[]};function yA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}yA.isMDXComponent=!0;const wA={toc:[]};function DA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}DA.isMDXComponent=!0;const MA={toc:[]};function XA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}XA.isMDXComponent=!0;const _A={toc:[]};function gA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_A,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}gA.isMDXComponent=!0;const TA={toc:[]};function CA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}CA.isMDXComponent=!0;const xA={toc:[]};function vA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}vA.isMDXComponent=!0;const LA={toc:[]};function ZA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}ZA.isMDXComponent=!0;const bA={toc:[]};function NA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}NA.isMDXComponent=!0;const zA={toc:[]};function AA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}AA.isMDXComponent=!0;const WA={toc:[]};function IA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}IA.isMDXComponent=!0;const RA={toc:[]};function PA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}PA.isMDXComponent=!0;const SA={toc:[]};function OA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}OA.isMDXComponent=!0;const EA={toc:[]};function BA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}BA.isMDXComponent=!0;const GA={toc:[]};function VA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}VA.isMDXComponent=!0;const UA={toc:[]};function FA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}FA.isMDXComponent=!0;const qA={toc:[]};function jA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}jA.isMDXComponent=!0;const YA={toc:[]};function HA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}HA.isMDXComponent=!0;const QA={toc:[]};function $A(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}$A.isMDXComponent=!0;const KA={toc:[]};function JA(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}JA.isMDXComponent=!0;const tW={toc:[]};function eW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}eW.isMDXComponent=!0;const nW={toc:[]};function oW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}oW.isMDXComponent=!0;const pW={toc:[]};function rW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}rW.isMDXComponent=!0;const sW={toc:[]};function cW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}cW.isMDXComponent=!0;const iW={toc:[]};function aW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}aW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}dW.isMDXComponent=!0;const hW={toc:[]};function fW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}fW.isMDXComponent=!0;const kW={toc:[]};function yW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}yW.isMDXComponent=!0;const wW={toc:[]};function DW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}DW.isMDXComponent=!0;const MW={toc:[]};function XW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}XW.isMDXComponent=!0;const _W={toc:[]};function gW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_W,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}gW.isMDXComponent=!0;const TW={toc:[]};function CW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}CW.isMDXComponent=!0;const xW={toc:[]};function vW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}vW.isMDXComponent=!0;const LW={toc:[]};function ZW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}ZW.isMDXComponent=!0;const bW={toc:[]};function NW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}NW.isMDXComponent=!0;const zW={toc:[]};function AW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}AW.isMDXComponent=!0;const WW={toc:[]};function IW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}IW.isMDXComponent=!0;const RW={toc:[]};function PW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}PW.isMDXComponent=!0;const SW={toc:[]};function OW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}OW.isMDXComponent=!0;const EW={toc:[]};function BW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}BW.isMDXComponent=!0;const GW={toc:[]};function VW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}VW.isMDXComponent=!0;const UW={toc:[]};function FW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}FW.isMDXComponent=!0;const qW={toc:[]};function jW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}jW.isMDXComponent=!0;const YW={toc:[]};function HW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}HW.isMDXComponent=!0;const QW={toc:[]};function $W(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}$W.isMDXComponent=!0;const KW={toc:[]};function JW(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}JW.isMDXComponent=!0;const tI={toc:[]};function eI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}eI.isMDXComponent=!0;const nI={toc:[]};function oI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}oI.isMDXComponent=!0;const pI={toc:[]};function rI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}rI.isMDXComponent=!0;const sI={toc:[]};function cI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}cI.isMDXComponent=!0;const iI={toc:[]};function aI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}aI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}dI.isMDXComponent=!0;const hI={toc:[]};function fI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}fI.isMDXComponent=!0;const kI={toc:[]};function yI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}yI.isMDXComponent=!0;const wI={toc:[]};function DI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}DI.isMDXComponent=!0;const MI={toc:[]};function XI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}XI.isMDXComponent=!0;const _I={toc:[]};function gI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_I,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}gI.isMDXComponent=!0;const TI={toc:[]};function CI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}CI.isMDXComponent=!0;const xI={toc:[]};function vI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}vI.isMDXComponent=!0;const LI={toc:[]};function ZI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}ZI.isMDXComponent=!0;const bI={toc:[]};function NI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}NI.isMDXComponent=!0;const zI={toc:[]};function AI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}AI.isMDXComponent=!0;const WI={toc:[]};function II(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}II.isMDXComponent=!0;const RI={toc:[]};function PI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}PI.isMDXComponent=!0;const SI={toc:[]};function OI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}OI.isMDXComponent=!0;const EI={toc:[]};function BI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}BI.isMDXComponent=!0;const GI={toc:[]};function VI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}VI.isMDXComponent=!0;const UI={toc:[]};function FI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}FI.isMDXComponent=!0;const qI={toc:[]};function jI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}jI.isMDXComponent=!0;const YI={toc:[]};function HI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}HI.isMDXComponent=!0;const QI={toc:[]};function $I(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}$I.isMDXComponent=!0;const KI={toc:[]};function JI(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}JI.isMDXComponent=!0;const tR={toc:[]};function eR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}eR.isMDXComponent=!0;const nR={toc:[]};function oR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}oR.isMDXComponent=!0;const pR={toc:[]};function rR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}rR.isMDXComponent=!0;const sR={toc:[]};function cR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}cR.isMDXComponent=!0;const iR={toc:[]};function aR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}aR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}dR.isMDXComponent=!0;const hR={toc:[]};function fR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}fR.isMDXComponent=!0;const kR={toc:[]};function yR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}yR.isMDXComponent=!0;const wR={toc:[]};function DR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}DR.isMDXComponent=!0;const MR={toc:[]};function XR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}XR.isMDXComponent=!0;const _R={toc:[]};function gR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_R,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}gR.isMDXComponent=!0;const TR={toc:[]};function CR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}CR.isMDXComponent=!0;const xR={toc:[]};function vR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}vR.isMDXComponent=!0;const LR={toc:[]};function ZR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}ZR.isMDXComponent=!0;const bR={toc:[]};function NR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}NR.isMDXComponent=!0;const zR={toc:[]};function AR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}AR.isMDXComponent=!0;const WR={toc:[]};function IR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}IR.isMDXComponent=!0;const RR={toc:[]};function PR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}PR.isMDXComponent=!0;const SR={toc:[]};function OR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}OR.isMDXComponent=!0;const ER={toc:[]};function BR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ER,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}BR.isMDXComponent=!0;const GR={toc:[]};function VR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n\n// snippet Curve properties:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {all, createRef, easeInCubic, easeOutCubic} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      endAngle={270}\n      endArrow\n    />,\n  );\n\n  yield* all(ref().start(1, 1), ref().rotation(180, 1, easeInCubic));\n  ref().start(0).end(0);\n  yield* all(ref().end(1, 1), ref().rotation(360, 1, easeOutCubic));\n});\n")))}VR.isMDXComponent=!0;const UR={toc:[]};function FR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing circular shapes."))}FR.isMDXComponent=!0;const qR={toc:[]};function jR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}jR.isMDXComponent=!0;const YR={toc:[]};function HR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}HR.isMDXComponent=!0;const QR={toc:[]};function $R(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}$R.isMDXComponent=!0;const KR={toc:[]};function JR(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}JR.isMDXComponent=!0;const tP={toc:[]};function eP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}eP.isMDXComponent=!0;const nP={toc:[]};function oP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}oP.isMDXComponent=!0;const pP={toc:[]};function rP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}rP.isMDXComponent=!0;const sP={toc:[]};function cP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}cP.isMDXComponent=!0;const iP={toc:[]};function aP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}aP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}dP.isMDXComponent=!0;const hP={toc:[]};function fP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}fP.isMDXComponent=!0;const kP={toc:[]};function yP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}yP.isMDXComponent=!0;const wP={toc:[]};function DP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}DP.isMDXComponent=!0;const MP={toc:[]};function XP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}XP.isMDXComponent=!0;const _P={toc:[]};function gP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_P,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A closed circle will look like a pie chart:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.kt)("p",null,"An open one will look like an arc:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}gP.isMDXComponent=!0;const TP={toc:[]};function CP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"false"))}CP.isMDXComponent=!0;const xP={toc:[]};function vP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}vP.isMDXComponent=!0;const LP={toc:[]};function ZP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the circle begins at ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}ZP.isMDXComponent=!0;const bP={toc:[]};function NP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the circle sector should be drawn counterclockwise."))}NP.isMDXComponent=!0;const zP={toc:[]};function AP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}AP.isMDXComponent=!0;const WP={toc:[]};function IP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}IP.isMDXComponent=!0;const RP={toc:[]};function PP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}PP.isMDXComponent=!0;const SP={toc:[]};function OP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"360"))}OP.isMDXComponent=!0;const EP={toc:[]};function BP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}BP.isMDXComponent=!0;const GP={toc:[]};function VP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}VP.isMDXComponent=!0;const UP={toc:[]};function FP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}FP.isMDXComponent=!0;const qP={toc:[]};function jP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}jP.isMDXComponent=!0;const YP={toc:[]};function HP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}HP.isMDXComponent=!0;const QP={toc:[]};function $P(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}$P.isMDXComponent=!0;const KP={toc:[]};function JP(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}JP.isMDXComponent=!0;const tS={toc:[]};function eS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}eS.isMDXComponent=!0;const nS={toc:[]};function oS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}oS.isMDXComponent=!0;const pS={toc:[]};function rS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}rS.isMDXComponent=!0;const sS={toc:[]};function cS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}cS.isMDXComponent=!0;const iS={toc:[]};function aS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}aS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}dS.isMDXComponent=!0;const hS={toc:[]};function fS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}fS.isMDXComponent=!0;const kS={toc:[]};function yS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}yS.isMDXComponent=!0;const wS={toc:[]};function DS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}DS.isMDXComponent=!0;const MS={toc:[]};function XS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}XS.isMDXComponent=!0;const _S={toc:[]};function gS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_S,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}gS.isMDXComponent=!0;const TS={toc:[]};function CS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}CS.isMDXComponent=!0;const xS={toc:[]};function vS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}vS.isMDXComponent=!0;const LS={toc:[]};function ZS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}ZS.isMDXComponent=!0;const bS={toc:[]};function NS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}NS.isMDXComponent=!0;const zS={toc:[]};function AS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}AS.isMDXComponent=!0;const WS={toc:[]};function IS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}IS.isMDXComponent=!0;const RS={toc:[]};function PS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}PS.isMDXComponent=!0;const SS={toc:[]};function OS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}OS.isMDXComponent=!0;const ES={toc:[]};function BS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ES,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}BS.isMDXComponent=!0;const GS={toc:[]};function VS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}VS.isMDXComponent=!0;const US={toc:[]};function FS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},US,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}FS.isMDXComponent=!0;const qS={toc:[]};function jS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}jS.isMDXComponent=!0;const YS={toc:[]};function HS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}HS.isMDXComponent=!0;const QS={toc:[]};function $S(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}$S.isMDXComponent=!0;const KS={toc:[]};function JS(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}JS.isMDXComponent=!0;const tO={toc:[]};function eO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}eO.isMDXComponent=!0;const nO={toc:[]};function oO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}oO.isMDXComponent=!0;const pO={toc:[]};function rO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}rO.isMDXComponent=!0;const sO={toc:[]};function cO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}cO.isMDXComponent=!0;const iO={toc:[]};function aO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}aO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}dO.isMDXComponent=!0;const hO={toc:[]};function fO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}fO.isMDXComponent=!0;const kO={toc:[]};function yO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}yO.isMDXComponent=!0;const wO={toc:[]};function DO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}DO.isMDXComponent=!0;const MO={toc:[]};function XO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}XO.isMDXComponent=!0;const _O={toc:[]};function gO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_O,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}gO.isMDXComponent=!0;const TO={toc:[]};function CO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}CO.isMDXComponent=!0;const xO={toc:[]};function vO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}vO.isMDXComponent=!0;const LO={toc:[]};function ZO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}ZO.isMDXComponent=!0;const bO={toc:[]};function NO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}NO.isMDXComponent=!0;const zO={toc:[]};function AO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}AO.isMDXComponent=!0;const WO={toc:[]};function IO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}IO.isMDXComponent=!0;const RO={toc:[]};function PO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}PO.isMDXComponent=!0;const SO={toc:[]};function OO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}OO.isMDXComponent=!0;const EO={toc:[]};function BO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}BO.isMDXComponent=!0;const GO={toc:[]};function VO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}VO.isMDXComponent=!0;const UO={toc:[]};function FO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}FO.isMDXComponent=!0;const qO={toc:[]};function jO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}jO.isMDXComponent=!0;const YO={toc:[]};function HO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}HO.isMDXComponent=!0;const QO={toc:[]};function $O(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}$O.isMDXComponent=!0;const KO={toc:[]};function JO(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}JO.isMDXComponent=!0;const tE={toc:[]};function eE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}eE.isMDXComponent=!0;const nE={toc:[]};function oE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}oE.isMDXComponent=!0;const pE={toc:[]};function rE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}rE.isMDXComponent=!0;const sE={toc:[]};function cE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}cE.isMDXComponent=!0;const iE={toc:[]};function aE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}aE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dE.isMDXComponent=!0;const hE={toc:[]};function fE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}fE.isMDXComponent=!0;const kE={toc:[]};function yE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}yE.isMDXComponent=!0;const wE={toc:[]};function DE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}DE.isMDXComponent=!0;const ME={toc:[]};function XE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ME,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}XE.isMDXComponent=!0;const _E={toc:[]};function gE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_E,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}gE.isMDXComponent=!0;const TE={toc:[]};function CE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}CE.isMDXComponent=!0;const xE={toc:[]};function vE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}vE.isMDXComponent=!0;const LE={toc:[]};function ZE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}ZE.isMDXComponent=!0;const bE={toc:[]};function NE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}NE.isMDXComponent=!0;const zE={toc:[]};function AE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}AE.isMDXComponent=!0;const WE={toc:[]};function IE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}IE.isMDXComponent=!0;const RE={toc:[]};function PE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}PE.isMDXComponent=!0;const SE={toc:[]};function OE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}OE.isMDXComponent=!0;const EE={toc:[]};function BE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}BE.isMDXComponent=!0;const GE={toc:[]};function VE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}VE.isMDXComponent=!0;const UE={toc:[]};function FE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}FE.isMDXComponent=!0;const qE={toc:[]};function jE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}jE.isMDXComponent=!0;const YE={toc:[]};function HE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}HE.isMDXComponent=!0;const QE={toc:[]};function $E(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}$E.isMDXComponent=!0;const KE={toc:[]};function JE(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}JE.isMDXComponent=!0;const tB={toc:[]};function eB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}eB.isMDXComponent=!0;const nB={toc:[]};function oB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}oB.isMDXComponent=!0;const pB={toc:[]};function rB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}rB.isMDXComponent=!0;const sB={toc:[]};function cB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}cB.isMDXComponent=!0;const iB={toc:[]};function aB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}aB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}dB.isMDXComponent=!0;const hB={toc:[]};function fB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}fB.isMDXComponent=!0;const kB={toc:[]};function yB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}yB.isMDXComponent=!0;const wB={toc:[]};function DB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}DB.isMDXComponent=!0;const MB={toc:[]};function XB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}XB.isMDXComponent=!0;const _B={toc:[]};function gB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_B,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}gB.isMDXComponent=!0;const TB={toc:[]};function CB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}CB.isMDXComponent=!0;const xB={toc:[]};function vB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}vB.isMDXComponent=!0;const LB={toc:[]};function ZB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}ZB.isMDXComponent=!0;const bB={toc:[]};function NB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}NB.isMDXComponent=!0;const zB={toc:[]};function AB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}AB.isMDXComponent=!0;const WB={toc:[]};function IB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}IB.isMDXComponent=!0;const RB={toc:[]};function PB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}PB.isMDXComponent=!0;const SB={toc:[]};function OB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}OB.isMDXComponent=!0;const EB={toc:[]};function BB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}BB.isMDXComponent=!0;const GB={toc:[]};function VB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}VB.isMDXComponent=!0;const UB={toc:[]};function FB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}FB.isMDXComponent=!0;const qB={toc:[]};function jB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}jB.isMDXComponent=!0;const YB={toc:[]};function HB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}HB.isMDXComponent=!0;const QB={toc:[]};function $B(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}$B.isMDXComponent=!0;const KB={toc:[]};function JB(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}JB.isMDXComponent=!0;const tG={toc:[]};function eG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}eG.isMDXComponent=!0;const nG={toc:[]};function oG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}oG.isMDXComponent=!0;const pG={toc:[]};function rG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}rG.isMDXComponent=!0;const sG={toc:[]};function cG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}cG.isMDXComponent=!0;const iG={toc:[]};function aG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}aG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}dG.isMDXComponent=!0;const hG={toc:[]};function fG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}fG.isMDXComponent=!0;const kG={toc:[]};function yG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}yG.isMDXComponent=!0;const wG={toc:[]};function DG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}DG.isMDXComponent=!0;const MG={toc:[]};function XG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}XG.isMDXComponent=!0;const _G={toc:[]};function gG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_G,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}gG.isMDXComponent=!0;const TG={toc:[]};function CG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}CG.isMDXComponent=!0;const xG={toc:[]};function vG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}vG.isMDXComponent=!0;const LG={toc:[]};function ZG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}ZG.isMDXComponent=!0;const bG={toc:[]};function NG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}NG.isMDXComponent=!0;const zG={toc:[]};function AG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}AG.isMDXComponent=!0;const WG={toc:[]};function IG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}IG.isMDXComponent=!0;const RG={toc:[]};function PG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}PG.isMDXComponent=!0;const SG={toc:[]};function OG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}OG.isMDXComponent=!0;const EG={toc:[]};function BG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}BG.isMDXComponent=!0;const GG={toc:[]};function VG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}VG.isMDXComponent=!0;const UG={toc:[]};function FG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}FG.isMDXComponent=!0;const qG={toc:[]};function jG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}jG.isMDXComponent=!0;const YG={toc:[]};function HG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}HG.isMDXComponent=!0;const QG={toc:[]};function $G(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}$G.isMDXComponent=!0;const KG={toc:[]};function JG(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}JG.isMDXComponent=!0;const tV={toc:[]};function eV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}eV.isMDXComponent=!0;const nV={toc:[]};function oV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}oV.isMDXComponent=!0;const pV={toc:[]};function rV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}rV.isMDXComponent=!0;const sV={toc:[]};function cV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}cV.isMDXComponent=!0;const iV={toc:[]};function aV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}aV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dV.isMDXComponent=!0;const hV={toc:[]};function fV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}fV.isMDXComponent=!0;const kV={toc:[]};function yV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}yV.isMDXComponent=!0;const wV={toc:[]};function DV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}DV.isMDXComponent=!0;const MV={toc:[]};function XV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}XV.isMDXComponent=!0;const _V={toc:[]};function gV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_V,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}gV.isMDXComponent=!0;const TV={toc:[]};function CV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}CV.isMDXComponent=!0;const xV={toc:[]};function vV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}vV.isMDXComponent=!0;const LV={toc:[]};function ZV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}ZV.isMDXComponent=!0;const bV={toc:[]};function NV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}NV.isMDXComponent=!0;const zV={toc:[]};function AV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}AV.isMDXComponent=!0;const WV={toc:[]};function IV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, CubicBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  view.add(\n    <CubicBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, -100]}\n      p1={[100, -100]}\n      p2={[-100, 100]}\n      p3={[200, 100]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}IV.isMDXComponent=!0;const RV={toc:[]};function PV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a cubic B\xe9zier curve."))}PV.isMDXComponent=!0;const SV={toc:[]};function OV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}OV.isMDXComponent=!0;const EV={toc:[]};function BV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}BV.isMDXComponent=!0;const GV={toc:[]};function VV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}VV.isMDXComponent=!0;const UV={toc:[]};function FV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}FV.isMDXComponent=!0;const qV={toc:[]};function jV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}jV.isMDXComponent=!0;const YV={toc:[]};function HV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}HV.isMDXComponent=!0;const QV={toc:[]};function $V(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}$V.isMDXComponent=!0;const KV={toc:[]};function JV(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}JV.isMDXComponent=!0;const tU={toc:[]};function eU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}eU.isMDXComponent=!0;const nU={toc:[]};function oU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}oU.isMDXComponent=!0;const pU={toc:[]};function rU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}rU.isMDXComponent=!0;const sU={toc:[]};function cU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}cU.isMDXComponent=!0;const iU={toc:[]};function aU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}aU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}dU.isMDXComponent=!0;const hU={toc:[]};function fU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}fU.isMDXComponent=!0;const kU={toc:[]};function yU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}yU.isMDXComponent=!0;const wU={toc:[]};function DU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}DU.isMDXComponent=!0;const MU={toc:[]};function XU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}XU.isMDXComponent=!0;const _U={toc:[]};function gU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_U,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}gU.isMDXComponent=!0;const TU={toc:[]};function CU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}CU.isMDXComponent=!0;const xU={toc:[]};function vU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}vU.isMDXComponent=!0;const LU={toc:[]};function ZU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}ZU.isMDXComponent=!0;const bU={toc:[]};function NU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}NU.isMDXComponent=!0;const zU={toc:[]};function AU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}AU.isMDXComponent=!0;const WU={toc:[]};function IU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}IU.isMDXComponent=!0;const RU={toc:[]};function PU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}PU.isMDXComponent=!0;const SU={toc:[]};function OU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}OU.isMDXComponent=!0;const EU={toc:[]};function BU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}BU.isMDXComponent=!0;const GU={toc:[]};function VU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The first control point of the B\xe9zier curve."))}VU.isMDXComponent=!0;const UU={toc:[]};function FU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The second control point of the B\xe9zier curve."))}FU.isMDXComponent=!0;const qU={toc:[]};function jU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}jU.isMDXComponent=!0;const YU={toc:[]};function HU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}HU.isMDXComponent=!0;const QU={toc:[]};function $U(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}$U.isMDXComponent=!0;const KU={toc:[]};function JU(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}JU.isMDXComponent=!0;const tF={toc:[]};function eF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}eF.isMDXComponent=!0;const nF={toc:[]};function oF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}oF.isMDXComponent=!0;const pF={toc:[]};function rF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}rF.isMDXComponent=!0;const sF={toc:[]};function cF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}cF.isMDXComponent=!0;const iF={toc:[]};function aF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}aF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}dF.isMDXComponent=!0;const hF={toc:[]};function fF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}fF.isMDXComponent=!0;const kF={toc:[]};function yF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}yF.isMDXComponent=!0;const wF={toc:[]};function DF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}DF.isMDXComponent=!0;const MF={toc:[]};function XF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}XF.isMDXComponent=!0;const _F={toc:[]};function gF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_F,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}gF.isMDXComponent=!0;const TF={toc:[]};function CF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}CF.isMDXComponent=!0;const xF={toc:[]};function vF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}vF.isMDXComponent=!0;const LF={toc:[]};function ZF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}ZF.isMDXComponent=!0;const bF={toc:[]};function NF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}NF.isMDXComponent=!0;const zF={toc:[]};function AF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}AF.isMDXComponent=!0;const WF={toc:[]};function IF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}IF.isMDXComponent=!0;const RF={toc:[]};function PF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}PF.isMDXComponent=!0;const SF={toc:[]};function OF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}OF.isMDXComponent=!0;const EF={toc:[]};function BF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}BF.isMDXComponent=!0;const GF={toc:[]};function VF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}VF.isMDXComponent=!0;const UF={toc:[]};function FF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}FF.isMDXComponent=!0;const qF={toc:[]};function jF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}jF.isMDXComponent=!0;const YF={toc:[]};function HF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}HF.isMDXComponent=!0;const QF={toc:[]};function $F(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}$F.isMDXComponent=!0;const KF={toc:[]};function JF(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}JF.isMDXComponent=!0;const tq={toc:[]};function eq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}eq.isMDXComponent=!0;const nq={toc:[]};function oq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}oq.isMDXComponent=!0;const pq={toc:[]};function rq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}rq.isMDXComponent=!0;const sq={toc:[]};function cq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}cq.isMDXComponent=!0;const iq={toc:[]};function aq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}aq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}dq.isMDXComponent=!0;const hq={toc:[]};function fq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}fq.isMDXComponent=!0;const kq={toc:[]};function yq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}yq.isMDXComponent=!0;const wq={toc:[]};function Dq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Dq.isMDXComponent=!0;const Mq={toc:[]};function Xq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Xq.isMDXComponent=!0;const _q={toc:[]};function gq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_q,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}gq.isMDXComponent=!0;const Tq={toc:[]};function Cq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Cq.isMDXComponent=!0;const xq={toc:[]};function vq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}vq.isMDXComponent=!0;const Lq={toc:[]};function Zq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Zq.isMDXComponent=!0;const bq={toc:[]};function Nq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Nq.isMDXComponent=!0;const zq={toc:[]};function Aq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Aq.isMDXComponent=!0;const Wq={toc:[]};function Iq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Iq.isMDXComponent=!0;const Rq={toc:[]};function Pq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Pq.isMDXComponent=!0;const Sq={toc:[]};function Oq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Oq.isMDXComponent=!0;const Eq={toc:[]};function Bq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Eq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Bq.isMDXComponent=!0;const Gq={toc:[]};function Vq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Vq.isMDXComponent=!0;const Uq={toc:[]};function Fq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Fq.isMDXComponent=!0;const qq={toc:[]};function jq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}jq.isMDXComponent=!0;const Yq={toc:[]};function Hq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Hq.isMDXComponent=!0;const Qq={toc:[]};function $q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$q.isMDXComponent=!0;const Kq={toc:[]};function Jq(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Jq.isMDXComponent=!0;const tj={toc:[]};function ej(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}ej.isMDXComponent=!0;const nj={toc:[]};function oj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}oj.isMDXComponent=!0;const pj={toc:[]};function rj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}rj.isMDXComponent=!0;const sj={toc:[]};function cj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}cj.isMDXComponent=!0;const ij={toc:[]};function aj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ij,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}aj.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}dj.isMDXComponent=!0;const hj={toc:[]};function fj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}fj.isMDXComponent=!0;const kj={toc:[]};function yj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}yj.isMDXComponent=!0;const wj={toc:[]};function Dj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Dj.isMDXComponent=!0;const Mj={toc:[]};function Xj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Xj.isMDXComponent=!0;const _j={toc:[]};function gj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_j,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}gj.isMDXComponent=!0;const Tj={toc:[]};function Cj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Tj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Cj.isMDXComponent=!0;const xj={toc:[]};function vj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}vj.isMDXComponent=!0;const Lj={toc:[]};function Zj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Lj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Zj.isMDXComponent=!0;const bj={toc:[]};function Nj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Nj.isMDXComponent=!0;const zj={toc:[]};function Aj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Aj.isMDXComponent=!0;const Wj={toc:[]};function Ij(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Ij.isMDXComponent=!0;const Rj={toc:[]};function Pj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Pj.isMDXComponent=!0;const Sj={toc:[]};function Oj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Sj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Oj.isMDXComponent=!0;const Ej={toc:[]};function Bj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ej,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Bj.isMDXComponent=!0;const Gj={toc:[]};function Vj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Vj.isMDXComponent=!0;const Uj={toc:[]};function Fj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Uj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Fj.isMDXComponent=!0;const qj={toc:[]};function jj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}jj.isMDXComponent=!0;const Yj={toc:[]};function Hj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Yj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Hj.isMDXComponent=!0;const Qj={toc:[]};function $j(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}$j.isMDXComponent=!0;const Kj={toc:[]};function Jj(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Kj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Jj.isMDXComponent=!0;const tY={toc:[]};function eY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}eY.isMDXComponent=!0;const nY={toc:[]};function oY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}oY.isMDXComponent=!0;const pY={toc:[]};function rY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}rY.isMDXComponent=!0;const sY={toc:[]};function cY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}cY.isMDXComponent=!0;const iY={toc:[]};function aY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}aY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}dY.isMDXComponent=!0;const hY={toc:[]};function fY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}fY.isMDXComponent=!0;const kY={toc:[]};function yY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}yY.isMDXComponent=!0;const wY={toc:[]};function DY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}DY.isMDXComponent=!0;const MY={toc:[]};function XY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}XY.isMDXComponent=!0;const _Y={toc:[]};function gY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Y,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}gY.isMDXComponent=!0;const TY={toc:[]};function CY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}CY.isMDXComponent=!0;const xY={toc:[]};function vY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}vY.isMDXComponent=!0;const LY={toc:[]};function ZY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}ZY.isMDXComponent=!0;const bY={toc:[]};function NY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}NY.isMDXComponent=!0;const zY={toc:[]};function AY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}AY.isMDXComponent=!0;const WY={toc:[]};function IY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}IY.isMDXComponent=!0;const RY={toc:[]};function PY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}PY.isMDXComponent=!0;const SY={toc:[]};function OY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}OY.isMDXComponent=!0;const EY={toc:[]};function BY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}BY.isMDXComponent=!0;const GY={toc:[]};function VY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}VY.isMDXComponent=!0;const UY={toc:[]};function FY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}FY.isMDXComponent=!0;const qY={toc:[]};function jY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}jY.isMDXComponent=!0;const YY={toc:[]};function HY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}HY.isMDXComponent=!0;const QY={toc:[]};function $Y(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}$Y.isMDXComponent=!0;const KY={toc:[]};function JY(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}JY.isMDXComponent=!0;const tH={toc:[]};function eH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}eH.isMDXComponent=!0;const nH={toc:[]};function oH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}oH.isMDXComponent=!0;const pH={toc:[]};function rH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}rH.isMDXComponent=!0;const sH={toc:[]};function cH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}cH.isMDXComponent=!0;const iH={toc:[]};function aH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}aH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}dH.isMDXComponent=!0;const hH={toc:[]};function fH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}fH.isMDXComponent=!0;const kH={toc:[]};function yH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}yH.isMDXComponent=!0;const wH={toc:[]};function DH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}DH.isMDXComponent=!0;const MH={toc:[]};function XH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}XH.isMDXComponent=!0;const _H={toc:[]};function gH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_H,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}gH.isMDXComponent=!0;const TH={toc:[]};function CH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}CH.isMDXComponent=!0;const xH={toc:[]};function vH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}vH.isMDXComponent=!0;const LH={toc:[]};function ZH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}ZH.isMDXComponent=!0;const bH={toc:[]};function NH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}NH.isMDXComponent=!0;const zH={toc:[]};function AH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}AH.isMDXComponent=!0;const WH={toc:[]};function IH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}IH.isMDXComponent=!0;const RH={toc:[]};function PH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}PH.isMDXComponent=!0;const SH={toc:[]};function OH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}OH.isMDXComponent=!0;const EH={toc:[]};function BH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}BH.isMDXComponent=!0;const GH={toc:[]};function VH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}VH.isMDXComponent=!0;const UH={toc:[]};function FH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}FH.isMDXComponent=!0;const qH={toc:[]};function jH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}jH.isMDXComponent=!0;const YH={toc:[]};function HH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}HH.isMDXComponent=!0;const QH={toc:[]};function $H(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}$H.isMDXComponent=!0;const KH={toc:[]};function JH(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}JH.isMDXComponent=!0;const tQ={toc:[]};function eQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}eQ.isMDXComponent=!0;const nQ={toc:[]};function oQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}oQ.isMDXComponent=!0;const pQ={toc:[]};function rQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}rQ.isMDXComponent=!0;const sQ={toc:[]};function cQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}cQ.isMDXComponent=!0;const iQ={toc:[]};function aQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}aQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function fQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}fQ.isMDXComponent=!0;const kQ={toc:[]};function yQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}yQ.isMDXComponent=!0;const wQ={toc:[]};function DQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}DQ.isMDXComponent=!0;const MQ={toc:[]};function XQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}XQ.isMDXComponent=!0;const _Q={toc:[]};function gQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_Q,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}gQ.isMDXComponent=!0;const TQ={toc:[]};function CQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}CQ.isMDXComponent=!0;const xQ={toc:[]};function vQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}vQ.isMDXComponent=!0;const LQ={toc:[]};function ZQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}ZQ.isMDXComponent=!0;const bQ={toc:[]};function NQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}NQ.isMDXComponent=!0;const zQ={toc:[]};function AQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}AQ.isMDXComponent=!0;const WQ={toc:[]};function IQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}IQ.isMDXComponent=!0;const RQ={toc:[]};function PQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}PQ.isMDXComponent=!0;const SQ={toc:[]};function OQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}OQ.isMDXComponent=!0;const EQ={toc:[]};function BQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}BQ.isMDXComponent=!0;const GQ={toc:[]};function VQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}VQ.isMDXComponent=!0;const UQ={toc:[]};function FQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}FQ.isMDXComponent=!0;const qQ={toc:[]};function jQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}jQ.isMDXComponent=!0;const YQ={toc:[]};function HQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}HQ.isMDXComponent=!0;const QQ={toc:[]};function $Q(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}$Q.isMDXComponent=!0;const KQ={toc:[]};function JQ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}JQ.isMDXComponent=!0;const t$={toc:[]};function e$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}e$.isMDXComponent=!0;const n$={toc:[]};function o$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}o$.isMDXComponent=!0;const p$={toc:[]};function r$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}r$.isMDXComponent=!0;const s$={toc:[]};function c$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}c$.isMDXComponent=!0;const i$={toc:[]};function a$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}a$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}d$.isMDXComponent=!0;const h$={toc:[]};function f$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}f$.isMDXComponent=!0;const k$={toc:[]};function y$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}y$.isMDXComponent=!0;const w$={toc:[]};function D$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}D$.isMDXComponent=!0;const M$={toc:[]};function X$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}X$.isMDXComponent=!0;const _$={toc:[]};function g$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}g$.isMDXComponent=!0;const T$={toc:[]};function C$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}C$.isMDXComponent=!0;const x$={toc:[]};function v$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}v$.isMDXComponent=!0;const L$={toc:[]};function Z$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Z$.isMDXComponent=!0;const b$={toc:[]};function N$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}N$.isMDXComponent=!0;const z$={toc:[]};function A$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}A$.isMDXComponent=!0;const W$={toc:[]};function I$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}I$.isMDXComponent=!0;const R$={toc:[]};function P$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}P$.isMDXComponent=!0;const S$={toc:[]};function O$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}O$.isMDXComponent=!0;const E$={toc:[]};function B$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}B$.isMDXComponent=!0;const G$={toc:[]};function V$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}V$.isMDXComponent=!0;const U$={toc:[]};function F$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}F$.isMDXComponent=!0;const q$={toc:[]};function j$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}j$.isMDXComponent=!0;const Y$={toc:[]};function H$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}H$.isMDXComponent=!0;const Q$={toc:[]};function $$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}$$.isMDXComponent=!0;const K$={toc:[]};function J$(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}J$.isMDXComponent=!0;const tK={toc:[]};function eK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}eK.isMDXComponent=!0;const nK={toc:[]};function oK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}oK.isMDXComponent=!0;const pK={toc:[]};function rK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}rK.isMDXComponent=!0;const sK={toc:[]};function cK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}cK.isMDXComponent=!0;const iK={toc:[]};function aK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}aK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}dK.isMDXComponent=!0;const hK={toc:[]};function fK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}fK.isMDXComponent=!0;const kK={toc:[]};function yK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}yK.isMDXComponent=!0;const wK={toc:[]};function DK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}DK.isMDXComponent=!0;const MK={toc:[]};function XK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}XK.isMDXComponent=!0;const _K={toc:[]};function gK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_K,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}gK.isMDXComponent=!0;const TK={toc:[]};function CK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}CK.isMDXComponent=!0;const xK={toc:[]};function vK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}vK.isMDXComponent=!0;const LK={toc:[]};function ZK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}ZK.isMDXComponent=!0;const bK={toc:[]};function NK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}NK.isMDXComponent=!0;const zK={toc:[]};function AK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}AK.isMDXComponent=!0;const WK={toc:[]};function IK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}IK.isMDXComponent=!0;const RK={toc:[]};function PK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}PK.isMDXComponent=!0;const SK={toc:[]};function OK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}OK.isMDXComponent=!0;const EK={toc:[]};function BK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}BK.isMDXComponent=!0;const GK={toc:[]};function VK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}VK.isMDXComponent=!0;const UK={toc:[]};function FK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}FK.isMDXComponent=!0;const qK={toc:[]};function jK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}jK.isMDXComponent=!0;const YK={toc:[]};function HK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}HK.isMDXComponent=!0;const QK={toc:[]};function $K(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}$K.isMDXComponent=!0;const KK={toc:[]};function JK(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}JK.isMDXComponent=!0;const tJ={toc:[]};function eJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}eJ.isMDXComponent=!0;const nJ={toc:[]};function oJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},nJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}oJ.isMDXComponent=!0;const pJ={toc:[]};function rJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}rJ.isMDXComponent=!0;const sJ={toc:[]};function cJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},sJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}cJ.isMDXComponent=!0;const iJ={toc:[]};function aJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}aJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},lJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function fJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},hJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}fJ.isMDXComponent=!0;const kJ={toc:[]};function yJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},kJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}yJ.isMDXComponent=!0;const wJ={toc:[]};function DJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}DJ.isMDXComponent=!0;const MJ={toc:[]};function XJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},MJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}XJ.isMDXComponent=!0;const _J={toc:[]};function gJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_J,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}gJ.isMDXComponent=!0;const TJ={toc:[]};function CJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},TJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}CJ.isMDXComponent=!0;const xJ={toc:[]};function vJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}vJ.isMDXComponent=!0;const LJ={toc:[]};function ZJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},LJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}ZJ.isMDXComponent=!0;const bJ={toc:[]};function NJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},bJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}NJ.isMDXComponent=!0;const zJ={toc:[]};function AJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},zJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}AJ.isMDXComponent=!0;const WJ={toc:[]};function IJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},WJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}IJ.isMDXComponent=!0;const RJ={toc:[]};function PJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},RJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}PJ.isMDXComponent=!0;const SJ={toc:[]};function OJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},SJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}OJ.isMDXComponent=!0;const EJ={toc:[]};function BJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},EJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}BJ.isMDXComponent=!0;const GJ={toc:[]};function VJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},GJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}VJ.isMDXComponent=!0;const UJ={toc:[]};function FJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},UJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}FJ.isMDXComponent=!0;const qJ={toc:[]};function jJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}jJ.isMDXComponent=!0;const YJ={toc:[]};function HJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},YJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}HJ.isMDXComponent=!0;const QJ={toc:[]};function $J(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},QJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}$J.isMDXComponent=!0;const KJ={toc:[]};function JJ(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},KJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}JJ.isMDXComponent=!0;const t0={toc:[]};function e0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}e0.isMDXComponent=!0;const n0={toc:[]};function o0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}o0.isMDXComponent=!0;const p0={toc:[]};function r0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}r0.isMDXComponent=!0;const s0={toc:[]};function c0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}c0.isMDXComponent=!0;const i0={toc:[]};function a0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}a0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}d0.isMDXComponent=!0;const h0={toc:[]};function f0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}f0.isMDXComponent=!0;const k0={toc:[]};function y0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}y0.isMDXComponent=!0;const w0={toc:[]};function D0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}D0.isMDXComponent=!0;const M0={toc:[]};function X0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}X0.isMDXComponent=!0;const _0={toc:[]};function g0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}g0.isMDXComponent=!0;const T0={toc:[]};function C0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}C0.isMDXComponent=!0;const x0={toc:[]};function v0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}v0.isMDXComponent=!0;const L0={toc:[]};function Z0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Z0.isMDXComponent=!0;const b0={toc:[]};function N0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}N0.isMDXComponent=!0;const z0={toc:[]};function A0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}A0.isMDXComponent=!0;const W0={toc:[]};function I0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}I0.isMDXComponent=!0;const R0={toc:[]};function P0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}P0.isMDXComponent=!0;const S0={toc:[]};function O0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}O0.isMDXComponent=!0;const E0={toc:[]};function B0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}B0.isMDXComponent=!0;const G0={toc:[]};function V0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}V0.isMDXComponent=!0;const U0={toc:[]};function F0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}F0.isMDXComponent=!0;const q0={toc:[]};function j0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}j0.isMDXComponent=!0;const Y0={toc:[]};function H0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}H0.isMDXComponent=!0;const Q0={toc:[]};function $0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}$0.isMDXComponent=!0;const K0={toc:[]};function J0(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}J0.isMDXComponent=!0;const t2={toc:[]};function e2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}e2.isMDXComponent=!0;const n2={toc:[]};function o2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}o2.isMDXComponent=!0;const p2={toc:[]};function r2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}r2.isMDXComponent=!0;const s2={toc:[]};function c2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}c2.isMDXComponent=!0;const i2={toc:[]};function a2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}a2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}d2.isMDXComponent=!0;const h2={toc:[]};function f2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}f2.isMDXComponent=!0;const k2={toc:[]};function y2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}y2.isMDXComponent=!0;const w2={toc:[]};function D2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}D2.isMDXComponent=!0;const M2={toc:[]};function X2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}X2.isMDXComponent=!0;const _2={toc:[]};function g2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}g2.isMDXComponent=!0;const T2={toc:[]};function C2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}C2.isMDXComponent=!0;const x2={toc:[]};function v2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}v2.isMDXComponent=!0;const L2={toc:[]};function Z2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Z2.isMDXComponent=!0;const b2={toc:[]};function N2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}N2.isMDXComponent=!0;const z2={toc:[]};function A2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}A2.isMDXComponent=!0;const W2={toc:[]};function I2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}I2.isMDXComponent=!0;const R2={toc:[]};function P2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}P2.isMDXComponent=!0;const S2={toc:[]};function O2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}O2.isMDXComponent=!0;const E2={toc:[]};function B2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}B2.isMDXComponent=!0;const G2={toc:[]};function V2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}V2.isMDXComponent=!0;const U2={toc:[]};function F2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}F2.isMDXComponent=!0;const q2={toc:[]};function j2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}j2.isMDXComponent=!0;const Y2={toc:[]};function H2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}H2.isMDXComponent=!0;const Q2={toc:[]};function $2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}$2.isMDXComponent=!0;const K2={toc:[]};function J2(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}J2.isMDXComponent=!0;const t6={toc:[]};function e6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}e6.isMDXComponent=!0;const n6={toc:[]};function o6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}o6.isMDXComponent=!0;const p6={toc:[]};function r6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}r6.isMDXComponent=!0;const s6={toc:[]};function c6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}c6.isMDXComponent=!0;const i6={toc:[]};function a6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}a6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}d6.isMDXComponent=!0;const h6={toc:[]};function f6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}f6.isMDXComponent=!0;const k6={toc:[]};function y6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}y6.isMDXComponent=!0;const w6={toc:[]};function D6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}D6.isMDXComponent=!0;const M6={toc:[]};function X6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}X6.isMDXComponent=!0;const _6={toc:[]};function g6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}g6.isMDXComponent=!0;const T6={toc:[]};function C6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}C6.isMDXComponent=!0;const x6={toc:[]};function v6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}v6.isMDXComponent=!0;const L6={toc:[]};function Z6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Z6.isMDXComponent=!0;const b6={toc:[]};function N6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}N6.isMDXComponent=!0;const z6={toc:[]};function A6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}A6.isMDXComponent=!0;const W6={toc:[]};function I6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}I6.isMDXComponent=!0;const R6={toc:[]};function P6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Grid, makeScene2D} from '@motion-canvas/2d';\nimport {all, createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const grid = createRef<Grid>();\n\n  view.add(\n    <Grid\n      ref={grid}\n      width={'100%'}\n      height={'100%'}\n      stroke={'#666'}\n      start={0}\n      end={1}\n    />,\n  );\n\n  yield* all(\n    grid().end(0.5, 1).to(1, 1).wait(1),\n    grid().start(0.5, 1).to(0, 1).wait(1),\n  );\n});\n")))}P6.isMDXComponent=!0;const S6={toc:[]};function O6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a two-dimensional grid."))}O6.isMDXComponent=!0;const E6={toc:[]};function B6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}B6.isMDXComponent=!0;const G6={toc:[]};function V6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}V6.isMDXComponent=!0;const U6={toc:[]};function F6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}F6.isMDXComponent=!0;const q6={toc:[]};function j6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}j6.isMDXComponent=!0;const Y6={toc:[]};function H6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}H6.isMDXComponent=!0;const Q6={toc:[]};function $6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}$6.isMDXComponent=!0;const K6={toc:[]};function J6(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}J6.isMDXComponent=!0;const t3={toc:[]};function e3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}e3.isMDXComponent=!0;const n3={toc:[]};function o3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}o3.isMDXComponent=!0;const p3={toc:[]};function r3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}r3.isMDXComponent=!0;const s3={toc:[]};function c3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}c3.isMDXComponent=!0;const i3={toc:[]};function a3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}a3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the end of each grid line."))}d3.isMDXComponent=!0;const h3={toc:[]};function f3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}f3.isMDXComponent=!0;const k3={toc:[]};function y3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}y3.isMDXComponent=!0;const w3={toc:[]};function D3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}D3.isMDXComponent=!0;const M3={toc:[]};function X3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}X3.isMDXComponent=!0;const _3={toc:[]};function g3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}g3.isMDXComponent=!0;const T3={toc:[]};function C3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}C3.isMDXComponent=!0;const x3={toc:[]};function v3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}v3.isMDXComponent=!0;const L3={toc:[]};function Z3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Z3.isMDXComponent=!0;const b3={toc:[]};function N3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}N3.isMDXComponent=!0;const z3={toc:[]};function A3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}A3.isMDXComponent=!0;const W3={toc:[]};function I3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}I3.isMDXComponent=!0;const R3={toc:[]};function P3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}P3.isMDXComponent=!0;const S3={toc:[]};function O3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}O3.isMDXComponent=!0;const E3={toc:[]};function B3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}B3.isMDXComponent=!0;const G3={toc:[]};function V3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}V3.isMDXComponent=!0;const U3={toc:[]};function F3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}F3.isMDXComponent=!0;const q3={toc:[]};function j3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}j3.isMDXComponent=!0;const Y3={toc:[]};function H3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}H3.isMDXComponent=!0;const Q3={toc:[]};function $3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The spacing between the grid lines."))}$3.isMDXComponent=!0;const K3={toc:[]};function J3(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}J3.isMDXComponent=!0;const t5={toc:[]};function e5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}e5.isMDXComponent=!0;const n5={toc:[]};function o5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}o5.isMDXComponent=!0;const p5={toc:[]};function r5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}r5.isMDXComponent=!0;const s5={toc:[]};function c5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}c5.isMDXComponent=!0;const i5={toc:[]};function a5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}a5.isMDXComponent=!0;const l5={toc:[]};function u5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}u5.isMDXComponent=!0;const m5={toc:[]};function d5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}d5.isMDXComponent=!0;const h5={toc:[]};function f5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}f5.isMDXComponent=!0;const k5={toc:[]};function y5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}y5.isMDXComponent=!0;const w5={toc:[]};function D5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}D5.isMDXComponent=!0;const M5={toc:[]};function X5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}X5.isMDXComponent=!0;const _5={toc:[]};function g5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}g5.isMDXComponent=!0;const T5={toc:[]};function C5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}C5.isMDXComponent=!0;const x5={toc:[]};function v5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}v5.isMDXComponent=!0;const L5={toc:[]};function Z5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Z5.isMDXComponent=!0;const b5={toc:[]};function N5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}N5.isMDXComponent=!0;const z5={toc:[]};function A5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}A5.isMDXComponent=!0;const W5={toc:[]};function I5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}I5.isMDXComponent=!0;const R5={toc:[]};function P5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}P5.isMDXComponent=!0;const S5={toc:[]};function O5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}O5.isMDXComponent=!0;const E5={toc:[]};function B5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}B5.isMDXComponent=!0;const G5={toc:[]};function V5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}V5.isMDXComponent=!0;const U5={toc:[]};function F5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}F5.isMDXComponent=!0;const q5={toc:[]};function j5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}j5.isMDXComponent=!0;const Y5={toc:[]};function H5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}H5.isMDXComponent=!0;const Q5={toc:[]};function $5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}$5.isMDXComponent=!0;const K5={toc:[]};function J5(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}J5.isMDXComponent=!0;const t1={toc:[]};function e1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}e1.isMDXComponent=!0;const n1={toc:[]};function o1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}o1.isMDXComponent=!0;const p1={toc:[]};function r1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}r1.isMDXComponent=!0;const s1={toc:[]};function c1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}c1.isMDXComponent=!0;const i1={toc:[]};function a1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}a1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}d1.isMDXComponent=!0;const h1={toc:[]};function f1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}f1.isMDXComponent=!0;const k1={toc:[]};function y1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}y1.isMDXComponent=!0;const w1={toc:[]};function D1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}D1.isMDXComponent=!0;const M1={toc:[]};function X1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}X1.isMDXComponent=!0;const _1={toc:[]};function g1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}g1.isMDXComponent=!0;const T1={toc:[]};function C1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}C1.isMDXComponent=!0;const x1={toc:[]};function v1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}v1.isMDXComponent=!0;const L1={toc:[]};function Z1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Z1.isMDXComponent=!0;const b1={toc:[]};function N1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}N1.isMDXComponent=!0;const z1={toc:[]};function A1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}A1.isMDXComponent=!0;const W1={toc:[]};function I1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}I1.isMDXComponent=!0;const R1={toc:[]};function P1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}P1.isMDXComponent=!0;const S1={toc:[]};function O1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}O1.isMDXComponent=!0;const E1={toc:[]};function B1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}B1.isMDXComponent=!0;const G1={toc:[]};function V1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}V1.isMDXComponent=!0;const U1={toc:[]};function F1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}F1.isMDXComponent=!0;const q1={toc:[]};function j1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}j1.isMDXComponent=!0;const Y1={toc:[]};function H1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}H1.isMDXComponent=!0;const Q1={toc:[]};function $1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}$1.isMDXComponent=!0;const K1={toc:[]};function J1(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}J1.isMDXComponent=!0;const t4={toc:[]};function e4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}e4.isMDXComponent=!0;const n4={toc:[]};function o4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}o4.isMDXComponent=!0;const p4={toc:[]};function r4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}r4.isMDXComponent=!0;const s4={toc:[]};function c4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}c4.isMDXComponent=!0;const i4={toc:[]};function a4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}a4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}d4.isMDXComponent=!0;const h4={toc:[]};function f4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}f4.isMDXComponent=!0;const k4={toc:[]};function y4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}y4.isMDXComponent=!0;const w4={toc:[]};function D4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}D4.isMDXComponent=!0;const M4={toc:[]};function X4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}X4.isMDXComponent=!0;const _4={toc:[]};function g4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}g4.isMDXComponent=!0;const T4={toc:[]};function C4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}C4.isMDXComponent=!0;const x4={toc:[]};function v4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}v4.isMDXComponent=!0;const L4={toc:[]};function Z4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Z4.isMDXComponent=!0;const b4={toc:[]};function N4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}N4.isMDXComponent=!0;const z4={toc:[]};function A4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}A4.isMDXComponent=!0;const W4={toc:[]};function I4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}I4.isMDXComponent=!0;const R4={toc:[]};function P4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}P4.isMDXComponent=!0;const S4={toc:[]};function O4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}O4.isMDXComponent=!0;const E4={toc:[]};function B4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}B4.isMDXComponent=!0;const G4={toc:[]};function V4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}V4.isMDXComponent=!0;const U4={toc:[]};function F4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}F4.isMDXComponent=!0;const q4={toc:[]};function j4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}j4.isMDXComponent=!0;const Y4={toc:[]};function H4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}H4.isMDXComponent=!0;const Q4={toc:[]};function $4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}$4.isMDXComponent=!0;const K4={toc:[]};function J4(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}J4.isMDXComponent=!0;const t8={toc:[]};function e8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}e8.isMDXComponent=!0;const n8={toc:[]};function o8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}o8.isMDXComponent=!0;const p8={toc:[]};function r8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}r8.isMDXComponent=!0;const s8={toc:[]};function c8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}c8.isMDXComponent=!0;const i8={toc:[]};function a8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}a8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}d8.isMDXComponent=!0;const h8={toc:[]};function f8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}f8.isMDXComponent=!0;const k8={toc:[]};function y8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}y8.isMDXComponent=!0;const w8={toc:[]};function D8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}D8.isMDXComponent=!0;const M8={toc:[]};function X8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}X8.isMDXComponent=!0;const _8={toc:[]};function g8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}g8.isMDXComponent=!0;const T8={toc:[]};function C8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}C8.isMDXComponent=!0;const x8={toc:[]};function v8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}v8.isMDXComponent=!0;const L8={toc:[]};function Z8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Z8.isMDXComponent=!0;const b8={toc:[]};function N8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}N8.isMDXComponent=!0;const z8={toc:[]};function A8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}A8.isMDXComponent=!0;const W8={toc:[]};function I8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}I8.isMDXComponent=!0;const R8={toc:[]};function P8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}P8.isMDXComponent=!0;const S8={toc:[]};function O8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}O8.isMDXComponent=!0;const E8={toc:[]};function B8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}B8.isMDXComponent=!0;const G8={toc:[]};function V8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}V8.isMDXComponent=!0;const U8={toc:[]};function F8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}F8.isMDXComponent=!0;const q8={toc:[]};function j8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}j8.isMDXComponent=!0;const Y8={toc:[]};function H8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}H8.isMDXComponent=!0;const Q8={toc:[]};function $8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}$8.isMDXComponent=!0;const K8={toc:[]};function J8(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}J8.isMDXComponent=!0;const t7={toc:[]};function e7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}e7.isMDXComponent=!0;const n7={toc:[]};function o7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}o7.isMDXComponent=!0;const p7={toc:[]};function r7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}r7.isMDXComponent=!0;const s7={toc:[]};function c7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}c7.isMDXComponent=!0;const i7={toc:[]};function a7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An Icon Component that provides easy access to over 150k icons.\nSee ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}a7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}d7.isMDXComponent=!0;const h7={toc:[]};function f7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}f7.isMDXComponent=!0;const k7={toc:[]};function y7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}y7.isMDXComponent=!0;const w7={toc:[]};function D7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}D7.isMDXComponent=!0;const M7={toc:[]};function X7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}X7.isMDXComponent=!0;const _7={toc:[]};function g7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}g7.isMDXComponent=!0;const T7={toc:[]};function C7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}C7.isMDXComponent=!0;const x7={toc:[]};function v7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}v7.isMDXComponent=!0;const L7={toc:[]};function Z7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Z7.isMDXComponent=!0;const b7={toc:[]};function N7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}N7.isMDXComponent=!0;const z7={toc:[]};function A7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}A7.isMDXComponent=!0;const W7={toc:[]};function I7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}I7.isMDXComponent=!0;const R7={toc:[]};function P7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}P7.isMDXComponent=!0;const S7={toc:[]};function O7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}O7.isMDXComponent=!0;const E7={toc:[]};function B7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}B7.isMDXComponent=!0;const G7={toc:[]};function V7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}V7.isMDXComponent=!0;const U7={toc:[]};function F7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}F7.isMDXComponent=!0;const q7={toc:[]};function j7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}j7.isMDXComponent=!0;const Y7={toc:[]};function H7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"'white'"))}H7.isMDXComponent=!0;const Q7={toc:[]};function $7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}$7.isMDXComponent=!0;const K7={toc:[]};function J7(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}J7.isMDXComponent=!0;const t9={toc:[]};function e9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},t9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}e9.isMDXComponent=!0;const n9={toc:[]};function o9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},n9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}o9.isMDXComponent=!0;const p9={toc:[]};function r9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},p9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}r9.isMDXComponent=!0;const s9={toc:[]};function c9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},s9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}c9.isMDXComponent=!0;const i9={toc:[]};function a9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},i9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}a9.isMDXComponent=!0;const l9={toc:[]};function u9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},l9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}u9.isMDXComponent=!0;const m9={toc:[]};function d9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},m9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}d9.isMDXComponent=!0;const h9={toc:[]};function f9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},h9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}f9.isMDXComponent=!0;const k9={toc:[]};function y9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},k9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}y9.isMDXComponent=!0;const w9={toc:[]};function D9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},w9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}D9.isMDXComponent=!0;const M9={toc:[]};function X9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},M9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}X9.isMDXComponent=!0;const _9={toc:[]};function g9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}g9.isMDXComponent=!0;const T9={toc:[]};function C9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},T9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}C9.isMDXComponent=!0;const x9={toc:[]};function v9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},x9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}v9.isMDXComponent=!0;const L9={toc:[]};function Z9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},L9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Z9.isMDXComponent=!0;const b9={toc:[]};function N9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},b9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}N9.isMDXComponent=!0;const z9={toc:[]};function A9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},z9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}A9.isMDXComponent=!0;const W9={toc:[]};function I9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},W9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}I9.isMDXComponent=!0;const R9={toc:[]};function P9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},R9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}P9.isMDXComponent=!0;const S9={toc:[]};function O9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},S9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}O9.isMDXComponent=!0;const E9={toc:[]};function B9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},E9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}B9.isMDXComponent=!0;const G9={toc:[]};function V9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},G9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}V9.isMDXComponent=!0;const U9={toc:[]};function F9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},U9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}F9.isMDXComponent=!0;const q9={toc:[]};function j9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},q9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}j9.isMDXComponent=!0;const Y9={toc:[]};function H9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Y9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}H9.isMDXComponent=!0;const Q9={toc:[]};function $9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Q9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}$9.isMDXComponent=!0;const K9={toc:[]};function J9(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},K9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}J9.isMDXComponent=!0;const ttt={toc:[]};function ett(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ttt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}ett.isMDXComponent=!0;const ntt={toc:[]};function ott(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ntt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ott.isMDXComponent=!0;const ptt={toc:[]};function rtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ptt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}rtt.isMDXComponent=!0;const stt={toc:[]};function ctt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},stt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}ctt.isMDXComponent=!0;const itt={toc:[]};function att(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},itt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}att.isMDXComponent=!0;const ltt={toc:[]};function utt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ltt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}utt.isMDXComponent=!0;const mtt={toc:[]};function dtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},mtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}dtt.isMDXComponent=!0;const htt={toc:[]};function ftt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},htt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}ftt.isMDXComponent=!0;const ktt={toc:[]};function ytt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ktt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}ytt.isMDXComponent=!0;const wtt={toc:[]};function Dtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},wtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}Dtt.isMDXComponent=!0;const Mtt={toc:[]};function Xtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Mtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Xtt.isMDXComponent=!0;const _tt={toc:[]};function gtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},_tt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}gtt.isMDXComponent=!0;const Ttt={toc:[]};function Ctt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ttt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Ctt.isMDXComponent=!0;const xtt={toc:[]};function vtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},xtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}vtt.isMDXComponent=!0;const Ltt={toc:[]};function Ztt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ltt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Ztt.isMDXComponent=!0;const btt={toc:[]};function Ntt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},btt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Ntt.isMDXComponent=!0;const ztt={toc:[]};function Att(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ztt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Att.isMDXComponent=!0;const Wtt={toc:[]};function Itt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Wtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Itt.isMDXComponent=!0;const Rtt={toc:[]};function Ptt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Rtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Ptt.isMDXComponent=!0;const Stt={toc:[]};function Ott(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Stt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Ott.isMDXComponent=!0;const Ett={toc:[]};function Btt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ett,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Btt.isMDXComponent=!0;const Gtt={toc:[]};function Vtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Gtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Vtt.isMDXComponent=!0;const Utt={toc:[]};function Ftt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Utt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Ftt.isMDXComponent=!0;const qtt={toc:[]};function jtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},qtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}jtt.isMDXComponent=!0;const Ytt={toc:[]};function Htt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ytt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Htt.isMDXComponent=!0;const Qtt={toc:[]};function $tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Qtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}$tt.isMDXComponent=!0;const Ktt={toc:[]};function Jtt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ktt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Jtt.isMDXComponent=!0;const tet={toc:[]};function eet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},tet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}eet.isMDXComponent=!0;const net={toc:[]};function oet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},net,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}oet.isMDXComponent=!0;const pet={toc:[]};function ret(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},pet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}ret.isMDXComponent=!0;const set={toc:[]};function cet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},set,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}cet.isMDXComponent=!0;const iet={toc:[]};function aet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},iet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}aet.isMDXComponent=!0;const uet={toc:[]};function met(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}met.isMDXComponent=!0;const det={toc:[]};function het(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},det,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}het.isMDXComponent=!0;const fet={toc:[]};function ket(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}ket.isMDXComponent=!0;const yet={toc:[]};function wet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}wet.isMDXComponent=!0;const Det={toc:[]};function Met(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Det,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Met.isMDXComponent=!0;const Xet={toc:[]};function _et(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}_et.isMDXComponent=!0;const get={toc:[]};function Tet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},get,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Tet.isMDXComponent=!0;const Cet={toc:[]};function xet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}xet.isMDXComponent=!0;const vet={toc:[]};function Let(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Let.isMDXComponent=!0;const Zet={toc:[]};function bet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}bet.isMDXComponent=!0;const Net={toc:[]};function zet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Net,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}zet.isMDXComponent=!0;const Aet={toc:[]};function Wet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Wet.isMDXComponent=!0;const Iet={toc:[]};function Ret(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Ret.isMDXComponent=!0;const Pet={toc:[]};function Set(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Set.isMDXComponent=!0;const Oet={toc:[]};function Eet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Eet.isMDXComponent=!0;const Bet={toc:[]};function Get(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Get.isMDXComponent=!0;const Vet={toc:[]};function Uet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Uet.isMDXComponent=!0;const Fet={toc:[]};function qet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}qet.isMDXComponent=!0;const jet={toc:[]};function Yet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Yet.isMDXComponent=!0;const Het={toc:[]};function Qet(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Het,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Qet.isMDXComponent=!0;const $et={toc:[]};function Ket(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Ket.isMDXComponent=!0;const Jet={toc:[]};function tnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}tnt.isMDXComponent=!0;const ent={toc:[]};function nnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ent,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}nnt.isMDXComponent=!0;const ont={toc:[]};function pnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ont,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}pnt.isMDXComponent=!0;const rnt={toc:[]};function snt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}snt.isMDXComponent=!0;const cnt={toc:[]};function int(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}int.isMDXComponent=!0;const ant={toc:[]};function lnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ant,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lnt.isMDXComponent=!0;const unt={toc:[]};function mnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},unt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}mnt.isMDXComponent=!0;const dnt={toc:[]};function hnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}hnt.isMDXComponent=!0;const fnt={toc:[]};function knt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}knt.isMDXComponent=!0;const ynt={toc:[]};function wnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ynt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}wnt.isMDXComponent=!0;const Dnt={toc:[]};function Mnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}Mnt.isMDXComponent=!0;const Xnt={toc:[]};function _nt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}_nt.isMDXComponent=!0;const gnt={toc:[]};function Tnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}Tnt.isMDXComponent=!0;const Cnt={toc:[]};function xnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}xnt.isMDXComponent=!0;const vnt={toc:[]};function Lnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Lnt.isMDXComponent=!0;const Znt={toc:[]};function bnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Znt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}bnt.isMDXComponent=!0;const Nnt={toc:[]};function znt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}znt.isMDXComponent=!0;const Ant={toc:[]};function Wnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ant,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Wnt.isMDXComponent=!0;const Int={toc:[]};function Rnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Int,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Rnt.isMDXComponent=!0;const Pnt={toc:[]};function Snt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Snt.isMDXComponent=!0;const Ont={toc:[]};function Ent(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ont,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Ent.isMDXComponent=!0;const Bnt={toc:[]};function Gnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Gnt.isMDXComponent=!0;const Vnt={toc:[]};function Unt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Unt.isMDXComponent=!0;const Fnt={toc:[]};function qnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}qnt.isMDXComponent=!0;const jnt={toc:[]};function Ynt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Ynt.isMDXComponent=!0;const Hnt={toc:[]};function Qnt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Qnt.isMDXComponent=!0;const $nt={toc:[]};function Knt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Knt.isMDXComponent=!0;const Jnt={toc:[]};function tot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}tot.isMDXComponent=!0;const eot={toc:[]};function not(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}not.isMDXComponent=!0;const oot={toc:[]};function pot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}pot.isMDXComponent=!0;const rot={toc:[]};function sot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}sot.isMDXComponent=!0;const cot={toc:[]};function iot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}iot.isMDXComponent=!0;const aot={toc:[]};function lot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}lot.isMDXComponent=!0;const uot={toc:[]};function mot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}mot.isMDXComponent=!0;const dot={toc:[]};function hot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}hot.isMDXComponent=!0;const fot={toc:[]};function kot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}kot.isMDXComponent=!0;const yot={toc:[]};function wot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wot.isMDXComponent=!0;const Dot={toc:[]};function Mot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Mot.isMDXComponent=!0;const Xot={toc:[]};function _ot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}_ot.isMDXComponent=!0;const got={toc:[]};function Tot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},got,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Tot.isMDXComponent=!0;const Cot={toc:[]};function xot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}xot.isMDXComponent=!0;const vot={toc:[]};function Lot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Lot.isMDXComponent=!0;const Zot={toc:[]};function bot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}bot.isMDXComponent=!0;const Not={toc:[]};function zot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Not,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}zot.isMDXComponent=!0;const Aot={toc:[]};function Wot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Wot.isMDXComponent=!0;const Iot={toc:[]};function Rot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Rot.isMDXComponent=!0;const Pot={toc:[]};function Sot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Sot.isMDXComponent=!0;const Oot={toc:[]};function Eot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Eot.isMDXComponent=!0;const Bot={toc:[]};function Got(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Got.isMDXComponent=!0;const Vot={toc:[]};function Uot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Uot.isMDXComponent=!0;const Fot={toc:[]};function qot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}qot.isMDXComponent=!0;const jot={toc:[]};function Yot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Yot.isMDXComponent=!0;const Hot={toc:[]};function Qot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Qot.isMDXComponent=!0;const $ot={toc:[]};function Kot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Kot.isMDXComponent=!0;const Jot={toc:[]};function tpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}tpt.isMDXComponent=!0;const ept={toc:[]};function npt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ept,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}npt.isMDXComponent=!0;const opt={toc:[]};function ppt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},opt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}ppt.isMDXComponent=!0;const rpt={toc:[]};function spt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}spt.isMDXComponent=!0;const cpt={toc:[]};function ipt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}ipt.isMDXComponent=!0;const apt={toc:[]};function lpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},apt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}lpt.isMDXComponent=!0;const upt={toc:[]};function mpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}mpt.isMDXComponent=!0;const dpt={toc:[]};function hpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}hpt.isMDXComponent=!0;const fpt={toc:[]};function kpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}kpt.isMDXComponent=!0;const ypt={toc:[]};function wpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ypt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}wpt.isMDXComponent=!0;const Dpt={toc:[]};function Mpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Mpt.isMDXComponent=!0;const Xpt={toc:[]};function _pt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}_pt.isMDXComponent=!0;const gpt={toc:[]};function Tpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Tpt.isMDXComponent=!0;const Cpt={toc:[]};function xpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}xpt.isMDXComponent=!0;const vpt={toc:[]};function Lpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Lpt.isMDXComponent=!0;const Zpt={toc:[]};function bpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}bpt.isMDXComponent=!0;const Npt={toc:[]};function zpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}zpt.isMDXComponent=!0;const Apt={toc:[]};function Wpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Apt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Wpt.isMDXComponent=!0;const Ipt={toc:[]};function Rpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ipt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Rpt.isMDXComponent=!0;const Ppt={toc:[]};function Spt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ppt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Spt.isMDXComponent=!0;const Opt={toc:[]};function Ept(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Opt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Ept.isMDXComponent=!0;const Bpt={toc:[]};function Gpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Gpt.isMDXComponent=!0;const Vpt={toc:[]};function Upt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Upt.isMDXComponent=!0;const Fpt={toc:[]};function qpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}qpt.isMDXComponent=!0;const jpt={toc:[]};function Ypt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Ypt.isMDXComponent=!0;const Hpt={toc:[]};function Qpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Qpt.isMDXComponent=!0;const $pt={toc:[]};function Kpt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Kpt.isMDXComponent=!0;const Jpt={toc:[]};function trt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}trt.isMDXComponent=!0;const ert={toc:[]};function nrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ert,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}nrt.isMDXComponent=!0;const ort={toc:[]};function prt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ort,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}prt.isMDXComponent=!0;const rrt={toc:[]};function srt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}srt.isMDXComponent=!0;const crt={toc:[]};function irt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},crt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}irt.isMDXComponent=!0;const art={toc:[]};function lrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},art,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}lrt.isMDXComponent=!0;const urt={toc:[]};function mrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},urt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}mrt.isMDXComponent=!0;const drt={toc:[]};function hrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},drt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}hrt.isMDXComponent=!0;const frt={toc:[]};function krt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},frt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}krt.isMDXComponent=!0;const yrt={toc:[]};function wrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wrt.isMDXComponent=!0;const Drt={toc:[]};function Mrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Drt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Address to Iconify API for the requested Icon."))}Mrt.isMDXComponent=!0;const Xrt={toc:[]};function _rt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create the URL that will be used as the Image source"))}_rt.isMDXComponent=!0;const grt={toc:[]};function Trt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},grt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Trt.isMDXComponent=!0;const Crt={toc:[]};function xrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Crt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}xrt.isMDXComponent=!0;const vrt={toc:[]};function Lrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Lrt.isMDXComponent=!0;const Zrt={toc:[]};function brt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}brt.isMDXComponent=!0;const Nrt={toc:[]};function zrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}zrt.isMDXComponent=!0;const Art={toc:[]};function Wrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Art,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Wrt.isMDXComponent=!0;const Irt={toc:[]};function Rrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Irt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Rrt.isMDXComponent=!0;const Prt={toc:[]};function Srt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Prt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Srt.isMDXComponent=!0;const Ort={toc:[]};function Ert(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ort,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Ert.isMDXComponent=!0;const Brt={toc:[]};function Grt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Brt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Grt.isMDXComponent=!0;const Vrt={toc:[]};function Urt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d/lib/components';\nimport {all, waitFor} from '@motion-canvas/core/lib/flow';\nimport {createRef} from '@motion-canvas/core/lib/utils';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  yield view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}Urt.isMDXComponent=!0;const Frt={toc:[]};function qrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Frt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}qrt.isMDXComponent=!0;const jrt={toc:[]};function Yrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Yrt.isMDXComponent=!0;const Hrt={toc:[]};function Qrt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Qrt.isMDXComponent=!0;const $rt={toc:[]};function Krt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Krt.isMDXComponent=!0;const Jrt={toc:[]};function tst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}tst.isMDXComponent=!0;const est={toc:[]};function nst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},est,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}nst.isMDXComponent=!0;const ost={toc:[]};function pst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ost,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}pst.isMDXComponent=!0;const rst={toc:[]};function sst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}sst.isMDXComponent=!0;const cst={toc:[]};function ist(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}ist.isMDXComponent=!0;const ast={toc:[]};function lst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ast,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}lst.isMDXComponent=!0;const ust={toc:[]};function mst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ust,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}mst.isMDXComponent=!0;const dst={toc:[]};function hst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}hst.isMDXComponent=!0;const fst={toc:[]};function kst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}kst.isMDXComponent=!0;const yst={toc:[]};function wst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}wst.isMDXComponent=!0;const Dst={toc:[]};function Mst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Mst.isMDXComponent=!0;const Xst={toc:[]};function _st(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}_st.isMDXComponent=!0;const gst={toc:[]};function Tst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Tst.isMDXComponent=!0;const Cst={toc:[]};function xst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}xst.isMDXComponent=!0;const vst={toc:[]};function Lst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Lst.isMDXComponent=!0;const Zst={toc:[]};function bst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}bst.isMDXComponent=!0;const Nst={toc:[]};function zst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}zst.isMDXComponent=!0;const Ast={toc:[]};function Wst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ast,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Wst.isMDXComponent=!0;const Ist={toc:[]};function Rst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ist,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Rst.isMDXComponent=!0;const Pst={toc:[]};function Sst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Sst.isMDXComponent=!0;const Ost={toc:[]};function Est(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ost,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Est.isMDXComponent=!0;const Bst={toc:[]};function Gst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Gst.isMDXComponent=!0;const Vst={toc:[]};function Ust(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Ust.isMDXComponent=!0;const Fst={toc:[]};function qst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}qst.isMDXComponent=!0;const jst={toc:[]};function Yst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Yst.isMDXComponent=!0;const Hst={toc:[]};function Qst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Qst.isMDXComponent=!0;const $st={toc:[]};function Kst(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$st,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Kst.isMDXComponent=!0;const Jst={toc:[]};function tct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}tct.isMDXComponent=!0;const ect={toc:[]};function nct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ect,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}nct.isMDXComponent=!0;const oct={toc:[]};function pct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}pct.isMDXComponent=!0;const rct={toc:[]};function sct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}sct.isMDXComponent=!0;const cct={toc:[]};function ict(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}ict.isMDXComponent=!0;const act={toc:[]};function lct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},act,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}lct.isMDXComponent=!0;const uct={toc:[]};function mct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}mct.isMDXComponent=!0;const dct={toc:[]};function hct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}hct.isMDXComponent=!0;const fct={toc:[]};function kct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}kct.isMDXComponent=!0;const yct={toc:[]};function wct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}wct.isMDXComponent=!0;const Dct={toc:[]};function Mct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Mct.isMDXComponent=!0;const Xct={toc:[]};function _ct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}_ct.isMDXComponent=!0;const gct={toc:[]};function Tct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Tct.isMDXComponent=!0;const Cct={toc:[]};function xct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}xct.isMDXComponent=!0;const vct={toc:[]};function Lct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Lct.isMDXComponent=!0;const Zct={toc:[]};function bct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}bct.isMDXComponent=!0;const Nct={toc:[]};function zct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}zct.isMDXComponent=!0;const Act={toc:[]};function Wct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Act,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Wct.isMDXComponent=!0;const Ict={toc:[]};function Rct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ict,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Rct.isMDXComponent=!0;const Pct={toc:[]};function Sct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Sct.isMDXComponent=!0;const Oct={toc:[]};function Ect(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}Ect.isMDXComponent=!0;const Bct={toc:[]};function Gct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Gct.isMDXComponent=!0;const Vct={toc:[]};function Uct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Uct.isMDXComponent=!0;const Fct={toc:[]};function qct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}qct.isMDXComponent=!0;const jct={toc:[]};function Yct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Yct.isMDXComponent=!0;const Hct={toc:[]};function Qct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}Qct.isMDXComponent=!0;const $ct={toc:[]};function Kct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Kct.isMDXComponent=!0;const Jct={toc:[]};function tit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}tit.isMDXComponent=!0;const eit={toc:[]};function nit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}nit.isMDXComponent=!0;const oit={toc:[]};function pit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pit.isMDXComponent=!0;const rit={toc:[]};function sit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}sit.isMDXComponent=!0;const cit={toc:[]};function iit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}iit.isMDXComponent=!0;const ait={toc:[]};function lit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ait,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}lit.isMDXComponent=!0;const uit={toc:[]};function mit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}mit.isMDXComponent=!0;const dit={toc:[]};function hit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}hit.isMDXComponent=!0;const fit={toc:[]};function kit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}kit.isMDXComponent=!0;const yit={toc:[]};function wit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wit.isMDXComponent=!0;const Dit={toc:[]};function Mit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Mit.isMDXComponent=!0;const Xit={toc:[]};function _it(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}_it.isMDXComponent=!0;const git={toc:[]};function Tit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},git,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Tit.isMDXComponent=!0;const Cit={toc:[]};function xit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}xit.isMDXComponent=!0;const vit={toc:[]};function Lit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Lit.isMDXComponent=!0;const Zit={toc:[]};function bit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}bit.isMDXComponent=!0;const Nit={toc:[]};function zit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}zit.isMDXComponent=!0;const Ait={toc:[]};function Wit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ait,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Wit.isMDXComponent=!0;const Iit={toc:[]};function Rit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Rit.isMDXComponent=!0;const Pit={toc:[]};function Sit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Sit.isMDXComponent=!0;const Oit={toc:[]};function Eit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Eit.isMDXComponent=!0;const Bit={toc:[]};function Git(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Git.isMDXComponent=!0;const Vit={toc:[]};function Uit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Uit.isMDXComponent=!0;const Fit={toc:[]};function qit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}qit.isMDXComponent=!0;const jit={toc:[]};function Yit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Yit.isMDXComponent=!0;const Hit={toc:[]};function Qit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Qit.isMDXComponent=!0;const $it={toc:[]};function Kit(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$it,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Kit.isMDXComponent=!0;const Jit={toc:[]};function tat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}tat.isMDXComponent=!0;const eat={toc:[]};function nat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}nat.isMDXComponent=!0;const oat={toc:[]};function pat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}pat.isMDXComponent=!0;const rat={toc:[]};function sat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}sat.isMDXComponent=!0;const cat={toc:[]};function iat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}iat.isMDXComponent=!0;const aat={toc:[]};function lat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}lat.isMDXComponent=!0;const uat={toc:[]};function mat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}mat.isMDXComponent=!0;const dat={toc:[]};function hat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}hat.isMDXComponent=!0;const fat={toc:[]};function kat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}kat.isMDXComponent=!0;const yat={toc:[]};function wat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}wat.isMDXComponent=!0;const Dat={toc:[]};function Mat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Mat.isMDXComponent=!0;const Xat={toc:[]};function _at(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}_at.isMDXComponent=!0;const gat={toc:[]};function Tat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Tat.isMDXComponent=!0;const Cat={toc:[]};function xat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}xat.isMDXComponent=!0;const vat={toc:[]};function Lat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Lat.isMDXComponent=!0;const Zat={toc:[]};function bat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}bat.isMDXComponent=!0;const Nat={toc:[]};function zat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}zat.isMDXComponent=!0;const Aat={toc:[]};function Wat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Wat.isMDXComponent=!0;const Iat={toc:[]};function Rat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Rat.isMDXComponent=!0;const Pat={toc:[]};function Sat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Sat.isMDXComponent=!0;const Oat={toc:[]};function Eat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Eat.isMDXComponent=!0;const Bat={toc:[]};function Gat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Gat.isMDXComponent=!0;const Vat={toc:[]};function Uat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}Uat.isMDXComponent=!0;const Fat={toc:[]};function qat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}qat.isMDXComponent=!0;const jat={toc:[]};function Yat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}Yat.isMDXComponent=!0;const Hat={toc:[]};function Qat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}Qat.isMDXComponent=!0;const $at={toc:[]};function Kat(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$at,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Kat.isMDXComponent=!0;const Jat={toc:[]};function tlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}tlt.isMDXComponent=!0;const elt={toc:[]};function nlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},elt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}nlt.isMDXComponent=!0;const olt={toc:[]};function plt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},olt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}plt.isMDXComponent=!0;const rlt={toc:[]};function slt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}slt.isMDXComponent=!0;const clt={toc:[]};function ilt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},clt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}ilt.isMDXComponent=!0;const alt={toc:[]};function llt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},alt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}llt.isMDXComponent=!0;const ult={toc:[]};function mlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ult,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}mlt.isMDXComponent=!0;const dlt={toc:[]};function hlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}hlt.isMDXComponent=!0;const flt={toc:[]};function klt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},flt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}klt.isMDXComponent=!0;const ylt={toc:[]};function wlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ylt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}wlt.isMDXComponent=!0;const Dlt={toc:[]};function Mlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Mlt.isMDXComponent=!0;const Xlt={toc:[]};function _lt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}_lt.isMDXComponent=!0;const glt={toc:[]};function Tlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},glt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Tlt.isMDXComponent=!0;const Clt={toc:[]};function xlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Clt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}xlt.isMDXComponent=!0;const vlt={toc:[]};function Llt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Llt.isMDXComponent=!0;const Zlt={toc:[]};function blt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}blt.isMDXComponent=!0;const Nlt={toc:[]};function zlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}zlt.isMDXComponent=!0;const Alt={toc:[]};function Wlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Alt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Wlt.isMDXComponent=!0;const Ilt={toc:[]};function Rlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ilt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Rlt.isMDXComponent=!0;const Plt={toc:[]};function Slt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Plt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Slt.isMDXComponent=!0;const Olt={toc:[]};function Elt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Olt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Elt.isMDXComponent=!0;const Blt={toc:[]};function Glt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Blt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Glt.isMDXComponent=!0;const Vlt={toc:[]};function Ult(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Ult.isMDXComponent=!0;const Flt={toc:[]};function qlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Flt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}qlt.isMDXComponent=!0;const jlt={toc:[]};function Ylt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Ylt.isMDXComponent=!0;const Hlt={toc:[]};function Qlt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Qlt.isMDXComponent=!0;const $lt={toc:[]};function Klt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Klt.isMDXComponent=!0;const Jlt={toc:[]};function tut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}tut.isMDXComponent=!0;const eut={toc:[]};function nut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}nut.isMDXComponent=!0;const out={toc:[]};function put(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},out,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}put.isMDXComponent=!0;const rut={toc:[]};function sut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}sut.isMDXComponent=!0;const cut={toc:[]};function iut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}iut.isMDXComponent=!0;const aut={toc:[]};function lut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}lut.isMDXComponent=!0;const uut={toc:[]};function mut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}mut.isMDXComponent=!0;const dut={toc:[]};function hut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}hut.isMDXComponent=!0;const fut={toc:[]};function kut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}kut.isMDXComponent=!0;const yut={toc:[]};function wut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}wut.isMDXComponent=!0;const Dut={toc:[]};function Mut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Mut.isMDXComponent=!0;const Xut={toc:[]};function _ut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}_ut.isMDXComponent=!0;const gut={toc:[]};function Tut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Tut.isMDXComponent=!0;const Cut={toc:[]};function xut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}xut.isMDXComponent=!0;const vut={toc:[]};function Lut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}Lut.isMDXComponent=!0;const Zut={toc:[]};function but(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}but.isMDXComponent=!0;const Nut={toc:[]};function zut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}zut.isMDXComponent=!0;const Aut={toc:[]};function Wut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Wut.isMDXComponent=!0;const Iut={toc:[]};function Rut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Rut.isMDXComponent=!0;const Put={toc:[]};function Sut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Put,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Sut.isMDXComponent=!0;const Out={toc:[]};function Eut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Out,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Eut.isMDXComponent=!0;const But={toc:[]};function Gut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},But,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Gut.isMDXComponent=!0;const Vut={toc:[]};function Uut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Uut.isMDXComponent=!0;const Fut={toc:[]};function qut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}qut.isMDXComponent=!0;const jut={toc:[]};function Yut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Yut.isMDXComponent=!0;const Hut={toc:[]};function Qut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Qut.isMDXComponent=!0;const $ut={toc:[]};function Kut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Kut.isMDXComponent=!0;const Jut={toc:[]};function tmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}tmt.isMDXComponent=!0;const emt={toc:[]};function nmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},emt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}nmt.isMDXComponent=!0;const omt={toc:[]};function pmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},omt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}pmt.isMDXComponent=!0;const rmt={toc:[]};function smt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}smt.isMDXComponent=!0;const cmt={toc:[]};function imt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}imt.isMDXComponent=!0;const amt={toc:[]};function lmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},amt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}lmt.isMDXComponent=!0;const umt={toc:[]};function mmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},umt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}mmt.isMDXComponent=!0;const dmt={toc:[]};function hmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}hmt.isMDXComponent=!0;const fmt={toc:[]};function kmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}kmt.isMDXComponent=!0;const ymt={toc:[]};function wmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ymt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}wmt.isMDXComponent=!0;const Dmt={toc:[]};function Mmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Mmt.isMDXComponent=!0;const Xmt={toc:[]};function _mt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}_mt.isMDXComponent=!0;const gmt={toc:[]};function Tmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Tmt.isMDXComponent=!0;const Cmt={toc:[]};function xmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}xmt.isMDXComponent=!0;const vmt={toc:[]};function Lmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Lmt.isMDXComponent=!0;const Zmt={toc:[]};function bmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}bmt.isMDXComponent=!0;const Nmt={toc:[]};function zmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}zmt.isMDXComponent=!0;const Amt={toc:[]};function Wmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Amt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Wmt.isMDXComponent=!0;const Imt={toc:[]};function Rmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Imt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Rmt.isMDXComponent=!0;const Pmt={toc:[]};function Smt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Smt.isMDXComponent=!0;const Omt={toc:[]};function Emt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Omt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Emt.isMDXComponent=!0;const Bmt={toc:[]};function Gmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Gmt.isMDXComponent=!0;const Vmt={toc:[]};function Umt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Umt.isMDXComponent=!0;const Fmt={toc:[]};function qmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}qmt.isMDXComponent=!0;const jmt={toc:[]};function Ymt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Ymt.isMDXComponent=!0;const Hmt={toc:[]};function Qmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Qmt.isMDXComponent=!0;const $mt={toc:[]};function Kmt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Kmt.isMDXComponent=!0;const Jmt={toc:[]};function tdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}tdt.isMDXComponent=!0;const edt={toc:[]};function ndt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},edt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}ndt.isMDXComponent=!0;const odt={toc:[]};function pdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},odt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}pdt.isMDXComponent=!0;const rdt={toc:[]};function sdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}sdt.isMDXComponent=!0;const cdt={toc:[]};function idt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node representing a knot of a ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}idt.isMDXComponent=!0;const adt={toc:[]};function ldt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},adt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}ldt.isMDXComponent=!0;const udt={toc:[]};function mdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},udt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}mdt.isMDXComponent=!0;const ddt={toc:[]};function hdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ddt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}hdt.isMDXComponent=!0;const fdt={toc:[]};function kdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}kdt.isMDXComponent=!0;const ydt={toc:[]};function wdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ydt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wdt.isMDXComponent=!0;const Ddt={toc:[]};function Mdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ddt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Mdt.isMDXComponent=!0;const Xdt={toc:[]};function _dt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}_dt.isMDXComponent=!0;const gdt={toc:[]};function Tdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}Tdt.isMDXComponent=!0;const Cdt={toc:[]};function xdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}xdt.isMDXComponent=!0;const vdt={toc:[]};function Ldt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Ldt.isMDXComponent=!0;const Zdt={toc:[]};function bdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the startHandle."))}bdt.isMDXComponent=!0;const Ndt={toc:[]};function zdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ndt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}zdt.isMDXComponent=!0;const Adt={toc:[]};function Wdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Adt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Wdt.isMDXComponent=!0;const Idt={toc:[]};function Rdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Idt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Rdt.isMDXComponent=!0;const Pdt={toc:[]};function Sdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Sdt.isMDXComponent=!0;const Odt={toc:[]};function Edt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Odt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Edt.isMDXComponent=!0;const Bdt={toc:[]};function Gdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Gdt.isMDXComponent=!0;const Vdt={toc:[]};function Udt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Udt.isMDXComponent=!0;const Fdt={toc:[]};function qdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}qdt.isMDXComponent=!0;const jdt={toc:[]};function Ydt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Ydt.isMDXComponent=!0;const Hdt={toc:[]};function Qdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the endHandle."))}Qdt.isMDXComponent=!0;const $dt={toc:[]};function Kdt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}Kdt.isMDXComponent=!0;const Jdt={toc:[]};function tht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}tht.isMDXComponent=!0;const eht={toc:[]};function nht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}nht.isMDXComponent=!0;const oht={toc:[]};function pht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}pht.isMDXComponent=!0;const rht={toc:[]};function sht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}sht.isMDXComponent=!0;const cht={toc:[]};function iht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}iht.isMDXComponent=!0;const aht={toc:[]};function lht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}lht.isMDXComponent=!0;const uht={toc:[]};function mht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}mht.isMDXComponent=!0;const dht={toc:[]};function hht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}hht.isMDXComponent=!0;const fht={toc:[]};function kht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}kht.isMDXComponent=!0;const yht={toc:[]};function wht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wht.isMDXComponent=!0;const Dht={toc:[]};function Mht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Mht.isMDXComponent=!0;const Xht={toc:[]};function _ht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}_ht.isMDXComponent=!0;const ght={toc:[]};function Tht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ght,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Tht.isMDXComponent=!0;const Cht={toc:[]};function xht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}xht.isMDXComponent=!0;const vht={toc:[]};function Lht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Lht.isMDXComponent=!0;const Zht={toc:[]};function bht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}bht.isMDXComponent=!0;const Nht={toc:[]};function zht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}zht.isMDXComponent=!0;const Aht={toc:[]};function Wht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Wht.isMDXComponent=!0;const Iht={toc:[]};function Rht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Rht.isMDXComponent=!0;const Pht={toc:[]};function Sht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Sht.isMDXComponent=!0;const Oht={toc:[]};function Eht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Eht.isMDXComponent=!0;const Bht={toc:[]};function Ght(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Ght.isMDXComponent=!0;const Vht={toc:[]};function Uht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Uht.isMDXComponent=!0;const Fht={toc:[]};function qht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}qht.isMDXComponent=!0;const jht={toc:[]};function Yht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Yht.isMDXComponent=!0;const Hht={toc:[]};function Qht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Qht.isMDXComponent=!0;const $ht={toc:[]};function Kht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Kht.isMDXComponent=!0;const Jht={toc:[]};function tft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}tft.isMDXComponent=!0;const eft={toc:[]};function nft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}nft.isMDXComponent=!0;const oft={toc:[]};function pft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}pft.isMDXComponent=!0;const rft={toc:[]};function sft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}sft.isMDXComponent=!0;const cft={toc:[]};function ift(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}ift.isMDXComponent=!0;const aft={toc:[]};function lft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}lft.isMDXComponent=!0;const uft={toc:[]};function mft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}mft.isMDXComponent=!0;const dft={toc:[]};function hft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}hft.isMDXComponent=!0;const fft={toc:[]};function kft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}kft.isMDXComponent=!0;const yft={toc:[]};function wft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}wft.isMDXComponent=!0;const Dft={toc:[]};function Mft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Mft.isMDXComponent=!0;const Xft={toc:[]};function _ft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}_ft.isMDXComponent=!0;const gft={toc:[]};function Tft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Tft.isMDXComponent=!0;const Cft={toc:[]};function xft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}xft.isMDXComponent=!0;const vft={toc:[]};function Lft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Lft.isMDXComponent=!0;const Zft={toc:[]};function bft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}bft.isMDXComponent=!0;const Nft={toc:[]};function zft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}zft.isMDXComponent=!0;const Aft={toc:[]};function Wft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Wft.isMDXComponent=!0;const Ift={toc:[]};function Rft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ift,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Rft.isMDXComponent=!0;const Pft={toc:[]};function Sft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Sft.isMDXComponent=!0;const Oft={toc:[]};function Eft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Eft.isMDXComponent=!0;const Bft={toc:[]};function Gft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Gft.isMDXComponent=!0;const Vft={toc:[]};function Uft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Uft.isMDXComponent=!0;const Fft={toc:[]};function qft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}qft.isMDXComponent=!0;const jft={toc:[]};function Yft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Yft.isMDXComponent=!0;const Hft={toc:[]};function Qft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Qft.isMDXComponent=!0;const $ft={toc:[]};function Kft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Kft.isMDXComponent=!0;const Jft={toc:[]};function tkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}tkt.isMDXComponent=!0;const ekt={toc:[]};function nkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ekt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}nkt.isMDXComponent=!0;const okt={toc:[]};function pkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},okt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}pkt.isMDXComponent=!0;const rkt={toc:[]};function skt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}skt.isMDXComponent=!0;const ckt={toc:[]};function ikt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ckt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}ikt.isMDXComponent=!0;const akt={toc:[]};function lkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},akt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}lkt.isMDXComponent=!0;const ukt={toc:[]};function mkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ukt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}mkt.isMDXComponent=!0;const dkt={toc:[]};function hkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}hkt.isMDXComponent=!0;const fkt={toc:[]};function kkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}kkt.isMDXComponent=!0;const ykt={toc:[]};function wkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ykt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}wkt.isMDXComponent=!0;const Dkt={toc:[]};function Mkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Mkt.isMDXComponent=!0;const Xkt={toc:[]};function _kt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}_kt.isMDXComponent=!0;const gkt={toc:[]};function Tkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Tkt.isMDXComponent=!0;const Ckt={toc:[]};function xkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ckt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}xkt.isMDXComponent=!0;const vkt={toc:[]};function Lkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Lkt.isMDXComponent=!0;const Zkt={toc:[]};function bkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}bkt.isMDXComponent=!0;const Nkt={toc:[]};function zkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}zkt.isMDXComponent=!0;const Akt={toc:[]};function Wkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Akt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Wkt.isMDXComponent=!0;const Ikt={toc:[]};function Rkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ikt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Rkt.isMDXComponent=!0;const Pkt={toc:[]};function Skt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Skt.isMDXComponent=!0;const Okt={toc:[]};function Ekt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Okt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Ekt.isMDXComponent=!0;const Bkt={toc:[]};function Gkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Gkt.isMDXComponent=!0;const Vkt={toc:[]};function Ukt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Ukt.isMDXComponent=!0;const Fkt={toc:[]};function qkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}qkt.isMDXComponent=!0;const jkt={toc:[]};function Ykt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Ykt.isMDXComponent=!0;const Hkt={toc:[]};function Qkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Qkt.isMDXComponent=!0;const $kt={toc:[]};function Kkt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Kkt.isMDXComponent=!0;const Jkt={toc:[]};function tyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}tyt.isMDXComponent=!0;const eyt={toc:[]};function nyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}nyt.isMDXComponent=!0;const oyt={toc:[]};function pyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}pyt.isMDXComponent=!0;const ryt={toc:[]};function syt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ryt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}syt.isMDXComponent=!0;const cyt={toc:[]};function iyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}iyt.isMDXComponent=!0;const ayt={toc:[]};function lyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ayt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lyt.isMDXComponent=!0;const uyt={toc:[]};function myt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}myt.isMDXComponent=!0;const dyt={toc:[]};function hyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}hyt.isMDXComponent=!0;const fyt={toc:[]};function kyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}kyt.isMDXComponent=!0;const yyt={toc:[]};function wyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}wyt.isMDXComponent=!0;const Dyt={toc:[]};function Myt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Myt.isMDXComponent=!0;const Xyt={toc:[]};function _yt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}_yt.isMDXComponent=!0;const gyt={toc:[]};function Tyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Tyt.isMDXComponent=!0;const Cyt={toc:[]};function xyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}xyt.isMDXComponent=!0;const vyt={toc:[]};function Lyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Lyt.isMDXComponent=!0;const Zyt={toc:[]};function byt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Latex, makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Latex\n      // Note how this uses \\color to set the color.\n      tex=\"{\\color{white} ax^2+bx+c=0 \\implies x=\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}}\"\n      width={600} // height and width can calculate based on each other\n    />,\n  );\n});\n")))}byt.isMDXComponent=!0;const Nyt={toc:[]};function zyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for rendering equations with LaTeX."))}zyt.isMDXComponent=!0;const Ayt={toc:[]};function Wyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ayt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Wyt.isMDXComponent=!0;const Iyt={toc:[]};function Ryt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Ryt.isMDXComponent=!0;const Pyt={toc:[]};function Syt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Syt.isMDXComponent=!0;const Oyt={toc:[]};function Eyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Eyt.isMDXComponent=!0;const Byt={toc:[]};function Gyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Byt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Gyt.isMDXComponent=!0;const Vyt={toc:[]};function Uyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Uyt.isMDXComponent=!0;const Fyt={toc:[]};function qyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}qyt.isMDXComponent=!0;const jyt={toc:[]};function Yyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Yyt.isMDXComponent=!0;const Hyt={toc:[]};function Qyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Qyt.isMDXComponent=!0;const $yt={toc:[]};function Kyt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Kyt.isMDXComponent=!0;const Jyt={toc:[]};function twt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}twt.isMDXComponent=!0;const ewt={toc:[]};function nwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ewt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}nwt.isMDXComponent=!0;const owt={toc:[]};function pwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},owt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}pwt.isMDXComponent=!0;const rwt={toc:[]};function swt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}swt.isMDXComponent=!0;const cwt={toc:[]};function iwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}iwt.isMDXComponent=!0;const awt={toc:[]};function lwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lwt.isMDXComponent=!0;const uwt={toc:[]};function mwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}mwt.isMDXComponent=!0;const dwt={toc:[]};function hwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}hwt.isMDXComponent=!0;const fwt={toc:[]};function kwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}kwt.isMDXComponent=!0;const ywt={toc:[]};function wwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ywt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}wwt.isMDXComponent=!0;const Dwt={toc:[]};function Mwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Mwt.isMDXComponent=!0;const Xwt={toc:[]};function _wt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}_wt.isMDXComponent=!0;const gwt={toc:[]};function Twt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Twt.isMDXComponent=!0;const Cwt={toc:[]};function xwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xwt.isMDXComponent=!0;const vwt={toc:[]};function Lwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Lwt.isMDXComponent=!0;const Zwt={toc:[]};function bwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}bwt.isMDXComponent=!0;const Nwt={toc:[]};function zwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}zwt.isMDXComponent=!0;const Awt={toc:[]};function Wwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Wwt.isMDXComponent=!0;const Iwt={toc:[]};function Rwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Rwt.isMDXComponent=!0;const Pwt={toc:[]};function Swt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Swt.isMDXComponent=!0;const Owt={toc:[]};function Ewt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Owt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Ewt.isMDXComponent=!0;const Bwt={toc:[]};function Gwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Gwt.isMDXComponent=!0;const Vwt={toc:[]};function Uwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Uwt.isMDXComponent=!0;const Fwt={toc:[]};function qwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}qwt.isMDXComponent=!0;const jwt={toc:[]};function Ywt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Ywt.isMDXComponent=!0;const Hwt={toc:[]};function Qwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Qwt.isMDXComponent=!0;const $wt={toc:[]};function Kwt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Kwt.isMDXComponent=!0;const Jwt={toc:[]};function tDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}tDt.isMDXComponent=!0;const eDt={toc:[]};function nDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}nDt.isMDXComponent=!0;const oDt={toc:[]};function pDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}pDt.isMDXComponent=!0;const rDt={toc:[]};function sDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}sDt.isMDXComponent=!0;const cDt={toc:[]};function iDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}iDt.isMDXComponent=!0;const aDt={toc:[]};function lDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}lDt.isMDXComponent=!0;const uDt={toc:[]};function mDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}mDt.isMDXComponent=!0;const dDt={toc:[]};function hDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}hDt.isMDXComponent=!0;const fDt={toc:[]};function kDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}kDt.isMDXComponent=!0;const yDt={toc:[]};function wDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}wDt.isMDXComponent=!0;const DDt={toc:[]};function MDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}MDt.isMDXComponent=!0;const XDt={toc:[]};function _Dt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}_Dt.isMDXComponent=!0;const gDt={toc:[]};function TDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}TDt.isMDXComponent=!0;const CDt={toc:[]};function xDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}xDt.isMDXComponent=!0;const vDt={toc:[]};function LDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}LDt.isMDXComponent=!0;const ZDt={toc:[]};function bDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}bDt.isMDXComponent=!0;const NDt={toc:[]};function zDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}zDt.isMDXComponent=!0;const ADt={toc:[]};function WDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}WDt.isMDXComponent=!0;const IDt={toc:[]};function RDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}RDt.isMDXComponent=!0;const PDt={toc:[]};function SDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}SDt.isMDXComponent=!0;const ODt={toc:[]};function EDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ODt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}EDt.isMDXComponent=!0;const BDt={toc:[]};function GDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}GDt.isMDXComponent=!0;const VDt={toc:[]};function UDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}UDt.isMDXComponent=!0;const FDt={toc:[]};function qDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}qDt.isMDXComponent=!0;const jDt={toc:[]};function YDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}YDt.isMDXComponent=!0;const HDt={toc:[]};function QDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}QDt.isMDXComponent=!0;const $Dt={toc:[]};function KDt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}KDt.isMDXComponent=!0;const JDt={toc:[]};function tMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}tMt.isMDXComponent=!0;const eMt={toc:[]};function nMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}nMt.isMDXComponent=!0;const oMt={toc:[]};function pMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}pMt.isMDXComponent=!0;const rMt={toc:[]};function sMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}sMt.isMDXComponent=!0;const cMt={toc:[]};function iMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}iMt.isMDXComponent=!0;const aMt={toc:[]};function lMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}lMt.isMDXComponent=!0;const uMt={toc:[]};function mMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}mMt.isMDXComponent=!0;const dMt={toc:[]};function hMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}hMt.isMDXComponent=!0;const fMt={toc:[]};function kMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}kMt.isMDXComponent=!0;const yMt={toc:[]};function wMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}wMt.isMDXComponent=!0;const DMt={toc:[]};function MMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}MMt.isMDXComponent=!0;const XMt={toc:[]};function _Mt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}_Mt.isMDXComponent=!0;const gMt={toc:[]};function TMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}TMt.isMDXComponent=!0;const CMt={toc:[]};function xMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}xMt.isMDXComponent=!0;const vMt={toc:[]};function LMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}LMt.isMDXComponent=!0;const ZMt={toc:[]};function bMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}bMt.isMDXComponent=!0;const NMt={toc:[]};function zMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}zMt.isMDXComponent=!0;const AMt={toc:[]};function WMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}WMt.isMDXComponent=!0;const IMt={toc:[]};function RMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}RMt.isMDXComponent=!0;const PMt={toc:[]};function SMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}SMt.isMDXComponent=!0;const OMt={toc:[]};function EMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}EMt.isMDXComponent=!0;const BMt={toc:[]};function GMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}GMt.isMDXComponent=!0;const VMt={toc:[]};function UMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}UMt.isMDXComponent=!0;const FMt={toc:[]};function qMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}qMt.isMDXComponent=!0;const jMt={toc:[]};function YMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}YMt.isMDXComponent=!0;const HMt={toc:[]};function QMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}QMt.isMDXComponent=!0;const $Mt={toc:[]};function KMt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}KMt.isMDXComponent=!0;const JMt={toc:[]};function tXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}tXt.isMDXComponent=!0;const eXt={toc:[]};function nXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}nXt.isMDXComponent=!0;const oXt={toc:[]};function pXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}pXt.isMDXComponent=!0;const rXt={toc:[]};function sXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}sXt.isMDXComponent=!0;const cXt={toc:[]};function iXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}iXt.isMDXComponent=!0;const aXt={toc:[]};function lXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}lXt.isMDXComponent=!0;const uXt={toc:[]};function mXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}mXt.isMDXComponent=!0;const dXt={toc:[]};function hXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}hXt.isMDXComponent=!0;const fXt={toc:[]};function kXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}kXt.isMDXComponent=!0;const yXt={toc:[]};function wXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wXt.isMDXComponent=!0;const DXt={toc:[]};function MXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}MXt.isMDXComponent=!0;const XXt={toc:[]};function _Xt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}_Xt.isMDXComponent=!0;const gXt={toc:[]};function TXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}TXt.isMDXComponent=!0;const CXt={toc:[]};function xXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}xXt.isMDXComponent=!0;const vXt={toc:[]};function LXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}LXt.isMDXComponent=!0;const ZXt={toc:[]};function bXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}bXt.isMDXComponent=!0;const NXt={toc:[]};function zXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}zXt.isMDXComponent=!0;const AXt={toc:[]};function WXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}WXt.isMDXComponent=!0;const IXt={toc:[]};function RXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}RXt.isMDXComponent=!0;const PXt={toc:[]};function SXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}SXt.isMDXComponent=!0;const OXt={toc:[]};function EXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}EXt.isMDXComponent=!0;const BXt={toc:[]};function GXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}GXt.isMDXComponent=!0;const VXt={toc:[]};function UXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}UXt.isMDXComponent=!0;const FXt={toc:[]};function qXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}qXt.isMDXComponent=!0;const jXt={toc:[]};function YXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}YXt.isMDXComponent=!0;const HXt={toc:[]};function QXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}QXt.isMDXComponent=!0;const $Xt={toc:[]};function KXt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}KXt.isMDXComponent=!0;const JXt={toc:[]};function t_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}t_t.isMDXComponent=!0;const e_t={toc:[]};function n_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}n_t.isMDXComponent=!0;const o_t={toc:[]};function p_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}p_t.isMDXComponent=!0;const r_t={toc:[]};function s_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}s_t.isMDXComponent=!0;const c_t={toc:[]};function i_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}i_t.isMDXComponent=!0;const a_t={toc:[]};function l_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}l_t.isMDXComponent=!0;const u_t={toc:[]};function m_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}m_t.isMDXComponent=!0;const d_t={toc:[]};function h_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}h_t.isMDXComponent=!0;const f_t={toc:[]};function k_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}k_t.isMDXComponent=!0;const y_t={toc:[]};function w_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}w_t.isMDXComponent=!0;const D_t={toc:[]};function M_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}M_t.isMDXComponent=!0;const X_t={toc:[]};function __t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}__t.isMDXComponent=!0;const g_t={toc:[]};function T_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}T_t.isMDXComponent=!0;const C_t={toc:[]};function x_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}x_t.isMDXComponent=!0;const v_t={toc:[]};function L_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}L_t.isMDXComponent=!0;const Z_t={toc:[]};function b_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}b_t.isMDXComponent=!0;const N_t={toc:[]};function z_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}z_t.isMDXComponent=!0;const A_t={toc:[]};function W_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}W_t.isMDXComponent=!0;const I_t={toc:[]};function R_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}R_t.isMDXComponent=!0;const P_t={toc:[]};function S_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}S_t.isMDXComponent=!0;const O_t={toc:[]};function E_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}E_t.isMDXComponent=!0;const B_t={toc:[]};function G_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}G_t.isMDXComponent=!0;const V_t={toc:[]};function U_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}U_t.isMDXComponent=!0;const F_t={toc:[]};function q_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}q_t.isMDXComponent=!0;const j_t={toc:[]};function Y_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Y_t.isMDXComponent=!0;const H_t={toc:[]};function Q_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Q_t.isMDXComponent=!0;const $_t={toc:[]};function K_t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}K_t.isMDXComponent=!0;const J_t={toc:[]};function tgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}tgt.isMDXComponent=!0;const egt={toc:[]};function ngt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},egt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}ngt.isMDXComponent=!0;const ogt={toc:[]};function pgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ogt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}pgt.isMDXComponent=!0;const rgt={toc:[]};function sgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}sgt.isMDXComponent=!0;const cgt={toc:[]};function igt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}igt.isMDXComponent=!0;const agt={toc:[]};function lgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},agt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}lgt.isMDXComponent=!0;const ugt={toc:[]};function mgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ugt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}mgt.isMDXComponent=!0;const dgt={toc:[]};function hgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}hgt.isMDXComponent=!0;const fgt={toc:[]};function kgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}kgt.isMDXComponent=!0;const ygt={toc:[]};function wgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ygt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}wgt.isMDXComponent=!0;const Dgt={toc:[]};function Mgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Mgt.isMDXComponent=!0;const Xgt={toc:[]};function _gt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}_gt.isMDXComponent=!0;const ggt={toc:[]};function Tgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ggt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Tgt.isMDXComponent=!0;const Cgt={toc:[]};function xgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}xgt.isMDXComponent=!0;const vgt={toc:[]};function Lgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Lgt.isMDXComponent=!0;const Zgt={toc:[]};function bgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bgt.isMDXComponent=!0;const Ngt={toc:[]};function zgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ngt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}zgt.isMDXComponent=!0;const Agt={toc:[]};function Wgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Agt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Wgt.isMDXComponent=!0;const Igt={toc:[]};function Rgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Igt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Rgt.isMDXComponent=!0;const Pgt={toc:[]};function Sgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Sgt.isMDXComponent=!0;const Ogt={toc:[]};function Egt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ogt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Egt.isMDXComponent=!0;const Bgt={toc:[]};function Ggt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Ggt.isMDXComponent=!0;const Vgt={toc:[]};function Ugt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Ugt.isMDXComponent=!0;const Fgt={toc:[]};function qgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}qgt.isMDXComponent=!0;const jgt={toc:[]};function Ygt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Ygt.isMDXComponent=!0;const Hgt={toc:[]};function Qgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Qgt.isMDXComponent=!0;const $gt={toc:[]};function Kgt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Kgt.isMDXComponent=!0;const Jgt={toc:[]};function tTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}tTt.isMDXComponent=!0;const eTt={toc:[]};function nTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}nTt.isMDXComponent=!0;const oTt={toc:[]};function pTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}pTt.isMDXComponent=!0;const rTt={toc:[]};function sTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}sTt.isMDXComponent=!0;const cTt={toc:[]};function iTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}iTt.isMDXComponent=!0;const aTt={toc:[]};function lTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}lTt.isMDXComponent=!0;const uTt={toc:[]};function mTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}mTt.isMDXComponent=!0;const dTt={toc:[]};function hTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}hTt.isMDXComponent=!0;const fTt={toc:[]};function kTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}kTt.isMDXComponent=!0;const yTt={toc:[]};function wTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}wTt.isMDXComponent=!0;const DTt={toc:[]};function MTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}MTt.isMDXComponent=!0;const XTt={toc:[]};function _Tt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}_Tt.isMDXComponent=!0;const gTt={toc:[]};function TTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}TTt.isMDXComponent=!0;const CTt={toc:[]};function xTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}xTt.isMDXComponent=!0;const vTt={toc:[]};function LTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}LTt.isMDXComponent=!0;const ZTt={toc:[]};function bTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}bTt.isMDXComponent=!0;const NTt={toc:[]};function zTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}zTt.isMDXComponent=!0;const ATt={toc:[]};function WTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ATt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}WTt.isMDXComponent=!0;const ITt={toc:[]};function RTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ITt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}RTt.isMDXComponent=!0;const PTt={toc:[]};function STt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}STt.isMDXComponent=!0;const OTt={toc:[]};function ETt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}ETt.isMDXComponent=!0;const BTt={toc:[]};function GTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}GTt.isMDXComponent=!0;const VTt={toc:[]};function UTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}UTt.isMDXComponent=!0;const FTt={toc:[]};function qTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}qTt.isMDXComponent=!0;const jTt={toc:[]};function YTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}YTt.isMDXComponent=!0;const HTt={toc:[]};function QTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}QTt.isMDXComponent=!0;const $Tt={toc:[]};function KTt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Tt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}KTt.isMDXComponent=!0;const JTt={toc:[]};function tCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}tCt.isMDXComponent=!0;const eCt={toc:[]};function nCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}nCt.isMDXComponent=!0;const oCt={toc:[]};function pCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}pCt.isMDXComponent=!0;const rCt={toc:[]};function sCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}sCt.isMDXComponent=!0;const cCt={toc:[]};function iCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}iCt.isMDXComponent=!0;const aCt={toc:[]};function lCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}lCt.isMDXComponent=!0;const uCt={toc:[]};function mCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}mCt.isMDXComponent=!0;const dCt={toc:[]};function hCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}hCt.isMDXComponent=!0;const fCt={toc:[]};function kCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kCt.isMDXComponent=!0;const yCt={toc:[]};function wCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}wCt.isMDXComponent=!0;const DCt={toc:[]};function MCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}MCt.isMDXComponent=!0;const XCt={toc:[]};function _Ct(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}_Ct.isMDXComponent=!0;const gCt={toc:[]};function TCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}TCt.isMDXComponent=!0;const CCt={toc:[]};function xCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}xCt.isMDXComponent=!0;const vCt={toc:[]};function LCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}LCt.isMDXComponent=!0;const ZCt={toc:[]};function bCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}bCt.isMDXComponent=!0;const NCt={toc:[]};function zCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}zCt.isMDXComponent=!0;const ACt={toc:[]};function WCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ACt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}WCt.isMDXComponent=!0;const ICt={toc:[]};function RCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ICt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}RCt.isMDXComponent=!0;const PCt={toc:[]};function SCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}SCt.isMDXComponent=!0;const OCt={toc:[]};function ECt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ECt.isMDXComponent=!0;const BCt={toc:[]};function GCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}GCt.isMDXComponent=!0;const VCt={toc:[]};function UCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}UCt.isMDXComponent=!0;const FCt={toc:[]};function qCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}qCt.isMDXComponent=!0;const jCt={toc:[]};function YCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}YCt.isMDXComponent=!0;const HCt={toc:[]};function QCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}QCt.isMDXComponent=!0;const $Ct={toc:[]};function KCt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}KCt.isMDXComponent=!0;const JCt={toc:[]};function txt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}txt.isMDXComponent=!0;const ext={toc:[]};function nxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ext,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}nxt.isMDXComponent=!0;const oxt={toc:[]};function pxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}pxt.isMDXComponent=!0;const rxt={toc:[]};function sxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}sxt.isMDXComponent=!0;const cxt={toc:[]};function ixt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}ixt.isMDXComponent=!0;const axt={toc:[]};function lxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},axt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}lxt.isMDXComponent=!0;const uxt={toc:[]};function mxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}mxt.isMDXComponent=!0;const dxt={toc:[]};function hxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}hxt.isMDXComponent=!0;const fxt={toc:[]};function kxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}kxt.isMDXComponent=!0;const yxt={toc:[]};function wxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}wxt.isMDXComponent=!0;const Dxt={toc:[]};function Mxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Mxt.isMDXComponent=!0;const Xxt={toc:[]};function _xt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}_xt.isMDXComponent=!0;const gxt={toc:[]};function Txt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Txt.isMDXComponent=!0;const Cxt={toc:[]};function xxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}xxt.isMDXComponent=!0;const vxt={toc:[]};function Lxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Lxt.isMDXComponent=!0;const Zxt={toc:[]};function bxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bxt.isMDXComponent=!0;const Nxt={toc:[]};function zxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}zxt.isMDXComponent=!0;const Axt={toc:[]};function Wxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Axt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Wxt.isMDXComponent=!0;const Ixt={toc:[]};function Rxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ixt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Rxt.isMDXComponent=!0;const Pxt={toc:[]};function Sxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Sxt.isMDXComponent=!0;const Oxt={toc:[]};function Ext(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Ext.isMDXComponent=!0;const Bxt={toc:[]};function Gxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Gxt.isMDXComponent=!0;const Vxt={toc:[]};function Uxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Uxt.isMDXComponent=!0;const Fxt={toc:[]};function qxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}qxt.isMDXComponent=!0;const jxt={toc:[]};function Yxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Yxt.isMDXComponent=!0;const Hxt={toc:[]};function Qxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Qxt.isMDXComponent=!0;const $xt={toc:[]};function Kxt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Kxt.isMDXComponent=!0;const Jxt={toc:[]};function tvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}tvt.isMDXComponent=!0;const evt={toc:[]};function nvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},evt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}nvt.isMDXComponent=!0;const ovt={toc:[]};function pvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ovt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}pvt.isMDXComponent=!0;const rvt={toc:[]};function svt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}svt.isMDXComponent=!0;const cvt={toc:[]};function ivt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}ivt.isMDXComponent=!0;const avt={toc:[]};function lvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},avt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lvt.isMDXComponent=!0;const uvt={toc:[]};function mvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}mvt.isMDXComponent=!0;const dvt={toc:[]};function hvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}hvt.isMDXComponent=!0;const fvt={toc:[]};function kvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}kvt.isMDXComponent=!0;const yvt={toc:[]};function wvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}wvt.isMDXComponent=!0;const Dvt={toc:[]};function Mvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Mvt.isMDXComponent=!0;const Xvt={toc:[]};function _vt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}_vt.isMDXComponent=!0;const gvt={toc:[]};function Tvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Tvt.isMDXComponent=!0;const Cvt={toc:[]};function xvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}xvt.isMDXComponent=!0;const vvt={toc:[]};function Lvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Lvt.isMDXComponent=!0;const Zvt={toc:[]};function bvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}bvt.isMDXComponent=!0;const Nvt={toc:[]};function zvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}zvt.isMDXComponent=!0;const Avt={toc:[]};function Wvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Avt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Wvt.isMDXComponent=!0;const Ivt={toc:[]};function Rvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ivt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Rvt.isMDXComponent=!0;const Pvt={toc:[]};function Svt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Svt.isMDXComponent=!0;const Ovt={toc:[]};function Evt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ovt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Evt.isMDXComponent=!0;const Bvt={toc:[]};function Gvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Gvt.isMDXComponent=!0;const Vvt={toc:[]};function Uvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Uvt.isMDXComponent=!0;const Fvt={toc:[]};function qvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}qvt.isMDXComponent=!0;const jvt={toc:[]};function Yvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Yvt.isMDXComponent=!0;const Hvt={toc:[]};function Qvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Qvt.isMDXComponent=!0;const $vt={toc:[]};function Kvt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Kvt.isMDXComponent=!0;const Jvt={toc:[]};function tLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}tLt.isMDXComponent=!0;const eLt={toc:[]};function nLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}nLt.isMDXComponent=!0;const oLt={toc:[]};function pLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}pLt.isMDXComponent=!0;const rLt={toc:[]};function sLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}sLt.isMDXComponent=!0;const cLt={toc:[]};function iLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}iLt.isMDXComponent=!0;const aLt={toc:[]};function lLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}lLt.isMDXComponent=!0;const uLt={toc:[]};function mLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}mLt.isMDXComponent=!0;const dLt={toc:[]};function hLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}hLt.isMDXComponent=!0;const fLt={toc:[]};function kLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}kLt.isMDXComponent=!0;const yLt={toc:[]};function wLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}wLt.isMDXComponent=!0;const DLt={toc:[]};function MLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}MLt.isMDXComponent=!0;const XLt={toc:[]};function _Lt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}_Lt.isMDXComponent=!0;const gLt={toc:[]};function TLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}TLt.isMDXComponent=!0;const CLt={toc:[]};function xLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}xLt.isMDXComponent=!0;const vLt={toc:[]};function LLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}LLt.isMDXComponent=!0;const ZLt={toc:[]};function bLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}bLt.isMDXComponent=!0;const NLt={toc:[]};function zLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}zLt.isMDXComponent=!0;const ALt={toc:[]};function WLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ALt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}WLt.isMDXComponent=!0;const ILt={toc:[]};function RLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ILt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}RLt.isMDXComponent=!0;const PLt={toc:[]};function SLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}SLt.isMDXComponent=!0;const OLt={toc:[]};function ELt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}ELt.isMDXComponent=!0;const BLt={toc:[]};function GLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}GLt.isMDXComponent=!0;const VLt={toc:[]};function ULt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}ULt.isMDXComponent=!0;const FLt={toc:[]};function qLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qLt.isMDXComponent=!0;const jLt={toc:[]};function YLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}YLt.isMDXComponent=!0;const HLt={toc:[]};function QLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}QLt.isMDXComponent=!0;const $Lt={toc:[]};function KLt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}KLt.isMDXComponent=!0;const JLt={toc:[]};function tZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}tZt.isMDXComponent=!0;const eZt={toc:[]};function nZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}nZt.isMDXComponent=!0;const oZt={toc:[]};function pZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}pZt.isMDXComponent=!0;const rZt={toc:[]};function sZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}sZt.isMDXComponent=!0;const cZt={toc:[]};function iZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}iZt.isMDXComponent=!0;const aZt={toc:[]};function lZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}lZt.isMDXComponent=!0;const uZt={toc:[]};function mZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}mZt.isMDXComponent=!0;const dZt={toc:[]};function hZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}hZt.isMDXComponent=!0;const fZt={toc:[]};function kZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}kZt.isMDXComponent=!0;const yZt={toc:[]};function wZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}wZt.isMDXComponent=!0;const DZt={toc:[]};function MZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}MZt.isMDXComponent=!0;const XZt={toc:[]};function _Zt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}_Zt.isMDXComponent=!0;const gZt={toc:[]};function TZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}TZt.isMDXComponent=!0;const CZt={toc:[]};function xZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}xZt.isMDXComponent=!0;const vZt={toc:[]};function LZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}LZt.isMDXComponent=!0;const ZZt={toc:[]};function bZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}bZt.isMDXComponent=!0;const NZt={toc:[]};function zZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}zZt.isMDXComponent=!0;const AZt={toc:[]};function WZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}WZt.isMDXComponent=!0;const IZt={toc:[]};function RZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}RZt.isMDXComponent=!0;const PZt={toc:[]};function SZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}SZt.isMDXComponent=!0;const OZt={toc:[]};function EZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}EZt.isMDXComponent=!0;const BZt={toc:[]};function GZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}GZt.isMDXComponent=!0;const VZt={toc:[]};function UZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}UZt.isMDXComponent=!0;const FZt={toc:[]};function qZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qZt.isMDXComponent=!0;const jZt={toc:[]};function YZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}YZt.isMDXComponent=!0;const HZt={toc:[]};function QZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}QZt.isMDXComponent=!0;const $Zt={toc:[]};function KZt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}KZt.isMDXComponent=!0;const JZt={toc:[]};function tbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}tbt.isMDXComponent=!0;const ebt={toc:[]};function nbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ebt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}nbt.isMDXComponent=!0;const obt={toc:[]};function pbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},obt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}pbt.isMDXComponent=!0;const rbt={toc:[]};function sbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}sbt.isMDXComponent=!0;const cbt={toc:[]};function ibt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}ibt.isMDXComponent=!0;const abt={toc:[]};function lbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},abt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}lbt.isMDXComponent=!0;const ubt={toc:[]};function mbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ubt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}mbt.isMDXComponent=!0;const dbt={toc:[]};function hbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}hbt.isMDXComponent=!0;const fbt={toc:[]};function kbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}kbt.isMDXComponent=!0;const ybt={toc:[]};function wbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ybt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}wbt.isMDXComponent=!0;const Dbt={toc:[]};function Mbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Mbt.isMDXComponent=!0;const Xbt={toc:[]};function _bt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}_bt.isMDXComponent=!0;const gbt={toc:[]};function Tbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Tbt.isMDXComponent=!0;const Cbt={toc:[]};function xbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}xbt.isMDXComponent=!0;const vbt={toc:[]};function Lbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Lbt.isMDXComponent=!0;const Zbt={toc:[]};function bbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}bbt.isMDXComponent=!0;const Nbt={toc:[]};function zbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}zbt.isMDXComponent=!0;const Abt={toc:[]};function Wbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Abt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Wbt.isMDXComponent=!0;const Ibt={toc:[]};function Rbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ibt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Rbt.isMDXComponent=!0;const Pbt={toc:[]};function Sbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Sbt.isMDXComponent=!0;const Obt={toc:[]};function Ebt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Obt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Ebt.isMDXComponent=!0;const Bbt={toc:[]};function Gbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Gbt.isMDXComponent=!0;const Vbt={toc:[]};function Ubt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Ubt.isMDXComponent=!0;const Fbt={toc:[]};function qbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}qbt.isMDXComponent=!0;const jbt={toc:[]};function Ybt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Ybt.isMDXComponent=!0;const Hbt={toc:[]};function Qbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Qbt.isMDXComponent=!0;const $bt={toc:[]};function Kbt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Kbt.isMDXComponent=!0;const Jbt={toc:[]};function tNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}tNt.isMDXComponent=!0;const eNt={toc:[]};function nNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}nNt.isMDXComponent=!0;const oNt={toc:[]};function pNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}pNt.isMDXComponent=!0;const rNt={toc:[]};function sNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}sNt.isMDXComponent=!0;const cNt={toc:[]};function iNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}iNt.isMDXComponent=!0;const aNt={toc:[]};function lNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}lNt.isMDXComponent=!0;const uNt={toc:[]};function mNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}mNt.isMDXComponent=!0;const dNt={toc:[]};function hNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}hNt.isMDXComponent=!0;const fNt={toc:[]};function kNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}kNt.isMDXComponent=!0;const yNt={toc:[]};function wNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}wNt.isMDXComponent=!0;const DNt={toc:[]};function MNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}MNt.isMDXComponent=!0;const XNt={toc:[]};function _Nt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}_Nt.isMDXComponent=!0;const gNt={toc:[]};function TNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}TNt.isMDXComponent=!0;const CNt={toc:[]};function xNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}xNt.isMDXComponent=!0;const vNt={toc:[]};function LNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}LNt.isMDXComponent=!0;const ZNt={toc:[]};function bNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}bNt.isMDXComponent=!0;const NNt={toc:[]};function zNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}zNt.isMDXComponent=!0;const ANt={toc:[]};function WNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ANt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}WNt.isMDXComponent=!0;const INt={toc:[]};function RNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},INt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}RNt.isMDXComponent=!0;const PNt={toc:[]};function SNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}SNt.isMDXComponent=!0;const ONt={toc:[]};function ENt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ONt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}ENt.isMDXComponent=!0;const BNt={toc:[]};function GNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}GNt.isMDXComponent=!0;const VNt={toc:[]};function UNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}UNt.isMDXComponent=!0;const FNt={toc:[]};function qNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}qNt.isMDXComponent=!0;const jNt={toc:[]};function YNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}YNt.isMDXComponent=!0;const HNt={toc:[]};function QNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}QNt.isMDXComponent=!0;const $Nt={toc:[]};function KNt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}KNt.isMDXComponent=!0;const JNt={toc:[]};function tzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}tzt.isMDXComponent=!0;const ezt={toc:[]};function nzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ezt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}nzt.isMDXComponent=!0;const ozt={toc:[]};function pzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ozt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}pzt.isMDXComponent=!0;const rzt={toc:[]};function szt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}szt.isMDXComponent=!0;const czt={toc:[]};function izt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},czt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}izt.isMDXComponent=!0;const azt={toc:[]};function lzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},azt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}lzt.isMDXComponent=!0;const uzt={toc:[]};function mzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}mzt.isMDXComponent=!0;const dzt={toc:[]};function hzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}hzt.isMDXComponent=!0;const fzt={toc:[]};function kzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}kzt.isMDXComponent=!0;const yzt={toc:[]};function wzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}wzt.isMDXComponent=!0;const Dzt={toc:[]};function Mzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Mzt.isMDXComponent=!0;const Xzt={toc:[]};function _zt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}_zt.isMDXComponent=!0;const gzt={toc:[]};function Tzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Tzt.isMDXComponent=!0;const Czt={toc:[]};function xzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Czt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}xzt.isMDXComponent=!0;const vzt={toc:[]};function Lzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Lzt.isMDXComponent=!0;const Zzt={toc:[]};function bzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}bzt.isMDXComponent=!0;const Nzt={toc:[]};function zzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}zzt.isMDXComponent=!0;const Azt={toc:[]};function Wzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Azt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Wzt.isMDXComponent=!0;const Izt={toc:[]};function Rzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Izt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Rzt.isMDXComponent=!0;const Pzt={toc:[]};function Szt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Szt.isMDXComponent=!0;const Ozt={toc:[]};function Ezt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ozt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Ezt.isMDXComponent=!0;const Bzt={toc:[]};function Gzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Gzt.isMDXComponent=!0;const Vzt={toc:[]};function Uzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Uzt.isMDXComponent=!0;const Fzt={toc:[]};function qzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}qzt.isMDXComponent=!0;const jzt={toc:[]};function Yzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Yzt.isMDXComponent=!0;const Hzt={toc:[]};function Qzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Qzt.isMDXComponent=!0;const $zt={toc:[]};function Kzt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$zt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Kzt.isMDXComponent=!0;const Jzt={toc:[]};function tAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}tAt.isMDXComponent=!0;const eAt={toc:[]};function nAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}nAt.isMDXComponent=!0;const oAt={toc:[]};function pAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pAt.isMDXComponent=!0;const rAt={toc:[]};function sAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}sAt.isMDXComponent=!0;const cAt={toc:[]};function iAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}iAt.isMDXComponent=!0;const aAt={toc:[]};function lAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lAt.isMDXComponent=!0;const uAt={toc:[]};function mAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}mAt.isMDXComponent=!0;const dAt={toc:[]};function hAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}hAt.isMDXComponent=!0;const fAt={toc:[]};function kAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kAt.isMDXComponent=!0;const yAt={toc:[]};function wAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}wAt.isMDXComponent=!0;const DAt={toc:[]};function MAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}MAt.isMDXComponent=!0;const XAt={toc:[]};function _At(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}_At.isMDXComponent=!0;const gAt={toc:[]};function TAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}TAt.isMDXComponent=!0;const CAt={toc:[]};function xAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}xAt.isMDXComponent=!0;const vAt={toc:[]};function LAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}LAt.isMDXComponent=!0;const ZAt={toc:[]};function bAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}bAt.isMDXComponent=!0;const NAt={toc:[]};function zAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}zAt.isMDXComponent=!0;const AAt={toc:[]};function WAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}WAt.isMDXComponent=!0;const IAt={toc:[]};function RAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}RAt.isMDXComponent=!0;const PAt={toc:[]};function SAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}SAt.isMDXComponent=!0;const OAt={toc:[]};function EAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}EAt.isMDXComponent=!0;const BAt={toc:[]};function GAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}GAt.isMDXComponent=!0;const VAt={toc:[]};function UAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}UAt.isMDXComponent=!0;const FAt={toc:[]};function qAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}qAt.isMDXComponent=!0;const jAt={toc:[]};function YAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}YAt.isMDXComponent=!0;const HAt={toc:[]};function QAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}QAt.isMDXComponent=!0;const $At={toc:[]};function KAt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$At,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}KAt.isMDXComponent=!0;const JAt={toc:[]};function tWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}tWt.isMDXComponent=!0;const eWt={toc:[]};function nWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}nWt.isMDXComponent=!0;const oWt={toc:[]};function pWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}pWt.isMDXComponent=!0;const rWt={toc:[]};function sWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}sWt.isMDXComponent=!0;const cWt={toc:[]};function iWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}iWt.isMDXComponent=!0;const aWt={toc:[]};function lWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}lWt.isMDXComponent=!0;const uWt={toc:[]};function mWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}mWt.isMDXComponent=!0;const dWt={toc:[]};function hWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}hWt.isMDXComponent=!0;const fWt={toc:[]};function kWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}kWt.isMDXComponent=!0;const yWt={toc:[]};function wWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}wWt.isMDXComponent=!0;const DWt={toc:[]};function MWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}MWt.isMDXComponent=!0;const XWt={toc:[]};function _Wt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}_Wt.isMDXComponent=!0;const gWt={toc:[]};function TWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}TWt.isMDXComponent=!0;const CWt={toc:[]};function xWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}xWt.isMDXComponent=!0;const vWt={toc:[]};function LWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}LWt.isMDXComponent=!0;const ZWt={toc:[]};function bWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}bWt.isMDXComponent=!0;const NWt={toc:[]};function zWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}zWt.isMDXComponent=!0;const AWt={toc:[]};function WWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}WWt.isMDXComponent=!0;const IWt={toc:[]};function RWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}RWt.isMDXComponent=!0;const PWt={toc:[]};function SWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}SWt.isMDXComponent=!0;const OWt={toc:[]};function EWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}EWt.isMDXComponent=!0;const BWt={toc:[]};function GWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}GWt.isMDXComponent=!0;const VWt={toc:[]};function UWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}UWt.isMDXComponent=!0;const FWt={toc:[]};function qWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}qWt.isMDXComponent=!0;const jWt={toc:[]};function YWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}YWt.isMDXComponent=!0;const HWt={toc:[]};function QWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}QWt.isMDXComponent=!0;const $Wt={toc:[]};function KWt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}KWt.isMDXComponent=!0;const JWt={toc:[]};function tIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}tIt.isMDXComponent=!0;const eIt={toc:[]};function nIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}nIt.isMDXComponent=!0;const oIt={toc:[]};function pIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}pIt.isMDXComponent=!0;const rIt={toc:[]};function sIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}sIt.isMDXComponent=!0;const cIt={toc:[]};function iIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}iIt.isMDXComponent=!0;const aIt={toc:[]};function lIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lIt.isMDXComponent=!0;const uIt={toc:[]};function mIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}mIt.isMDXComponent=!0;const dIt={toc:[]};function hIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}hIt.isMDXComponent=!0;const fIt={toc:[]};function kIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}kIt.isMDXComponent=!0;const yIt={toc:[]};function wIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wIt.isMDXComponent=!0;const DIt={toc:[]};function MIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}MIt.isMDXComponent=!0;const XIt={toc:[]};function _It(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}_It.isMDXComponent=!0;const gIt={toc:[]};function TIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}TIt.isMDXComponent=!0;const CIt={toc:[]};function xIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}xIt.isMDXComponent=!0;const vIt={toc:[]};function LIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}LIt.isMDXComponent=!0;const ZIt={toc:[]};function bIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}bIt.isMDXComponent=!0;const NIt={toc:[]};function zIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}zIt.isMDXComponent=!0;const AIt={toc:[]};function WIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}WIt.isMDXComponent=!0;const IIt={toc:[]};function RIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}RIt.isMDXComponent=!0;const PIt={toc:[]};function SIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}SIt.isMDXComponent=!0;const OIt={toc:[]};function EIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}EIt.isMDXComponent=!0;const BIt={toc:[]};function GIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}GIt.isMDXComponent=!0;const VIt={toc:[]};function UIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}UIt.isMDXComponent=!0;const FIt={toc:[]};function qIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}qIt.isMDXComponent=!0;const jIt={toc:[]};function YIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}YIt.isMDXComponent=!0;const HIt={toc:[]};function QIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}QIt.isMDXComponent=!0;const $It={toc:[]};function KIt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$It,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}KIt.isMDXComponent=!0;const JIt={toc:[]};function tRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}tRt.isMDXComponent=!0;const eRt={toc:[]};function nRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}nRt.isMDXComponent=!0;const oRt={toc:[]};function pRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pRt.isMDXComponent=!0;const rRt={toc:[]};function sRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}sRt.isMDXComponent=!0;const cRt={toc:[]};function iRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}iRt.isMDXComponent=!0;const aRt={toc:[]};function lRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lRt.isMDXComponent=!0;const uRt={toc:[]};function mRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}mRt.isMDXComponent=!0;const dRt={toc:[]};function hRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}hRt.isMDXComponent=!0;const fRt={toc:[]};function kRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}kRt.isMDXComponent=!0;const yRt={toc:[]};function wRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}wRt.isMDXComponent=!0;const DRt={toc:[]};function MRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}MRt.isMDXComponent=!0;const XRt={toc:[]};function _Rt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}_Rt.isMDXComponent=!0;const gRt={toc:[]};function TRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}TRt.isMDXComponent=!0;const CRt={toc:[]};function xRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}xRt.isMDXComponent=!0;const vRt={toc:[]};function LRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}LRt.isMDXComponent=!0;const ZRt={toc:[]};function bRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}bRt.isMDXComponent=!0;const NRt={toc:[]};function zRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}zRt.isMDXComponent=!0;const ARt={toc:[]};function WRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ARt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}WRt.isMDXComponent=!0;const IRt={toc:[]};function RRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}RRt.isMDXComponent=!0;const PRt={toc:[]};function SRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}SRt.isMDXComponent=!0;const ORt={toc:[]};function ERt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ORt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ERt.isMDXComponent=!0;const BRt={toc:[]};function GRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}GRt.isMDXComponent=!0;const VRt={toc:[]};function URt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}URt.isMDXComponent=!0;const FRt={toc:[]};function qRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}qRt.isMDXComponent=!0;const jRt={toc:[]};function YRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}YRt.isMDXComponent=!0;const HRt={toc:[]};function QRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}QRt.isMDXComponent=!0;const $Rt={toc:[]};function KRt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Rt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}KRt.isMDXComponent=!0;const JRt={toc:[]};function tPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}tPt.isMDXComponent=!0;const ePt={toc:[]};function nPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ePt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}nPt.isMDXComponent=!0;const oPt={toc:[]};function pPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}pPt.isMDXComponent=!0;const rPt={toc:[]};function sPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}sPt.isMDXComponent=!0;const cPt={toc:[]};function iPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}iPt.isMDXComponent=!0;const aPt={toc:[]};function lPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}lPt.isMDXComponent=!0;const uPt={toc:[]};function mPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}mPt.isMDXComponent=!0;const dPt={toc:[]};function hPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}hPt.isMDXComponent=!0;const fPt={toc:[]};function kPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}kPt.isMDXComponent=!0;const yPt={toc:[]};function wPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wPt.isMDXComponent=!0;const DPt={toc:[]};function MPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}MPt.isMDXComponent=!0;const XPt={toc:[]};function _Pt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}_Pt.isMDXComponent=!0;const gPt={toc:[]};function TPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}TPt.isMDXComponent=!0;const CPt={toc:[]};function xPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}xPt.isMDXComponent=!0;const vPt={toc:[]};function LPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}LPt.isMDXComponent=!0;const ZPt={toc:[]};function bPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}bPt.isMDXComponent=!0;const NPt={toc:[]};function zPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}zPt.isMDXComponent=!0;const APt={toc:[]};function WPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},APt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}WPt.isMDXComponent=!0;const IPt={toc:[]};function RPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}RPt.isMDXComponent=!0;const PPt={toc:[]};function SPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}SPt.isMDXComponent=!0;const OPt={toc:[]};function EPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}EPt.isMDXComponent=!0;const BPt={toc:[]};function GPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}GPt.isMDXComponent=!0;const VPt={toc:[]};function UPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}UPt.isMDXComponent=!0;const FPt={toc:[]};function qPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}qPt.isMDXComponent=!0;const jPt={toc:[]};function YPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}YPt.isMDXComponent=!0;const HPt={toc:[]};function QPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}QPt.isMDXComponent=!0;const $Pt={toc:[]};function KPt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}KPt.isMDXComponent=!0;const JPt={toc:[]};function tSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}tSt.isMDXComponent=!0;const eSt={toc:[]};function nSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}nSt.isMDXComponent=!0;const oSt={toc:[]};function pSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}pSt.isMDXComponent=!0;const rSt={toc:[]};function sSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}sSt.isMDXComponent=!0;const cSt={toc:[]};function iSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}iSt.isMDXComponent=!0;const aSt={toc:[]};function lSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}lSt.isMDXComponent=!0;const uSt={toc:[]};function mSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}mSt.isMDXComponent=!0;const dSt={toc:[]};function hSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}hSt.isMDXComponent=!0;const fSt={toc:[]};function kSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}kSt.isMDXComponent=!0;const ySt={toc:[]};function wSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ySt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}wSt.isMDXComponent=!0;const DSt={toc:[]};function MSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}MSt.isMDXComponent=!0;const XSt={toc:[]};function _St(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}_St.isMDXComponent=!0;const gSt={toc:[]};function TSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}TSt.isMDXComponent=!0;const CSt={toc:[]};function xSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}xSt.isMDXComponent=!0;const vSt={toc:[]};function LSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}LSt.isMDXComponent=!0;const ZSt={toc:[]};function bSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}bSt.isMDXComponent=!0;const NSt={toc:[]};function zSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}zSt.isMDXComponent=!0;const ASt={toc:[]};function WSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ASt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}WSt.isMDXComponent=!0;const ISt={toc:[]};function RSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ISt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}RSt.isMDXComponent=!0;const PSt={toc:[]};function SSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}SSt.isMDXComponent=!0;const OSt={toc:[]};function ESt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}ESt.isMDXComponent=!0;const BSt={toc:[]};function GSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}GSt.isMDXComponent=!0;const VSt={toc:[]};function USt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}USt.isMDXComponent=!0;const FSt={toc:[]};function qSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}qSt.isMDXComponent=!0;const jSt={toc:[]};function YSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}YSt.isMDXComponent=!0;const HSt={toc:[]};function QSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}QSt.isMDXComponent=!0;const $St={toc:[]};function KSt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$St,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}KSt.isMDXComponent=!0;const JSt={toc:[]};function tOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}tOt.isMDXComponent=!0;const eOt={toc:[]};function nOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}nOt.isMDXComponent=!0;const oOt={toc:[]};function pOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}pOt.isMDXComponent=!0;const rOt={toc:[]};function sOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}sOt.isMDXComponent=!0;const cOt={toc:[]};function iOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}iOt.isMDXComponent=!0;const aOt={toc:[]};function lOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}lOt.isMDXComponent=!0;const uOt={toc:[]};function mOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}mOt.isMDXComponent=!0;const dOt={toc:[]};function hOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}hOt.isMDXComponent=!0;const fOt={toc:[]};function kOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}kOt.isMDXComponent=!0;const yOt={toc:[]};function wOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}wOt.isMDXComponent=!0;const DOt={toc:[]};function MOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}MOt.isMDXComponent=!0;const XOt={toc:[]};function _Ot(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}_Ot.isMDXComponent=!0;const gOt={toc:[]};function TOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}TOt.isMDXComponent=!0;const COt={toc:[]};function xOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},COt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}xOt.isMDXComponent=!0;const vOt={toc:[]};function LOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}LOt.isMDXComponent=!0;const ZOt={toc:[]};function bOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}bOt.isMDXComponent=!0;const NOt={toc:[]};function zOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}zOt.isMDXComponent=!0;const AOt={toc:[]};function WOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}WOt.isMDXComponent=!0;const IOt={toc:[]};function ROt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}ROt.isMDXComponent=!0;const POt={toc:[]};function SOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},POt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}SOt.isMDXComponent=!0;const OOt={toc:[]};function EOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}EOt.isMDXComponent=!0;const BOt={toc:[]};function GOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}GOt.isMDXComponent=!0;const VOt={toc:[]};function UOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}UOt.isMDXComponent=!0;const FOt={toc:[]};function qOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}qOt.isMDXComponent=!0;const jOt={toc:[]};function YOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}YOt.isMDXComponent=!0;const HOt={toc:[]};function QOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}QOt.isMDXComponent=!0;const $Ot={toc:[]};function KOt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}KOt.isMDXComponent=!0;const JOt={toc:[]};function tEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}tEt.isMDXComponent=!0;const eEt={toc:[]};function nEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}nEt.isMDXComponent=!0;const oEt={toc:[]};function pEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}pEt.isMDXComponent=!0;const rEt={toc:[]};function sEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}sEt.isMDXComponent=!0;const cEt={toc:[]};function iEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}iEt.isMDXComponent=!0;const aEt={toc:[]};function lEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lEt.isMDXComponent=!0;const uEt={toc:[]};function mEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}mEt.isMDXComponent=!0;const dEt={toc:[]};function hEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}hEt.isMDXComponent=!0;const fEt={toc:[]};function kEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}kEt.isMDXComponent=!0;const yEt={toc:[]};function wEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}wEt.isMDXComponent=!0;const DEt={toc:[]};function MEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}MEt.isMDXComponent=!0;const XEt={toc:[]};function _Et(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}_Et.isMDXComponent=!0;const gEt={toc:[]};function TEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}TEt.isMDXComponent=!0;const CEt={toc:[]};function xEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}xEt.isMDXComponent=!0;const vEt={toc:[]};function LEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}LEt.isMDXComponent=!0;const ZEt={toc:[]};function bEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}bEt.isMDXComponent=!0;const NEt={toc:[]};function zEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}zEt.isMDXComponent=!0;const AEt={toc:[]};function WEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}WEt.isMDXComponent=!0;const IEt={toc:[]};function REt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}REt.isMDXComponent=!0;const PEt={toc:[]};function SEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}SEt.isMDXComponent=!0;const OEt={toc:[]};function EEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}EEt.isMDXComponent=!0;const BEt={toc:[]};function GEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}GEt.isMDXComponent=!0;const VEt={toc:[]};function UEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}UEt.isMDXComponent=!0;const FEt={toc:[]};function qEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qEt.isMDXComponent=!0;const jEt={toc:[]};function YEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}YEt.isMDXComponent=!0;const HEt={toc:[]};function QEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}QEt.isMDXComponent=!0;const $Et={toc:[]};function KEt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}KEt.isMDXComponent=!0;const JEt={toc:[]};function tBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}tBt.isMDXComponent=!0;const eBt={toc:[]};function nBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}nBt.isMDXComponent=!0;const oBt={toc:[]};function pBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}pBt.isMDXComponent=!0;const rBt={toc:[]};function sBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}sBt.isMDXComponent=!0;const cBt={toc:[]};function iBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}iBt.isMDXComponent=!0;const aBt={toc:[]};function lBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}lBt.isMDXComponent=!0;const uBt={toc:[]};function mBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}mBt.isMDXComponent=!0;const dBt={toc:[]};function hBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}hBt.isMDXComponent=!0;const fBt={toc:[]};function kBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}kBt.isMDXComponent=!0;const yBt={toc:[]};function wBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}wBt.isMDXComponent=!0;const DBt={toc:[]};function MBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}MBt.isMDXComponent=!0;const XBt={toc:[]};function _Bt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}_Bt.isMDXComponent=!0;const gBt={toc:[]};function TBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}TBt.isMDXComponent=!0;const CBt={toc:[]};function xBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}xBt.isMDXComponent=!0;const vBt={toc:[]};function LBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}LBt.isMDXComponent=!0;const ZBt={toc:[]};function bBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}bBt.isMDXComponent=!0;const NBt={toc:[]};function zBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}zBt.isMDXComponent=!0;const ABt={toc:[]};function WBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ABt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}WBt.isMDXComponent=!0;const IBt={toc:[]};function RBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}RBt.isMDXComponent=!0;const PBt={toc:[]};function SBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}SBt.isMDXComponent=!0;const OBt={toc:[]};function EBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}EBt.isMDXComponent=!0;const BBt={toc:[]};function GBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}GBt.isMDXComponent=!0;const VBt={toc:[]};function UBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}UBt.isMDXComponent=!0;const FBt={toc:[]};function qBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}qBt.isMDXComponent=!0;const jBt={toc:[]};function YBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}YBt.isMDXComponent=!0;const HBt={toc:[]};function QBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}QBt.isMDXComponent=!0;const $Bt={toc:[]};function KBt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Bt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}KBt.isMDXComponent=!0;const JBt={toc:[]};function tGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}tGt.isMDXComponent=!0;const eGt={toc:[]};function nGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}nGt.isMDXComponent=!0;const oGt={toc:[]};function pGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}pGt.isMDXComponent=!0;const rGt={toc:[]};function sGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}sGt.isMDXComponent=!0;const cGt={toc:[]};function iGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}iGt.isMDXComponent=!0;const aGt={toc:[]};function lGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}lGt.isMDXComponent=!0;const uGt={toc:[]};function mGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}mGt.isMDXComponent=!0;const dGt={toc:[]};function hGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}hGt.isMDXComponent=!0;const fGt={toc:[]};function kGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}kGt.isMDXComponent=!0;const yGt={toc:[]};function wGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}wGt.isMDXComponent=!0;const DGt={toc:[]};function MGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}MGt.isMDXComponent=!0;const XGt={toc:[]};function _Gt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}_Gt.isMDXComponent=!0;const gGt={toc:[]};function TGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}TGt.isMDXComponent=!0;const CGt={toc:[]};function xGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}xGt.isMDXComponent=!0;const vGt={toc:[]};function LGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}LGt.isMDXComponent=!0;const ZGt={toc:[]};function bGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}bGt.isMDXComponent=!0;const NGt={toc:[]};function zGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}zGt.isMDXComponent=!0;const AGt={toc:[]};function WGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}WGt.isMDXComponent=!0;const IGt={toc:[]};function RGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}RGt.isMDXComponent=!0;const PGt={toc:[]};function SGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}SGt.isMDXComponent=!0;const OGt={toc:[]};function EGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}EGt.isMDXComponent=!0;const BGt={toc:[]};function GGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}GGt.isMDXComponent=!0;const VGt={toc:[]};function UGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}UGt.isMDXComponent=!0;const FGt={toc:[]};function qGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qGt.isMDXComponent=!0;const jGt={toc:[]};function YGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}YGt.isMDXComponent=!0;const HGt={toc:[]};function QGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}QGt.isMDXComponent=!0;const $Gt={toc:[]};function KGt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}KGt.isMDXComponent=!0;const JGt={toc:[]};function tVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}tVt.isMDXComponent=!0;const eVt={toc:[]};function nVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}nVt.isMDXComponent=!0;const oVt={toc:[]};function pVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}pVt.isMDXComponent=!0;const rVt={toc:[]};function sVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}sVt.isMDXComponent=!0;const cVt={toc:[]};function iVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}iVt.isMDXComponent=!0;const aVt={toc:[]};function lVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}lVt.isMDXComponent=!0;const uVt={toc:[]};function mVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}mVt.isMDXComponent=!0;const dVt={toc:[]};function hVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}hVt.isMDXComponent=!0;const fVt={toc:[]};function kVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}kVt.isMDXComponent=!0;const yVt={toc:[]};function wVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}wVt.isMDXComponent=!0;const DVt={toc:[]};function MVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}MVt.isMDXComponent=!0;const XVt={toc:[]};function _Vt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}_Vt.isMDXComponent=!0;const gVt={toc:[]};function TVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}TVt.isMDXComponent=!0;const CVt={toc:[]};function xVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}xVt.isMDXComponent=!0;const vVt={toc:[]};function LVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}LVt.isMDXComponent=!0;const ZVt={toc:[]};function bVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}bVt.isMDXComponent=!0;const NVt={toc:[]};function zVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}zVt.isMDXComponent=!0;const AVt={toc:[]};function WVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}WVt.isMDXComponent=!0;const IVt={toc:[]};function RVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}RVt.isMDXComponent=!0;const PVt={toc:[]};function SVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}SVt.isMDXComponent=!0;const OVt={toc:[]};function EVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}EVt.isMDXComponent=!0;const BVt={toc:[]};function GVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}GVt.isMDXComponent=!0;const VVt={toc:[]};function UVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}UVt.isMDXComponent=!0;const FVt={toc:[]};function qVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}qVt.isMDXComponent=!0;const jVt={toc:[]};function YVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}YVt.isMDXComponent=!0;const HVt={toc:[]};function QVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}QVt.isMDXComponent=!0;const $Vt={toc:[]};function KVt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Vt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}KVt.isMDXComponent=!0;const JVt={toc:[]};function tUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}tUt.isMDXComponent=!0;const eUt={toc:[]};function nUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}nUt.isMDXComponent=!0;const oUt={toc:[]};function pUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}pUt.isMDXComponent=!0;const rUt={toc:[]};function sUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}sUt.isMDXComponent=!0;const cUt={toc:[]};function iUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}iUt.isMDXComponent=!0;const aUt={toc:[]};function lUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}lUt.isMDXComponent=!0;const uUt={toc:[]};function mUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}mUt.isMDXComponent=!0;const dUt={toc:[]};function hUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}hUt.isMDXComponent=!0;const fUt={toc:[]};function kUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}kUt.isMDXComponent=!0;const yUt={toc:[]};function wUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}wUt.isMDXComponent=!0;const DUt={toc:[]};function MUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}MUt.isMDXComponent=!0;const XUt={toc:[]};function _Ut(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}_Ut.isMDXComponent=!0;const gUt={toc:[]};function TUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}TUt.isMDXComponent=!0;const CUt={toc:[]};function xUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}xUt.isMDXComponent=!0;const vUt={toc:[]};function LUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}LUt.isMDXComponent=!0;const ZUt={toc:[]};function bUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}bUt.isMDXComponent=!0;const NUt={toc:[]};function zUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}zUt.isMDXComponent=!0;const AUt={toc:[]};function WUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}WUt.isMDXComponent=!0;const IUt={toc:[]};function RUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}RUt.isMDXComponent=!0;const PUt={toc:[]};function SUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}SUt.isMDXComponent=!0;const OUt={toc:[]};function EUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}EUt.isMDXComponent=!0;const BUt={toc:[]};function GUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}GUt.isMDXComponent=!0;const VUt={toc:[]};function UUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}UUt.isMDXComponent=!0;const FUt={toc:[]};function qUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}qUt.isMDXComponent=!0;const jUt={toc:[]};function YUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}YUt.isMDXComponent=!0;const HUt={toc:[]};function QUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}QUt.isMDXComponent=!0;const $Ut={toc:[]};function KUt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}KUt.isMDXComponent=!0;const JUt={toc:[]};function tFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}tFt.isMDXComponent=!0;const eFt={toc:[]};function nFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}nFt.isMDXComponent=!0;const oFt={toc:[]};function pFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}pFt.isMDXComponent=!0;const rFt={toc:[]};function sFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}sFt.isMDXComponent=!0;const cFt={toc:[]};function iFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}iFt.isMDXComponent=!0;const aFt={toc:[]};function lFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}lFt.isMDXComponent=!0;const uFt={toc:[]};function mFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}mFt.isMDXComponent=!0;const dFt={toc:[]};function hFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}hFt.isMDXComponent=!0;const fFt={toc:[]};function kFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}kFt.isMDXComponent=!0;const yFt={toc:[]};function wFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}wFt.isMDXComponent=!0;const DFt={toc:[]};function MFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}MFt.isMDXComponent=!0;const XFt={toc:[]};function _Ft(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}_Ft.isMDXComponent=!0;const gFt={toc:[]};function TFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}TFt.isMDXComponent=!0;const CFt={toc:[]};function xFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}xFt.isMDXComponent=!0;const vFt={toc:[]};function LFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}LFt.isMDXComponent=!0;const ZFt={toc:[]};function bFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}bFt.isMDXComponent=!0;const NFt={toc:[]};function zFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}zFt.isMDXComponent=!0;const AFt={toc:[]};function WFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}WFt.isMDXComponent=!0;const IFt={toc:[]};function RFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}RFt.isMDXComponent=!0;const PFt={toc:[]};function SFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}SFt.isMDXComponent=!0;const OFt={toc:[]};function EFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}EFt.isMDXComponent=!0;const BFt={toc:[]};function GFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}GFt.isMDXComponent=!0;const VFt={toc:[]};function UFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}UFt.isMDXComponent=!0;const FFt={toc:[]};function qFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}qFt.isMDXComponent=!0;const jFt={toc:[]};function YFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}YFt.isMDXComponent=!0;const HFt={toc:[]};function QFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}QFt.isMDXComponent=!0;const $Ft={toc:[]};function KFt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}KFt.isMDXComponent=!0;const JFt={toc:[]};function tqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}tqt.isMDXComponent=!0;const eqt={toc:[]};function nqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}nqt.isMDXComponent=!0;const oqt={toc:[]};function pqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}pqt.isMDXComponent=!0;const rqt={toc:[]};function sqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}sqt.isMDXComponent=!0;const cqt={toc:[]};function iqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}iqt.isMDXComponent=!0;const aqt={toc:[]};function lqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}lqt.isMDXComponent=!0;const uqt={toc:[]};function mqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}mqt.isMDXComponent=!0;const dqt={toc:[]};function hqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}hqt.isMDXComponent=!0;const fqt={toc:[]};function kqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}kqt.isMDXComponent=!0;const yqt={toc:[]};function wqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}wqt.isMDXComponent=!0;const Dqt={toc:[]};function Mqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Mqt.isMDXComponent=!0;const Xqt={toc:[]};function _qt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}_qt.isMDXComponent=!0;const gqt={toc:[]};function Tqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Tqt.isMDXComponent=!0;const Cqt={toc:[]};function xqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}xqt.isMDXComponent=!0;const vqt={toc:[]};function Lqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Lqt.isMDXComponent=!0;const Zqt={toc:[]};function bqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bqt.isMDXComponent=!0;const Nqt={toc:[]};function zqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}zqt.isMDXComponent=!0;const Aqt={toc:[]};function Wqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Wqt.isMDXComponent=!0;const Iqt={toc:[]};function Rqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Rqt.isMDXComponent=!0;const Pqt={toc:[]};function Sqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Sqt.isMDXComponent=!0;const Oqt={toc:[]};function Eqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Eqt.isMDXComponent=!0;const Bqt={toc:[]};function Gqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Gqt.isMDXComponent=!0;const Vqt={toc:[]};function Uqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Uqt.isMDXComponent=!0;const Fqt={toc:[]};function qqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}qqt.isMDXComponent=!0;const jqt={toc:[]};function Yqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Yqt.isMDXComponent=!0;const Hqt={toc:[]};function Qqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Qqt.isMDXComponent=!0;const $qt={toc:[]};function Kqt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticeable if the number of sides is low, e.g. for a\ntriangle."))}Kqt.isMDXComponent=!0;const Jqt={toc:[]};function tjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}tjt.isMDXComponent=!0;const ejt={toc:[]};function njt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ejt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing regular polygons."))}njt.isMDXComponent=!0;const ojt={toc:[]};function pjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ojt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}pjt.isMDXComponent=!0;const rjt={toc:[]};function sjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}sjt.isMDXComponent=!0;const cjt={toc:[]};function ijt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ijt.isMDXComponent=!0;const ajt={toc:[]};function ljt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ajt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}ljt.isMDXComponent=!0;const ujt={toc:[]};function mjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ujt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}mjt.isMDXComponent=!0;const djt={toc:[]};function hjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},djt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}hjt.isMDXComponent=!0;const fjt={toc:[]};function kjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}kjt.isMDXComponent=!0;const yjt={toc:[]};function wjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}wjt.isMDXComponent=!0;const Djt={toc:[]};function Mjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Djt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Mjt.isMDXComponent=!0;const Xjt={toc:[]};function _jt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}_jt.isMDXComponent=!0;const gjt={toc:[]};function Tjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Tjt.isMDXComponent=!0;const Cjt={toc:[]};function xjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}xjt.isMDXComponent=!0;const vjt={toc:[]};function Ljt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Ljt.isMDXComponent=!0;const Zjt={toc:[]};function bjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}bjt.isMDXComponent=!0;const Njt={toc:[]};function zjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Njt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}zjt.isMDXComponent=!0;const Ajt={toc:[]};function Wjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ajt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Wjt.isMDXComponent=!0;const Ijt={toc:[]};function Rjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ijt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Rjt.isMDXComponent=!0;const Pjt={toc:[]};function Sjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Sjt.isMDXComponent=!0;const Ojt={toc:[]};function Ejt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ojt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Ejt.isMDXComponent=!0;const Bjt={toc:[]};function Gjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Gjt.isMDXComponent=!0;const Vjt={toc:[]};function Ujt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Ujt.isMDXComponent=!0;const Fjt={toc:[]};function qjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}qjt.isMDXComponent=!0;const jjt={toc:[]};function Yjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Yjt.isMDXComponent=!0;const Hjt={toc:[]};function Qjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Qjt.isMDXComponent=!0;const $jt={toc:[]};function Kjt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Kjt.isMDXComponent=!0;const Jjt={toc:[]};function tYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}tYt.isMDXComponent=!0;const eYt={toc:[]};function nYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}nYt.isMDXComponent=!0;const oYt={toc:[]};function pYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}pYt.isMDXComponent=!0;const rYt={toc:[]};function sYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}sYt.isMDXComponent=!0;const cYt={toc:[]};function iYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}iYt.isMDXComponent=!0;const aYt={toc:[]};function lYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}lYt.isMDXComponent=!0;const uYt={toc:[]};function mYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}mYt.isMDXComponent=!0;const dYt={toc:[]};function hYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}hYt.isMDXComponent=!0;const fYt={toc:[]};function kYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}kYt.isMDXComponent=!0;const yYt={toc:[]};function wYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}wYt.isMDXComponent=!0;const DYt={toc:[]};function MYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}MYt.isMDXComponent=!0;const XYt={toc:[]};function _Yt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}_Yt.isMDXComponent=!0;const gYt={toc:[]};function TYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}TYt.isMDXComponent=!0;const CYt={toc:[]};function xYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}xYt.isMDXComponent=!0;const vYt={toc:[]};function LYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}LYt.isMDXComponent=!0;const ZYt={toc:[]};function bYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}bYt.isMDXComponent=!0;const NYt={toc:[]};function zYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}zYt.isMDXComponent=!0;const AYt={toc:[]};function WYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}WYt.isMDXComponent=!0;const IYt={toc:[]};function RYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}RYt.isMDXComponent=!0;const PYt={toc:[]};function SYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}SYt.isMDXComponent=!0;const OYt={toc:[]};function EYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}EYt.isMDXComponent=!0;const BYt={toc:[]};function GYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}GYt.isMDXComponent=!0;const VYt={toc:[]};function UYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}UYt.isMDXComponent=!0;const FYt={toc:[]};function qYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qYt.isMDXComponent=!0;const jYt={toc:[]};function YYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}YYt.isMDXComponent=!0;const HYt={toc:[]};function QYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}QYt.isMDXComponent=!0;const $Yt={toc:[]};function KYt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Yt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}KYt.isMDXComponent=!0;const JYt={toc:[]};function tHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}tHt.isMDXComponent=!0;const eHt={toc:[]};function nHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}nHt.isMDXComponent=!0;const oHt={toc:[]};function pHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}pHt.isMDXComponent=!0;const rHt={toc:[]};function sHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}sHt.isMDXComponent=!0;const cHt={toc:[]};function iHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}iHt.isMDXComponent=!0;const aHt={toc:[]};function lHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}lHt.isMDXComponent=!0;const uHt={toc:[]};function mHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}mHt.isMDXComponent=!0;const dHt={toc:[]};function hHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}hHt.isMDXComponent=!0;const fHt={toc:[]};function kHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}kHt.isMDXComponent=!0;const yHt={toc:[]};function wHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wHt.isMDXComponent=!0;const DHt={toc:[]};function MHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}MHt.isMDXComponent=!0;const XHt={toc:[]};function _Ht(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}_Ht.isMDXComponent=!0;const gHt={toc:[]};function THt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}THt.isMDXComponent=!0;const CHt={toc:[]};function xHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}xHt.isMDXComponent=!0;const vHt={toc:[]};function LHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}LHt.isMDXComponent=!0;const ZHt={toc:[]};function bHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}bHt.isMDXComponent=!0;const NHt={toc:[]};function zHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}zHt.isMDXComponent=!0;const AHt={toc:[]};function WHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}WHt.isMDXComponent=!0;const IHt={toc:[]};function RHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}RHt.isMDXComponent=!0;const PHt={toc:[]};function SHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}SHt.isMDXComponent=!0;const OHt={toc:[]};function EHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}EHt.isMDXComponent=!0;const BHt={toc:[]};function GHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}GHt.isMDXComponent=!0;const VHt={toc:[]};function UHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}UHt.isMDXComponent=!0;const FHt={toc:[]};function qHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}qHt.isMDXComponent=!0;const jHt={toc:[]};function YHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}YHt.isMDXComponent=!0;const HHt={toc:[]};function QHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}QHt.isMDXComponent=!0;const $Ht={toc:[]};function KHt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}KHt.isMDXComponent=!0;const JHt={toc:[]};function tQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}tQt.isMDXComponent=!0;const eQt={toc:[]};function nQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}nQt.isMDXComponent=!0;const oQt={toc:[]};function pQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}pQt.isMDXComponent=!0;const rQt={toc:[]};function sQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}sQt.isMDXComponent=!0;const cQt={toc:[]};function iQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}iQt.isMDXComponent=!0;const aQt={toc:[]};function lQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}lQt.isMDXComponent=!0;const uQt={toc:[]};function mQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}mQt.isMDXComponent=!0;const dQt={toc:[]};function hQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}hQt.isMDXComponent=!0;const fQt={toc:[]};function kQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}kQt.isMDXComponent=!0;const yQt={toc:[]};function wQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}wQt.isMDXComponent=!0;const DQt={toc:[]};function MQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}MQt.isMDXComponent=!0;const XQt={toc:[]};function _Qt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}_Qt.isMDXComponent=!0;const gQt={toc:[]};function TQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}TQt.isMDXComponent=!0;const CQt={toc:[]};function xQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}xQt.isMDXComponent=!0;const vQt={toc:[]};function LQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}LQt.isMDXComponent=!0;const ZQt={toc:[]};function bQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}bQt.isMDXComponent=!0;const NQt={toc:[]};function zQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}zQt.isMDXComponent=!0;const AQt={toc:[]};function WQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}WQt.isMDXComponent=!0;const IQt={toc:[]};function RQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}RQt.isMDXComponent=!0;const PQt={toc:[]};function SQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}SQt.isMDXComponent=!0;const OQt={toc:[]};function EQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}EQt.isMDXComponent=!0;const BQt={toc:[]};function GQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}GQt.isMDXComponent=!0;const VQt={toc:[]};function UQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}UQt.isMDXComponent=!0;const FQt={toc:[]};function qQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}qQt.isMDXComponent=!0;const jQt={toc:[]};function YQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}YQt.isMDXComponent=!0;const HQt={toc:[]};function QQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}QQt.isMDXComponent=!0;const $Qt={toc:[]};function KQt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}KQt.isMDXComponent=!0;const JQt={toc:[]};function t$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}t$t.isMDXComponent=!0;const e$t={toc:[]};function n$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}n$t.isMDXComponent=!0;const o$t={toc:[]};function p$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}p$t.isMDXComponent=!0;const r$t={toc:[]};function s$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}s$t.isMDXComponent=!0;const c$t={toc:[]};function i$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}i$t.isMDXComponent=!0;const a$t={toc:[]};function l$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}l$t.isMDXComponent=!0;const u$t={toc:[]};function m$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}m$t.isMDXComponent=!0;const d$t={toc:[]};function h$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}h$t.isMDXComponent=!0;const f$t={toc:[]};function k$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}k$t.isMDXComponent=!0;const y$t={toc:[]};function w$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}w$t.isMDXComponent=!0;const D$t={toc:[]};function M$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}M$t.isMDXComponent=!0;const X$t={toc:[]};function _$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}_$t.isMDXComponent=!0;const g$t={toc:[]};function T$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}T$t.isMDXComponent=!0;const C$t={toc:[]};function x$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}x$t.isMDXComponent=!0;const v$t={toc:[]};function L$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}L$t.isMDXComponent=!0;const Z$t={toc:[]};function b$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}b$t.isMDXComponent=!0;const N$t={toc:[]};function z$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}z$t.isMDXComponent=!0;const A$t={toc:[]};function W$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}W$t.isMDXComponent=!0;const I$t={toc:[]};function R$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}R$t.isMDXComponent=!0;const P$t={toc:[]};function S$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}S$t.isMDXComponent=!0;const O$t={toc:[]};function E$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}E$t.isMDXComponent=!0;const B$t={toc:[]};function G$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}G$t.isMDXComponent=!0;const V$t={toc:[]};function U$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}U$t.isMDXComponent=!0;const F$t={toc:[]};function q$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}q$t.isMDXComponent=!0;const j$t={toc:[]};function Y$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Y$t.isMDXComponent=!0;const H$t={toc:[]};function Q$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Q$t.isMDXComponent=!0;const $$t={toc:[]};function K$t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}K$t.isMDXComponent=!0;const J$t={toc:[]};function tKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}tKt.isMDXComponent=!0;const eKt={toc:[]};function nKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}nKt.isMDXComponent=!0;const oKt={toc:[]};function pKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}pKt.isMDXComponent=!0;const rKt={toc:[]};function sKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}sKt.isMDXComponent=!0;const cKt={toc:[]};function iKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}iKt.isMDXComponent=!0;const aKt={toc:[]};function lKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}lKt.isMDXComponent=!0;const uKt={toc:[]};function mKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}mKt.isMDXComponent=!0;const dKt={toc:[]};function hKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}hKt.isMDXComponent=!0;const fKt={toc:[]};function kKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}kKt.isMDXComponent=!0;const yKt={toc:[]};function wKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}wKt.isMDXComponent=!0;const DKt={toc:[]};function MKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}MKt.isMDXComponent=!0;const XKt={toc:[]};function _Kt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, QuadBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}_Kt.isMDXComponent=!0;const gKt={toc:[]};function TKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}TKt.isMDXComponent=!0;const CKt={toc:[]};function xKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}xKt.isMDXComponent=!0;const vKt={toc:[]};function LKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}LKt.isMDXComponent=!0;const ZKt={toc:[]};function bKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}bKt.isMDXComponent=!0;const NKt={toc:[]};function zKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}zKt.isMDXComponent=!0;const AKt={toc:[]};function WKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}WKt.isMDXComponent=!0;const IKt={toc:[]};function RKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}RKt.isMDXComponent=!0;const PKt={toc:[]};function SKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}SKt.isMDXComponent=!0;const OKt={toc:[]};function EKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}EKt.isMDXComponent=!0;const BKt={toc:[]};function GKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}GKt.isMDXComponent=!0;const VKt={toc:[]};function UKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}UKt.isMDXComponent=!0;const FKt={toc:[]};function qKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}qKt.isMDXComponent=!0;const jKt={toc:[]};function YKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}YKt.isMDXComponent=!0;const HKt={toc:[]};function QKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}QKt.isMDXComponent=!0;const $Kt={toc:[]};function KKt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}KKt.isMDXComponent=!0;const JKt={toc:[]};function tJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}tJt.isMDXComponent=!0;const eJt={toc:[]};function nJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}nJt.isMDXComponent=!0;const oJt={toc:[]};function pJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pJt.isMDXComponent=!0;const rJt={toc:[]};function sJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}sJt.isMDXComponent=!0;const cJt={toc:[]};function iJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}iJt.isMDXComponent=!0;const aJt={toc:[]};function lJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}lJt.isMDXComponent=!0;const uJt={toc:[]};function mJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}mJt.isMDXComponent=!0;const dJt={toc:[]};function hJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}hJt.isMDXComponent=!0;const fJt={toc:[]};function kJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}kJt.isMDXComponent=!0;const yJt={toc:[]};function wJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}wJt.isMDXComponent=!0;const DJt={toc:[]};function MJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}MJt.isMDXComponent=!0;const XJt={toc:[]};function _Jt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}_Jt.isMDXComponent=!0;const gJt={toc:[]};function TJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}TJt.isMDXComponent=!0;const CJt={toc:[]};function xJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}xJt.isMDXComponent=!0;const vJt={toc:[]};function LJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}LJt.isMDXComponent=!0;const ZJt={toc:[]};function bJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The control point of the B\xe9zier curve."))}bJt.isMDXComponent=!0;const NJt={toc:[]};function zJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}zJt.isMDXComponent=!0;const AJt={toc:[]};function WJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}WJt.isMDXComponent=!0;const IJt={toc:[]};function RJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}RJt.isMDXComponent=!0;const PJt={toc:[]};function SJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}SJt.isMDXComponent=!0;const OJt={toc:[]};function EJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}EJt.isMDXComponent=!0;const BJt={toc:[]};function GJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}GJt.isMDXComponent=!0;const VJt={toc:[]};function UJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}UJt.isMDXComponent=!0;const FJt={toc:[]};function qJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}qJt.isMDXComponent=!0;const jJt={toc:[]};function YJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}YJt.isMDXComponent=!0;const HJt={toc:[]};function QJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}QJt.isMDXComponent=!0;const $Jt={toc:[]};function KJt(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Jt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}KJt.isMDXComponent=!0;const JJt={toc:[]};function t0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}t0t.isMDXComponent=!0;const e0t={toc:[]};function n0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}n0t.isMDXComponent=!0;const o0t={toc:[]};function p0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}p0t.isMDXComponent=!0;const r0t={toc:[]};function s0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}s0t.isMDXComponent=!0;const c0t={toc:[]};function i0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}i0t.isMDXComponent=!0;const a0t={toc:[]};function l0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}l0t.isMDXComponent=!0;const u0t={toc:[]};function m0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}m0t.isMDXComponent=!0;const d0t={toc:[]};function h0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}h0t.isMDXComponent=!0;const f0t={toc:[]};function k0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}k0t.isMDXComponent=!0;const y0t={toc:[]};function w0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}w0t.isMDXComponent=!0;const D0t={toc:[]};function M0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}M0t.isMDXComponent=!0;const X0t={toc:[]};function _0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}_0t.isMDXComponent=!0;const g0t={toc:[]};function T0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}T0t.isMDXComponent=!0;const C0t={toc:[]};function x0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}x0t.isMDXComponent=!0;const v0t={toc:[]};function L0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}L0t.isMDXComponent=!0;const Z0t={toc:[]};function b0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}b0t.isMDXComponent=!0;const N0t={toc:[]};function z0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}z0t.isMDXComponent=!0;const A0t={toc:[]};function W0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}W0t.isMDXComponent=!0;const I0t={toc:[]};function R0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}R0t.isMDXComponent=!0;const P0t={toc:[]};function S0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}S0t.isMDXComponent=!0;const O0t={toc:[]};function E0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}E0t.isMDXComponent=!0;const B0t={toc:[]};function G0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}G0t.isMDXComponent=!0;const V0t={toc:[]};function U0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}U0t.isMDXComponent=!0;const F0t={toc:[]};function q0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}q0t.isMDXComponent=!0;const j0t={toc:[]};function Y0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Y0t.isMDXComponent=!0;const H0t={toc:[]};function Q0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Q0t.isMDXComponent=!0;const $0t={toc:[]};function K0t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}K0t.isMDXComponent=!0;const J0t={toc:[]};function t2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}t2t.isMDXComponent=!0;const e2t={toc:[]};function n2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}n2t.isMDXComponent=!0;const o2t={toc:[]};function p2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}p2t.isMDXComponent=!0;const r2t={toc:[]};function s2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}s2t.isMDXComponent=!0;const c2t={toc:[]};function i2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}i2t.isMDXComponent=!0;const a2t={toc:[]};function l2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}l2t.isMDXComponent=!0;const u2t={toc:[]};function m2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}m2t.isMDXComponent=!0;const d2t={toc:[]};function h2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}h2t.isMDXComponent=!0;const f2t={toc:[]};function k2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}k2t.isMDXComponent=!0;const y2t={toc:[]};function w2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}w2t.isMDXComponent=!0;const D2t={toc:[]};function M2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}M2t.isMDXComponent=!0;const X2t={toc:[]};function _2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}_2t.isMDXComponent=!0;const g2t={toc:[]};function T2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}T2t.isMDXComponent=!0;const C2t={toc:[]};function x2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}x2t.isMDXComponent=!0;const v2t={toc:[]};function L2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}L2t.isMDXComponent=!0;const Z2t={toc:[]};function b2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}b2t.isMDXComponent=!0;const N2t={toc:[]};function z2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}z2t.isMDXComponent=!0;const A2t={toc:[]};function W2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}W2t.isMDXComponent=!0;const I2t={toc:[]};function R2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}R2t.isMDXComponent=!0;const P2t={toc:[]};function S2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}S2t.isMDXComponent=!0;const O2t={toc:[]};function E2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}E2t.isMDXComponent=!0;const B2t={toc:[]};function G2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}G2t.isMDXComponent=!0;const V2t={toc:[]};function U2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}U2t.isMDXComponent=!0;const F2t={toc:[]};function q2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}q2t.isMDXComponent=!0;const j2t={toc:[]};function Y2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Y2t.isMDXComponent=!0;const H2t={toc:[]};function Q2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Q2t.isMDXComponent=!0;const $2t={toc:[]};function K2t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}K2t.isMDXComponent=!0;const J2t={toc:[]};function t6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}t6t.isMDXComponent=!0;const e6t={toc:[]};function n6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}n6t.isMDXComponent=!0;const o6t={toc:[]};function p6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}p6t.isMDXComponent=!0;const r6t={toc:[]};function s6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}s6t.isMDXComponent=!0;const c6t={toc:[]};function i6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}i6t.isMDXComponent=!0;const a6t={toc:[]};function l6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}l6t.isMDXComponent=!0;const u6t={toc:[]};function m6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}m6t.isMDXComponent=!0;const d6t={toc:[]};function h6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}h6t.isMDXComponent=!0;const f6t={toc:[]};function k6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}k6t.isMDXComponent=!0;const y6t={toc:[]};function w6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}w6t.isMDXComponent=!0;const D6t={toc:[]};function M6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}M6t.isMDXComponent=!0;const X6t={toc:[]};function _6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}_6t.isMDXComponent=!0;const g6t={toc:[]};function T6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}T6t.isMDXComponent=!0;const C6t={toc:[]};function x6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}x6t.isMDXComponent=!0;const v6t={toc:[]};function L6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}L6t.isMDXComponent=!0;const Z6t={toc:[]};function b6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}b6t.isMDXComponent=!0;const N6t={toc:[]};function z6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}z6t.isMDXComponent=!0;const A6t={toc:[]};function W6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}W6t.isMDXComponent=!0;const I6t={toc:[]};function R6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}R6t.isMDXComponent=!0;const P6t={toc:[]};function S6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}S6t.isMDXComponent=!0;const O6t={toc:[]};function E6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}E6t.isMDXComponent=!0;const B6t={toc:[]};function G6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}G6t.isMDXComponent=!0;const V6t={toc:[]};function U6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}U6t.isMDXComponent=!0;const F6t={toc:[]};function q6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}q6t.isMDXComponent=!0;const j6t={toc:[]};function Y6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Y6t.isMDXComponent=!0;const H6t={toc:[]};function Q6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Q6t.isMDXComponent=!0;const $6t={toc:[]};function K6t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}K6t.isMDXComponent=!0;const J6t={toc:[]};function t3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}t3t.isMDXComponent=!0;const e3t={toc:[]};function n3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}n3t.isMDXComponent=!0;const o3t={toc:[]};function p3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}p3t.isMDXComponent=!0;const r3t={toc:[]};function s3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}s3t.isMDXComponent=!0;const c3t={toc:[]};function i3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}i3t.isMDXComponent=!0;const a3t={toc:[]};function l3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}l3t.isMDXComponent=!0;const u3t={toc:[]};function m3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}m3t.isMDXComponent=!0;const d3t={toc:[]};function h3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}h3t.isMDXComponent=!0;const f3t={toc:[]};function k3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}k3t.isMDXComponent=!0;const y3t={toc:[]};function w3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}w3t.isMDXComponent=!0;const D3t={toc:[]};function M3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}M3t.isMDXComponent=!0;const X3t={toc:[]};function _3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}_3t.isMDXComponent=!0;const g3t={toc:[]};function T3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}T3t.isMDXComponent=!0;const C3t={toc:[]};function x3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}x3t.isMDXComponent=!0;const v3t={toc:[]};function L3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}L3t.isMDXComponent=!0;const Z3t={toc:[]};function b3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}b3t.isMDXComponent=!0;const N3t={toc:[]};function z3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}z3t.isMDXComponent=!0;const A3t={toc:[]};function W3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}W3t.isMDXComponent=!0;const I3t={toc:[]};function R3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}R3t.isMDXComponent=!0;const P3t={toc:[]};function S3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}S3t.isMDXComponent=!0;const O3t={toc:[]};function E3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}E3t.isMDXComponent=!0;const B3t={toc:[]};function G3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}G3t.isMDXComponent=!0;const V3t={toc:[]};function U3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}U3t.isMDXComponent=!0;const F3t={toc:[]};function q3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}q3t.isMDXComponent=!0;const j3t={toc:[]};function Y3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Y3t.isMDXComponent=!0;const H3t={toc:[]};function Q3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Q3t.isMDXComponent=!0;const $3t={toc:[]};function K3t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}K3t.isMDXComponent=!0;const J3t={toc:[]};function t5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}t5t.isMDXComponent=!0;const e5t={toc:[]};function n5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}n5t.isMDXComponent=!0;const o5t={toc:[]};function p5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}p5t.isMDXComponent=!0;const r5t={toc:[]};function s5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}s5t.isMDXComponent=!0;const c5t={toc:[]};function i5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}i5t.isMDXComponent=!0;const a5t={toc:[]};function l5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}l5t.isMDXComponent=!0;const u5t={toc:[]};function m5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}m5t.isMDXComponent=!0;const d5t={toc:[]};function h5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}h5t.isMDXComponent=!0;const f5t={toc:[]};function k5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}k5t.isMDXComponent=!0;const y5t={toc:[]};function w5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}w5t.isMDXComponent=!0;const D5t={toc:[]};function M5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}M5t.isMDXComponent=!0;const X5t={toc:[]};function _5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}_5t.isMDXComponent=!0;const g5t={toc:[]};function T5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}T5t.isMDXComponent=!0;const C5t={toc:[]};function x5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}x5t.isMDXComponent=!0;const v5t={toc:[]};function L5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}L5t.isMDXComponent=!0;const Z5t={toc:[]};function b5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}b5t.isMDXComponent=!0;const N5t={toc:[]};function z5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}z5t.isMDXComponent=!0;const A5t={toc:[]};function W5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}W5t.isMDXComponent=!0;const I5t={toc:[]};function R5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}R5t.isMDXComponent=!0;const P5t={toc:[]};function S5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}S5t.isMDXComponent=!0;const O5t={toc:[]};function E5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}E5t.isMDXComponent=!0;const B5t={toc:[]};function G5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}G5t.isMDXComponent=!0;const V5t={toc:[]};function U5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}U5t.isMDXComponent=!0;const F5t={toc:[]};function q5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}q5t.isMDXComponent=!0;const j5t={toc:[]};function Y5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Y5t.isMDXComponent=!0;const H5t={toc:[]};function Q5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Q5t.isMDXComponent=!0;const $5t={toc:[]};function K5t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}K5t.isMDXComponent=!0;const J5t={toc:[]};function t1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d';\nimport {Ray} from '@motion-canvas/2d/lib/components';\nimport {createRef} from '@motion-canvas/core/lib/utils';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}t1t.isMDXComponent=!0;const e1t={toc:[]};function n1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing an individual line segment."))}n1t.isMDXComponent=!0;const o1t={toc:[]};function p1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}p1t.isMDXComponent=!0;const r1t={toc:[]};function s1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}s1t.isMDXComponent=!0;const c1t={toc:[]};function i1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}i1t.isMDXComponent=!0;const a1t={toc:[]};function l1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}l1t.isMDXComponent=!0;const u1t={toc:[]};function m1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}m1t.isMDXComponent=!0;const d1t={toc:[]};function h1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}h1t.isMDXComponent=!0;const f1t={toc:[]};function k1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}k1t.isMDXComponent=!0;const y1t={toc:[]};function w1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}w1t.isMDXComponent=!0;const D1t={toc:[]};function M1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}M1t.isMDXComponent=!0;const X1t={toc:[]};function _1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}_1t.isMDXComponent=!0;const g1t={toc:[]};function T1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}T1t.isMDXComponent=!0;const C1t={toc:[]};function x1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}x1t.isMDXComponent=!0;const v1t={toc:[]};function L1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}L1t.isMDXComponent=!0;const Z1t={toc:[]};function b1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}b1t.isMDXComponent=!0;const N1t={toc:[]};function z1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}z1t.isMDXComponent=!0;const A1t={toc:[]};function W1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}W1t.isMDXComponent=!0;const I1t={toc:[]};function R1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}R1t.isMDXComponent=!0;const P1t={toc:[]};function S1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}S1t.isMDXComponent=!0;const O1t={toc:[]};function E1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}E1t.isMDXComponent=!0;const B1t={toc:[]};function G1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}G1t.isMDXComponent=!0;const V1t={toc:[]};function U1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}U1t.isMDXComponent=!0;const F1t={toc:[]};function q1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}q1t.isMDXComponent=!0;const j1t={toc:[]};function Y1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}Y1t.isMDXComponent=!0;const H1t={toc:[]};function Q1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Q1t.isMDXComponent=!0;const $1t={toc:[]};function K1t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}K1t.isMDXComponent=!0;const J1t={toc:[]};function t4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}t4t.isMDXComponent=!0;const e4t={toc:[]};function n4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}n4t.isMDXComponent=!0;const o4t={toc:[]};function p4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}p4t.isMDXComponent=!0;const r4t={toc:[]};function s4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}s4t.isMDXComponent=!0;const c4t={toc:[]};function i4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}i4t.isMDXComponent=!0;const a4t={toc:[]};function l4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}l4t.isMDXComponent=!0;const u4t={toc:[]};function m4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}m4t.isMDXComponent=!0;const d4t={toc:[]};function h4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}h4t.isMDXComponent=!0;const f4t={toc:[]};function k4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}k4t.isMDXComponent=!0;const y4t={toc:[]};function w4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}w4t.isMDXComponent=!0;const D4t={toc:[]};function M4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}M4t.isMDXComponent=!0;const X4t={toc:[]};function _4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}_4t.isMDXComponent=!0;const g4t={toc:[]};function T4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}T4t.isMDXComponent=!0;const C4t={toc:[]};function x4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}x4t.isMDXComponent=!0;const v4t={toc:[]};function L4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}L4t.isMDXComponent=!0;const Z4t={toc:[]};function b4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}b4t.isMDXComponent=!0;const N4t={toc:[]};function z4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}z4t.isMDXComponent=!0;const A4t={toc:[]};function W4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}W4t.isMDXComponent=!0;const I4t={toc:[]};function R4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}R4t.isMDXComponent=!0;const P4t={toc:[]};function S4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}S4t.isMDXComponent=!0;const O4t={toc:[]};function E4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}E4t.isMDXComponent=!0;const B4t={toc:[]};function G4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}G4t.isMDXComponent=!0;const V4t={toc:[]};function U4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}U4t.isMDXComponent=!0;const F4t={toc:[]};function q4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}q4t.isMDXComponent=!0;const j4t={toc:[]};function Y4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Y4t.isMDXComponent=!0;const H4t={toc:[]};function Q4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Q4t.isMDXComponent=!0;const $4t={toc:[]};function K4t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}K4t.isMDXComponent=!0;const J4t={toc:[]};function t8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}t8t.isMDXComponent=!0;const e8t={toc:[]};function n8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}n8t.isMDXComponent=!0;const o8t={toc:[]};function p8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}p8t.isMDXComponent=!0;const r8t={toc:[]};function s8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}s8t.isMDXComponent=!0;const c8t={toc:[]};function i8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}i8t.isMDXComponent=!0;const a8t={toc:[]};function l8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}l8t.isMDXComponent=!0;const u8t={toc:[]};function m8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}m8t.isMDXComponent=!0;const d8t={toc:[]};function h8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}h8t.isMDXComponent=!0;const f8t={toc:[]};function k8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}k8t.isMDXComponent=!0;const y8t={toc:[]};function w8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}w8t.isMDXComponent=!0;const D8t={toc:[]};function M8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}M8t.isMDXComponent=!0;const X8t={toc:[]};function _8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}_8t.isMDXComponent=!0;const g8t={toc:[]};function T8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}T8t.isMDXComponent=!0;const C8t={toc:[]};function x8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}x8t.isMDXComponent=!0;const v8t={toc:[]};function L8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}L8t.isMDXComponent=!0;const Z8t={toc:[]};function b8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}b8t.isMDXComponent=!0;const N8t={toc:[]};function z8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}z8t.isMDXComponent=!0;const A8t={toc:[]};function W8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}W8t.isMDXComponent=!0;const I8t={toc:[]};function R8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}R8t.isMDXComponent=!0;const P8t={toc:[]};function S8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}S8t.isMDXComponent=!0;const O8t={toc:[]};function E8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}E8t.isMDXComponent=!0;const B8t={toc:[]};function G8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}G8t.isMDXComponent=!0;const V8t={toc:[]};function U8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}U8t.isMDXComponent=!0;const F8t={toc:[]};function q8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}q8t.isMDXComponent=!0;const j8t={toc:[]};function Y8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Y8t.isMDXComponent=!0;const H8t={toc:[]};function Q8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Q8t.isMDXComponent=!0;const $8t={toc:[]};function K8t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}K8t.isMDXComponent=!0;const J8t={toc:[]};function t7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}t7t.isMDXComponent=!0;const e7t={toc:[]};function n7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}n7t.isMDXComponent=!0;const o7t={toc:[]};function p7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}p7t.isMDXComponent=!0;const r7t={toc:[]};function s7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}s7t.isMDXComponent=!0;const c7t={toc:[]};function i7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}i7t.isMDXComponent=!0;const a7t={toc:[]};function l7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}l7t.isMDXComponent=!0;const u7t={toc:[]};function m7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}m7t.isMDXComponent=!0;const d7t={toc:[]};function h7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}h7t.isMDXComponent=!0;const f7t={toc:[]};function k7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}k7t.isMDXComponent=!0;const y7t={toc:[]};function w7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}w7t.isMDXComponent=!0;const D7t={toc:[]};function M7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}M7t.isMDXComponent=!0;const X7t={toc:[]};function _7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}_7t.isMDXComponent=!0;const g7t={toc:[]};function T7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}T7t.isMDXComponent=!0;const C7t={toc:[]};function x7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}x7t.isMDXComponent=!0;const v7t={toc:[]};function L7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}L7t.isMDXComponent=!0;const Z7t={toc:[]};function b7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}b7t.isMDXComponent=!0;const N7t={toc:[]};function z7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}z7t.isMDXComponent=!0;const A7t={toc:[]};function W7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}W7t.isMDXComponent=!0;const I7t={toc:[]};function R7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}R7t.isMDXComponent=!0;const P7t={toc:[]};function S7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}S7t.isMDXComponent=!0;const O7t={toc:[]};function E7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}E7t.isMDXComponent=!0;const B7t={toc:[]};function G7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}G7t.isMDXComponent=!0;const V7t={toc:[]};function U7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}U7t.isMDXComponent=!0;const F7t={toc:[]};function q7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}q7t.isMDXComponent=!0;const j7t={toc:[]};function Y7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Y7t.isMDXComponent=!0;const H7t={toc:[]};function Q7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Q7t.isMDXComponent=!0;const $7t={toc:[]};function K7t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}K7t.isMDXComponent=!0;const J7t={toc:[]};function t9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}t9t.isMDXComponent=!0;const e9t={toc:[]};function n9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}n9t.isMDXComponent=!0;const o9t={toc:[]};function p9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}p9t.isMDXComponent=!0;const r9t={toc:[]};function s9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}s9t.isMDXComponent=!0;const c9t={toc:[]};function i9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}i9t.isMDXComponent=!0;const a9t={toc:[]};function l9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}l9t.isMDXComponent=!0;const u9t={toc:[]};function m9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}m9t.isMDXComponent=!0;const d9t={toc:[]};function h9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}h9t.isMDXComponent=!0;const f9t={toc:[]};function k9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}k9t.isMDXComponent=!0;const y9t={toc:[]};function w9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}w9t.isMDXComponent=!0;const D9t={toc:[]};function M9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}M9t.isMDXComponent=!0;const X9t={toc:[]};function _9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}_9t.isMDXComponent=!0;const g9t={toc:[]};function T9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}T9t.isMDXComponent=!0;const C9t={toc:[]};function x9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}x9t.isMDXComponent=!0;const v9t={toc:[]};function L9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}L9t.isMDXComponent=!0;const Z9t={toc:[]};function b9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}b9t.isMDXComponent=!0;const N9t={toc:[]};function z9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}z9t.isMDXComponent=!0;const A9t={toc:[]};function W9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}W9t.isMDXComponent=!0;const I9t={toc:[]};function R9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}R9t.isMDXComponent=!0;const P9t={toc:[]};function S9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}S9t.isMDXComponent=!0;const O9t={toc:[]};function E9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}E9t.isMDXComponent=!0;const B9t={toc:[]};function G9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}G9t.isMDXComponent=!0;const V9t={toc:[]};function U9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}U9t.isMDXComponent=!0;const F9t={toc:[]};function q9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}q9t.isMDXComponent=!0;const j9t={toc:[]};function Y9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Y9t.isMDXComponent=!0;const H9t={toc:[]};function Q9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Q9t.isMDXComponent=!0;const $9t={toc:[]};function K9t(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}K9t.isMDXComponent=!0;const J9t={toc:[]};function tte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}tte.isMDXComponent=!0;const ete={toc:[]};function nte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ete,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}nte.isMDXComponent=!0;const ote={toc:[]};function pte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ote,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}pte.isMDXComponent=!0;const rte={toc:[]};function ste(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}ste.isMDXComponent=!0;const cte={toc:[]};function ite(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ite.isMDXComponent=!0;const ate={toc:[]};function lte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ate,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}lte.isMDXComponent=!0;const ute={toc:[]};function mte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ute,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}mte.isMDXComponent=!0;const dte={toc:[]};function hte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}hte.isMDXComponent=!0;const fte={toc:[]};function kte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}kte.isMDXComponent=!0;const yte={toc:[]};function wte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}wte.isMDXComponent=!0;const Dte={toc:[]};function Mte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Mte.isMDXComponent=!0;const Xte={toc:[]};function _te(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_te.isMDXComponent=!0;const gte={toc:[]};function Tte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Tte.isMDXComponent=!0;const Cte={toc:[]};function xte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}xte.isMDXComponent=!0;const vte={toc:[]};function Lte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Lte.isMDXComponent=!0;const Zte={toc:[]};function bte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}bte.isMDXComponent=!0;const Nte={toc:[]};function zte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}zte.isMDXComponent=!0;const Ate={toc:[]};function Wte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ate,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Wte.isMDXComponent=!0;const Ite={toc:[]};function Rte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ite,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Rte.isMDXComponent=!0;const Pte={toc:[]};function Ste(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Ste.isMDXComponent=!0;const Ote={toc:[]};function Ete(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ote,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Ete.isMDXComponent=!0;const Bte={toc:[]};function Gte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Gte.isMDXComponent=!0;const Vte={toc:[]};function Ute(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Ute.isMDXComponent=!0;const Fte={toc:[]};function qte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}qte.isMDXComponent=!0;const jte={toc:[]};function Yte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Yte.isMDXComponent=!0;const Hte={toc:[]};function Qte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Qte.isMDXComponent=!0;const $te={toc:[]};function Kte(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$te,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Kte.isMDXComponent=!0;const Jte={toc:[]};function tee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}tee.isMDXComponent=!0;const eee={toc:[]};function nee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}nee.isMDXComponent=!0;const oee={toc:[]};function pee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}pee.isMDXComponent=!0;const ree={toc:[]};function see(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ree,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}see.isMDXComponent=!0;const cee={toc:[]};function iee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}iee.isMDXComponent=!0;const aee={toc:[]};function lee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}lee.isMDXComponent=!0;const uee={toc:[]};function mee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}mee.isMDXComponent=!0;const dee={toc:[]};function hee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}hee.isMDXComponent=!0;const fee={toc:[]};function kee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}kee.isMDXComponent=!0;const yee={toc:[]};function wee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}wee.isMDXComponent=!0;const Dee={toc:[]};function Mee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Mee.isMDXComponent=!0;const Xee={toc:[]};function _ee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}_ee.isMDXComponent=!0;const gee={toc:[]};function Tee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Tee.isMDXComponent=!0;const Cee={toc:[]};function xee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}xee.isMDXComponent=!0;const vee={toc:[]};function Lee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Lee.isMDXComponent=!0;const Zee={toc:[]};function bee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}bee.isMDXComponent=!0;const Nee={toc:[]};function zee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}zee.isMDXComponent=!0;const Aee={toc:[]};function Wee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Wee.isMDXComponent=!0;const Iee={toc:[]};function Ree(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Ree.isMDXComponent=!0;const Pee={toc:[]};function See(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}See.isMDXComponent=!0;const Oee={toc:[]};function Eee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Eee.isMDXComponent=!0;const Bee={toc:[]};function Gee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Gee.isMDXComponent=!0;const Vee={toc:[]};function Uee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Uee.isMDXComponent=!0;const Fee={toc:[]};function qee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qee.isMDXComponent=!0;const jee={toc:[]};function Yee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Yee.isMDXComponent=!0;const Hee={toc:[]};function Qee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Qee.isMDXComponent=!0;const $ee={toc:[]};function Kee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Kee.isMDXComponent=!0;const Jee={toc:[]};function tne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}tne.isMDXComponent=!0;const ene={toc:[]};function nne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ene,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}nne.isMDXComponent=!0;const one={toc:[]};function pne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},one,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}pne.isMDXComponent=!0;const rne={toc:[]};function sne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}sne.isMDXComponent=!0;const cne={toc:[]};function ine(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ine.isMDXComponent=!0;const ane={toc:[]};function lne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ane,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}lne.isMDXComponent=!0;const une={toc:[]};function mne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},une,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}mne.isMDXComponent=!0;const dne={toc:[]};function hne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}hne.isMDXComponent=!0;const fne={toc:[]};function kne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}kne.isMDXComponent=!0;const yne={toc:[]};function wne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wne.isMDXComponent=!0;const Dne={toc:[]};function Mne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Mne.isMDXComponent=!0;const Xne={toc:[]};function _ne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}_ne.isMDXComponent=!0;const gne={toc:[]};function Tne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Tne.isMDXComponent=!0;const Cne={toc:[]};function xne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}xne.isMDXComponent=!0;const vne={toc:[]};function Lne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Lne.isMDXComponent=!0;const Zne={toc:[]};function bne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}bne.isMDXComponent=!0;const Nne={toc:[]};function zne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}zne.isMDXComponent=!0;const Ane={toc:[]};function Wne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ane,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Wne.isMDXComponent=!0;const Ine={toc:[]};function Rne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ine,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Rne.isMDXComponent=!0;const Pne={toc:[]};function Sne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Sne.isMDXComponent=!0;const One={toc:[]};function Ene(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},One,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Ene.isMDXComponent=!0;const Bne={toc:[]};function Gne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Gne.isMDXComponent=!0;const Vne={toc:[]};function Une(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}Une.isMDXComponent=!0;const Fne={toc:[]};function qne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}qne.isMDXComponent=!0;const jne={toc:[]};function Yne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Yne.isMDXComponent=!0;const Hne={toc:[]};function Qne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Qne.isMDXComponent=!0;const $ne={toc:[]};function Kne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Kne.isMDXComponent=!0;const Jne={toc:[]};function toe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}toe.isMDXComponent=!0;const eoe={toc:[]};function noe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}noe.isMDXComponent=!0;const ooe={toc:[]};function poe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ooe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}poe.isMDXComponent=!0;const roe={toc:[]};function soe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},roe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}soe.isMDXComponent=!0;const coe={toc:[]};function ioe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},coe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}ioe.isMDXComponent=!0;const aoe={toc:[]};function loe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}loe.isMDXComponent=!0;const uoe={toc:[]};function moe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}moe.isMDXComponent=!0;const doe={toc:[]};function hoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},doe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}hoe.isMDXComponent=!0;const foe={toc:[]};function koe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},foe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}koe.isMDXComponent=!0;const yoe={toc:[]};function woe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}woe.isMDXComponent=!0;const Doe={toc:[]};function Moe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Doe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Moe.isMDXComponent=!0;const Xoe={toc:[]};function _oe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}_oe.isMDXComponent=!0;const goe={toc:[]};function Toe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},goe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Toe.isMDXComponent=!0;const Coe={toc:[]};function xoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Coe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xoe.isMDXComponent=!0;const voe={toc:[]};function Loe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},voe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Loe.isMDXComponent=!0;const Zoe={toc:[]};function boe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}boe.isMDXComponent=!0;const Noe={toc:[]};function zoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Noe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}zoe.isMDXComponent=!0;const Aoe={toc:[]};function Woe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Woe.isMDXComponent=!0;const Ioe={toc:[]};function Roe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ioe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Roe.isMDXComponent=!0;const Poe={toc:[]};function Soe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Poe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Soe.isMDXComponent=!0;const Ooe={toc:[]};function Eoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ooe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Eoe.isMDXComponent=!0;const Boe={toc:[]};function Goe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Boe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Goe.isMDXComponent=!0;const Voe={toc:[]};function Uoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Voe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Uoe.isMDXComponent=!0;const Foe={toc:[]};function qoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Foe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}qoe.isMDXComponent=!0;const joe={toc:[]};function Yoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},joe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Yoe.isMDXComponent=!0;const Hoe={toc:[]};function Qoe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Qoe.isMDXComponent=!0;const $oe={toc:[]};function Koe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Koe.isMDXComponent=!0;const Joe={toc:[]};function tpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Joe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}tpe.isMDXComponent=!0;const epe={toc:[]};function npe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},epe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}npe.isMDXComponent=!0;const ope={toc:[]};function ppe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ope,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}ppe.isMDXComponent=!0;const rpe={toc:[]};function spe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}spe.isMDXComponent=!0;const cpe={toc:[]};function ipe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}ipe.isMDXComponent=!0;const ape={toc:[]};function lpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ape,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}lpe.isMDXComponent=!0;const upe={toc:[]};function mpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}mpe.isMDXComponent=!0;const dpe={toc:[]};function hpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}hpe.isMDXComponent=!0;const fpe={toc:[]};function kpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}kpe.isMDXComponent=!0;const ype={toc:[]};function wpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ype,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wpe.isMDXComponent=!0;const Dpe={toc:[]};function Mpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Mpe.isMDXComponent=!0;const Xpe={toc:[]};function _pe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}_pe.isMDXComponent=!0;const gpe={toc:[]};function Tpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Tpe.isMDXComponent=!0;const Cpe={toc:[]};function xpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}xpe.isMDXComponent=!0;const vpe={toc:[]};function Lpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Lpe.isMDXComponent=!0;const Zpe={toc:[]};function bpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}bpe.isMDXComponent=!0;const Npe={toc:[]};function zpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}zpe.isMDXComponent=!0;const Ape={toc:[]};function Wpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ape,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Wpe.isMDXComponent=!0;const Ipe={toc:[]};function Rpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ipe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Rpe.isMDXComponent=!0;const Ppe={toc:[]};function Spe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ppe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Spe.isMDXComponent=!0;const Ope={toc:[]};function Epe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ope,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Epe.isMDXComponent=!0;const Bpe={toc:[]};function Gpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Gpe.isMDXComponent=!0;const Vpe={toc:[]};function Upe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Upe.isMDXComponent=!0;const Fpe={toc:[]};function qpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}qpe.isMDXComponent=!0;const jpe={toc:[]};function Ype(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Ype.isMDXComponent=!0;const Hpe={toc:[]};function Qpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Qpe.isMDXComponent=!0;const $pe={toc:[]};function Kpe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Kpe.isMDXComponent=!0;const Jpe={toc:[]};function tre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}tre.isMDXComponent=!0;const ere={toc:[]};function nre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ere,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}nre.isMDXComponent=!0;const ore={toc:[]};function pre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ore,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pre.isMDXComponent=!0;const rre={toc:[]};function sre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}sre.isMDXComponent=!0;const cre={toc:[]};function ire(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}ire.isMDXComponent=!0;const are={toc:[]};function lre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},are,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}lre.isMDXComponent=!0;const ure={toc:[]};function mre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ure,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}mre.isMDXComponent=!0;const dre={toc:[]};function hre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}hre.isMDXComponent=!0;const fre={toc:[]};function kre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}kre.isMDXComponent=!0;const yre={toc:[]};function wre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}wre.isMDXComponent=!0;const Dre={toc:[]};function Mre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Mre.isMDXComponent=!0;const Xre={toc:[]};function _re(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}_re.isMDXComponent=!0;const gre={toc:[]};function Tre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Tre.isMDXComponent=!0;const Cre={toc:[]};function xre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}xre.isMDXComponent=!0;const vre={toc:[]};function Lre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Lre.isMDXComponent=!0;const Zre={toc:[]};function bre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}bre.isMDXComponent=!0;const Nre={toc:[]};function zre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}zre.isMDXComponent=!0;const Are={toc:[]};function Wre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Are,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Wre.isMDXComponent=!0;const Ire={toc:[]};function Rre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ire,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Rre.isMDXComponent=!0;const Pre={toc:[]};function Sre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Sre.isMDXComponent=!0;const Ore={toc:[]};function Ere(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ore,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Ere.isMDXComponent=!0;const Bre={toc:[]};function Gre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Gre.isMDXComponent=!0;const Vre={toc:[]};function Ure(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Ure.isMDXComponent=!0;const Fre={toc:[]};function qre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}qre.isMDXComponent=!0;const jre={toc:[]};function Yre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Yre.isMDXComponent=!0;const Hre={toc:[]};function Qre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Qre.isMDXComponent=!0;const $re={toc:[]};function Kre(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Kre.isMDXComponent=!0;const Jre={toc:[]};function tse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}tse.isMDXComponent=!0;const ese={toc:[]};function nse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ese,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}nse.isMDXComponent=!0;const ose={toc:[]};function pse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ose,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}pse.isMDXComponent=!0;const rse={toc:[]};function sse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}sse.isMDXComponent=!0;const cse={toc:[]};function ise(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}ise.isMDXComponent=!0;const ase={toc:[]};function lse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ase,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}lse.isMDXComponent=!0;const use={toc:[]};function mse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},use,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}mse.isMDXComponent=!0;const dse={toc:[]};function hse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}hse.isMDXComponent=!0;const fse={toc:[]};function kse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}kse.isMDXComponent=!0;const yse={toc:[]};function wse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}wse.isMDXComponent=!0;const Dse={toc:[]};function Mse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Mse.isMDXComponent=!0;const Xse={toc:[]};function _se(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}_se.isMDXComponent=!0;const gse={toc:[]};function Tse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Tse.isMDXComponent=!0;const Cse={toc:[]};function xse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}xse.isMDXComponent=!0;const vse={toc:[]};function Lse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Lse.isMDXComponent=!0;const Zse={toc:[]};function bse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}bse.isMDXComponent=!0;const Nse={toc:[]};function zse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}zse.isMDXComponent=!0;const Ase={toc:[]};function Wse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ase,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Wse.isMDXComponent=!0;const Ise={toc:[]};function Rse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ise,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Rse.isMDXComponent=!0;const Pse={toc:[]};function Sse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Sse.isMDXComponent=!0;const Ose={toc:[]};function Ese(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ose,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Ese.isMDXComponent=!0;const Bse={toc:[]};function Gse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Gse.isMDXComponent=!0;const Vse={toc:[]};function Use(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Use.isMDXComponent=!0;const Fse={toc:[]};function qse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}qse.isMDXComponent=!0;const jse={toc:[]};function Yse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Yse.isMDXComponent=!0;const Hse={toc:[]};function Qse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Qse.isMDXComponent=!0;const $se={toc:[]};function Kse(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Kse.isMDXComponent=!0;const Jse={toc:[]};function tce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}tce.isMDXComponent=!0;const ece={toc:[]};function nce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ece,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}nce.isMDXComponent=!0;const oce={toc:[]};function pce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}pce.isMDXComponent=!0;const rce={toc:[]};function sce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}sce.isMDXComponent=!0;const cce={toc:[]};function ice(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}ice.isMDXComponent=!0;const ace={toc:[]};function lce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ace,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lce.isMDXComponent=!0;const uce={toc:[]};function mce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}mce.isMDXComponent=!0;const dce={toc:[]};function hce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}hce.isMDXComponent=!0;const fce={toc:[]};function kce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}kce.isMDXComponent=!0;const yce={toc:[]};function wce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}wce.isMDXComponent=!0;const Dce={toc:[]};function Mce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Mce.isMDXComponent=!0;const Xce={toc:[]};function _ce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}_ce.isMDXComponent=!0;const gce={toc:[]};function Tce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Tce.isMDXComponent=!0;const Cce={toc:[]};function xce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}xce.isMDXComponent=!0;const vce={toc:[]};function Lce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Lce.isMDXComponent=!0;const Zce={toc:[]};function bce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}bce.isMDXComponent=!0;const Nce={toc:[]};function zce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}zce.isMDXComponent=!0;const Ace={toc:[]};function Wce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ace,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Wce.isMDXComponent=!0;const Ice={toc:[]};function Rce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ice,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Rce.isMDXComponent=!0;const Pce={toc:[]};function Sce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Sce.isMDXComponent=!0;const Oce={toc:[]};function Ece(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Ece.isMDXComponent=!0;const Bce={toc:[]};function Gce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Gce.isMDXComponent=!0;const Vce={toc:[]};function Uce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Uce.isMDXComponent=!0;const Fce={toc:[]};function qce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}qce.isMDXComponent=!0;const jce={toc:[]};function Yce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Yce.isMDXComponent=!0;const Hce={toc:[]};function Qce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Qce.isMDXComponent=!0;const $ce={toc:[]};function Kce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Kce.isMDXComponent=!0;const Jce={toc:[]};function tie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}tie.isMDXComponent=!0;const eie={toc:[]};function nie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}nie.isMDXComponent=!0;const oie={toc:[]};function pie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}pie.isMDXComponent=!0;const rie={toc:[]};function sie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}sie.isMDXComponent=!0;const cie={toc:[]};function iie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}iie.isMDXComponent=!0;const aie={toc:[]};function lie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}lie.isMDXComponent=!0;const uie={toc:[]};function mie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}mie.isMDXComponent=!0;const die={toc:[]};function hie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},die,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}hie.isMDXComponent=!0;const fie={toc:[]};function kie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}kie.isMDXComponent=!0;const yie={toc:[]};function wie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you're not interested in animating SVG, you can use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img"},(0,s.kt)("inlineCode",{parentName:"a"},"Img"))," instead."))}wie.isMDXComponent=!0;const Die={toc:[]};function Mie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Die,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A Node for drawing and animating SVG images."))}Mie.isMDXComponent=!0;const Xie={toc:[]};function _ie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}_ie.isMDXComponent=!0;const gie={toc:[]};function Tie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Tie.isMDXComponent=!0;const Cie={toc:[]};function xie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}xie.isMDXComponent=!0;const vie={toc:[]};function Lie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Lie.isMDXComponent=!0;const Zie={toc:[]};function bie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}bie.isMDXComponent=!0;const Nie={toc:[]};function zie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}zie.isMDXComponent=!0;const Aie={toc:[]};function Wie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Wie.isMDXComponent=!0;const Iie={toc:[]};function Rie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Rie.isMDXComponent=!0;const Pie={toc:[]};function Sie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Sie.isMDXComponent=!0;const Oie={toc:[]};function Eie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Eie.isMDXComponent=!0;const Bie={toc:[]};function Gie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Gie.isMDXComponent=!0;const Vie={toc:[]};function Uie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Uie.isMDXComponent=!0;const Fie={toc:[]};function qie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}qie.isMDXComponent=!0;const jie={toc:[]};function Yie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Yie.isMDXComponent=!0;const Hie={toc:[]};function Qie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Qie.isMDXComponent=!0;const $ie={toc:[]};function Kie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Kie.isMDXComponent=!0;const Jie={toc:[]};function tae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}tae.isMDXComponent=!0;const eae={toc:[]};function nae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}nae.isMDXComponent=!0;const oae={toc:[]};function pae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}pae.isMDXComponent=!0;const rae={toc:[]};function sae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}sae.isMDXComponent=!0;const cae={toc:[]};function iae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}iae.isMDXComponent=!0;const aae={toc:[]};function lae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lae.isMDXComponent=!0;const uae={toc:[]};function mae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}mae.isMDXComponent=!0;const dae={toc:[]};function hae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}hae.isMDXComponent=!0;const fae={toc:[]};function kae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}kae.isMDXComponent=!0;const yae={toc:[]};function wae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}wae.isMDXComponent=!0;const Dae={toc:[]};function Mae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Mae.isMDXComponent=!0;const Xae={toc:[]};function _ae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}_ae.isMDXComponent=!0;const gae={toc:[]};function Tae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Tae.isMDXComponent=!0;const Cae={toc:[]};function xae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}xae.isMDXComponent=!0;const vae={toc:[]};function Lae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"SVG string to be rendered"))}Lae.isMDXComponent=!0;const Zae={toc:[]};function bae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}bae.isMDXComponent=!0;const Nae={toc:[]};function zae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}zae.isMDXComponent=!0;const Aae={toc:[]};function Wae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Wae.isMDXComponent=!0;const Iae={toc:[]};function Rae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Rae.isMDXComponent=!0;const Pae={toc:[]};function Sae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Sae.isMDXComponent=!0;const Oae={toc:[]};function Eae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Eae.isMDXComponent=!0;const Bae={toc:[]};function Gae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Child to wrap all SVG node"))}Gae.isMDXComponent=!0;const Vae={toc:[]};function Uae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Uae.isMDXComponent=!0;const Fae={toc:[]};function qae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}qae.isMDXComponent=!0;const jae={toc:[]};function Yae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Yae.isMDXComponent=!0;const Hae={toc:[]};function Qae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Qae.isMDXComponent=!0;const $ae={toc:[]};function Kae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Kae.isMDXComponent=!0;const Jae={toc:[]};function tle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}tle.isMDXComponent=!0;const ele={toc:[]};function nle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ele,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}nle.isMDXComponent=!0;const ole={toc:[]};function ple(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ole,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData")," to convert."))}ple.isMDXComponent=!0;const rle={toc:[]};function sle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGShapeData")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGShape"),"."))}sle.isMDXComponent=!0;const cle={toc:[]};function ile(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"SVGShapeData")," to convert."))}ile.isMDXComponent=!0;const ale={toc:[]};function lle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ale,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}lle.isMDXComponent=!0;const ule={toc:[]};function mle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ule,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}mle.isMDXComponent=!0;const dle={toc:[]};function hle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}hle.isMDXComponent=!0;const fle={toc:[]};function kle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}kle.isMDXComponent=!0;const yle={toc:[]};function wle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}wle.isMDXComponent=!0;const Dle={toc:[]};function Mle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Mle.isMDXComponent=!0;const Xle={toc:[]};function _le(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}_le.isMDXComponent=!0;const gle={toc:[]};function Tle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Tle.isMDXComponent=!0;const Cle={toc:[]};function xle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}xle.isMDXComponent=!0;const vle={toc:[]};function Lle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Lle.isMDXComponent=!0;const Zle={toc:[]};function ble(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}ble.isMDXComponent=!0;const Nle={toc:[]};function zle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}zle.isMDXComponent=!0;const Ale={toc:[]};function Wle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ale,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Wle.isMDXComponent=!0;const Ile={toc:[]};function Rle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ile,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Rle.isMDXComponent=!0;const Ple={toc:[]};function Sle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ple,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Sle.isMDXComponent=!0;const Ole={toc:[]};function Ele(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ole,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Ele.isMDXComponent=!0;const Ble={toc:[]};function Gle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ble,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Gle.isMDXComponent=!0;const Vle={toc:[]};function Ule(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Ule.isMDXComponent=!0;const Fle={toc:[]};function qle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}qle.isMDXComponent=!0;const jle={toc:[]};function Yle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Yle.isMDXComponent=!0;const Hle={toc:[]};function Qle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a tweening list to tween between two SVG nodes."))}Qle.isMDXComponent=!0;const $le={toc:[]};function Kle(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial node,"))}Kle.isMDXComponent=!0;const Jle={toc:[]};function tue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The final node."))}tue.isMDXComponent=!0;const eue={toc:[]};function nue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}nue.isMDXComponent=!0;const oue={toc:[]};function pue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function."))}pue.isMDXComponent=!0;const rue={toc:[]};function sue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}sue.isMDXComponent=!0;const cue={toc:[]};function iue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}iue.isMDXComponent=!0;const aue={toc:[]};function lue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get all SVG nodes with the given id."))}lue.isMDXComponent=!0;const uue={toc:[]};function mue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An id to query."))}mue.isMDXComponent=!0;const due={toc:[]};function hue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},due,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}hue.isMDXComponent=!0;const fue={toc:[]};function kue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}kue.isMDXComponent=!0;const yue={toc:[]};function wue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}wue.isMDXComponent=!0;const Due={toc:[]};function Mue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Due,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Mue.isMDXComponent=!0;const Xue={toc:[]};function _ue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}_ue.isMDXComponent=!0;const gue={toc:[]};function Tue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Tue.isMDXComponent=!0;const Cue={toc:[]};function xue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}xue.isMDXComponent=!0;const vue={toc:[]};function Lue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Lue.isMDXComponent=!0;const Zue={toc:[]};function bue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}bue.isMDXComponent=!0;const Nue={toc:[]};function zue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}zue.isMDXComponent=!0;const Aue={toc:[]};function Wue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Wue.isMDXComponent=!0;const Iue={toc:[]};function Rue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Rue.isMDXComponent=!0;const Pue={toc:[]};function Sue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Sue.isMDXComponent=!0;const Oue={toc:[]};function Eue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Eue.isMDXComponent=!0;const Bue={toc:[]};function Gue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Gue.isMDXComponent=!0;const Vue={toc:[]};function Uue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Uue.isMDXComponent=!0;const Fue={toc:[]};function que(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}que.isMDXComponent=!0;const jue={toc:[]};function Yue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Yue.isMDXComponent=!0;const Hue={toc:[]};function Que(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Que.isMDXComponent=!0;const $ue={toc:[]};function Kue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Kue.isMDXComponent=!0;const Jue={toc:[]};function tme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}tme.isMDXComponent=!0;const eme={toc:[]};function nme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}nme.isMDXComponent=!0;const ome={toc:[]};function pme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ome,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}pme.isMDXComponent=!0;const rme={toc:[]};function sme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}sme.isMDXComponent=!0;const cme={toc:[]};function ime(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}ime.isMDXComponent=!0;const ame={toc:[]};function lme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ame,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}lme.isMDXComponent=!0;const ume={toc:[]};function mme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ume,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}mme.isMDXComponent=!0;const dme={toc:[]};function hme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}hme.isMDXComponent=!0;const fme={toc:[]};function kme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}kme.isMDXComponent=!0;const yme={toc:[]};function wme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}wme.isMDXComponent=!0;const Dme={toc:[]};function Mme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Mme.isMDXComponent=!0;const Xme={toc:[]};function _me(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}_me.isMDXComponent=!0;const gme={toc:[]};function Tme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Tme.isMDXComponent=!0;const Cme={toc:[]};function xme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}xme.isMDXComponent=!0;const vme={toc:[]};function Lme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Lme.isMDXComponent=!0;const Zme={toc:[]};function bme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}bme.isMDXComponent=!0;const Nme={toc:[]};function zme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}zme.isMDXComponent=!0;const Ame={toc:[]};function Wme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ame,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Wme.isMDXComponent=!0;const Ime={toc:[]};function Rme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ime,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Rme.isMDXComponent=!0;const Pme={toc:[]};function Sme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Sme.isMDXComponent=!0;const Ome={toc:[]};function Eme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ome,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Eme.isMDXComponent=!0;const Bme={toc:[]};function Gme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert an SVG string to ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}Gme.isMDXComponent=!0;const Vme={toc:[]};function Ume(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An SVG string to be parsed."))}Ume.isMDXComponent=!0;const Fme={toc:[]};function qme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}qme.isMDXComponent=!0;const jme={toc:[]};function Yme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Yme.isMDXComponent=!0;const Hme={toc:[]};function Qme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Qme.isMDXComponent=!0;const $me={toc:[]};function Kme(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Kme.isMDXComponent=!0;const Jme={toc:[]};function tde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}tde.isMDXComponent=!0;const ede={toc:[]};function nde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ede,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}nde.isMDXComponent=!0;const ode={toc:[]};function pde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ode,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pde.isMDXComponent=!0;const rde={toc:[]};function sde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}sde.isMDXComponent=!0;const cde={toc:[]};function ide(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}ide.isMDXComponent=!0;const ade={toc:[]};function lde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ade,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}lde.isMDXComponent=!0;const ude={toc:[]};function mde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ude,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}mde.isMDXComponent=!0;const dde={toc:[]};function hde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}hde.isMDXComponent=!0;const fde={toc:[]};function kde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}kde.isMDXComponent=!0;const yde={toc:[]};function wde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}wde.isMDXComponent=!0;const Dde={toc:[]};function Mde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Mde.isMDXComponent=!0;const Xde={toc:[]};function _de(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}_de.isMDXComponent=!0;const gde={toc:[]};function Tde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Tde.isMDXComponent=!0;const Cde={toc:[]};function xde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}xde.isMDXComponent=!0;const vde={toc:[]};function Lde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Lde.isMDXComponent=!0;const Zde={toc:[]};function bde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}bde.isMDXComponent=!0;const Nde={toc:[]};function zde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}zde.isMDXComponent=!0;const Ade={toc:[]};function Wde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ade,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Wde.isMDXComponent=!0;const Ide={toc:[]};function Rde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ide,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Rde.isMDXComponent=!0;const Pde={toc:[]};function Sde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Sde.isMDXComponent=!0;const Ode={toc:[]};function Ede(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ode,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Ede.isMDXComponent=!0;const Bde={toc:[]};function Gde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Gde.isMDXComponent=!0;const Vde={toc:[]};function Ude(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Ude.isMDXComponent=!0;const Fde={toc:[]};function qde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}qde.isMDXComponent=!0;const jde={toc:[]};function Yde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Yde.isMDXComponent=!0;const Hde={toc:[]};function Qde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Qde.isMDXComponent=!0;const $de={toc:[]};function Kde(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$de,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Kde.isMDXComponent=!0;const Jde={toc:[]};function the(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}the.isMDXComponent=!0;const ehe={toc:[]};function nhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ehe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}nhe.isMDXComponent=!0;const ohe={toc:[]};function phe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ohe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}phe.isMDXComponent=!0;const rhe={toc:[]};function she(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}she.isMDXComponent=!0;const che={toc:[]};function ihe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},che,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}ihe.isMDXComponent=!0;const ahe={toc:[]};function lhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ahe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"MotionCanvas Shape properties"))}lhe.isMDXComponent=!0;const uhe={toc:[]};function mhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get position, rotation and scale from Matrix transformation as Shape properties"))}mhe.isMDXComponent=!0;const dhe={toc:[]};function hhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Matrix transformation"))}hhe.isMDXComponent=!0;const fhe={toc:[]};function khe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData")," that can be used to build SVGDocument."))}khe.isMDXComponent=!0;const yhe={toc:[]};function whe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse an SVG string as ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData"),"."))}whe.isMDXComponent=!0;const Dhe={toc:[]};function Mhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"And SVG string to be parsed."))}Mhe.isMDXComponent=!0;const Xhe={toc:[]};function _he(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}_he.isMDXComponent=!0;const ghe={toc:[]};function The(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ghe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}The.isMDXComponent=!0;const Che={toc:[]};function xhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Che,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}xhe.isMDXComponent=!0;const vhe={toc:[]};function Lhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Lhe.isMDXComponent=!0;const Zhe={toc:[]};function bhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}bhe.isMDXComponent=!0;const Nhe={toc:[]};function zhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}zhe.isMDXComponent=!0;const Ahe={toc:[]};function Whe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ahe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Whe.isMDXComponent=!0;const Ihe={toc:[]};function Rhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ihe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Rhe.isMDXComponent=!0;const Phe={toc:[]};function She(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Phe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}She.isMDXComponent=!0;const Ohe={toc:[]};function Ehe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ohe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Ehe.isMDXComponent=!0;const Bhe={toc:[]};function Ghe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Ghe.isMDXComponent=!0;const Vhe={toc:[]};function Uhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Uhe.isMDXComponent=!0;const Fhe={toc:[]};function qhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}qhe.isMDXComponent=!0;const jhe={toc:[]};function Yhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Yhe.isMDXComponent=!0;const Hhe={toc:[]};function Qhe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Qhe.isMDXComponent=!0;const $he={toc:[]};function Khe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$he,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Khe.isMDXComponent=!0;const Jhe={toc:[]};function tfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}tfe.isMDXComponent=!0;const efe={toc:[]};function nfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},efe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}nfe.isMDXComponent=!0;const ofe={toc:[]};function pfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ofe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}pfe.isMDXComponent=!0;const rfe={toc:[]};function sfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}sfe.isMDXComponent=!0;const cfe={toc:[]};function ife(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}ife.isMDXComponent=!0;const afe={toc:[]};function lfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},afe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lfe.isMDXComponent=!0;const ufe={toc:[]};function mfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ufe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}mfe.isMDXComponent=!0;const dfe={toc:[]};function hfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}hfe.isMDXComponent=!0;const ffe={toc:[]};function kfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ffe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}kfe.isMDXComponent=!0;const yfe={toc:[]};function wfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}wfe.isMDXComponent=!0;const Dfe={toc:[]};function Mfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Mfe.isMDXComponent=!0;const Xfe={toc:[]};function _fe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}_fe.isMDXComponent=!0;const gfe={toc:[]};function Tfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Tfe.isMDXComponent=!0;const Cfe={toc:[]};function xfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}xfe.isMDXComponent=!0;const vfe={toc:[]};function Lfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Lfe.isMDXComponent=!0;const Zfe={toc:[]};function bfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}bfe.isMDXComponent=!0;const Nfe={toc:[]};function zfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}zfe.isMDXComponent=!0;const Afe={toc:[]};function Wfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Afe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Wfe.isMDXComponent=!0;const Ife={toc:[]};function Rfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ife,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Rfe.isMDXComponent=!0;const Pfe={toc:[]};function Sfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Sfe.isMDXComponent=!0;const Ofe={toc:[]};function Efe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ofe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Efe.isMDXComponent=!0;const Bfe={toc:[]};function Gfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Gfe.isMDXComponent=!0;const Vfe={toc:[]};function Ufe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Ufe.isMDXComponent=!0;const Ffe={toc:[]};function qfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ffe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}qfe.isMDXComponent=!0;const jfe={toc:[]};function Yfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Yfe.isMDXComponent=!0;const Hfe={toc:[]};function Qfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Qfe.isMDXComponent=!0;const $fe={toc:[]};function Kfe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Kfe.isMDXComponent=!0;const Jfe={toc:[]};function tke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}tke.isMDXComponent=!0;const eke={toc:[]};function nke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}nke.isMDXComponent=!0;const oke={toc:[]};function pke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pke.isMDXComponent=!0;const rke={toc:[]};function ske(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}ske.isMDXComponent=!0;const cke={toc:[]};function ike(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}ike.isMDXComponent=!0;const ake={toc:[]};function lke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ake,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}lke.isMDXComponent=!0;const uke={toc:[]};function mke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}mke.isMDXComponent=!0;const dke={toc:[]};function hke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}hke.isMDXComponent=!0;const fke={toc:[]};function kke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}kke.isMDXComponent=!0;const yke={toc:[]};function wke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}wke.isMDXComponent=!0;const Dke={toc:[]};function Mke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Mke.isMDXComponent=!0;const Xke={toc:[]};function _ke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}_ke.isMDXComponent=!0;const gke={toc:[]};function Tke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Tke.isMDXComponent=!0;const Cke={toc:[]};function xke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}xke.isMDXComponent=!0;const vke={toc:[]};function Lke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Lke.isMDXComponent=!0;const Zke={toc:[]};function bke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}bke.isMDXComponent=!0;const Nke={toc:[]};function zke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}zke.isMDXComponent=!0;const Ake={toc:[]};function Wke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ake,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Wke.isMDXComponent=!0;const Ike={toc:[]};function Rke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ike,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Rke.isMDXComponent=!0;const Pke={toc:[]};function Ske(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Ske.isMDXComponent=!0;const Oke={toc:[]};function Eke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Eke.isMDXComponent=!0;const Bke={toc:[]};function Gke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Gke.isMDXComponent=!0;const Vke={toc:[]};function Uke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Uke.isMDXComponent=!0;const Fke={toc:[]};function qke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}qke.isMDXComponent=!0;const jke={toc:[]};function Yke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Yke.isMDXComponent=!0;const Hke={toc:[]};function Qke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Qke.isMDXComponent=!0;const $ke={toc:[]};function Kke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Kke.isMDXComponent=!0;const Jke={toc:[]};function tye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}tye.isMDXComponent=!0;const eye={toc:[]};function nye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}nye.isMDXComponent=!0;const oye={toc:[]};function pye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}pye.isMDXComponent=!0;const rye={toc:[]};function sye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}sye.isMDXComponent=!0;const cye={toc:[]};function iye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}iye.isMDXComponent=!0;const aye={toc:[]};function lye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}lye.isMDXComponent=!0;const uye={toc:[]};function mye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}mye.isMDXComponent=!0;const dye={toc:[]};function hye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}hye.isMDXComponent=!0;const fye={toc:[]};function kye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}kye.isMDXComponent=!0;const yye={toc:[]};function wye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}wye.isMDXComponent=!0;const Dye={toc:[]};function Mye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Mye.isMDXComponent=!0;const Xye={toc:[]};function _ye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}_ye.isMDXComponent=!0;const gye={toc:[]};function Tye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Tye.isMDXComponent=!0;const Cye={toc:[]};function xye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}xye.isMDXComponent=!0;const vye={toc:[]};function Lye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Lye.isMDXComponent=!0;const Zye={toc:[]};function bye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}bye.isMDXComponent=!0;const Nye={toc:[]};function zye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}zye.isMDXComponent=!0;const Aye={toc:[]};function Wye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Wye.isMDXComponent=!0;const Iye={toc:[]};function Rye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Rye.isMDXComponent=!0;const Pye={toc:[]};function Sye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Sye.isMDXComponent=!0;const Oye={toc:[]};function Eye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Eye.isMDXComponent=!0;const Bye={toc:[]};function Gye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Gye.isMDXComponent=!0;const Vye={toc:[]};function Uye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Uye.isMDXComponent=!0;const Fye={toc:[]};function qye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}qye.isMDXComponent=!0;const jye={toc:[]};function Yye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Yye.isMDXComponent=!0;const Hye={toc:[]};function Qye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Qye.isMDXComponent=!0;const $ye={toc:[]};function Kye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Kye.isMDXComponent=!0;const Jye={toc:[]};function twe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}twe.isMDXComponent=!0;const ewe={toc:[]};function nwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ewe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}nwe.isMDXComponent=!0;const owe={toc:[]};function pwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},owe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}pwe.isMDXComponent=!0;const rwe={toc:[]};function swe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}swe.isMDXComponent=!0;const cwe={toc:[]};function iwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}iwe.isMDXComponent=!0;const awe={toc:[]};function lwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},awe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}lwe.isMDXComponent=!0;const uwe={toc:[]};function mwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}mwe.isMDXComponent=!0;const dwe={toc:[]};function hwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}hwe.isMDXComponent=!0;const fwe={toc:[]};function kwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}kwe.isMDXComponent=!0;const ywe={toc:[]};function wwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ywe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}wwe.isMDXComponent=!0;const Dwe={toc:[]};function Mwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Mwe.isMDXComponent=!0;const Xwe={toc:[]};function _we(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}_we.isMDXComponent=!0;const gwe={toc:[]};function Twe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Twe.isMDXComponent=!0;const Cwe={toc:[]};function xwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}xwe.isMDXComponent=!0;const vwe={toc:[]};function Lwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Lwe.isMDXComponent=!0;const Zwe={toc:[]};function bwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}bwe.isMDXComponent=!0;const Nwe={toc:[]};function zwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}zwe.isMDXComponent=!0;const Awe={toc:[]};function Wwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Awe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Wwe.isMDXComponent=!0;const Iwe={toc:[]};function Rwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Rwe.isMDXComponent=!0;const Pwe={toc:[]};function Swe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Swe.isMDXComponent=!0;const Owe={toc:[]};function Ewe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Owe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Ewe.isMDXComponent=!0;const Bwe={toc:[]};function Gwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Gwe.isMDXComponent=!0;const Vwe={toc:[]};function Uwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Uwe.isMDXComponent=!0;const Fwe={toc:[]};function qwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}qwe.isMDXComponent=!0;const jwe={toc:[]};function Ywe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Ywe.isMDXComponent=!0;const Hwe={toc:[]};function Qwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Qwe.isMDXComponent=!0;const $we={toc:[]};function Kwe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$we,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Kwe.isMDXComponent=!0;const Jwe={toc:[]};function tDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}tDe.isMDXComponent=!0;const eDe={toc:[]};function nDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}nDe.isMDXComponent=!0;const oDe={toc:[]};function pDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}pDe.isMDXComponent=!0;const rDe={toc:[]};function sDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}sDe.isMDXComponent=!0;const cDe={toc:[]};function iDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}iDe.isMDXComponent=!0;const aDe={toc:[]};function lDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}lDe.isMDXComponent=!0;const uDe={toc:[]};function mDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}mDe.isMDXComponent=!0;const dDe={toc:[]};function hDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}hDe.isMDXComponent=!0;const fDe={toc:[]};function kDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}kDe.isMDXComponent=!0;const yDe={toc:[]};function wDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}wDe.isMDXComponent=!0;const DDe={toc:[]};function MDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}MDe.isMDXComponent=!0;const XDe={toc:[]};function _De(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}_De.isMDXComponent=!0;const gDe={toc:[]};function TDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}TDe.isMDXComponent=!0;const CDe={toc:[]};function xDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}xDe.isMDXComponent=!0;const vDe={toc:[]};function LDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}LDe.isMDXComponent=!0;const ZDe={toc:[]};function bDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}bDe.isMDXComponent=!0;const NDe={toc:[]};function zDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}zDe.isMDXComponent=!0;const ADe={toc:[]};function WDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ADe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}WDe.isMDXComponent=!0;const IDe={toc:[]};function RDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining knots using the ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.kt)("p",null,"Defining knots with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}RDe.isMDXComponent=!0;const PDe={toc:[]};function SDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a smooth line through a number of points."))}SDe.isMDXComponent=!0;const ODe={toc:[]};function EDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ODe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}EDe.isMDXComponent=!0;const BDe={toc:[]};function GDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}GDe.isMDXComponent=!0;const VDe={toc:[]};function UDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}UDe.isMDXComponent=!0;const FDe={toc:[]};function qDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}qDe.isMDXComponent=!0;const jDe={toc:[]};function YDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}YDe.isMDXComponent=!0;const HDe={toc:[]};function QDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}QDe.isMDXComponent=!0;const $De={toc:[]};function KDe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$De,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}KDe.isMDXComponent=!0;const JDe={toc:[]};function tMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}tMe.isMDXComponent=!0;const eMe={toc:[]};function nMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}nMe.isMDXComponent=!0;const oMe={toc:[]};function pMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}pMe.isMDXComponent=!0;const rMe={toc:[]};function sMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}sMe.isMDXComponent=!0;const cMe={toc:[]};function iMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}iMe.isMDXComponent=!0;const aMe={toc:[]};function lMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}lMe.isMDXComponent=!0;const uMe={toc:[]};function mMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}mMe.isMDXComponent=!0;const dMe={toc:[]};function hMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}hMe.isMDXComponent=!0;const fMe={toc:[]};function kMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}kMe.isMDXComponent=!0;const yMe={toc:[]};function wMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wMe.isMDXComponent=!0;const DMe={toc:[]};function MMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}MMe.isMDXComponent=!0;const XMe={toc:[]};function _Me(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}_Me.isMDXComponent=!0;const gMe={toc:[]};function TMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}TMe.isMDXComponent=!0;const CMe={toc:[]};function xMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}xMe.isMDXComponent=!0;const vMe={toc:[]};function LMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}LMe.isMDXComponent=!0;const ZMe={toc:[]};function bMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}bMe.isMDXComponent=!0;const NMe={toc:[]};function zMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}zMe.isMDXComponent=!0;const AMe={toc:[]};function WMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}WMe.isMDXComponent=!0;const IMe={toc:[]};function RMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}RMe.isMDXComponent=!0;const PMe={toc:[]};function SMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}SMe.isMDXComponent=!0;const OMe={toc:[]};function EMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}EMe.isMDXComponent=!0;const BMe={toc:[]};function GMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}GMe.isMDXComponent=!0;const VMe={toc:[]};function UMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}UMe.isMDXComponent=!0;const FMe={toc:[]};function qMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}qMe.isMDXComponent=!0;const jMe={toc:[]};function YMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}YMe.isMDXComponent=!0;const HMe={toc:[]};function QMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}QMe.isMDXComponent=!0;const $Me={toc:[]};function KMe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}KMe.isMDXComponent=!0;const JMe={toc:[]};function tXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}tXe.isMDXComponent=!0;const eXe={toc:[]};function nXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}nXe.isMDXComponent=!0;const oXe={toc:[]};function pXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}pXe.isMDXComponent=!0;const rXe={toc:[]};function sXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}sXe.isMDXComponent=!0;const cXe={toc:[]};function iXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}iXe.isMDXComponent=!0;const aXe={toc:[]};function lXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}lXe.isMDXComponent=!0;const uXe={toc:[]};function mXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}mXe.isMDXComponent=!0;const dXe={toc:[]};function hXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0.4"))}hXe.isMDXComponent=!0;const fXe={toc:[]};function kXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}kXe.isMDXComponent=!0;const yXe={toc:[]};function wXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wXe.isMDXComponent=!0;const DXe={toc:[]};function MXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}MXe.isMDXComponent=!0;const XXe={toc:[]};function _Xe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}_Xe.isMDXComponent=!0;const gXe={toc:[]};function TXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}TXe.isMDXComponent=!0;const CXe={toc:[]};function xXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}xXe.isMDXComponent=!0;const vXe={toc:[]};function LXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}LXe.isMDXComponent=!0;const ZXe={toc:[]};function bXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}bXe.isMDXComponent=!0;const NXe={toc:[]};function zXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}zXe.isMDXComponent=!0;const AXe={toc:[]};function WXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}WXe.isMDXComponent=!0;const IXe={toc:[]};function RXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}RXe.isMDXComponent=!0;const PXe={toc:[]};function SXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}SXe.isMDXComponent=!0;const OXe={toc:[]};function EXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}EXe.isMDXComponent=!0;const BXe={toc:[]};function GXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}GXe.isMDXComponent=!0;const VXe={toc:[]};function UXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}UXe.isMDXComponent=!0;const FXe={toc:[]};function qXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}qXe.isMDXComponent=!0;const jXe={toc:[]};function YXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}YXe.isMDXComponent=!0;const HXe={toc:[]};function QXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}QXe.isMDXComponent=!0;const $Xe={toc:[]};function KXe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}KXe.isMDXComponent=!0;const JXe={toc:[]};function t_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}t_e.isMDXComponent=!0;const e_e={toc:[]};function n_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}n_e.isMDXComponent=!0;const o_e={toc:[]};function p_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}p_e.isMDXComponent=!0;const r_e={toc:[]};function s_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}s_e.isMDXComponent=!0;const c_e={toc:[]};function i_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}i_e.isMDXComponent=!0;const a_e={toc:[]};function l_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}l_e.isMDXComponent=!0;const u_e={toc:[]};function m_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}m_e.isMDXComponent=!0;const d_e={toc:[]};function h_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}h_e.isMDXComponent=!0;const f_e={toc:[]};function k_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}k_e.isMDXComponent=!0;const y_e={toc:[]};function w_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}w_e.isMDXComponent=!0;const D_e={toc:[]};function M_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}M_e.isMDXComponent=!0;const X_e={toc:[]};function __e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}__e.isMDXComponent=!0;const g_e={toc:[]};function T_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}T_e.isMDXComponent=!0;const C_e={toc:[]};function x_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}x_e.isMDXComponent=!0;const v_e={toc:[]};function L_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}L_e.isMDXComponent=!0;const Z_e={toc:[]};function b_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}b_e.isMDXComponent=!0;const N_e={toc:[]};function z_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}z_e.isMDXComponent=!0;const A_e={toc:[]};function W_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}W_e.isMDXComponent=!0;const I_e={toc:[]};function R_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}R_e.isMDXComponent=!0;const P_e={toc:[]};function S_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}S_e.isMDXComponent=!0;const O_e={toc:[]};function E_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}E_e.isMDXComponent=!0;const B_e={toc:[]};function G_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}G_e.isMDXComponent=!0;const V_e={toc:[]};function U_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}U_e.isMDXComponent=!0;const F_e={toc:[]};function q_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}q_e.isMDXComponent=!0;const j_e={toc:[]};function Y_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Y_e.isMDXComponent=!0;const H_e={toc:[]};function Q_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Q_e.isMDXComponent=!0;const $_e={toc:[]};function K_e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}K_e.isMDXComponent=!0;const J_e={toc:[]};function tge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}tge.isMDXComponent=!0;const ege={toc:[]};function nge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ege,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}nge.isMDXComponent=!0;const oge={toc:[]};function pge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pge.isMDXComponent=!0;const rge={toc:[]};function sge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}sge.isMDXComponent=!0;const cge={toc:[]};function ige(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}ige.isMDXComponent=!0;const age={toc:[]};function lge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},age,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}lge.isMDXComponent=!0;const uge={toc:[]};function mge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}mge.isMDXComponent=!0;const dge={toc:[]};function hge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}hge.isMDXComponent=!0;const fge={toc:[]};function kge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}kge.isMDXComponent=!0;const yge={toc:[]};function wge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}wge.isMDXComponent=!0;const Dge={toc:[]};function Mge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Mge.isMDXComponent=!0;const Xge={toc:[]};function _ge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}_ge.isMDXComponent=!0;const gge={toc:[]};function Tge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Tge.isMDXComponent=!0;const Cge={toc:[]};function xge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}xge.isMDXComponent=!0;const vge={toc:[]};function Lge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Lge.isMDXComponent=!0;const Zge={toc:[]};function bge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}bge.isMDXComponent=!0;const Nge={toc:[]};function zge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}zge.isMDXComponent=!0;const Age={toc:[]};function Wge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Age,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Wge.isMDXComponent=!0;const Ige={toc:[]};function Rge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ige,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Rge.isMDXComponent=!0;const Pge={toc:[]};function Sge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Sge.isMDXComponent=!0;const Oge={toc:[]};function Ege(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Ege.isMDXComponent=!0;const Bge={toc:[]};function Gge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Gge.isMDXComponent=!0;const Vge={toc:[]};function Uge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Uge.isMDXComponent=!0;const Fge={toc:[]};function qge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}qge.isMDXComponent=!0;const jge={toc:[]};function Yge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Yge.isMDXComponent=!0;const Hge={toc:[]};function Qge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Qge.isMDXComponent=!0;const $ge={toc:[]};function Kge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Kge.isMDXComponent=!0;const Jge={toc:[]};function tTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}tTe.isMDXComponent=!0;const eTe={toc:[]};function nTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}nTe.isMDXComponent=!0;const oTe={toc:[]};function pTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}pTe.isMDXComponent=!0;const rTe={toc:[]};function sTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}sTe.isMDXComponent=!0;const cTe={toc:[]};function iTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}iTe.isMDXComponent=!0;const aTe={toc:[]};function lTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lTe.isMDXComponent=!0;const uTe={toc:[]};function mTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}mTe.isMDXComponent=!0;const dTe={toc:[]};function hTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}hTe.isMDXComponent=!0;const fTe={toc:[]};function kTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}kTe.isMDXComponent=!0;const yTe={toc:[]};function wTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}wTe.isMDXComponent=!0;const DTe={toc:[]};function MTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}MTe.isMDXComponent=!0;const XTe={toc:[]};function _Te(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}_Te.isMDXComponent=!0;const gTe={toc:[]};function TTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}TTe.isMDXComponent=!0;const CTe={toc:[]};function xTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}xTe.isMDXComponent=!0;const vTe={toc:[]};function LTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}LTe.isMDXComponent=!0;const ZTe={toc:[]};function bTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}bTe.isMDXComponent=!0;const NTe={toc:[]};function zTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}zTe.isMDXComponent=!0;const ATe={toc:[]};function WTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ATe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}WTe.isMDXComponent=!0;const ITe={toc:[]};function RTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ITe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}RTe.isMDXComponent=!0;const PTe={toc:[]};function STe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}STe.isMDXComponent=!0;const OTe={toc:[]};function ETe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}ETe.isMDXComponent=!0;const BTe={toc:[]};function GTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}GTe.isMDXComponent=!0;const VTe={toc:[]};function UTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}UTe.isMDXComponent=!0;const FTe={toc:[]};function qTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}qTe.isMDXComponent=!0;const jTe={toc:[]};function YTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}YTe.isMDXComponent=!0;const HTe={toc:[]};function QTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}QTe.isMDXComponent=!0;const $Te={toc:[]};function KTe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Te,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}KTe.isMDXComponent=!0;const JTe={toc:[]};function tCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}tCe.isMDXComponent=!0;const eCe={toc:[]};function nCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}nCe.isMDXComponent=!0;const oCe={toc:[]};function pCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pCe.isMDXComponent=!0;const rCe={toc:[]};function sCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}sCe.isMDXComponent=!0;const cCe={toc:[]};function iCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}iCe.isMDXComponent=!0;const aCe={toc:[]};function lCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}lCe.isMDXComponent=!0;const uCe={toc:[]};function mCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}mCe.isMDXComponent=!0;const dCe={toc:[]};function hCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}hCe.isMDXComponent=!0;const fCe={toc:[]};function kCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}kCe.isMDXComponent=!0;const yCe={toc:[]};function wCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}wCe.isMDXComponent=!0;const DCe={toc:[]};function MCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}MCe.isMDXComponent=!0;const XCe={toc:[]};function _Ce(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}_Ce.isMDXComponent=!0;const gCe={toc:[]};function TCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}TCe.isMDXComponent=!0;const CCe={toc:[]};function xCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}xCe.isMDXComponent=!0;const vCe={toc:[]};function LCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}LCe.isMDXComponent=!0;const ZCe={toc:[]};function bCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}bCe.isMDXComponent=!0;const NCe={toc:[]};function zCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}zCe.isMDXComponent=!0;const ACe={toc:[]};function WCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ACe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}WCe.isMDXComponent=!0;const ICe={toc:[]};function RCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ICe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}RCe.isMDXComponent=!0;const PCe={toc:[]};function SCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}SCe.isMDXComponent=!0;const OCe={toc:[]};function ECe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}ECe.isMDXComponent=!0;const BCe={toc:[]};function GCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}GCe.isMDXComponent=!0;const VCe={toc:[]};function UCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}UCe.isMDXComponent=!0;const FCe={toc:[]};function qCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qCe.isMDXComponent=!0;const jCe={toc:[]};function YCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}YCe.isMDXComponent=!0;const HCe={toc:[]};function QCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}QCe.isMDXComponent=!0;const $Ce={toc:[]};function KCe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}KCe.isMDXComponent=!0;const JCe={toc:[]};function txe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}txe.isMDXComponent=!0;const exe={toc:[]};function nxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},exe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}nxe.isMDXComponent=!0;const oxe={toc:[]};function pxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}pxe.isMDXComponent=!0;const rxe={toc:[]};function sxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}sxe.isMDXComponent=!0;const cxe={toc:[]};function ixe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}ixe.isMDXComponent=!0;const axe={toc:[]};function lxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},axe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lxe.isMDXComponent=!0;const uxe={toc:[]};function mxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}mxe.isMDXComponent=!0;const dxe={toc:[]};function hxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}hxe.isMDXComponent=!0;const fxe={toc:[]};function kxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}kxe.isMDXComponent=!0;const yxe={toc:[]};function wxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}wxe.isMDXComponent=!0;const Dxe={toc:[]};function Mxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Mxe.isMDXComponent=!0;const Xxe={toc:[]};function _xe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}_xe.isMDXComponent=!0;const gxe={toc:[]};function Txe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Txe.isMDXComponent=!0;const Cxe={toc:[]};function xxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}xxe.isMDXComponent=!0;const vxe={toc:[]};function Lxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Lxe.isMDXComponent=!0;const Zxe={toc:[]};function bxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}bxe.isMDXComponent=!0;const Nxe={toc:[]};function zxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}zxe.isMDXComponent=!0;const Axe={toc:[]};function Wxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Axe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Wxe.isMDXComponent=!0;const Ixe={toc:[]};function Rxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ixe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Rxe.isMDXComponent=!0;const Pxe={toc:[]};function Sxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Sxe.isMDXComponent=!0;const Oxe={toc:[]};function Exe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Exe.isMDXComponent=!0;const Bxe={toc:[]};function Gxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Gxe.isMDXComponent=!0;const Vxe={toc:[]};function Uxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Uxe.isMDXComponent=!0;const Fxe={toc:[]};function qxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qxe.isMDXComponent=!0;const jxe={toc:[]};function Yxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Yxe.isMDXComponent=!0;const Hxe={toc:[]};function Qxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Qxe.isMDXComponent=!0;const $xe={toc:[]};function Kxe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Kxe.isMDXComponent=!0;const Jxe={toc:[]};function tve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}tve.isMDXComponent=!0;const eve={toc:[]};function nve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}nve.isMDXComponent=!0;const ove={toc:[]};function pve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ove,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}pve.isMDXComponent=!0;const rve={toc:[]};function sve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}sve.isMDXComponent=!0;const cve={toc:[]};function ive(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}ive.isMDXComponent=!0;const ave={toc:[]};function lve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ave,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}lve.isMDXComponent=!0;const uve={toc:[]};function mve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}mve.isMDXComponent=!0;const dve={toc:[]};function hve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}hve.isMDXComponent=!0;const fve={toc:[]};function kve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}kve.isMDXComponent=!0;const yve={toc:[]};function wve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}wve.isMDXComponent=!0;const Dve={toc:[]};function Mve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Mve.isMDXComponent=!0;const Xve={toc:[]};function _ve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}_ve.isMDXComponent=!0;const gve={toc:[]};function Tve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Tve.isMDXComponent=!0;const Cve={toc:[]};function xve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}xve.isMDXComponent=!0;const vve={toc:[]};function Lve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Lve.isMDXComponent=!0;const Zve={toc:[]};function bve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}bve.isMDXComponent=!0;const Nve={toc:[]};function zve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}zve.isMDXComponent=!0;const Ave={toc:[]};function Wve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ave,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Wve.isMDXComponent=!0;const Ive={toc:[]};function Rve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ive,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Rve.isMDXComponent=!0;const Pve={toc:[]};function Sve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Sve.isMDXComponent=!0;const Ove={toc:[]};function Eve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ove,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Eve.isMDXComponent=!0;const Bve={toc:[]};function Gve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Gve.isMDXComponent=!0;const Vve={toc:[]};function Uve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Uve.isMDXComponent=!0;const Fve={toc:[]};function qve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}qve.isMDXComponent=!0;const jve={toc:[]};function Yve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Yve.isMDXComponent=!0;const Hve={toc:[]};function Qve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Qve.isMDXComponent=!0;const $ve={toc:[]};function Kve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Kve.isMDXComponent=!0;const Jve={toc:[]};function tLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}tLe.isMDXComponent=!0;const eLe={toc:[]};function nLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}nLe.isMDXComponent=!0;const oLe={toc:[]};function pLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}pLe.isMDXComponent=!0;const rLe={toc:[]};function sLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}sLe.isMDXComponent=!0;const cLe={toc:[]};function iLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}iLe.isMDXComponent=!0;const aLe={toc:[]};function lLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}lLe.isMDXComponent=!0;const uLe={toc:[]};function mLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}mLe.isMDXComponent=!0;const dLe={toc:[]};function hLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}hLe.isMDXComponent=!0;const fLe={toc:[]};function kLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kLe.isMDXComponent=!0;const yLe={toc:[]};function wLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}wLe.isMDXComponent=!0;const DLe={toc:[]};function MLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}MLe.isMDXComponent=!0;const XLe={toc:[]};function _Le(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}_Le.isMDXComponent=!0;const gLe={toc:[]};function TLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}TLe.isMDXComponent=!0;const CLe={toc:[]};function xLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}xLe.isMDXComponent=!0;const vLe={toc:[]};function LLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}LLe.isMDXComponent=!0;const ZLe={toc:[]};function bLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}bLe.isMDXComponent=!0;const NLe={toc:[]};function zLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}zLe.isMDXComponent=!0;const ALe={toc:[]};function WLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ALe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}WLe.isMDXComponent=!0;const ILe={toc:[]};function RLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ILe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}RLe.isMDXComponent=!0;const PLe={toc:[]};function SLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}SLe.isMDXComponent=!0;const OLe={toc:[]};function ELe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}ELe.isMDXComponent=!0;const BLe={toc:[]};function GLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}GLe.isMDXComponent=!0;const VLe={toc:[]};function ULe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}ULe.isMDXComponent=!0;const FLe={toc:[]};function qLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}qLe.isMDXComponent=!0;const jLe={toc:[]};function YLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}YLe.isMDXComponent=!0;const HLe={toc:[]};function QLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}QLe.isMDXComponent=!0;const $Le={toc:[]};function KLe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}KLe.isMDXComponent=!0;const JLe={toc:[]};function tZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}tZe.isMDXComponent=!0;const eZe={toc:[]};function nZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}nZe.isMDXComponent=!0;const oZe={toc:[]};function pZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}pZe.isMDXComponent=!0;const rZe={toc:[]};function sZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}sZe.isMDXComponent=!0;const cZe={toc:[]};function iZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}iZe.isMDXComponent=!0;const aZe={toc:[]};function lZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}lZe.isMDXComponent=!0;const uZe={toc:[]};function mZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}mZe.isMDXComponent=!0;const dZe={toc:[]};function hZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}hZe.isMDXComponent=!0;const fZe={toc:[]};function kZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}kZe.isMDXComponent=!0;const yZe={toc:[]};function wZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}wZe.isMDXComponent=!0;const DZe={toc:[]};function MZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}MZe.isMDXComponent=!0;const XZe={toc:[]};function _Ze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_Ze.isMDXComponent=!0;const gZe={toc:[]};function TZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}TZe.isMDXComponent=!0;const CZe={toc:[]};function xZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}xZe.isMDXComponent=!0;const vZe={toc:[]};function LZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}LZe.isMDXComponent=!0;const ZZe={toc:[]};function bZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}bZe.isMDXComponent=!0;const NZe={toc:[]};function zZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}zZe.isMDXComponent=!0;const AZe={toc:[]};function WZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}WZe.isMDXComponent=!0;const IZe={toc:[]};function RZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}RZe.isMDXComponent=!0;const PZe={toc:[]};function SZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}SZe.isMDXComponent=!0;const OZe={toc:[]};function EZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}EZe.isMDXComponent=!0;const BZe={toc:[]};function GZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}GZe.isMDXComponent=!0;const VZe={toc:[]};function UZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}UZe.isMDXComponent=!0;const FZe={toc:[]};function qZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}qZe.isMDXComponent=!0;const jZe={toc:[]};function YZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}YZe.isMDXComponent=!0;const HZe={toc:[]};function QZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}QZe.isMDXComponent=!0;const $Ze={toc:[]};function KZe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}KZe.isMDXComponent=!0;const JZe={toc:[]};function tbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}tbe.isMDXComponent=!0;const ebe={toc:[]};function nbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ebe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}nbe.isMDXComponent=!0;const obe={toc:[]};function pbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},obe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}pbe.isMDXComponent=!0;const rbe={toc:[]};function sbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}sbe.isMDXComponent=!0;const cbe={toc:[]};function ibe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ibe.isMDXComponent=!0;const abe={toc:[]};function lbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},abe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}lbe.isMDXComponent=!0;const ube={toc:[]};function mbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ube,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}mbe.isMDXComponent=!0;const dbe={toc:[]};function hbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}hbe.isMDXComponent=!0;const fbe={toc:[]};function kbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}kbe.isMDXComponent=!0;const ybe={toc:[]};function wbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ybe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}wbe.isMDXComponent=!0;const Dbe={toc:[]};function Mbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Mbe.isMDXComponent=!0;const Xbe={toc:[]};function _be(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_be.isMDXComponent=!0;const gbe={toc:[]};function Tbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Tbe.isMDXComponent=!0;const Cbe={toc:[]};function xbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}xbe.isMDXComponent=!0;const vbe={toc:[]};function Lbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Lbe.isMDXComponent=!0;const Zbe={toc:[]};function bbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}bbe.isMDXComponent=!0;const Nbe={toc:[]};function zbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}zbe.isMDXComponent=!0;const Abe={toc:[]};function Wbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Abe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}Wbe.isMDXComponent=!0;const Ibe={toc:[]};function Rbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ibe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Rbe.isMDXComponent=!0;const Pbe={toc:[]};function Sbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Sbe.isMDXComponent=!0;const Obe={toc:[]};function Ebe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Obe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Ebe.isMDXComponent=!0;const Bbe={toc:[]};function Gbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Gbe.isMDXComponent=!0;const Vbe={toc:[]};function Ube(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Ube.isMDXComponent=!0;const Fbe={toc:[]};function qbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}qbe.isMDXComponent=!0;const jbe={toc:[]};function Ybe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Ybe.isMDXComponent=!0;const Hbe={toc:[]};function Qbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Qbe.isMDXComponent=!0;const $be={toc:[]};function Kbe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$be,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Kbe.isMDXComponent=!0;const Jbe={toc:[]};function tNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}tNe.isMDXComponent=!0;const eNe={toc:[]};function nNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}nNe.isMDXComponent=!0;const oNe={toc:[]};function pNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pNe.isMDXComponent=!0;const rNe={toc:[]};function sNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}sNe.isMDXComponent=!0;const cNe={toc:[]};function iNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}iNe.isMDXComponent=!0;const aNe={toc:[]};function lNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}lNe.isMDXComponent=!0;const uNe={toc:[]};function mNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}mNe.isMDXComponent=!0;const dNe={toc:[]};function hNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}hNe.isMDXComponent=!0;const fNe={toc:[]};function kNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}kNe.isMDXComponent=!0;const yNe={toc:[]};function wNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}wNe.isMDXComponent=!0;const DNe={toc:[]};function MNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}MNe.isMDXComponent=!0;const XNe={toc:[]};function _Ne(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}_Ne.isMDXComponent=!0;const gNe={toc:[]};function TNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}TNe.isMDXComponent=!0;const CNe={toc:[]};function xNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}xNe.isMDXComponent=!0;const vNe={toc:[]};function LNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}LNe.isMDXComponent=!0;const ZNe={toc:[]};function bNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}bNe.isMDXComponent=!0;const NNe={toc:[]};function zNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}zNe.isMDXComponent=!0;const ANe={toc:[]};function WNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ANe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}WNe.isMDXComponent=!0;const INe={toc:[]};function RNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},INe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}RNe.isMDXComponent=!0;const PNe={toc:[]};function SNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}SNe.isMDXComponent=!0;const ONe={toc:[]};function ENe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ONe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}ENe.isMDXComponent=!0;const BNe={toc:[]};function GNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}GNe.isMDXComponent=!0;const VNe={toc:[]};function UNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}UNe.isMDXComponent=!0;const FNe={toc:[]};function qNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qNe.isMDXComponent=!0;const jNe={toc:[]};function YNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}YNe.isMDXComponent=!0;const HNe={toc:[]};function QNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}QNe.isMDXComponent=!0;const $Ne={toc:[]};function KNe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}KNe.isMDXComponent=!0;const JNe={toc:[]};function tze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}tze.isMDXComponent=!0;const eze={toc:[]};function nze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}nze.isMDXComponent=!0;const oze={toc:[]};function pze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}pze.isMDXComponent=!0;const rze={toc:[]};function sze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}sze.isMDXComponent=!0;const cze={toc:[]};function ize(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ize.isMDXComponent=!0;const aze={toc:[]};function lze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}lze.isMDXComponent=!0;const uze={toc:[]};function mze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}mze.isMDXComponent=!0;const dze={toc:[]};function hze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}hze.isMDXComponent=!0;const fze={toc:[]};function kze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}kze.isMDXComponent=!0;const yze={toc:[]};function wze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wze.isMDXComponent=!0;const Dze={toc:[]};function Mze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Mze.isMDXComponent=!0;const Xze={toc:[]};function _ze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}_ze.isMDXComponent=!0;const gze={toc:[]};function Tze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Tze.isMDXComponent=!0;const Cze={toc:[]};function xze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}xze.isMDXComponent=!0;const vze={toc:[]};function Lze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Lze.isMDXComponent=!0;const Zze={toc:[]};function bze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}bze.isMDXComponent=!0;const Nze={toc:[]};function zze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}zze.isMDXComponent=!0;const Aze={toc:[]};function Wze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Wze.isMDXComponent=!0;const Ize={toc:[]};function Rze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ize,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Rze.isMDXComponent=!0;const Pze={toc:[]};function Sze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Sze.isMDXComponent=!0;const Oze={toc:[]};function Eze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Eze.isMDXComponent=!0;const Bze={toc:[]};function Gze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Gze.isMDXComponent=!0;const Vze={toc:[]};function Uze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Uze.isMDXComponent=!0;const Fze={toc:[]};function qze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}qze.isMDXComponent=!0;const jze={toc:[]};function Yze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Yze.isMDXComponent=!0;const Hze={toc:[]};function Qze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Qze.isMDXComponent=!0;const $ze={toc:[]};function Kze(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$ze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Kze.isMDXComponent=!0;const Jze={toc:[]};function tAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}tAe.isMDXComponent=!0;const eAe={toc:[]};function nAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nAe.isMDXComponent=!0;const oAe={toc:[]};function pAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}pAe.isMDXComponent=!0;const rAe={toc:[]};function sAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}sAe.isMDXComponent=!0;const cAe={toc:[]};function iAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}iAe.isMDXComponent=!0;const aAe={toc:[]};function lAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}lAe.isMDXComponent=!0;const uAe={toc:[]};function mAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}mAe.isMDXComponent=!0;const dAe={toc:[]};function hAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}hAe.isMDXComponent=!0;const fAe={toc:[]};function kAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}kAe.isMDXComponent=!0;const yAe={toc:[]};function wAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}wAe.isMDXComponent=!0;const DAe={toc:[]};function MAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}MAe.isMDXComponent=!0;const XAe={toc:[]};function _Ae(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}_Ae.isMDXComponent=!0;const gAe={toc:[]};function TAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}TAe.isMDXComponent=!0;const CAe={toc:[]};function xAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}xAe.isMDXComponent=!0;const vAe={toc:[]};function LAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}LAe.isMDXComponent=!0;const ZAe={toc:[]};function bAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local video:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import video from './example.mp4';\n// ...\nview.add(<Video src={video} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Video src="https://example.com/video.mp4" />)\n')))}bAe.isMDXComponent=!0;const NAe={toc:[]};function zAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}zAe.isMDXComponent=!0;const AAe={toc:[]};function WAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}WAe.isMDXComponent=!0;const IAe={toc:[]};function RAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}RAe.isMDXComponent=!0;const PAe={toc:[]};function SAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}SAe.isMDXComponent=!0;const OAe={toc:[]};function EAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}EAe.isMDXComponent=!0;const BAe={toc:[]};function GAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}GAe.isMDXComponent=!0;const VAe={toc:[]};function UAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}UAe.isMDXComponent=!0;const FAe={toc:[]};function qAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}qAe.isMDXComponent=!0;const jAe={toc:[]};function YAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}YAe.isMDXComponent=!0;const HAe={toc:[]};function QAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}QAe.isMDXComponent=!0;const $Ae={toc:[]};function KAe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}KAe.isMDXComponent=!0;const JAe={toc:[]};function tWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}tWe.isMDXComponent=!0;const eWe={toc:[]};function nWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}nWe.isMDXComponent=!0;const oWe={toc:[]};function pWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}pWe.isMDXComponent=!0;const rWe={toc:[]};function sWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}sWe.isMDXComponent=!0;const cWe={toc:[]};function iWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}iWe.isMDXComponent=!0;const aWe={toc:[]};function lWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}lWe.isMDXComponent=!0;const uWe={toc:[]};function mWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}mWe.isMDXComponent=!0;const dWe={toc:[]};function hWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}hWe.isMDXComponent=!0;const fWe={toc:[]};function kWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}kWe.isMDXComponent=!0;const yWe={toc:[]};function wWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}wWe.isMDXComponent=!0;const DWe={toc:[]};function MWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}MWe.isMDXComponent=!0;const XWe={toc:[]};function _We(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}_We.isMDXComponent=!0;const gWe={toc:[]};function TWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}TWe.isMDXComponent=!0;const CWe={toc:[]};function xWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}xWe.isMDXComponent=!0;const vWe={toc:[]};function LWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}LWe.isMDXComponent=!0;const ZWe={toc:[]};function bWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}bWe.isMDXComponent=!0;const NWe={toc:[]};function zWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}zWe.isMDXComponent=!0;const AWe={toc:[]};function WWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}WWe.isMDXComponent=!0;const IWe={toc:[]};function RWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}RWe.isMDXComponent=!0;const PWe={toc:[]};function SWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}SWe.isMDXComponent=!0;const OWe={toc:[]};function EWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}EWe.isMDXComponent=!0;const BWe={toc:[]};function GWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}GWe.isMDXComponent=!0;const VWe={toc:[]};function UWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}UWe.isMDXComponent=!0;const FWe={toc:[]};function qWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}qWe.isMDXComponent=!0;const jWe={toc:[]};function YWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}YWe.isMDXComponent=!0;const HWe={toc:[]};function QWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}QWe.isMDXComponent=!0;const $We={toc:[]};function KWe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$We,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}KWe.isMDXComponent=!0;const JWe={toc:[]};function tIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}tIe.isMDXComponent=!0;const eIe={toc:[]};function nIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}nIe.isMDXComponent=!0;const oIe={toc:[]};function pIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}pIe.isMDXComponent=!0;const rIe={toc:[]};function sIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}sIe.isMDXComponent=!0;const cIe={toc:[]};function iIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}iIe.isMDXComponent=!0;const aIe={toc:[]};function lIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}lIe.isMDXComponent=!0;const uIe={toc:[]};function mIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}mIe.isMDXComponent=!0;const dIe={toc:[]};function hIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}hIe.isMDXComponent=!0;const fIe={toc:[]};function kIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}kIe.isMDXComponent=!0;const yIe={toc:[]};function wIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wIe.isMDXComponent=!0;const DIe={toc:[]};function MIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}MIe.isMDXComponent=!0;const XIe={toc:[]};function _Ie(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}_Ie.isMDXComponent=!0;const gIe={toc:[]};function TIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}TIe.isMDXComponent=!0;const CIe={toc:[]};function xIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}xIe.isMDXComponent=!0;const vIe={toc:[]};function LIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}LIe.isMDXComponent=!0;const ZIe={toc:[]};function bIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}bIe.isMDXComponent=!0;const NIe={toc:[]};function zIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}zIe.isMDXComponent=!0;const AIe={toc:[]};function WIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}WIe.isMDXComponent=!0;const IIe={toc:[]};function RIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}RIe.isMDXComponent=!0;const PIe={toc:[]};function SIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}SIe.isMDXComponent=!0;const OIe={toc:[]};function EIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}EIe.isMDXComponent=!0;const BIe={toc:[]};function GIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}GIe.isMDXComponent=!0;const VIe={toc:[]};function UIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}UIe.isMDXComponent=!0;const FIe={toc:[]};function qIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}qIe.isMDXComponent=!0;const jIe={toc:[]};function YIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}YIe.isMDXComponent=!0;const HIe={toc:[]};function QIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}QIe.isMDXComponent=!0;const $Ie={toc:[]};function KIe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}KIe.isMDXComponent=!0;const JIe={toc:[]};function tRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}tRe.isMDXComponent=!0;const eRe={toc:[]};function nRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}nRe.isMDXComponent=!0;const oRe={toc:[]};function pRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}pRe.isMDXComponent=!0;const rRe={toc:[]};function sRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}sRe.isMDXComponent=!0;const cRe={toc:[]};function iRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}iRe.isMDXComponent=!0;const aRe={toc:[]};function lRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}lRe.isMDXComponent=!0;const uRe={toc:[]};function mRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}mRe.isMDXComponent=!0;const dRe={toc:[]};function hRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}hRe.isMDXComponent=!0;const fRe={toc:[]};function kRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}kRe.isMDXComponent=!0;const yRe={toc:[]};function wRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}wRe.isMDXComponent=!0;const DRe={toc:[]};function MRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}MRe.isMDXComponent=!0;const XRe={toc:[]};function _Re(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}_Re.isMDXComponent=!0;const gRe={toc:[]};function TRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}TRe.isMDXComponent=!0;const CRe={toc:[]};function xRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}xRe.isMDXComponent=!0;const vRe={toc:[]};function LRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}LRe.isMDXComponent=!0;const ZRe={toc:[]};function bRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}bRe.isMDXComponent=!0;const NRe={toc:[]};function zRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}zRe.isMDXComponent=!0;const ARe={toc:[]};function WRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ARe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}WRe.isMDXComponent=!0;const IRe={toc:[]};function RRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}RRe.isMDXComponent=!0;const PRe={toc:[]};function SRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}SRe.isMDXComponent=!0;const ORe={toc:[]};function ERe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ORe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}ERe.isMDXComponent=!0;const BRe={toc:[]};function GRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}GRe.isMDXComponent=!0;const VRe={toc:[]};function URe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}URe.isMDXComponent=!0;const FRe={toc:[]};function qRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}qRe.isMDXComponent=!0;const jRe={toc:[]};function YRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}YRe.isMDXComponent=!0;const HRe={toc:[]};function QRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}QRe.isMDXComponent=!0;const $Re={toc:[]};function KRe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Re,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}KRe.isMDXComponent=!0;const JRe={toc:[]};function tPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}tPe.isMDXComponent=!0;const ePe={toc:[]};function nPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ePe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}nPe.isMDXComponent=!0;const oPe={toc:[]};function pPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}pPe.isMDXComponent=!0;const rPe={toc:[]};function sPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}sPe.isMDXComponent=!0;const cPe={toc:[]};function iPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}iPe.isMDXComponent=!0;const aPe={toc:[]};function lPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}lPe.isMDXComponent=!0;const uPe={toc:[]};function mPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}mPe.isMDXComponent=!0;const dPe={toc:[]};function hPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}hPe.isMDXComponent=!0;const fPe={toc:[]};function kPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}kPe.isMDXComponent=!0;const yPe={toc:[]};function wPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}wPe.isMDXComponent=!0;const DPe={toc:[]};function MPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}MPe.isMDXComponent=!0;const XPe={toc:[]};function _Pe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_Pe.isMDXComponent=!0;const gPe={toc:[]};function TPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}TPe.isMDXComponent=!0;const CPe={toc:[]};function xPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}xPe.isMDXComponent=!0;const vPe={toc:[]};function LPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}LPe.isMDXComponent=!0;const ZPe={toc:[]};function bPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}bPe.isMDXComponent=!0;const NPe={toc:[]};function zPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}zPe.isMDXComponent=!0;const APe={toc:[]};function WPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},APe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}WPe.isMDXComponent=!0;const IPe={toc:[]};function RPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}RPe.isMDXComponent=!0;const PPe={toc:[]};function SPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}SPe.isMDXComponent=!0;const OPe={toc:[]};function EPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}EPe.isMDXComponent=!0;const BPe={toc:[]};function GPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}GPe.isMDXComponent=!0;const VPe={toc:[]};function UPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}UPe.isMDXComponent=!0;const FPe={toc:[]};function qPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}qPe.isMDXComponent=!0;const jPe={toc:[]};function YPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}YPe.isMDXComponent=!0;const HPe={toc:[]};function QPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}QPe.isMDXComponent=!0;const $Pe={toc:[]};function KPe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}KPe.isMDXComponent=!0;const JPe={toc:[]};function tSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}tSe.isMDXComponent=!0;const eSe={toc:[]};function nSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}nSe.isMDXComponent=!0;const oSe={toc:[]};function pSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}pSe.isMDXComponent=!0;const rSe={toc:[]};function sSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}sSe.isMDXComponent=!0;const cSe={toc:[]};function iSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}iSe.isMDXComponent=!0;const aSe={toc:[]};function lSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}lSe.isMDXComponent=!0;const uSe={toc:[]};function mSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}mSe.isMDXComponent=!0;const dSe={toc:[]};function hSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}hSe.isMDXComponent=!0;const fSe={toc:[]};function kSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}kSe.isMDXComponent=!0;const ySe={toc:[]};function wSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ySe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}wSe.isMDXComponent=!0;const DSe={toc:[]};function MSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}MSe.isMDXComponent=!0;const XSe={toc:[]};function _Se(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}_Se.isMDXComponent=!0;const gSe={toc:[]};function TSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}TSe.isMDXComponent=!0;const CSe={toc:[]};function xSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}xSe.isMDXComponent=!0;const vSe={toc:[]};function LSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}LSe.isMDXComponent=!0;const ZSe={toc:[]};function bSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}bSe.isMDXComponent=!0;const NSe={toc:[]};function zSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}zSe.isMDXComponent=!0;const ASe={toc:[]};function WSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ASe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}WSe.isMDXComponent=!0;const ISe={toc:[]};function RSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ISe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}RSe.isMDXComponent=!0;const PSe={toc:[]};function SSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}SSe.isMDXComponent=!0;const OSe={toc:[]};function ESe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}ESe.isMDXComponent=!0;const BSe={toc:[]};function GSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}GSe.isMDXComponent=!0;const VSe={toc:[]};function USe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}USe.isMDXComponent=!0;const FSe={toc:[]};function qSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qSe.isMDXComponent=!0;const jSe={toc:[]};function YSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}YSe.isMDXComponent=!0;const HSe={toc:[]};function QSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}QSe.isMDXComponent=!0;const $Se={toc:[]};function KSe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Se,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}KSe.isMDXComponent=!0;const JSe={toc:[]};function tOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}tOe.isMDXComponent=!0;const eOe={toc:[]};function nOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}nOe.isMDXComponent=!0;const oOe={toc:[]};function pOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}pOe.isMDXComponent=!0;const rOe={toc:[]};function sOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}sOe.isMDXComponent=!0;const cOe={toc:[]};function iOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}iOe.isMDXComponent=!0;const aOe={toc:[]};function lOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}lOe.isMDXComponent=!0;const uOe={toc:[]};function mOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}mOe.isMDXComponent=!0;const dOe={toc:[]};function hOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}hOe.isMDXComponent=!0;const fOe={toc:[]};function kOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}kOe.isMDXComponent=!0;const yOe={toc:[]};function wOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wOe.isMDXComponent=!0;const DOe={toc:[]};function MOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}MOe.isMDXComponent=!0;const XOe={toc:[]};function _Oe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}_Oe.isMDXComponent=!0;const gOe={toc:[]};function TOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}TOe.isMDXComponent=!0;const COe={toc:[]};function xOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},COe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}xOe.isMDXComponent=!0;const vOe={toc:[]};function LOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}LOe.isMDXComponent=!0;const ZOe={toc:[]};function bOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}bOe.isMDXComponent=!0;const NOe={toc:[]};function zOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}zOe.isMDXComponent=!0;const AOe={toc:[]};function WOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}WOe.isMDXComponent=!0;const IOe={toc:[]};function ROe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}ROe.isMDXComponent=!0;const POe={toc:[]};function SOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},POe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}SOe.isMDXComponent=!0;const OOe={toc:[]};function EOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}EOe.isMDXComponent=!0;const BOe={toc:[]};function GOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}GOe.isMDXComponent=!0;const VOe={toc:[]};function UOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}UOe.isMDXComponent=!0;const FOe={toc:[]};function qOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}qOe.isMDXComponent=!0;const jOe={toc:[]};function YOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}YOe.isMDXComponent=!0;const HOe={toc:[]};function QOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}QOe.isMDXComponent=!0;const $Oe={toc:[]};function KOe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Oe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}KOe.isMDXComponent=!0;const JOe={toc:[]};function tEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}tEe.isMDXComponent=!0;const eEe={toc:[]};function nEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}nEe.isMDXComponent=!0;const oEe={toc:[]};function pEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}pEe.isMDXComponent=!0;const rEe={toc:[]};function sEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}sEe.isMDXComponent=!0;const cEe={toc:[]};function iEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}iEe.isMDXComponent=!0;const aEe={toc:[]};function lEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}lEe.isMDXComponent=!0;const uEe={toc:[]};function mEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}mEe.isMDXComponent=!0;const dEe={toc:[]};function hEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}hEe.isMDXComponent=!0;const fEe={toc:[]};function kEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}kEe.isMDXComponent=!0;const yEe={toc:[]};function wEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}wEe.isMDXComponent=!0;const DEe={toc:[]};function MEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}MEe.isMDXComponent=!0;const XEe={toc:[]};function _Ee(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}_Ee.isMDXComponent=!0;const gEe={toc:[]};function TEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}TEe.isMDXComponent=!0;const CEe={toc:[]};function xEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xEe.isMDXComponent=!0;const vEe={toc:[]};function LEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}LEe.isMDXComponent=!0;const ZEe={toc:[]};function bEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}bEe.isMDXComponent=!0;const NEe={toc:[]};function zEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}zEe.isMDXComponent=!0;const AEe={toc:[]};function WEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}WEe.isMDXComponent=!0;const IEe={toc:[]};function REe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}REe.isMDXComponent=!0;const PEe={toc:[]};function SEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}SEe.isMDXComponent=!0;const OEe={toc:[]};function EEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}EEe.isMDXComponent=!0;const BEe={toc:[]};function GEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}GEe.isMDXComponent=!0;const VEe={toc:[]};function UEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}UEe.isMDXComponent=!0;const FEe={toc:[]};function qEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}qEe.isMDXComponent=!0;const jEe={toc:[]};function YEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}YEe.isMDXComponent=!0;const HEe={toc:[]};function QEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}QEe.isMDXComponent=!0;const $Ee={toc:[]};function KEe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}KEe.isMDXComponent=!0;const JEe={toc:[]};function tBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}tBe.isMDXComponent=!0;const eBe={toc:[]};function nBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}nBe.isMDXComponent=!0;const oBe={toc:[]};function pBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}pBe.isMDXComponent=!0;const rBe={toc:[]};function sBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}sBe.isMDXComponent=!0;const cBe={toc:[]};function iBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}iBe.isMDXComponent=!0;const aBe={toc:[]};function lBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}lBe.isMDXComponent=!0;const uBe={toc:[]};function mBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}mBe.isMDXComponent=!0;const dBe={toc:[]};function hBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}hBe.isMDXComponent=!0;const fBe={toc:[]};function kBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}kBe.isMDXComponent=!0;const yBe={toc:[]};function wBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wBe.isMDXComponent=!0;const DBe={toc:[]};function MBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}MBe.isMDXComponent=!0;const XBe={toc:[]};function _Be(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}_Be.isMDXComponent=!0;const gBe={toc:[]};function TBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}TBe.isMDXComponent=!0;const CBe={toc:[]};function xBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}xBe.isMDXComponent=!0;const vBe={toc:[]};function LBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}LBe.isMDXComponent=!0;const ZBe={toc:[]};function bBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}bBe.isMDXComponent=!0;const NBe={toc:[]};function zBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}zBe.isMDXComponent=!0;const ABe={toc:[]};function WBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ABe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}WBe.isMDXComponent=!0;const IBe={toc:[]};function RBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}RBe.isMDXComponent=!0;const PBe={toc:[]};function SBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}SBe.isMDXComponent=!0;const OBe={toc:[]};function EBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}EBe.isMDXComponent=!0;const BBe={toc:[]};function GBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}GBe.isMDXComponent=!0;const VBe={toc:[]};function UBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}UBe.isMDXComponent=!0;const FBe={toc:[]};function qBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}qBe.isMDXComponent=!0;const jBe={toc:[]};function YBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}YBe.isMDXComponent=!0;const HBe={toc:[]};function QBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}QBe.isMDXComponent=!0;const $Be={toc:[]};function KBe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Be,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}KBe.isMDXComponent=!0;const JBe={toc:[]};function tGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}tGe.isMDXComponent=!0;const eGe={toc:[]};function nGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}nGe.isMDXComponent=!0;const oGe={toc:[]};function pGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pGe.isMDXComponent=!0;const rGe={toc:[]};function sGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}sGe.isMDXComponent=!0;const cGe={toc:[]};function iGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}iGe.isMDXComponent=!0;const aGe={toc:[]};function lGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}lGe.isMDXComponent=!0;const uGe={toc:[]};function mGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}mGe.isMDXComponent=!0;const dGe={toc:[]};function hGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}hGe.isMDXComponent=!0;const fGe={toc:[]};function kGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}kGe.isMDXComponent=!0;const yGe={toc:[]};function wGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}wGe.isMDXComponent=!0;const DGe={toc:[]};function MGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}MGe.isMDXComponent=!0;const XGe={toc:[]};function _Ge(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}_Ge.isMDXComponent=!0;const gGe={toc:[]};function TGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}TGe.isMDXComponent=!0;const CGe={toc:[]};function xGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}xGe.isMDXComponent=!0;const vGe={toc:[]};function LGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}LGe.isMDXComponent=!0;const ZGe={toc:[]};function bGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}bGe.isMDXComponent=!0;const NGe={toc:[]};function zGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}zGe.isMDXComponent=!0;const AGe={toc:[]};function WGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}WGe.isMDXComponent=!0;const IGe={toc:[]};function RGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}RGe.isMDXComponent=!0;const PGe={toc:[]};function SGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}SGe.isMDXComponent=!0;const OGe={toc:[]};function EGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}EGe.isMDXComponent=!0;const BGe={toc:[]};function GGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}GGe.isMDXComponent=!0;const VGe={toc:[]};function UGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}UGe.isMDXComponent=!0;const FGe={toc:[]};function qGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}qGe.isMDXComponent=!0;const jGe={toc:[]};function YGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}YGe.isMDXComponent=!0;const HGe={toc:[]};function QGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}QGe.isMDXComponent=!0;const $Ge={toc:[]};function KGe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}KGe.isMDXComponent=!0;const JGe={toc:[]};function tVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}tVe.isMDXComponent=!0;const eVe={toc:[]};function nVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}nVe.isMDXComponent=!0;const oVe={toc:[]};function pVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}pVe.isMDXComponent=!0;const rVe={toc:[]};function sVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}sVe.isMDXComponent=!0;const cVe={toc:[]};function iVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}iVe.isMDXComponent=!0;const aVe={toc:[]};function lVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}lVe.isMDXComponent=!0;const uVe={toc:[]};function mVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}mVe.isMDXComponent=!0;const dVe={toc:[]};function hVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}hVe.isMDXComponent=!0;const fVe={toc:[]};function kVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}kVe.isMDXComponent=!0;const yVe={toc:[]};function wVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}wVe.isMDXComponent=!0;const DVe={toc:[]};function MVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}MVe.isMDXComponent=!0;const XVe={toc:[]};function _Ve(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}_Ve.isMDXComponent=!0;const gVe={toc:[]};function TVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}TVe.isMDXComponent=!0;const CVe={toc:[]};function xVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}xVe.isMDXComponent=!0;const vVe={toc:[]};function LVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}LVe.isMDXComponent=!0;const ZVe={toc:[]};function bVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}bVe.isMDXComponent=!0;const NVe={toc:[]};function zVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}zVe.isMDXComponent=!0;const AVe={toc:[]};function WVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}WVe.isMDXComponent=!0;const IVe={toc:[]};function RVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}RVe.isMDXComponent=!0;const PVe={toc:[]};function SVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}SVe.isMDXComponent=!0;const OVe={toc:[]};function EVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}EVe.isMDXComponent=!0;const BVe={toc:[]};function GVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}GVe.isMDXComponent=!0;const VVe={toc:[]};function UVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}UVe.isMDXComponent=!0;const FVe={toc:[]};function qVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}qVe.isMDXComponent=!0;const jVe={toc:[]};function YVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}YVe.isMDXComponent=!0;const HVe={toc:[]};function QVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}QVe.isMDXComponent=!0;const $Ve={toc:[]};function KVe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}KVe.isMDXComponent=!0;const JVe={toc:[]};function tUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}tUe.isMDXComponent=!0;const eUe={toc:[]};function nUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}nUe.isMDXComponent=!0;const oUe={toc:[]};function pUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}pUe.isMDXComponent=!0;const rUe={toc:[]};function sUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}sUe.isMDXComponent=!0;const cUe={toc:[]};function iUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}iUe.isMDXComponent=!0;const aUe={toc:[]};function lUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lUe.isMDXComponent=!0;const uUe={toc:[]};function mUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}mUe.isMDXComponent=!0;const dUe={toc:[]};function hUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}hUe.isMDXComponent=!0;const fUe={toc:[]};function kUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}kUe.isMDXComponent=!0;const yUe={toc:[]};function wUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}wUe.isMDXComponent=!0;const DUe={toc:[]};function MUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}MUe.isMDXComponent=!0;const XUe={toc:[]};function _Ue(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}_Ue.isMDXComponent=!0;const gUe={toc:[]};function TUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}TUe.isMDXComponent=!0;const CUe={toc:[]};function xUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."),(0,s.kt)("p",null,"Providing a duration will tween the node to the restored state. Otherwise,\nit will be restored immediately."))}xUe.isMDXComponent=!0;const vUe={toc:[]};function LUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state over 1 second\nyield* node.restore(1);\n")))}LUe.isMDXComponent=!0;const ZUe={toc:[]};function bUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}bUe.isMDXComponent=!0;const NUe={toc:[]};function zUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}zUe.isMDXComponent=!0;const AUe={toc:[]};function WUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}WUe.isMDXComponent=!0;const IUe={toc:[]};function RUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}RUe.isMDXComponent=!0;const PUe={toc:[]};function SUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}SUe.isMDXComponent=!0;const OUe={toc:[]};function EUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}EUe.isMDXComponent=!0;const BUe={toc:[]};function GUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}GUe.isMDXComponent=!0;const VUe={toc:[]};function UUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}UUe.isMDXComponent=!0;const FUe={toc:[]};function qUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}qUe.isMDXComponent=!0;const jUe={toc:[]};function YUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}YUe.isMDXComponent=!0;const HUe={toc:[]};function QUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}QUe.isMDXComponent=!0;const $Ue={toc:[]};function KUe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}KUe.isMDXComponent=!0;const JUe={toc:[]};function tFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}tFe.isMDXComponent=!0;const eFe={toc:[]};function nFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}nFe.isMDXComponent=!0;const oFe={toc:[]};function pFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}pFe.isMDXComponent=!0;const rFe={toc:[]};function sFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}sFe.isMDXComponent=!0;const cFe={toc:[]};function iFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}iFe.isMDXComponent=!0;const aFe={toc:[]};function lFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}lFe.isMDXComponent=!0;const uFe={toc:[]};function mFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}mFe.isMDXComponent=!0;const dFe={toc:[]};function hFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}hFe.isMDXComponent=!0;const fFe={toc:[]};function kFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}kFe.isMDXComponent=!0;const yFe={toc:[]};function wFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}wFe.isMDXComponent=!0;const DFe={toc:[]};function MFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}MFe.isMDXComponent=!0;const XFe={toc:[]};function _Fe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_Fe.isMDXComponent=!0;const gFe={toc:[]};function TFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}TFe.isMDXComponent=!0;const CFe={toc:[]};function xFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xFe.isMDXComponent=!0;const vFe={toc:[]};function LFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}LFe.isMDXComponent=!0;const ZFe={toc:[]};function bFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bFe.isMDXComponent=!0;const NFe={toc:[]};function zFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}zFe.isMDXComponent=!0;const AFe={toc:[]};function WFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}WFe.isMDXComponent=!0;const IFe={toc:[]};function RFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}RFe.isMDXComponent=!0;const PFe={toc:[]};function SFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the circle begins at ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}SFe.isMDXComponent=!0;const OFe={toc:[]};function EFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the circle sector should be drawn counterclockwise."))}EFe.isMDXComponent=!0;const BFe={toc:[]};function GFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}GFe.isMDXComponent=!0;const VFe={toc:[]};function UFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}UFe.isMDXComponent=!0;const FFe={toc:[]};function qFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}qFe.isMDXComponent=!0;const jFe={toc:[]};function YFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}YFe.isMDXComponent=!0;const HFe={toc:[]};function QFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}QFe.isMDXComponent=!0;const $Fe={toc:[]};function KFe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}KFe.isMDXComponent=!0;const JFe={toc:[]};function tqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}tqe.isMDXComponent=!0;const eqe={toc:[]};function nqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}nqe.isMDXComponent=!0;const oqe={toc:[]};function pqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pqe.isMDXComponent=!0;const rqe={toc:[]};function sqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}sqe.isMDXComponent=!0;const cqe={toc:[]};function iqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iqe.isMDXComponent=!0;const aqe={toc:[]};function lqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lqe.isMDXComponent=!0;const uqe={toc:[]};function mqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}mqe.isMDXComponent=!0;const dqe={toc:[]};function hqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}hqe.isMDXComponent=!0;const fqe={toc:[]};function kqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}kqe.isMDXComponent=!0;const yqe={toc:[]};function wqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}wqe.isMDXComponent=!0;const Dqe={toc:[]};function Mqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Mqe.isMDXComponent=!0;const Xqe={toc:[]};function _qe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}_qe.isMDXComponent=!0;const gqe={toc:[]};function Tqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Tqe.isMDXComponent=!0;const Cqe={toc:[]};function xqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}xqe.isMDXComponent=!0;const vqe={toc:[]};function Lqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lqe.isMDXComponent=!0;const Zqe={toc:[]};function bqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}bqe.isMDXComponent=!0;const Nqe={toc:[]};function zqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zqe.isMDXComponent=!0;const Aqe={toc:[]};function Wqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Wqe.isMDXComponent=!0;const Iqe={toc:[]};function Rqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Rqe.isMDXComponent=!0;const Pqe={toc:[]};function Sqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Sqe.isMDXComponent=!0;const Oqe={toc:[]};function Eqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Eqe.isMDXComponent=!0;const Bqe={toc:[]};function Gqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Gqe.isMDXComponent=!0;const Vqe={toc:[]};function Uqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Uqe.isMDXComponent=!0;const Fqe={toc:[]};function qqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}qqe.isMDXComponent=!0;const jqe={toc:[]};function Yqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yqe.isMDXComponent=!0;const Hqe={toc:[]};function Qqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Qqe.isMDXComponent=!0;const $qe={toc:[]};function Kqe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Kqe.isMDXComponent=!0;const Jqe={toc:[]};function tje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}tje.isMDXComponent=!0;const eje={toc:[]};function nje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}nje.isMDXComponent=!0;const oje={toc:[]};function pje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}pje.isMDXComponent=!0;const rje={toc:[]};function sje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}sje.isMDXComponent=!0;const cje={toc:[]};function ije(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}ije.isMDXComponent=!0;const aje={toc:[]};function lje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lje.isMDXComponent=!0;const uje={toc:[]};function mje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}mje.isMDXComponent=!0;const dje={toc:[]};function hje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}hje.isMDXComponent=!0;const fje={toc:[]};function kje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}kje.isMDXComponent=!0;const yje={toc:[]};function wje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wje.isMDXComponent=!0;const Dje={toc:[]};function Mje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Mje.isMDXComponent=!0;const Xje={toc:[]};function _je(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_je.isMDXComponent=!0;const gje={toc:[]};function Tje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Tje.isMDXComponent=!0;const Cje={toc:[]};function xje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}xje.isMDXComponent=!0;const vje={toc:[]};function Lje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Lje.isMDXComponent=!0;const Zje={toc:[]};function bje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}bje.isMDXComponent=!0;const Nje={toc:[]};function zje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}zje.isMDXComponent=!0;const Aje={toc:[]};function Wje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Wje.isMDXComponent=!0;const Ije={toc:[]};function Rje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ije,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Rje.isMDXComponent=!0;const Pje={toc:[]};function Sje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Sje.isMDXComponent=!0;const Oje={toc:[]};function Eje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Eje.isMDXComponent=!0;const Bje={toc:[]};function Gje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Gje.isMDXComponent=!0;const Vje={toc:[]};function Uje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Uje.isMDXComponent=!0;const Fje={toc:[]};function qje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qje.isMDXComponent=!0;const jje={toc:[]};function Yje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Yje.isMDXComponent=!0;const Hje={toc:[]};function Qje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Qje.isMDXComponent=!0;const $je={toc:[]};function Kje(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Kje.isMDXComponent=!0;const Jje={toc:[]};function tYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tYe.isMDXComponent=!0;const eYe={toc:[]};function nYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}nYe.isMDXComponent=!0;const oYe={toc:[]};function pYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pYe.isMDXComponent=!0;const rYe={toc:[]};function sYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}sYe.isMDXComponent=!0;const cYe={toc:[]};function iYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iYe.isMDXComponent=!0;const aYe={toc:[]};function lYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lYe.isMDXComponent=!0;const uYe={toc:[]};function mYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}mYe.isMDXComponent=!0;const dYe={toc:[]};function hYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}hYe.isMDXComponent=!0;const fYe={toc:[]};function kYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kYe.isMDXComponent=!0;const yYe={toc:[]};function wYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}wYe.isMDXComponent=!0;const DYe={toc:[]};function MYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}MYe.isMDXComponent=!0;const XYe={toc:[]};function _Ye(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}_Ye.isMDXComponent=!0;const gYe={toc:[]};function TYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}TYe.isMDXComponent=!0;const CYe={toc:[]};function xYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}xYe.isMDXComponent=!0;const vYe={toc:[]};function LYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LYe.isMDXComponent=!0;const ZYe={toc:[]};function bYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}bYe.isMDXComponent=!0;const NYe={toc:[]};function zYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zYe.isMDXComponent=!0;const AYe={toc:[]};function WYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}WYe.isMDXComponent=!0;const IYe={toc:[]};function RYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}RYe.isMDXComponent=!0;const PYe={toc:[]};function SYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}SYe.isMDXComponent=!0;const OYe={toc:[]};function EYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}EYe.isMDXComponent=!0;const BYe={toc:[]};function GYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}GYe.isMDXComponent=!0;const VYe={toc:[]};function UYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}UYe.isMDXComponent=!0;const FYe={toc:[]};function qYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}qYe.isMDXComponent=!0;const jYe={toc:[]};function YYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}YYe.isMDXComponent=!0;const HYe={toc:[]};function QYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}QYe.isMDXComponent=!0;const $Ye={toc:[]};function KYe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}KYe.isMDXComponent=!0;const JYe={toc:[]};function tHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}tHe.isMDXComponent=!0;const eHe={toc:[]};function nHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nHe.isMDXComponent=!0;const oHe={toc:[]};function pHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}pHe.isMDXComponent=!0;const rHe={toc:[]};function sHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sHe.isMDXComponent=!0;const cHe={toc:[]};function iHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}iHe.isMDXComponent=!0;const aHe={toc:[]};function lHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lHe.isMDXComponent=!0;const uHe={toc:[]};function mHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}mHe.isMDXComponent=!0;const dHe={toc:[]};function hHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hHe.isMDXComponent=!0;const fHe={toc:[]};function kHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kHe.isMDXComponent=!0;const yHe={toc:[]};function wHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}wHe.isMDXComponent=!0;const DHe={toc:[]};function MHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the end of each grid line."))}MHe.isMDXComponent=!0;const XHe={toc:[]};function _He(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_He.isMDXComponent=!0;const gHe={toc:[]};function THe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}THe.isMDXComponent=!0;const CHe={toc:[]};function xHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xHe.isMDXComponent=!0;const vHe={toc:[]};function LHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}LHe.isMDXComponent=!0;const ZHe={toc:[]};function bHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The spacing between the grid lines."))}bHe.isMDXComponent=!0;const NHe={toc:[]};function zHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}zHe.isMDXComponent=!0;const AHe={toc:[]};function WHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}WHe.isMDXComponent=!0;const IHe={toc:[]};function RHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}RHe.isMDXComponent=!0;const PHe={toc:[]};function SHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}SHe.isMDXComponent=!0;const OHe={toc:[]};function EHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}EHe.isMDXComponent=!0;const BHe={toc:[]};function GHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}GHe.isMDXComponent=!0;const VHe={toc:[]};function UHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}UHe.isMDXComponent=!0;const FHe={toc:[]};function qHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}qHe.isMDXComponent=!0;const jHe={toc:[]};function YHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}YHe.isMDXComponent=!0;const HHe={toc:[]};function QHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}QHe.isMDXComponent=!0;const $He={toc:[]};function KHe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$He,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}KHe.isMDXComponent=!0;const JHe={toc:[]};function tQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}tQe.isMDXComponent=!0;const eQe={toc:[]};function nQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nQe.isMDXComponent=!0;const oQe={toc:[]};function pQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}pQe.isMDXComponent=!0;const rQe={toc:[]};function sQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}sQe.isMDXComponent=!0;const cQe={toc:[]};function iQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}iQe.isMDXComponent=!0;const aQe={toc:[]};function lQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lQe.isMDXComponent=!0;const uQe={toc:[]};function mQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}mQe.isMDXComponent=!0;const dQe={toc:[]};function hQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}hQe.isMDXComponent=!0;const fQe={toc:[]};function kQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}kQe.isMDXComponent=!0;const yQe={toc:[]};function wQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}wQe.isMDXComponent=!0;const DQe={toc:[]};function MQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}MQe.isMDXComponent=!0;const XQe={toc:[]};function _Qe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}_Qe.isMDXComponent=!0;const gQe={toc:[]};function TQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}TQe.isMDXComponent=!0;const CQe={toc:[]};function xQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}xQe.isMDXComponent=!0;const vQe={toc:[]};function LQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}LQe.isMDXComponent=!0;const ZQe={toc:[]};function bQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}bQe.isMDXComponent=!0;const NQe={toc:[]};function zQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}zQe.isMDXComponent=!0;const AQe={toc:[]};function WQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}WQe.isMDXComponent=!0;const IQe={toc:[]};function RQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}RQe.isMDXComponent=!0;const PQe={toc:[]};function SQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}SQe.isMDXComponent=!0;const OQe={toc:[]};function EQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}EQe.isMDXComponent=!0;const BQe={toc:[]};function GQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}GQe.isMDXComponent=!0;const VQe={toc:[]};function UQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}UQe.isMDXComponent=!0;const FQe={toc:[]};function qQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}qQe.isMDXComponent=!0;const jQe={toc:[]};function YQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}YQe.isMDXComponent=!0;const HQe={toc:[]};function QQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}QQe.isMDXComponent=!0;const $Qe={toc:[]};function KQe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}KQe.isMDXComponent=!0;const JQe={toc:[]};function t$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}t$e.isMDXComponent=!0;const e$e={toc:[]};function n$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}n$e.isMDXComponent=!0;const o$e={toc:[]};function p$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}p$e.isMDXComponent=!0;const r$e={toc:[]};function s$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}s$e.isMDXComponent=!0;const c$e={toc:[]};function i$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}i$e.isMDXComponent=!0;const a$e={toc:[]};function l$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}l$e.isMDXComponent=!0;const u$e={toc:[]};function m$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}m$e.isMDXComponent=!0;const d$e={toc:[]};function h$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}h$e.isMDXComponent=!0;const f$e={toc:[]};function k$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}k$e.isMDXComponent=!0;const y$e={toc:[]};function w$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}w$e.isMDXComponent=!0;const D$e={toc:[]};function M$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}M$e.isMDXComponent=!0;const X$e={toc:[]};function _$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_$e.isMDXComponent=!0;const g$e={toc:[]};function T$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}T$e.isMDXComponent=!0;const C$e={toc:[]};function x$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}x$e.isMDXComponent=!0;const v$e={toc:[]};function L$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}L$e.isMDXComponent=!0;const Z$e={toc:[]};function b$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}b$e.isMDXComponent=!0;const N$e={toc:[]};function z$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}z$e.isMDXComponent=!0;const A$e={toc:[]};function W$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}W$e.isMDXComponent=!0;const I$e={toc:[]};function R$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}R$e.isMDXComponent=!0;const P$e={toc:[]};function S$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}S$e.isMDXComponent=!0;const O$e={toc:[]};function E$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}E$e.isMDXComponent=!0;const B$e={toc:[]};function G$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}G$e.isMDXComponent=!0;const V$e={toc:[]};function U$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}U$e.isMDXComponent=!0;const F$e={toc:[]};function q$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}q$e.isMDXComponent=!0;const j$e={toc:[]};function Y$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Y$e.isMDXComponent=!0;const H$e={toc:[]};function Q$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Q$e.isMDXComponent=!0;const $$e={toc:[]};function K$e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}K$e.isMDXComponent=!0;const J$e={toc:[]};function tKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}tKe.isMDXComponent=!0;const eKe={toc:[]};function nKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}nKe.isMDXComponent=!0;const oKe={toc:[]};function pKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}pKe.isMDXComponent=!0;const rKe={toc:[]};function sKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}sKe.isMDXComponent=!0;const cKe={toc:[]};function iKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}iKe.isMDXComponent=!0;const aKe={toc:[]};function lKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}lKe.isMDXComponent=!0;const uKe={toc:[]};function mKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}mKe.isMDXComponent=!0;const dKe={toc:[]};function hKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}hKe.isMDXComponent=!0;const fKe={toc:[]};function kKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}kKe.isMDXComponent=!0;const yKe={toc:[]};function wKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}wKe.isMDXComponent=!0;const DKe={toc:[]};function MKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MKe.isMDXComponent=!0;const XKe={toc:[]};function _Ke(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}_Ke.isMDXComponent=!0;const gKe={toc:[]};function TKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}TKe.isMDXComponent=!0;const CKe={toc:[]};function xKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}xKe.isMDXComponent=!0;const vKe={toc:[]};function LKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LKe.isMDXComponent=!0;const ZKe={toc:[]};function bKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}bKe.isMDXComponent=!0;const NKe={toc:[]};function zKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}zKe.isMDXComponent=!0;const AKe={toc:[]};function WKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}WKe.isMDXComponent=!0;const IKe={toc:[]};function RKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}RKe.isMDXComponent=!0;const PKe={toc:[]};function SKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}SKe.isMDXComponent=!0;const OKe={toc:[]};function EKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}EKe.isMDXComponent=!0;const BKe={toc:[]};function GKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}GKe.isMDXComponent=!0;const VKe={toc:[]};function UKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}UKe.isMDXComponent=!0;const FKe={toc:[]};function qKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qKe.isMDXComponent=!0;const jKe={toc:[]};function YKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}YKe.isMDXComponent=!0;const HKe={toc:[]};function QKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}QKe.isMDXComponent=!0;const $Ke={toc:[]};function KKe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}KKe.isMDXComponent=!0;const JKe={toc:[]};function tJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}tJe.isMDXComponent=!0;const eJe={toc:[]};function nJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}nJe.isMDXComponent=!0;const oJe={toc:[]};function pJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pJe.isMDXComponent=!0;const rJe={toc:[]};function sJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}sJe.isMDXComponent=!0;const cJe={toc:[]};function iJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}iJe.isMDXComponent=!0;const aJe={toc:[]};function lJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}lJe.isMDXComponent=!0;const uJe={toc:[]};function mJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}mJe.isMDXComponent=!0;const dJe={toc:[]};function hJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}hJe.isMDXComponent=!0;const fJe={toc:[]};function kJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}kJe.isMDXComponent=!0;const yJe={toc:[]};function wJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}wJe.isMDXComponent=!0;const DJe={toc:[]};function MJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},DJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}MJe.isMDXComponent=!0;const XJe={toc:[]};function _Je(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},XJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}_Je.isMDXComponent=!0;const gJe={toc:[]};function TJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}TJe.isMDXComponent=!0;const CJe={toc:[]};function xJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},CJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}xJe.isMDXComponent=!0;const vJe={toc:[]};function LJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}LJe.isMDXComponent=!0;const ZJe={toc:[]};function bJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ZJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}bJe.isMDXComponent=!0;const NJe={toc:[]};function zJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},NJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zJe.isMDXComponent=!0;const AJe={toc:[]};function WJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},AJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}WJe.isMDXComponent=!0;const IJe={toc:[]};function RJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},IJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}RJe.isMDXComponent=!0;const PJe={toc:[]};function SJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},PJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}SJe.isMDXComponent=!0;const OJe={toc:[]};function EJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},OJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}EJe.isMDXComponent=!0;const BJe={toc:[]};function GJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},BJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}GJe.isMDXComponent=!0;const VJe={toc:[]};function UJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},VJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}UJe.isMDXComponent=!0;const FJe={toc:[]};function qJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},FJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}qJe.isMDXComponent=!0;const jJe={toc:[]};function YJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}YJe.isMDXComponent=!0;const HJe={toc:[]};function QJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},HJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}QJe.isMDXComponent=!0;const $Je={toc:[]};function KJe(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$Je,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}KJe.isMDXComponent=!0;const JJe={toc:[]};function t0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},JJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}t0e.isMDXComponent=!0;const e0e={toc:[]};function n0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}n0e.isMDXComponent=!0;const o0e={toc:[]};function p0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}p0e.isMDXComponent=!0;const r0e={toc:[]};function s0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}s0e.isMDXComponent=!0;const c0e={toc:[]};function i0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}i0e.isMDXComponent=!0;const a0e={toc:[]};function l0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}l0e.isMDXComponent=!0;const u0e={toc:[]};function m0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}m0e.isMDXComponent=!0;const d0e={toc:[]};function h0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}h0e.isMDXComponent=!0;const f0e={toc:[]};function k0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}k0e.isMDXComponent=!0;const y0e={toc:[]};function w0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w0e.isMDXComponent=!0;const D0e={toc:[]};function M0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}M0e.isMDXComponent=!0;const X0e={toc:[]};function _0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}_0e.isMDXComponent=!0;const g0e={toc:[]};function T0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}T0e.isMDXComponent=!0;const C0e={toc:[]};function x0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}x0e.isMDXComponent=!0;const v0e={toc:[]};function L0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}L0e.isMDXComponent=!0;const Z0e={toc:[]};function b0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}b0e.isMDXComponent=!0;const N0e={toc:[]};function z0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}z0e.isMDXComponent=!0;const A0e={toc:[]};function W0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}W0e.isMDXComponent=!0;const I0e={toc:[]};function R0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}R0e.isMDXComponent=!0;const P0e={toc:[]};function S0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}S0e.isMDXComponent=!0;const O0e={toc:[]};function E0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}E0e.isMDXComponent=!0;const B0e={toc:[]};function G0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}G0e.isMDXComponent=!0;const V0e={toc:[]};function U0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}U0e.isMDXComponent=!0;const F0e={toc:[]};function q0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}q0e.isMDXComponent=!0;const j0e={toc:[]};function Y0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Y0e.isMDXComponent=!0;const H0e={toc:[]};function Q0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Q0e.isMDXComponent=!0;const $0e={toc:[]};function K0e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}K0e.isMDXComponent=!0;const J0e={toc:[]};function t2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}t2e.isMDXComponent=!0;const e2e={toc:[]};function n2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}n2e.isMDXComponent=!0;const o2e={toc:[]};function p2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}p2e.isMDXComponent=!0;const r2e={toc:[]};function s2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}s2e.isMDXComponent=!0;const c2e={toc:[]};function i2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}i2e.isMDXComponent=!0;const a2e={toc:[]};function l2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}l2e.isMDXComponent=!0;const u2e={toc:[]};function m2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}m2e.isMDXComponent=!0;const d2e={toc:[]};function h2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}h2e.isMDXComponent=!0;const f2e={toc:[]};function k2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}k2e.isMDXComponent=!0;const y2e={toc:[]};function w2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w2e.isMDXComponent=!0;const D2e={toc:[]};function M2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}M2e.isMDXComponent=!0;const X2e={toc:[]};function _2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_2e.isMDXComponent=!0;const g2e={toc:[]};function T2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}T2e.isMDXComponent=!0;const C2e={toc:[]};function x2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}x2e.isMDXComponent=!0;const v2e={toc:[]};function L2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}L2e.isMDXComponent=!0;const Z2e={toc:[]};function b2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}b2e.isMDXComponent=!0;const N2e={toc:[]};function z2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}z2e.isMDXComponent=!0;const A2e={toc:[]};function W2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}W2e.isMDXComponent=!0;const I2e={toc:[]};function R2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}R2e.isMDXComponent=!0;const P2e={toc:[]};function S2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}S2e.isMDXComponent=!0;const O2e={toc:[]};function E2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}E2e.isMDXComponent=!0;const B2e={toc:[]};function G2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}G2e.isMDXComponent=!0;const V2e={toc:[]};function U2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}U2e.isMDXComponent=!0;const F2e={toc:[]};function q2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}q2e.isMDXComponent=!0;const j2e={toc:[]};function Y2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Y2e.isMDXComponent=!0;const H2e={toc:[]};function Q2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Q2e.isMDXComponent=!0;const $2e={toc:[]};function K2e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}K2e.isMDXComponent=!0;const J2e={toc:[]};function t6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}t6e.isMDXComponent=!0;const e6e={toc:[]};function n6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}n6e.isMDXComponent=!0;const o6e={toc:[]};function p6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}p6e.isMDXComponent=!0;const r6e={toc:[]};function s6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}s6e.isMDXComponent=!0;const c6e={toc:[]};function i6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}i6e.isMDXComponent=!0;const a6e={toc:[]};function l6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}l6e.isMDXComponent=!0;const u6e={toc:[]};function m6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}m6e.isMDXComponent=!0;const d6e={toc:[]};function h6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}h6e.isMDXComponent=!0;const f6e={toc:[]};function k6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}k6e.isMDXComponent=!0;const y6e={toc:[]};function w6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}w6e.isMDXComponent=!0;const D6e={toc:[]};function M6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}M6e.isMDXComponent=!0;const X6e={toc:[]};function _6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}_6e.isMDXComponent=!0;const g6e={toc:[]};function T6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}T6e.isMDXComponent=!0;const C6e={toc:[]};function x6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}x6e.isMDXComponent=!0;const v6e={toc:[]};function L6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}L6e.isMDXComponent=!0;const Z6e={toc:[]};function b6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}b6e.isMDXComponent=!0;const N6e={toc:[]};function z6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}z6e.isMDXComponent=!0;const A6e={toc:[]};function W6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}W6e.isMDXComponent=!0;const I6e={toc:[]};function R6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}R6e.isMDXComponent=!0;const P6e={toc:[]};function S6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}S6e.isMDXComponent=!0;const O6e={toc:[]};function E6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}E6e.isMDXComponent=!0;const B6e={toc:[]};function G6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}G6e.isMDXComponent=!0;const V6e={toc:[]};function U6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}U6e.isMDXComponent=!0;const F6e={toc:[]};function q6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}q6e.isMDXComponent=!0;const j6e={toc:[]};function Y6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Y6e.isMDXComponent=!0;const H6e={toc:[]};function Q6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Q6e.isMDXComponent=!0;const $6e={toc:[]};function K6e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}K6e.isMDXComponent=!0;const J6e={toc:[]};function t3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}t3e.isMDXComponent=!0;const e3e={toc:[]};function n3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}n3e.isMDXComponent=!0;const o3e={toc:[]};function p3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}p3e.isMDXComponent=!0;const r3e={toc:[]};function s3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}s3e.isMDXComponent=!0;const c3e={toc:[]};function i3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}i3e.isMDXComponent=!0;const a3e={toc:[]};function l3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}l3e.isMDXComponent=!0;const u3e={toc:[]};function m3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}m3e.isMDXComponent=!0;const d3e={toc:[]};function h3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}h3e.isMDXComponent=!0;const f3e={toc:[]};function k3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}k3e.isMDXComponent=!0;const y3e={toc:[]};function w3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}w3e.isMDXComponent=!0;const D3e={toc:[]};function M3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}M3e.isMDXComponent=!0;const X3e={toc:[]};function _3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_3e.isMDXComponent=!0;const g3e={toc:[]};function T3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}T3e.isMDXComponent=!0;const C3e={toc:[]};function x3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}x3e.isMDXComponent=!0;const v3e={toc:[]};function L3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}L3e.isMDXComponent=!0;const Z3e={toc:[]};function b3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}b3e.isMDXComponent=!0;const N3e={toc:[]};function z3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}z3e.isMDXComponent=!0;const A3e={toc:[]};function W3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}W3e.isMDXComponent=!0;const I3e={toc:[]};function R3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}R3e.isMDXComponent=!0;const P3e={toc:[]};function S3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}S3e.isMDXComponent=!0;const O3e={toc:[]};function E3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}E3e.isMDXComponent=!0;const B3e={toc:[]};function G3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}G3e.isMDXComponent=!0;const V3e={toc:[]};function U3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}U3e.isMDXComponent=!0;const F3e={toc:[]};function q3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}q3e.isMDXComponent=!0;const j3e={toc:[]};function Y3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Y3e.isMDXComponent=!0;const H3e={toc:[]};function Q3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Q3e.isMDXComponent=!0;const $3e={toc:[]};function K3e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}K3e.isMDXComponent=!0;const J3e={toc:[]};function t5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}t5e.isMDXComponent=!0;const e5e={toc:[]};function n5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}n5e.isMDXComponent=!0;const o5e={toc:[]};function p5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p5e.isMDXComponent=!0;const r5e={toc:[]};function s5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}s5e.isMDXComponent=!0;const c5e={toc:[]};function i5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}i5e.isMDXComponent=!0;const a5e={toc:[]};function l5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}l5e.isMDXComponent=!0;const u5e={toc:[]};function m5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}m5e.isMDXComponent=!0;const d5e={toc:[]};function h5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}h5e.isMDXComponent=!0;const f5e={toc:[]};function k5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}k5e.isMDXComponent=!0;const y5e={toc:[]};function w5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}w5e.isMDXComponent=!0;const D5e={toc:[]};function M5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}M5e.isMDXComponent=!0;const X5e={toc:[]};function _5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}_5e.isMDXComponent=!0;const g5e={toc:[]};function T5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}T5e.isMDXComponent=!0;const C5e={toc:[]};function x5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}x5e.isMDXComponent=!0;const v5e={toc:[]};function L5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}L5e.isMDXComponent=!0;const Z5e={toc:[]};function b5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}b5e.isMDXComponent=!0;const N5e={toc:[]};function z5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}z5e.isMDXComponent=!0;const A5e={toc:[]};function W5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}W5e.isMDXComponent=!0;const I5e={toc:[]};function R5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}R5e.isMDXComponent=!0;const P5e={toc:[]};function S5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}S5e.isMDXComponent=!0;const O5e={toc:[]};function E5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}E5e.isMDXComponent=!0;const B5e={toc:[]};function G5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}G5e.isMDXComponent=!0;const V5e={toc:[]};function U5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}U5e.isMDXComponent=!0;const F5e={toc:[]};function q5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}q5e.isMDXComponent=!0;const j5e={toc:[]};function Y5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Y5e.isMDXComponent=!0;const H5e={toc:[]};function Q5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Q5e.isMDXComponent=!0;const $5e={toc:[]};function K5e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}K5e.isMDXComponent=!0;const J5e={toc:[]};function t1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}t1e.isMDXComponent=!0;const e1e={toc:[]};function n1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}n1e.isMDXComponent=!0;const o1e={toc:[]};function p1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}p1e.isMDXComponent=!0;const r1e={toc:[]};function s1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}s1e.isMDXComponent=!0;const c1e={toc:[]};function i1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}i1e.isMDXComponent=!0;const a1e={toc:[]};function l1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}l1e.isMDXComponent=!0;const u1e={toc:[]};function m1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}m1e.isMDXComponent=!0;const d1e={toc:[]};function h1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}h1e.isMDXComponent=!0;const f1e={toc:[]};function k1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}k1e.isMDXComponent=!0;const y1e={toc:[]};function w1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w1e.isMDXComponent=!0;const D1e={toc:[]};function M1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}M1e.isMDXComponent=!0;const X1e={toc:[]};function _1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}_1e.isMDXComponent=!0;const g1e={toc:[]};function T1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}T1e.isMDXComponent=!0;const C1e={toc:[]};function x1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}x1e.isMDXComponent=!0;const v1e={toc:[]};function L1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}L1e.isMDXComponent=!0;const Z1e={toc:[]};function b1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}b1e.isMDXComponent=!0;const N1e={toc:[]};function z1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}z1e.isMDXComponent=!0;const A1e={toc:[]};function W1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}W1e.isMDXComponent=!0;const I1e={toc:[]};function R1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}R1e.isMDXComponent=!0;const P1e={toc:[]};function S1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}S1e.isMDXComponent=!0;const O1e={toc:[]};function E1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}E1e.isMDXComponent=!0;const B1e={toc:[]};function G1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}G1e.isMDXComponent=!0;const V1e={toc:[]};function U1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}U1e.isMDXComponent=!0;const F1e={toc:[]};function q1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}q1e.isMDXComponent=!0;const j1e={toc:[]};function Y1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Y1e.isMDXComponent=!0;const H1e={toc:[]};function Q1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Q1e.isMDXComponent=!0;const $1e={toc:[]};function K1e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}K1e.isMDXComponent=!0;const J1e={toc:[]};function t4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}t4e.isMDXComponent=!0;const e4e={toc:[]};function n4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}n4e.isMDXComponent=!0;const o4e={toc:[]};function p4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}p4e.isMDXComponent=!0;const r4e={toc:[]};function s4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}s4e.isMDXComponent=!0;const c4e={toc:[]};function i4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}i4e.isMDXComponent=!0;const a4e={toc:[]};function l4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}l4e.isMDXComponent=!0;const u4e={toc:[]};function m4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}m4e.isMDXComponent=!0;const d4e={toc:[]};function h4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}h4e.isMDXComponent=!0;const f4e={toc:[]};function k4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}k4e.isMDXComponent=!0;const y4e={toc:[]};function w4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}w4e.isMDXComponent=!0;const D4e={toc:[]};function M4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}M4e.isMDXComponent=!0;const X4e={toc:[]};function _4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}_4e.isMDXComponent=!0;const g4e={toc:[]};function T4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}T4e.isMDXComponent=!0;const C4e={toc:[]};function x4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}x4e.isMDXComponent=!0;const v4e={toc:[]};function L4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}L4e.isMDXComponent=!0;const Z4e={toc:[]};function b4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}b4e.isMDXComponent=!0;const N4e={toc:[]};function z4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}z4e.isMDXComponent=!0;const A4e={toc:[]};function W4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}W4e.isMDXComponent=!0;const I4e={toc:[]};function R4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}R4e.isMDXComponent=!0;const P4e={toc:[]};function S4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}S4e.isMDXComponent=!0;const O4e={toc:[]};function E4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}E4e.isMDXComponent=!0;const B4e={toc:[]};function G4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}G4e.isMDXComponent=!0;const V4e={toc:[]};function U4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}U4e.isMDXComponent=!0;const F4e={toc:[]};function q4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}q4e.isMDXComponent=!0;const j4e={toc:[]};function Y4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Y4e.isMDXComponent=!0;const H4e={toc:[]};function Q4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Q4e.isMDXComponent=!0;const $4e={toc:[]};function K4e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}K4e.isMDXComponent=!0;const J4e={toc:[]};function t8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}t8e.isMDXComponent=!0;const e8e={toc:[]};function n8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}n8e.isMDXComponent=!0;const o8e={toc:[]};function p8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}p8e.isMDXComponent=!0;const r8e={toc:[]};function s8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}s8e.isMDXComponent=!0;const c8e={toc:[]};function i8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}i8e.isMDXComponent=!0;const a8e={toc:[]};function l8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}l8e.isMDXComponent=!0;const u8e={toc:[]};function m8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}m8e.isMDXComponent=!0;const d8e={toc:[]};function h8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}h8e.isMDXComponent=!0;const f8e={toc:[]};function k8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}k8e.isMDXComponent=!0;const y8e={toc:[]};function w8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w8e.isMDXComponent=!0;const D8e={toc:[]};function M8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}M8e.isMDXComponent=!0;const X8e={toc:[]};function _8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}_8e.isMDXComponent=!0;const g8e={toc:[]};function T8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}T8e.isMDXComponent=!0;const C8e={toc:[]};function x8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}x8e.isMDXComponent=!0;const v8e={toc:[]};function L8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}L8e.isMDXComponent=!0;const Z8e={toc:[]};function b8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}b8e.isMDXComponent=!0;const N8e={toc:[]};function z8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}z8e.isMDXComponent=!0;const A8e={toc:[]};function W8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}W8e.isMDXComponent=!0;const I8e={toc:[]};function R8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}R8e.isMDXComponent=!0;const P8e={toc:[]};function S8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}S8e.isMDXComponent=!0;const O8e={toc:[]};function E8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}E8e.isMDXComponent=!0;const B8e={toc:[]};function G8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}G8e.isMDXComponent=!0;const V8e={toc:[]};function U8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}U8e.isMDXComponent=!0;const F8e={toc:[]};function q8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}q8e.isMDXComponent=!0;const j8e={toc:[]};function Y8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Y8e.isMDXComponent=!0;const H8e={toc:[]};function Q8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Q8e.isMDXComponent=!0;const $8e={toc:[]};function K8e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}K8e.isMDXComponent=!0;const J8e={toc:[]};function t7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}t7e.isMDXComponent=!0;const e7e={toc:[]};function n7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}n7e.isMDXComponent=!0;const o7e={toc:[]};function p7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}p7e.isMDXComponent=!0;const r7e={toc:[]};function s7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}s7e.isMDXComponent=!0;const c7e={toc:[]};function i7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}i7e.isMDXComponent=!0;const a7e={toc:[]};function l7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}l7e.isMDXComponent=!0;const u7e={toc:[]};function m7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}m7e.isMDXComponent=!0;const d7e={toc:[]};function h7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}h7e.isMDXComponent=!0;const f7e={toc:[]};function k7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}k7e.isMDXComponent=!0;const y7e={toc:[]};function w7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}w7e.isMDXComponent=!0;const D7e={toc:[]};function M7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}M7e.isMDXComponent=!0;const X7e={toc:[]};function _7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}_7e.isMDXComponent=!0;const g7e={toc:[]};function T7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}T7e.isMDXComponent=!0;const C7e={toc:[]};function x7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}x7e.isMDXComponent=!0;const v7e={toc:[]};function L7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represent SVG document that contains SVG shapes.\nThis only used single time because ",(0,s.kt)("inlineCode",{parentName:"p"},"nodes")," have reference to parent SVG renderer."))}L7e.isMDXComponent=!0;const Z7e={toc:[]};function b7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Data of SVGDocument.\nThis can used many times because it do not reference parent SVG.\nThis must build into SVGDocument"))}b7e.isMDXComponent=!0;const N7e={toc:[]};function z7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}z7e.isMDXComponent=!0;const A7e={toc:[]};function W7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}W7e.isMDXComponent=!0;const I7e={toc:[]};function R7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}R7e.isMDXComponent=!0;const P7e={toc:[]};function S7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}S7e.isMDXComponent=!0;const O7e={toc:[]};function E7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}E7e.isMDXComponent=!0;const B7e={toc:[]};function G7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}G7e.isMDXComponent=!0;const V7e={toc:[]};function U7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}U7e.isMDXComponent=!0;const F7e={toc:[]};function q7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}q7e.isMDXComponent=!0;const j7e={toc:[]};function Y7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Y7e.isMDXComponent=!0;const H7e={toc:[]};function Q7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Q7e.isMDXComponent=!0;const $7e={toc:[]};function K7e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}K7e.isMDXComponent=!0;const J7e={toc:[]};function t9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}t9e.isMDXComponent=!0;const e9e={toc:[]};function n9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},e9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}n9e.isMDXComponent=!0;const o9e={toc:[]};function p9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},o9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}p9e.isMDXComponent=!0;const r9e={toc:[]};function s9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},r9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}s9e.isMDXComponent=!0;const c9e={toc:[]};function i9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},c9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}i9e.isMDXComponent=!0;const a9e={toc:[]};function l9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},a9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represent SVG shape.\nThis only used single time because ",(0,s.kt)("inlineCode",{parentName:"p"},"node")," may have reference to parent SVG renderer."))}l9e.isMDXComponent=!0;const u9e={toc:[]};function m9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},u9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Data of SVGShape.\nThis can used many times  because it do not reference parent SVG.\nThis must build into SVGShape"))}m9e.isMDXComponent=!0;const d9e={toc:[]};function h9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},d9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}h9e.isMDXComponent=!0;const f9e={toc:[]};function k9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},f9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}k9e.isMDXComponent=!0;const y9e={toc:[]};function w9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},y9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}w9e.isMDXComponent=!0;const D9e={toc:[]};function M9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},D9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}M9e.isMDXComponent=!0;const X9e={toc:[]};function _9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},X9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}_9e.isMDXComponent=!0;const g9e={toc:[]};function T9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},g9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}T9e.isMDXComponent=!0;const C9e={toc:[]};function x9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},C9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}x9e.isMDXComponent=!0;const v9e={toc:[]};function L9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},v9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}L9e.isMDXComponent=!0;const Z9e={toc:[]};function b9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Z9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}b9e.isMDXComponent=!0;const N9e={toc:[]};function z9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},N9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}z9e.isMDXComponent=!0;const A9e={toc:[]};function W9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},A9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}W9e.isMDXComponent=!0;const I9e={toc:[]};function R9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},I9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}R9e.isMDXComponent=!0;const P9e={toc:[]};function S9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},P9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}S9e.isMDXComponent=!0;const O9e={toc:[]};function E9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},O9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}E9e.isMDXComponent=!0;const B9e={toc:[]};function G9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},B9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}G9e.isMDXComponent=!0;const V9e={toc:[]};function U9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},V9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}U9e.isMDXComponent=!0;const F9e={toc:[]};function q9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},F9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}q9e.isMDXComponent=!0;const j9e={toc:[]};function Y9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},j9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Y9e.isMDXComponent=!0;const H9e={toc:[]};function Q9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},H9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Q9e.isMDXComponent=!0;const $9e={toc:[]};function K9e(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}K9e.isMDXComponent=!0;const J9e={toc:[]};function ttn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},J9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ttn.isMDXComponent=!0;const etn={toc:[]};function ntn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},etn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}ntn.isMDXComponent=!0;const otn={toc:[]};function ptn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},otn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ptn.isMDXComponent=!0;const rtn={toc:[]};function stn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}stn.isMDXComponent=!0;const ctn={toc:[]};function itn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ctn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}itn.isMDXComponent=!0;const atn={toc:[]};function ltn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},atn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}ltn.isMDXComponent=!0;const utn={toc:[]};function mtn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},utn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}mtn.isMDXComponent=!0;const dtn={toc:[]};function htn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}htn.isMDXComponent=!0;const ftn={toc:[]};function ktn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ftn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ktn.isMDXComponent=!0;const ytn={toc:[]};function wtn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ytn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}wtn.isMDXComponent=!0;const Dtn={toc:[]};function Mtn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Mtn.isMDXComponent=!0;const Xtn={toc:[]};function _tn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}_tn.isMDXComponent=!0;const gtn={toc:[]};function Ttn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ttn.isMDXComponent=!0;const Ctn={toc:[]};function xtn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ctn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}xtn.isMDXComponent=!0;const vtn={toc:[]};function Ltn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Spline.points"))}Ltn.isMDXComponent=!0;const Ztn={toc:[]};function btn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ztn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}btn.isMDXComponent=!0;const Ntn={toc:[]};function ztn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ntn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}ztn.isMDXComponent=!0;const Atn={toc:[]};function Wtn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Atn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}Wtn.isMDXComponent=!0;const Itn={toc:[]};function Rtn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Itn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}Rtn.isMDXComponent=!0;const Ptn={toc:[]};function Stn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ptn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Stn.isMDXComponent=!0;const Otn={toc:[]};function Etn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Otn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Etn.isMDXComponent=!0;const Btn={toc:[]};function Gtn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Btn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Gtn.isMDXComponent=!0;const Vtn={toc:[]};function Utn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Utn.isMDXComponent=!0;const Ftn={toc:[]};function qtn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ftn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}qtn.isMDXComponent=!0;const jtn={toc:[]};function Ytn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Ytn.isMDXComponent=!0;const Htn={toc:[]};function Qtn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Htn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qtn.isMDXComponent=!0;const $tn={toc:[]};function Ktn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$tn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Ktn.isMDXComponent=!0;const Jtn={toc:[]};function ten(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ten.isMDXComponent=!0;const een={toc:[]};function nen(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},een,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}nen.isMDXComponent=!0;const oen={toc:[]};function pen(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pen.isMDXComponent=!0;const ren={toc:[]};function sen(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ren,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}sen.isMDXComponent=!0;const cen={toc:[]};function ien(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ien.isMDXComponent=!0;const aen={toc:[]};function len(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}len.isMDXComponent=!0;const uen={toc:[]};function men(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}men.isMDXComponent=!0;const den={toc:[]};function hen(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},den,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}hen.isMDXComponent=!0;const fen={toc:[]};function ken(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ken.isMDXComponent=!0;const yen={toc:[]};function wen(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}wen.isMDXComponent=!0;const Den={toc:[]};function Men(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Den,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Men.isMDXComponent=!0;const Xen={toc:[]};function _en(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}_en.isMDXComponent=!0;const gen={toc:[]};function Ten(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ten.isMDXComponent=!0;const Cen={toc:[]};function xen(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}xen.isMDXComponent=!0;const ven={toc:[]};function Len(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ven,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Len.isMDXComponent=!0;const Zen={toc:[]};function ben(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}ben.isMDXComponent=!0;const Nen={toc:[]};function zen(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zen.isMDXComponent=!0;const Aen={toc:[]};function Wen(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Wen.isMDXComponent=!0;const Ien={toc:[]};function Ren(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ien,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ren.isMDXComponent=!0;const Pen={toc:[]};function Sen(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Sen.isMDXComponent=!0;const Oen={toc:[]};function Een(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}Een.isMDXComponent=!0;const Ben={toc:[]};function Gen(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ben,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}Gen.isMDXComponent=!0;const Ven={toc:[]};function Uen(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ven,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Uen.isMDXComponent=!0;const Fen={toc:[]};function qen(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}qen.isMDXComponent=!0;const jen={toc:[]};function Yen(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Yen.isMDXComponent=!0;const Hen={toc:[]};function Qen(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Qen.isMDXComponent=!0;const $en={toc:[]};function Ken(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$en,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ken.isMDXComponent=!0;const Jen={toc:[]};function tnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}tnn.isMDXComponent=!0;const enn={toc:[]};function nnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},enn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}nnn.isMDXComponent=!0;const onn={toc:[]};function pnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},onn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pnn.isMDXComponent=!0;const rnn={toc:[]};function snn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}snn.isMDXComponent=!0;const cnn={toc:[]};function inn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}inn.isMDXComponent=!0;const ann={toc:[]};function lnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ann,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}lnn.isMDXComponent=!0;const unn={toc:[]};function mnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},unn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}mnn.isMDXComponent=!0;const dnn={toc:[]};function hnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}hnn.isMDXComponent=!0;const fnn={toc:[]};function knn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}knn.isMDXComponent=!0;const ynn={toc:[]};function wnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ynn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wnn.isMDXComponent=!0;const Dnn={toc:[]};function Mnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Mnn.isMDXComponent=!0;const Xnn={toc:[]};function _nn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}_nn.isMDXComponent=!0;const gnn={toc:[]};function Tnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Tnn.isMDXComponent=!0;const Cnn={toc:[]};function xnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xnn.isMDXComponent=!0;const vnn={toc:[]};function Lnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Lnn.isMDXComponent=!0;const Znn={toc:[]};function bnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Znn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}bnn.isMDXComponent=!0;const Nnn={toc:[]};function znn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}znn.isMDXComponent=!0;const Ann={toc:[]};function Wnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ann,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Wnn.isMDXComponent=!0;const Inn={toc:[]};function Rnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Inn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Rnn.isMDXComponent=!0;const Pnn={toc:[]};function Snn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Snn.isMDXComponent=!0;const Onn={toc:[]};function Enn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Onn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Enn.isMDXComponent=!0;const Bnn={toc:[]};function Gnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Gnn.isMDXComponent=!0;const Vnn={toc:[]};function Unn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}Unn.isMDXComponent=!0;const Fnn={toc:[]};function qnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}qnn.isMDXComponent=!0;const jnn={toc:[]};function Ynn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}Ynn.isMDXComponent=!0;const Hnn={toc:[]};function Qnn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Qnn.isMDXComponent=!0;const $nn={toc:[]};function Knn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$nn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Knn.isMDXComponent=!0;const Jnn={toc:[]};function ton(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ton.isMDXComponent=!0;const eon={toc:[]};function non(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},eon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}non.isMDXComponent=!0;const oon={toc:[]};function pon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}pon.isMDXComponent=!0;const ron={toc:[]};function son(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ron,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}son.isMDXComponent=!0;const con={toc:[]};function ion(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},con,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting time for this video in seconds."))}ion.isMDXComponent=!0;const aon={toc:[]};function lon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lon.isMDXComponent=!0;const uon={toc:[]};function mon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}mon.isMDXComponent=!0;const don={toc:[]};function hon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},don,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}hon.isMDXComponent=!0;const fon={toc:[]};function kon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}kon.isMDXComponent=!0;const yon={toc:[]};function won(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}won.isMDXComponent=!0;const Don={toc:[]};function Mon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Don,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Mon.isMDXComponent=!0;const Xon={toc:[]};function _on(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}_on.isMDXComponent=!0;const gon={toc:[]};function Ton(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Ton.isMDXComponent=!0;const Con={toc:[]};function xon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Con,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xon.isMDXComponent=!0;const von={toc:[]};function Lon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},von,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Lon.isMDXComponent=!0;const Zon={toc:[]};function bon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}bon.isMDXComponent=!0;const Non={toc:[]};function zon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Non,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}zon.isMDXComponent=!0;const Aon={toc:[]};function Won(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Aon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Won.isMDXComponent=!0;const Ion={toc:[]};function Ron(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ion,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ron.isMDXComponent=!0;const Pon={toc:[]};function Son(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Son.isMDXComponent=!0;const Oon={toc:[]};function Eon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Eon.isMDXComponent=!0;const Bon={toc:[]};function Gon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Gon.isMDXComponent=!0;const Von={toc:[]};function Uon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Von,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Uon.isMDXComponent=!0;const Fon={toc:[]};function qon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qon.isMDXComponent=!0;const jon={toc:[]};function Yon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Yon.isMDXComponent=!0;const Hon={toc:[]};function Qon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Qon.isMDXComponent=!0;const $on={toc:[]};function Kon(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$on,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Kon.isMDXComponent=!0;const Jon={toc:[]};function tpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}tpn.isMDXComponent=!0;const epn={toc:[]};function npn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},epn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}npn.isMDXComponent=!0;const opn={toc:[]};function ppn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},opn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ppn.isMDXComponent=!0;const rpn={toc:[]};function spn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}spn.isMDXComponent=!0;const cpn={toc:[]};function ipn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}ipn.isMDXComponent=!0;const apn={toc:[]};function lpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},apn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}lpn.isMDXComponent=!0;const upn={toc:[]};function mpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},upn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}mpn.isMDXComponent=!0;const dpn={toc:[]};function hpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}hpn.isMDXComponent=!0;const fpn={toc:[]};function kpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}kpn.isMDXComponent=!0;const ypn={toc:[]};function wpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ypn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}wpn.isMDXComponent=!0;const Dpn={toc:[]};function Mpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Mpn.isMDXComponent=!0;const Xpn={toc:[]};function _pn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}_pn.isMDXComponent=!0;const gpn={toc:[]};function Tpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Tpn.isMDXComponent=!0;const Cpn={toc:[]};function xpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}xpn.isMDXComponent=!0;const vpn={toc:[]};function Lpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Lpn.isMDXComponent=!0;const Zpn={toc:[]};function bpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}bpn.isMDXComponent=!0;const Npn={toc:[]};function zpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Npn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}zpn.isMDXComponent=!0;const Apn={toc:[]};function Wpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Apn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Wpn.isMDXComponent=!0;const Ipn={toc:[]};function Rpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ipn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Rpn.isMDXComponent=!0;const Ppn={toc:[]};function Spn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ppn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Spn.isMDXComponent=!0;const Opn={toc:[]};function Epn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Opn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Epn.isMDXComponent=!0;const Bpn={toc:[]};function Gpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Gpn.isMDXComponent=!0;const Vpn={toc:[]};function Upn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}Upn.isMDXComponent=!0;const Fpn={toc:[]};function qpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}qpn.isMDXComponent=!0;const jpn={toc:[]};function Ypn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}Ypn.isMDXComponent=!0;const Hpn={toc:[]};function Qpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}Qpn.isMDXComponent=!0;const $pn={toc:[]};function Kpn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$pn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}Kpn.isMDXComponent=!0;const Jpn={toc:[]};function trn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.kt)("p",null,"Source code liberally taken from:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}trn.isMDXComponent=!0;const ern={toc:[]};function nrn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ern,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}nrn.isMDXComponent=!0;const orn={toc:[]};function prn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},orn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}prn.isMDXComponent=!0;const rrn={toc:[]};function srn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}srn.isMDXComponent=!0;const crn={toc:[]};function irn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},crn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}irn.isMDXComponent=!0;const arn={toc:[]};function lrn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},arn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}lrn.isMDXComponent=!0;const urn={toc:[]};function mrn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},urn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}mrn.isMDXComponent=!0;const drn={toc:[]};function hrn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},drn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}hrn.isMDXComponent=!0;const frn={toc:[]};function krn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},frn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}krn.isMDXComponent=!0;const yrn={toc:[]};function wrn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}wrn.isMDXComponent=!0;const Drn={toc:[]};function Mrn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Drn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}Mrn.isMDXComponent=!0;const Xrn={toc:[]};function _rn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The degree of the polynomial"))}_rn.isMDXComponent=!0;const grn={toc:[]};function Trn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},grn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the nth derivative of the polynomial."))}Trn.isMDXComponent=!0;const Crn={toc:[]};function xrn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Crn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of times to differentiate the polynomial."))}xrn.isMDXComponent=!0;const vrn={toc:[]};function Lrn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given value t."))}Lrn.isMDXComponent=!0;const Zrn={toc:[]};function brn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}brn.isMDXComponent=!0;const Nrn={toc:[]};function zrn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}zrn.isMDXComponent=!0;const Arn={toc:[]};function Wrn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Arn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}Wrn.isMDXComponent=!0;const Irn={toc:[]};function Rrn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Irn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The derivative of the polynomial to sample from"))}Rrn.isMDXComponent=!0;const Prn={toc:[]};function Srn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Prn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial."))}Srn.isMDXComponent=!0;const Orn={toc:[]};function Ern(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Orn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}Ern.isMDXComponent=!0;const Brn={toc:[]};function Grn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Brn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the output value range within the unit interval."))}Grn.isMDXComponent=!0;const Vrn={toc:[]};function Urn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}Urn.isMDXComponent=!0;const Frn={toc:[]};function qrn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Frn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}qrn.isMDXComponent=!0;const jrn={toc:[]};function Yrn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}Yrn.isMDXComponent=!0;const Hrn={toc:[]};function Qrn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The point at which to split the polynomial."))}Qrn.isMDXComponent=!0;const $rn={toc:[]};function Krn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$rn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a constant polynomial"))}Krn.isMDXComponent=!0;const Jrn={toc:[]};function tsn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}tsn.isMDXComponent=!0;const esn={toc:[]};function nsn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},esn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a cubic polynomial"))}nsn.isMDXComponent=!0;const osn={toc:[]};function psn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},osn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}psn.isMDXComponent=!0;const rsn={toc:[]};function ssn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}ssn.isMDXComponent=!0;const csn={toc:[]};function isn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},csn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}isn.isMDXComponent=!0;const asn={toc:[]};function lsn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},asn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}lsn.isMDXComponent=!0;const usn={toc:[]};function msn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},usn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a linear polynomial"))}msn.isMDXComponent=!0;const dsn={toc:[]};function hsn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}hsn.isMDXComponent=!0;const fsn={toc:[]};function ksn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}ksn.isMDXComponent=!0;const ysn={toc:[]};function wsn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ysn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a quadratic polynomial"))}wsn.isMDXComponent=!0;const Dsn={toc:[]};function Msn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}Msn.isMDXComponent=!0;const Xsn={toc:[]};function _sn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}_sn.isMDXComponent=!0;const gsn={toc:[]};function Tsn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}Tsn.isMDXComponent=!0;const Csn={toc:[]};function xsn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Csn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}xsn.isMDXComponent=!0;const vsn={toc:[]};function Lsn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}Lsn.isMDXComponent=!0;const Zsn={toc:[]};function bsn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}bsn.isMDXComponent=!0;const Nsn={toc:[]};function zsn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}zsn.isMDXComponent=!0;const Asn={toc:[]};function Wsn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Asn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}Wsn.isMDXComponent=!0;const Isn={toc:[]};function Rsn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Isn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}Rsn.isMDXComponent=!0;const Psn={toc:[]};function Ssn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Psn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}Ssn.isMDXComponent=!0;const Osn={toc:[]};function Esn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Osn,n,{components:e,mdxType:"MDXLayout"}))}Esn.isMDXComponent=!0;const Bsn={toc:[]};function Gsn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}Gsn.isMDXComponent=!0;const Vsn={toc:[]};function Usn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The knots defining the spline"))}Usn.isMDXComponent=!0;const Fsn={toc:[]};function qsn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the spline should be closed or not"))}qsn.isMDXComponent=!0;const jsn={toc:[]};function Ysn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}Ysn.isMDXComponent=!0;const Hsn={toc:[]};function Qsn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}Qsn.isMDXComponent=!0;const $sn={toc:[]};function Ksn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$sn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}Ksn.isMDXComponent=!0;const Jsn={toc:[]};function tcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}tcn.isMDXComponent=!0;const ecn={toc:[]};function ncn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ecn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}ncn.isMDXComponent=!0;const ocn={toc:[]};function pcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ocn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}pcn.isMDXComponent=!0;const rcn={toc:[]};function scn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}scn.isMDXComponent=!0;const ccn={toc:[]};function icn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ccn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}icn.isMDXComponent=!0;const acn={toc:[]};function lcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},acn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}lcn.isMDXComponent=!0;const ucn={toc:[]};function mcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ucn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}mcn.isMDXComponent=!0;const dcn={toc:[]};function hcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}hcn.isMDXComponent=!0;const fcn={toc:[]};function kcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.kt)("p",null,"By default, any property is cloneable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}kcn.isMDXComponent=!0;const ycn={toc:[]};function wcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ycn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}wcn.isMDXComponent=!0;const Dcn={toc:[]};function Mcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a cloneable property decorator."))}Mcn.isMDXComponent=!0;const Xcn={toc:[]};function _cn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be cloneable."))}_cn.isMDXComponent=!0;const gcn={toc:[]};function Tcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}Tcn.isMDXComponent=!0;const Ccn={toc:[]};function xcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ccn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}xcn.isMDXComponent=!0;const vcn={toc:[]};function Lcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a compound property decorator."))}Lcn.isMDXComponent=!0;const Zcn={toc:[]};function bcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}bcn.isMDXComponent=!0;const Ncn={toc:[]};function zcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ncn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}zcn.isMDXComponent=!0;const Acn={toc:[]};function Wcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Acn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a computed method decorator."))}Wcn.isMDXComponent=!0;const Icn={toc:[]};function Rcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Icn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the initial value of a property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Rcn.isMDXComponent=!0;const Pcn={toc:[]};function Scn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}Scn.isMDXComponent=!0;const Ocn={toc:[]};function Ecn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ocn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an initial signal value decorator."))}Ecn.isMDXComponent=!0;const Bcn={toc:[]};function Gcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the property."))}Gcn.isMDXComponent=!0;const Vcn={toc:[]};function Ucn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.kt)("p",null,"By default, any property is inspectable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Ucn.isMDXComponent=!0;const Fcn={toc:[]};function qcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}qcn.isMDXComponent=!0;const jcn={toc:[]};function Ycn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an inspectable property decorator."))}Ycn.isMDXComponent=!0;const Hcn={toc:[]};function Qcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be inspectable."))}Qcn.isMDXComponent=!0;const $cn={toc:[]};function Kcn(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$cn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Kcn.isMDXComponent=!0;const Jcn={toc:[]};function tin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}tin.isMDXComponent=!0;const ein={toc:[]};function nin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ein,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal interpolation function decorator."))}nin.isMDXComponent=!0;const oin={toc:[]};function pin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function for the property."))}pin.isMDXComponent=!0;const rin={toc:[]};function sin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},rin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.kt)("p",null,"If the wrapper class has a method called ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}sin.isMDXComponent=!0;const cin={toc:[]};function iin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},cin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}iin.isMDXComponent=!0;const ain={toc:[]};function lin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ain,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal parser decorator."))}lin.isMDXComponent=!0;const uin={toc:[]};function min(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}min.isMDXComponent=!0;const din={toc:[]};function hin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},din,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given property into a signal."),(0,s.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}hin.isMDXComponent=!0;const fin={toc:[]};function kin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}kin.isMDXComponent=!0;const yin={toc:[]};function win(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal decorator."))}win.isMDXComponent=!0;const Din={toc:[]};function Min(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Din,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Min.isMDXComponent=!0;const Xin={toc:[]};function _in(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}_in.isMDXComponent=!0;const gin={toc:[]};function Tin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal wrapper decorator."))}Tin.isMDXComponent=!0;const Cin={toc:[]};function xin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Cin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}xin.isMDXComponent=!0;const vin={toc:[]};function Lin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},vin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unified abstraction for all CSS filters."))}Lin.isMDXComponent=!0;const Zin={toc:[]};function bin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Zin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the desired length is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}bin.isMDXComponent=!0;const Nin={toc:[]};function zin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Nin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}zin.isMDXComponent=!0;const Ain={toc:[]};function Win(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Ain,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can be either:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'"))))}Win.isMDXComponent=!0;const Iin={toc:[]};function Rin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Iin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length used by most layout properties."))}Rin.isMDXComponent=!0;const Pin={toc:[]};function Sin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Pin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,s.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}Sin.isMDXComponent=!0;const Oin={toc:[]};function Ein(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Oin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}Ein.isMDXComponent=!0;const Bin={toc:[]};function Gin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Bin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in pixels."))}Gin.isMDXComponent=!0;const Vin={toc:[]};function Uin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Vin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}Uin.isMDXComponent=!0;const Fin={toc:[]};function qin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Fin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}qin.isMDXComponent=!0;const jin={toc:[]};function Yin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},jin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}Yin.isMDXComponent=!0;const Hin={toc:[]};function Qin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Hin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}Qin.isMDXComponent=!0;const $in={toc:[]};function Kin(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},$in,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}Kin.isMDXComponent=!0;const Jin={toc:[]};function tan(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Jin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}tan.isMDXComponent=!0;const ean={toc:[]};function nan(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ean,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}nan.isMDXComponent=!0;const oan={toc:[]};function pan(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},oan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in degrees."))}pan.isMDXComponent=!0;const ran={toc:[]};function san(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},ran,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}san.isMDXComponent=!0;const can={toc:[]};function ian(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},can,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}ian.isMDXComponent=!0;const aan={toc:[]};function lan(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},aan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}lan.isMDXComponent=!0;const uan={toc:[]};function man(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},uan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}man.isMDXComponent=!0;const dan={toc:[]};function han(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},dan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}han.isMDXComponent=!0;const fan={toc:[]};function kan(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},fan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}kan.isMDXComponent=!0;const yan={toc:[]};function wan(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},yan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}wan.isMDXComponent=!0;const Dan={toc:[]};function Man(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Dan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}Man.isMDXComponent=!0;const Xan={toc:[]};function _an(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},Xan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}_an.isMDXComponent=!0;const gan={toc:[]};function Tan(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,r.Z)({},gan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}function Can(t){let{id:e}=t;const n=o[e]??p.Fragment;return p.createElement(n,null)}Tan.isMDXComponent=!0},9322:(t,e,n)=>{n.d(e,{Z:()=>m});var o=n(2784),p=n(6879),r=n(8698);const s="toggle_S_IX",c="collapsed_wdUB",i="collapse_TjTN",a="inverse_g6vW",l="clearFix_HQ1T";var u=n(6277);function m(t){let{comment:e,full:n=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@remarks"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==e?void 0:e.summaryId}),o.createElement(p.Z,{id:null==r?void 0:r.contentId}),n&&o.createElement(d,{comment:e}))}function d(t){let{comment:e}=t;const[n,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@preview"===e}))}),[e]),h=(0,o.useMemo)((()=>{var t;return(null==e||null==(t=e.blockTags)?void 0:t.filter((t=>{let{tag:e}=t;return"@example"===e})))??[]}),[e]),f=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@defaultValue"===e}))}),[e]),k=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@deprecated"===e}))}),[e]),y=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@see"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==d?void 0:d.contentId}),h.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(s,n&&c),onClick:t=>{t.preventDefault(),m(!n)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:n},o.createElement("div",{className:i},h.map((t=>o.createElement(p.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,a)})),f&&o.createElement(o.Fragment,null,"Default Value:"," ",o.createElement("code",null,f.content.map((t=>t.text)).join(""))),k&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(p.Z,{id:k.contentId})),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(p.Z,{id:y.contentId})))}},1930:(t,e,n)=>{n.d(e,{Z:()=>Gt});var o=n(2784),p=n(7390),r=n(6835),s=n(68),c=n(6277),i=n(8569);const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=n(7896);function u(t){let{width:e=24,height:n=24,...p}=t;return o.createElement("svg",(0,l.Z)({width:e,height:n,"aria-hidden":"true",viewBox:"0 0 24 24"},p),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:e,highlight:n,onClick:p,link:l}=t;const m=(0,r.F)(),d=(0,s.s2)();return o.createElement("div",{className:(0,c.Z)(i.Z.codeBlockContent,a.codeBlock,n&&a.highlight,p&&a.pointer)},o.createElement("pre",{onClick:p,onKeyDown:t=>{"Enter"===t.key&&(null==p||p())},tabIndex:0,ref:m.codeBlockRef,className:(0,c.Z)(i.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:i.Z.codeBlockLines,style:d},e)),l&&o.createElement("div",{className:i.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=n(9318);function h(t){let{children:e}=t;return o.createElement(d.Z,{as:"div",className:(0,c.Z)(a.codeBlockContainer,"language-typescript")},e)}var f=n(9817);function k(t){let{children:e,type:n,to:p,id:r,tooltip:c}=t;const i=(0,s.Ld)(n);return p?o.createElement(f.Z,(0,l.Z)({id:r,to:p,"data-tooltip":c},i),e):o.createElement("span",(0,l.Z)({id:r},i),e)}let y,w;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(y||(y={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(w||(w={}));const D={[y.None]:a.none,[y.Angle]:a.angle,[y.Curly]:a.curly,[y.Square]:a.square,[y.Parentheses]:a.parentheses};function M(t){let{children:e,type:n,separator:p=w.Comma}=t;return o.createElement("span",{className:(0,c.Z)(a.list,D[n??y.None])},o.createElement("span",{className:(0,c.Z)(a.elements,p!==w.Comma&&a.left)},(Array.isArray(e)?e:[e]).flatMap(((t,e)=>o.createElement("span",{"data-separator":p,key:e,className:a.element},t)))))}var X=n(8617);function _(t){var e;let{type:n}=t;const p=(0,X.RU)(n.project),r=null==p?void 0:p[n.id],s=n.externalUrl??(0,X.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(k,{to:s,type:s?"class-name":"constant",tooltip:!0},n.name),!(null==(e=n.typeArguments)||!e.length)&&o.createElement(M,{type:y.Angle},n.typeArguments.map(((t,e)=>o.createElement(O,{key:e,type:t})))))}function g(t){let{type:e}=t;return o.createElement(k,{type:"keyword"},e.name)}function T(t){let{type:e}=t;return e.elements?o.createElement(M,{type:y.Square},e.elements.map(((t,e)=>o.createElement(O,{key:e,type:t})))):o.createElement(o.Fragment,null,"[]")}function C(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(O,{type:e.elementType}),"[]")}function x(t){let{type:e}=t;return o.createElement(M,{type:y.Parentheses,separator:w.Pipe},e.types.map(((t,e)=>o.createElement(O,{key:e,type:t}))))}function v(t){let{type:e}=t;const[n,p]=(0,o.useMemo)((()=>{if(null===e.value)return["null","keyword"];switch(typeof e.value){case"object":return[(e.value.negative?"-":"")+e.value.value,"number"];case"boolean":return[e.value,"keyword"];case"number":return[e.value,"number"];case"string":return[`'${e.value}'`,"string"];default:return[e.value,"constant"]}}),[e.value]);return o.createElement(k,{type:p},n)}function L(t){let{type:e}=t;return e.asserts?o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"asserts "),o.createElement(k,null,e.name," ")):o.createElement(o.Fragment,null,o.createElement(k,null,e.name," "),o.createElement(k,{type:"keyword"},"is "),o.createElement(O,{type:e.targetType}))}function Z(t){let{type:e}=t;const n=(0,X.in)();return o.createElement(Q,{reflection:n(e.declaration)})}function b(t){let{type:e}=t;return o.createElement(M,{type:y.Parentheses,separator:w.Ampersand},e.types.map(((t,e)=>o.createElement(O,{key:e,type:t}))))}function N(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"string"},"`",e.head),e.tail.map(((t,e)=>{let[n,p]=t;return o.createElement(o.Fragment,null,"${",o.createElement(O,{key:e,type:n}),"}",o.createElement(k,{type:"string"},p))})),o.createElement(k,{type:"string"},"`"))}function z(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"typeof "),o.createElement(O,{type:e.queryType}))}function A(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(O,{type:e.checkType}),o.createElement(k,{type:"keyword"}," extends "),o.createElement(O,{type:e.extendsType})," ? ",o.createElement(O,{type:e.trueType})," : ",o.createElement(O,{type:e.falseType}))}function W(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"infer "),o.createElement(k,{type:"constant"},e.name))}function I(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(O,{type:e.objectType}),"[",o.createElement(O,{type:e.indexType}),"]")}function R(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},e.operator," "),o.createElement(O,{type:e.target}))}function P(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(M,{type:y.Curly},o.createElement(o.Fragment,null,"[",o.createElement(k,{type:"class"},e.parameter),o.createElement(k,{type:"keyword"}," in "),o.createElement(O,{type:e.parameterType}),"]: ",o.createElement(O,{type:e.templateType}))))}function S(t){let{type:e}=t;return o.createElement(o.Fragment,null,e.name,": ",o.createElement(O,{type:e.element}))}function O(t){const e=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return R;case"conditional":return A;case"reflection":return Z;case"query":return z;case"named-tuple-member":return S;case"union":return x;case"intrinsic":return g;case"literal":return v;case"reference":return _;case"predicate":return L;case"tuple":return T;case"array":return C;case"intersection":return b;case"inferred":return W;case"mapped":return P;case"template-literal":return N;case"indexedAccess":return I}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(e,t)}function E(t){let{flags:e,explicitAccessModifier:n}=t;const p=[];return null!=e&&e.isAbstract&&p.push("abstract"),null!=e&&e.isStatic&&p.push("static"),null!=e&&e.isConst&&p.push("const"),null!=e&&e.isReadonly&&p.push("readonly"),null!=e&&e.isPrivate&&p.push("private"),null!=e&&e.isProtected&&p.push("protected"),(null==e||!e.isPublic)&&(!n||null!=e&&e.isProtected||null!=e&&e.isPrivate)||p.push("public"),o.createElement(o.Fragment,null,p.map((t=>o.createElement(k,{key:t,type:"keyword"},t," "))))}function B(t){let{reflection:e}=t;const n="__namedParameters"===e.name?"{...}":e.name;return o.createElement(o.Fragment,null,o.createElement(E,{flags:e.flags}),e.flags.isRest&&"...",o.createElement(k,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"plain"},n),e.flags.isOptional&&"?",": ",e.type&&o.createElement(O,{type:e.type}),e.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(k,{type:"plain"},e.defaultValue)))}function G(t){let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(E,{flags:e.flags}),e.varianceModifier&&o.createElement(k,{type:"keyword"},e.varianceModifier," "),o.createElement(k,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"class-name"},e.name),e.type&&o.createElement(o.Fragment,null," extends ",o.createElement(O,{type:e.type})),e.default&&o.createElement(o.Fragment,null," = ",o.createElement(O,{type:e.default})))}function V(t){var e,n;let{reflection:r,flags:s}=t;const c=(0,X.in)(),i="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(E,{flags:s??r.flags,explicitAccessModifier:!i}),r.kind===p.W.GetSignature&&o.createElement(k,{type:"keyword"},"get "),r.kind===p.W.SetSignature&&o.createElement(k,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(k,{to:r.overwrites.externalUrl??(0,X.Gr)(c(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===p.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(k,{to:"#",type:"keyword"},"new")," ",o.createElement(k,{type:"plain"},r.type.name)):i?"":o.createElement(k,{type:"function"},r.name),!(null==(e=r.typeParameter)||!e.length)&&o.createElement(M,{type:y.Angle},r.typeParameter.map((t=>o.createElement(G,{key:t.id,reflection:c(t)})))),null!=(n=r.parameters)&&n.length?o.createElement(M,{type:y.Parentheses},r.parameters.map((t=>o.createElement(B,{key:t,reflection:c(t)})))):"()",r.type&&o.createElement(o.Fragment,null,i?" => ":": ",o.createElement(O,{type:r.type})))}function U(t){let{reflection:e}=t;return o.createElement(B,{reflection:e})}const F={[p.W.Namespace]:"namespace",[p.W.Enum]:"enum",[p.W.Class]:"class",[p.W.Interface]:"interface"};function q(t){var e,n,p;let{reflection:r}=t;const s=(0,X.in)();return o.createElement(o.Fragment,null,o.createElement(E,{flags:r.flags}),o.createElement(k,{type:"keyword"},F[r.kind]," "),o.createElement(k,{type:"class-name"},r.name),!(null==(e=r.typeParameters)||!e.length)&&o.createElement(M,{type:y.Angle},r.typeParameters.map((t=>o.createElement(G,{key:t.id,reflection:s(t)}))))," ",!(null==(n=r.extendedTypes)||!n.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"extends "),o.createElement(M,null,r.extendedTypes.map(((t,e)=>o.createElement(O,{key:e,type:t}))))),!(null==(p=r.implementedTypes)||!p.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"implements "),o.createElement(M,null,r.implementedTypes.map(((t,e)=>o.createElement(O,{key:e,type:t}))))))}function j(t){let{reflection:e}=t;const n=(0,X.in)();return o.createElement(o.Fragment,null,o.createElement(E,{flags:e.flags}),o.createElement(k,{type:"keyword"},"type "),o.createElement(k,{type:"class-name"},e.name),e.typeParameters&&o.createElement(M,{type:y.Angle},e.typeParameters.map((t=>o.createElement(G,{key:t.id,reflection:n(t)}))))," = ",o.createElement(O,{type:e.type}))}function Y(t){let{reflection:e}=t;const n=(0,X.in)();return e.signatures?o.createElement(V,{reflection:e.signatures[0]}):e.children?o.createElement(M,{type:y.Curly},e.children.map((t=>o.createElement(Q,{key:t.id,reflection:n(t)})))):o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"unknown"))}function H(t){var e;let{reflection:n}=t;const p=(null==(e=n.signatures)?void 0:e[0])??n.getSignature??n.setSignature??n.indexSignature;return o.createElement(V,{reflection:p})}function Q(t){let{reflection:e}=t;const n=(0,o.useMemo)((()=>{switch(e.kind){case p.W.Project:case p.W.Module:case p.W.EnumMember:case p.W.Variable:case p.W.Function:break;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return q;case p.W.Constructor:return V;case p.W.Property:return U;case p.W.Method:return H;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:break;case p.W.TypeLiteral:return Y;case p.W.TypeParameter:return G;case p.W.Accessor:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return j;case p.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.id]);return o.createElement(n,{reflection:e})}function $(t){let{children:e}=t;const n=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!n.current)return;const t=n.current.closest("pre");if(t.scrollWidth>t.clientWidth){const e=Array.from(n.current.querySelectorAll(`.${a.elements}`)).sort(((t,e)=>function(t,e){return t>e?1:t<e?-1:0}(e.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&e.length>0;)e.shift().classList.add(a.wrap)}})),o.createElement(o.Fragment,null,e&&o.createElement("span",{ref:n,className:(0,c.Z)(a.line,"token-line")},e),o.createElement("br",null))}var K=n(9322),J=n(6879);function tt(t){let{parameters:e}=t;const n=(0,X.in)(),p=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,p.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(G,{reflection:t})),o.createElement(J.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{parameters:e}=t;const n=(0,X.in)(),p=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,p.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(B,{reflection:t})),o.createElement(J.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{signatures:e,flags:n,source:p}=t;const r=(0,X.in)(),s=(0,o.useMemo)((()=>e.map(r)),[e]),[c,i]=(0,o.useState)(s[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,s.map((t=>o.createElement(m,{link:null==p?void 0:p.url,key:t.id,highlight:e.length>1&&t.id===c.id,onClick:e.length>1?()=>i(t):void 0},o.createElement($,null,o.createElement(V,{reflection:t,flags:n})))))),o.createElement(K.Z,{comment:c.comment}),o.createElement(tt,{parameters:c.typeParameter}),o.createElement(et,{parameters:c.parameters}))}var ot=n(7708);function pt(t){let{width:e=24,height:n=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},p),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",st="filters_z1iC",ct="icon_ROIU";function it(){const t=(0,o.useRef)(null),[e,n]=(0,o.useState)(!1),[p,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const e=e=>{t.current&&!t.current.contains(e.target)&&n(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,c.Z)("dropdown dropdown--right margin-bottom--md",e&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),n(!e)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),n(!e))}},"Filters",o.createElement(pt,{className:ct})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,c.Z)("dropdown__link",p.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:p.private,onChange:t=>{r({...p,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&n(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,c.Z)("dropdown__link",p.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:p.inherited,onChange:t=>{r({...p,inherited:t.target.checked})}}),"Inherited members")))))}function at(t){let{children:e,kind:n}=t;return n===p.W.Class||n===p.W.Interface?o.createElement("div",{className:(0,c.Z)("row",rt)},o.createElement("div",{className:(0,c.Z)("col",st)},o.createElement(it,null)),o.createElement("div",{className:"col"},e)):o.createElement(o.Fragment,null,e)}var lt=n(3181),ut=n(3851),mt=n(4126),dt=n(2424),ht=n(2244),ft=n(4155);function kt(t){return function(t){var e;return(null==(e=o.Children.map(t,(t=>{if(!t||(0,o.isValidElement)(t)&&function(t){const{props:e}=t;return!!e&&"object"==typeof e&&"value"in e}(t))return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:e.filter(Boolean))??[]}(t).map((t=>{let{props:{value:e,label:n,attributes:o,default:p}}=t;return{value:e,label:n,attributes:o,default:p}}))}function yt(t){const{values:e,children:n}=t;return(0,o.useMemo)((()=>{const t=e??kt(n);return function(t){const e=(0,ht.l)(t,((t,e)=>t.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[e,n])}function wt(t){let{value:e,tabValues:n}=t;return n.some((t=>t.value===e))}function Dt(t){let{queryString:e=!1,groupId:n}=t;const p=(0,lt.k6)(),r=function(t){let{queryString:e=!1,groupId:n}=t;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,dt._X)(r),(0,o.useCallback)((t=>{if(!r)return;const e=new URLSearchParams(p.location.search);e.set(r,t),p.replace({...p.location,search:e.toString()})}),[r,p])]}function Mt(t){const{defaultValue:e,queryString:n=!1,groupId:p}=t,r=yt(t),[s,c]=(0,o.useState)((()=>function(t){let{defaultValue:e,tabValues:n}=t;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!wt({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const o=n.find((t=>t.default))??n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:e,tabValues:r}))),[i,a]=Dt({queryString:n,groupId:p}),[l,u]=function(t){let{groupId:e}=t;const n=function(t){return t?`docusaurus.tab.${t}`:null}(e),[p,r]=(0,ft.Nk)(n);return[p,(0,o.useCallback)((t=>{n&&r.set(t)}),[n,r])]}({groupId:p}),m=(()=>{const t=i??l;return wt({value:t,tabValues:r})?t:null})();(0,o.useLayoutEffect)((()=>{m&&c(m)}),[m]);return{selectedValue:s,selectValue:(0,o.useCallback)((t=>{if(!wt({value:t,tabValues:r}))throw new Error(`Can't select invalid tab value=${t}`);c(t),a(t),u(t)}),[a,u,r]),tabValues:r}}var Xt=n(9741);const _t="tabList_M0Dn",gt="tabItem_ysIP";function Tt(t){let{className:e,block:n,selectedValue:p,selectValue:r,tabValues:s}=t;const i=[],{blockElementScrollPositionUntilNextRender:a}=(0,mt.o5)(),u=t=>{const e=t.currentTarget,n=i.indexOf(e),o=s[n].value;o!==p&&(a(e),r(o))},m=t=>{var e;let n=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const e=i.indexOf(t.currentTarget)+1;n=i[e]??i[0];break}case"ArrowLeft":{const e=i.indexOf(t.currentTarget)-1;n=i[e]??i[i.length-1];break}}null==(e=n)||e.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":n},e)},s.map((t=>{let{value:e,label:n,attributes:r}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:p===e?0:-1,"aria-selected":p===e,key:e,ref:t=>i.push(t),onKeyDown:m,onClick:u},r,{className:(0,c.Z)("tabs__item",gt,null==r?void 0:r.className,{"tabs__item--active":p===e})}),n??e)})))}function Ct(t){let{lazy:e,children:n,selectedValue:p}=t;const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const t=r.find((t=>t.props.value===p));return t?(0,o.cloneElement)(t,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},r.map(((t,e)=>(0,o.cloneElement)(t,{key:e,hidden:t.props.value!==p}))))}function xt(t){const e=Mt(t);return o.createElement("div",{className:(0,c.Z)("tabs-container",_t)},o.createElement(Tt,(0,l.Z)({},t,e)),o.createElement(Ct,(0,l.Z)({},t,e)))}function vt(t){const e=(0,Xt.Z)();return o.createElement(xt,(0,l.Z)({key:String(e)},t))}const Lt="tabItem_OMyP";function Zt(t){let{children:e,hidden:n,className:p}=t;return o.createElement("div",{role:"tabpanel",className:(0,c.Z)(Lt,p),hidden:n},e)}function bt(t){let{group:e}=t;return"Constructors"===e.title&&0===e.external.length&&1===e.nested.length?o.createElement(Gt,{reflection:e.nested[0]}):o.createElement(o.Fragment,null,e.external.length>0&&o.createElement("ul",null,e.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(_,{type:t})))))),e.nested.length>0&&e.nested.map(((t,e)=>o.createElement(o.Fragment,{key:t.id},e>0&&o.createElement("hr",null),o.createElement(Gt,{reflection:t})))))}function Nt(t){let{group:e,project:n}=t;const p=(0,lt.TH)(),r=(0,X.RU)(n),s=p.hash.split("-")[0].slice(1),[c]=(0,ot.mN)(),i=(0,o.useMemo)((()=>(e.categories??[e]).map((t=>function(t,e,n){const o=[],p=[],r=[];for(const s of t.children){const t=e[s];t&&(0,ot.It)(n,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,r,c))).filter((t=>!!t))),[e,r,c]);return(0,o.useEffect)((()=>{if(1===i.length)return;const t=p.hash.split("-")[0].slice(1);for(const e of i)if(e.anchors.includes(t))return}),[p.hash,i]),0===i.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h2",id:e.title},e.title),i.length>1?o.createElement(vt,{groupId:e.title},i.map((t=>o.createElement(Zt,{default:t.anchors.includes(s),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(bt,{group:t}))))):o.createElement(bt,{group:i[0]}))}function zt(t){var e,n,p,r,s;let{reflection:c}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(e=c.sources)||null==(n=e[0])?void 0:n.url},o.createElement($,null,o.createElement(Q,{reflection:c})))),o.createElement(at,{kind:c.kind},o.createElement(K.Z,{comment:c.comment})),o.createElement(tt,{parameters:c.typeParameters}),(null==(p=c.implementedBy)?void 0:p.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,c.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(_,{type:t}))))))),(null==(r=c.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,c.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(_,{type:t}))))))),c.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:c.signatures})),null==(s=c.groups)?void 0:s.map((t=>o.createElement(Nt,{group:t,key:t.title,project:c.project}))))}function At(t){var e;let{reflection:n,headless:p}=t;const r=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!p&&(n.hasOwnPage?o.createElement("h1",null,n.name):o.createElement(ut.Z,{as:"h3",id:n.anchor},o.createElement("code",null,n.name))),o.createElement(nt,{signatures:r,flags:n.flags,source:null==(e=n.sources)?void 0:e[0]}),n.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(_,{type:n.inheritedFrom}))),n.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(_,{type:n.overwrites}))))}function Wt(t){var e,n;let{reflection:p,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(p.hasOwnPage?o.createElement("h1",null,p.name):o.createElement(ut.Z,{as:"h3",id:p.anchor},o.createElement("code",null,p.name))),o.createElement(h,null,o.createElement(m,{link:null==(e=p.sources)||null==(n=e[0])?void 0:n.url},o.createElement($,null,o.createElement(U,{reflection:p})))),o.createElement(K.Z,{comment:p.comment}),p.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(_,{type:p.inheritedFrom}))))}function It(t){var e,n,p;let{reflection:r}=t;const s=(0,X.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(e=r.sources)||null==(n=e[0])?void 0:n.url},o.createElement($,null,o.createElement(Q,{reflection:r})))),o.createElement(K.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:r.signatures})),null==(p=r.groups)?void 0:p.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>s[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Gt,{key:t.id,reflection:t})))))))}var Rt=n(8128);function Pt(t){var e;let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(Rt.Z,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),o.createElement(at,{kind:n.kind},o.createElement(K.Z,{comment:n.comment})),null==(e=n.groups)?void 0:e.map((t=>o.createElement(Nt,{group:t,key:t.title,project:n.project}))))}const St="cardContainer_ybwo",Ot="cardTitle_Ehd1",Et="cardDescription_b6wr";function Bt(t){let{reflection:e}=t;const n=(0,X.RU)(e.project),p=e.groups[0].children.map((t=>n[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,c.Z)("row")},p.map((t=>{var e;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(f.Z,{href:t.href,className:(0,c.Z)("card padding--lg",St)},o.createElement("h2",{className:(0,c.Z)("text--truncate",Ot)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,c.Z)("text--truncate",Et)},(null==(e=t.comment)?void 0:e.summaryText)??"\xa0")))}))))}function Gt(t){let{reflection:e,headless:n=!1}=t;const r=(0,o.useMemo)((()=>{switch(e.kind){case p.W.Project:return Bt;case p.W.Module:return Pt;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return zt;case p.W.Function:case p.W.Accessor:case p.W.Constructor:case p.W.Method:return At;case p.W.Variable:case p.W.Property:case p.W.EnumMember:return Wt;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:case p.W.TypeLiteral:case p.W.TypeParameter:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return It;case p.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.kind]);return o.createElement(r,{reflection:e,headless:n})}},7390:(t,e,n)=>{let o;n.d(e,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},8617:(t,e,n)=>{n.d(e,{Gr:()=>a,RU:()=>s,gs:()=>r,in:()=>c,rG:()=>i});var o=n(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:e,lookup:n,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:n,urlLookup:r}},e)}function s(t){const{lookup:e}=(0,o.useContext)(p);return e[t]}function c(){const{lookup:t}=(0,o.useContext)(p);return e=>{if("number"==typeof(null==e?void 0:e.project))return t[e.project][e.id]}}function i(){const{urlLookup:t,lookup:e}=(0,o.useContext)(p);return n=>{var o;const p=t[n];return p?(null==(o=e[p.projectId])?void 0:o[p.id])??null:null}}function a(t){if(t)return t.href}},68:(t,e,n)=>{n.d(e,{Ld:()=>c,Y0:()=>s,s2:()=>i});var o=n(2784),p=n(822);const r=o.createContext(null);function s(t){let{children:e}=t;const n=(0,p.p)(),s=(0,o.useMemo)((()=>function(t,e){const{plain:n}=t,o=Object.create(null),p=t.styles.reduce(((t,n)=>{const{languages:o,style:p}=n;return o&&!o.includes(e)||n.types.forEach((e=>{t[e]={...t[e],...p}})),t}),o);return p.root=n,p.plain={...n,backgroundColor:null},p}(n,"typescript")),[n]);return o.createElement(r.Provider,{value:s},e)}function c(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return{className:`token ${t}`,style:e[t]??e.plain}}function i(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return e[t]??e.plain}},7708:(t,e,n)=>{n.d(e,{It:()=>m,Wy:()=>l,mN:()=>u});var o=n(2784),p=n(1263),r=n(9741);const s="api-filters",c=p.Z.canUseDOM?localStorage.getItem(s):null,i=c?JSON.parse(c):{inherited:!0,private:!1},a=o.createContext([i,()=>{}]);function l(t){let{children:e}=t;const[n,p]=(0,o.useState)(i),c=(0,r.Z)();return o.createElement(a.Provider,{value:[n,t=>{c&&localStorage.setItem(s,JSON.stringify(t)),p(t)}]},e)}function u(){return(0,o.useContext)(a)}function m(t,e){var n,o;const p=(null==(n=e.flags)?void 0:n.isPrivate)||(null==(o=e.flags)?void 0:o.isProtected);if(!t.private&&p)return!1;const r=!!e.inheritedFrom;return!(!t.inherited&&r)}},5192:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>c,metadata:()=>a,toc:()=>u});var o=n(7896),p=(n(2784),n(876)),r=n(2072),s=n(2665);const c={sidebar_position:10,slug:"/transitions"},i="Transitions",a={unversionedId:"getting-started/transitions",id:"getting-started/transitions",title:"Transitions",description:"Transitions allow you to customize the way scenes transition from one into",source:"@site/docs/getting-started/transitions.mdx",sourceDirName:"getting-started",slug:"/transitions",permalink:"/docs/transitions",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/transitions.mdx",tags:[],version:"current",lastUpdatedBy:"Ashish Baravaliya",sidebarPosition:10,frontMatter:{sidebar_position:10,slug:"/transitions"},sidebar:"docs",previous:{title:"Time Events",permalink:"/docs/time-events"},next:{title:"Logging",permalink:"/docs/logging"}},l={},u=[{value:"Before we start",id:"before-we-start",level:2},{value:"Pre-made transitions",id:"pre-made-transitions",level:2},{value:"<code>slideTransition</code>",id:"slidetransition",level:3},{value:"<code>zoomInTransition</code>",id:"zoomintransition",level:3},{value:"<code>zoomOutTransition</code>",id:"zoomouttransition",level:3},{value:"<code>fadeTransition</code>",id:"fadetransition",level:3},{value:"Custom transitions",id:"custom-transitions",level:2},{value:"Animate when transitioning",id:"animate-when-transitioning",level:2}],m={toc:u};function d(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,o.Z)({},m,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"transitions"},"Transitions"),(0,p.kt)("p",null,"Transitions allow you to customize the way scenes transition from one into\nanother. A transition is an animation performed at the beginning of the scene.\nIt can modify the context of both the current and the previous scene."),(0,p.kt)("h2",{id:"before-we-start"},"Before we start"),(0,p.kt)("div",{className:"row"},(0,p.kt)("div",{className:"col"},(0,p.kt)("p",null,"Make sure your project contains at least two scenes. In this example, we've\nprepared ",(0,p.kt)("inlineCode",{parentName:"p"},"firstScene.tsx")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"secondScene.tsx"),", and configured our project to\ndisplay one after the other. We'll be setting up our transitions in the second\nscene."),(0,p.kt)("p",null,"Make sure to put something different in both scenes to easier see the\ntransitions.")),(0,p.kt)("div",{className:"col"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre"},"my-animation/\n\u2514\u2500 src/\n   \u251c\u2500 scenes/\n   \u2502  \u251c\u2500 firstScene.tsx\n   \u2502  \u2514\u2500 secondScene.tsx\n   \u2514\u2500 project.ts\n")))),(0,p.kt)("h2",{id:"pre-made-transitions"},"Pre-made transitions"),(0,p.kt)("p",null,"Motion Canvas comes with a set of common transitions in a form of easy-to-use\ngenerators. To use them, ",(0,p.kt)("inlineCode",{parentName:"p"},"yield*")," the transition generator at the beginning of\nthe new scene:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/scenes/secondScene.tsx"',title:'"src/scenes/secondScene.tsx"'},"export default makeScene2D(function* (view) {\n  // set up the scene:\n  view.add(/* your nodes here */);\n\n  // perform a slide transition to the left:\n  yield* slideTransition(Direction.Left);\n\n  // proceed with the animation\n  yield* waitFor(3);\n});\n")),(0,p.kt)(s.Z,{small:!0,name:"transitions",link:"transitions-second",mdxType:"AnimationPlayer"}),(0,p.kt)("admonition",{type:"caution"},(0,p.kt)("p",{parentName:"admonition"},"Make sure to add nodes to the view before yielding the transition generator.\nOtherwise, your scene will remain empty until the transition ends.")),(0,p.kt)("p",null,"All available transitions are listed below:"),(0,p.kt)("h3",{id:"slidetransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"slideTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#slideTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"zoomintransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"zoomInTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#zoomInTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"zoomouttransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"zoomOutTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#zoomOutTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"fadetransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"fadeTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#fadeTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"custom-transitions"},"Custom transitions"),(0,p.kt)("p",null,"You can use the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/transitions#useTransition"},(0,p.kt)("inlineCode",{parentName:"a"},"useTransition"))," function\nto implement custom transitions. It allows you to specify two callbacks that\nwill modify the contexts of the current and previous scene respectively. The\nvalue it returns is a callback that you need to call once you finish the\ntransition."),(0,p.kt)("p",null,"The transition template looks as follows:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// set up the transition\nconst endTransition = useTransition(\n  currentContext => {\n    // modify the context of the current scene\n  },\n  previousContext => {\n    // modify the context of the previous scene\n  },\n);\n\n// perform animations\n\n// finish the transition\nendTransition();\n")),(0,p.kt)("p",null,"Here's how you could implement a simple slide transition:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"export function* slideTransition(\n  direction: Direction = Direction.Top,\n  duration = 0.6,\n): ThreadGenerator {\n  const size = useScene().getSize();\n  const position = size.getOriginOffset(direction).scale(2);\n  const previousPosition = Vector2.createSignal();\n  const currentPosition = Vector2.createSignal(position);\n\n  // set up the transition\n  const endTransition = useTransition(\n    // modify the context of the current scene\n    ctx => ctx.translate(currentPosition.x(), currentPosition.y()),\n    // modify the context of the previous scene\n    ctx => ctx.translate(previousPosition.x(), previousPosition.y()),\n  );\n\n  // perform animations\n  yield* all(\n    previousPosition(position.scale(-1), duration),\n    currentPosition(Vector2.zero, duration),\n  );\n\n  // finish the transition\n  endTransition();\n}\n")),(0,p.kt)("h2",{id:"animate-when-transitioning"},"Animate when transitioning"),(0,p.kt)("p",null,"By default, Motion Canvas will transition to the next scene once the generator\nof the current scene has reached the end. In this case, the scene will freeze\nfor the duration of the transition. You can use the\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#finishScene"},(0,p.kt)("inlineCode",{parentName:"a"},"finishScene"))," function to trigger the transition\nearly, allowing the animation to continue while transitioning:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"export default makeScene2D(function* (view) {\n  yield* animationOne();\n  // trigger the transition early:\n  finishScene();\n  // continue animating:\n  yield* animationTwo();\n});\n")))}d.isMDXComponent=!0}}]);