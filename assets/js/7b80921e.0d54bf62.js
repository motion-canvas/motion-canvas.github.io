"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[9869],{876:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>g});var a=t(2784);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=a.createContext({}),c=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(o.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,l=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(t),m=i,g=d["".concat(o,".").concat(m)]||d[m]||u[m]||l;return t?a.createElement(g,r(r({ref:n},p),{},{components:t})):a.createElement(g,r({ref:n},p))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=t.length,r=new Array(l);r[0]=m;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[d]="string"==typeof e?e:i,r[1]=s;for(var c=2;c<l;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},2665:(e,n,t)=>{t.d(n,{Z:()=>h});var a=t(2784);const i="container_lQCo",l="small_As57",r="banner_A4QS",s="player_tELG",o="link_BTzN",c="icon_wSGd";var p=t(7896);function d(e){let{width:n=24,height:t=24,...i}=e;return a.createElement("svg",(0,p.Z)({viewBox:"0 0 24 24",width:n,height:t,"aria-hidden":!0},i),a.createElement("path",{d:"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z",fill:"currentColor"}))}var u=t(9817),m=t(6277);function g(e){let{name:n}=e;const t=`https://github.com/motion-canvas/motion-canvas/blob/main/packages/examples/src/scenes/${n}.tsx`;return a.createElement(u.Z,{to:t,className:(0,m.Z)("padding--sm",o)},a.createElement("span",null,"View source code"),a.createElement(d,{className:c}))}function h(e){let{name:n,banner:t,small:o,link:c}=e;return a.createElement("div",{className:(0,m.Z)(i,t&&r,o&&l)},a.createElement("motion-canvas-player",{class:s,src:`/examples/${n}.js`,auto:t}),a.createElement(g,{name:c||n}))}t(1263).Z.canUseDOM&&t.e(7067).then(t.bind(t,7067))},9364:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var a=t(7896),i=(t(2784),t(876)),l=t(2665),r=t(8128);const s={sidebar_position:6,slug:"/signals"},o="Signals",c={unversionedId:"getting-started/signals",id:"getting-started/signals",title:"Signals",description:"Signals represent a value that may change over time. They can be used to define",source:"@site/docs/getting-started/signals.mdx",sourceDirName:"getting-started",slug:"/signals",permalink:"/docs/signals",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/signals.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",sidebarPosition:6,frontMatter:{sidebar_position:6,slug:"/signals"},sidebar:"docs",previous:{title:"Layouts",permalink:"/docs/layouts"},next:{title:"References",permalink:"/docs/references"}},p={},d=[{value:"Overview",id:"overview",level:2},{value:"Explanation",id:"explanation",level:2},{value:"Laziness",id:"laziness",level:3},{value:"Caching",id:"caching",level:3},{value:"Dependency tracking",id:"dependency-tracking",level:3},{value:"<code>DEFAULT</code> values",id:"default-values",level:2},{value:"Complex example",id:"complex-example",level:2}],u={toc:d};function m(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"signals"},"Signals"),(0,i.kt)("p",null,"Signals represent a value that may change over time. They can be used to define\ndependencies between the state of the animation. This way, when a value changes,\nall other values that depend on it get automatically updated."),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Signals for primitive types are created using the\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/signals#createSignal"},(0,i.kt)("inlineCode",{parentName:"a"},"createSignal()"))," function, where the first\nargument specifies their initial value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {createSignal} from '@motion-canvas/core';\n\nconst signal = createSignal(0);\n")),(0,i.kt)("p",null,"Additionally, each complex type has a static ",(0,i.kt)("inlineCode",{parentName:"p"},"createSignal()")," method that can be\nused to create a signal for said type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {Vector2} from '@motion-canvas/core';\n\nconst signal = Vector2.createSignal(Vector2.up);\n")),(0,i.kt)("p",null,"Properties of every node are also represented by signals:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const circle = <Circle />;\n\nconst signal = circle.fill;\n")),(0,i.kt)("p",null,"Once created, signals can be invoked to perform one of the three possible\nactions (The action is chosen based on the number of arguments):"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"retrieve the value:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const value = signal();\n"))),(0,i.kt)("li",{parentName:"ol"},"update the value:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"signal(3);\n"))),(0,i.kt)("li",{parentName:"ol"},"create a ",(0,i.kt)("a",{parentName:"li",href:"/docs/tweening"},"tween")," for the value:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield * signal(2, 0.3);\n")))),(0,i.kt)("p",null,"Instead of the actual value, a signal can be provided with a function that\ncomputes the value dynamically. Consider the following example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const radius = createSignal(1);\nconst area = createSignal(() => Math.PI * radius() * radius());\n\nconsole.log(area()); // 3.141592653589793\nradius(2);\nconsole.log(area()); // 12.566370614359172\n")),(0,i.kt)("p",null,"Here, the ",(0,i.kt)("inlineCode",{parentName:"p"},"area")," signal uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"radius")," signal to compute its value."),(0,i.kt)("h2",{id:"explanation"},"Explanation"),(0,i.kt)("p",null,"To better understand how signals work, let's modify the example from before to\nsee when exactly the area is calculated:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const radius = createSignal(1);\nconst area = createSignal(() => {\n  console.log('area recalculated!');\n  return Math.PI * radius() * radius();\n});\n\narea(); // area recalculated!\narea();\nradius(2);\narea(); // area recalculated!\nradius(3);\nradius(4);\narea(); // area recalculated!\n")),(0,i.kt)("p",null,"This demonstrates three important aspects of signals:"),(0,i.kt)("h3",{id:"laziness"},"Laziness"),(0,i.kt)("p",null,"Signals are only calculated when their value is requested. The first\n",(0,i.kt)("inlineCode",{parentName:"p"},'"area recalculated!"')," message is logged to console only after ",(0,i.kt)("inlineCode",{parentName:"p"},"area()")," is\ncalled."),(0,i.kt)("h3",{id:"caching"},"Caching"),(0,i.kt)("p",null,"Once the signal is calculated, its value is saved and then returned during\nsubsequent calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"area()"),". That's why nothing is logged to the console during\nthe second call. This aspect of signals makes them perfect for caching\ncomputationally heavy operations. In fact, Motion Canvas uses signals internally\nto cache things such as matrices."),(0,i.kt)("h3",{id:"dependency-tracking"},"Dependency tracking"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"area")," signal keeps track of other signals it depends on. When we change the\n",(0,i.kt)("inlineCode",{parentName:"p"},"radius")," signal, the ",(0,i.kt)("inlineCode",{parentName:"p"},"area")," signal is notified about that. But it doesn't get\nrecalculated immediately - laziness is still at play. We can modify the radius\nhowever many times we want, but the ",(0,i.kt)("inlineCode",{parentName:"p"},"area")," will be recalculated only once its\nvalue is requested again by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"area()"),"."),(0,i.kt)("h2",{id:"default-values"},(0,i.kt)("inlineCode",{parentName:"h2"},"DEFAULT")," values"),(0,i.kt)("p",null,"Signals keep track of the initial values specified during creation. At any time,\nwe can reset a signal to its initial value by passing the\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/signals#DEFAULT"},(0,i.kt)("inlineCode",{parentName:"a"},"DEFAULT"))," symbol to it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {DEFAULT, createSignal} from '@motion-canvas/core';\n\nconst signal = createSignal(3); // <- initial value is 3\nsignal(2);\nsignal(); // <- value is now 2\nsignal(DEFAULT);\nsignal(); // <- value is reset back to 3\n")),(0,i.kt)("p",null,"We can also use the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/signals#DEFAULT"},(0,i.kt)("inlineCode",{parentName:"a"},"DEFAULT"))," symbol for\n",(0,i.kt)("a",{parentName:"p",href:"/docs/tweening"},"tweening"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield * signal(DEFAULT, 2);\n")),(0,i.kt)("p",null,"Resetting to the default value is especially useful with node properties. In the\nexample below, we set the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#lineHeight"},(0,i.kt)("inlineCode",{parentName:"a"},"lineHeight")),"\nof the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Txt"},(0,i.kt)("inlineCode",{parentName:"a"},"Txt"))," node to ",(0,i.kt)("inlineCode",{parentName:"p"},"150%"),". This will override its\ndefault value, which would be simply inherited from its parent:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const text = createRef<Txt>();\nview.add(\n  <Txt lineHeight={'150%'} ref={text}>\n    Hello world!\n  </Txt>,\n);\n")),(0,i.kt)("p",null,"If we want to reset the ",(0,i.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#lineHeight"},(0,i.kt)("inlineCode",{parentName:"a"},"lineHeight")),"\nback to the default, inherited value, we can do so with\n",(0,i.kt)("a",{parentName:"p",href:"/api/core/signals#DEFAULT"},(0,i.kt)("inlineCode",{parentName:"a"},"DEFAULT")),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"text().lineHeight(DEFAULT);\n")),(0,i.kt)("h2",{id:"complex-example"},"Complex example"),(0,i.kt)("p",null,"We can use the fact that properties of nodes are represented by signals to\nconstruct scenes that automatically update when the data changes. Following the\nprevious example, let's create a visualisation for the area of the circle:"),(0,i.kt)(l.Z,{small:!0,name:"node-signal",mdxType:"AnimationPlayer"}),(0,i.kt)("p",null,"Below you'll find the code used to create this animation. We highlighted all the\nplaces where signals are used:"),(0,i.kt)(r.Z,{language:"tsx",mdxType:"CodeBlock"},"import {makeScene2D} from '@motion-canvas/2d/lib/scenes';\nimport {Circle, Txt, Line} from '@motion-canvas/2d/lib/components';\nimport {createSignal} from '@motion-canvas/core/lib/signals';\nimport {Vector2} from '@motion-canvas/core/lib/types';\nimport {waitFor} from '@motion-canvas/core/lib/flow';\n\nexport default makeScene2D(function* (view) {\n  // highlight-start\n  const radius = createSignal(3);\n  const area = createSignal(() => Math.PI * radius() * radius());\n  // highlight-end\n\n  const scale = 100;\n  const textStyle = {\n    fontWeight: 700,\n    fontSize: 56,\n    offsetY: -1,\n    padding: 20,\n    cache: true,\n  };\n\n  view.add(\n    <>\n      <Circle\n        // highlight-start\n        width={() => radius() * scale * 2}\n        height={() => radius() * scale * 2}\n        // highlight-end\n        fill={'#e13238'}\n      />\n      <Line\n        points={[\n          Vector2.zero,\n          // highlight-next-line\n          () => Vector2.right.scale(radius() * scale),\n        ]}\n        lineDash={[20, 20]}\n        startArrow\n        endArrow\n        endOffset={8}\n        lineWidth={8}\n        stroke={'#242424'}\n      />\n      <Txt\n        // highlight-start\n        text={() => `r = ${radius().toFixed(2)}`}\n        x={() => (radius() * scale) / 2}\n        // highlight-end\n        fill={'#242424'}\n        {...textStyle}\n      />\n      <Txt\n        // highlight-start\n        text={() => `A = ${area().toFixed(2)}`}\n        y={() => radius() * scale}\n        // highlight-end\n        fill={'#e13238'}\n        {...textStyle}\n      />\n    </>,\n  );\n\n  yield* radius(4, 2).to(3, 2);\n  yield* waitFor(1);\n});\n"),(0,i.kt)("p",null,"With this setup, all we need to do is animate the ",(0,i.kt)("inlineCode",{parentName:"p"},"radius")," signal, and the rest\nof the scene will adjust accordingly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield * radius(4, 2).to(3, 2);\n")))}m.isMDXComponent=!0}}]);