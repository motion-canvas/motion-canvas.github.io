"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[2474],{876:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>f});var a=t(2784);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),l=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=l(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=l(t),m=r,f=u["".concat(s,".").concat(m)]||u[m]||d[m]||o;return t?a.createElement(f,i(i({ref:n},p),{},{components:t})):a.createElement(f,i({ref:n},p))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c[u]="string"==typeof e?e:r,i[1]=c;for(var l=2;l<o;l++)i[l]=t[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},390:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var a=t(7896),r=(t(2784),t(876));const o={slug:"/spawners"},i="Spawners",c={unversionedId:"advanced/spawners",id:"advanced/spawners",title:"Spawners",description:"Sometimes we want the children of a given node to be reactive. In other words,",source:"@site/docs/advanced/spawners.mdx",sourceDirName:"advanced",slug:"/spawners",permalink:"/docs/spawners",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/advanced/spawners.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",frontMatter:{slug:"/spawners"},sidebar:"docs",previous:{title:"Random values",permalink:"/docs/random-values"}},s={},l=[],p={toc:l};function u(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"spawners"},"Spawners"),(0,r.kt)("p",null,"Sometimes we want the children of a given node to be reactive. In other words,\nwe want them to change according to some external state. Consider the following\nexample:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const count = createSignal(10);\n\nview.add(\n  <Layout layout>\n    {range(count()).map(() => (\n      <Circle width={32} height={32} fill={'white'} />\n    ))}\n  </Layout>,\n);\n")),(0,r.kt)("p",null,"We first create the ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," signal and then use its value to generate N number\nof circles."),(0,r.kt)("p",null,"This example is not reactive - changing the ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," signal won't change the\nnumber of circles inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"Layout")," node. We can fix that with the use of the\n",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#spawner"},(0,r.kt)("inlineCode",{parentName:"a"},"spawner"))," property:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const count = createSignal(10);\n\nview.add(\n  <Layout\n    layout\n    spawner={() =>\n      range(count()).map(() => <Circle width={32} height={32} fill={'white'} />)\n    }\n  />,\n);\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"spawner")," accepts a function that returns an array of nodes. These nodes will\nbecome the new children of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Layout")," node. We can now animate our ",(0,r.kt)("inlineCode",{parentName:"p"},"count"),"\nsignal to check if it works:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield * count(5, 2);\n")),(0,r.kt)("p",null,"It's important to remember that (like most Node properties) ",(0,r.kt)("inlineCode",{parentName:"p"},"spawner")," is a\nsignal. The function we pass to it will be invoked each time any of its\ndependencies change. If the spawner happens to generate a large number of nodes\nand its dependencies change every frame, it may drastically reduce the\nplayback's performance. To counteract this, we can use an object pool that will\nlet us reuse the same nodes instead of recreating them each time:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const count = createSignal(10);\n\nconst pool = range(64).map(i => (\n  <Circle x={i * 32} width={32} height={32} fill={'lightseagreen'} />\n));\n\nview.add(<Layout layout spawner={() => pool.slice(0, count())} />);\n")))}u.isMDXComponent=!0}}]);