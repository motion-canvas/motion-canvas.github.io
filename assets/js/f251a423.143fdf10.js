"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[9430],{8046:(t,e,n)=>{n.d(e,{Z:()=>r});var o=n(7896),p=n(2784);function r(t){let{width:e=24,height:n=24,...r}=t;return p.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0,fill:"currentColor"},r),p.createElement("path",{d:"M19.8,18.4L14,10.67V6.5l1.35-1.69C15.61,4.48,15.38,4,14.96,4H9.04C8.62,4,8.39,4.48,8.65,4.81L10,6.5v4.17L4.2,18.4 C3.71,19.06,4.18,20,5,20h14C19.82,20,20.29,19.06,19.8,18.4z"}))}},2072:(t,e,n)=>{n.d(e,{Z:()=>s});var o=n(2830),p=n(8617),r=n(2784);function s(t){let{url:e}=t;const n=(0,p.rG)()(e);return r.createElement(o.Z,{reflection:n,headless:!0})}},5302:(t,e,n)=>{n.d(e,{Z:()=>W3p});var o={};n.r(o),n.d(o,{content_0_0:()=>i,content_0_10:()=>C,content_0_100:()=>Ke,content_0_1000:()=>tv,content_0_1002:()=>ov,content_0_1004:()=>sv,content_0_1006:()=>iv,content_0_1008:()=>mv,content_0_1010:()=>fv,content_0_1012:()=>Dv,content_0_1014:()=>_v,content_0_1016:()=>Cv,content_0_1018:()=>vv,content_0_102:()=>tn,content_0_1020:()=>bv,content_0_1022:()=>Av,content_0_1024:()=>Rv,content_0_1026:()=>Bv,content_0_1028:()=>Ov,content_0_1030:()=>Vv,content_0_1032:()=>Yv,content_0_1034:()=>Kv,content_0_1036:()=>tL,content_0_1038:()=>oL,content_0_104:()=>on,content_0_1040:()=>sL,content_0_1042:()=>iL,content_0_1044:()=>mL,content_0_1046:()=>fL,content_0_1048:()=>DL,content_0_1050:()=>_L,content_0_1052:()=>CL,content_0_1054:()=>vL,content_0_1056:()=>bL,content_0_1058:()=>AL,content_0_106:()=>sn,content_0_1060:()=>RL,content_0_1062:()=>BL,content_0_1064:()=>OL,content_0_1066:()=>VL,content_0_1068:()=>YL,content_0_1070:()=>KL,content_0_1072:()=>tZ,content_0_1074:()=>oZ,content_0_1076:()=>sZ,content_0_1078:()=>iZ,content_0_108:()=>ln,content_0_1080:()=>mZ,content_0_1082:()=>fZ,content_0_1084:()=>DZ,content_0_1086:()=>_Z,content_0_1088:()=>CZ,content_0_1090:()=>vZ,content_0_1092:()=>bZ,content_0_1094:()=>AZ,content_0_1096:()=>RZ,content_0_1098:()=>BZ,content_0_110:()=>dn,content_0_1100:()=>OZ,content_0_1102:()=>VZ,content_0_1104:()=>YZ,content_0_1106:()=>KZ,content_0_1108:()=>tb,content_0_1110:()=>ob,content_0_1112:()=>sb,content_0_1114:()=>ib,content_0_1116:()=>mb,content_0_1118:()=>fb,content_0_112:()=>kn,content_0_1120:()=>Db,content_0_1122:()=>_b,content_0_1124:()=>Cb,content_0_1126:()=>vb,content_0_1128:()=>bb,content_0_1130:()=>Ab,content_0_1132:()=>Rb,content_0_1134:()=>Bb,content_0_1136:()=>Ob,content_0_1138:()=>Vb,content_0_114:()=>Mn,content_0_1140:()=>Yb,content_0_1142:()=>Kb,content_0_1144:()=>tN,content_0_1146:()=>oN,content_0_1148:()=>sN,content_0_1150:()=>iN,content_0_1152:()=>mN,content_0_1154:()=>fN,content_0_1156:()=>DN,content_0_1158:()=>_N,content_0_116:()=>wn,content_0_1160:()=>CN,content_0_1162:()=>vN,content_0_1164:()=>bN,content_0_1166:()=>AN,content_0_1168:()=>RN,content_0_1170:()=>BN,content_0_1172:()=>ON,content_0_1174:()=>VN,content_0_1176:()=>YN,content_0_1178:()=>KN,content_0_118:()=>xn,content_0_1180:()=>tz,content_0_1182:()=>oz,content_0_1184:()=>sz,content_0_1186:()=>iz,content_0_1188:()=>mz,content_0_1190:()=>fz,content_0_1192:()=>Dz,content_0_1194:()=>_z,content_0_1196:()=>Cz,content_0_1198:()=>vz,content_0_12:()=>v,content_0_120:()=>Ln,content_0_1200:()=>bz,content_0_1202:()=>Az,content_0_1204:()=>Rz,content_0_1206:()=>Bz,content_0_1208:()=>Oz,content_0_1210:()=>Vz,content_0_1212:()=>Yz,content_0_1214:()=>Kz,content_0_1216:()=>tA,content_0_1218:()=>oA,content_0_122:()=>Nn,content_0_1220:()=>sA,content_0_1222:()=>iA,content_0_1224:()=>mA,content_0_1226:()=>fA,content_0_1228:()=>DA,content_0_1230:()=>_A,content_0_1232:()=>CA,content_0_1234:()=>vA,content_0_1236:()=>bA,content_0_1238:()=>AA,content_0_124:()=>Pn,content_0_1240:()=>RA,content_0_1242:()=>BA,content_0_1244:()=>OA,content_0_1246:()=>VA,content_0_1248:()=>YA,content_0_1250:()=>KA,content_0_1252:()=>tP,content_0_1254:()=>oP,content_0_1256:()=>sP,content_0_1258:()=>iP,content_0_126:()=>In,content_0_1260:()=>mP,content_0_1262:()=>fP,content_0_1264:()=>DP,content_0_1266:()=>_P,content_0_1268:()=>CP,content_0_1270:()=>vP,content_0_1272:()=>bP,content_0_1274:()=>AP,content_0_1276:()=>RP,content_0_1278:()=>BP,content_0_128:()=>Gn,content_0_1280:()=>OP,content_0_1282:()=>VP,content_0_1284:()=>YP,content_0_1286:()=>KP,content_0_1288:()=>tW,content_0_1290:()=>oW,content_0_1292:()=>sW,content_0_1294:()=>iW,content_0_1296:()=>mW,content_0_1298:()=>fW,content_0_130:()=>Fn,content_0_1300:()=>DW,content_0_1302:()=>_W,content_0_1304:()=>CW,content_0_1306:()=>vW,content_0_1308:()=>bW,content_0_1310:()=>AW,content_0_1312:()=>RW,content_0_1314:()=>BW,content_0_1316:()=>OW,content_0_1318:()=>VW,content_0_132:()=>qn,content_0_1320:()=>YW,content_0_1322:()=>KW,content_0_1324:()=>tR,content_0_1326:()=>oR,content_0_1328:()=>sR,content_0_1330:()=>iR,content_0_1332:()=>mR,content_0_1334:()=>fR,content_0_1336:()=>DR,content_0_1338:()=>_R,content_0_134:()=>Qn,content_0_1340:()=>CR,content_0_1342:()=>vR,content_0_1344:()=>bR,content_0_1346:()=>AR,content_0_1348:()=>RR,content_0_1350:()=>BR,content_0_1352:()=>OR,content_0_1354:()=>VR,content_0_1356:()=>YR,content_0_1358:()=>KR,content_0_136:()=>$n,content_0_1360:()=>tI,content_0_1362:()=>oI,content_0_1364:()=>sI,content_0_1366:()=>iI,content_0_1368:()=>mI,content_0_1370:()=>fI,content_0_1372:()=>DI,content_0_1374:()=>_I,content_0_1376:()=>CI,content_0_1378:()=>vI,content_0_138:()=>eo,content_0_1380:()=>bI,content_0_1382:()=>AI,content_0_1384:()=>RI,content_0_1386:()=>BI,content_0_1388:()=>OI,content_0_1390:()=>VI,content_0_1392:()=>YI,content_0_1394:()=>KI,content_0_1396:()=>tS,content_0_1398:()=>oS,content_0_14:()=>b,content_0_140:()=>po,content_0_1400:()=>sS,content_0_1402:()=>iS,content_0_1404:()=>mS,content_0_1406:()=>fS,content_0_1408:()=>DS,content_0_1410:()=>_S,content_0_1412:()=>CS,content_0_1414:()=>vS,content_0_1416:()=>bS,content_0_1418:()=>AS,content_0_142:()=>co,content_0_1420:()=>RS,content_0_1422:()=>BS,content_0_1424:()=>OS,content_0_1426:()=>VS,content_0_1428:()=>YS,content_0_1430:()=>KS,content_0_1432:()=>tB,content_0_1434:()=>oB,content_0_1436:()=>sB,content_0_1438:()=>iB,content_0_144:()=>lo,content_0_1440:()=>mB,content_0_1442:()=>fB,content_0_1444:()=>DB,content_0_1446:()=>_B,content_0_1448:()=>CB,content_0_1450:()=>vB,content_0_1452:()=>bB,content_0_1454:()=>AB,content_0_1456:()=>RB,content_0_1458:()=>BB,content_0_146:()=>ho,content_0_1460:()=>OB,content_0_1462:()=>VB,content_0_1464:()=>YB,content_0_1466:()=>KB,content_0_1468:()=>tG,content_0_1470:()=>oG,content_0_1472:()=>sG,content_0_1474:()=>iG,content_0_1476:()=>mG,content_0_1478:()=>fG,content_0_148:()=>yo,content_0_1480:()=>DG,content_0_1482:()=>_G,content_0_1484:()=>CG,content_0_1486:()=>vG,content_0_1488:()=>bG,content_0_1490:()=>AG,content_0_1492:()=>RG,content_0_1494:()=>BG,content_0_1496:()=>OG,content_0_1498:()=>VG,content_0_150:()=>Xo,content_0_1500:()=>YG,content_0_1502:()=>KG,content_0_1504:()=>tE,content_0_1506:()=>oE,content_0_1508:()=>sE,content_0_1510:()=>iE,content_0_1512:()=>mE,content_0_1514:()=>fE,content_0_1516:()=>DE,content_0_1518:()=>_E,content_0_152:()=>To,content_0_1520:()=>CE,content_0_1522:()=>vE,content_0_1524:()=>bE,content_0_1526:()=>AE,content_0_1528:()=>RE,content_0_1530:()=>BE,content_0_1532:()=>OE,content_0_1534:()=>VE,content_0_1536:()=>YE,content_0_1538:()=>KE,content_0_154:()=>go,content_0_1540:()=>tO,content_0_1542:()=>oO,content_0_1544:()=>sO,content_0_1546:()=>iO,content_0_1548:()=>mO,content_0_1550:()=>fO,content_0_1552:()=>DO,content_0_1554:()=>_O,content_0_1556:()=>CO,content_0_1558:()=>vO,content_0_156:()=>Zo,content_0_1560:()=>bO,content_0_1562:()=>AO,content_0_1564:()=>RO,content_0_1566:()=>BO,content_0_1568:()=>OO,content_0_1570:()=>VO,content_0_1572:()=>YO,content_0_1574:()=>KO,content_0_1576:()=>tF,content_0_1578:()=>oF,content_0_158:()=>zo,content_0_1580:()=>sF,content_0_1582:()=>iF,content_0_1584:()=>mF,content_0_1586:()=>fF,content_0_1588:()=>DF,content_0_1590:()=>_F,content_0_1592:()=>CF,content_0_1594:()=>vF,content_0_1596:()=>bF,content_0_1598:()=>AF,content_0_16:()=>A,content_0_160:()=>Wo,content_0_1600:()=>RF,content_0_1602:()=>BF,content_0_1604:()=>OF,content_0_1606:()=>VF,content_0_1608:()=>YF,content_0_1610:()=>KF,content_0_1612:()=>tU,content_0_1614:()=>oU,content_0_1616:()=>sU,content_0_1618:()=>iU,content_0_162:()=>So,content_0_1620:()=>mU,content_0_1622:()=>fU,content_0_1624:()=>DU,content_0_1626:()=>_U,content_0_1628:()=>CU,content_0_1630:()=>vU,content_0_1632:()=>bU,content_0_1634:()=>AU,content_0_1636:()=>RU,content_0_1638:()=>BU,content_0_164:()=>Eo,content_0_1640:()=>OU,content_0_1642:()=>VU,content_0_1644:()=>YU,content_0_1646:()=>KU,content_0_1648:()=>tV,content_0_1650:()=>oV,content_0_1652:()=>sV,content_0_1654:()=>iV,content_0_1656:()=>mV,content_0_1658:()=>fV,content_0_166:()=>Uo,content_0_1660:()=>DV,content_0_1662:()=>_V,content_0_1664:()=>CV,content_0_1666:()=>vV,content_0_1668:()=>bV,content_0_1670:()=>AV,content_0_1672:()=>RV,content_0_1674:()=>BV,content_0_1676:()=>OV,content_0_1678:()=>VV,content_0_168:()=>jo,content_0_1680:()=>YV,content_0_1682:()=>KV,content_0_1684:()=>tq,content_0_1686:()=>oq,content_0_1688:()=>sq,content_0_1690:()=>iq,content_0_1692:()=>mq,content_0_1694:()=>fq,content_0_1696:()=>Dq,content_0_1698:()=>_q,content_0_170:()=>Ho,content_0_1700:()=>Cq,content_0_1702:()=>vq,content_0_1704:()=>bq,content_0_1706:()=>Aq,content_0_1708:()=>Rq,content_0_1710:()=>Bq,content_0_1712:()=>Oq,content_0_1714:()=>Vq,content_0_1716:()=>Yq,content_0_1718:()=>Kq,content_0_172:()=>Jo,content_0_1720:()=>tj,content_0_1722:()=>oj,content_0_1724:()=>sj,content_0_1726:()=>ij,content_0_1728:()=>mj,content_0_1730:()=>fj,content_0_1732:()=>Dj,content_0_1734:()=>_j,content_0_1736:()=>Cj,content_0_1738:()=>vj,content_0_174:()=>np,content_0_1740:()=>bj,content_0_1742:()=>Aj,content_0_1744:()=>Rj,content_0_1746:()=>Bj,content_0_1748:()=>Oj,content_0_1750:()=>Vj,content_0_1752:()=>Yj,content_0_1754:()=>Kj,content_0_1756:()=>tY,content_0_1758:()=>oY,content_0_176:()=>rp,content_0_1760:()=>sY,content_0_1762:()=>iY,content_0_1764:()=>mY,content_0_1766:()=>fY,content_0_1768:()=>DY,content_0_1770:()=>_Y,content_0_1772:()=>CY,content_0_1774:()=>vY,content_0_1776:()=>bY,content_0_1778:()=>AY,content_0_178:()=>ap,content_0_1780:()=>RY,content_0_1782:()=>BY,content_0_1784:()=>OY,content_0_1786:()=>VY,content_0_1788:()=>YY,content_0_1790:()=>KY,content_0_1792:()=>tQ,content_0_1794:()=>oQ,content_0_1796:()=>sQ,content_0_1798:()=>iQ,content_0_18:()=>R,content_0_180:()=>up,content_0_1800:()=>mQ,content_0_1802:()=>fQ,content_0_1804:()=>DQ,content_0_1806:()=>_Q,content_0_1808:()=>CQ,content_0_1810:()=>vQ,content_0_1812:()=>bQ,content_0_1814:()=>AQ,content_0_1816:()=>RQ,content_0_1818:()=>BQ,content_0_182:()=>hp,content_0_1820:()=>OQ,content_0_1822:()=>VQ,content_0_1824:()=>YQ,content_0_1826:()=>KQ,content_0_1828:()=>tH,content_0_1830:()=>oH,content_0_1832:()=>sH,content_0_1834:()=>iH,content_0_1836:()=>mH,content_0_1838:()=>fH,content_0_184:()=>yp,content_0_1840:()=>DH,content_0_1842:()=>_H,content_0_186:()=>Xp,content_0_188:()=>Tp,content_0_190:()=>gp,content_0_192:()=>Zp,content_0_194:()=>zp,content_0_196:()=>Wp,content_0_198:()=>Sp,content_0_2:()=>m,content_0_20:()=>B,content_0_200:()=>Ep,content_0_202:()=>Up,content_0_204:()=>jp,content_0_206:()=>Hp,content_0_208:()=>Jp,content_0_210:()=>nr,content_0_212:()=>rr,content_0_214:()=>ar,content_0_216:()=>ur,content_0_218:()=>hr,content_0_22:()=>O,content_0_220:()=>yr,content_0_222:()=>Xr,content_0_224:()=>Tr,content_0_226:()=>gr,content_0_228:()=>Zr,content_0_230:()=>zr,content_0_232:()=>Wr,content_0_234:()=>Sr,content_0_236:()=>Er,content_0_238:()=>Ur,content_0_24:()=>V,content_0_240:()=>jr,content_0_242:()=>Hr,content_0_244:()=>Jr,content_0_246:()=>ns,content_0_248:()=>rs,content_0_250:()=>as,content_0_252:()=>us,content_0_254:()=>hs,content_0_256:()=>ys,content_0_258:()=>Xs,content_0_26:()=>Y,content_0_260:()=>Ts,content_0_262:()=>gs,content_0_264:()=>Zs,content_0_266:()=>zs,content_0_268:()=>Ws,content_0_270:()=>Ss,content_0_272:()=>Es,content_0_274:()=>Us,content_0_276:()=>js,content_0_278:()=>Hs,content_0_28:()=>K,content_0_280:()=>Js,content_0_282:()=>nc,content_0_284:()=>rc,content_0_286:()=>ac,content_0_288:()=>uc,content_0_290:()=>hc,content_0_292:()=>yc,content_0_294:()=>Xc,content_0_296:()=>Tc,content_0_298:()=>gc,content_0_30:()=>tt,content_0_300:()=>Zc,content_0_302:()=>zc,content_0_304:()=>Wc,content_0_306:()=>Sc,content_0_308:()=>Ec,content_0_310:()=>Uc,content_0_312:()=>jc,content_0_314:()=>Hc,content_0_316:()=>Jc,content_0_318:()=>na,content_0_32:()=>ot,content_0_320:()=>ra,content_0_322:()=>aa,content_0_324:()=>ua,content_0_326:()=>ha,content_0_328:()=>ya,content_0_330:()=>Xa,content_0_332:()=>Ta,content_0_334:()=>ga,content_0_336:()=>Za,content_0_338:()=>za,content_0_34:()=>st,content_0_340:()=>Wa,content_0_342:()=>Sa,content_0_344:()=>Ea,content_0_346:()=>Ua,content_0_348:()=>ja,content_0_350:()=>Ha,content_0_352:()=>Ja,content_0_354:()=>ni,content_0_356:()=>ri,content_0_358:()=>ai,content_0_36:()=>it,content_0_360:()=>ui,content_0_362:()=>hi,content_0_364:()=>yi,content_0_366:()=>Xi,content_0_368:()=>Ti,content_0_370:()=>gi,content_0_372:()=>Zi,content_0_374:()=>zi,content_0_376:()=>Wi,content_0_378:()=>Si,content_0_38:()=>mt,content_0_380:()=>Ei,content_0_382:()=>Ui,content_0_384:()=>ji,content_0_386:()=>Hi,content_0_388:()=>Ji,content_0_390:()=>nl,content_0_392:()=>rl,content_0_394:()=>al,content_0_396:()=>ul,content_0_398:()=>hl,content_0_4:()=>f,content_0_40:()=>ft,content_0_400:()=>yl,content_0_402:()=>Xl,content_0_404:()=>Tl,content_0_406:()=>gl,content_0_408:()=>Zl,content_0_410:()=>zl,content_0_412:()=>Wl,content_0_414:()=>Sl,content_0_416:()=>El,content_0_418:()=>Ul,content_0_42:()=>Dt,content_0_420:()=>jl,content_0_422:()=>Hl,content_0_424:()=>Jl,content_0_426:()=>nu,content_0_428:()=>ru,content_0_430:()=>au,content_0_432:()=>uu,content_0_434:()=>hu,content_0_436:()=>yu,content_0_438:()=>Xu,content_0_44:()=>_t,content_0_440:()=>Tu,content_0_442:()=>gu,content_0_444:()=>Zu,content_0_446:()=>zu,content_0_448:()=>Wu,content_0_450:()=>Su,content_0_452:()=>Eu,content_0_454:()=>Uu,content_0_456:()=>ju,content_0_458:()=>Hu,content_0_46:()=>Ct,content_0_460:()=>Ju,content_0_462:()=>nm,content_0_464:()=>rm,content_0_466:()=>am,content_0_468:()=>um,content_0_470:()=>hm,content_0_472:()=>ym,content_0_474:()=>Xm,content_0_476:()=>Tm,content_0_478:()=>gm,content_0_48:()=>vt,content_0_480:()=>Zm,content_0_482:()=>zm,content_0_484:()=>Wm,content_0_486:()=>Sm,content_0_488:()=>Em,content_0_490:()=>Um,content_0_492:()=>jm,content_0_494:()=>Hm,content_0_496:()=>Jm,content_0_498:()=>nd,content_0_50:()=>bt,content_0_500:()=>rd,content_0_502:()=>ad,content_0_504:()=>ud,content_0_506:()=>hd,content_0_508:()=>yd,content_0_510:()=>Xd,content_0_512:()=>Td,content_0_514:()=>gd,content_0_516:()=>Zd,content_0_518:()=>zd,content_0_52:()=>At,content_0_520:()=>Wd,content_0_522:()=>Sd,content_0_524:()=>Ed,content_0_526:()=>Ud,content_0_528:()=>jd,content_0_530:()=>Hd,content_0_532:()=>Jd,content_0_534:()=>nh,content_0_536:()=>rh,content_0_538:()=>ah,content_0_54:()=>Rt,content_0_540:()=>uh,content_0_542:()=>hh,content_0_544:()=>yh,content_0_546:()=>Xh,content_0_548:()=>Th,content_0_550:()=>gh,content_0_552:()=>Zh,content_0_554:()=>zh,content_0_556:()=>Wh,content_0_558:()=>Sh,content_0_56:()=>Bt,content_0_560:()=>Eh,content_0_562:()=>Uh,content_0_564:()=>jh,content_0_566:()=>Hh,content_0_568:()=>Jh,content_0_570:()=>nf,content_0_572:()=>rf,content_0_574:()=>af,content_0_576:()=>mf,content_0_578:()=>ff,content_0_58:()=>Ot,content_0_580:()=>Df,content_0_582:()=>_f,content_0_584:()=>Cf,content_0_586:()=>vf,content_0_588:()=>bf,content_0_590:()=>Af,content_0_592:()=>Rf,content_0_594:()=>Bf,content_0_596:()=>Of,content_0_598:()=>Vf,content_0_6:()=>D,content_0_60:()=>Vt,content_0_600:()=>Yf,content_0_602:()=>Kf,content_0_604:()=>tk,content_0_606:()=>ok,content_0_608:()=>sk,content_0_610:()=>ik,content_0_612:()=>mk,content_0_614:()=>fk,content_0_616:()=>Dk,content_0_618:()=>_k,content_0_62:()=>Yt,content_0_620:()=>Ck,content_0_622:()=>vk,content_0_624:()=>bk,content_0_626:()=>Ak,content_0_628:()=>Rk,content_0_630:()=>Bk,content_0_632:()=>Ok,content_0_634:()=>Vk,content_0_636:()=>Yk,content_0_638:()=>Kk,content_0_64:()=>Kt,content_0_640:()=>ty,content_0_642:()=>oy,content_0_644:()=>sy,content_0_646:()=>iy,content_0_648:()=>my,content_0_650:()=>fy,content_0_652:()=>Dy,content_0_654:()=>_y,content_0_656:()=>Cy,content_0_658:()=>vy,content_0_66:()=>te,content_0_660:()=>by,content_0_662:()=>Ay,content_0_664:()=>Ry,content_0_666:()=>By,content_0_668:()=>Oy,content_0_670:()=>Vy,content_0_672:()=>Yy,content_0_674:()=>Ky,content_0_676:()=>tD,content_0_678:()=>oD,content_0_68:()=>oe,content_0_680:()=>sD,content_0_682:()=>iD,content_0_684:()=>mD,content_0_686:()=>fD,content_0_688:()=>DD,content_0_690:()=>_D,content_0_692:()=>CD,content_0_694:()=>vD,content_0_696:()=>bD,content_0_698:()=>AD,content_0_70:()=>se,content_0_700:()=>RD,content_0_702:()=>BD,content_0_704:()=>OD,content_0_706:()=>VD,content_0_708:()=>YD,content_0_710:()=>KD,content_0_712:()=>tM,content_0_714:()=>oM,content_0_716:()=>sM,content_0_718:()=>iM,content_0_72:()=>ie,content_0_720:()=>mM,content_0_722:()=>fM,content_0_724:()=>DM,content_0_726:()=>_M,content_0_728:()=>CM,content_0_730:()=>vM,content_0_732:()=>bM,content_0_734:()=>AM,content_0_736:()=>RM,content_0_738:()=>BM,content_0_74:()=>me,content_0_740:()=>OM,content_0_742:()=>VM,content_0_744:()=>YM,content_0_746:()=>KM,content_0_748:()=>tX,content_0_750:()=>oX,content_0_752:()=>sX,content_0_754:()=>iX,content_0_756:()=>mX,content_0_758:()=>fX,content_0_76:()=>fe,content_0_760:()=>DX,content_0_762:()=>_X,content_0_764:()=>CX,content_0_766:()=>vX,content_0_768:()=>bX,content_0_770:()=>AX,content_0_772:()=>RX,content_0_774:()=>BX,content_0_776:()=>OX,content_0_778:()=>VX,content_0_78:()=>De,content_0_780:()=>YX,content_0_782:()=>KX,content_0_784:()=>t_,content_0_786:()=>o_,content_0_788:()=>s_,content_0_790:()=>i_,content_0_792:()=>m_,content_0_794:()=>f_,content_0_796:()=>D_,content_0_798:()=>__,content_0_8:()=>_,content_0_80:()=>_e,content_0_800:()=>C_,content_0_802:()=>v_,content_0_804:()=>b_,content_0_806:()=>A_,content_0_808:()=>R_,content_0_810:()=>B_,content_0_812:()=>O_,content_0_814:()=>V_,content_0_816:()=>Y_,content_0_818:()=>K_,content_0_82:()=>Ce,content_0_820:()=>tw,content_0_822:()=>ow,content_0_824:()=>sw,content_0_826:()=>iw,content_0_828:()=>mw,content_0_830:()=>fw,content_0_832:()=>Dw,content_0_834:()=>_w,content_0_836:()=>Cw,content_0_838:()=>vw,content_0_84:()=>ve,content_0_840:()=>bw,content_0_842:()=>Aw,content_0_844:()=>Rw,content_0_846:()=>Bw,content_0_848:()=>Ow,content_0_850:()=>Vw,content_0_852:()=>Yw,content_0_854:()=>Kw,content_0_856:()=>tT,content_0_858:()=>oT,content_0_86:()=>be,content_0_860:()=>sT,content_0_862:()=>iT,content_0_864:()=>mT,content_0_866:()=>fT,content_0_868:()=>DT,content_0_870:()=>_T,content_0_872:()=>CT,content_0_874:()=>vT,content_0_876:()=>bT,content_0_878:()=>AT,content_0_88:()=>Ae,content_0_880:()=>RT,content_0_882:()=>BT,content_0_884:()=>OT,content_0_886:()=>VT,content_0_888:()=>YT,content_0_890:()=>KT,content_0_892:()=>tC,content_0_894:()=>oC,content_0_896:()=>sC,content_0_898:()=>iC,content_0_90:()=>Re,content_0_900:()=>mC,content_0_902:()=>fC,content_0_904:()=>DC,content_0_906:()=>_C,content_0_908:()=>CC,content_0_910:()=>vC,content_0_912:()=>bC,content_0_914:()=>AC,content_0_916:()=>RC,content_0_918:()=>BC,content_0_92:()=>Be,content_0_920:()=>OC,content_0_922:()=>VC,content_0_924:()=>YC,content_0_926:()=>KC,content_0_928:()=>tx,content_0_930:()=>ox,content_0_932:()=>sx,content_0_934:()=>ix,content_0_936:()=>mx,content_0_938:()=>fx,content_0_94:()=>Oe,content_0_940:()=>Dx,content_0_942:()=>_x,content_0_944:()=>Cx,content_0_946:()=>vx,content_0_948:()=>bx,content_0_950:()=>Ax,content_0_952:()=>Rx,content_0_954:()=>Bx,content_0_956:()=>Ox,content_0_958:()=>Vx,content_0_96:()=>Ve,content_0_960:()=>Yx,content_0_962:()=>Kx,content_0_964:()=>tg,content_0_966:()=>og,content_0_968:()=>sg,content_0_970:()=>ig,content_0_972:()=>mg,content_0_974:()=>fg,content_0_976:()=>Dg,content_0_978:()=>_g,content_0_98:()=>Ye,content_0_980:()=>Cg,content_0_982:()=>vg,content_0_984:()=>bg,content_0_986:()=>Ag,content_0_988:()=>Rg,content_0_990:()=>Bg,content_0_992:()=>Og,content_0_994:()=>Vg,content_0_996:()=>Yg,content_0_998:()=>Kg,content_3764_0:()=>CH,content_3764_10:()=>BH,content_3764_100:()=>mJ,content_3764_1000:()=>dht,content_3764_10000:()=>dap,content_3764_10002:()=>kap,content_3764_10004:()=>Map,content_3764_10006:()=>wap,content_3764_10008:()=>xap,content_3764_10010:()=>Lap,content_3764_10012:()=>Nap,content_3764_10014:()=>Pap,content_3764_10016:()=>Iap,content_3764_10018:()=>Gap,content_3764_1002:()=>kht,content_3764_10020:()=>Fap,content_3764_10022:()=>qap,content_3764_10024:()=>Qap,content_3764_10026:()=>$ap,content_3764_10028:()=>eip,content_3764_10030:()=>pip,content_3764_10032:()=>cip,content_3764_10034:()=>lip,content_3764_10036:()=>dip,content_3764_10038:()=>kip,content_3764_1004:()=>Mht,content_3764_10040:()=>Mip,content_3764_10042:()=>wip,content_3764_10044:()=>xip,content_3764_10046:()=>Lip,content_3764_10048:()=>Nip,content_3764_10050:()=>Pip,content_3764_10052:()=>Iip,content_3764_10054:()=>Gip,content_3764_10056:()=>Fip,content_3764_10058:()=>qip,content_3764_1006:()=>wht,content_3764_10060:()=>Qip,content_3764_10062:()=>$ip,content_3764_10064:()=>elp,content_3764_10066:()=>plp,content_3764_10068:()=>clp,content_3764_10070:()=>llp,content_3764_10072:()=>dlp,content_3764_10074:()=>klp,content_3764_10076:()=>Mlp,content_3764_10078:()=>wlp,content_3764_1008:()=>xht,content_3764_10080:()=>xlp,content_3764_10082:()=>Llp,content_3764_10084:()=>Nlp,content_3764_10086:()=>Plp,content_3764_10088:()=>Ilp,content_3764_10090:()=>Glp,content_3764_10092:()=>Flp,content_3764_10094:()=>qlp,content_3764_10096:()=>Qlp,content_3764_10098:()=>$lp,content_3764_1010:()=>Lht,content_3764_10100:()=>eup,content_3764_10102:()=>pup,content_3764_10104:()=>cup,content_3764_10106:()=>lup,content_3764_10108:()=>dup,content_3764_10110:()=>kup,content_3764_10112:()=>Mup,content_3764_10114:()=>wup,content_3764_10116:()=>xup,content_3764_10118:()=>Lup,content_3764_1012:()=>Nht,content_3764_10120:()=>Nup,content_3764_10122:()=>Pup,content_3764_10124:()=>Iup,content_3764_10126:()=>Gup,content_3764_10128:()=>Fup,content_3764_10130:()=>qup,content_3764_10132:()=>Qup,content_3764_10134:()=>$up,content_3764_10136:()=>emp,content_3764_10138:()=>pmp,content_3764_1014:()=>Pht,content_3764_10140:()=>cmp,content_3764_10142:()=>lmp,content_3764_10144:()=>dmp,content_3764_10146:()=>kmp,content_3764_10148:()=>Mmp,content_3764_10150:()=>wmp,content_3764_10152:()=>xmp,content_3764_10154:()=>Lmp,content_3764_10156:()=>Nmp,content_3764_10158:()=>Pmp,content_3764_1016:()=>Iht,content_3764_10160:()=>Imp,content_3764_10162:()=>Gmp,content_3764_10164:()=>Fmp,content_3764_10166:()=>qmp,content_3764_10168:()=>Qmp,content_3764_10170:()=>$mp,content_3764_10172:()=>edp,content_3764_10174:()=>pdp,content_3764_10176:()=>cdp,content_3764_10178:()=>ldp,content_3764_1018:()=>Ght,content_3764_10180:()=>ddp,content_3764_10182:()=>kdp,content_3764_10184:()=>Mdp,content_3764_10186:()=>wdp,content_3764_10188:()=>xdp,content_3764_10190:()=>Ldp,content_3764_10192:()=>Ndp,content_3764_10194:()=>Pdp,content_3764_10196:()=>Idp,content_3764_10198:()=>Gdp,content_3764_102:()=>fJ,content_3764_1020:()=>Fht,content_3764_10200:()=>Fdp,content_3764_10202:()=>qdp,content_3764_10204:()=>Qdp,content_3764_10206:()=>$dp,content_3764_10208:()=>ehp,content_3764_10210:()=>php,content_3764_10212:()=>chp,content_3764_10214:()=>lhp,content_3764_10216:()=>dhp,content_3764_10218:()=>khp,content_3764_1022:()=>qht,content_3764_10220:()=>Mhp,content_3764_10222:()=>whp,content_3764_10224:()=>xhp,content_3764_10226:()=>Lhp,content_3764_10228:()=>Nhp,content_3764_10230:()=>Php,content_3764_10232:()=>Ihp,content_3764_10234:()=>Ghp,content_3764_10236:()=>Fhp,content_3764_10238:()=>qhp,content_3764_1024:()=>Qht,content_3764_10240:()=>Qhp,content_3764_10242:()=>$hp,content_3764_10244:()=>efp,content_3764_10246:()=>pfp,content_3764_10248:()=>cfp,content_3764_10250:()=>lfp,content_3764_10252:()=>dfp,content_3764_10254:()=>kfp,content_3764_10256:()=>Mfp,content_3764_10258:()=>wfp,content_3764_1026:()=>$ht,content_3764_10260:()=>xfp,content_3764_10262:()=>Lfp,content_3764_10264:()=>Nfp,content_3764_10266:()=>Pfp,content_3764_10268:()=>Ifp,content_3764_10270:()=>Gfp,content_3764_10272:()=>Ffp,content_3764_10274:()=>qfp,content_3764_10276:()=>Qfp,content_3764_10278:()=>$fp,content_3764_1028:()=>eft,content_3764_10280:()=>ekp,content_3764_10282:()=>pkp,content_3764_10284:()=>ckp,content_3764_10286:()=>lkp,content_3764_10288:()=>dkp,content_3764_10290:()=>kkp,content_3764_10292:()=>Mkp,content_3764_10294:()=>wkp,content_3764_10296:()=>xkp,content_3764_10298:()=>Lkp,content_3764_1030:()=>pft,content_3764_10300:()=>Nkp,content_3764_10302:()=>Pkp,content_3764_10304:()=>Ikp,content_3764_10306:()=>Gkp,content_3764_10308:()=>Fkp,content_3764_10310:()=>qkp,content_3764_10312:()=>Qkp,content_3764_10314:()=>$kp,content_3764_10316:()=>eyp,content_3764_10318:()=>pyp,content_3764_1032:()=>cft,content_3764_10320:()=>cyp,content_3764_10322:()=>lyp,content_3764_10324:()=>dyp,content_3764_10326:()=>kyp,content_3764_10328:()=>Myp,content_3764_10330:()=>wyp,content_3764_10332:()=>xyp,content_3764_10334:()=>Lyp,content_3764_10336:()=>Nyp,content_3764_10338:()=>Pyp,content_3764_1034:()=>lft,content_3764_10340:()=>Iyp,content_3764_10342:()=>Gyp,content_3764_10344:()=>Fyp,content_3764_10346:()=>qyp,content_3764_10348:()=>Qyp,content_3764_10350:()=>$yp,content_3764_10352:()=>eDp,content_3764_10354:()=>pDp,content_3764_10356:()=>cDp,content_3764_10358:()=>lDp,content_3764_1036:()=>dft,content_3764_10360:()=>dDp,content_3764_10362:()=>kDp,content_3764_10364:()=>MDp,content_3764_10366:()=>wDp,content_3764_10368:()=>xDp,content_3764_10370:()=>LDp,content_3764_10372:()=>NDp,content_3764_10374:()=>PDp,content_3764_10376:()=>IDp,content_3764_10378:()=>GDp,content_3764_1038:()=>kft,content_3764_10380:()=>FDp,content_3764_10382:()=>qDp,content_3764_10384:()=>QDp,content_3764_10386:()=>$Dp,content_3764_10388:()=>eMp,content_3764_10390:()=>pMp,content_3764_10392:()=>cMp,content_3764_10394:()=>lMp,content_3764_10396:()=>dMp,content_3764_10398:()=>kMp,content_3764_104:()=>DJ,content_3764_1040:()=>Mft,content_3764_10400:()=>MMp,content_3764_10402:()=>wMp,content_3764_10404:()=>xMp,content_3764_10406:()=>LMp,content_3764_10408:()=>NMp,content_3764_10410:()=>PMp,content_3764_10412:()=>IMp,content_3764_10414:()=>GMp,content_3764_10416:()=>FMp,content_3764_10418:()=>qMp,content_3764_1042:()=>wft,content_3764_10420:()=>QMp,content_3764_10422:()=>$Mp,content_3764_10424:()=>eXp,content_3764_10426:()=>pXp,content_3764_10428:()=>cXp,content_3764_10430:()=>lXp,content_3764_10432:()=>dXp,content_3764_10434:()=>kXp,content_3764_10436:()=>MXp,content_3764_10438:()=>wXp,content_3764_1044:()=>xft,content_3764_10440:()=>xXp,content_3764_10442:()=>LXp,content_3764_10444:()=>NXp,content_3764_10446:()=>PXp,content_3764_10448:()=>IXp,content_3764_10450:()=>GXp,content_3764_10452:()=>FXp,content_3764_10454:()=>qXp,content_3764_10456:()=>QXp,content_3764_10458:()=>$Xp,content_3764_1046:()=>Lft,content_3764_10460:()=>e_p,content_3764_10462:()=>p_p,content_3764_10464:()=>c_p,content_3764_10466:()=>l_p,content_3764_10468:()=>d_p,content_3764_10470:()=>k_p,content_3764_10472:()=>M_p,content_3764_10474:()=>w_p,content_3764_10476:()=>x_p,content_3764_10478:()=>L_p,content_3764_1048:()=>Nft,content_3764_10480:()=>N_p,content_3764_10482:()=>P_p,content_3764_10484:()=>I_p,content_3764_10486:()=>G_p,content_3764_10488:()=>F_p,content_3764_10490:()=>q_p,content_3764_10492:()=>Q_p,content_3764_10494:()=>$_p,content_3764_10496:()=>ewp,content_3764_10498:()=>pwp,content_3764_1050:()=>Pft,content_3764_10500:()=>cwp,content_3764_10502:()=>lwp,content_3764_10504:()=>dwp,content_3764_10506:()=>kwp,content_3764_10508:()=>Mwp,content_3764_10510:()=>wwp,content_3764_10512:()=>xwp,content_3764_10514:()=>Lwp,content_3764_10516:()=>Nwp,content_3764_10518:()=>Pwp,content_3764_1052:()=>Ift,content_3764_10520:()=>Iwp,content_3764_10522:()=>Gwp,content_3764_10524:()=>Fwp,content_3764_10526:()=>qwp,content_3764_10528:()=>Qwp,content_3764_10530:()=>$wp,content_3764_10532:()=>eTp,content_3764_10534:()=>pTp,content_3764_10536:()=>cTp,content_3764_10538:()=>lTp,content_3764_1054:()=>Gft,content_3764_10540:()=>dTp,content_3764_10542:()=>kTp,content_3764_10544:()=>MTp,content_3764_10546:()=>wTp,content_3764_10548:()=>xTp,content_3764_10550:()=>LTp,content_3764_10552:()=>NTp,content_3764_10554:()=>PTp,content_3764_10556:()=>ITp,content_3764_10558:()=>GTp,content_3764_1056:()=>Fft,content_3764_10560:()=>FTp,content_3764_10562:()=>qTp,content_3764_10564:()=>QTp,content_3764_10566:()=>$Tp,content_3764_10568:()=>eCp,content_3764_10570:()=>pCp,content_3764_10572:()=>cCp,content_3764_10574:()=>lCp,content_3764_10576:()=>dCp,content_3764_10578:()=>kCp,content_3764_1058:()=>qft,content_3764_10580:()=>MCp,content_3764_10582:()=>wCp,content_3764_10584:()=>xCp,content_3764_10586:()=>LCp,content_3764_10588:()=>NCp,content_3764_10590:()=>PCp,content_3764_10592:()=>ICp,content_3764_10594:()=>GCp,content_3764_10596:()=>FCp,content_3764_10598:()=>qCp,content_3764_106:()=>_J,content_3764_1060:()=>Qft,content_3764_10600:()=>QCp,content_3764_10602:()=>$Cp,content_3764_10604:()=>exp,content_3764_10606:()=>pxp,content_3764_10608:()=>cxp,content_3764_10610:()=>lxp,content_3764_10612:()=>dxp,content_3764_10614:()=>kxp,content_3764_10616:()=>Mxp,content_3764_10618:()=>wxp,content_3764_1062:()=>$ft,content_3764_10620:()=>xxp,content_3764_10622:()=>Lxp,content_3764_10624:()=>Nxp,content_3764_10626:()=>Pxp,content_3764_10628:()=>Ixp,content_3764_10630:()=>Gxp,content_3764_10632:()=>Fxp,content_3764_10634:()=>qxp,content_3764_10636:()=>Qxp,content_3764_10638:()=>$xp,content_3764_1064:()=>ekt,content_3764_10640:()=>egp,content_3764_10642:()=>pgp,content_3764_10644:()=>cgp,content_3764_10646:()=>lgp,content_3764_10648:()=>dgp,content_3764_10650:()=>kgp,content_3764_10652:()=>Mgp,content_3764_10654:()=>wgp,content_3764_10656:()=>xgp,content_3764_10658:()=>Lgp,content_3764_1066:()=>pkt,content_3764_10660:()=>Ngp,content_3764_10662:()=>Pgp,content_3764_10664:()=>Igp,content_3764_10666:()=>Ggp,content_3764_10668:()=>Fgp,content_3764_10670:()=>qgp,content_3764_10672:()=>Qgp,content_3764_10674:()=>$gp,content_3764_10676:()=>evp,content_3764_10678:()=>pvp,content_3764_1068:()=>ckt,content_3764_10680:()=>cvp,content_3764_10682:()=>lvp,content_3764_10684:()=>dvp,content_3764_10686:()=>kvp,content_3764_10688:()=>Mvp,content_3764_10690:()=>wvp,content_3764_10692:()=>xvp,content_3764_10694:()=>Lvp,content_3764_10696:()=>Nvp,content_3764_10698:()=>Pvp,content_3764_1070:()=>lkt,content_3764_10700:()=>Ivp,content_3764_10702:()=>Gvp,content_3764_10704:()=>Fvp,content_3764_10706:()=>qvp,content_3764_10708:()=>Qvp,content_3764_10710:()=>$vp,content_3764_10712:()=>eLp,content_3764_10714:()=>pLp,content_3764_10716:()=>cLp,content_3764_10718:()=>lLp,content_3764_1072:()=>dkt,content_3764_10720:()=>dLp,content_3764_10722:()=>kLp,content_3764_10724:()=>MLp,content_3764_10726:()=>wLp,content_3764_10728:()=>xLp,content_3764_10730:()=>LLp,content_3764_10732:()=>NLp,content_3764_10734:()=>PLp,content_3764_10736:()=>ILp,content_3764_10738:()=>GLp,content_3764_1074:()=>kkt,content_3764_10740:()=>FLp,content_3764_10742:()=>qLp,content_3764_10744:()=>QLp,content_3764_10746:()=>$Lp,content_3764_10748:()=>eZp,content_3764_10750:()=>pZp,content_3764_10752:()=>cZp,content_3764_10754:()=>lZp,content_3764_10756:()=>dZp,content_3764_10758:()=>kZp,content_3764_1076:()=>Mkt,content_3764_10760:()=>MZp,content_3764_10762:()=>wZp,content_3764_10764:()=>xZp,content_3764_10766:()=>LZp,content_3764_10768:()=>NZp,content_3764_10770:()=>PZp,content_3764_10772:()=>IZp,content_3764_10774:()=>GZp,content_3764_10776:()=>FZp,content_3764_10778:()=>qZp,content_3764_1078:()=>wkt,content_3764_10780:()=>QZp,content_3764_10782:()=>$Zp,content_3764_10784:()=>ebp,content_3764_10786:()=>pbp,content_3764_10788:()=>cbp,content_3764_10790:()=>lbp,content_3764_10792:()=>dbp,content_3764_10794:()=>kbp,content_3764_10796:()=>Mbp,content_3764_10798:()=>wbp,content_3764_108:()=>CJ,content_3764_1080:()=>xkt,content_3764_10800:()=>xbp,content_3764_10802:()=>Lbp,content_3764_10804:()=>Nbp,content_3764_10806:()=>Pbp,content_3764_10808:()=>Ibp,content_3764_10810:()=>Gbp,content_3764_10812:()=>Fbp,content_3764_10814:()=>qbp,content_3764_10816:()=>Qbp,content_3764_10818:()=>$bp,content_3764_1082:()=>Lkt,content_3764_10820:()=>eNp,content_3764_10822:()=>pNp,content_3764_10824:()=>cNp,content_3764_10826:()=>lNp,content_3764_10828:()=>dNp,content_3764_10830:()=>kNp,content_3764_10832:()=>MNp,content_3764_10834:()=>wNp,content_3764_10836:()=>xNp,content_3764_10838:()=>LNp,content_3764_1084:()=>Nkt,content_3764_10840:()=>NNp,content_3764_10842:()=>PNp,content_3764_10844:()=>INp,content_3764_10846:()=>GNp,content_3764_10848:()=>FNp,content_3764_10850:()=>qNp,content_3764_10852:()=>QNp,content_3764_10854:()=>$Np,content_3764_10856:()=>ezp,content_3764_10858:()=>pzp,content_3764_1086:()=>Pkt,content_3764_10860:()=>czp,content_3764_10862:()=>lzp,content_3764_10864:()=>dzp,content_3764_10866:()=>kzp,content_3764_10868:()=>Mzp,content_3764_10870:()=>wzp,content_3764_10872:()=>xzp,content_3764_10874:()=>Lzp,content_3764_10876:()=>Nzp,content_3764_10878:()=>Pzp,content_3764_1088:()=>Ikt,content_3764_10880:()=>Izp,content_3764_10882:()=>Gzp,content_3764_10884:()=>Fzp,content_3764_10886:()=>qzp,content_3764_10888:()=>Qzp,content_3764_10890:()=>$zp,content_3764_10892:()=>eAp,content_3764_10894:()=>pAp,content_3764_10896:()=>cAp,content_3764_10898:()=>lAp,content_3764_1090:()=>Gkt,content_3764_10900:()=>dAp,content_3764_10902:()=>kAp,content_3764_10904:()=>MAp,content_3764_10906:()=>wAp,content_3764_10908:()=>xAp,content_3764_10910:()=>LAp,content_3764_10912:()=>NAp,content_3764_10914:()=>PAp,content_3764_10916:()=>IAp,content_3764_10918:()=>GAp,content_3764_1092:()=>Fkt,content_3764_10920:()=>FAp,content_3764_10922:()=>qAp,content_3764_10924:()=>QAp,content_3764_10926:()=>$Ap,content_3764_10928:()=>ePp,content_3764_10930:()=>pPp,content_3764_10932:()=>cPp,content_3764_10934:()=>lPp,content_3764_10936:()=>dPp,content_3764_10938:()=>kPp,content_3764_1094:()=>qkt,content_3764_10940:()=>MPp,content_3764_10942:()=>wPp,content_3764_10944:()=>xPp,content_3764_10946:()=>LPp,content_3764_10948:()=>NPp,content_3764_10950:()=>PPp,content_3764_10952:()=>IPp,content_3764_10954:()=>GPp,content_3764_10956:()=>FPp,content_3764_10958:()=>qPp,content_3764_1096:()=>Qkt,content_3764_10960:()=>QPp,content_3764_10962:()=>$Pp,content_3764_10964:()=>eWp,content_3764_10966:()=>pWp,content_3764_10968:()=>cWp,content_3764_10970:()=>lWp,content_3764_10972:()=>dWp,content_3764_10974:()=>kWp,content_3764_10976:()=>MWp,content_3764_10978:()=>wWp,content_3764_1098:()=>$kt,content_3764_10980:()=>xWp,content_3764_10982:()=>LWp,content_3764_10984:()=>NWp,content_3764_10986:()=>PWp,content_3764_10988:()=>IWp,content_3764_10990:()=>GWp,content_3764_10992:()=>FWp,content_3764_10994:()=>qWp,content_3764_10996:()=>QWp,content_3764_10998:()=>$Wp,content_3764_110:()=>vJ,content_3764_1100:()=>eyt,content_3764_11000:()=>eRp,content_3764_11002:()=>pRp,content_3764_11004:()=>cRp,content_3764_11006:()=>lRp,content_3764_11008:()=>dRp,content_3764_11010:()=>kRp,content_3764_11012:()=>MRp,content_3764_11014:()=>wRp,content_3764_11016:()=>xRp,content_3764_11018:()=>LRp,content_3764_1102:()=>pyt,content_3764_11020:()=>NRp,content_3764_11022:()=>PRp,content_3764_11024:()=>IRp,content_3764_11026:()=>GRp,content_3764_11028:()=>FRp,content_3764_11030:()=>qRp,content_3764_11032:()=>QRp,content_3764_11034:()=>$Rp,content_3764_11036:()=>eIp,content_3764_11038:()=>pIp,content_3764_1104:()=>cyt,content_3764_11040:()=>cIp,content_3764_11042:()=>lIp,content_3764_11044:()=>dIp,content_3764_11046:()=>kIp,content_3764_11048:()=>MIp,content_3764_11050:()=>wIp,content_3764_11052:()=>xIp,content_3764_11054:()=>LIp,content_3764_11056:()=>NIp,content_3764_11058:()=>PIp,content_3764_1106:()=>lyt,content_3764_11060:()=>IIp,content_3764_11062:()=>GIp,content_3764_11064:()=>FIp,content_3764_11066:()=>qIp,content_3764_11068:()=>QIp,content_3764_11070:()=>$Ip,content_3764_11072:()=>eSp,content_3764_11074:()=>pSp,content_3764_11076:()=>cSp,content_3764_11078:()=>lSp,content_3764_1108:()=>dyt,content_3764_11080:()=>dSp,content_3764_11082:()=>kSp,content_3764_11084:()=>MSp,content_3764_11086:()=>wSp,content_3764_11088:()=>xSp,content_3764_11090:()=>LSp,content_3764_11092:()=>NSp,content_3764_11094:()=>PSp,content_3764_11096:()=>ISp,content_3764_11098:()=>GSp,content_3764_1110:()=>kyt,content_3764_11100:()=>FSp,content_3764_11102:()=>qSp,content_3764_11104:()=>QSp,content_3764_11106:()=>$Sp,content_3764_11108:()=>eBp,content_3764_11110:()=>pBp,content_3764_11112:()=>cBp,content_3764_11114:()=>lBp,content_3764_11116:()=>dBp,content_3764_11118:()=>kBp,content_3764_1112:()=>Myt,content_3764_11120:()=>MBp,content_3764_11122:()=>wBp,content_3764_11124:()=>xBp,content_3764_11126:()=>LBp,content_3764_11128:()=>NBp,content_3764_11130:()=>PBp,content_3764_11132:()=>IBp,content_3764_11134:()=>GBp,content_3764_11136:()=>FBp,content_3764_11138:()=>qBp,content_3764_1114:()=>wyt,content_3764_11140:()=>QBp,content_3764_11142:()=>$Bp,content_3764_11144:()=>eGp,content_3764_11146:()=>pGp,content_3764_11148:()=>cGp,content_3764_11150:()=>lGp,content_3764_11152:()=>dGp,content_3764_11154:()=>kGp,content_3764_11156:()=>MGp,content_3764_11158:()=>wGp,content_3764_1116:()=>xyt,content_3764_11160:()=>xGp,content_3764_11162:()=>LGp,content_3764_11164:()=>NGp,content_3764_11166:()=>PGp,content_3764_11168:()=>IGp,content_3764_11170:()=>GGp,content_3764_11172:()=>FGp,content_3764_11174:()=>qGp,content_3764_11176:()=>QGp,content_3764_11178:()=>$Gp,content_3764_1118:()=>Lyt,content_3764_11180:()=>eEp,content_3764_11182:()=>pEp,content_3764_11184:()=>cEp,content_3764_11186:()=>lEp,content_3764_11188:()=>dEp,content_3764_11190:()=>kEp,content_3764_11192:()=>MEp,content_3764_11194:()=>wEp,content_3764_11196:()=>xEp,content_3764_11198:()=>LEp,content_3764_112:()=>bJ,content_3764_1120:()=>Nyt,content_3764_11200:()=>NEp,content_3764_11202:()=>PEp,content_3764_11204:()=>IEp,content_3764_11206:()=>GEp,content_3764_11208:()=>FEp,content_3764_11210:()=>qEp,content_3764_11212:()=>QEp,content_3764_11214:()=>$Ep,content_3764_11216:()=>eOp,content_3764_11218:()=>pOp,content_3764_1122:()=>Pyt,content_3764_11220:()=>cOp,content_3764_11222:()=>lOp,content_3764_11224:()=>dOp,content_3764_11226:()=>kOp,content_3764_11228:()=>MOp,content_3764_11230:()=>wOp,content_3764_11232:()=>xOp,content_3764_11234:()=>LOp,content_3764_11236:()=>NOp,content_3764_11238:()=>POp,content_3764_1124:()=>Iyt,content_3764_11240:()=>IOp,content_3764_11242:()=>GOp,content_3764_11244:()=>FOp,content_3764_11246:()=>qOp,content_3764_11248:()=>QOp,content_3764_11250:()=>$Op,content_3764_11252:()=>eFp,content_3764_11254:()=>pFp,content_3764_11256:()=>cFp,content_3764_11258:()=>lFp,content_3764_1126:()=>Gyt,content_3764_11260:()=>dFp,content_3764_11262:()=>kFp,content_3764_11264:()=>MFp,content_3764_11266:()=>wFp,content_3764_11268:()=>xFp,content_3764_11270:()=>LFp,content_3764_11272:()=>NFp,content_3764_11274:()=>PFp,content_3764_11276:()=>IFp,content_3764_11278:()=>GFp,content_3764_1128:()=>Fyt,content_3764_11280:()=>FFp,content_3764_11282:()=>qFp,content_3764_11284:()=>QFp,content_3764_11286:()=>$Fp,content_3764_11288:()=>eUp,content_3764_11290:()=>pUp,content_3764_11292:()=>cUp,content_3764_11294:()=>lUp,content_3764_11296:()=>dUp,content_3764_11298:()=>kUp,content_3764_1130:()=>qyt,content_3764_11300:()=>MUp,content_3764_11302:()=>wUp,content_3764_11304:()=>xUp,content_3764_11306:()=>LUp,content_3764_11308:()=>NUp,content_3764_11310:()=>PUp,content_3764_11312:()=>IUp,content_3764_11314:()=>GUp,content_3764_11316:()=>FUp,content_3764_11318:()=>qUp,content_3764_1132:()=>Qyt,content_3764_11320:()=>QUp,content_3764_11322:()=>$Up,content_3764_11324:()=>eVp,content_3764_11326:()=>pVp,content_3764_11328:()=>cVp,content_3764_11330:()=>lVp,content_3764_11332:()=>dVp,content_3764_11334:()=>kVp,content_3764_11336:()=>MVp,content_3764_11338:()=>wVp,content_3764_1134:()=>$yt,content_3764_11340:()=>xVp,content_3764_11342:()=>LVp,content_3764_11344:()=>NVp,content_3764_11346:()=>PVp,content_3764_11348:()=>IVp,content_3764_11350:()=>GVp,content_3764_11352:()=>FVp,content_3764_11354:()=>qVp,content_3764_11356:()=>QVp,content_3764_11358:()=>$Vp,content_3764_1136:()=>eDt,content_3764_11360:()=>eqp,content_3764_11362:()=>pqp,content_3764_11364:()=>cqp,content_3764_11366:()=>lqp,content_3764_11368:()=>dqp,content_3764_11370:()=>kqp,content_3764_11372:()=>Mqp,content_3764_11374:()=>wqp,content_3764_11376:()=>xqp,content_3764_11378:()=>Lqp,content_3764_1138:()=>pDt,content_3764_11380:()=>Nqp,content_3764_11382:()=>Pqp,content_3764_11384:()=>Iqp,content_3764_11386:()=>Gqp,content_3764_11388:()=>Fqp,content_3764_11390:()=>qqp,content_3764_11392:()=>Qqp,content_3764_11394:()=>$qp,content_3764_11396:()=>ejp,content_3764_11398:()=>pjp,content_3764_114:()=>AJ,content_3764_1140:()=>cDt,content_3764_11400:()=>cjp,content_3764_11402:()=>ljp,content_3764_11404:()=>djp,content_3764_11406:()=>kjp,content_3764_11408:()=>Mjp,content_3764_11410:()=>wjp,content_3764_11412:()=>xjp,content_3764_11414:()=>Ljp,content_3764_11416:()=>Njp,content_3764_11418:()=>Pjp,content_3764_1142:()=>lDt,content_3764_11420:()=>Ijp,content_3764_11422:()=>Gjp,content_3764_11424:()=>Fjp,content_3764_11426:()=>qjp,content_3764_11428:()=>Qjp,content_3764_11430:()=>$jp,content_3764_11432:()=>eYp,content_3764_11434:()=>pYp,content_3764_11436:()=>cYp,content_3764_11438:()=>lYp,content_3764_1144:()=>dDt,content_3764_11440:()=>dYp,content_3764_11442:()=>kYp,content_3764_11444:()=>MYp,content_3764_11446:()=>wYp,content_3764_11448:()=>xYp,content_3764_11450:()=>LYp,content_3764_11452:()=>NYp,content_3764_11454:()=>PYp,content_3764_11456:()=>IYp,content_3764_11458:()=>GYp,content_3764_1146:()=>kDt,content_3764_11460:()=>FYp,content_3764_11462:()=>qYp,content_3764_11464:()=>QYp,content_3764_11466:()=>$Yp,content_3764_11468:()=>eQp,content_3764_11470:()=>pQp,content_3764_11472:()=>cQp,content_3764_11474:()=>lQp,content_3764_11476:()=>dQp,content_3764_11478:()=>kQp,content_3764_1148:()=>MDt,content_3764_11480:()=>MQp,content_3764_11482:()=>wQp,content_3764_11484:()=>xQp,content_3764_11486:()=>LQp,content_3764_11488:()=>NQp,content_3764_11490:()=>PQp,content_3764_11492:()=>IQp,content_3764_11494:()=>GQp,content_3764_11496:()=>FQp,content_3764_11498:()=>qQp,content_3764_1150:()=>wDt,content_3764_11500:()=>QQp,content_3764_11502:()=>$Qp,content_3764_11504:()=>eHp,content_3764_11506:()=>pHp,content_3764_11508:()=>cHp,content_3764_11510:()=>lHp,content_3764_11512:()=>dHp,content_3764_11514:()=>kHp,content_3764_11516:()=>MHp,content_3764_11518:()=>wHp,content_3764_1152:()=>xDt,content_3764_11520:()=>xHp,content_3764_11522:()=>LHp,content_3764_11524:()=>NHp,content_3764_11526:()=>PHp,content_3764_11528:()=>IHp,content_3764_11530:()=>GHp,content_3764_11532:()=>FHp,content_3764_11534:()=>qHp,content_3764_11536:()=>QHp,content_3764_11538:()=>$Hp,content_3764_1154:()=>LDt,content_3764_11540:()=>eKp,content_3764_11542:()=>pKp,content_3764_11544:()=>cKp,content_3764_11546:()=>lKp,content_3764_11548:()=>dKp,content_3764_11550:()=>kKp,content_3764_11552:()=>MKp,content_3764_11554:()=>wKp,content_3764_11556:()=>xKp,content_3764_11558:()=>LKp,content_3764_1156:()=>NDt,content_3764_11560:()=>NKp,content_3764_11562:()=>PKp,content_3764_11564:()=>IKp,content_3764_11566:()=>GKp,content_3764_11568:()=>FKp,content_3764_11570:()=>qKp,content_3764_11572:()=>QKp,content_3764_11574:()=>$Kp,content_3764_11576:()=>e$p,content_3764_11578:()=>p$p,content_3764_1158:()=>PDt,content_3764_11580:()=>c$p,content_3764_11582:()=>l$p,content_3764_11584:()=>d$p,content_3764_11586:()=>k$p,content_3764_11588:()=>M$p,content_3764_11590:()=>w$p,content_3764_11592:()=>x$p,content_3764_11594:()=>L$p,content_3764_11596:()=>N$p,content_3764_11598:()=>P$p,content_3764_116:()=>RJ,content_3764_1160:()=>IDt,content_3764_11600:()=>I$p,content_3764_11602:()=>G$p,content_3764_11604:()=>F$p,content_3764_11606:()=>q$p,content_3764_11608:()=>Q$p,content_3764_11610:()=>$$p,content_3764_11612:()=>eJp,content_3764_11614:()=>pJp,content_3764_11616:()=>cJp,content_3764_11618:()=>lJp,content_3764_1162:()=>GDt,content_3764_11620:()=>dJp,content_3764_11622:()=>kJp,content_3764_11624:()=>MJp,content_3764_11626:()=>wJp,content_3764_11628:()=>xJp,content_3764_11630:()=>LJp,content_3764_11632:()=>NJp,content_3764_11634:()=>PJp,content_3764_11636:()=>IJp,content_3764_11638:()=>GJp,content_3764_1164:()=>FDt,content_3764_11640:()=>FJp,content_3764_11642:()=>qJp,content_3764_11644:()=>QJp,content_3764_11646:()=>$Jp,content_3764_11648:()=>e0p,content_3764_11650:()=>p0p,content_3764_11652:()=>c0p,content_3764_11654:()=>l0p,content_3764_11656:()=>d0p,content_3764_11658:()=>k0p,content_3764_1166:()=>qDt,content_3764_11660:()=>M0p,content_3764_11662:()=>w0p,content_3764_11664:()=>x0p,content_3764_11666:()=>L0p,content_3764_11668:()=>N0p,content_3764_11670:()=>P0p,content_3764_11672:()=>I0p,content_3764_11674:()=>G0p,content_3764_11676:()=>F0p,content_3764_11678:()=>q0p,content_3764_1168:()=>QDt,content_3764_11680:()=>Q0p,content_3764_11682:()=>$0p,content_3764_11684:()=>e4p,content_3764_11686:()=>p4p,content_3764_11688:()=>c4p,content_3764_11690:()=>l4p,content_3764_11692:()=>d4p,content_3764_11694:()=>k4p,content_3764_11696:()=>M4p,content_3764_11698:()=>w4p,content_3764_1170:()=>$Dt,content_3764_11700:()=>x4p,content_3764_11702:()=>L4p,content_3764_11704:()=>N4p,content_3764_11706:()=>P4p,content_3764_11708:()=>I4p,content_3764_11710:()=>G4p,content_3764_11712:()=>F4p,content_3764_11714:()=>q4p,content_3764_11716:()=>Q4p,content_3764_11718:()=>$4p,content_3764_1172:()=>eMt,content_3764_11720:()=>e6p,content_3764_11722:()=>p6p,content_3764_11724:()=>c6p,content_3764_11726:()=>l6p,content_3764_11728:()=>d6p,content_3764_11730:()=>k6p,content_3764_11732:()=>M6p,content_3764_11734:()=>w6p,content_3764_11736:()=>x6p,content_3764_11738:()=>L6p,content_3764_1174:()=>pMt,content_3764_11740:()=>N6p,content_3764_11742:()=>P6p,content_3764_11744:()=>I6p,content_3764_11746:()=>G6p,content_3764_11748:()=>F6p,content_3764_11750:()=>q6p,content_3764_11752:()=>Q6p,content_3764_11754:()=>$6p,content_3764_11756:()=>e3p,content_3764_11758:()=>p3p,content_3764_1176:()=>cMt,content_3764_11760:()=>c3p,content_3764_11762:()=>l3p,content_3764_11764:()=>d3p,content_3764_11766:()=>k3p,content_3764_11768:()=>M3p,content_3764_11770:()=>w3p,content_3764_11772:()=>x3p,content_3764_11774:()=>L3p,content_3764_11776:()=>N3p,content_3764_11778:()=>P3p,content_3764_1178:()=>lMt,content_3764_118:()=>BJ,content_3764_1180:()=>dMt,content_3764_1182:()=>kMt,content_3764_1184:()=>MMt,content_3764_1186:()=>wMt,content_3764_1188:()=>xMt,content_3764_1190:()=>LMt,content_3764_1192:()=>NMt,content_3764_1194:()=>PMt,content_3764_1196:()=>IMt,content_3764_1198:()=>GMt,content_3764_12:()=>OH,content_3764_120:()=>OJ,content_3764_1200:()=>FMt,content_3764_1202:()=>qMt,content_3764_1204:()=>QMt,content_3764_1206:()=>$Mt,content_3764_1208:()=>eXt,content_3764_1210:()=>pXt,content_3764_1212:()=>cXt,content_3764_1214:()=>lXt,content_3764_1216:()=>dXt,content_3764_1218:()=>kXt,content_3764_122:()=>VJ,content_3764_1220:()=>MXt,content_3764_1222:()=>wXt,content_3764_1224:()=>xXt,content_3764_1226:()=>LXt,content_3764_1228:()=>NXt,content_3764_1230:()=>PXt,content_3764_1232:()=>IXt,content_3764_1234:()=>GXt,content_3764_1236:()=>FXt,content_3764_1238:()=>qXt,content_3764_124:()=>YJ,content_3764_1240:()=>QXt,content_3764_1242:()=>$Xt,content_3764_1244:()=>e_t,content_3764_1246:()=>p_t,content_3764_1248:()=>c_t,content_3764_1250:()=>l_t,content_3764_1252:()=>d_t,content_3764_1254:()=>k_t,content_3764_1256:()=>M_t,content_3764_1258:()=>w_t,content_3764_126:()=>KJ,content_3764_1260:()=>x_t,content_3764_1262:()=>L_t,content_3764_1264:()=>N_t,content_3764_1266:()=>P_t,content_3764_1268:()=>I_t,content_3764_1270:()=>G_t,content_3764_1272:()=>F_t,content_3764_1274:()=>q_t,content_3764_1276:()=>Q_t,content_3764_1278:()=>$_t,content_3764_128:()=>t0,content_3764_1280:()=>ewt,content_3764_1282:()=>pwt,content_3764_1284:()=>cwt,content_3764_1286:()=>lwt,content_3764_1288:()=>dwt,content_3764_1290:()=>kwt,content_3764_1292:()=>Mwt,content_3764_1294:()=>wwt,content_3764_1296:()=>xwt,content_3764_1298:()=>Lwt,content_3764_130:()=>o0,content_3764_1300:()=>Nwt,content_3764_1302:()=>Pwt,content_3764_1304:()=>Iwt,content_3764_1306:()=>Gwt,content_3764_1308:()=>Fwt,content_3764_1310:()=>qwt,content_3764_1312:()=>Qwt,content_3764_1314:()=>$wt,content_3764_1316:()=>eTt,content_3764_1318:()=>pTt,content_3764_132:()=>s0,content_3764_1320:()=>cTt,content_3764_1322:()=>lTt,content_3764_1324:()=>dTt,content_3764_1326:()=>kTt,content_3764_1328:()=>MTt,content_3764_1330:()=>wTt,content_3764_1332:()=>xTt,content_3764_1334:()=>LTt,content_3764_1336:()=>NTt,content_3764_1338:()=>PTt,content_3764_134:()=>i0,content_3764_1340:()=>ITt,content_3764_1342:()=>GTt,content_3764_1344:()=>FTt,content_3764_1346:()=>qTt,content_3764_1348:()=>QTt,content_3764_1350:()=>$Tt,content_3764_1352:()=>eCt,content_3764_1354:()=>pCt,content_3764_1356:()=>cCt,content_3764_1358:()=>lCt,content_3764_136:()=>m0,content_3764_1360:()=>dCt,content_3764_1362:()=>kCt,content_3764_1364:()=>MCt,content_3764_1366:()=>wCt,content_3764_1368:()=>xCt,content_3764_1370:()=>LCt,content_3764_1372:()=>NCt,content_3764_1374:()=>PCt,content_3764_1376:()=>ICt,content_3764_1378:()=>GCt,content_3764_138:()=>f0,content_3764_1380:()=>FCt,content_3764_1382:()=>qCt,content_3764_1384:()=>QCt,content_3764_1386:()=>$Ct,content_3764_1388:()=>ext,content_3764_1390:()=>pxt,content_3764_1392:()=>cxt,content_3764_1394:()=>lxt,content_3764_1396:()=>dxt,content_3764_1398:()=>kxt,content_3764_14:()=>VH,content_3764_140:()=>D0,content_3764_1400:()=>Mxt,content_3764_1402:()=>wxt,content_3764_1404:()=>xxt,content_3764_1406:()=>Lxt,content_3764_1408:()=>Nxt,content_3764_1410:()=>Pxt,content_3764_1412:()=>Ixt,content_3764_1414:()=>Gxt,content_3764_1416:()=>Fxt,content_3764_1418:()=>qxt,content_3764_142:()=>_0,content_3764_1420:()=>Qxt,content_3764_1422:()=>$xt,content_3764_1424:()=>egt,content_3764_1426:()=>pgt,content_3764_1428:()=>cgt,content_3764_1430:()=>lgt,content_3764_1432:()=>dgt,content_3764_1434:()=>kgt,content_3764_1436:()=>Mgt,content_3764_1438:()=>wgt,content_3764_144:()=>C0,content_3764_1440:()=>xgt,content_3764_1442:()=>Lgt,content_3764_1444:()=>Ngt,content_3764_1446:()=>Pgt,content_3764_1448:()=>Igt,content_3764_1450:()=>Ggt,content_3764_1452:()=>Fgt,content_3764_1454:()=>qgt,content_3764_1456:()=>Qgt,content_3764_1458:()=>$gt,content_3764_146:()=>v0,content_3764_1460:()=>evt,content_3764_1462:()=>pvt,content_3764_1464:()=>cvt,content_3764_1466:()=>lvt,content_3764_1468:()=>dvt,content_3764_1470:()=>kvt,content_3764_1472:()=>Mvt,content_3764_1474:()=>wvt,content_3764_1476:()=>xvt,content_3764_1478:()=>Lvt,content_3764_148:()=>b0,content_3764_1480:()=>Nvt,content_3764_1482:()=>Pvt,content_3764_1484:()=>Ivt,content_3764_1486:()=>Gvt,content_3764_1488:()=>Fvt,content_3764_1490:()=>qvt,content_3764_1492:()=>Qvt,content_3764_1494:()=>$vt,content_3764_1496:()=>eLt,content_3764_1498:()=>pLt,content_3764_150:()=>A0,content_3764_1500:()=>cLt,content_3764_1502:()=>lLt,content_3764_1504:()=>dLt,content_3764_1506:()=>kLt,content_3764_1508:()=>MLt,content_3764_1510:()=>wLt,content_3764_1512:()=>xLt,content_3764_1514:()=>LLt,content_3764_1516:()=>NLt,content_3764_1518:()=>PLt,content_3764_152:()=>R0,content_3764_1520:()=>ILt,content_3764_1522:()=>GLt,content_3764_1524:()=>FLt,content_3764_1526:()=>qLt,content_3764_1528:()=>QLt,content_3764_1530:()=>$Lt,content_3764_1532:()=>eZt,content_3764_1534:()=>pZt,content_3764_1536:()=>cZt,content_3764_1538:()=>lZt,content_3764_154:()=>B0,content_3764_1540:()=>dZt,content_3764_1542:()=>kZt,content_3764_1544:()=>MZt,content_3764_1546:()=>wZt,content_3764_1548:()=>xZt,content_3764_1550:()=>LZt,content_3764_1552:()=>NZt,content_3764_1554:()=>PZt,content_3764_1556:()=>IZt,content_3764_1558:()=>GZt,content_3764_156:()=>O0,content_3764_1560:()=>FZt,content_3764_1562:()=>qZt,content_3764_1564:()=>QZt,content_3764_1566:()=>$Zt,content_3764_1568:()=>ebt,content_3764_1570:()=>pbt,content_3764_1572:()=>cbt,content_3764_1574:()=>lbt,content_3764_1576:()=>dbt,content_3764_1578:()=>kbt,content_3764_158:()=>V0,content_3764_1580:()=>Mbt,content_3764_1582:()=>wbt,content_3764_1584:()=>xbt,content_3764_1586:()=>Lbt,content_3764_1588:()=>Nbt,content_3764_1590:()=>Pbt,content_3764_1592:()=>Ibt,content_3764_1594:()=>Gbt,content_3764_1596:()=>Fbt,content_3764_1598:()=>qbt,content_3764_16:()=>YH,content_3764_160:()=>Y0,content_3764_1600:()=>Qbt,content_3764_1602:()=>$bt,content_3764_1604:()=>eNt,content_3764_1606:()=>pNt,content_3764_1608:()=>cNt,content_3764_1610:()=>lNt,content_3764_1612:()=>dNt,content_3764_1614:()=>kNt,content_3764_1616:()=>MNt,content_3764_1618:()=>wNt,content_3764_162:()=>K0,content_3764_1620:()=>xNt,content_3764_1622:()=>LNt,content_3764_1624:()=>NNt,content_3764_1626:()=>PNt,content_3764_1628:()=>INt,content_3764_1630:()=>GNt,content_3764_1632:()=>FNt,content_3764_1634:()=>qNt,content_3764_1636:()=>QNt,content_3764_1638:()=>$Nt,content_3764_164:()=>t4,content_3764_1640:()=>ezt,content_3764_1642:()=>pzt,content_3764_1644:()=>czt,content_3764_1646:()=>lzt,content_3764_1648:()=>dzt,content_3764_1650:()=>kzt,content_3764_1652:()=>Mzt,content_3764_1654:()=>wzt,content_3764_1656:()=>xzt,content_3764_1658:()=>Lzt,content_3764_166:()=>o4,content_3764_1660:()=>Nzt,content_3764_1662:()=>Pzt,content_3764_1664:()=>Izt,content_3764_1666:()=>Gzt,content_3764_1668:()=>Fzt,content_3764_1670:()=>qzt,content_3764_1672:()=>Qzt,content_3764_1674:()=>$zt,content_3764_1676:()=>eAt,content_3764_1678:()=>pAt,content_3764_168:()=>s4,content_3764_1680:()=>cAt,content_3764_1682:()=>lAt,content_3764_1684:()=>dAt,content_3764_1686:()=>kAt,content_3764_1688:()=>MAt,content_3764_1690:()=>wAt,content_3764_1692:()=>xAt,content_3764_1694:()=>LAt,content_3764_1696:()=>NAt,content_3764_1698:()=>PAt,content_3764_170:()=>i4,content_3764_1700:()=>IAt,content_3764_1702:()=>GAt,content_3764_1704:()=>FAt,content_3764_1706:()=>qAt,content_3764_1708:()=>QAt,content_3764_1710:()=>$At,content_3764_1712:()=>ePt,content_3764_1714:()=>pPt,content_3764_1716:()=>cPt,content_3764_1718:()=>lPt,content_3764_172:()=>m4,content_3764_1720:()=>dPt,content_3764_1722:()=>kPt,content_3764_1724:()=>MPt,content_3764_1726:()=>wPt,content_3764_1728:()=>xPt,content_3764_1730:()=>LPt,content_3764_1732:()=>NPt,content_3764_1734:()=>PPt,content_3764_1736:()=>IPt,content_3764_1738:()=>GPt,content_3764_174:()=>f4,content_3764_1740:()=>FPt,content_3764_1742:()=>qPt,content_3764_1744:()=>QPt,content_3764_1746:()=>$Pt,content_3764_1748:()=>eWt,content_3764_1750:()=>pWt,content_3764_1752:()=>cWt,content_3764_1754:()=>lWt,content_3764_1756:()=>dWt,content_3764_1758:()=>kWt,content_3764_176:()=>D4,content_3764_1760:()=>MWt,content_3764_1762:()=>wWt,content_3764_1764:()=>xWt,content_3764_1766:()=>LWt,content_3764_1768:()=>NWt,content_3764_1770:()=>PWt,content_3764_1772:()=>IWt,content_3764_1774:()=>GWt,content_3764_1776:()=>FWt,content_3764_1778:()=>qWt,content_3764_178:()=>_4,content_3764_1780:()=>QWt,content_3764_1782:()=>$Wt,content_3764_1784:()=>eRt,content_3764_1786:()=>pRt,content_3764_1788:()=>cRt,content_3764_1790:()=>lRt,content_3764_1792:()=>dRt,content_3764_1794:()=>kRt,content_3764_1796:()=>MRt,content_3764_1798:()=>wRt,content_3764_18:()=>KH,content_3764_180:()=>C4,content_3764_1800:()=>xRt,content_3764_1802:()=>LRt,content_3764_1804:()=>NRt,content_3764_1806:()=>PRt,content_3764_1808:()=>IRt,content_3764_1810:()=>GRt,content_3764_1812:()=>FRt,content_3764_1814:()=>qRt,content_3764_1816:()=>QRt,content_3764_1818:()=>$Rt,content_3764_182:()=>v4,content_3764_1820:()=>eIt,content_3764_1822:()=>pIt,content_3764_1824:()=>cIt,content_3764_1826:()=>lIt,content_3764_1828:()=>dIt,content_3764_1830:()=>kIt,content_3764_1832:()=>MIt,content_3764_1834:()=>wIt,content_3764_1836:()=>xIt,content_3764_1838:()=>LIt,content_3764_184:()=>b4,content_3764_1840:()=>NIt,content_3764_1842:()=>PIt,content_3764_1844:()=>IIt,content_3764_1846:()=>GIt,content_3764_1848:()=>FIt,content_3764_1850:()=>qIt,content_3764_1852:()=>QIt,content_3764_1854:()=>$It,content_3764_1856:()=>eSt,content_3764_1858:()=>pSt,content_3764_186:()=>A4,content_3764_1860:()=>cSt,content_3764_1862:()=>lSt,content_3764_1864:()=>dSt,content_3764_1866:()=>kSt,content_3764_1868:()=>MSt,content_3764_1870:()=>wSt,content_3764_1872:()=>xSt,content_3764_1874:()=>LSt,content_3764_1876:()=>NSt,content_3764_1878:()=>PSt,content_3764_188:()=>R4,content_3764_1880:()=>ISt,content_3764_1882:()=>GSt,content_3764_1884:()=>FSt,content_3764_1886:()=>qSt,content_3764_1888:()=>QSt,content_3764_1890:()=>$St,content_3764_1892:()=>eBt,content_3764_1894:()=>pBt,content_3764_1896:()=>cBt,content_3764_1898:()=>lBt,content_3764_190:()=>B4,content_3764_1900:()=>dBt,content_3764_1902:()=>kBt,content_3764_1904:()=>MBt,content_3764_1906:()=>wBt,content_3764_1908:()=>xBt,content_3764_1910:()=>LBt,content_3764_1912:()=>NBt,content_3764_1914:()=>PBt,content_3764_1916:()=>IBt,content_3764_1918:()=>GBt,content_3764_192:()=>O4,content_3764_1920:()=>FBt,content_3764_1922:()=>qBt,content_3764_1924:()=>QBt,content_3764_1926:()=>$Bt,content_3764_1928:()=>eGt,content_3764_1930:()=>pGt,content_3764_1932:()=>cGt,content_3764_1934:()=>lGt,content_3764_1936:()=>dGt,content_3764_1938:()=>kGt,content_3764_194:()=>V4,content_3764_1940:()=>MGt,content_3764_1942:()=>wGt,content_3764_1944:()=>xGt,content_3764_1946:()=>LGt,content_3764_1948:()=>NGt,content_3764_1950:()=>PGt,content_3764_1952:()=>IGt,content_3764_1954:()=>GGt,content_3764_1956:()=>FGt,content_3764_1958:()=>qGt,content_3764_196:()=>Y4,content_3764_1960:()=>QGt,content_3764_1962:()=>$Gt,content_3764_1964:()=>eEt,content_3764_1966:()=>pEt,content_3764_1968:()=>cEt,content_3764_1970:()=>lEt,content_3764_1972:()=>dEt,content_3764_1974:()=>kEt,content_3764_1976:()=>MEt,content_3764_1978:()=>wEt,content_3764_198:()=>K4,content_3764_1980:()=>xEt,content_3764_1982:()=>LEt,content_3764_1984:()=>NEt,content_3764_1986:()=>PEt,content_3764_1988:()=>IEt,content_3764_1990:()=>GEt,content_3764_1992:()=>FEt,content_3764_1994:()=>qEt,content_3764_1996:()=>QEt,content_3764_1998:()=>$Et,content_3764_2:()=>vH,content_3764_20:()=>tK,content_3764_200:()=>t6,content_3764_2000:()=>eOt,content_3764_2002:()=>pOt,content_3764_2004:()=>cOt,content_3764_2006:()=>lOt,content_3764_2008:()=>dOt,content_3764_2010:()=>kOt,content_3764_2012:()=>MOt,content_3764_2014:()=>wOt,content_3764_2016:()=>xOt,content_3764_2018:()=>LOt,content_3764_202:()=>o6,content_3764_2020:()=>NOt,content_3764_2022:()=>POt,content_3764_2024:()=>IOt,content_3764_2026:()=>GOt,content_3764_2028:()=>FOt,content_3764_2030:()=>qOt,content_3764_2032:()=>QOt,content_3764_2034:()=>$Ot,content_3764_2036:()=>eFt,content_3764_2038:()=>pFt,content_3764_204:()=>s6,content_3764_2040:()=>cFt,content_3764_2042:()=>lFt,content_3764_2044:()=>dFt,content_3764_2046:()=>kFt,content_3764_2048:()=>MFt,content_3764_2050:()=>wFt,content_3764_2052:()=>xFt,content_3764_2054:()=>LFt,content_3764_2056:()=>NFt,content_3764_2058:()=>PFt,content_3764_206:()=>i6,content_3764_2060:()=>IFt,content_3764_2062:()=>GFt,content_3764_2064:()=>FFt,content_3764_2066:()=>qFt,content_3764_2068:()=>QFt,content_3764_2070:()=>$Ft,content_3764_2072:()=>eUt,content_3764_2074:()=>pUt,content_3764_2076:()=>cUt,content_3764_2078:()=>lUt,content_3764_208:()=>m6,content_3764_2080:()=>dUt,content_3764_2082:()=>kUt,content_3764_2084:()=>MUt,content_3764_2086:()=>wUt,content_3764_2088:()=>xUt,content_3764_2090:()=>LUt,content_3764_2092:()=>NUt,content_3764_2094:()=>PUt,content_3764_2096:()=>IUt,content_3764_2098:()=>GUt,content_3764_210:()=>f6,content_3764_2100:()=>FUt,content_3764_2102:()=>qUt,content_3764_2104:()=>QUt,content_3764_2106:()=>$Ut,content_3764_2108:()=>eVt,content_3764_2110:()=>pVt,content_3764_2112:()=>cVt,content_3764_2114:()=>lVt,content_3764_2116:()=>dVt,content_3764_2118:()=>kVt,content_3764_212:()=>D6,content_3764_2120:()=>MVt,content_3764_2122:()=>wVt,content_3764_2124:()=>xVt,content_3764_2126:()=>LVt,content_3764_2128:()=>NVt,content_3764_2130:()=>PVt,content_3764_2132:()=>IVt,content_3764_2134:()=>GVt,content_3764_2136:()=>FVt,content_3764_2138:()=>qVt,content_3764_214:()=>_6,content_3764_2140:()=>QVt,content_3764_2142:()=>$Vt,content_3764_2144:()=>eqt,content_3764_2146:()=>pqt,content_3764_2148:()=>cqt,content_3764_2150:()=>lqt,content_3764_2152:()=>dqt,content_3764_2154:()=>kqt,content_3764_2156:()=>Mqt,content_3764_2158:()=>wqt,content_3764_216:()=>C6,content_3764_2160:()=>xqt,content_3764_2162:()=>Lqt,content_3764_2164:()=>Nqt,content_3764_2166:()=>Pqt,content_3764_2168:()=>Iqt,content_3764_2170:()=>Gqt,content_3764_2172:()=>Fqt,content_3764_2174:()=>qqt,content_3764_2176:()=>Qqt,content_3764_2178:()=>$qt,content_3764_218:()=>v6,content_3764_2180:()=>ejt,content_3764_2182:()=>pjt,content_3764_2184:()=>cjt,content_3764_2186:()=>ljt,content_3764_2188:()=>djt,content_3764_2190:()=>kjt,content_3764_2192:()=>Mjt,content_3764_2194:()=>wjt,content_3764_2196:()=>xjt,content_3764_2198:()=>Ljt,content_3764_22:()=>oK,content_3764_220:()=>b6,content_3764_2200:()=>Njt,content_3764_2202:()=>Pjt,content_3764_2204:()=>Ijt,content_3764_2206:()=>Gjt,content_3764_2208:()=>Fjt,content_3764_2210:()=>qjt,content_3764_2212:()=>Qjt,content_3764_2214:()=>$jt,content_3764_2216:()=>eYt,content_3764_2218:()=>pYt,content_3764_222:()=>A6,content_3764_2220:()=>cYt,content_3764_2222:()=>lYt,content_3764_2224:()=>dYt,content_3764_2226:()=>kYt,content_3764_2228:()=>MYt,content_3764_2230:()=>wYt,content_3764_2232:()=>xYt,content_3764_2234:()=>LYt,content_3764_2236:()=>NYt,content_3764_2238:()=>PYt,content_3764_224:()=>R6,content_3764_2240:()=>IYt,content_3764_2242:()=>GYt,content_3764_2244:()=>FYt,content_3764_2246:()=>qYt,content_3764_2248:()=>QYt,content_3764_2250:()=>$Yt,content_3764_2252:()=>eQt,content_3764_2254:()=>pQt,content_3764_2256:()=>cQt,content_3764_2258:()=>lQt,content_3764_226:()=>B6,content_3764_2260:()=>dQt,content_3764_2262:()=>kQt,content_3764_2264:()=>MQt,content_3764_2266:()=>wQt,content_3764_2268:()=>xQt,content_3764_2270:()=>LQt,content_3764_2272:()=>NQt,content_3764_2274:()=>PQt,content_3764_2276:()=>IQt,content_3764_2278:()=>GQt,content_3764_228:()=>O6,content_3764_2280:()=>FQt,content_3764_2282:()=>qQt,content_3764_2284:()=>QQt,content_3764_2286:()=>$Qt,content_3764_2288:()=>eHt,content_3764_2290:()=>pHt,content_3764_2292:()=>cHt,content_3764_2294:()=>lHt,content_3764_2296:()=>dHt,content_3764_2298:()=>kHt,content_3764_230:()=>V6,content_3764_2300:()=>MHt,content_3764_2302:()=>wHt,content_3764_2304:()=>xHt,content_3764_2306:()=>LHt,content_3764_2308:()=>NHt,content_3764_2310:()=>PHt,content_3764_2312:()=>IHt,content_3764_2314:()=>GHt,content_3764_2316:()=>FHt,content_3764_2318:()=>qHt,content_3764_232:()=>Y6,content_3764_2320:()=>QHt,content_3764_2322:()=>$Ht,content_3764_2324:()=>eKt,content_3764_2326:()=>pKt,content_3764_2328:()=>cKt,content_3764_2330:()=>lKt,content_3764_2332:()=>dKt,content_3764_2334:()=>kKt,content_3764_2336:()=>MKt,content_3764_2338:()=>wKt,content_3764_234:()=>K6,content_3764_2340:()=>xKt,content_3764_2342:()=>LKt,content_3764_2344:()=>NKt,content_3764_2346:()=>PKt,content_3764_2348:()=>IKt,content_3764_2350:()=>GKt,content_3764_2352:()=>FKt,content_3764_2354:()=>qKt,content_3764_2356:()=>QKt,content_3764_2358:()=>$Kt,content_3764_236:()=>t3,content_3764_2360:()=>e$t,content_3764_2362:()=>p$t,content_3764_2364:()=>c$t,content_3764_2366:()=>l$t,content_3764_2368:()=>d$t,content_3764_2370:()=>k$t,content_3764_2372:()=>M$t,content_3764_2374:()=>w$t,content_3764_2376:()=>x$t,content_3764_2378:()=>L$t,content_3764_238:()=>o3,content_3764_2380:()=>N$t,content_3764_2382:()=>P$t,content_3764_2384:()=>I$t,content_3764_2386:()=>G$t,content_3764_2388:()=>F$t,content_3764_2390:()=>q$t,content_3764_2392:()=>Q$t,content_3764_2394:()=>$$t,content_3764_2396:()=>eJt,content_3764_2398:()=>pJt,content_3764_24:()=>sK,content_3764_240:()=>s3,content_3764_2400:()=>cJt,content_3764_2402:()=>lJt,content_3764_2404:()=>dJt,content_3764_2406:()=>kJt,content_3764_2408:()=>MJt,content_3764_2410:()=>wJt,content_3764_2412:()=>xJt,content_3764_2414:()=>LJt,content_3764_2416:()=>NJt,content_3764_2418:()=>PJt,content_3764_242:()=>i3,content_3764_2420:()=>IJt,content_3764_2422:()=>GJt,content_3764_2424:()=>FJt,content_3764_2426:()=>qJt,content_3764_2428:()=>QJt,content_3764_2430:()=>$Jt,content_3764_2432:()=>e0t,content_3764_2434:()=>p0t,content_3764_2436:()=>c0t,content_3764_2438:()=>l0t,content_3764_244:()=>m3,content_3764_2440:()=>d0t,content_3764_2442:()=>k0t,content_3764_2444:()=>M0t,content_3764_2446:()=>w0t,content_3764_2448:()=>x0t,content_3764_2450:()=>L0t,content_3764_2452:()=>N0t,content_3764_2454:()=>P0t,content_3764_2456:()=>I0t,content_3764_2458:()=>G0t,content_3764_246:()=>f3,content_3764_2460:()=>F0t,content_3764_2462:()=>q0t,content_3764_2464:()=>Q0t,content_3764_2466:()=>$0t,content_3764_2468:()=>e4t,content_3764_2470:()=>p4t,content_3764_2472:()=>c4t,content_3764_2474:()=>l4t,content_3764_2476:()=>d4t,content_3764_2478:()=>k4t,content_3764_248:()=>D3,content_3764_2480:()=>M4t,content_3764_2482:()=>w4t,content_3764_2484:()=>x4t,content_3764_2486:()=>L4t,content_3764_2488:()=>N4t,content_3764_2490:()=>P4t,content_3764_2492:()=>I4t,content_3764_2494:()=>G4t,content_3764_2496:()=>F4t,content_3764_2498:()=>q4t,content_3764_250:()=>_3,content_3764_2500:()=>Q4t,content_3764_2502:()=>$4t,content_3764_2504:()=>e6t,content_3764_2506:()=>p6t,content_3764_2508:()=>c6t,content_3764_2510:()=>l6t,content_3764_2512:()=>d6t,content_3764_2514:()=>k6t,content_3764_2516:()=>M6t,content_3764_2518:()=>w6t,content_3764_252:()=>C3,content_3764_2520:()=>x6t,content_3764_2522:()=>L6t,content_3764_2524:()=>N6t,content_3764_2526:()=>P6t,content_3764_2528:()=>I6t,content_3764_2530:()=>G6t,content_3764_2532:()=>F6t,content_3764_2534:()=>q6t,content_3764_2536:()=>Q6t,content_3764_2538:()=>$6t,content_3764_254:()=>v3,content_3764_2540:()=>e3t,content_3764_2542:()=>p3t,content_3764_2544:()=>c3t,content_3764_2546:()=>l3t,content_3764_2548:()=>d3t,content_3764_2550:()=>k3t,content_3764_2552:()=>M3t,content_3764_2554:()=>w3t,content_3764_2556:()=>x3t,content_3764_2558:()=>L3t,content_3764_256:()=>b3,content_3764_2560:()=>N3t,content_3764_2562:()=>P3t,content_3764_2564:()=>I3t,content_3764_2566:()=>G3t,content_3764_2568:()=>F3t,content_3764_2570:()=>q3t,content_3764_2572:()=>Q3t,content_3764_2574:()=>$3t,content_3764_2576:()=>e7t,content_3764_2578:()=>p7t,content_3764_258:()=>A3,content_3764_2580:()=>c7t,content_3764_2582:()=>l7t,content_3764_2584:()=>d7t,content_3764_2586:()=>k7t,content_3764_2588:()=>M7t,content_3764_2590:()=>w7t,content_3764_2592:()=>x7t,content_3764_2594:()=>L7t,content_3764_2596:()=>N7t,content_3764_2598:()=>P7t,content_3764_26:()=>iK,content_3764_260:()=>R3,content_3764_2600:()=>I7t,content_3764_2602:()=>G7t,content_3764_2604:()=>F7t,content_3764_2606:()=>q7t,content_3764_2608:()=>Q7t,content_3764_2610:()=>$7t,content_3764_2612:()=>e2t,content_3764_2614:()=>p2t,content_3764_2616:()=>c2t,content_3764_2618:()=>l2t,content_3764_262:()=>B3,content_3764_2620:()=>d2t,content_3764_2622:()=>k2t,content_3764_2624:()=>M2t,content_3764_2626:()=>w2t,content_3764_2628:()=>x2t,content_3764_2630:()=>L2t,content_3764_2632:()=>N2t,content_3764_2634:()=>P2t,content_3764_2636:()=>I2t,content_3764_2638:()=>G2t,content_3764_264:()=>O3,content_3764_2640:()=>F2t,content_3764_2642:()=>q2t,content_3764_2644:()=>Q2t,content_3764_2646:()=>$2t,content_3764_2648:()=>e1t,content_3764_2650:()=>p1t,content_3764_2652:()=>c1t,content_3764_2654:()=>l1t,content_3764_2656:()=>d1t,content_3764_2658:()=>k1t,content_3764_266:()=>V3,content_3764_2660:()=>M1t,content_3764_2662:()=>w1t,content_3764_2664:()=>x1t,content_3764_2666:()=>L1t,content_3764_2668:()=>N1t,content_3764_2670:()=>P1t,content_3764_2672:()=>I1t,content_3764_2674:()=>G1t,content_3764_2676:()=>F1t,content_3764_2678:()=>q1t,content_3764_268:()=>Y3,content_3764_2680:()=>Q1t,content_3764_2682:()=>$1t,content_3764_2684:()=>e8t,content_3764_2686:()=>p8t,content_3764_2688:()=>c8t,content_3764_2690:()=>l8t,content_3764_2692:()=>d8t,content_3764_2694:()=>k8t,content_3764_2696:()=>M8t,content_3764_2698:()=>w8t,content_3764_270:()=>K3,content_3764_2700:()=>x8t,content_3764_2702:()=>L8t,content_3764_2704:()=>N8t,content_3764_2706:()=>P8t,content_3764_2708:()=>I8t,content_3764_2710:()=>G8t,content_3764_2712:()=>F8t,content_3764_2714:()=>q8t,content_3764_2716:()=>Q8t,content_3764_2718:()=>$8t,content_3764_272:()=>t7,content_3764_2720:()=>e5t,content_3764_2722:()=>p5t,content_3764_2724:()=>c5t,content_3764_2726:()=>l5t,content_3764_2728:()=>d5t,content_3764_2730:()=>k5t,content_3764_2732:()=>M5t,content_3764_2734:()=>w5t,content_3764_2736:()=>x5t,content_3764_2738:()=>L5t,content_3764_274:()=>o7,content_3764_2740:()=>N5t,content_3764_2742:()=>P5t,content_3764_2744:()=>I5t,content_3764_2746:()=>G5t,content_3764_2748:()=>F5t,content_3764_2750:()=>q5t,content_3764_2752:()=>Q5t,content_3764_2754:()=>$5t,content_3764_2756:()=>e9t,content_3764_2758:()=>p9t,content_3764_276:()=>s7,content_3764_2760:()=>c9t,content_3764_2762:()=>l9t,content_3764_2764:()=>d9t,content_3764_2766:()=>k9t,content_3764_2768:()=>M9t,content_3764_2770:()=>w9t,content_3764_2772:()=>x9t,content_3764_2774:()=>L9t,content_3764_2776:()=>N9t,content_3764_2778:()=>P9t,content_3764_278:()=>i7,content_3764_2780:()=>I9t,content_3764_2782:()=>G9t,content_3764_2784:()=>F9t,content_3764_2786:()=>q9t,content_3764_2788:()=>Q9t,content_3764_2790:()=>$9t,content_3764_2792:()=>ete,content_3764_2794:()=>pte,content_3764_2796:()=>cte,content_3764_2798:()=>lte,content_3764_28:()=>mK,content_3764_280:()=>m7,content_3764_2800:()=>dte,content_3764_2802:()=>kte,content_3764_2804:()=>Mte,content_3764_2806:()=>wte,content_3764_2808:()=>xte,content_3764_2810:()=>Lte,content_3764_2812:()=>Nte,content_3764_2814:()=>Pte,content_3764_2816:()=>Ite,content_3764_2818:()=>Gte,content_3764_282:()=>f7,content_3764_2820:()=>Fte,content_3764_2822:()=>qte,content_3764_2824:()=>Qte,content_3764_2826:()=>$te,content_3764_2828:()=>eee,content_3764_2830:()=>pee,content_3764_2832:()=>cee,content_3764_2834:()=>lee,content_3764_2836:()=>dee,content_3764_2838:()=>kee,content_3764_284:()=>D7,content_3764_2840:()=>Mee,content_3764_2842:()=>wee,content_3764_2844:()=>xee,content_3764_2846:()=>Lee,content_3764_2848:()=>Nee,content_3764_2850:()=>Pee,content_3764_2852:()=>Iee,content_3764_2854:()=>Gee,content_3764_2856:()=>Fee,content_3764_2858:()=>qee,content_3764_286:()=>_7,content_3764_2860:()=>Qee,content_3764_2862:()=>$ee,content_3764_2864:()=>ene,content_3764_2866:()=>pne,content_3764_2868:()=>cne,content_3764_2870:()=>lne,content_3764_2872:()=>dne,content_3764_2874:()=>kne,content_3764_2876:()=>Mne,content_3764_2878:()=>wne,content_3764_288:()=>C7,content_3764_2880:()=>xne,content_3764_2882:()=>Lne,content_3764_2884:()=>Nne,content_3764_2886:()=>Pne,content_3764_2888:()=>Ine,content_3764_2890:()=>Gne,content_3764_2892:()=>Fne,content_3764_2894:()=>qne,content_3764_2896:()=>Qne,content_3764_2898:()=>$ne,content_3764_290:()=>v7,content_3764_2900:()=>eoe,content_3764_2902:()=>poe,content_3764_2904:()=>coe,content_3764_2906:()=>loe,content_3764_2908:()=>doe,content_3764_2910:()=>koe,content_3764_2912:()=>Moe,content_3764_2914:()=>woe,content_3764_2916:()=>xoe,content_3764_2918:()=>Loe,content_3764_292:()=>b7,content_3764_2920:()=>Noe,content_3764_2922:()=>Poe,content_3764_2924:()=>Ioe,content_3764_2926:()=>Goe,content_3764_2928:()=>Foe,content_3764_2930:()=>qoe,content_3764_2932:()=>Qoe,content_3764_2934:()=>$oe,content_3764_2936:()=>epe,content_3764_2938:()=>ppe,content_3764_294:()=>A7,content_3764_2940:()=>cpe,content_3764_2942:()=>lpe,content_3764_2944:()=>dpe,content_3764_2946:()=>kpe,content_3764_2948:()=>Mpe,content_3764_2950:()=>wpe,content_3764_2952:()=>xpe,content_3764_2954:()=>Lpe,content_3764_2956:()=>Npe,content_3764_2958:()=>Ppe,content_3764_296:()=>R7,content_3764_2960:()=>Ipe,content_3764_2962:()=>Gpe,content_3764_2964:()=>Fpe,content_3764_2966:()=>qpe,content_3764_2968:()=>Qpe,content_3764_2970:()=>$pe,content_3764_2972:()=>ere,content_3764_2974:()=>pre,content_3764_2976:()=>cre,content_3764_2978:()=>lre,content_3764_298:()=>B7,content_3764_2980:()=>dre,content_3764_2982:()=>kre,content_3764_2984:()=>Mre,content_3764_2986:()=>wre,content_3764_2988:()=>xre,content_3764_2990:()=>Lre,content_3764_2992:()=>Nre,content_3764_2994:()=>Pre,content_3764_2996:()=>Ire,content_3764_2998:()=>Gre,content_3764_30:()=>fK,content_3764_300:()=>O7,content_3764_3000:()=>Fre,content_3764_3002:()=>qre,content_3764_3004:()=>Qre,content_3764_3006:()=>$re,content_3764_3008:()=>ese,content_3764_3010:()=>pse,content_3764_3012:()=>cse,content_3764_3014:()=>lse,content_3764_3016:()=>dse,content_3764_3018:()=>kse,content_3764_302:()=>V7,content_3764_3020:()=>Mse,content_3764_3022:()=>wse,content_3764_3024:()=>xse,content_3764_3026:()=>Lse,content_3764_3028:()=>Nse,content_3764_3030:()=>Pse,content_3764_3032:()=>Ise,content_3764_3034:()=>Gse,content_3764_3036:()=>Fse,content_3764_3038:()=>qse,content_3764_304:()=>Y7,content_3764_3040:()=>Qse,content_3764_3042:()=>$se,content_3764_3044:()=>ece,content_3764_3046:()=>pce,content_3764_3048:()=>cce,content_3764_3050:()=>lce,content_3764_3052:()=>dce,content_3764_3054:()=>kce,content_3764_3056:()=>Mce,content_3764_3058:()=>wce,content_3764_306:()=>K7,content_3764_3060:()=>xce,content_3764_3062:()=>Lce,content_3764_3064:()=>Nce,content_3764_3066:()=>Pce,content_3764_3068:()=>Ice,content_3764_3070:()=>Gce,content_3764_3072:()=>Fce,content_3764_3074:()=>qce,content_3764_3076:()=>Qce,content_3764_3078:()=>$ce,content_3764_308:()=>t2,content_3764_3080:()=>eae,content_3764_3082:()=>pae,content_3764_3084:()=>cae,content_3764_3086:()=>lae,content_3764_3088:()=>dae,content_3764_3090:()=>kae,content_3764_3092:()=>Mae,content_3764_3094:()=>wae,content_3764_3096:()=>xae,content_3764_3098:()=>Lae,content_3764_310:()=>o2,content_3764_3100:()=>Nae,content_3764_3102:()=>Pae,content_3764_3104:()=>Iae,content_3764_3106:()=>Gae,content_3764_3108:()=>Fae,content_3764_3110:()=>qae,content_3764_3112:()=>Qae,content_3764_3114:()=>$ae,content_3764_3116:()=>eie,content_3764_3118:()=>pie,content_3764_312:()=>s2,content_3764_3120:()=>cie,content_3764_3122:()=>lie,content_3764_3124:()=>die,content_3764_3126:()=>kie,content_3764_3128:()=>Mie,content_3764_3130:()=>wie,content_3764_3132:()=>xie,content_3764_3134:()=>Lie,content_3764_3136:()=>Nie,content_3764_3138:()=>Pie,content_3764_314:()=>i2,content_3764_3140:()=>Iie,content_3764_3142:()=>Gie,content_3764_3144:()=>Fie,content_3764_3146:()=>qie,content_3764_3148:()=>Qie,content_3764_3150:()=>$ie,content_3764_3152:()=>ele,content_3764_3154:()=>ple,content_3764_3156:()=>cle,content_3764_3158:()=>lle,content_3764_316:()=>m2,content_3764_3160:()=>dle,content_3764_3162:()=>kle,content_3764_3164:()=>Mle,content_3764_3166:()=>wle,content_3764_3168:()=>xle,content_3764_3170:()=>Lle,content_3764_3172:()=>Nle,content_3764_3174:()=>Ple,content_3764_3176:()=>Ile,content_3764_3178:()=>Gle,content_3764_318:()=>f2,content_3764_3180:()=>Fle,content_3764_3182:()=>qle,content_3764_3184:()=>Qle,content_3764_3186:()=>$le,content_3764_3188:()=>eue,content_3764_3190:()=>pue,content_3764_3192:()=>cue,content_3764_3194:()=>lue,content_3764_3196:()=>due,content_3764_3198:()=>kue,content_3764_32:()=>DK,content_3764_320:()=>D2,content_3764_3200:()=>Mue,content_3764_3202:()=>wue,content_3764_3204:()=>xue,content_3764_3206:()=>Lue,content_3764_3208:()=>Nue,content_3764_3210:()=>Pue,content_3764_3212:()=>Iue,content_3764_3214:()=>Gue,content_3764_3216:()=>Fue,content_3764_3218:()=>que,content_3764_322:()=>_2,content_3764_3220:()=>Que,content_3764_3222:()=>$ue,content_3764_3224:()=>eme,content_3764_3226:()=>pme,content_3764_3228:()=>cme,content_3764_3230:()=>lme,content_3764_3232:()=>dme,content_3764_3234:()=>kme,content_3764_3236:()=>Mme,content_3764_3238:()=>wme,content_3764_324:()=>C2,content_3764_3240:()=>xme,content_3764_3242:()=>Lme,content_3764_3244:()=>Nme,content_3764_3246:()=>Pme,content_3764_3248:()=>Ime,content_3764_3250:()=>Gme,content_3764_3252:()=>Fme,content_3764_3254:()=>qme,content_3764_3256:()=>Qme,content_3764_3258:()=>$me,content_3764_326:()=>v2,content_3764_3260:()=>ede,content_3764_3262:()=>pde,content_3764_3264:()=>cde,content_3764_3266:()=>lde,content_3764_3268:()=>dde,content_3764_3270:()=>kde,content_3764_3272:()=>Mde,content_3764_3274:()=>wde,content_3764_3276:()=>xde,content_3764_3278:()=>Lde,content_3764_328:()=>b2,content_3764_3280:()=>Nde,content_3764_3282:()=>Pde,content_3764_3284:()=>Ide,content_3764_3286:()=>Gde,content_3764_3288:()=>Fde,content_3764_3290:()=>qde,content_3764_3292:()=>Qde,content_3764_3294:()=>$de,content_3764_3296:()=>ehe,content_3764_3298:()=>phe,content_3764_330:()=>A2,content_3764_3300:()=>che,content_3764_3302:()=>lhe,content_3764_3304:()=>dhe,content_3764_3306:()=>khe,content_3764_3308:()=>Mhe,content_3764_3310:()=>whe,content_3764_3312:()=>xhe,content_3764_3314:()=>Lhe,content_3764_3316:()=>Nhe,content_3764_3318:()=>Phe,content_3764_332:()=>R2,content_3764_3320:()=>Ihe,content_3764_3322:()=>Ghe,content_3764_3324:()=>Fhe,content_3764_3326:()=>qhe,content_3764_3328:()=>Qhe,content_3764_3330:()=>$he,content_3764_3332:()=>efe,content_3764_3334:()=>pfe,content_3764_3336:()=>cfe,content_3764_3338:()=>lfe,content_3764_334:()=>B2,content_3764_3340:()=>dfe,content_3764_3342:()=>kfe,content_3764_3344:()=>Mfe,content_3764_3346:()=>wfe,content_3764_3348:()=>xfe,content_3764_3350:()=>Lfe,content_3764_3352:()=>Nfe,content_3764_3354:()=>Pfe,content_3764_3356:()=>Ife,content_3764_3358:()=>Gfe,content_3764_336:()=>O2,content_3764_3360:()=>Ffe,content_3764_3362:()=>qfe,content_3764_3364:()=>Qfe,content_3764_3366:()=>$fe,content_3764_3368:()=>eke,content_3764_3370:()=>pke,content_3764_3372:()=>cke,content_3764_3374:()=>lke,content_3764_3376:()=>dke,content_3764_3378:()=>kke,content_3764_338:()=>V2,content_3764_3380:()=>Mke,content_3764_3382:()=>wke,content_3764_3384:()=>xke,content_3764_3386:()=>Lke,content_3764_3388:()=>Nke,content_3764_3390:()=>Pke,content_3764_3392:()=>Ike,content_3764_3394:()=>Gke,content_3764_3396:()=>Fke,content_3764_3398:()=>qke,content_3764_34:()=>_K,content_3764_340:()=>Y2,content_3764_3400:()=>Qke,content_3764_3402:()=>$ke,content_3764_3404:()=>eye,content_3764_3406:()=>pye,content_3764_3408:()=>cye,content_3764_3410:()=>lye,content_3764_3412:()=>dye,content_3764_3414:()=>kye,content_3764_3416:()=>Mye,content_3764_3418:()=>wye,content_3764_342:()=>K2,content_3764_3420:()=>xye,content_3764_3422:()=>Lye,content_3764_3424:()=>Nye,content_3764_3426:()=>Pye,content_3764_3428:()=>Iye,content_3764_3430:()=>Gye,content_3764_3432:()=>Fye,content_3764_3434:()=>qye,content_3764_3436:()=>Qye,content_3764_3438:()=>$ye,content_3764_344:()=>t1,content_3764_3440:()=>eDe,content_3764_3442:()=>pDe,content_3764_3444:()=>cDe,content_3764_3446:()=>lDe,content_3764_3448:()=>dDe,content_3764_3450:()=>kDe,content_3764_3452:()=>MDe,content_3764_3454:()=>wDe,content_3764_3456:()=>xDe,content_3764_3458:()=>LDe,content_3764_346:()=>o1,content_3764_3460:()=>NDe,content_3764_3462:()=>PDe,content_3764_3464:()=>IDe,content_3764_3466:()=>GDe,content_3764_3468:()=>FDe,content_3764_3470:()=>qDe,content_3764_3472:()=>QDe,content_3764_3474:()=>$De,content_3764_3476:()=>eMe,content_3764_3478:()=>pMe,content_3764_348:()=>s1,content_3764_3480:()=>cMe,content_3764_3482:()=>lMe,content_3764_3484:()=>dMe,content_3764_3486:()=>kMe,content_3764_3488:()=>MMe,content_3764_3490:()=>wMe,content_3764_3492:()=>xMe,content_3764_3494:()=>LMe,content_3764_3496:()=>NMe,content_3764_3498:()=>PMe,content_3764_350:()=>i1,content_3764_3500:()=>IMe,content_3764_3502:()=>GMe,content_3764_3504:()=>FMe,content_3764_3506:()=>qMe,content_3764_3508:()=>QMe,content_3764_3510:()=>$Me,content_3764_3512:()=>eXe,content_3764_3514:()=>pXe,content_3764_3516:()=>cXe,content_3764_3518:()=>lXe,content_3764_352:()=>m1,content_3764_3520:()=>dXe,content_3764_3522:()=>kXe,content_3764_3524:()=>MXe,content_3764_3526:()=>wXe,content_3764_3528:()=>xXe,content_3764_3530:()=>LXe,content_3764_3532:()=>NXe,content_3764_3534:()=>PXe,content_3764_3536:()=>IXe,content_3764_3538:()=>GXe,content_3764_354:()=>f1,content_3764_3540:()=>FXe,content_3764_3542:()=>qXe,content_3764_3544:()=>QXe,content_3764_3546:()=>$Xe,content_3764_3548:()=>e_e,content_3764_3550:()=>p_e,content_3764_3552:()=>c_e,content_3764_3554:()=>l_e,content_3764_3556:()=>d_e,content_3764_3558:()=>k_e,content_3764_356:()=>D1,content_3764_3560:()=>M_e,content_3764_3562:()=>w_e,content_3764_3564:()=>x_e,content_3764_3566:()=>L_e,content_3764_3568:()=>N_e,content_3764_3570:()=>P_e,content_3764_3572:()=>I_e,content_3764_3574:()=>G_e,content_3764_3576:()=>F_e,content_3764_3578:()=>q_e,content_3764_358:()=>_1,content_3764_3580:()=>Q_e,content_3764_3582:()=>$_e,content_3764_3584:()=>ewe,content_3764_3586:()=>pwe,content_3764_3588:()=>cwe,content_3764_3590:()=>lwe,content_3764_3592:()=>dwe,content_3764_3594:()=>kwe,content_3764_3596:()=>Mwe,content_3764_3598:()=>wwe,content_3764_36:()=>CK,content_3764_360:()=>C1,content_3764_3600:()=>xwe,content_3764_3602:()=>Lwe,content_3764_3604:()=>Nwe,content_3764_3606:()=>Pwe,content_3764_3608:()=>Iwe,content_3764_3610:()=>Gwe,content_3764_3612:()=>Fwe,content_3764_3614:()=>qwe,content_3764_3616:()=>Qwe,content_3764_3618:()=>$we,content_3764_362:()=>v1,content_3764_3620:()=>eTe,content_3764_3622:()=>pTe,content_3764_3624:()=>cTe,content_3764_3626:()=>lTe,content_3764_3628:()=>dTe,content_3764_3630:()=>kTe,content_3764_3632:()=>MTe,content_3764_3634:()=>wTe,content_3764_3636:()=>xTe,content_3764_3638:()=>LTe,content_3764_364:()=>b1,content_3764_3640:()=>NTe,content_3764_3642:()=>PTe,content_3764_3644:()=>ITe,content_3764_3646:()=>GTe,content_3764_3648:()=>FTe,content_3764_3650:()=>qTe,content_3764_3652:()=>QTe,content_3764_3654:()=>$Te,content_3764_3656:()=>eCe,content_3764_3658:()=>pCe,content_3764_366:()=>A1,content_3764_3660:()=>cCe,content_3764_3662:()=>lCe,content_3764_3664:()=>dCe,content_3764_3666:()=>kCe,content_3764_3668:()=>MCe,content_3764_3670:()=>wCe,content_3764_3672:()=>xCe,content_3764_3674:()=>LCe,content_3764_3676:()=>NCe,content_3764_3678:()=>PCe,content_3764_368:()=>R1,content_3764_3680:()=>ICe,content_3764_3682:()=>GCe,content_3764_3684:()=>FCe,content_3764_3686:()=>qCe,content_3764_3688:()=>QCe,content_3764_3690:()=>$Ce,content_3764_3692:()=>exe,content_3764_3694:()=>pxe,content_3764_3696:()=>cxe,content_3764_3698:()=>lxe,content_3764_370:()=>B1,content_3764_3700:()=>dxe,content_3764_3702:()=>kxe,content_3764_3704:()=>Mxe,content_3764_3706:()=>wxe,content_3764_3708:()=>xxe,content_3764_3710:()=>Lxe,content_3764_3712:()=>Nxe,content_3764_3714:()=>Pxe,content_3764_3716:()=>Ixe,content_3764_3718:()=>Gxe,content_3764_372:()=>O1,content_3764_3720:()=>Fxe,content_3764_3722:()=>qxe,content_3764_3724:()=>Qxe,content_3764_3726:()=>$xe,content_3764_3728:()=>ege,content_3764_3730:()=>pge,content_3764_3732:()=>cge,content_3764_3734:()=>lge,content_3764_3736:()=>dge,content_3764_3738:()=>kge,content_3764_374:()=>V1,content_3764_3740:()=>Mge,content_3764_3742:()=>wge,content_3764_3744:()=>xge,content_3764_3746:()=>Lge,content_3764_3748:()=>Nge,content_3764_3750:()=>Pge,content_3764_3752:()=>Ige,content_3764_3754:()=>Gge,content_3764_3756:()=>Fge,content_3764_3758:()=>qge,content_3764_376:()=>Y1,content_3764_3760:()=>Qge,content_3764_3762:()=>$ge,content_3764_3764:()=>eve,content_3764_3766:()=>pve,content_3764_3768:()=>cve,content_3764_3770:()=>lve,content_3764_3772:()=>dve,content_3764_3774:()=>kve,content_3764_3776:()=>Mve,content_3764_3778:()=>wve,content_3764_378:()=>K1,content_3764_3780:()=>xve,content_3764_3782:()=>Lve,content_3764_3784:()=>Nve,content_3764_3786:()=>Pve,content_3764_3788:()=>Ive,content_3764_3790:()=>Gve,content_3764_3792:()=>Fve,content_3764_3794:()=>qve,content_3764_3796:()=>Qve,content_3764_3798:()=>$ve,content_3764_38:()=>vK,content_3764_380:()=>t8,content_3764_3800:()=>eLe,content_3764_3802:()=>pLe,content_3764_3804:()=>cLe,content_3764_3806:()=>lLe,content_3764_3808:()=>dLe,content_3764_3810:()=>kLe,content_3764_3812:()=>MLe,content_3764_3814:()=>wLe,content_3764_3816:()=>xLe,content_3764_3818:()=>LLe,content_3764_382:()=>o8,content_3764_3820:()=>NLe,content_3764_3822:()=>PLe,content_3764_3824:()=>ILe,content_3764_3826:()=>GLe,content_3764_3828:()=>FLe,content_3764_3830:()=>qLe,content_3764_3832:()=>QLe,content_3764_3834:()=>$Le,content_3764_3836:()=>eZe,content_3764_3838:()=>pZe,content_3764_384:()=>s8,content_3764_3840:()=>cZe,content_3764_3842:()=>lZe,content_3764_3844:()=>dZe,content_3764_3846:()=>kZe,content_3764_3848:()=>MZe,content_3764_3850:()=>wZe,content_3764_3852:()=>xZe,content_3764_3854:()=>LZe,content_3764_3856:()=>NZe,content_3764_3858:()=>PZe,content_3764_386:()=>i8,content_3764_3860:()=>IZe,content_3764_3862:()=>GZe,content_3764_3864:()=>FZe,content_3764_3866:()=>qZe,content_3764_3868:()=>QZe,content_3764_3870:()=>$Ze,content_3764_3872:()=>ebe,content_3764_3874:()=>pbe,content_3764_3876:()=>cbe,content_3764_3878:()=>lbe,content_3764_388:()=>m8,content_3764_3880:()=>dbe,content_3764_3882:()=>kbe,content_3764_3884:()=>Mbe,content_3764_3886:()=>wbe,content_3764_3888:()=>xbe,content_3764_3890:()=>Lbe,content_3764_3892:()=>Nbe,content_3764_3894:()=>Pbe,content_3764_3896:()=>Ibe,content_3764_3898:()=>Gbe,content_3764_390:()=>f8,content_3764_3900:()=>Fbe,content_3764_3902:()=>qbe,content_3764_3904:()=>Qbe,content_3764_3906:()=>$be,content_3764_3908:()=>eNe,content_3764_3910:()=>pNe,content_3764_3912:()=>cNe,content_3764_3914:()=>lNe,content_3764_3916:()=>dNe,content_3764_3918:()=>kNe,content_3764_392:()=>D8,content_3764_3920:()=>MNe,content_3764_3922:()=>wNe,content_3764_3924:()=>xNe,content_3764_3926:()=>LNe,content_3764_3928:()=>NNe,content_3764_3930:()=>PNe,content_3764_3932:()=>INe,content_3764_3934:()=>GNe,content_3764_3936:()=>FNe,content_3764_3938:()=>qNe,content_3764_394:()=>_8,content_3764_3940:()=>QNe,content_3764_3942:()=>$Ne,content_3764_3944:()=>eze,content_3764_3946:()=>pze,content_3764_3948:()=>cze,content_3764_3950:()=>lze,content_3764_3952:()=>dze,content_3764_3954:()=>kze,content_3764_3956:()=>Mze,content_3764_3958:()=>wze,content_3764_396:()=>C8,content_3764_3960:()=>xze,content_3764_3962:()=>Lze,content_3764_3964:()=>Nze,content_3764_3966:()=>Pze,content_3764_3968:()=>Ize,content_3764_3970:()=>Gze,content_3764_3972:()=>Fze,content_3764_3974:()=>qze,content_3764_3976:()=>Qze,content_3764_3978:()=>$ze,content_3764_398:()=>v8,content_3764_3980:()=>eAe,content_3764_3982:()=>pAe,content_3764_3984:()=>cAe,content_3764_3986:()=>lAe,content_3764_3988:()=>dAe,content_3764_3990:()=>kAe,content_3764_3992:()=>MAe,content_3764_3994:()=>wAe,content_3764_3996:()=>xAe,content_3764_3998:()=>LAe,content_3764_4:()=>bH,content_3764_40:()=>bK,content_3764_400:()=>b8,content_3764_4000:()=>NAe,content_3764_4002:()=>PAe,content_3764_4004:()=>IAe,content_3764_4006:()=>GAe,content_3764_4008:()=>FAe,content_3764_4010:()=>qAe,content_3764_4012:()=>QAe,content_3764_4014:()=>$Ae,content_3764_4016:()=>ePe,content_3764_4018:()=>pPe,content_3764_402:()=>A8,content_3764_4020:()=>cPe,content_3764_4022:()=>lPe,content_3764_4024:()=>dPe,content_3764_4026:()=>kPe,content_3764_4028:()=>MPe,content_3764_4030:()=>wPe,content_3764_4032:()=>xPe,content_3764_4034:()=>LPe,content_3764_4036:()=>NPe,content_3764_4038:()=>PPe,content_3764_404:()=>R8,content_3764_4040:()=>IPe,content_3764_4042:()=>GPe,content_3764_4044:()=>FPe,content_3764_4046:()=>qPe,content_3764_4048:()=>QPe,content_3764_4050:()=>$Pe,content_3764_4052:()=>eWe,content_3764_4054:()=>pWe,content_3764_4056:()=>cWe,content_3764_4058:()=>lWe,content_3764_406:()=>B8,content_3764_4060:()=>dWe,content_3764_4062:()=>kWe,content_3764_4064:()=>MWe,content_3764_4066:()=>wWe,content_3764_4068:()=>xWe,content_3764_4070:()=>LWe,content_3764_4072:()=>NWe,content_3764_4074:()=>PWe,content_3764_4076:()=>IWe,content_3764_4078:()=>GWe,content_3764_408:()=>O8,content_3764_4080:()=>FWe,content_3764_4082:()=>qWe,content_3764_4084:()=>QWe,content_3764_4086:()=>$We,content_3764_4088:()=>eRe,content_3764_4090:()=>pRe,content_3764_4092:()=>cRe,content_3764_4094:()=>lRe,content_3764_4096:()=>dRe,content_3764_4098:()=>kRe,content_3764_410:()=>V8,content_3764_4100:()=>MRe,content_3764_4102:()=>wRe,content_3764_4104:()=>xRe,content_3764_4106:()=>LRe,content_3764_4108:()=>NRe,content_3764_4110:()=>PRe,content_3764_4112:()=>IRe,content_3764_4114:()=>GRe,content_3764_4116:()=>FRe,content_3764_4118:()=>qRe,content_3764_412:()=>Y8,content_3764_4120:()=>QRe,content_3764_4122:()=>$Re,content_3764_4124:()=>eIe,content_3764_4126:()=>pIe,content_3764_4128:()=>cIe,content_3764_4130:()=>lIe,content_3764_4132:()=>dIe,content_3764_4134:()=>kIe,content_3764_4136:()=>MIe,content_3764_4138:()=>wIe,content_3764_414:()=>K8,content_3764_4140:()=>xIe,content_3764_4142:()=>LIe,content_3764_4144:()=>NIe,content_3764_4146:()=>PIe,content_3764_4148:()=>IIe,content_3764_4150:()=>GIe,content_3764_4152:()=>FIe,content_3764_4154:()=>qIe,content_3764_4156:()=>QIe,content_3764_4158:()=>$Ie,content_3764_416:()=>t5,content_3764_4160:()=>eSe,content_3764_4162:()=>pSe,content_3764_4164:()=>cSe,content_3764_4166:()=>lSe,content_3764_4168:()=>dSe,content_3764_4170:()=>kSe,content_3764_4172:()=>MSe,content_3764_4174:()=>wSe,content_3764_4176:()=>xSe,content_3764_4178:()=>LSe,content_3764_418:()=>o5,content_3764_4180:()=>NSe,content_3764_4182:()=>PSe,content_3764_4184:()=>ISe,content_3764_4186:()=>GSe,content_3764_4188:()=>FSe,content_3764_4190:()=>qSe,content_3764_4192:()=>QSe,content_3764_4194:()=>$Se,content_3764_4196:()=>eBe,content_3764_4198:()=>pBe,content_3764_42:()=>AK,content_3764_420:()=>s5,content_3764_4200:()=>cBe,content_3764_4202:()=>lBe,content_3764_4204:()=>dBe,content_3764_4206:()=>kBe,content_3764_4208:()=>MBe,content_3764_4210:()=>wBe,content_3764_4212:()=>xBe,content_3764_4214:()=>LBe,content_3764_4216:()=>NBe,content_3764_4218:()=>PBe,content_3764_422:()=>i5,content_3764_4220:()=>IBe,content_3764_4222:()=>GBe,content_3764_4224:()=>FBe,content_3764_4226:()=>qBe,content_3764_4228:()=>QBe,content_3764_4230:()=>$Be,content_3764_4232:()=>eGe,content_3764_4234:()=>pGe,content_3764_4236:()=>cGe,content_3764_4238:()=>lGe,content_3764_424:()=>m5,content_3764_4240:()=>dGe,content_3764_4242:()=>kGe,content_3764_4244:()=>MGe,content_3764_4246:()=>wGe,content_3764_4248:()=>xGe,content_3764_4250:()=>LGe,content_3764_4252:()=>NGe,content_3764_4254:()=>PGe,content_3764_4256:()=>IGe,content_3764_4258:()=>GGe,content_3764_426:()=>f5,content_3764_4260:()=>FGe,content_3764_4262:()=>qGe,content_3764_4264:()=>QGe,content_3764_4266:()=>$Ge,content_3764_4268:()=>eEe,content_3764_4270:()=>pEe,content_3764_4272:()=>cEe,content_3764_4274:()=>lEe,content_3764_4276:()=>dEe,content_3764_4278:()=>kEe,content_3764_428:()=>D5,content_3764_4280:()=>MEe,content_3764_4282:()=>wEe,content_3764_4284:()=>xEe,content_3764_4286:()=>LEe,content_3764_4288:()=>NEe,content_3764_4290:()=>PEe,content_3764_4292:()=>IEe,content_3764_4294:()=>GEe,content_3764_4296:()=>FEe,content_3764_4298:()=>qEe,content_3764_430:()=>_5,content_3764_4300:()=>QEe,content_3764_4302:()=>$Ee,content_3764_4304:()=>eOe,content_3764_4306:()=>pOe,content_3764_4308:()=>cOe,content_3764_4310:()=>lOe,content_3764_4312:()=>dOe,content_3764_4314:()=>kOe,content_3764_4316:()=>MOe,content_3764_4318:()=>wOe,content_3764_432:()=>C5,content_3764_4320:()=>xOe,content_3764_4322:()=>LOe,content_3764_4324:()=>NOe,content_3764_4326:()=>POe,content_3764_4328:()=>IOe,content_3764_4330:()=>GOe,content_3764_4332:()=>FOe,content_3764_4334:()=>qOe,content_3764_4336:()=>QOe,content_3764_4338:()=>$Oe,content_3764_434:()=>v5,content_3764_4340:()=>eFe,content_3764_4342:()=>pFe,content_3764_4344:()=>cFe,content_3764_4346:()=>lFe,content_3764_4348:()=>dFe,content_3764_4350:()=>kFe,content_3764_4352:()=>MFe,content_3764_4354:()=>wFe,content_3764_4356:()=>xFe,content_3764_4358:()=>LFe,content_3764_436:()=>b5,content_3764_4360:()=>NFe,content_3764_4362:()=>PFe,content_3764_4364:()=>IFe,content_3764_4366:()=>GFe,content_3764_4368:()=>FFe,content_3764_4370:()=>qFe,content_3764_4372:()=>QFe,content_3764_4374:()=>$Fe,content_3764_4376:()=>eUe,content_3764_4378:()=>pUe,content_3764_438:()=>A5,content_3764_4380:()=>cUe,content_3764_4382:()=>lUe,content_3764_4384:()=>dUe,content_3764_4386:()=>kUe,content_3764_4388:()=>MUe,content_3764_4390:()=>wUe,content_3764_4392:()=>xUe,content_3764_4394:()=>LUe,content_3764_4396:()=>NUe,content_3764_4398:()=>PUe,content_3764_44:()=>RK,content_3764_440:()=>R5,content_3764_4400:()=>IUe,content_3764_4402:()=>GUe,content_3764_4404:()=>FUe,content_3764_4406:()=>qUe,content_3764_4408:()=>QUe,content_3764_4410:()=>$Ue,content_3764_4412:()=>eVe,content_3764_4414:()=>pVe,content_3764_4416:()=>cVe,content_3764_4418:()=>lVe,content_3764_442:()=>B5,content_3764_4420:()=>dVe,content_3764_4422:()=>kVe,content_3764_4424:()=>MVe,content_3764_4426:()=>wVe,content_3764_4428:()=>xVe,content_3764_4430:()=>LVe,content_3764_4432:()=>NVe,content_3764_4434:()=>PVe,content_3764_4436:()=>IVe,content_3764_4438:()=>GVe,content_3764_444:()=>O5,content_3764_4440:()=>FVe,content_3764_4442:()=>qVe,content_3764_4444:()=>QVe,content_3764_4446:()=>$Ve,content_3764_4448:()=>eqe,content_3764_4450:()=>pqe,content_3764_4452:()=>cqe,content_3764_4454:()=>lqe,content_3764_4456:()=>dqe,content_3764_4458:()=>kqe,content_3764_446:()=>V5,content_3764_4460:()=>Mqe,content_3764_4462:()=>wqe,content_3764_4464:()=>xqe,content_3764_4466:()=>Lqe,content_3764_4468:()=>Nqe,content_3764_4470:()=>Pqe,content_3764_4472:()=>Iqe,content_3764_4474:()=>Gqe,content_3764_4476:()=>Fqe,content_3764_4478:()=>qqe,content_3764_448:()=>Y5,content_3764_4480:()=>Qqe,content_3764_4482:()=>$qe,content_3764_4484:()=>eje,content_3764_4486:()=>pje,content_3764_4488:()=>cje,content_3764_4490:()=>lje,content_3764_4492:()=>dje,content_3764_4494:()=>kje,content_3764_4496:()=>Mje,content_3764_4498:()=>wje,content_3764_450:()=>K5,content_3764_4500:()=>xje,content_3764_4502:()=>Lje,content_3764_4504:()=>Nje,content_3764_4506:()=>Pje,content_3764_4508:()=>Ije,content_3764_4510:()=>Gje,content_3764_4512:()=>Fje,content_3764_4514:()=>qje,content_3764_4516:()=>Qje,content_3764_4518:()=>$je,content_3764_452:()=>t9,content_3764_4520:()=>eYe,content_3764_4522:()=>pYe,content_3764_4524:()=>cYe,content_3764_4526:()=>lYe,content_3764_4528:()=>dYe,content_3764_4530:()=>kYe,content_3764_4532:()=>MYe,content_3764_4534:()=>wYe,content_3764_4536:()=>xYe,content_3764_4538:()=>LYe,content_3764_454:()=>o9,content_3764_4540:()=>NYe,content_3764_4542:()=>PYe,content_3764_4544:()=>IYe,content_3764_4546:()=>GYe,content_3764_4548:()=>FYe,content_3764_4550:()=>qYe,content_3764_4552:()=>QYe,content_3764_4554:()=>$Ye,content_3764_4556:()=>eQe,content_3764_4558:()=>pQe,content_3764_456:()=>s9,content_3764_4560:()=>cQe,content_3764_4562:()=>lQe,content_3764_4564:()=>dQe,content_3764_4566:()=>kQe,content_3764_4568:()=>MQe,content_3764_4570:()=>wQe,content_3764_4572:()=>xQe,content_3764_4574:()=>LQe,content_3764_4576:()=>NQe,content_3764_4578:()=>PQe,content_3764_458:()=>i9,content_3764_4580:()=>IQe,content_3764_4582:()=>GQe,content_3764_4584:()=>FQe,content_3764_4586:()=>qQe,content_3764_4588:()=>QQe,content_3764_4590:()=>$Qe,content_3764_4592:()=>eHe,content_3764_4594:()=>pHe,content_3764_4596:()=>cHe,content_3764_4598:()=>lHe,content_3764_46:()=>BK,content_3764_460:()=>m9,content_3764_4600:()=>dHe,content_3764_4602:()=>kHe,content_3764_4604:()=>MHe,content_3764_4606:()=>wHe,content_3764_4608:()=>xHe,content_3764_4610:()=>LHe,content_3764_4612:()=>NHe,content_3764_4614:()=>PHe,content_3764_4616:()=>IHe,content_3764_4618:()=>GHe,content_3764_462:()=>f9,content_3764_4620:()=>FHe,content_3764_4622:()=>qHe,content_3764_4624:()=>QHe,content_3764_4626:()=>$He,content_3764_4628:()=>eKe,content_3764_4630:()=>pKe,content_3764_4632:()=>cKe,content_3764_4634:()=>lKe,content_3764_4636:()=>dKe,content_3764_4638:()=>kKe,content_3764_464:()=>D9,content_3764_4640:()=>MKe,content_3764_4642:()=>wKe,content_3764_4644:()=>xKe,content_3764_4646:()=>LKe,content_3764_4648:()=>NKe,content_3764_4650:()=>PKe,content_3764_4652:()=>IKe,content_3764_4654:()=>GKe,content_3764_4656:()=>FKe,content_3764_4658:()=>qKe,content_3764_466:()=>_9,content_3764_4660:()=>QKe,content_3764_4662:()=>$Ke,content_3764_4664:()=>e$e,content_3764_4666:()=>p$e,content_3764_4668:()=>c$e,content_3764_4670:()=>l$e,content_3764_4672:()=>d$e,content_3764_4674:()=>k$e,content_3764_4676:()=>M$e,content_3764_4678:()=>w$e,content_3764_468:()=>C9,content_3764_4680:()=>x$e,content_3764_4682:()=>L$e,content_3764_4684:()=>N$e,content_3764_4686:()=>P$e,content_3764_4688:()=>I$e,content_3764_4690:()=>G$e,content_3764_4692:()=>F$e,content_3764_4694:()=>q$e,content_3764_4696:()=>Q$e,content_3764_4698:()=>$$e,content_3764_470:()=>v9,content_3764_4700:()=>eJe,content_3764_4702:()=>pJe,content_3764_4704:()=>cJe,content_3764_4706:()=>lJe,content_3764_4708:()=>dJe,content_3764_4710:()=>kJe,content_3764_4712:()=>MJe,content_3764_4714:()=>wJe,content_3764_4716:()=>xJe,content_3764_4718:()=>LJe,content_3764_472:()=>b9,content_3764_4720:()=>NJe,content_3764_4722:()=>PJe,content_3764_4724:()=>IJe,content_3764_4726:()=>GJe,content_3764_4728:()=>FJe,content_3764_4730:()=>qJe,content_3764_4732:()=>QJe,content_3764_4734:()=>$Je,content_3764_4736:()=>e0e,content_3764_4738:()=>p0e,content_3764_474:()=>A9,content_3764_4740:()=>c0e,content_3764_4742:()=>l0e,content_3764_4744:()=>d0e,content_3764_4746:()=>k0e,content_3764_4748:()=>M0e,content_3764_4750:()=>w0e,content_3764_4752:()=>x0e,content_3764_4754:()=>L0e,content_3764_4756:()=>N0e,content_3764_4758:()=>P0e,content_3764_476:()=>R9,content_3764_4760:()=>I0e,content_3764_4762:()=>G0e,content_3764_4764:()=>F0e,content_3764_4766:()=>q0e,content_3764_4768:()=>Q0e,content_3764_4770:()=>$0e,content_3764_4772:()=>e4e,content_3764_4774:()=>p4e,content_3764_4776:()=>c4e,content_3764_4778:()=>l4e,content_3764_478:()=>B9,content_3764_4780:()=>d4e,content_3764_4782:()=>k4e,content_3764_4784:()=>M4e,content_3764_4786:()=>w4e,content_3764_4788:()=>x4e,content_3764_4790:()=>L4e,content_3764_4792:()=>N4e,content_3764_4794:()=>P4e,content_3764_4796:()=>I4e,content_3764_4798:()=>G4e,content_3764_48:()=>OK,content_3764_480:()=>O9,content_3764_4800:()=>F4e,content_3764_4802:()=>q4e,content_3764_4804:()=>Q4e,content_3764_4806:()=>$4e,content_3764_4808:()=>e6e,content_3764_4810:()=>p6e,content_3764_4812:()=>c6e,content_3764_4814:()=>l6e,content_3764_4816:()=>d6e,content_3764_4818:()=>k6e,content_3764_482:()=>V9,content_3764_4820:()=>M6e,content_3764_4822:()=>w6e,content_3764_4824:()=>x6e,content_3764_4826:()=>L6e,content_3764_4828:()=>N6e,content_3764_4830:()=>P6e,content_3764_4832:()=>I6e,content_3764_4834:()=>G6e,content_3764_4836:()=>F6e,content_3764_4838:()=>q6e,content_3764_484:()=>Y9,content_3764_4840:()=>Q6e,content_3764_4842:()=>$6e,content_3764_4844:()=>e3e,content_3764_4846:()=>p3e,content_3764_4848:()=>c3e,content_3764_4850:()=>l3e,content_3764_4852:()=>d3e,content_3764_4854:()=>k3e,content_3764_4856:()=>M3e,content_3764_4858:()=>w3e,content_3764_486:()=>K9,content_3764_4860:()=>x3e,content_3764_4862:()=>L3e,content_3764_4864:()=>N3e,content_3764_4866:()=>P3e,content_3764_4868:()=>I3e,content_3764_4870:()=>G3e,content_3764_4872:()=>F3e,content_3764_4874:()=>q3e,content_3764_4876:()=>Q3e,content_3764_4878:()=>$3e,content_3764_488:()=>ttt,content_3764_4880:()=>e7e,content_3764_4882:()=>p7e,content_3764_4884:()=>c7e,content_3764_4886:()=>l7e,content_3764_4888:()=>d7e,content_3764_4890:()=>k7e,content_3764_4892:()=>M7e,content_3764_4894:()=>w7e,content_3764_4896:()=>x7e,content_3764_4898:()=>L7e,content_3764_490:()=>ott,content_3764_4900:()=>N7e,content_3764_4902:()=>P7e,content_3764_4904:()=>I7e,content_3764_4906:()=>G7e,content_3764_4908:()=>F7e,content_3764_4910:()=>q7e,content_3764_4912:()=>Q7e,content_3764_4914:()=>$7e,content_3764_4916:()=>e2e,content_3764_4918:()=>p2e,content_3764_492:()=>stt,content_3764_4920:()=>c2e,content_3764_4922:()=>l2e,content_3764_4924:()=>d2e,content_3764_4926:()=>k2e,content_3764_4928:()=>M2e,content_3764_4930:()=>w2e,content_3764_4932:()=>x2e,content_3764_4934:()=>L2e,content_3764_4936:()=>N2e,content_3764_4938:()=>P2e,content_3764_494:()=>itt,content_3764_4940:()=>I2e,content_3764_4942:()=>G2e,content_3764_4944:()=>F2e,content_3764_4946:()=>q2e,content_3764_4948:()=>Q2e,content_3764_4950:()=>$2e,content_3764_4952:()=>e1e,content_3764_4954:()=>p1e,content_3764_4956:()=>c1e,content_3764_4958:()=>l1e,content_3764_496:()=>mtt,content_3764_4960:()=>d1e,content_3764_4962:()=>k1e,content_3764_4964:()=>M1e,content_3764_4966:()=>w1e,content_3764_4968:()=>x1e,content_3764_4970:()=>L1e,content_3764_4972:()=>N1e,content_3764_4974:()=>P1e,content_3764_4976:()=>I1e,content_3764_4978:()=>G1e,content_3764_498:()=>ftt,content_3764_4980:()=>F1e,content_3764_4982:()=>q1e,content_3764_4984:()=>Q1e,content_3764_4986:()=>$1e,content_3764_4988:()=>e8e,content_3764_4990:()=>p8e,content_3764_4992:()=>c8e,content_3764_4994:()=>l8e,content_3764_4996:()=>d8e,content_3764_4998:()=>k8e,content_3764_50:()=>VK,content_3764_500:()=>Dtt,content_3764_5000:()=>M8e,content_3764_5002:()=>w8e,content_3764_5004:()=>x8e,content_3764_5006:()=>L8e,content_3764_5008:()=>N8e,content_3764_5010:()=>P8e,content_3764_5012:()=>I8e,content_3764_5014:()=>G8e,content_3764_5016:()=>F8e,content_3764_5018:()=>q8e,content_3764_502:()=>_tt,content_3764_5020:()=>Q8e,content_3764_5022:()=>$8e,content_3764_5024:()=>e5e,content_3764_5026:()=>p5e,content_3764_5028:()=>c5e,content_3764_5030:()=>l5e,content_3764_5032:()=>d5e,content_3764_5034:()=>k5e,content_3764_5036:()=>M5e,content_3764_5038:()=>w5e,content_3764_504:()=>Ctt,content_3764_5040:()=>x5e,content_3764_5042:()=>L5e,content_3764_5044:()=>N5e,content_3764_5046:()=>P5e,content_3764_5048:()=>I5e,content_3764_5050:()=>G5e,content_3764_5052:()=>F5e,content_3764_5054:()=>q5e,content_3764_5056:()=>Q5e,content_3764_5058:()=>$5e,content_3764_506:()=>vtt,content_3764_5060:()=>e9e,content_3764_5062:()=>p9e,content_3764_5064:()=>c9e,content_3764_5066:()=>l9e,content_3764_5068:()=>d9e,content_3764_5070:()=>k9e,content_3764_5072:()=>M9e,content_3764_5074:()=>w9e,content_3764_5076:()=>x9e,content_3764_5078:()=>L9e,content_3764_508:()=>btt,content_3764_5080:()=>N9e,content_3764_5082:()=>P9e,content_3764_5084:()=>I9e,content_3764_5086:()=>G9e,content_3764_5088:()=>F9e,content_3764_5090:()=>q9e,content_3764_5092:()=>Q9e,content_3764_5094:()=>$9e,content_3764_5096:()=>etn,content_3764_5098:()=>ptn,content_3764_510:()=>Att,content_3764_5100:()=>ctn,content_3764_5102:()=>ltn,content_3764_5104:()=>dtn,content_3764_5106:()=>ktn,content_3764_5108:()=>Mtn,content_3764_5110:()=>wtn,content_3764_5112:()=>xtn,content_3764_5114:()=>Ltn,content_3764_5116:()=>Ntn,content_3764_5118:()=>Ptn,content_3764_512:()=>Rtt,content_3764_5120:()=>Itn,content_3764_5122:()=>Gtn,content_3764_5124:()=>Ftn,content_3764_5126:()=>qtn,content_3764_5128:()=>Qtn,content_3764_5130:()=>$tn,content_3764_5132:()=>een,content_3764_5134:()=>pen,content_3764_5136:()=>cen,content_3764_5138:()=>len,content_3764_514:()=>Btt,content_3764_5140:()=>den,content_3764_5142:()=>ken,content_3764_5144:()=>Men,content_3764_5146:()=>wen,content_3764_5148:()=>xen,content_3764_5150:()=>Len,content_3764_5152:()=>Nen,content_3764_5154:()=>Pen,content_3764_5156:()=>Ien,content_3764_5158:()=>Gen,content_3764_516:()=>Ott,content_3764_5160:()=>Fen,content_3764_5162:()=>qen,content_3764_5164:()=>Qen,content_3764_5166:()=>$en,content_3764_5168:()=>enn,content_3764_5170:()=>pnn,content_3764_5172:()=>cnn,content_3764_5174:()=>lnn,content_3764_5176:()=>dnn,content_3764_5178:()=>knn,content_3764_518:()=>Vtt,content_3764_5180:()=>Mnn,content_3764_5182:()=>wnn,content_3764_5184:()=>xnn,content_3764_5186:()=>Lnn,content_3764_5188:()=>Nnn,content_3764_5190:()=>Pnn,content_3764_5192:()=>Inn,content_3764_5194:()=>Gnn,content_3764_5196:()=>Fnn,content_3764_5198:()=>qnn,content_3764_52:()=>YK,content_3764_520:()=>Ytt,content_3764_5200:()=>Qnn,content_3764_5202:()=>$nn,content_3764_5204:()=>eon,content_3764_5206:()=>pon,content_3764_5208:()=>con,content_3764_5210:()=>lon,content_3764_5212:()=>don,content_3764_5214:()=>kon,content_3764_5216:()=>Mon,content_3764_5218:()=>won,content_3764_522:()=>Ktt,content_3764_5220:()=>xon,content_3764_5222:()=>Lon,content_3764_5224:()=>Non,content_3764_5226:()=>Pon,content_3764_5228:()=>Ion,content_3764_5230:()=>Gon,content_3764_5232:()=>Fon,content_3764_5234:()=>qon,content_3764_5236:()=>Qon,content_3764_5238:()=>$on,content_3764_524:()=>tet,content_3764_5240:()=>epn,content_3764_5242:()=>ppn,content_3764_5244:()=>cpn,content_3764_5246:()=>lpn,content_3764_5248:()=>dpn,content_3764_5250:()=>kpn,content_3764_5252:()=>Mpn,content_3764_5254:()=>wpn,content_3764_5256:()=>xpn,content_3764_5258:()=>Lpn,content_3764_526:()=>oet,content_3764_5260:()=>Npn,content_3764_5262:()=>Ppn,content_3764_5264:()=>Ipn,content_3764_5266:()=>Gpn,content_3764_5268:()=>Fpn,content_3764_5270:()=>qpn,content_3764_5272:()=>Qpn,content_3764_5274:()=>$pn,content_3764_5276:()=>ern,content_3764_5278:()=>prn,content_3764_528:()=>set,content_3764_5280:()=>crn,content_3764_5282:()=>lrn,content_3764_5284:()=>drn,content_3764_5286:()=>krn,content_3764_5288:()=>Mrn,content_3764_5290:()=>wrn,content_3764_5292:()=>xrn,content_3764_5294:()=>Lrn,content_3764_5296:()=>Nrn,content_3764_5298:()=>Prn,content_3764_530:()=>iet,content_3764_5300:()=>Irn,content_3764_5302:()=>Grn,content_3764_5304:()=>Frn,content_3764_5306:()=>qrn,content_3764_5308:()=>Qrn,content_3764_5310:()=>$rn,content_3764_5312:()=>esn,content_3764_5314:()=>psn,content_3764_5316:()=>csn,content_3764_5318:()=>lsn,content_3764_532:()=>det,content_3764_5320:()=>dsn,content_3764_5322:()=>ksn,content_3764_5324:()=>Msn,content_3764_5326:()=>wsn,content_3764_5328:()=>xsn,content_3764_5330:()=>Lsn,content_3764_5332:()=>Nsn,content_3764_5334:()=>Psn,content_3764_5336:()=>Isn,content_3764_5338:()=>Gsn,content_3764_534:()=>ket,content_3764_5340:()=>Fsn,content_3764_5342:()=>qsn,content_3764_5344:()=>Qsn,content_3764_5346:()=>$sn,content_3764_5348:()=>ecn,content_3764_5350:()=>pcn,content_3764_5352:()=>ccn,content_3764_5354:()=>lcn,content_3764_5356:()=>dcn,content_3764_5358:()=>kcn,content_3764_536:()=>Met,content_3764_5360:()=>Mcn,content_3764_5362:()=>wcn,content_3764_5364:()=>xcn,content_3764_5366:()=>Lcn,content_3764_5368:()=>Ncn,content_3764_5370:()=>Pcn,content_3764_5372:()=>Icn,content_3764_5374:()=>Gcn,content_3764_5376:()=>Fcn,content_3764_5378:()=>qcn,content_3764_538:()=>wet,content_3764_5380:()=>Qcn,content_3764_5382:()=>$cn,content_3764_5384:()=>ean,content_3764_5386:()=>pan,content_3764_5388:()=>can,content_3764_5390:()=>lan,content_3764_5392:()=>dan,content_3764_5394:()=>kan,content_3764_5396:()=>Man,content_3764_5398:()=>wan,content_3764_54:()=>KK,content_3764_540:()=>xet,content_3764_5400:()=>xan,content_3764_5402:()=>Lan,content_3764_5404:()=>Nan,content_3764_5406:()=>Pan,content_3764_5408:()=>Ian,content_3764_5410:()=>Gan,content_3764_5412:()=>Fan,content_3764_5414:()=>qan,content_3764_5416:()=>Qan,content_3764_5418:()=>$an,content_3764_542:()=>Let,content_3764_5420:()=>ein,content_3764_5422:()=>pin,content_3764_5424:()=>cin,content_3764_5426:()=>lin,content_3764_5428:()=>din,content_3764_5430:()=>kin,content_3764_5432:()=>Min,content_3764_5434:()=>win,content_3764_5436:()=>xin,content_3764_5438:()=>Lin,content_3764_544:()=>Net,content_3764_5440:()=>Nin,content_3764_5442:()=>Pin,content_3764_5444:()=>Iin,content_3764_5446:()=>Gin,content_3764_5448:()=>Fin,content_3764_5450:()=>qin,content_3764_5452:()=>Qin,content_3764_5454:()=>$in,content_3764_5456:()=>eln,content_3764_5458:()=>pln,content_3764_546:()=>Pet,content_3764_5460:()=>cln,content_3764_5462:()=>lln,content_3764_5464:()=>dln,content_3764_5466:()=>kln,content_3764_5468:()=>Mln,content_3764_5470:()=>wln,content_3764_5472:()=>xln,content_3764_5474:()=>Lln,content_3764_5476:()=>Nln,content_3764_5478:()=>Pln,content_3764_548:()=>Iet,content_3764_5480:()=>Iln,content_3764_5482:()=>Gln,content_3764_5484:()=>Fln,content_3764_5486:()=>qln,content_3764_5488:()=>Qln,content_3764_5490:()=>$ln,content_3764_5492:()=>eun,content_3764_5494:()=>pun,content_3764_5496:()=>cun,content_3764_5498:()=>lun,content_3764_550:()=>Get,content_3764_5500:()=>dun,content_3764_5502:()=>kun,content_3764_5504:()=>Mun,content_3764_5506:()=>wun,content_3764_5508:()=>xun,content_3764_5510:()=>Lun,content_3764_5512:()=>Nun,content_3764_5514:()=>Pun,content_3764_5516:()=>Iun,content_3764_5518:()=>Gun,content_3764_552:()=>Fet,content_3764_5520:()=>Fun,content_3764_5522:()=>qun,content_3764_5524:()=>Qun,content_3764_5526:()=>$un,content_3764_5528:()=>emn,content_3764_5530:()=>pmn,content_3764_5532:()=>cmn,content_3764_5534:()=>lmn,content_3764_5536:()=>dmn,content_3764_5538:()=>kmn,content_3764_554:()=>qet,content_3764_5540:()=>Mmn,content_3764_5542:()=>wmn,content_3764_5544:()=>xmn,content_3764_5546:()=>Lmn,content_3764_5548:()=>Nmn,content_3764_5550:()=>Pmn,content_3764_5552:()=>Imn,content_3764_5554:()=>Gmn,content_3764_5556:()=>Fmn,content_3764_5558:()=>qmn,content_3764_556:()=>Qet,content_3764_5560:()=>Qmn,content_3764_5562:()=>$mn,content_3764_5564:()=>edn,content_3764_5566:()=>pdn,content_3764_5568:()=>cdn,content_3764_5570:()=>ldn,content_3764_5572:()=>ddn,content_3764_5574:()=>kdn,content_3764_5576:()=>Mdn,content_3764_5578:()=>wdn,content_3764_558:()=>$et,content_3764_5580:()=>xdn,content_3764_5582:()=>Ldn,content_3764_5584:()=>Ndn,content_3764_5586:()=>Pdn,content_3764_5588:()=>Idn,content_3764_5590:()=>Gdn,content_3764_5592:()=>Fdn,content_3764_5594:()=>qdn,content_3764_5596:()=>Qdn,content_3764_5598:()=>$dn,content_3764_56:()=>t$,content_3764_560:()=>ent,content_3764_5600:()=>ehn,content_3764_5602:()=>phn,content_3764_5604:()=>chn,content_3764_5606:()=>lhn,content_3764_5608:()=>dhn,content_3764_5610:()=>khn,content_3764_5612:()=>Mhn,content_3764_5614:()=>whn,content_3764_5616:()=>xhn,content_3764_5618:()=>Lhn,content_3764_562:()=>pnt,content_3764_5620:()=>Nhn,content_3764_5622:()=>Phn,content_3764_5624:()=>Ihn,content_3764_5626:()=>Ghn,content_3764_5628:()=>Fhn,content_3764_5630:()=>qhn,content_3764_5632:()=>Qhn,content_3764_5634:()=>$hn,content_3764_5636:()=>efn,content_3764_5638:()=>pfn,content_3764_564:()=>cnt,content_3764_5640:()=>cfn,content_3764_5642:()=>lfn,content_3764_5644:()=>dfn,content_3764_5646:()=>kfn,content_3764_5648:()=>Mfn,content_3764_5650:()=>wfn,content_3764_5652:()=>xfn,content_3764_5654:()=>Lfn,content_3764_5656:()=>Nfn,content_3764_5658:()=>Pfn,content_3764_566:()=>lnt,content_3764_5660:()=>Ifn,content_3764_5662:()=>Gfn,content_3764_5664:()=>Ffn,content_3764_5666:()=>qfn,content_3764_5668:()=>Qfn,content_3764_5670:()=>$fn,content_3764_5672:()=>ekn,content_3764_5674:()=>pkn,content_3764_5676:()=>ckn,content_3764_5678:()=>lkn,content_3764_568:()=>dnt,content_3764_5680:()=>dkn,content_3764_5682:()=>kkn,content_3764_5684:()=>Mkn,content_3764_5686:()=>wkn,content_3764_5688:()=>xkn,content_3764_5690:()=>Lkn,content_3764_5692:()=>Nkn,content_3764_5694:()=>Pkn,content_3764_5696:()=>Ikn,content_3764_5698:()=>Gkn,content_3764_570:()=>knt,content_3764_5700:()=>Fkn,content_3764_5702:()=>qkn,content_3764_5704:()=>Qkn,content_3764_5706:()=>$kn,content_3764_5708:()=>eyn,content_3764_5710:()=>pyn,content_3764_5712:()=>cyn,content_3764_5714:()=>lyn,content_3764_5716:()=>dyn,content_3764_5718:()=>kyn,content_3764_572:()=>Mnt,content_3764_5720:()=>Myn,content_3764_5722:()=>wyn,content_3764_5724:()=>xyn,content_3764_5726:()=>Lyn,content_3764_5728:()=>Nyn,content_3764_5730:()=>Pyn,content_3764_5732:()=>Iyn,content_3764_5734:()=>Gyn,content_3764_5736:()=>Fyn,content_3764_5738:()=>qyn,content_3764_574:()=>wnt,content_3764_5740:()=>Qyn,content_3764_5742:()=>$yn,content_3764_5744:()=>eDn,content_3764_5746:()=>pDn,content_3764_5748:()=>cDn,content_3764_5750:()=>lDn,content_3764_5752:()=>dDn,content_3764_5754:()=>kDn,content_3764_5756:()=>MDn,content_3764_5758:()=>wDn,content_3764_576:()=>xnt,content_3764_5760:()=>xDn,content_3764_5762:()=>LDn,content_3764_5764:()=>NDn,content_3764_5766:()=>PDn,content_3764_5768:()=>IDn,content_3764_5770:()=>GDn,content_3764_5772:()=>FDn,content_3764_5774:()=>qDn,content_3764_5776:()=>QDn,content_3764_5778:()=>$Dn,content_3764_578:()=>Lnt,content_3764_5780:()=>eMn,content_3764_5782:()=>pMn,content_3764_5784:()=>cMn,content_3764_5786:()=>lMn,content_3764_5788:()=>dMn,content_3764_5790:()=>kMn,content_3764_5792:()=>MMn,content_3764_5794:()=>wMn,content_3764_5796:()=>xMn,content_3764_5798:()=>LMn,content_3764_58:()=>o$,content_3764_580:()=>Nnt,content_3764_5800:()=>NMn,content_3764_5802:()=>PMn,content_3764_5804:()=>IMn,content_3764_5806:()=>GMn,content_3764_5808:()=>FMn,content_3764_5810:()=>qMn,content_3764_5812:()=>QMn,content_3764_5814:()=>$Mn,content_3764_5816:()=>eXn,content_3764_5818:()=>pXn,content_3764_582:()=>Pnt,content_3764_5820:()=>cXn,content_3764_5822:()=>lXn,content_3764_5824:()=>dXn,content_3764_5826:()=>kXn,content_3764_5828:()=>MXn,content_3764_5830:()=>wXn,content_3764_5832:()=>xXn,content_3764_5834:()=>LXn,content_3764_5836:()=>NXn,content_3764_5838:()=>PXn,content_3764_584:()=>Int,content_3764_5840:()=>IXn,content_3764_5842:()=>GXn,content_3764_5844:()=>FXn,content_3764_5846:()=>qXn,content_3764_5848:()=>QXn,content_3764_5850:()=>$Xn,content_3764_5852:()=>e_n,content_3764_5854:()=>p_n,content_3764_5856:()=>c_n,content_3764_5858:()=>l_n,content_3764_586:()=>Gnt,content_3764_5860:()=>d_n,content_3764_5862:()=>k_n,content_3764_5864:()=>M_n,content_3764_5866:()=>w_n,content_3764_5868:()=>x_n,content_3764_5870:()=>L_n,content_3764_5872:()=>N_n,content_3764_5874:()=>P_n,content_3764_5876:()=>I_n,content_3764_5878:()=>G_n,content_3764_588:()=>Fnt,content_3764_5880:()=>F_n,content_3764_5882:()=>q_n,content_3764_5884:()=>Q_n,content_3764_5886:()=>$_n,content_3764_5888:()=>ewn,content_3764_5890:()=>pwn,content_3764_5892:()=>cwn,content_3764_5894:()=>lwn,content_3764_5896:()=>dwn,content_3764_5898:()=>kwn,content_3764_590:()=>qnt,content_3764_5900:()=>Mwn,content_3764_5902:()=>wwn,content_3764_5904:()=>xwn,content_3764_5906:()=>Lwn,content_3764_5908:()=>Nwn,content_3764_5910:()=>Pwn,content_3764_5912:()=>Iwn,content_3764_5914:()=>Gwn,content_3764_5916:()=>Fwn,content_3764_5918:()=>qwn,content_3764_592:()=>Qnt,content_3764_5920:()=>Qwn,content_3764_5922:()=>$wn,content_3764_5924:()=>eTn,content_3764_5926:()=>pTn,content_3764_5928:()=>cTn,content_3764_5930:()=>lTn,content_3764_5932:()=>dTn,content_3764_5934:()=>kTn,content_3764_5936:()=>MTn,content_3764_5938:()=>wTn,content_3764_594:()=>$nt,content_3764_5940:()=>xTn,content_3764_5942:()=>LTn,content_3764_5944:()=>NTn,content_3764_5946:()=>PTn,content_3764_5948:()=>ITn,content_3764_5950:()=>GTn,content_3764_5952:()=>FTn,content_3764_5954:()=>qTn,content_3764_5956:()=>QTn,content_3764_5958:()=>$Tn,content_3764_596:()=>eot,content_3764_5960:()=>eCn,content_3764_5962:()=>pCn,content_3764_5964:()=>cCn,content_3764_5966:()=>lCn,content_3764_5968:()=>dCn,content_3764_5970:()=>kCn,content_3764_5972:()=>MCn,content_3764_5974:()=>wCn,content_3764_5976:()=>xCn,content_3764_5978:()=>LCn,content_3764_598:()=>pot,content_3764_5980:()=>NCn,content_3764_5982:()=>PCn,content_3764_5984:()=>ICn,content_3764_5986:()=>GCn,content_3764_5988:()=>FCn,content_3764_5990:()=>qCn,content_3764_5992:()=>QCn,content_3764_5994:()=>$Cn,content_3764_5996:()=>exn,content_3764_5998:()=>pxn,content_3764_6:()=>AH,content_3764_60:()=>s$,content_3764_600:()=>cot,content_3764_6000:()=>cxn,content_3764_6002:()=>lxn,content_3764_6004:()=>dxn,content_3764_6006:()=>kxn,content_3764_6008:()=>Mxn,content_3764_6010:()=>wxn,content_3764_6012:()=>xxn,content_3764_6014:()=>Lxn,content_3764_6016:()=>Nxn,content_3764_6018:()=>Pxn,content_3764_602:()=>lot,content_3764_6020:()=>Ixn,content_3764_6022:()=>Gxn,content_3764_6024:()=>Fxn,content_3764_6026:()=>qxn,content_3764_6028:()=>Qxn,content_3764_6030:()=>$xn,content_3764_6032:()=>egn,content_3764_6034:()=>pgn,content_3764_6036:()=>cgn,content_3764_6038:()=>lgn,content_3764_604:()=>dot,content_3764_6040:()=>dgn,content_3764_6042:()=>kgn,content_3764_6044:()=>Mgn,content_3764_6046:()=>wgn,content_3764_6048:()=>xgn,content_3764_6050:()=>Lgn,content_3764_6052:()=>Ngn,content_3764_6054:()=>Pgn,content_3764_6056:()=>Ign,content_3764_6058:()=>Ggn,content_3764_606:()=>kot,content_3764_6060:()=>Fgn,content_3764_6062:()=>qgn,content_3764_6064:()=>Qgn,content_3764_6066:()=>$gn,content_3764_6068:()=>evn,content_3764_6070:()=>pvn,content_3764_6072:()=>cvn,content_3764_6074:()=>lvn,content_3764_6076:()=>dvn,content_3764_6078:()=>kvn,content_3764_608:()=>Mot,content_3764_6080:()=>Mvn,content_3764_6082:()=>wvn,content_3764_6084:()=>xvn,content_3764_6086:()=>Lvn,content_3764_6088:()=>Nvn,content_3764_6090:()=>Pvn,content_3764_6092:()=>Ivn,content_3764_6094:()=>Gvn,content_3764_6096:()=>Fvn,content_3764_6098:()=>qvn,content_3764_610:()=>wot,content_3764_6100:()=>Qvn,content_3764_6102:()=>$vn,content_3764_6104:()=>eLn,content_3764_6106:()=>pLn,content_3764_6108:()=>cLn,content_3764_6110:()=>lLn,content_3764_6112:()=>dLn,content_3764_6114:()=>kLn,content_3764_6116:()=>MLn,content_3764_6118:()=>wLn,content_3764_612:()=>xot,content_3764_6120:()=>xLn,content_3764_6122:()=>LLn,content_3764_6124:()=>NLn,content_3764_6126:()=>PLn,content_3764_6128:()=>ILn,content_3764_6130:()=>GLn,content_3764_6132:()=>FLn,content_3764_6134:()=>qLn,content_3764_6136:()=>QLn,content_3764_6138:()=>$Ln,content_3764_614:()=>Lot,content_3764_6140:()=>eZn,content_3764_6142:()=>pZn,content_3764_6144:()=>cZn,content_3764_6146:()=>lZn,content_3764_6148:()=>dZn,content_3764_6150:()=>kZn,content_3764_6152:()=>MZn,content_3764_6154:()=>wZn,content_3764_6156:()=>xZn,content_3764_6158:()=>LZn,content_3764_616:()=>Not,content_3764_6160:()=>NZn,content_3764_6162:()=>PZn,content_3764_6164:()=>IZn,content_3764_6166:()=>GZn,content_3764_6168:()=>FZn,content_3764_6170:()=>qZn,content_3764_6172:()=>QZn,content_3764_6174:()=>$Zn,content_3764_6176:()=>ebn,content_3764_6178:()=>pbn,content_3764_618:()=>Pot,content_3764_6180:()=>cbn,content_3764_6182:()=>lbn,content_3764_6184:()=>dbn,content_3764_6186:()=>kbn,content_3764_6188:()=>Mbn,content_3764_6190:()=>wbn,content_3764_6192:()=>xbn,content_3764_6194:()=>Lbn,content_3764_6196:()=>Nbn,content_3764_6198:()=>Pbn,content_3764_62:()=>i$,content_3764_620:()=>Iot,content_3764_6200:()=>Ibn,content_3764_6202:()=>Gbn,content_3764_6204:()=>Fbn,content_3764_6206:()=>qbn,content_3764_6208:()=>Qbn,content_3764_6210:()=>$bn,content_3764_6212:()=>eNn,content_3764_6214:()=>pNn,content_3764_6216:()=>cNn,content_3764_6218:()=>lNn,content_3764_622:()=>Got,content_3764_6220:()=>dNn,content_3764_6222:()=>kNn,content_3764_6224:()=>MNn,content_3764_6226:()=>wNn,content_3764_6228:()=>xNn,content_3764_6230:()=>LNn,content_3764_6232:()=>NNn,content_3764_6234:()=>PNn,content_3764_6236:()=>INn,content_3764_6238:()=>GNn,content_3764_624:()=>Fot,content_3764_6240:()=>FNn,content_3764_6242:()=>qNn,content_3764_6244:()=>QNn,content_3764_6246:()=>$Nn,content_3764_6248:()=>ezn,content_3764_6250:()=>pzn,content_3764_6252:()=>czn,content_3764_6254:()=>lzn,content_3764_6256:()=>dzn,content_3764_6258:()=>kzn,content_3764_626:()=>qot,content_3764_6260:()=>Mzn,content_3764_6262:()=>wzn,content_3764_6264:()=>xzn,content_3764_6266:()=>Lzn,content_3764_6268:()=>Nzn,content_3764_6270:()=>Pzn,content_3764_6272:()=>Izn,content_3764_6274:()=>Gzn,content_3764_6276:()=>Fzn,content_3764_6278:()=>qzn,content_3764_628:()=>Qot,content_3764_6280:()=>Qzn,content_3764_6282:()=>$zn,content_3764_6284:()=>eAn,content_3764_6286:()=>pAn,content_3764_6288:()=>cAn,content_3764_6290:()=>lAn,content_3764_6292:()=>dAn,content_3764_6294:()=>kAn,content_3764_6296:()=>MAn,content_3764_6298:()=>wAn,content_3764_630:()=>$ot,content_3764_6300:()=>xAn,content_3764_6302:()=>LAn,content_3764_6304:()=>NAn,content_3764_6306:()=>PAn,content_3764_6308:()=>IAn,content_3764_6310:()=>GAn,content_3764_6312:()=>FAn,content_3764_6314:()=>qAn,content_3764_6316:()=>QAn,content_3764_6318:()=>$An,content_3764_632:()=>ept,content_3764_6320:()=>ePn,content_3764_6322:()=>pPn,content_3764_6324:()=>cPn,content_3764_6326:()=>lPn,content_3764_6328:()=>dPn,content_3764_6330:()=>kPn,content_3764_6332:()=>MPn,content_3764_6334:()=>wPn,content_3764_6336:()=>xPn,content_3764_6338:()=>LPn,content_3764_634:()=>ppt,content_3764_6340:()=>NPn,content_3764_6342:()=>PPn,content_3764_6344:()=>IPn,content_3764_6346:()=>GPn,content_3764_6348:()=>FPn,content_3764_6350:()=>qPn,content_3764_6352:()=>QPn,content_3764_6354:()=>$Pn,content_3764_6356:()=>eWn,content_3764_6358:()=>pWn,content_3764_636:()=>cpt,content_3764_6360:()=>cWn,content_3764_6362:()=>lWn,content_3764_6364:()=>dWn,content_3764_6366:()=>kWn,content_3764_6368:()=>MWn,content_3764_6370:()=>wWn,content_3764_6372:()=>xWn,content_3764_6374:()=>LWn,content_3764_6376:()=>NWn,content_3764_6378:()=>PWn,content_3764_638:()=>lpt,content_3764_6380:()=>IWn,content_3764_6382:()=>GWn,content_3764_6384:()=>FWn,content_3764_6386:()=>qWn,content_3764_6388:()=>QWn,content_3764_6390:()=>$Wn,content_3764_6392:()=>eRn,content_3764_6394:()=>pRn,content_3764_6396:()=>cRn,content_3764_6398:()=>lRn,content_3764_64:()=>m$,content_3764_640:()=>dpt,content_3764_6400:()=>dRn,content_3764_6402:()=>kRn,content_3764_6404:()=>MRn,content_3764_6406:()=>wRn,content_3764_6408:()=>xRn,content_3764_6410:()=>LRn,content_3764_6412:()=>NRn,content_3764_6414:()=>PRn,content_3764_6416:()=>IRn,content_3764_6418:()=>GRn,content_3764_642:()=>kpt,content_3764_6420:()=>FRn,content_3764_6422:()=>qRn,content_3764_6424:()=>QRn,content_3764_6426:()=>$Rn,content_3764_6428:()=>eIn,content_3764_6430:()=>pIn,content_3764_6432:()=>cIn,content_3764_6434:()=>lIn,content_3764_6436:()=>dIn,content_3764_6438:()=>kIn,content_3764_644:()=>Mpt,content_3764_6440:()=>MIn,content_3764_6442:()=>wIn,content_3764_6444:()=>xIn,content_3764_6446:()=>LIn,content_3764_6448:()=>NIn,content_3764_6450:()=>PIn,content_3764_6452:()=>IIn,content_3764_6454:()=>GIn,content_3764_6456:()=>FIn,content_3764_6458:()=>qIn,content_3764_646:()=>wpt,content_3764_6460:()=>QIn,content_3764_6462:()=>$In,content_3764_6464:()=>eSn,content_3764_6466:()=>pSn,content_3764_6468:()=>cSn,content_3764_6470:()=>lSn,content_3764_6472:()=>dSn,content_3764_6474:()=>kSn,content_3764_6476:()=>MSn,content_3764_6478:()=>wSn,content_3764_648:()=>xpt,content_3764_6480:()=>xSn,content_3764_6482:()=>LSn,content_3764_6484:()=>NSn,content_3764_6486:()=>PSn,content_3764_6488:()=>ISn,content_3764_6490:()=>GSn,content_3764_6492:()=>FSn,content_3764_6494:()=>qSn,content_3764_6496:()=>QSn,content_3764_6498:()=>$Sn,content_3764_650:()=>Lpt,content_3764_6500:()=>eBn,content_3764_6502:()=>pBn,content_3764_6504:()=>cBn,content_3764_6506:()=>lBn,content_3764_6508:()=>dBn,content_3764_6510:()=>kBn,content_3764_6512:()=>MBn,content_3764_6514:()=>wBn,content_3764_6516:()=>xBn,content_3764_6518:()=>LBn,content_3764_652:()=>Npt,content_3764_6520:()=>NBn,content_3764_6522:()=>PBn,content_3764_6524:()=>IBn,content_3764_6526:()=>GBn,content_3764_6528:()=>FBn,content_3764_6530:()=>qBn,content_3764_6532:()=>QBn,content_3764_6534:()=>$Bn,content_3764_6536:()=>eGn,content_3764_6538:()=>pGn,content_3764_654:()=>Ppt,content_3764_6540:()=>cGn,content_3764_6542:()=>lGn,content_3764_6544:()=>dGn,content_3764_6546:()=>kGn,content_3764_6548:()=>MGn,content_3764_6550:()=>wGn,content_3764_6552:()=>xGn,content_3764_6554:()=>LGn,content_3764_6556:()=>NGn,content_3764_6558:()=>PGn,content_3764_656:()=>Ipt,content_3764_6560:()=>IGn,content_3764_6562:()=>GGn,content_3764_6564:()=>FGn,content_3764_6566:()=>qGn,content_3764_6568:()=>QGn,content_3764_6570:()=>$Gn,content_3764_6572:()=>eEn,content_3764_6574:()=>pEn,content_3764_6576:()=>cEn,content_3764_6578:()=>lEn,content_3764_658:()=>Gpt,content_3764_6580:()=>dEn,content_3764_6582:()=>kEn,content_3764_6584:()=>MEn,content_3764_6586:()=>wEn,content_3764_6588:()=>xEn,content_3764_6590:()=>LEn,content_3764_6592:()=>NEn,content_3764_6594:()=>PEn,content_3764_6596:()=>IEn,content_3764_6598:()=>GEn,content_3764_66:()=>f$,content_3764_660:()=>Fpt,content_3764_6600:()=>FEn,content_3764_6602:()=>qEn,content_3764_6604:()=>QEn,content_3764_6606:()=>$En,content_3764_6608:()=>eOn,content_3764_6610:()=>pOn,content_3764_6612:()=>cOn,content_3764_6614:()=>lOn,content_3764_6616:()=>dOn,content_3764_6618:()=>kOn,content_3764_662:()=>qpt,content_3764_6620:()=>MOn,content_3764_6622:()=>wOn,content_3764_6624:()=>xOn,content_3764_6626:()=>LOn,content_3764_6628:()=>NOn,content_3764_6630:()=>POn,content_3764_6632:()=>IOn,content_3764_6634:()=>GOn,content_3764_6636:()=>FOn,content_3764_6638:()=>qOn,content_3764_664:()=>Qpt,content_3764_6640:()=>QOn,content_3764_6642:()=>$On,content_3764_6644:()=>eFn,content_3764_6646:()=>pFn,content_3764_6648:()=>cFn,content_3764_6650:()=>lFn,content_3764_6652:()=>dFn,content_3764_6654:()=>kFn,content_3764_6656:()=>MFn,content_3764_6658:()=>wFn,content_3764_666:()=>$pt,content_3764_6660:()=>xFn,content_3764_6662:()=>LFn,content_3764_6664:()=>NFn,content_3764_6666:()=>PFn,content_3764_6668:()=>IFn,content_3764_6670:()=>GFn,content_3764_6672:()=>FFn,content_3764_6674:()=>qFn,content_3764_6676:()=>QFn,content_3764_6678:()=>$Fn,content_3764_668:()=>ert,content_3764_6680:()=>eUn,content_3764_6682:()=>pUn,content_3764_6684:()=>cUn,content_3764_6686:()=>lUn,content_3764_6688:()=>dUn,content_3764_6690:()=>kUn,content_3764_6692:()=>MUn,content_3764_6694:()=>wUn,content_3764_6696:()=>xUn,content_3764_6698:()=>LUn,content_3764_670:()=>prt,content_3764_6700:()=>NUn,content_3764_6702:()=>PUn,content_3764_6704:()=>IUn,content_3764_6706:()=>GUn,content_3764_6708:()=>FUn,content_3764_6710:()=>qUn,content_3764_6712:()=>QUn,content_3764_6714:()=>$Un,content_3764_6716:()=>eVn,content_3764_6718:()=>pVn,content_3764_672:()=>crt,content_3764_6720:()=>cVn,content_3764_6722:()=>lVn,content_3764_6724:()=>dVn,content_3764_6726:()=>kVn,content_3764_6728:()=>MVn,content_3764_6730:()=>wVn,content_3764_6732:()=>xVn,content_3764_6734:()=>LVn,content_3764_6736:()=>NVn,content_3764_6738:()=>PVn,content_3764_674:()=>lrt,content_3764_6740:()=>IVn,content_3764_6742:()=>GVn,content_3764_6744:()=>FVn,content_3764_6746:()=>qVn,content_3764_6748:()=>QVn,content_3764_6750:()=>$Vn,content_3764_6752:()=>eqn,content_3764_6754:()=>pqn,content_3764_6756:()=>cqn,content_3764_6758:()=>lqn,content_3764_676:()=>drt,content_3764_6760:()=>dqn,content_3764_6762:()=>kqn,content_3764_6764:()=>Mqn,content_3764_6766:()=>wqn,content_3764_6768:()=>xqn,content_3764_6770:()=>Lqn,content_3764_6772:()=>Nqn,content_3764_6774:()=>Pqn,content_3764_6776:()=>Iqn,content_3764_6778:()=>Gqn,content_3764_678:()=>krt,content_3764_6780:()=>Fqn,content_3764_6782:()=>qqn,content_3764_6784:()=>Qqn,content_3764_6786:()=>$qn,content_3764_6788:()=>ejn,content_3764_6790:()=>pjn,content_3764_6792:()=>cjn,content_3764_6794:()=>ljn,content_3764_6796:()=>djn,content_3764_6798:()=>kjn,content_3764_68:()=>D$,content_3764_680:()=>Mrt,content_3764_6800:()=>Mjn,content_3764_6802:()=>wjn,content_3764_6804:()=>xjn,content_3764_6806:()=>Ljn,content_3764_6808:()=>Njn,content_3764_6810:()=>Pjn,content_3764_6812:()=>Ijn,content_3764_6814:()=>Gjn,content_3764_6816:()=>Fjn,content_3764_6818:()=>qjn,content_3764_682:()=>wrt,content_3764_6820:()=>Qjn,content_3764_6822:()=>$jn,content_3764_6824:()=>eYn,content_3764_6826:()=>pYn,content_3764_6828:()=>cYn,content_3764_6830:()=>lYn,content_3764_6832:()=>dYn,content_3764_6834:()=>kYn,content_3764_6836:()=>MYn,content_3764_6838:()=>wYn,content_3764_684:()=>xrt,content_3764_6840:()=>xYn,content_3764_6842:()=>LYn,content_3764_6844:()=>NYn,content_3764_6846:()=>PYn,content_3764_6848:()=>IYn,content_3764_6850:()=>GYn,content_3764_6852:()=>FYn,content_3764_6854:()=>qYn,content_3764_6856:()=>QYn,content_3764_6858:()=>$Yn,content_3764_686:()=>Lrt,content_3764_6860:()=>eQn,content_3764_6862:()=>pQn,content_3764_6864:()=>cQn,content_3764_6866:()=>lQn,content_3764_6868:()=>dQn,content_3764_6870:()=>kQn,content_3764_6872:()=>MQn,content_3764_6874:()=>wQn,content_3764_6876:()=>xQn,content_3764_6878:()=>LQn,content_3764_688:()=>Nrt,content_3764_6880:()=>NQn,content_3764_6882:()=>PQn,content_3764_6884:()=>IQn,content_3764_6886:()=>GQn,content_3764_6888:()=>FQn,content_3764_6890:()=>qQn,content_3764_6892:()=>QQn,content_3764_6894:()=>$Qn,content_3764_6896:()=>eHn,content_3764_6898:()=>pHn,content_3764_690:()=>Prt,content_3764_6900:()=>cHn,content_3764_6902:()=>lHn,content_3764_6904:()=>dHn,content_3764_6906:()=>kHn,content_3764_6908:()=>MHn,content_3764_6910:()=>wHn,content_3764_6912:()=>xHn,content_3764_6914:()=>LHn,content_3764_6916:()=>NHn,content_3764_6918:()=>PHn,content_3764_692:()=>Irt,content_3764_6920:()=>IHn,content_3764_6922:()=>GHn,content_3764_6924:()=>FHn,content_3764_6926:()=>qHn,content_3764_6928:()=>QHn,content_3764_6930:()=>$Hn,content_3764_6932:()=>eKn,content_3764_6934:()=>pKn,content_3764_6936:()=>cKn,content_3764_6938:()=>lKn,content_3764_694:()=>Grt,content_3764_6940:()=>dKn,content_3764_6942:()=>kKn,content_3764_6944:()=>MKn,content_3764_6946:()=>wKn,content_3764_6948:()=>xKn,content_3764_6950:()=>LKn,content_3764_6952:()=>NKn,content_3764_6954:()=>PKn,content_3764_6956:()=>IKn,content_3764_6958:()=>GKn,content_3764_696:()=>Frt,content_3764_6960:()=>FKn,content_3764_6962:()=>qKn,content_3764_6964:()=>QKn,content_3764_6966:()=>$Kn,content_3764_6968:()=>e$n,content_3764_6970:()=>p$n,content_3764_6972:()=>c$n,content_3764_6974:()=>l$n,content_3764_6976:()=>d$n,content_3764_6978:()=>k$n,content_3764_698:()=>qrt,content_3764_6980:()=>M$n,content_3764_6982:()=>w$n,content_3764_6984:()=>x$n,content_3764_6986:()=>L$n,content_3764_6988:()=>N$n,content_3764_6990:()=>P$n,content_3764_6992:()=>I$n,content_3764_6994:()=>G$n,content_3764_6996:()=>F$n,content_3764_6998:()=>q$n,content_3764_70:()=>_$,content_3764_700:()=>Qrt,content_3764_7000:()=>Q$n,content_3764_7002:()=>$$n,content_3764_7004:()=>eJn,content_3764_7006:()=>pJn,content_3764_7008:()=>cJn,content_3764_7010:()=>lJn,content_3764_7012:()=>dJn,content_3764_7014:()=>kJn,content_3764_7016:()=>MJn,content_3764_7018:()=>wJn,content_3764_702:()=>$rt,content_3764_7020:()=>xJn,content_3764_7022:()=>LJn,content_3764_7024:()=>NJn,content_3764_7026:()=>PJn,content_3764_7028:()=>IJn,content_3764_7030:()=>GJn,content_3764_7032:()=>FJn,content_3764_7034:()=>qJn,content_3764_7036:()=>QJn,content_3764_7038:()=>$Jn,content_3764_704:()=>est,content_3764_7040:()=>e0n,content_3764_7042:()=>p0n,content_3764_7044:()=>c0n,content_3764_7046:()=>l0n,content_3764_7048:()=>d0n,content_3764_7050:()=>k0n,content_3764_7052:()=>M0n,content_3764_7054:()=>w0n,content_3764_7056:()=>x0n,content_3764_7058:()=>L0n,content_3764_706:()=>pst,content_3764_7060:()=>N0n,content_3764_7062:()=>P0n,content_3764_7064:()=>I0n,content_3764_7066:()=>G0n,content_3764_7068:()=>F0n,content_3764_7070:()=>q0n,content_3764_7072:()=>Q0n,content_3764_7074:()=>$0n,content_3764_7076:()=>e4n,content_3764_7078:()=>p4n,content_3764_708:()=>cst,content_3764_7080:()=>c4n,content_3764_7082:()=>l4n,content_3764_7084:()=>d4n,content_3764_7086:()=>k4n,content_3764_7088:()=>M4n,content_3764_7090:()=>w4n,content_3764_7092:()=>x4n,content_3764_7094:()=>L4n,content_3764_7096:()=>N4n,content_3764_7098:()=>P4n,content_3764_710:()=>lst,content_3764_7100:()=>I4n,content_3764_7102:()=>G4n,content_3764_7104:()=>F4n,content_3764_7106:()=>q4n,content_3764_7108:()=>Q4n,content_3764_7110:()=>$4n,content_3764_7112:()=>e6n,content_3764_7114:()=>p6n,content_3764_7116:()=>c6n,content_3764_7118:()=>l6n,content_3764_712:()=>dst,content_3764_7120:()=>d6n,content_3764_7122:()=>k6n,content_3764_7124:()=>M6n,content_3764_7126:()=>w6n,content_3764_7128:()=>x6n,content_3764_7130:()=>L6n,content_3764_7132:()=>N6n,content_3764_7134:()=>P6n,content_3764_7136:()=>I6n,content_3764_7138:()=>G6n,content_3764_714:()=>kst,content_3764_7140:()=>F6n,content_3764_7142:()=>q6n,content_3764_7144:()=>Q6n,content_3764_7146:()=>$6n,content_3764_7148:()=>e3n,content_3764_7150:()=>p3n,content_3764_7152:()=>c3n,content_3764_7154:()=>l3n,content_3764_7156:()=>d3n,content_3764_7158:()=>k3n,content_3764_716:()=>Mst,content_3764_7160:()=>M3n,content_3764_7162:()=>w3n,content_3764_7164:()=>x3n,content_3764_7166:()=>L3n,content_3764_7168:()=>N3n,content_3764_7170:()=>P3n,content_3764_7172:()=>I3n,content_3764_7174:()=>G3n,content_3764_7176:()=>F3n,content_3764_7178:()=>q3n,content_3764_718:()=>wst,content_3764_7180:()=>Q3n,content_3764_7182:()=>$3n,content_3764_7184:()=>e7n,content_3764_7186:()=>p7n,content_3764_7188:()=>c7n,content_3764_7190:()=>l7n,content_3764_7192:()=>d7n,content_3764_7194:()=>k7n,content_3764_7196:()=>M7n,content_3764_7198:()=>w7n,content_3764_72:()=>C$,content_3764_720:()=>xst,content_3764_7200:()=>x7n,content_3764_7202:()=>L7n,content_3764_7204:()=>N7n,content_3764_7206:()=>P7n,content_3764_7208:()=>I7n,content_3764_7210:()=>G7n,content_3764_7212:()=>F7n,content_3764_7214:()=>q7n,content_3764_7216:()=>Q7n,content_3764_7218:()=>$7n,content_3764_722:()=>Lst,content_3764_7220:()=>e2n,content_3764_7222:()=>p2n,content_3764_7224:()=>c2n,content_3764_7226:()=>l2n,content_3764_7228:()=>d2n,content_3764_7230:()=>k2n,content_3764_7232:()=>M2n,content_3764_7234:()=>w2n,content_3764_7236:()=>x2n,content_3764_7238:()=>L2n,content_3764_724:()=>Nst,content_3764_7240:()=>N2n,content_3764_7242:()=>P2n,content_3764_7244:()=>I2n,content_3764_7246:()=>G2n,content_3764_7248:()=>F2n,content_3764_7250:()=>q2n,content_3764_7252:()=>Q2n,content_3764_7254:()=>$2n,content_3764_7256:()=>e1n,content_3764_7258:()=>p1n,content_3764_726:()=>Pst,content_3764_7260:()=>c1n,content_3764_7262:()=>l1n,content_3764_7264:()=>d1n,content_3764_7266:()=>k1n,content_3764_7268:()=>M1n,content_3764_7270:()=>w1n,content_3764_7272:()=>x1n,content_3764_7274:()=>L1n,content_3764_7276:()=>N1n,content_3764_7278:()=>P1n,content_3764_728:()=>Ist,content_3764_7280:()=>I1n,content_3764_7282:()=>G1n,content_3764_7284:()=>F1n,content_3764_7286:()=>q1n,content_3764_7288:()=>Q1n,content_3764_7290:()=>$1n,content_3764_7292:()=>e8n,content_3764_7294:()=>p8n,content_3764_7296:()=>c8n,content_3764_7298:()=>l8n,content_3764_730:()=>Gst,content_3764_7300:()=>d8n,content_3764_7302:()=>k8n,content_3764_7304:()=>M8n,content_3764_7306:()=>w8n,content_3764_7308:()=>x8n,content_3764_7310:()=>L8n,content_3764_7312:()=>N8n,content_3764_7314:()=>P8n,content_3764_7316:()=>I8n,content_3764_7318:()=>G8n,content_3764_732:()=>Fst,content_3764_7320:()=>F8n,content_3764_7322:()=>q8n,content_3764_7324:()=>Q8n,content_3764_7326:()=>$8n,content_3764_7328:()=>e5n,content_3764_7330:()=>p5n,content_3764_7332:()=>c5n,content_3764_7334:()=>l5n,content_3764_7336:()=>d5n,content_3764_7338:()=>k5n,content_3764_734:()=>qst,content_3764_7340:()=>M5n,content_3764_7342:()=>w5n,content_3764_7344:()=>x5n,content_3764_7346:()=>L5n,content_3764_7348:()=>N5n,content_3764_7350:()=>P5n,content_3764_7352:()=>I5n,content_3764_7354:()=>G5n,content_3764_7356:()=>F5n,content_3764_7358:()=>q5n,content_3764_736:()=>Qst,content_3764_7360:()=>Q5n,content_3764_7362:()=>$5n,content_3764_7364:()=>e9n,content_3764_7366:()=>p9n,content_3764_7368:()=>c9n,content_3764_7370:()=>l9n,content_3764_7372:()=>d9n,content_3764_7374:()=>k9n,content_3764_7376:()=>M9n,content_3764_7378:()=>w9n,content_3764_738:()=>$st,content_3764_7380:()=>x9n,content_3764_7382:()=>L9n,content_3764_7384:()=>N9n,content_3764_7386:()=>P9n,content_3764_7388:()=>I9n,content_3764_7390:()=>G9n,content_3764_7392:()=>F9n,content_3764_7394:()=>q9n,content_3764_7396:()=>Q9n,content_3764_7398:()=>$9n,content_3764_74:()=>v$,content_3764_740:()=>ect,content_3764_7400:()=>eto,content_3764_7402:()=>pto,content_3764_7404:()=>cto,content_3764_7406:()=>lto,content_3764_7408:()=>dto,content_3764_7410:()=>kto,content_3764_7412:()=>Mto,content_3764_7414:()=>wto,content_3764_7416:()=>xto,content_3764_7418:()=>Lto,content_3764_742:()=>pct,content_3764_7420:()=>Nto,content_3764_7422:()=>Pto,content_3764_7424:()=>Ito,content_3764_7426:()=>Gto,content_3764_7428:()=>Fto,content_3764_7430:()=>qto,content_3764_7432:()=>Qto,content_3764_7434:()=>$to,content_3764_7436:()=>eeo,content_3764_7438:()=>peo,content_3764_744:()=>cct,content_3764_7440:()=>ceo,content_3764_7442:()=>leo,content_3764_7444:()=>deo,content_3764_7446:()=>keo,content_3764_7448:()=>Meo,content_3764_7450:()=>weo,content_3764_7452:()=>xeo,content_3764_7454:()=>Leo,content_3764_7456:()=>Neo,content_3764_7458:()=>Peo,content_3764_746:()=>lct,content_3764_7460:()=>Ieo,content_3764_7462:()=>Geo,content_3764_7464:()=>Feo,content_3764_7466:()=>qeo,content_3764_7468:()=>Qeo,content_3764_7470:()=>$eo,content_3764_7472:()=>eno,content_3764_7474:()=>pno,content_3764_7476:()=>cno,content_3764_7478:()=>lno,content_3764_748:()=>dct,content_3764_7480:()=>dno,content_3764_7482:()=>kno,content_3764_7484:()=>Mno,content_3764_7486:()=>wno,content_3764_7488:()=>xno,content_3764_7490:()=>Lno,content_3764_7492:()=>Nno,content_3764_7494:()=>Pno,content_3764_7496:()=>Ino,content_3764_7498:()=>Gno,content_3764_750:()=>kct,content_3764_7500:()=>Fno,content_3764_7502:()=>qno,content_3764_7504:()=>Qno,content_3764_7506:()=>$no,content_3764_7508:()=>eoo,content_3764_7510:()=>poo,content_3764_7512:()=>coo,content_3764_7514:()=>loo,content_3764_7516:()=>doo,content_3764_7518:()=>koo,content_3764_752:()=>Mct,content_3764_7520:()=>Moo,content_3764_7522:()=>woo,content_3764_7524:()=>xoo,content_3764_7526:()=>Loo,content_3764_7528:()=>Noo,content_3764_7530:()=>Poo,content_3764_7532:()=>Ioo,content_3764_7534:()=>Goo,content_3764_7536:()=>Foo,content_3764_7538:()=>qoo,content_3764_754:()=>wct,content_3764_7540:()=>Qoo,content_3764_7542:()=>$oo,content_3764_7544:()=>epo,content_3764_7546:()=>ppo,content_3764_7548:()=>cpo,content_3764_7550:()=>lpo,content_3764_7552:()=>dpo,content_3764_7554:()=>kpo,content_3764_7556:()=>Mpo,content_3764_7558:()=>wpo,content_3764_756:()=>xct,content_3764_7560:()=>xpo,content_3764_7562:()=>Lpo,content_3764_7564:()=>Npo,content_3764_7566:()=>Ppo,content_3764_7568:()=>Ipo,content_3764_7570:()=>Gpo,content_3764_7572:()=>Fpo,content_3764_7574:()=>qpo,content_3764_7576:()=>Qpo,content_3764_7578:()=>$po,content_3764_758:()=>Lct,content_3764_7580:()=>ero,content_3764_7582:()=>pro,content_3764_7584:()=>cro,content_3764_7586:()=>lro,content_3764_7588:()=>dro,content_3764_7590:()=>kro,content_3764_7592:()=>Mro,content_3764_7594:()=>wro,content_3764_7596:()=>xro,content_3764_7598:()=>Lro,content_3764_76:()=>b$,content_3764_760:()=>Nct,content_3764_7600:()=>Nro,content_3764_7602:()=>Pro,content_3764_7604:()=>Iro,content_3764_7606:()=>Gro,content_3764_7608:()=>Fro,content_3764_7610:()=>qro,content_3764_7612:()=>Qro,content_3764_7614:()=>$ro,content_3764_7616:()=>eso,content_3764_7618:()=>pso,content_3764_762:()=>Pct,content_3764_7620:()=>cso,content_3764_7622:()=>lso,content_3764_7624:()=>dso,content_3764_7626:()=>kso,content_3764_7628:()=>Mso,content_3764_7630:()=>wso,content_3764_7632:()=>xso,content_3764_7634:()=>Lso,content_3764_7636:()=>Nso,content_3764_7638:()=>Pso,content_3764_764:()=>Ict,content_3764_7640:()=>Iso,content_3764_7642:()=>Gso,content_3764_7644:()=>Fso,content_3764_7646:()=>qso,content_3764_7648:()=>Qso,content_3764_7650:()=>$so,content_3764_7652:()=>eco,content_3764_7654:()=>pco,content_3764_7656:()=>cco,content_3764_7658:()=>lco,content_3764_766:()=>Gct,content_3764_7660:()=>dco,content_3764_7662:()=>kco,content_3764_7664:()=>Mco,content_3764_7666:()=>wco,content_3764_7668:()=>xco,content_3764_7670:()=>Lco,content_3764_7672:()=>Nco,content_3764_7674:()=>Pco,content_3764_7676:()=>Ico,content_3764_7678:()=>Gco,content_3764_768:()=>Fct,content_3764_7680:()=>Fco,content_3764_7682:()=>qco,content_3764_7684:()=>Qco,content_3764_7686:()=>$co,content_3764_7688:()=>eao,content_3764_7690:()=>pao,content_3764_7692:()=>cao,content_3764_7694:()=>lao,content_3764_7696:()=>dao,content_3764_7698:()=>kao,content_3764_770:()=>qct,content_3764_7700:()=>Mao,content_3764_7702:()=>wao,content_3764_7704:()=>xao,content_3764_7706:()=>Lao,content_3764_7708:()=>Nao,content_3764_7710:()=>Pao,content_3764_7712:()=>Iao,content_3764_7714:()=>Gao,content_3764_7716:()=>Fao,content_3764_7718:()=>qao,content_3764_772:()=>Qct,content_3764_7720:()=>Qao,content_3764_7722:()=>$ao,content_3764_7724:()=>eio,content_3764_7726:()=>pio,content_3764_7728:()=>cio,content_3764_7730:()=>lio,content_3764_7732:()=>dio,content_3764_7734:()=>kio,content_3764_7736:()=>Mio,content_3764_7738:()=>wio,content_3764_774:()=>$ct,content_3764_7740:()=>xio,content_3764_7742:()=>Lio,content_3764_7744:()=>Nio,content_3764_7746:()=>Pio,content_3764_7748:()=>Iio,content_3764_7750:()=>Gio,content_3764_7752:()=>Fio,content_3764_7754:()=>qio,content_3764_7756:()=>Qio,content_3764_7758:()=>$io,content_3764_776:()=>eat,content_3764_7760:()=>elo,content_3764_7762:()=>plo,content_3764_7764:()=>clo,content_3764_7766:()=>llo,content_3764_7768:()=>dlo,content_3764_7770:()=>klo,content_3764_7772:()=>Mlo,content_3764_7774:()=>wlo,content_3764_7776:()=>xlo,content_3764_7778:()=>Llo,content_3764_778:()=>pat,content_3764_7780:()=>Nlo,content_3764_7782:()=>Plo,content_3764_7784:()=>Ilo,content_3764_7786:()=>Glo,content_3764_7788:()=>Flo,content_3764_7790:()=>qlo,content_3764_7792:()=>Qlo,content_3764_7794:()=>$lo,content_3764_7796:()=>euo,content_3764_7798:()=>puo,content_3764_78:()=>A$,content_3764_780:()=>cat,content_3764_7800:()=>cuo,content_3764_7802:()=>luo,content_3764_7804:()=>duo,content_3764_7806:()=>kuo,content_3764_7808:()=>Muo,content_3764_7810:()=>wuo,content_3764_7812:()=>xuo,content_3764_7814:()=>Luo,content_3764_7816:()=>Nuo,content_3764_7818:()=>Puo,content_3764_782:()=>lat,content_3764_7820:()=>Iuo,content_3764_7822:()=>Guo,content_3764_7824:()=>Fuo,content_3764_7826:()=>quo,content_3764_7828:()=>Quo,content_3764_7830:()=>$uo,content_3764_7832:()=>emo,content_3764_7834:()=>pmo,content_3764_7836:()=>cmo,content_3764_7838:()=>lmo,content_3764_784:()=>dat,content_3764_7840:()=>dmo,content_3764_7842:()=>kmo,content_3764_7844:()=>Mmo,content_3764_7846:()=>wmo,content_3764_7848:()=>xmo,content_3764_7850:()=>Lmo,content_3764_7852:()=>Nmo,content_3764_7854:()=>Pmo,content_3764_7856:()=>Imo,content_3764_7858:()=>Gmo,content_3764_786:()=>kat,content_3764_7860:()=>Fmo,content_3764_7862:()=>qmo,content_3764_7864:()=>Qmo,content_3764_7866:()=>$mo,content_3764_7868:()=>edo,content_3764_7870:()=>pdo,content_3764_7872:()=>cdo,content_3764_7874:()=>ldo,content_3764_7876:()=>ddo,content_3764_7878:()=>kdo,content_3764_788:()=>Mat,content_3764_7880:()=>Mdo,content_3764_7882:()=>wdo,content_3764_7884:()=>xdo,content_3764_7886:()=>Ldo,content_3764_7888:()=>Ndo,content_3764_7890:()=>Pdo,content_3764_7892:()=>Ido,content_3764_7894:()=>Gdo,content_3764_7896:()=>Fdo,content_3764_7898:()=>qdo,content_3764_790:()=>wat,content_3764_7900:()=>Qdo,content_3764_7902:()=>$do,content_3764_7904:()=>eho,content_3764_7906:()=>pho,content_3764_7908:()=>cho,content_3764_7910:()=>lho,content_3764_7912:()=>dho,content_3764_7914:()=>kho,content_3764_7916:()=>Mho,content_3764_7918:()=>who,content_3764_792:()=>xat,content_3764_7920:()=>xho,content_3764_7922:()=>Lho,content_3764_7924:()=>Nho,content_3764_7926:()=>Pho,content_3764_7928:()=>Iho,content_3764_7930:()=>Gho,content_3764_7932:()=>Fho,content_3764_7934:()=>qho,content_3764_7936:()=>Qho,content_3764_7938:()=>$ho,content_3764_794:()=>Lat,content_3764_7940:()=>efo,content_3764_7942:()=>pfo,content_3764_7944:()=>cfo,content_3764_7946:()=>lfo,content_3764_7948:()=>dfo,content_3764_7950:()=>kfo,content_3764_7952:()=>Mfo,content_3764_7954:()=>wfo,content_3764_7956:()=>xfo,content_3764_7958:()=>Lfo,content_3764_796:()=>Nat,content_3764_7960:()=>Nfo,content_3764_7962:()=>Pfo,content_3764_7964:()=>Ifo,content_3764_7966:()=>Gfo,content_3764_7968:()=>Ffo,content_3764_7970:()=>qfo,content_3764_7972:()=>Qfo,content_3764_7974:()=>$fo,content_3764_7976:()=>eko,content_3764_7978:()=>pko,content_3764_798:()=>Pat,content_3764_7980:()=>cko,content_3764_7982:()=>lko,content_3764_7984:()=>dko,content_3764_7986:()=>kko,content_3764_7988:()=>Mko,content_3764_7990:()=>wko,content_3764_7992:()=>xko,content_3764_7994:()=>Lko,content_3764_7996:()=>Nko,content_3764_7998:()=>Pko,content_3764_8:()=>RH,content_3764_80:()=>R$,content_3764_800:()=>Iat,content_3764_8000:()=>Iko,content_3764_8002:()=>Gko,content_3764_8004:()=>Fko,content_3764_8006:()=>qko,content_3764_8008:()=>Qko,content_3764_8010:()=>$ko,content_3764_8012:()=>eyo,content_3764_8014:()=>pyo,content_3764_8016:()=>cyo,content_3764_8018:()=>lyo,content_3764_802:()=>Gat,content_3764_8020:()=>dyo,content_3764_8022:()=>kyo,content_3764_8024:()=>Myo,content_3764_8026:()=>wyo,content_3764_8028:()=>xyo,content_3764_8030:()=>Lyo,content_3764_8032:()=>Nyo,content_3764_8034:()=>Pyo,content_3764_8036:()=>Iyo,content_3764_8038:()=>Gyo,content_3764_804:()=>Fat,content_3764_8040:()=>Fyo,content_3764_8042:()=>qyo,content_3764_8044:()=>Qyo,content_3764_8046:()=>$yo,content_3764_8048:()=>eDo,content_3764_8050:()=>pDo,content_3764_8052:()=>cDo,content_3764_8054:()=>lDo,content_3764_8056:()=>dDo,content_3764_8058:()=>kDo,content_3764_806:()=>qat,content_3764_8060:()=>MDo,content_3764_8062:()=>wDo,content_3764_8064:()=>xDo,content_3764_8066:()=>LDo,content_3764_8068:()=>NDo,content_3764_8070:()=>PDo,content_3764_8072:()=>IDo,content_3764_8074:()=>GDo,content_3764_8076:()=>FDo,content_3764_8078:()=>qDo,content_3764_808:()=>Qat,content_3764_8080:()=>QDo,content_3764_8082:()=>$Do,content_3764_8084:()=>eMo,content_3764_8086:()=>pMo,content_3764_8088:()=>cMo,content_3764_8090:()=>lMo,content_3764_8092:()=>dMo,content_3764_8094:()=>kMo,content_3764_8096:()=>MMo,content_3764_8098:()=>wMo,content_3764_810:()=>$at,content_3764_8100:()=>xMo,content_3764_8102:()=>LMo,content_3764_8104:()=>NMo,content_3764_8106:()=>PMo,content_3764_8108:()=>IMo,content_3764_8110:()=>GMo,content_3764_8112:()=>FMo,content_3764_8114:()=>qMo,content_3764_8116:()=>QMo,content_3764_8118:()=>$Mo,content_3764_812:()=>eit,content_3764_8120:()=>eXo,content_3764_8122:()=>pXo,content_3764_8124:()=>cXo,content_3764_8126:()=>lXo,content_3764_8128:()=>dXo,content_3764_8130:()=>kXo,content_3764_8132:()=>MXo,content_3764_8134:()=>wXo,content_3764_8136:()=>xXo,content_3764_8138:()=>LXo,content_3764_814:()=>pit,content_3764_8140:()=>NXo,content_3764_8142:()=>PXo,content_3764_8144:()=>IXo,content_3764_8146:()=>GXo,content_3764_8148:()=>FXo,content_3764_8150:()=>qXo,content_3764_8152:()=>QXo,content_3764_8154:()=>$Xo,content_3764_8156:()=>e_o,content_3764_8158:()=>p_o,content_3764_816:()=>cit,content_3764_8160:()=>c_o,content_3764_8162:()=>l_o,content_3764_8164:()=>d_o,content_3764_8166:()=>k_o,content_3764_8168:()=>M_o,content_3764_8170:()=>w_o,content_3764_8172:()=>x_o,content_3764_8174:()=>L_o,content_3764_8176:()=>N_o,content_3764_8178:()=>P_o,content_3764_818:()=>lit,content_3764_8180:()=>I_o,content_3764_8182:()=>G_o,content_3764_8184:()=>F_o,content_3764_8186:()=>q_o,content_3764_8188:()=>Q_o,content_3764_8190:()=>$_o,content_3764_8192:()=>ewo,content_3764_8194:()=>pwo,content_3764_8196:()=>cwo,content_3764_8198:()=>lwo,content_3764_82:()=>B$,content_3764_820:()=>dit,content_3764_8200:()=>dwo,content_3764_8202:()=>kwo,content_3764_8204:()=>Mwo,content_3764_8206:()=>wwo,content_3764_8208:()=>xwo,content_3764_8210:()=>Lwo,content_3764_8212:()=>Nwo,content_3764_8214:()=>Pwo,content_3764_8216:()=>Iwo,content_3764_8218:()=>Gwo,content_3764_822:()=>kit,content_3764_8220:()=>Fwo,content_3764_8222:()=>qwo,content_3764_8224:()=>Qwo,content_3764_8226:()=>$wo,content_3764_8228:()=>eTo,content_3764_8230:()=>pTo,content_3764_8232:()=>cTo,content_3764_8234:()=>lTo,content_3764_8236:()=>dTo,content_3764_8238:()=>kTo,content_3764_824:()=>Mit,content_3764_8240:()=>MTo,content_3764_8242:()=>wTo,content_3764_8244:()=>xTo,content_3764_8246:()=>LTo,content_3764_8248:()=>NTo,content_3764_8250:()=>PTo,content_3764_8252:()=>ITo,content_3764_8254:()=>GTo,content_3764_8256:()=>FTo,content_3764_8258:()=>qTo,content_3764_826:()=>wit,content_3764_8260:()=>QTo,content_3764_8262:()=>$To,content_3764_8264:()=>eCo,content_3764_8266:()=>pCo,content_3764_8268:()=>cCo,content_3764_8270:()=>lCo,content_3764_8272:()=>dCo,content_3764_8274:()=>kCo,content_3764_8276:()=>MCo,content_3764_8278:()=>wCo,content_3764_828:()=>xit,content_3764_8280:()=>xCo,content_3764_8282:()=>LCo,content_3764_8284:()=>NCo,content_3764_8286:()=>PCo,content_3764_8288:()=>ICo,content_3764_8290:()=>GCo,content_3764_8292:()=>FCo,content_3764_8294:()=>qCo,content_3764_8296:()=>QCo,content_3764_8298:()=>$Co,content_3764_830:()=>Lit,content_3764_8300:()=>exo,content_3764_8302:()=>pxo,content_3764_8304:()=>cxo,content_3764_8306:()=>lxo,content_3764_8308:()=>dxo,content_3764_8310:()=>kxo,content_3764_8312:()=>Mxo,content_3764_8314:()=>wxo,content_3764_8316:()=>xxo,content_3764_8318:()=>Lxo,content_3764_832:()=>Nit,content_3764_8320:()=>Nxo,content_3764_8322:()=>Pxo,content_3764_8324:()=>Ixo,content_3764_8326:()=>Gxo,content_3764_8328:()=>Fxo,content_3764_8330:()=>qxo,content_3764_8332:()=>Qxo,content_3764_8334:()=>$xo,content_3764_8336:()=>ego,content_3764_8338:()=>pgo,content_3764_834:()=>Pit,content_3764_8340:()=>cgo,content_3764_8342:()=>lgo,content_3764_8344:()=>dgo,content_3764_8346:()=>kgo,content_3764_8348:()=>Mgo,content_3764_8350:()=>wgo,content_3764_8352:()=>xgo,content_3764_8354:()=>Lgo,content_3764_8356:()=>Ngo,content_3764_8358:()=>Pgo,content_3764_836:()=>Iit,content_3764_8360:()=>Igo,content_3764_8362:()=>Ggo,content_3764_8364:()=>Fgo,content_3764_8366:()=>qgo,content_3764_8368:()=>Qgo,content_3764_8370:()=>$go,content_3764_8372:()=>evo,content_3764_8374:()=>pvo,content_3764_8376:()=>cvo,content_3764_8378:()=>lvo,content_3764_838:()=>Git,content_3764_8380:()=>dvo,content_3764_8382:()=>kvo,content_3764_8384:()=>Mvo,content_3764_8386:()=>wvo,content_3764_8388:()=>xvo,content_3764_8390:()=>Lvo,content_3764_8392:()=>Nvo,content_3764_8394:()=>Pvo,content_3764_8396:()=>Ivo,content_3764_8398:()=>Gvo,content_3764_84:()=>O$,content_3764_840:()=>Fit,content_3764_8400:()=>Fvo,content_3764_8402:()=>qvo,content_3764_8404:()=>Qvo,content_3764_8406:()=>$vo,content_3764_8408:()=>eLo,content_3764_8410:()=>pLo,content_3764_8412:()=>cLo,content_3764_8414:()=>lLo,content_3764_8416:()=>dLo,content_3764_8418:()=>kLo,content_3764_842:()=>qit,content_3764_8420:()=>MLo,content_3764_8422:()=>wLo,content_3764_8424:()=>xLo,content_3764_8426:()=>LLo,content_3764_8428:()=>NLo,content_3764_8430:()=>PLo,content_3764_8432:()=>ILo,content_3764_8434:()=>GLo,content_3764_8436:()=>FLo,content_3764_8438:()=>qLo,content_3764_844:()=>Qit,content_3764_8440:()=>QLo,content_3764_8442:()=>$Lo,content_3764_8444:()=>eZo,content_3764_8446:()=>pZo,content_3764_8448:()=>cZo,content_3764_8450:()=>lZo,content_3764_8452:()=>dZo,content_3764_8454:()=>kZo,content_3764_8456:()=>MZo,content_3764_8458:()=>wZo,content_3764_846:()=>$it,content_3764_8460:()=>xZo,content_3764_8462:()=>LZo,content_3764_8464:()=>NZo,content_3764_8466:()=>PZo,content_3764_8468:()=>IZo,content_3764_8470:()=>GZo,content_3764_8472:()=>FZo,content_3764_8474:()=>qZo,content_3764_8476:()=>QZo,content_3764_8478:()=>$Zo,content_3764_848:()=>elt,content_3764_8480:()=>ebo,content_3764_8482:()=>pbo,content_3764_8484:()=>cbo,content_3764_8486:()=>lbo,content_3764_8488:()=>dbo,content_3764_8490:()=>kbo,content_3764_8492:()=>Mbo,content_3764_8494:()=>wbo,content_3764_8496:()=>xbo,content_3764_8498:()=>Lbo,content_3764_850:()=>plt,content_3764_8500:()=>Nbo,content_3764_8502:()=>Pbo,content_3764_8504:()=>Ibo,content_3764_8506:()=>Gbo,content_3764_8508:()=>Fbo,content_3764_8510:()=>qbo,content_3764_8512:()=>Qbo,content_3764_8514:()=>$bo,content_3764_8516:()=>eNo,content_3764_8518:()=>pNo,content_3764_852:()=>clt,content_3764_8520:()=>cNo,content_3764_8522:()=>lNo,content_3764_8524:()=>dNo,content_3764_8526:()=>kNo,content_3764_8528:()=>MNo,content_3764_8530:()=>wNo,content_3764_8532:()=>xNo,content_3764_8534:()=>LNo,content_3764_8536:()=>NNo,content_3764_8538:()=>PNo,content_3764_854:()=>llt,content_3764_8540:()=>INo,content_3764_8542:()=>GNo,content_3764_8544:()=>FNo,content_3764_8546:()=>qNo,content_3764_8548:()=>QNo,content_3764_8550:()=>$No,content_3764_8552:()=>ezo,content_3764_8554:()=>pzo,content_3764_8556:()=>czo,content_3764_8558:()=>lzo,content_3764_856:()=>dlt,content_3764_8560:()=>dzo,content_3764_8562:()=>kzo,content_3764_8564:()=>Mzo,content_3764_8566:()=>wzo,content_3764_8568:()=>xzo,content_3764_8570:()=>Lzo,content_3764_8572:()=>Nzo,content_3764_8574:()=>Pzo,content_3764_8576:()=>Izo,content_3764_8578:()=>Gzo,content_3764_858:()=>klt,content_3764_8580:()=>Fzo,content_3764_8582:()=>qzo,content_3764_8584:()=>Qzo,content_3764_8586:()=>$zo,content_3764_8588:()=>eAo,content_3764_8590:()=>pAo,content_3764_8592:()=>cAo,content_3764_8594:()=>lAo,content_3764_8596:()=>dAo,content_3764_8598:()=>kAo,content_3764_86:()=>V$,content_3764_860:()=>Mlt,content_3764_8600:()=>MAo,content_3764_8602:()=>wAo,content_3764_8604:()=>xAo,content_3764_8606:()=>LAo,content_3764_8608:()=>NAo,content_3764_8610:()=>PAo,content_3764_8612:()=>IAo,content_3764_8614:()=>GAo,content_3764_8616:()=>FAo,content_3764_8618:()=>qAo,content_3764_862:()=>wlt,content_3764_8620:()=>QAo,content_3764_8622:()=>$Ao,content_3764_8624:()=>ePo,content_3764_8626:()=>pPo,content_3764_8628:()=>cPo,content_3764_8630:()=>lPo,content_3764_8632:()=>dPo,content_3764_8634:()=>kPo,content_3764_8636:()=>MPo,content_3764_8638:()=>wPo,content_3764_864:()=>xlt,content_3764_8640:()=>xPo,content_3764_8642:()=>LPo,content_3764_8644:()=>NPo,content_3764_8646:()=>PPo,content_3764_8648:()=>IPo,content_3764_8650:()=>GPo,content_3764_8652:()=>FPo,content_3764_8654:()=>qPo,content_3764_8656:()=>QPo,content_3764_8658:()=>$Po,content_3764_866:()=>Llt,content_3764_8660:()=>eWo,content_3764_8662:()=>pWo,content_3764_8664:()=>cWo,content_3764_8666:()=>lWo,content_3764_8668:()=>dWo,content_3764_8670:()=>kWo,content_3764_8672:()=>MWo,content_3764_8674:()=>wWo,content_3764_8676:()=>xWo,content_3764_8678:()=>LWo,content_3764_868:()=>Nlt,content_3764_8680:()=>NWo,content_3764_8682:()=>PWo,content_3764_8684:()=>IWo,content_3764_8686:()=>GWo,content_3764_8688:()=>FWo,content_3764_8690:()=>qWo,content_3764_8692:()=>QWo,content_3764_8694:()=>$Wo,content_3764_8696:()=>eRo,content_3764_8698:()=>pRo,content_3764_870:()=>Plt,content_3764_8700:()=>cRo,content_3764_8702:()=>lRo,content_3764_8704:()=>dRo,content_3764_8706:()=>kRo,content_3764_8708:()=>MRo,content_3764_8710:()=>wRo,content_3764_8712:()=>xRo,content_3764_8714:()=>LRo,content_3764_8716:()=>NRo,content_3764_8718:()=>PRo,content_3764_872:()=>Ilt,content_3764_8720:()=>IRo,content_3764_8722:()=>GRo,content_3764_8724:()=>FRo,content_3764_8726:()=>qRo,content_3764_8728:()=>QRo,content_3764_8730:()=>$Ro,content_3764_8732:()=>eIo,content_3764_8734:()=>pIo,content_3764_8736:()=>cIo,content_3764_8738:()=>lIo,content_3764_874:()=>Glt,content_3764_8740:()=>dIo,content_3764_8742:()=>kIo,content_3764_8744:()=>MIo,content_3764_8746:()=>wIo,content_3764_8748:()=>xIo,content_3764_8750:()=>LIo,content_3764_8752:()=>NIo,content_3764_8754:()=>PIo,content_3764_8756:()=>IIo,content_3764_8758:()=>GIo,content_3764_876:()=>Flt,content_3764_8760:()=>FIo,content_3764_8762:()=>qIo,content_3764_8764:()=>QIo,content_3764_8766:()=>$Io,content_3764_8768:()=>eSo,content_3764_8770:()=>pSo,content_3764_8772:()=>cSo,content_3764_8774:()=>lSo,content_3764_8776:()=>dSo,content_3764_8778:()=>kSo,content_3764_878:()=>qlt,content_3764_8780:()=>MSo,content_3764_8782:()=>wSo,content_3764_8784:()=>xSo,content_3764_8786:()=>LSo,content_3764_8788:()=>NSo,content_3764_8790:()=>PSo,content_3764_8792:()=>ISo,content_3764_8794:()=>GSo,content_3764_8796:()=>FSo,content_3764_8798:()=>qSo,content_3764_88:()=>Y$,content_3764_880:()=>Qlt,content_3764_8800:()=>QSo,content_3764_8802:()=>$So,content_3764_8804:()=>eBo,content_3764_8806:()=>pBo,content_3764_8808:()=>cBo,content_3764_8810:()=>lBo,content_3764_8812:()=>dBo,content_3764_8814:()=>kBo,content_3764_8816:()=>MBo,content_3764_8818:()=>wBo,content_3764_882:()=>$lt,content_3764_8820:()=>xBo,content_3764_8822:()=>LBo,content_3764_8824:()=>NBo,content_3764_8826:()=>PBo,content_3764_8828:()=>IBo,content_3764_8830:()=>GBo,content_3764_8832:()=>FBo,content_3764_8834:()=>qBo,content_3764_8836:()=>QBo,content_3764_8838:()=>$Bo,content_3764_884:()=>eut,content_3764_8840:()=>eGo,content_3764_8842:()=>pGo,content_3764_8844:()=>cGo,content_3764_8846:()=>lGo,content_3764_8848:()=>dGo,content_3764_8850:()=>kGo,content_3764_8852:()=>MGo,content_3764_8854:()=>wGo,content_3764_8856:()=>xGo,content_3764_8858:()=>LGo,content_3764_886:()=>put,content_3764_8860:()=>NGo,content_3764_8862:()=>PGo,content_3764_8864:()=>IGo,content_3764_8866:()=>GGo,content_3764_8868:()=>FGo,content_3764_8870:()=>qGo,content_3764_8872:()=>QGo,content_3764_8874:()=>$Go,content_3764_8876:()=>eEo,content_3764_8878:()=>pEo,content_3764_888:()=>cut,content_3764_8880:()=>cEo,content_3764_8882:()=>lEo,content_3764_8884:()=>dEo,content_3764_8886:()=>kEo,content_3764_8888:()=>MEo,content_3764_8890:()=>wEo,content_3764_8892:()=>xEo,content_3764_8894:()=>LEo,content_3764_8896:()=>NEo,content_3764_8898:()=>PEo,content_3764_890:()=>lut,content_3764_8900:()=>IEo,content_3764_8902:()=>GEo,content_3764_8904:()=>FEo,content_3764_8906:()=>qEo,content_3764_8908:()=>QEo,content_3764_8910:()=>$Eo,content_3764_8912:()=>eOo,content_3764_8914:()=>pOo,content_3764_8916:()=>cOo,content_3764_8918:()=>lOo,content_3764_892:()=>dut,content_3764_8920:()=>dOo,content_3764_8922:()=>kOo,content_3764_8924:()=>MOo,content_3764_8926:()=>wOo,content_3764_8928:()=>xOo,content_3764_8930:()=>LOo,content_3764_8932:()=>NOo,content_3764_8934:()=>POo,content_3764_8936:()=>IOo,content_3764_8938:()=>GOo,content_3764_894:()=>kut,content_3764_8940:()=>FOo,content_3764_8942:()=>qOo,content_3764_8944:()=>QOo,content_3764_8946:()=>$Oo,content_3764_8948:()=>eFo,content_3764_8950:()=>pFo,content_3764_8952:()=>cFo,content_3764_8954:()=>lFo,content_3764_8956:()=>dFo,content_3764_8958:()=>kFo,content_3764_896:()=>Mut,content_3764_8960:()=>MFo,content_3764_8962:()=>wFo,content_3764_8964:()=>xFo,content_3764_8966:()=>LFo,content_3764_8968:()=>NFo,content_3764_8970:()=>PFo,content_3764_8972:()=>IFo,content_3764_8974:()=>GFo,content_3764_8976:()=>FFo,content_3764_8978:()=>qFo,content_3764_898:()=>wut,content_3764_8980:()=>QFo,content_3764_8982:()=>$Fo,content_3764_8984:()=>eUo,content_3764_8986:()=>pUo,content_3764_8988:()=>cUo,content_3764_8990:()=>lUo,content_3764_8992:()=>dUo,content_3764_8994:()=>kUo,content_3764_8996:()=>MUo,content_3764_8998:()=>wUo,content_3764_90:()=>K$,content_3764_900:()=>xut,content_3764_9000:()=>xUo,content_3764_9002:()=>LUo,content_3764_9004:()=>NUo,content_3764_9006:()=>PUo,content_3764_9008:()=>IUo,content_3764_9010:()=>GUo,content_3764_9012:()=>FUo,content_3764_9014:()=>qUo,content_3764_9016:()=>QUo,content_3764_9018:()=>$Uo,content_3764_902:()=>Lut,content_3764_9020:()=>eVo,content_3764_9022:()=>pVo,content_3764_9024:()=>cVo,content_3764_9026:()=>lVo,content_3764_9028:()=>dVo,content_3764_9030:()=>kVo,content_3764_9032:()=>MVo,content_3764_9034:()=>wVo,content_3764_9036:()=>xVo,content_3764_9038:()=>LVo,content_3764_904:()=>Nut,content_3764_9040:()=>NVo,content_3764_9042:()=>PVo,content_3764_9044:()=>IVo,content_3764_9046:()=>GVo,content_3764_9048:()=>FVo,content_3764_9050:()=>qVo,content_3764_9052:()=>QVo,content_3764_9054:()=>$Vo,content_3764_9056:()=>eqo,content_3764_9058:()=>pqo,content_3764_906:()=>Put,content_3764_9060:()=>cqo,content_3764_9062:()=>lqo,content_3764_9064:()=>dqo,content_3764_9066:()=>kqo,content_3764_9068:()=>Mqo,content_3764_9070:()=>wqo,content_3764_9072:()=>xqo,content_3764_9074:()=>Lqo,content_3764_9076:()=>Nqo,content_3764_9078:()=>Pqo,content_3764_908:()=>Iut,content_3764_9080:()=>Iqo,content_3764_9082:()=>Gqo,content_3764_9084:()=>Fqo,content_3764_9086:()=>qqo,content_3764_9088:()=>Qqo,content_3764_9090:()=>$qo,content_3764_9092:()=>ejo,content_3764_9094:()=>pjo,content_3764_9096:()=>cjo,content_3764_9098:()=>ljo,content_3764_910:()=>Gut,content_3764_9100:()=>djo,content_3764_9102:()=>kjo,content_3764_9104:()=>Mjo,content_3764_9106:()=>wjo,content_3764_9108:()=>xjo,content_3764_9110:()=>Ljo,content_3764_9112:()=>Njo,content_3764_9114:()=>Pjo,content_3764_9116:()=>Ijo,content_3764_9118:()=>Gjo,content_3764_912:()=>Fut,content_3764_9120:()=>Fjo,content_3764_9122:()=>qjo,content_3764_9124:()=>Qjo,content_3764_9126:()=>$jo,content_3764_9128:()=>eYo,content_3764_9130:()=>pYo,content_3764_9132:()=>cYo,content_3764_9134:()=>lYo,content_3764_9136:()=>dYo,content_3764_9138:()=>kYo,content_3764_914:()=>qut,content_3764_9140:()=>MYo,content_3764_9142:()=>wYo,content_3764_9144:()=>xYo,content_3764_9146:()=>LYo,content_3764_9148:()=>NYo,content_3764_9150:()=>PYo,content_3764_9152:()=>IYo,content_3764_9154:()=>GYo,content_3764_9156:()=>FYo,content_3764_9158:()=>qYo,content_3764_916:()=>Qut,content_3764_9160:()=>QYo,content_3764_9162:()=>$Yo,content_3764_9164:()=>eQo,content_3764_9166:()=>pQo,content_3764_9168:()=>cQo,content_3764_9170:()=>lQo,content_3764_9172:()=>dQo,content_3764_9174:()=>kQo,content_3764_9176:()=>MQo,content_3764_9178:()=>wQo,content_3764_918:()=>$ut,content_3764_9180:()=>xQo,content_3764_9182:()=>LQo,content_3764_9184:()=>NQo,content_3764_9186:()=>PQo,content_3764_9188:()=>IQo,content_3764_9190:()=>GQo,content_3764_9192:()=>FQo,content_3764_9194:()=>qQo,content_3764_9196:()=>QQo,content_3764_9198:()=>$Qo,content_3764_92:()=>tJ,content_3764_920:()=>emt,content_3764_9200:()=>eHo,content_3764_9202:()=>pHo,content_3764_9204:()=>cHo,content_3764_9206:()=>lHo,content_3764_9208:()=>dHo,content_3764_9210:()=>kHo,content_3764_9212:()=>MHo,content_3764_9214:()=>wHo,content_3764_9216:()=>xHo,content_3764_9218:()=>LHo,content_3764_922:()=>pmt,content_3764_9220:()=>NHo,content_3764_9222:()=>PHo,content_3764_9224:()=>IHo,content_3764_9226:()=>GHo,content_3764_9228:()=>FHo,content_3764_9230:()=>qHo,content_3764_9232:()=>QHo,content_3764_9234:()=>$Ho,content_3764_9236:()=>eKo,content_3764_9238:()=>pKo,content_3764_924:()=>cmt,content_3764_9240:()=>cKo,content_3764_9242:()=>lKo,content_3764_9244:()=>dKo,content_3764_9246:()=>kKo,content_3764_9248:()=>MKo,content_3764_9250:()=>wKo,content_3764_9252:()=>xKo,content_3764_9254:()=>LKo,content_3764_9256:()=>NKo,content_3764_9258:()=>PKo,content_3764_926:()=>lmt,content_3764_9260:()=>IKo,content_3764_9262:()=>GKo,content_3764_9264:()=>FKo,content_3764_9266:()=>qKo,content_3764_9268:()=>QKo,content_3764_9270:()=>$Ko,content_3764_9272:()=>e$o,content_3764_9274:()=>p$o,content_3764_9276:()=>c$o,content_3764_9278:()=>l$o,content_3764_928:()=>dmt,content_3764_9280:()=>d$o,content_3764_9282:()=>k$o,content_3764_9284:()=>M$o,content_3764_9286:()=>w$o,content_3764_9288:()=>x$o,content_3764_9290:()=>L$o,content_3764_9292:()=>N$o,content_3764_9294:()=>P$o,content_3764_9296:()=>I$o,content_3764_9298:()=>G$o,content_3764_930:()=>kmt,content_3764_9300:()=>F$o,content_3764_9302:()=>q$o,content_3764_9304:()=>Q$o,content_3764_9306:()=>$$o,content_3764_9308:()=>eJo,content_3764_9310:()=>pJo,content_3764_9312:()=>cJo,content_3764_9314:()=>lJo,content_3764_9316:()=>dJo,content_3764_9318:()=>kJo,content_3764_932:()=>Mmt,content_3764_9320:()=>MJo,content_3764_9322:()=>wJo,content_3764_9324:()=>xJo,content_3764_9326:()=>LJo,content_3764_9328:()=>NJo,content_3764_9330:()=>PJo,content_3764_9332:()=>IJo,content_3764_9334:()=>GJo,content_3764_9336:()=>FJo,content_3764_9338:()=>qJo,content_3764_934:()=>wmt,content_3764_9340:()=>QJo,content_3764_9342:()=>$Jo,content_3764_9344:()=>e0o,content_3764_9346:()=>p0o,content_3764_9348:()=>c0o,content_3764_9350:()=>l0o,content_3764_9352:()=>d0o,content_3764_9354:()=>k0o,content_3764_9356:()=>M0o,content_3764_9358:()=>w0o,content_3764_936:()=>xmt,content_3764_9360:()=>x0o,content_3764_9362:()=>L0o,content_3764_9364:()=>N0o,content_3764_9366:()=>P0o,content_3764_9368:()=>I0o,content_3764_9370:()=>G0o,content_3764_9372:()=>F0o,content_3764_9374:()=>q0o,content_3764_9376:()=>Q0o,content_3764_9378:()=>$0o,content_3764_938:()=>Lmt,content_3764_9380:()=>e4o,content_3764_9382:()=>p4o,content_3764_9384:()=>c4o,content_3764_9386:()=>l4o,content_3764_9388:()=>d4o,content_3764_9390:()=>k4o,content_3764_9392:()=>M4o,content_3764_9394:()=>w4o,content_3764_9396:()=>x4o,content_3764_9398:()=>L4o,content_3764_94:()=>oJ,content_3764_940:()=>Nmt,content_3764_9400:()=>N4o,content_3764_9402:()=>P4o,content_3764_9404:()=>I4o,content_3764_9406:()=>G4o,content_3764_9408:()=>F4o,content_3764_9410:()=>q4o,content_3764_9412:()=>Q4o,content_3764_9414:()=>$4o,content_3764_9416:()=>e6o,content_3764_9418:()=>p6o,content_3764_942:()=>Pmt,content_3764_9420:()=>c6o,content_3764_9422:()=>l6o,content_3764_9424:()=>d6o,content_3764_9426:()=>k6o,content_3764_9428:()=>M6o,content_3764_9430:()=>w6o,content_3764_9432:()=>x6o,content_3764_9434:()=>L6o,content_3764_9436:()=>N6o,content_3764_9438:()=>P6o,content_3764_944:()=>Imt,content_3764_9440:()=>I6o,content_3764_9442:()=>G6o,content_3764_9444:()=>F6o,content_3764_9446:()=>q6o,content_3764_9448:()=>Q6o,content_3764_9450:()=>$6o,content_3764_9452:()=>e3o,content_3764_9454:()=>p3o,content_3764_9456:()=>c3o,content_3764_9458:()=>l3o,content_3764_946:()=>Gmt,content_3764_9460:()=>d3o,content_3764_9462:()=>k3o,content_3764_9464:()=>M3o,content_3764_9466:()=>w3o,content_3764_9468:()=>x3o,content_3764_9470:()=>L3o,content_3764_9472:()=>N3o,content_3764_9474:()=>P3o,content_3764_9476:()=>I3o,content_3764_9478:()=>G3o,content_3764_948:()=>Fmt,content_3764_9480:()=>F3o,content_3764_9482:()=>q3o,content_3764_9484:()=>Q3o,content_3764_9486:()=>$3o,content_3764_9488:()=>e7o,content_3764_9490:()=>p7o,content_3764_9492:()=>c7o,content_3764_9494:()=>l7o,content_3764_9496:()=>d7o,content_3764_9498:()=>k7o,content_3764_950:()=>qmt,content_3764_9500:()=>M7o,content_3764_9502:()=>w7o,content_3764_9504:()=>x7o,content_3764_9506:()=>L7o,content_3764_9508:()=>N7o,content_3764_9510:()=>P7o,content_3764_9512:()=>I7o,content_3764_9514:()=>G7o,content_3764_9516:()=>F7o,content_3764_9518:()=>q7o,content_3764_952:()=>Qmt,content_3764_9520:()=>Q7o,content_3764_9522:()=>$7o,content_3764_9524:()=>e2o,content_3764_9526:()=>p2o,content_3764_9528:()=>c2o,content_3764_9530:()=>l2o,content_3764_9532:()=>d2o,content_3764_9534:()=>k2o,content_3764_9536:()=>M2o,content_3764_9538:()=>w2o,content_3764_954:()=>$mt,content_3764_9540:()=>x2o,content_3764_9542:()=>L2o,content_3764_9544:()=>N2o,content_3764_9546:()=>P2o,content_3764_9548:()=>I2o,content_3764_9550:()=>G2o,content_3764_9552:()=>F2o,content_3764_9554:()=>q2o,content_3764_9556:()=>Q2o,content_3764_9558:()=>$2o,content_3764_956:()=>edt,content_3764_9560:()=>e1o,content_3764_9562:()=>p1o,content_3764_9564:()=>c1o,content_3764_9566:()=>l1o,content_3764_9568:()=>d1o,content_3764_9570:()=>k1o,content_3764_9572:()=>M1o,content_3764_9574:()=>w1o,content_3764_9576:()=>x1o,content_3764_9578:()=>L1o,content_3764_958:()=>pdt,content_3764_9580:()=>N1o,content_3764_9582:()=>P1o,content_3764_9584:()=>I1o,content_3764_9586:()=>G1o,content_3764_9588:()=>F1o,content_3764_9590:()=>q1o,content_3764_9592:()=>Q1o,content_3764_9594:()=>$1o,content_3764_9596:()=>e8o,content_3764_9598:()=>p8o,content_3764_96:()=>sJ,content_3764_960:()=>cdt,content_3764_9600:()=>c8o,content_3764_9602:()=>l8o,content_3764_9604:()=>d8o,content_3764_9606:()=>k8o,content_3764_9608:()=>M8o,content_3764_9610:()=>w8o,content_3764_9612:()=>x8o,content_3764_9614:()=>L8o,content_3764_9616:()=>N8o,content_3764_9618:()=>P8o,content_3764_962:()=>ldt,content_3764_9620:()=>I8o,content_3764_9622:()=>G8o,content_3764_9624:()=>F8o,content_3764_9626:()=>q8o,content_3764_9628:()=>Q8o,content_3764_9630:()=>$8o,content_3764_9632:()=>e5o,content_3764_9634:()=>p5o,content_3764_9636:()=>c5o,content_3764_9638:()=>l5o,content_3764_964:()=>ddt,content_3764_9640:()=>d5o,content_3764_9642:()=>k5o,content_3764_9644:()=>M5o,content_3764_9646:()=>w5o,content_3764_9648:()=>x5o,content_3764_9650:()=>L5o,content_3764_9652:()=>N5o,content_3764_9654:()=>P5o,content_3764_9656:()=>I5o,content_3764_9658:()=>G5o,content_3764_966:()=>kdt,content_3764_9660:()=>F5o,content_3764_9662:()=>q5o,content_3764_9664:()=>Q5o,content_3764_9666:()=>$5o,content_3764_9668:()=>e9o,content_3764_9670:()=>p9o,content_3764_9672:()=>c9o,content_3764_9674:()=>l9o,content_3764_9676:()=>d9o,content_3764_9678:()=>k9o,content_3764_968:()=>Mdt,content_3764_9680:()=>M9o,content_3764_9682:()=>w9o,content_3764_9684:()=>x9o,content_3764_9686:()=>L9o,content_3764_9688:()=>N9o,content_3764_9690:()=>P9o,content_3764_9692:()=>I9o,content_3764_9694:()=>G9o,content_3764_9696:()=>F9o,content_3764_9698:()=>q9o,content_3764_970:()=>wdt,content_3764_9700:()=>Q9o,content_3764_9702:()=>$9o,content_3764_9704:()=>etp,content_3764_9706:()=>ptp,content_3764_9708:()=>ctp,content_3764_9710:()=>ltp,content_3764_9712:()=>dtp,content_3764_9714:()=>ktp,content_3764_9716:()=>Mtp,content_3764_9718:()=>wtp,content_3764_972:()=>xdt,content_3764_9720:()=>xtp,content_3764_9722:()=>Ltp,content_3764_9724:()=>Ntp,content_3764_9726:()=>Ptp,content_3764_9728:()=>Itp,content_3764_9730:()=>Gtp,content_3764_9732:()=>Ftp,content_3764_9734:()=>qtp,content_3764_9736:()=>Qtp,content_3764_9738:()=>$tp,content_3764_974:()=>Ldt,content_3764_9740:()=>eep,content_3764_9742:()=>pep,content_3764_9744:()=>cep,content_3764_9746:()=>lep,content_3764_9748:()=>dep,content_3764_9750:()=>kep,content_3764_9752:()=>Mep,content_3764_9754:()=>wep,content_3764_9756:()=>xep,content_3764_9758:()=>Lep,content_3764_976:()=>Ndt,content_3764_9760:()=>Nep,content_3764_9762:()=>Pep,content_3764_9764:()=>Iep,content_3764_9766:()=>Gep,content_3764_9768:()=>Fep,content_3764_9770:()=>qep,content_3764_9772:()=>Qep,content_3764_9774:()=>$ep,content_3764_9776:()=>enp,content_3764_9778:()=>pnp,content_3764_978:()=>Pdt,content_3764_9780:()=>cnp,content_3764_9782:()=>lnp,content_3764_9784:()=>dnp,content_3764_9786:()=>knp,content_3764_9788:()=>Mnp,content_3764_9790:()=>wnp,content_3764_9792:()=>xnp,content_3764_9794:()=>Lnp,content_3764_9796:()=>Nnp,content_3764_9798:()=>Pnp,content_3764_98:()=>iJ,content_3764_980:()=>Idt,content_3764_9800:()=>Inp,content_3764_9802:()=>Gnp,content_3764_9804:()=>Fnp,content_3764_9806:()=>qnp,content_3764_9808:()=>Qnp,content_3764_9810:()=>$np,content_3764_9812:()=>eop,content_3764_9814:()=>pop,content_3764_9816:()=>cop,content_3764_9818:()=>lop,content_3764_982:()=>Gdt,content_3764_9820:()=>dop,content_3764_9822:()=>kop,content_3764_9824:()=>Mop,content_3764_9826:()=>wop,content_3764_9828:()=>xop,content_3764_9830:()=>Lop,content_3764_9832:()=>Nop,content_3764_9834:()=>Pop,content_3764_9836:()=>Iop,content_3764_9838:()=>Gop,content_3764_984:()=>Fdt,content_3764_9840:()=>Fop,content_3764_9842:()=>qop,content_3764_9844:()=>Qop,content_3764_9846:()=>$op,content_3764_9848:()=>epp,content_3764_9850:()=>ppp,content_3764_9852:()=>cpp,content_3764_9854:()=>lpp,content_3764_9856:()=>dpp,content_3764_9858:()=>kpp,content_3764_986:()=>qdt,content_3764_9860:()=>Mpp,content_3764_9862:()=>wpp,content_3764_9864:()=>xpp,content_3764_9866:()=>Lpp,content_3764_9868:()=>Npp,content_3764_9870:()=>Ppp,content_3764_9872:()=>Ipp,content_3764_9874:()=>Gpp,content_3764_9876:()=>Fpp,content_3764_9878:()=>qpp,content_3764_988:()=>Qdt,content_3764_9880:()=>Qpp,content_3764_9882:()=>$pp,content_3764_9884:()=>erp,content_3764_9886:()=>prp,content_3764_9888:()=>crp,content_3764_9890:()=>lrp,content_3764_9892:()=>drp,content_3764_9894:()=>krp,content_3764_9896:()=>Mrp,content_3764_9898:()=>wrp,content_3764_990:()=>$dt,content_3764_9900:()=>xrp,content_3764_9902:()=>Lrp,content_3764_9904:()=>Nrp,content_3764_9906:()=>Prp,content_3764_9908:()=>Irp,content_3764_9910:()=>Grp,content_3764_9912:()=>Frp,content_3764_9914:()=>qrp,content_3764_9916:()=>Qrp,content_3764_9918:()=>$rp,content_3764_992:()=>eht,content_3764_9920:()=>esp,content_3764_9922:()=>psp,content_3764_9924:()=>csp,content_3764_9926:()=>lsp,content_3764_9928:()=>dsp,content_3764_9930:()=>ksp,content_3764_9932:()=>Msp,content_3764_9934:()=>wsp,content_3764_9936:()=>xsp,content_3764_9938:()=>Lsp,content_3764_994:()=>pht,content_3764_9940:()=>Nsp,content_3764_9942:()=>Psp,content_3764_9944:()=>Isp,content_3764_9946:()=>Gsp,content_3764_9948:()=>Fsp,content_3764_9950:()=>qsp,content_3764_9952:()=>Qsp,content_3764_9954:()=>$sp,content_3764_9956:()=>ecp,content_3764_9958:()=>pcp,content_3764_996:()=>cht,content_3764_9960:()=>ccp,content_3764_9962:()=>lcp,content_3764_9964:()=>dcp,content_3764_9966:()=>kcp,content_3764_9968:()=>Mcp,content_3764_9970:()=>wcp,content_3764_9972:()=>xcp,content_3764_9974:()=>Lcp,content_3764_9976:()=>Ncp,content_3764_9978:()=>Pcp,content_3764_998:()=>lht,content_3764_9980:()=>Icp,content_3764_9982:()=>Gcp,content_3764_9984:()=>Fcp,content_3764_9986:()=>qcp,content_3764_9988:()=>Qcp,content_3764_9990:()=>$cp,content_3764_9992:()=>eap,content_3764_9994:()=>pap,content_3764_9996:()=>cap,content_3764_9998:()=>lap});var p=n(7896),r=n(2784),s=n(876);const c={toc:[]},a="wrapper";function i(t){let{components:e,...n}=t;return(0,s.kt)(a,(0,p.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Main Motion Canvas classes."))}i.isMDXComponent=!0;const l={toc:[]},u="wrapper";function m(t){let{components:e,...n}=t;return(0,s.kt)(u,(0,p.Z)({},l,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when a new message is logged."))}m.isMDXComponent=!0;const d={toc:[]},h="wrapper";function f(t){let{components:e,...n}=t;return(0,s.kt)(h,(0,p.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A read-only representation of the playback."))}f.isMDXComponent=!0;const k={toc:[]},y="wrapper";function D(t){let{components:e,...n}=t;return(0,s.kt)(y,(0,p.Z)({},k,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The time passed since the last frame in seconds."))}D.isMDXComponent=!0;const M={toc:[]},X="wrapper";function _(t){let{components:e,...n}=t;return(0,s.kt)(X,(0,p.Z)({},M,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert frames to seconds using the current framerate."))}_.isMDXComponent=!0;const w={toc:[]},T="wrapper";function C(t){let{components:e,...n}=t;return(0,s.kt)(T,(0,p.Z)({},w,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frames to convert."))}C.isMDXComponent=!0;const x={toc:[]},g="wrapper";function v(t){let{components:e,...n}=t;return(0,s.kt)(g,(0,p.Z)({},x,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert seconds to frames using the current framerate."))}v.isMDXComponent=!0;const L={toc:[]},Z="wrapper";function b(t){let{components:e,...n}=t;return(0,s.kt)(Z,(0,p.Z)({},L,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seconds to convert."))}b.isMDXComponent=!0;const N={toc:[]},z="wrapper";function A(t){let{components:e,...n}=t;return(0,s.kt)(z,(0,p.Z)({},N,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class builds on top of the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to provide a simple\ninterface similar to other media players. It plays through the animation\nusing a real-time update loop and optionally synchronises it with audio."))}A.isMDXComponent=!0;const P={toc:[]},W="wrapper";function R(t){let{components:e,...n}=t;return(0,s.kt)(W,(0,p.Z)({},P,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player logic used by the editor and embeddable player."))}R.isMDXComponent=!0;const I={toc:[]},S="wrapper";function B(t){let{components:e,...n}=t;return(0,s.kt)(S,(0,p.Z)({},I,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to provide visual feedback."))}B.isMDXComponent=!0;const G={toc:[]},E="wrapper";function O(t){let{components:e,...n}=t;return(0,s.kt)(E,(0,p.Z)({},G,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered right after recalculation finishes."))}O.isMDXComponent=!0;const F={toc:[]},U="wrapper";function V(t){let{components:e,...n}=t;return(0,s.kt)(U,(0,p.Z)({},F,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Player does not perform any rendering on its own. For the animation to be\nvisible, another class must subscribe to this event and perform the\nrendering itself. ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Stage"},(0,s.kt)("inlineCode",{parentName:"a"},"Stage"))," can be used to display the animation."))}V.isMDXComponent=!0;const q={toc:[]},j="wrapper";function Y(t){let{components:e,...n}=t;return(0,s.kt)(j,(0,p.Z)({},q,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered during each iteration of the update loop when the frame is ready\nto be rendered."))}Y.isMDXComponent=!0;const Q={toc:[]},H="wrapper";function K(t){let{components:e,...n}=t;return(0,s.kt)(H,(0,p.Z)({},Q,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A player needs to be active in order for the update loop to run. Each\nplayer is active by default."))}K.isMDXComponent=!0;const $={toc:[]},J="wrapper";function tt(t){let{components:e,...n}=t;return(0,s.kt)(J,(0,p.Z)({},$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Activate the player."))}tt.isMDXComponent=!0;const et={toc:[]},nt="wrapper";function ot(t){let{components:e,...n}=t;return(0,s.kt)(nt,(0,p.Z)({},et,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivating the player prevents its update loop from running. This should\nbe done before disposing the player, to prevent it from running in the\nbackground."),(0,s.kt)("p",null,"Just pausing the player does not stop the loop."))}ot.isMDXComponent=!0;const pt={toc:[]},rt="wrapper";function st(t){let{components:e,...n}=t;return(0,s.kt)(rt,(0,p.Z)({},pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Deactivate the player."))}st.isMDXComponent=!0;const ct={toc:[]},at="wrapper";function it(t){let{components:e,...n}=t;return(0,s.kt)(at,(0,p.Z)({},ct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the given frame is inside the animation range."))}it.isMDXComponent=!0;const lt={toc:[]},ut="wrapper";function mt(t){let{components:e,...n}=t;return(0,s.kt)(ut,(0,p.Z)({},lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame to check."))}mt.isMDXComponent=!0;const dt={toc:[]},ht="wrapper";function ft(t){let{components:e,...n}=t;return(0,s.kt)(ht,(0,p.Z)({},dt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the given frame is inside the user-defined range."))}ft.isMDXComponent=!0;const kt={toc:[]},yt="wrapper";function Dt(t){let{components:e,...n}=t;return(0,s.kt)(yt,(0,p.Z)({},kt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame to check."))}Dt.isMDXComponent=!0;const Mt={toc:[]},Xt="wrapper";function _t(t){let{components:e,...n}=t;return(0,s.kt)(Xt,(0,p.Z)({},Mt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing presentation process."))}_t.isMDXComponent=!0;const wt={toc:[]},Tt="wrapper";function Ct(t){let{components:e,...n}=t;return(0,s.kt)(Tt,(0,p.Z)({},wt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Present the animation."))}Ct.isMDXComponent=!0;const xt={toc:[]},gt="wrapper";function vt(t){let{components:e,...n}=t;return(0,s.kt)(gt,(0,p.Z)({},xt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presentation settings."))}vt.isMDXComponent=!0;const Lt={toc:[]},Zt="wrapper";function bt(t){let{components:e,...n}=t;return(0,s.kt)(Zt,(0,p.Z)({},Lt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Resume the presentation if waiting for the next slide."))}bt.isMDXComponent=!0;const Nt={toc:[]},zt="wrapper";function At(t){let{components:e,...n}=t;return(0,s.kt)(zt,(0,p.Z)({},Nt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}At.isMDXComponent=!0;const Pt={toc:[]},Wt="wrapper";function Rt(t){let{components:e,...n}=t;return(0,s.kt)(Wt,(0,p.Z)({},Pt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Rt.isMDXComponent=!0;const It={toc:[]},St="wrapper";function Bt(t){let{components:e,...n}=t;return(0,s.kt)(St,(0,p.Z)({},It,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Bt.isMDXComponent=!0;const Gt={toc:[]},Et="wrapper";function Ot(t){let{components:e,...n}=t;return(0,s.kt)(Et,(0,p.Z)({},Gt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Ot.isMDXComponent=!0;const Ft={toc:[]},Ut="wrapper";function Vt(t){let{components:e,...n}=t;return(0,s.kt)(Ut,(0,p.Z)({},Ft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}Vt.isMDXComponent=!0;const qt={toc:[]},jt="wrapper";function Yt(t){let{components:e,...n}=t;return(0,s.kt)(jt,(0,p.Z)({},qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Yt.isMDXComponent=!0;const Qt={toc:[]},Ht="wrapper";function Kt(t){let{components:e,...n}=t;return(0,s.kt)(Ht,(0,p.Z)({},Qt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Kt.isMDXComponent=!0;const $t={toc:[]},Jt="wrapper";function te(t){let{components:e,...n}=t;return(0,s.kt)(Jt,(0,p.Z)({},$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}te.isMDXComponent=!0;const ee={toc:[]},ne="wrapper";function oe(t){let{components:e,...n}=t;return(0,s.kt)(ne,(0,p.Z)({},ee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}oe.isMDXComponent=!0;const pe={toc:[]},re="wrapper";function se(t){let{components:e,...n}=t;return(0,s.kt)(re,(0,p.Z)({},pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}se.isMDXComponent=!0;const ce={toc:[]},ae="wrapper";function ie(t){let{components:e,...n}=t;return(0,s.kt)(ae,(0,p.Z)({},ce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}ie.isMDXComponent=!0;const le={toc:[]},ue="wrapper";function me(t){let{components:e,...n}=t;return(0,s.kt)(ue,(0,p.Z)({},le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}me.isMDXComponent=!0;const de={toc:[]},he="wrapper";function fe(t){let{components:e,...n}=t;return(0,s.kt)(he,(0,p.Z)({},de,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}fe.isMDXComponent=!0;const ke={toc:[]},ye="wrapper";function De(t){let{components:e,...n}=t;return(0,s.kt)(ye,(0,p.Z)({},ke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}De.isMDXComponent=!0;const Me={toc:[]},Xe="wrapper";function _e(t){let{components:e,...n}=t;return(0,s.kt)(Xe,(0,p.Z)({},Me,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This class uses the ",(0,s.kt)("inlineCode",{parentName:"p"},"PlaybackManager")," to render animations. In contrast to a\nplayer, a renderer does not use an update loop. It plays through the\nanimation as fast as it can, occasionally pausing to keep the UI responsive."),(0,s.kt)("p",null,"The actual exporting is outsourced to an ",(0,s.kt)("a",{parentName:"p",href:"/api/core/app/Exporter"},(0,s.kt)("inlineCode",{parentName:"a"},"Exporter")),"."))}_e.isMDXComponent=!0;const we={toc:[]},Te="wrapper";function Ce(t){let{components:e,...n}=t;return(0,s.kt)(Te,(0,p.Z)({},we,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering logic used by the editor to export animations."))}Ce.isMDXComponent=!0;const xe={toc:[]},ge="wrapper";function ve(t){let{components:e,...n}=t;return(0,s.kt)(ge,(0,p.Z)({},xe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abort the ongoing render process."))}ve.isMDXComponent=!0;const Le={toc:[]},Ze="wrapper";function be(t){let{components:e,...n}=t;return(0,s.kt)(Ze,(0,p.Z)({},Le,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the animation using the provided settings."))}be.isMDXComponent=!0;const Ne={toc:[]},ze="wrapper";function Ae(t){let{components:e,...n}=t;return(0,s.kt)(ze,(0,p.Z)({},Ne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}Ae.isMDXComponent=!0;const Pe={toc:[]},We="wrapper";function Re(t){let{components:e,...n}=t;return(0,s.kt)(We,(0,p.Z)({},Pe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method always uses the default ",(0,s.kt)("inlineCode",{parentName:"p"},"ImageExporter"),"."))}Re.isMDXComponent=!0;const Ie={toc:[]},Se="wrapper";function Be(t){let{components:e,...n}=t;return(0,s.kt)(Se,(0,p.Z)({},Ie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export an individual frame."))}Be.isMDXComponent=!0;const Ge={toc:[]},Ee="wrapper";function Oe(t){let{components:e,...n}=t;return(0,s.kt)(Ee,(0,p.Z)({},Ge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}Oe.isMDXComponent=!0;const Fe={toc:[]},Ue="wrapper";function Ve(t){let{components:e,...n}=t;return(0,s.kt)(Ue,(0,p.Z)({},Fe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timestamp to export."))}Ve.isMDXComponent=!0;const qe={toc:[]},je="wrapper";function Ye(t){let{components:e,...n}=t;return(0,s.kt)(je,(0,p.Z)({},qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispose the WebGL context to free up resources."))}Ye.isMDXComponent=!0;const Qe={toc:[]},He="wrapper";function Ke(t){let{components:e,...n}=t;return(0,s.kt)(He,(0,p.Z)({},Qe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Manages canvases on which an animation can be displayed."))}Ke.isMDXComponent=!0;const $e={toc:[]},Je="wrapper";function tn(t){let{components:e,...n}=t;return(0,s.kt)(Je,(0,p.Z)({},$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for implementing custom exporters."))}tn.isMDXComponent=!0;const en={toc:[]},nn="wrapper";function on(t){let{components:e,...n}=t;return(0,s.kt)(nn,(0,p.Z)({},en,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called at the beginning of the rendering process, before anything else has\nbeen set up. The returned value can be used to override the rendering\nsettings provided by the user."))}on.isMDXComponent=!0;const pn={toc:[]},rn="wrapper";function sn(t){let{components:e,...n}=t;return(0,s.kt)(rn,(0,p.Z)({},pn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the rendering configuration."))}sn.isMDXComponent=!0;const cn={toc:[]},an="wrapper";function ln(t){let{components:e,...n}=t;return(0,s.kt)(an,(0,p.Z)({},cn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called each time after a frame is rendered."))}ln.isMDXComponent=!0;const un={toc:[]},mn="wrapper";function dn(t){let{components:e,...n}=t;return(0,s.kt)(mn,(0,p.Z)({},un,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Export a frame."))}dn.isMDXComponent=!0;const hn={toc:[]},fn="wrapper";function kn(t){let{components:e,...n}=t;return(0,s.kt)(fn,(0,p.Z)({},hn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A canvas containing the rendered frame."))}kn.isMDXComponent=!0;const yn={toc:[]},Dn="wrapper";function Mn(t){let{components:e,...n}=t;return(0,s.kt)(Dn,(0,p.Z)({},yn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number."))}Mn.isMDXComponent=!0;const Xn={toc:[]},_n="wrapper";function wn(t){let{components:e,...n}=t;return(0,s.kt)(_n,(0,p.Z)({},Xn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame number within the scene."))}wn.isMDXComponent=!0;const Tn={toc:[]},Cn="wrapper";function xn(t){let{components:e,...n}=t;return(0,s.kt)(Cn,(0,p.Z)({},Tn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the scene with which the frame is associated."))}xn.isMDXComponent=!0;const gn={toc:[]},vn="wrapper";function Ln(t){let{components:e,...n}=t;return(0,s.kt)(vn,(0,p.Z)({},gn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An abort signal triggered if the user aborts the rendering."))}Ln.isMDXComponent=!0;const Zn={toc:[]},bn="wrapper";function Nn(t){let{components:e,...n}=t;return(0,s.kt)(bn,(0,p.Z)({},Zn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called after the rendering has been set up, right before the first frame\nis rendered. Once ",(0,s.kt)("inlineCode",{parentName:"p"},"start()")," is called, it is guaranteed that the ",(0,s.kt)("inlineCode",{parentName:"p"},"stop()"),"\nmethod will be called as well. Can be used to initialize any resources that\nrequire a clean-up."))}Nn.isMDXComponent=!0;const zn={toc:[]},An="wrapper";function Pn(t){let{components:e,...n}=t;return(0,s.kt)(An,(0,p.Z)({},zn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Begin the rendering process."))}Pn.isMDXComponent=!0;const Wn={toc:[]},Rn="wrapper";function In(t){let{components:e,...n}=t;return(0,s.kt)(Rn,(0,p.Z)({},Wn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Guaranteed to be called after the rendering has finished - no matter the\nresult. Can be used to finalize the exporting and perform any necessary\nclean-up."))}In.isMDXComponent=!0;const Sn={toc:[]},Bn="wrapper";function Gn(t){let{components:e,...n}=t;return(0,s.kt)(Bn,(0,p.Z)({},Sn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Finish the rendering process."))}Gn.isMDXComponent=!0;const En={toc:[]},On="wrapper";function Fn(t){let{components:e,...n}=t;return(0,s.kt)(On,(0,p.Z)({},En,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The result of the rendering."))}Fn.isMDXComponent=!0;const Un={toc:[]},Vn="wrapper";function qn(t){let{components:e,...n}=t;return(0,s.kt)(Vn,(0,p.Z)({},Un,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The static interface for exporters."))}qn.isMDXComponent=!0;const jn={toc:[]},Yn="wrapper";function Qn(t){let{components:e,...n}=t;return(0,s.kt)(Yn,(0,p.Z)({},jn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This name will be displayed in the editor."))}Qn.isMDXComponent=!0;const Hn={toc:[]},Kn="wrapper";function $n(t){let{components:e,...n}=t;return(0,s.kt)(Kn,(0,p.Z)({},Hn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this exporter."))}$n.isMDXComponent=!0;const Jn={toc:[]},to="wrapper";function eo(t){let{components:e,...n}=t;return(0,s.kt)(to,(0,p.Z)({},Jn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This identifier will be used to store the settings of this exporter.\nIt's recommended to prepend it with the name of the package to avoid\ncollisions."))}eo.isMDXComponent=!0;const no={toc:[]},oo="wrapper";function po(t){let{components:e,...n}=t;return(0,s.kt)(oo,(0,p.Z)({},no,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The unique identifier of this exporter."))}po.isMDXComponent=!0;const ro={toc:[]},so="wrapper";function co(t){let{components:e,...n}=t;return(0,s.kt)(so,(0,p.Z)({},ro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A new exporter is created whenever the user starts a new rendering process."))}co.isMDXComponent=!0;const ao={toc:[]},io="wrapper";function lo(t){let{components:e,...n}=t;return(0,s.kt)(io,(0,p.Z)({},ao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this exporter."))}lo.isMDXComponent=!0;const uo={toc:[]},mo="wrapper";function ho(t){let{components:e,...n}=t;return(0,s.kt)(mo,(0,p.Z)({},uo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current project."))}ho.isMDXComponent=!0;const fo={toc:[]},ko="wrapper";function yo(t){let{components:e,...n}=t;return(0,s.kt)(ko,(0,p.Z)({},fo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rendering settings."))}yo.isMDXComponent=!0;const Do={toc:[]},Mo="wrapper";function Xo(t){let{components:e,...n}=t;return(0,s.kt)(Mo,(0,p.Z)({},Do,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a meta field representing the options of this exporter."))}Xo.isMDXComponent=!0;const _o={toc:[]},wo="wrapper";function To(t){let{components:e,...n}=t;return(0,s.kt)(wo,(0,p.Z)({},_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When displayed in the editor, the log entry will have the following format:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"                             inspect node \u2510\n  \u250c expand more          duration \u2510       \u2502\n  \u25bc                               \u25bc       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u25b6 message                       300 ms (+) \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 remarks                                    \u2502\n\u2502 object                                     \u2502\n\u2502 stacktrace                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")))}To.isMDXComponent=!0;const Co={toc:[]},xo="wrapper";function go(t){let{components:e,...n}=t;return(0,s.kt)(xo,(0,p.Z)({},Co,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an individual log entry."))}go.isMDXComponent=!0;const vo={toc:[]},Lo="wrapper";function Zo(t){let{components:e,...n}=t;return(0,s.kt)(Lo,(0,p.Z)({},vo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}Zo.isMDXComponent=!0;const bo={toc:[]},No="wrapper";function zo(t){let{components:e,...n}=t;return(0,s.kt)(No,(0,p.Z)({},bo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional duration in milliseconds."))}zo.isMDXComponent=!0;const Ao={toc:[]},Po="wrapper";function Wo(t){let{components:e,...n}=t;return(0,s.kt)(Po,(0,p.Z)({},Ao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This will be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.kt)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}Wo.isMDXComponent=!0;const Ro={toc:[]},Io="wrapper";function So(t){let{components:e,...n}=t;return(0,s.kt)(Io,(0,p.Z)({},Ro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional key used to inspect a related object."))}So.isMDXComponent=!0;const Bo={toc:[]},Go="wrapper";function Eo(t){let{components:e,...n}=t;return(0,s.kt)(Go,(0,p.Z)({},Bo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log level."))}Eo.isMDXComponent=!0;const Oo={toc:[]},Fo="wrapper";function Uo(t){let{components:e,...n}=t;return(0,s.kt)(Fo,(0,p.Z)({},Oo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Always visible."))}Uo.isMDXComponent=!0;const Vo={toc:[]},qo="wrapper";function jo(t){let{components:e,...n}=t;return(0,s.kt)(qo,(0,p.Z)({},Vo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main message of the log."))}jo.isMDXComponent=!0;const Yo={toc:[]},Qo="wrapper";function Ho(t){let{components:e,...n}=t;return(0,s.kt)(Qo,(0,p.Z)({},Yo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded."))}Ho.isMDXComponent=!0;const Ko={toc:[]},$o="wrapper";function Jo(t){let{components:e,...n}=t;return(0,s.kt)($o,(0,p.Z)({},Ko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An object that will be serialized as JSON and displayed under the message."))}Jo.isMDXComponent=!0;const tp={toc:[]},ep="wrapper";function np(t){let{components:e,...n}=t;return(0,s.kt)(ep,(0,p.Z)({},tp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded."))}np.isMDXComponent=!0;const op={toc:[]},pp="wrapper";function rp(t){let{components:e,...n}=t;return(0,s.kt)(pp,(0,p.Z)({},op,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Additional information about the log."))}rp.isMDXComponent=!0;const sp={toc:[]},cp="wrapper";function ap(t){let{components:e,...n}=t;return(0,s.kt)(cp,(0,p.Z)({},sp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded.\nThe current stack trace can be obtained using ",(0,s.kt)("inlineCode",{parentName:"p"},"new Error().stack"),".\nBoth Chromium and Firefox stack traces are supported."))}ap.isMDXComponent=!0;const ip={toc:[]},lp="wrapper";function up(t){let{components:e,...n}=t;return(0,s.kt)(lp,(0,p.Z)({},ip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace of the log."))}up.isMDXComponent=!0;const mp={toc:[]},dp="wrapper";function hp(t){let{components:e,...n}=t;return(0,s.kt)(dp,(0,p.Z)({},mp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://motioncanvas.io/docs/media#audio"},"https://motioncanvas.io/docs/media#audio")))}hp.isMDXComponent=!0;const fp={toc:[]},kp="wrapper";function yp(t){let{components:e,...n}=t;return(0,s.kt)(kp,(0,p.Z)({},fp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An url for the audio track to play alongside the animation."))}yp.isMDXComponent=!0;const Dp={toc:[]},Mp="wrapper";function Xp(t){let{components:e,...n}=t;return(0,s.kt)(Mp,(0,p.Z)({},Dp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configure the offset in the Video Settings tab of th editor."))}Xp.isMDXComponent=!0;const _p={toc:[]},wp="wrapper";function Tp(t){let{components:e,...n}=t;return(0,s.kt)(wp,(0,p.Z)({},_p,n,{components:e,mdxType:"MDXLayout"}))}Tp.isMDXComponent=!0;const Cp={toc:[]},xp="wrapper";function gp(t){let{components:e,...n}=t;return(0,s.kt)(xp,(0,p.Z)({},Cp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://motioncanvas.io/docs/experimental"},"https://motioncanvas.io/docs/experimental")))}gp.isMDXComponent=!0;const vp={toc:[]},Lp="wrapper";function Zp(t){let{components:e,...n}=t;return(0,s.kt)(Lp,(0,p.Z)({},vp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enable experimental features."))}Zp.isMDXComponent=!0;const bp={toc:[]},Np="wrapper";function zp(t){let{components:e,...n}=t;return(0,s.kt)(Np,(0,p.Z)({},bp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A custom logger instance to use."))}zp.isMDXComponent=!0;const Ap={toc:[]},Pp="wrapper";function Wp(t){let{components:e,...n}=t;return(0,s.kt)(Pp,(0,p.Z)({},Ap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the project."))}Wp.isMDXComponent=!0;const Rp={toc:[]},Ip="wrapper";function Sp(t){let{components:e,...n}=t;return(0,s.kt)(Ip,(0,p.Z)({},Rp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When a string is provided, the plugin will be imported dynamically using\nthe string as the module specifier. This is the preferred way to include\neditor plugins because it makes sure that the plugin's source code gets\nexcluded from the production build."))}Sp.isMDXComponent=!0;const Bp={toc:[]},Gp="wrapper";function Ep(t){let{components:e,...n}=t;return(0,s.kt)(Gp,(0,p.Z)({},Bp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of plugins to include in the project."))}Ep.isMDXComponent=!0;const Op={toc:[]},Fp="wrapper";function Up(t){let{components:e,...n}=t;return(0,s.kt)(Fp,(0,p.Z)({},Op,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A full scene description can be obtained by loading a scene module with a\n",(0,s.kt)("inlineCode",{parentName:"p"},"?scene")," query parameter."))}Up.isMDXComponent=!0;const Vp={toc:[]},qp="wrapper";function jp(t){let{components:e,...n}=t;return(0,s.kt)(qp,(0,p.Z)({},Vp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import exampleScene from './example?scene';\n\nexport default makeProject({\n  scenes: [exampleScene],\n});\n")))}jp.isMDXComponent=!0;const Yp={toc:[]},Qp="wrapper";function Hp(t){let{components:e,...n}=t;return(0,s.kt)(Qp,(0,p.Z)({},Yp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of scene descriptions that make up the project."))}Hp.isMDXComponent=!0;const Kp={toc:[]},$p="wrapper";function Jp(t){let{components:e,...n}=t;return(0,s.kt)($p,(0,p.Z)({},Kp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://motioncanvas.io/docs/project-variables"},"https://motioncanvas.io/docs/project-variables")))}Jp.isMDXComponent=!0;const tr={toc:[]},er="wrapper";function nr(t){let{components:e,...n}=t;return(0,s.kt)(er,(0,p.Z)({},tr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Default values for project variables."))}nr.isMDXComponent=!0;const or={toc:[]},pr="wrapper";function rr(t){let{components:e,...n}=t;return(0,s.kt)(pr,(0,p.Z)({},or,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the settings metadata."))}rr.isMDXComponent=!0;const sr={toc:[]},cr="wrapper";function ar(t){let{components:e,...n}=t;return(0,s.kt)(cr,(0,p.Z)({},sr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the settings metadata."))}ar.isMDXComponent=!0;const ir={toc:[]},lr="wrapper";function ur(t){let{components:e,...n}=t;return(0,s.kt)(lr,(0,p.Z)({},ir,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Property decorators."))}ur.isMDXComponent=!0;const mr={toc:[]},dr="wrapper";function hr(t){let{components:e,...n}=t;return(0,s.kt)(dr,(0,p.Z)({},mr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A property marked as lazy will not be initialized until it's requested for\nthe first time. Lazy properties are read-only."),(0,s.kt)("p",null,"Must be used for any static properties that require the DOM API to be\ninitialized."))}hr.isMDXComponent=!0;const fr={toc:[]},kr="wrapper";function yr(t){let{components:e,...n}=t;return(0,s.kt)(kr,(0,p.Z)({},fr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a lazy decorator."))}yr.isMDXComponent=!0;const Dr={toc:[]},Mr="wrapper";function Xr(t){let{components:e,...n}=t;return(0,s.kt)(Mr,(0,p.Z)({},Dr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the value of this property."))}Xr.isMDXComponent=!0;const _r={toc:[]},wr="wrapper";function Tr(t){let{components:e,...n}=t;return(0,s.kt)(wr,(0,p.Z)({},_r,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscriptions and triggering of events."))}Tr.isMDXComponent=!0;const Cr={toc:[]},xr="wrapper";function gr(t){let{components:e,...n}=t;return(0,s.kt)(xr,(0,p.Z)({},Cr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,s.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}gr.isMDXComponent=!0;const vr={toc:[]},Lr="wrapper";function Zr(t){let{components:e,...n}=t;return(0,s.kt)(Lr,(0,p.Z)({},vr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}Zr.isMDXComponent=!0;const br={toc:[]},Nr="wrapper";function zr(t){let{components:e,...n}=t;return(0,s.kt)(Nr,(0,p.Z)({},br,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches an asynchronous ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}zr.isMDXComponent=!0;const Ar={toc:[]},Pr="wrapper";function Wr(t){let{components:e,...n}=t;return(0,s.kt)(Pr,(0,p.Z)({},Ar,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}Wr.isMDXComponent=!0;const Rr={toc:[]},Ir="wrapper";function Sr(t){let{components:e,...n}=t;return(0,s.kt)(Ir,(0,p.Z)({},Rr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Sr.isMDXComponent=!0;const Br={toc:[]},Gr="wrapper";function Er(t){let{components:e,...n}=t;return(0,s.kt)(Gr,(0,p.Z)({},Br,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Er.isMDXComponent=!0;const Or={toc:[]},Fr="wrapper";function Ur(t){let{components:e,...n}=t;return(0,s.kt)(Fr,(0,p.Z)({},Or,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Ur.isMDXComponent=!0;const Vr={toc:[]},qr="wrapper";function jr(t){let{components:e,...n}=t;return(0,s.kt)(qr,(0,p.Z)({},Vr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}jr.isMDXComponent=!0;const Yr={toc:[]},Qr="wrapper";function Hr(t){let{components:e,...n}=t;return(0,s.kt)(Qr,(0,p.Z)({},Yr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Hr.isMDXComponent=!0;const Kr={toc:[]},$r="wrapper";function Jr(t){let{components:e,...n}=t;return(0,s.kt)($r,(0,p.Z)({},Kr,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Jr.isMDXComponent=!0;const ts={toc:[]},es="wrapper";function ns(t){let{components:e,...n}=t;return(0,s.kt)(es,(0,p.Z)({},ts,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}ns.isMDXComponent=!0;const os={toc:[]},ps="wrapper";function rs(t){let{components:e,...n}=t;return(0,s.kt)(ps,(0,p.Z)({},os,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}rs.isMDXComponent=!0;const ss={toc:[]},cs="wrapper";function as(t){let{components:e,...n}=t;return(0,s.kt)(cs,(0,p.Z)({},ss,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}as.isMDXComponent=!0;const is={toc:[]},ls="wrapper";function us(t){let{components:e,...n}=t;return(0,s.kt)(ls,(0,p.Z)({},is,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}us.isMDXComponent=!0;const ms={toc:[]},ds="wrapper";function hs(t){let{components:e,...n}=t;return(0,s.kt)(ds,(0,p.Z)({},ms,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}hs.isMDXComponent=!0;const fs={toc:[]},ks="wrapper";function ys(t){let{components:e,...n}=t;return(0,s.kt)(ks,(0,p.Z)({},fs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}ys.isMDXComponent=!0;const Ds={toc:[]},Ms="wrapper";function Xs(t){let{components:e,...n}=t;return(0,s.kt)(Ms,(0,p.Z)({},Ds,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Xs.isMDXComponent=!0;const _s={toc:[]},ws="wrapper";function Ts(t){let{components:e,...n}=t;return(0,s.kt)(ws,(0,p.Z)({},_s,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Ts.isMDXComponent=!0;const Cs={toc:[]},xs="wrapper";function gs(t){let{components:e,...n}=t;return(0,s.kt)(xs,(0,p.Z)({},Cs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value argument to subscribers."))}gs.isMDXComponent=!0;const vs={toc:[]},Ls="wrapper";function Zs(t){let{components:e,...n}=t;return(0,s.kt)(Ls,(0,p.Z)({},vs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A base for dispatching ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,s.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Zs.isMDXComponent=!0;const bs={toc:[]},Ns="wrapper";function zs(t){let{components:e,...n}=t;return(0,s.kt)(Ns,(0,p.Z)({},bs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}zs.isMDXComponent=!0;const As={toc:[]},Ps="wrapper";function Ws(t){let{components:e,...n}=t;return(0,s.kt)(Ps,(0,p.Z)({},As,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Ws.isMDXComponent=!0;const Rs={toc:[]},Is="wrapper";function Ss(t){let{components:e,...n}=t;return(0,s.kt)(Is,(0,p.Z)({},Rs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}Ss.isMDXComponent=!0;const Bs={toc:[]},Gs="wrapper";function Es(t){let{components:e,...n}=t;return(0,s.kt)(Gs,(0,p.Z)({},Bs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Es.isMDXComponent=!0;const Os={toc:[]},Fs="wrapper";function Us(t){let{components:e,...n}=t;return(0,s.kt)(Fs,(0,p.Z)({},Os,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Us.isMDXComponent=!0;const Vs={toc:[]},qs="wrapper";function js(t){let{components:e,...n}=t;return(0,s.kt)(qs,(0,p.Z)({},Vs,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}js.isMDXComponent=!0;const Ys={toc:[]},Qs="wrapper";function Hs(t){let{components:e,...n}=t;return(0,s.kt)(Qs,(0,p.Z)({},Ys,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}Hs.isMDXComponent=!0;const Ks={toc:[]},$s="wrapper";function Js(t){let{components:e,...n}=t;return(0,s.kt)($s,(0,p.Z)({},Ks,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}Js.isMDXComponent=!0;const tc={toc:[]},ec="wrapper";function nc(t){let{components:e,...n}=t;return(0,s.kt)(ec,(0,p.Z)({},tc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,s.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,s.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}nc.isMDXComponent=!0;const oc={toc:[]},pc="wrapper";function rc(t){let{components:e,...n}=t;return(0,s.kt)(pc,(0,p.Z)({},oc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}rc.isMDXComponent=!0;const sc={toc:[]},cc="wrapper";function ac(t){let{components:e,...n}=t;return(0,s.kt)(cc,(0,p.Z)({},sc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}ac.isMDXComponent=!0;const ic={toc:[]},lc="wrapper";function uc(t){let{components:e,...n}=t;return(0,s.kt)(lc,(0,p.Z)({},ic,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}uc.isMDXComponent=!0;const mc={toc:[]},dc="wrapper";function hc(t){let{components:e,...n}=t;return(0,s.kt)(dc,(0,p.Z)({},mc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Are subscribers being notified?"))}hc.isMDXComponent=!0;const fc={toc:[]},kc="wrapper";function yc(t){let{components:e,...n}=t;return(0,s.kt)(kc,(0,p.Z)({},fc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Notify all current and future subscribers."))}yc.isMDXComponent=!0;const Dc={toc:[]},Mc="wrapper";function Xc(t){let{components:e,...n}=t;return(0,s.kt)(Mc,(0,p.Z)({},Dc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Stop notifying future subscribers."))}Xc.isMDXComponent=!0;const _c={toc:[]},wc="wrapper";function Tc(t){let{components:e,...n}=t;return(0,s.kt)(wc,(0,p.Z)({},_c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Tc.isMDXComponent=!0;const Cc={toc:[]},xc="wrapper";function gc(t){let{components:e,...n}=t;return(0,s.kt)(xc,(0,p.Z)({},Cc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}gc.isMDXComponent=!0;const vc={toc:[]},Lc="wrapper";function Zc(t){let{components:e,...n}=t;return(0,s.kt)(Lc,(0,p.Z)({},vc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Zc.isMDXComponent=!0;const bc={toc:[]},Nc="wrapper";function zc(t){let{components:e,...n}=t;return(0,s.kt)(Nc,(0,p.Z)({},bc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}zc.isMDXComponent=!0;const Ac={toc:[]},Pc="wrapper";function Wc(t){let{components:e,...n}=t;return(0,s.kt)(Pc,(0,p.Z)({},Ac,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Wc.isMDXComponent=!0;const Rc={toc:[]},Ic="wrapper";function Sc(t){let{components:e,...n}=t;return(0,s.kt)(Ic,(0,p.Z)({},Rc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Sc.isMDXComponent=!0;const Bc={toc:[]},Gc="wrapper";function Ec(t){let{components:e,...n}=t;return(0,s.kt)(Gc,(0,p.Z)({},Bc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Ec.isMDXComponent=!0;const Oc={toc:[]},Fc="wrapper";function Uc(t){let{components:e,...n}=t;return(0,s.kt)(Fc,(0,p.Z)({},Oc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A callback function that cancels the subscription."))}Uc.isMDXComponent=!0;const Vc={toc:[]},qc="wrapper";function jc(t){let{components:e,...n}=t;return(0,s.kt)(qc,(0,p.Z)({},Vc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."))}jc.isMDXComponent=!0;const Yc={toc:[]},Qc="wrapper";function Hc(t){let{components:e,...n}=t;return(0,s.kt)(Qc,(0,p.Z)({},Yc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}Hc.isMDXComponent=!0;const Kc={toc:[]},$c="wrapper";function Jc(t){let{components:e,...n}=t;return(0,s.kt)($c,(0,p.Z)({},Kc,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Jc.isMDXComponent=!0;const ta={toc:[]},ea="wrapper";function na(t){let{components:e,...n}=t;return(0,s.kt)(ea,(0,p.Z)({},ta,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}na.isMDXComponent=!0;const oa={toc:[]},pa="wrapper";function ra(t){let{components:e,...n}=t;return(0,s.kt)(pa,(0,p.Z)({},oa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}ra.isMDXComponent=!0;const sa={toc:[]},ca="wrapper";function aa(t){let{components:e,...n}=t;return(0,s.kt)(ca,(0,p.Z)({},sa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the callback function."))}aa.isMDXComponent=!0;const ia={toc:[]},la="wrapper";function ua(t){let{components:e,...n}=t;return(0,s.kt)(la,(0,p.Z)({},ia,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ua.isMDXComponent=!0;const ma={toc:[]},da="wrapper";function ha(t){let{components:e,...n}=t;return(0,s.kt)(da,(0,p.Z)({},ma,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}ha.isMDXComponent=!0;const fa={toc:[]},ka="wrapper";function ya(t){let{components:e,...n}=t;return(0,s.kt)(ka,(0,p.Z)({},fa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}ya.isMDXComponent=!0;const Da={toc:[]},Ma="wrapper";function Xa(t){let{components:e,...n}=t;return(0,s.kt)(Ma,(0,p.Z)({},Da,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}Xa.isMDXComponent=!0;const _a={toc:[]},wa="wrapper";function Ta(t){let{components:e,...n}=t;return(0,s.kt)(wa,(0,p.Z)({},_a,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ta.isMDXComponent=!0;const Ca={toc:[]},xa="wrapper";function ga(t){let{components:e,...n}=t;return(0,s.kt)(xa,(0,p.Z)({},Ca,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}ga.isMDXComponent=!0;const va={toc:[]},La="wrapper";function Za(t){let{components:e,...n}=t;return(0,s.kt)(La,(0,p.Z)({},va,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Za.isMDXComponent=!0;const ba={toc:[]},Na="wrapper";function za(t){let{components:e,...n}=t;return(0,s.kt)(Na,(0,p.Z)({},ba,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}za.isMDXComponent=!0;const Aa={toc:[]},Pa="wrapper";function Wa(t){let{components:e,...n}=t;return(0,s.kt)(Pa,(0,p.Z)({},Aa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Wa.isMDXComponent=!0;const Ra={toc:[]},Ia="wrapper";function Sa(t){let{components:e,...n}=t;return(0,s.kt)(Ia,(0,p.Z)({},Ra,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}Sa.isMDXComponent=!0;const Ba={toc:[]},Ga="wrapper";function Ea(t){let{components:e,...n}=t;return(0,s.kt)(Ga,(0,p.Z)({},Ba,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Ea.isMDXComponent=!0;const Oa={toc:[]},Fa="wrapper";function Ua(t){let{components:e,...n}=t;return(0,s.kt)(Fa,(0,p.Z)({},Oa,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Ua.isMDXComponent=!0;const Va={toc:[]},qa="wrapper";function ja(t){let{components:e,...n}=t;return(0,s.kt)(qa,(0,p.Z)({},Va,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}ja.isMDXComponent=!0;const Ya={toc:[]},Qa="wrapper";function Ha(t){let{components:e,...n}=t;return(0,s.kt)(Qa,(0,p.Z)({},Ya,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Ha.isMDXComponent=!0;const Ka={toc:[]},$a="wrapper";function Ja(t){let{components:e,...n}=t;return(0,s.kt)($a,(0,p.Z)({},Ka,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Dispatches a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,s.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Ja.isMDXComponent=!0;const ti={toc:[]},ei="wrapper";function ni(t){let{components:e,...n}=t;return(0,s.kt)(ei,(0,p.Z)({},ti,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value."))}ni.isMDXComponent=!0;const oi={toc:[]},pi="wrapper";function ri(t){let{components:e,...n}=t;return(0,s.kt)(pi,(0,p.Z)({},oi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the most recent value of this dispatcher."))}ri.isMDXComponent=!0;const si={toc:[]},ci="wrapper";function ai(t){let{components:e,...n}=t;return(0,s.kt)(ci,(0,p.Z)({},si,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Setting the value will immediately notify all subscribers."))}ai.isMDXComponent=!0;const ii={toc:[]},li="wrapper";function ui(t){let{components:e,...n}=t;return(0,s.kt)(li,(0,p.Z)({},ii,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value of this dispatcher."))}ui.isMDXComponent=!0;const mi={toc:[]},di="wrapper";function hi(t){let{components:e,...n}=t;return(0,s.kt)(di,(0,p.Z)({},mi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}hi.isMDXComponent=!0;const fi={toc:[]},ki="wrapper";function yi(t){let{components:e,...n}=t;return(0,s.kt)(ki,(0,p.Z)({},fi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe all subscribers from the event."))}yi.isMDXComponent=!0;const Di={toc:[]},Mi="wrapper";function Xi(t){let{components:e,...n}=t;return(0,s.kt)(Mi,(0,p.Z)({},Di,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Callback function that cancels the subscription."))}Xi.isMDXComponent=!0;const _i={toc:[]},wi="wrapper";function Ti(t){let{components:e,...n}=t;return(0,s.kt)(wi,(0,p.Z)({},_i,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subscribe to the event."),(0,s.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ti.isMDXComponent=!0;const Ci={toc:[]},xi="wrapper";function gi(t){let{components:e,...n}=t;return(0,s.kt)(xi,(0,p.Z)({},Ci,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to invoke when the event occurs."))}gi.isMDXComponent=!0;const vi={toc:[]},Li="wrapper";function Zi(t){let{components:e,...n}=t;return(0,s.kt)(Li,(0,p.Z)({},vi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Zi.isMDXComponent=!0;const bi={toc:[]},Ni="wrapper";function zi(t){let{components:e,...n}=t;return(0,s.kt)(Ni,(0,p.Z)({},bi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unsubscribe from the event."))}zi.isMDXComponent=!0;const Ai={toc:[]},Pi="wrapper";function Wi(t){let{components:e,...n}=t;return(0,s.kt)(Pi,(0,p.Z)({},Ai,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The handler to unsubscribe."))}Wi.isMDXComponent=!0;const Ri={toc:[]},Ii="wrapper";function Si(t){let{components:e,...n}=t;return(0,s.kt)(Ii,(0,p.Z)({},Ri,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the value passed to subscribers."))}Si.isMDXComponent=!0;const Bi={toc:[]},Gi="wrapper";function Ei(t){let{components:e,...n}=t;return(0,s.kt)(Gi,(0,p.Z)({},Bi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Ei.isMDXComponent=!0;const Oi={toc:[]},Fi="wrapper";function Ui(t){let{components:e,...n}=t;return(0,s.kt)(Fi,(0,p.Z)({},Oi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}Ui.isMDXComponent=!0;const Vi={toc:[]},qi="wrapper";function ji(t){let{components:e,...n}=t;return(0,s.kt)(qi,(0,p.Z)({},Vi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}ji.isMDXComponent=!0;const Yi={toc:[]},Qi="wrapper";function Hi(t){let{components:e,...n}=t;return(0,s.kt)(Qi,(0,p.Z)({},Yi,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Hi.isMDXComponent=!0;const Ki={toc:[]},$i="wrapper";function Ji(t){let{components:e,...n}=t;return(0,s.kt)($i,(0,p.Z)({},Ki,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}Ji.isMDXComponent=!0;const tl={toc:[]},el="wrapper";function nl(t){let{components:e,...n}=t;return(0,s.kt)(el,(0,p.Z)({},tl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the argument passed to subscribers."))}nl.isMDXComponent=!0;const ol={toc:[]},pl="wrapper";function rl(t){let{components:e,...n}=t;return(0,s.kt)(pl,(0,p.Z)({},ol,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}rl.isMDXComponent=!0;const sl={toc:[]},cl="wrapper";function al(t){let{components:e,...n}=t;return(0,s.kt)(cl,(0,p.Z)({},sl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provides safe access to the public interface of ",(0,s.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,s.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}al.isMDXComponent=!0;const il={toc:[]},ll="wrapper";function ul(t){let{components:e,...n}=t;return(0,s.kt)(ll,(0,p.Z)({},il,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}ul.isMDXComponent=!0;const ml={toc:[]},dl="wrapper";function hl(t){let{components:e,...n}=t;return(0,s.kt)(dl,(0,p.Z)({},ml,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of times the timer has ticked."))}hl.isMDXComponent=!0;const fl={toc:[]},kl="wrapper";function yl(t){let{components:e,...n}=t;return(0,s.kt)(kl,(0,p.Z)({},fl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator responsible for running this timer."))}yl.isMDXComponent=!0;const Dl={toc:[]},Ml="wrapper";function Xl(t){let{components:e,...n}=t;return(0,s.kt)(Ml,(0,p.Z)({},Dl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the timer ticks."))}Xl.isMDXComponent=!0;const _l={toc:[]},wl="wrapper";function Tl(t){let{components:e,...n}=t;return(0,s.kt)(wl,(0,p.Z)({},_l,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current iteration index."))}Tl.isMDXComponent=!0;const Cl={toc:[]},xl="wrapper";function gl(t){let{components:e,...n}=t;return(0,s.kt)(xl,(0,p.Z)({},Cl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}gl.isMDXComponent=!0;const vl={toc:[]},Ll="wrapper";function Zl(t){let{components:e,...n}=t;return(0,s.kt)(Ll,(0,p.Z)({},vl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Zl.isMDXComponent=!0;const bl={toc:[]},Nl="wrapper";function zl(t){let{components:e,...n}=t;return(0,s.kt)(Nl,(0,p.Z)({},bl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}zl.isMDXComponent=!0;const Al={toc:[]},Pl="wrapper";function Wl(t){let{components:e,...n}=t;return(0,s.kt)(Pl,(0,p.Z)({},Al,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Wl.isMDXComponent=!0;const Rl={toc:[]},Il="wrapper";function Sl(t){let{components:e,...n}=t;return(0,s.kt)(Il,(0,p.Z)({},Rl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Sl.isMDXComponent=!0;const Bl={toc:[]},Gl="wrapper";function El(t){let{components:e,...n}=t;return(0,s.kt)(Gl,(0,p.Z)({},Bl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}El.isMDXComponent=!0;const Ol={toc:[]},Fl="wrapper";function Ul(t){let{components:e,...n}=t;return(0,s.kt)(Fl,(0,p.Z)({},Ol,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Ul.isMDXComponent=!0;const Vl={toc:[]},ql="wrapper";function jl(t){let{components:e,...n}=t;return(0,s.kt)(ql,(0,p.Z)({},Vl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run tasks one after another."))}jl.isMDXComponent=!0;const Yl={toc:[]},Ql="wrapper";function Hl(t){let{components:e,...n}=t;return(0,s.kt)(Ql,(0,p.Z)({},Yl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to run."))}Hl.isMDXComponent=!0;const Kl={toc:[]},$l="wrapper";function Jl(t){let{components:e,...n}=t;return(0,s.kt)($l,(0,p.Z)({},Kl,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,s.kt)("p",null,"Note that the same animation can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,s.kt)("p",null,"The reason ",(0,s.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}Jl.isMDXComponent=!0;const tu={toc:[]},eu="wrapper";function nu(t){let{components:e,...n}=t;return(0,s.kt)(eu,(0,p.Z)({},tu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}nu.isMDXComponent=!0;const ou={toc:[]},pu="wrapper";function ru(t){let{components:e,...n}=t;return(0,s.kt)(pu,(0,p.Z)({},ou,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay in seconds"))}ru.isMDXComponent=!0;const su={toc:[]},cu="wrapper";function au(t){let{components:e,...n}=t;return(0,s.kt)(cu,(0,p.Z)({},su,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task or callback to run after the delay."))}au.isMDXComponent=!0;const iu={toc:[]},lu="wrapper";function uu(t){let{components:e,...n}=t;return(0,s.kt)(lu,(0,p.Z)({},iu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}uu.isMDXComponent=!0;const mu={toc:[]},du="wrapper";function hu(t){let{components:e,...n}=t;return(0,s.kt)(du,(0,p.Z)({},mu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Call the given callback every N seconds."))}hu.isMDXComponent=!0;const fu={toc:[]},ku="wrapper";function yu(t){let{components:e,...n}=t;return(0,s.kt)(ku,(0,p.Z)({},fu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interval between subsequent calls."))}yu.isMDXComponent=!0;const Du={toc:[]},Mu="wrapper";function Xu(t){let{components:e,...n}=t;return(0,s.kt)(Mu,(0,p.Z)({},Du,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to be called."))}Xu.isMDXComponent=!0;const _u={toc:[]},wu="wrapper";function Tu(t){let{components:e,...n}=t;return(0,s.kt)(wu,(0,p.Z)({},_u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each iteration waits until the previous one is completed."))}Tu.isMDXComponent=!0;const Cu={toc:[]},xu="wrapper";function gu(t){let{components:e,...n}=t;return(0,s.kt)(xu,(0,p.Z)({},Cu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n);\n")))}gu.isMDXComponent=!0;const vu={toc:[]},Lu="wrapper";function Zu(t){let{components:e,...n}=t;return(0,s.kt)(Lu,(0,p.Z)({},vu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given generator N times."))}Zu.isMDXComponent=!0;const bu={toc:[]},Nu="wrapper";function zu(t){let{components:e,...n}=t;return(0,s.kt)(Nu,(0,p.Z)({},bu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of iterations."))}zu.isMDXComponent=!0;const Au={toc:[]},Pu="wrapper";function Wu(t){let{components:e,...n}=t;return(0,s.kt)(Pu,(0,p.Z)({},Au,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Wu.isMDXComponent=!0;const Ru={toc:[]},Iu="wrapper";function Su(t){let{components:e,...n}=t;return(0,s.kt)(Iu,(0,p.Z)({},Ru,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Su.isMDXComponent=!0;const Bu={toc:[]},Gu="wrapper";function Eu(t){let{components:e,...n}=t;return(0,s.kt)(Gu,(0,p.Z)({},Bu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopFor(\n  3,\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}Eu.isMDXComponent=!0;const Ou={toc:[]},Fu="wrapper";function Uu(t){let{components:e,...n}=t;return(0,s.kt)(Fu,(0,p.Z)({},Ou,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop for the given amount of time."))}Uu.isMDXComponent=!0;const Vu={toc:[]},qu="wrapper";function ju(t){let{components:e,...n}=t;return(0,s.kt)(qu,(0,p.Z)({},Vu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration in seconds."))}ju.isMDXComponent=!0;const Yu={toc:[]},Qu="wrapper";function Hu(t){let{components:e,...n}=t;return(0,s.kt)(Qu,(0,p.Z)({},Yu,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}Hu.isMDXComponent=!0;const Ku={toc:[]},$u="wrapper";function Ju(t){let{components:e,...n}=t;return(0,s.kt)($u,(0,p.Z)({},Ku,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Generators are executed completely before the next iteration starts.\nAn iteration is allowed to finish even when the time is up. This means that\nthe actual duration of the loop may be longer than the given duration."))}Ju.isMDXComponent=!0;const tm={toc:[]},em="wrapper";function nm(t){let{components:e,...n}=t;return(0,s.kt)(em,(0,p.Z)({},tm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* loopUntil(\n  'Stop Looping',\n  () => circle().position.x(-10, 0.1).to(10, 0.1)\n);\n")))}nm.isMDXComponent=!0;const om={toc:[]},pm="wrapper";function rm(t){let{components:e,...n}=t;return(0,s.kt)(pm,(0,p.Z)({},om,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run a generator in a loop until the given time event."))}rm.isMDXComponent=!0;const sm={toc:[]},cm="wrapper";function am(t){let{components:e,...n}=t;return(0,s.kt)(cm,(0,p.Z)({},sm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The event."))}am.isMDXComponent=!0;const im={toc:[]},lm="wrapper";function um(t){let{components:e,...n}=t;return(0,s.kt)(lm,(0,p.Z)({},im,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each\niteration."))}um.isMDXComponent=!0;const mm={toc:[]},dm="wrapper";function hm(t){let{components:e,...n}=t;return(0,s.kt)(dm,(0,p.Z)({},mm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Do nothing."))}hm.isMDXComponent=!0;const fm={toc:[]},km="wrapper";function ym(t){let{components:e,...n}=t;return(0,s.kt)(km,(0,p.Z)({},fm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}ym.isMDXComponent=!0;const Dm={toc:[]},Mm="wrapper";function Xm(t){let{components:e,...n}=t;return(0,s.kt)(Mm,(0,p.Z)({},Dm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Xm.isMDXComponent=!0;const _m={toc:[]},wm="wrapper";function Tm(t){let{components:e,...n}=t;return(0,s.kt)(wm,(0,p.Z)({},_m,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Tm.isMDXComponent=!0;const Cm={toc:[]},xm="wrapper";function gm(t){let{components:e,...n}=t;return(0,s.kt)(xm,(0,p.Z)({},Cm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}gm.isMDXComponent=!0;const vm={toc:[]},Lm="wrapper";function Zm(t){let{components:e,...n}=t;return(0,s.kt)(Lm,(0,p.Z)({},vm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Turn the given generator function into a threadable generator."))}Zm.isMDXComponent=!0;const bm={toc:[]},Nm="wrapper";function zm(t){let{components:e,...n}=t;return(0,s.kt)(Nm,(0,p.Z)({},bm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional name used when displaying this generator in the UI."))}zm.isMDXComponent=!0;const Am={toc:[]},Pm="wrapper";function Wm(t){let{components:e,...n}=t;return(0,s.kt)(Pm,(0,p.Z)({},Am,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a factory that creates the generator."))}Wm.isMDXComponent=!0;const Rm={toc:[]},Im="wrapper";function Sm(t){let{components:e,...n}=t;return(0,s.kt)(Im,(0,p.Z)({},Rm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Sm.isMDXComponent=!0;const Bm={toc:[]},Gm="wrapper";function Em(t){let{components:e,...n}=t;return(0,s.kt)(Gm,(0,p.Z)({},Bm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Em.isMDXComponent=!0;const Om={toc:[]},Fm="wrapper";function Um(t){let{components:e,...n}=t;return(0,s.kt)(Fm,(0,p.Z)({},Om,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Start all tasks one after another with a constant delay between."))}Um.isMDXComponent=!0;const Vm={toc:[]},qm="wrapper";function jm(t){let{components:e,...n}=t;return(0,s.kt)(qm,(0,p.Z)({},Vm,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delay between each of the tasks."))}jm.isMDXComponent=!0;const Ym={toc:[]},Qm="wrapper";function Hm(t){let{components:e,...n}=t;return(0,s.kt)(Qm,(0,p.Z)({},Ym,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to be run in a sequence."))}Hm.isMDXComponent=!0;const Km={toc:[]},$m="wrapper";function Jm(t){let{components:e,...n}=t;return(0,s.kt)($m,(0,p.Z)({},Km,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}Jm.isMDXComponent=!0;const td={toc:[]},ed="wrapper";function nd(t){let{components:e,...n}=t;return(0,s.kt)(ed,(0,p.Z)({},td,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the given amount of time."))}nd.isMDXComponent=!0;const od={toc:[]},pd="wrapper";function rd(t){let{components:e,...n}=t;return(0,s.kt)(pd,(0,p.Z)({},od,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The relative time in seconds."))}rd.isMDXComponent=!0;const sd={toc:[]},cd="wrapper";function ad(t){let{components:e,...n}=t;return(0,s.kt)(cd,(0,p.Z)({},sd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}ad.isMDXComponent=!0;const id={toc:[]},ld="wrapper";function ud(t){let{components:e,...n}=t;return(0,s.kt)(ld,(0,p.Z)({},id,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}ud.isMDXComponent=!0;const md={toc:[]},dd="wrapper";function hd(t){let{components:e,...n}=t;return(0,s.kt)(dd,(0,p.Z)({},md,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}hd.isMDXComponent=!0;const fd={toc:[]},kd="wrapper";function yd(t){let{components:e,...n}=t;return(0,s.kt)(kd,(0,p.Z)({},fd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait until the given time event."))}yd.isMDXComponent=!0;const Dd={toc:[]},Md="wrapper";function Xd(t){let{components:e,...n}=t;return(0,s.kt)(Md,(0,p.Z)({},Dd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the time event."))}Xd.isMDXComponent=!0;const _d={toc:[]},wd="wrapper";function Td(t){let{components:e,...n}=t;return(0,s.kt)(wd,(0,p.Z)({},_d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional task to be run after the function completes."))}Td.isMDXComponent=!0;const Cd={toc:[]},xd="wrapper";function gd(t){let{components:e,...n}=t;return(0,s.kt)(xd,(0,p.Z)({},Cd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multi-media management."))}gd.isMDXComponent=!0;const vd={toc:[]},Ld="wrapper";function Zd(t){let{components:e,...n}=t;return(0,s.kt)(Ld,(0,p.Z)({},vd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Zd.isMDXComponent=!0;const bd={toc:[]},Nd="wrapper";function zd(t){let{components:e,...n}=t;return(0,s.kt)(Nd,(0,p.Z)({},bd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause/resume the audio."))}zd.isMDXComponent=!0;const Ad={toc:[]},Pd="wrapper";function Wd(t){let{components:e,...n}=t;return(0,s.kt)(Pd,(0,p.Z)({},Ad,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the audio should be paused or resumed."))}Wd.isMDXComponent=!0;const Rd={toc:[]},Id="wrapper";function Sd(t){let{components:e,...n}=t;return(0,s.kt)(Id,(0,p.Z)({},Rd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The absolute biggest value from the peaks array."))}Sd.isMDXComponent=!0;const Bd={toc:[]},Gd="wrapper";function Ed(t){let{components:e,...n}=t;return(0,s.kt)(Gd,(0,p.Z)({},Bd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The amount of samples taken."))}Ed.isMDXComponent=!0;const Od={toc:[]},Fd="wrapper";function Ud(t){let{components:e,...n}=t;return(0,s.kt)(Fd,(0,p.Z)({},Od,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Ud.isMDXComponent=!0;const Vd={toc:[]},qd="wrapper";function jd(t){let{components:e,...n}=t;return(0,s.kt)(qd,(0,p.Z)({},Vd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Samples per seconds."))}jd.isMDXComponent=!0;const Yd={toc:[]},Qd="wrapper";function Hd(t){let{components:e,...n}=t;return(0,s.kt)(Qd,(0,p.Z)({},Yd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime representation of meta files."))}Hd.isMDXComponent=!0;const Kd={toc:[]},$d="wrapper";function Jd(t){let{components:e,...n}=t;return(0,s.kt)($d,(0,p.Z)({},Kd,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a boolean value stored in a meta file."))}Jd.isMDXComponent=!0;const th={toc:[]},eh="wrapper";function nh(t){let{components:e,...n}=t;return(0,s.kt)(eh,(0,p.Z)({},th,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}nh.isMDXComponent=!0;const oh={toc:[]},ph="wrapper";function rh(t){let{components:e,...n}=t;return(0,s.kt)(ph,(0,p.Z)({},oh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}rh.isMDXComponent=!0;const sh={toc:[]},ch="wrapper";function ah(t){let{components:e,...n}=t;return(0,s.kt)(ch,(0,p.Z)({},sh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}ah.isMDXComponent=!0;const ih={toc:[]},lh="wrapper";function uh(t){let{components:e,...n}=t;return(0,s.kt)(lh,(0,p.Z)({},ih,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}uh.isMDXComponent=!0;const mh={toc:[]},dh="wrapper";function hh(t){let{components:e,...n}=t;return(0,s.kt)(dh,(0,p.Z)({},mh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}hh.isMDXComponent=!0;const fh={toc:[]},kh="wrapper";function yh(t){let{components:e,...n}=t;return(0,s.kt)(kh,(0,p.Z)({},fh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}yh.isMDXComponent=!0;const Dh={toc:[]},Mh="wrapper";function Xh(t){let{components:e,...n}=t;return(0,s.kt)(Mh,(0,p.Z)({},Dh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Xh.isMDXComponent=!0;const _h={toc:[]},wh="wrapper";function Th(t){let{components:e,...n}=t;return(0,s.kt)(wh,(0,p.Z)({},_h,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Th.isMDXComponent=!0;const Ch={toc:[]},xh="wrapper";function gh(t){let{components:e,...n}=t;return(0,s.kt)(xh,(0,p.Z)({},Ch,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}gh.isMDXComponent=!0;const vh={toc:[]},Lh="wrapper";function Zh(t){let{components:e,...n}=t;return(0,s.kt)(Lh,(0,p.Z)({},vh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Zh.isMDXComponent=!0;const bh={toc:[]},Nh="wrapper";function zh(t){let{components:e,...n}=t;return(0,s.kt)(Nh,(0,p.Z)({},bh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}zh.isMDXComponent=!0;const Ah={toc:[]},Ph="wrapper";function Wh(t){let{components:e,...n}=t;return(0,s.kt)(Ph,(0,p.Z)({},Ah,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Wh.isMDXComponent=!0;const Rh={toc:[]},Ih="wrapper";function Sh(t){let{components:e,...n}=t;return(0,s.kt)(Ih,(0,p.Z)({},Rh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Sh.isMDXComponent=!0;const Bh={toc:[]},Gh="wrapper";function Eh(t){let{components:e,...n}=t;return(0,s.kt)(Gh,(0,p.Z)({},Bh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Eh.isMDXComponent=!0;const Oh={toc:[]},Fh="wrapper";function Uh(t){let{components:e,...n}=t;return(0,s.kt)(Fh,(0,p.Z)({},Oh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}Uh.isMDXComponent=!0;const Vh={toc:[]},qh="wrapper";function jh(t){let{components:e,...n}=t;return(0,s.kt)(qh,(0,p.Z)({},Vh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}jh.isMDXComponent=!0;const Yh={toc:[]},Qh="wrapper";function Hh(t){let{components:e,...n}=t;return(0,s.kt)(Qh,(0,p.Z)({},Yh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}Hh.isMDXComponent=!0;const Kh={toc:[]},$h="wrapper";function Jh(t){let{components:e,...n}=t;return(0,s.kt)($h,(0,p.Z)({},Kh,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}Jh.isMDXComponent=!0;const tf={toc:[]},ef="wrapper";function nf(t){let{components:e,...n}=t;return(0,s.kt)(ef,(0,p.Z)({},tf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}nf.isMDXComponent=!0;const of={toc:[]},pf="wrapper";function rf(t){let{components:e,...n}=t;return(0,s.kt)(pf,(0,p.Z)({},of,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}rf.isMDXComponent=!0;const sf={toc:[]},cf="wrapper";function af(t){let{components:e,...n}=t;return(0,s.kt)(cf,(0,p.Z)({},sf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color stored in a meta file."))}af.isMDXComponent=!0;const lf={toc:[]},uf="wrapper";function mf(t){let{components:e,...n}=t;return(0,s.kt)(uf,(0,p.Z)({},lf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}mf.isMDXComponent=!0;const df={toc:[]},hf="wrapper";function ff(t){let{components:e,...n}=t;return(0,s.kt)(hf,(0,p.Z)({},df,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}ff.isMDXComponent=!0;const kf={toc:[]},yf="wrapper";function Df(t){let{components:e,...n}=t;return(0,s.kt)(yf,(0,p.Z)({},kf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Df.isMDXComponent=!0;const Mf={toc:[]},Xf="wrapper";function _f(t){let{components:e,...n}=t;return(0,s.kt)(Xf,(0,p.Z)({},Mf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}_f.isMDXComponent=!0;const wf={toc:[]},Tf="wrapper";function Cf(t){let{components:e,...n}=t;return(0,s.kt)(Tf,(0,p.Z)({},wf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Cf.isMDXComponent=!0;const xf={toc:[]},gf="wrapper";function vf(t){let{components:e,...n}=t;return(0,s.kt)(gf,(0,p.Z)({},xf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}vf.isMDXComponent=!0;const Lf={toc:[]},Zf="wrapper";function bf(t){let{components:e,...n}=t;return(0,s.kt)(Zf,(0,p.Z)({},Lf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}bf.isMDXComponent=!0;const Nf={toc:[]},zf="wrapper";function Af(t){let{components:e,...n}=t;return(0,s.kt)(zf,(0,p.Z)({},Nf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Af.isMDXComponent=!0;const Pf={toc:[]},Wf="wrapper";function Rf(t){let{components:e,...n}=t;return(0,s.kt)(Wf,(0,p.Z)({},Pf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Rf.isMDXComponent=!0;const If={toc:[]},Sf="wrapper";function Bf(t){let{components:e,...n}=t;return(0,s.kt)(Sf,(0,p.Z)({},If,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Bf.isMDXComponent=!0;const Gf={toc:[]},Ef="wrapper";function Of(t){let{components:e,...n}=t;return(0,s.kt)(Ef,(0,p.Z)({},Gf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Of.isMDXComponent=!0;const Ff={toc:[]},Uf="wrapper";function Vf(t){let{components:e,...n}=t;return(0,s.kt)(Uf,(0,p.Z)({},Ff,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Vf.isMDXComponent=!0;const qf={toc:[]},jf="wrapper";function Yf(t){let{components:e,...n}=t;return(0,s.kt)(jf,(0,p.Z)({},qf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Yf.isMDXComponent=!0;const Qf={toc:[]},Hf="wrapper";function Kf(t){let{components:e,...n}=t;return(0,s.kt)(Hf,(0,p.Z)({},Qf,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}Kf.isMDXComponent=!0;const $f={toc:[]},Jf="wrapper";function tk(t){let{components:e,...n}=t;return(0,s.kt)(Jf,(0,p.Z)({},$f,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}tk.isMDXComponent=!0;const ek={toc:[]},nk="wrapper";function ok(t){let{components:e,...n}=t;return(0,s.kt)(nk,(0,p.Z)({},ek,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}ok.isMDXComponent=!0;const pk={toc:[]},rk="wrapper";function sk(t){let{components:e,...n}=t;return(0,s.kt)(rk,(0,p.Z)({},pk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}sk.isMDXComponent=!0;const ck={toc:[]},ak="wrapper";function ik(t){let{components:e,...n}=t;return(0,s.kt)(ak,(0,p.Z)({},ck,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}ik.isMDXComponent=!0;const lk={toc:[]},uk="wrapper";function mk(t){let{components:e,...n}=t;return(0,s.kt)(uk,(0,p.Z)({},lk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}mk.isMDXComponent=!0;const dk={toc:[]},hk="wrapper";function fk(t){let{components:e,...n}=t;return(0,s.kt)(hk,(0,p.Z)({},dk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}fk.isMDXComponent=!0;const kk={toc:[]},yk="wrapper";function Dk(t){let{components:e,...n}=t;return(0,s.kt)(yk,(0,p.Z)({},kk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an enum value stored in a meta file."))}Dk.isMDXComponent=!0;const Mk={toc:[]},Xk="wrapper";function _k(t){let{components:e,...n}=t;return(0,s.kt)(Xk,(0,p.Z)({},Mk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}_k.isMDXComponent=!0;const wk={toc:[]},Tk="wrapper";function Ck(t){let{components:e,...n}=t;return(0,s.kt)(Tk,(0,p.Z)({},wk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Ck.isMDXComponent=!0;const xk={toc:[]},gk="wrapper";function vk(t){let{components:e,...n}=t;return(0,s.kt)(gk,(0,p.Z)({},xk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}vk.isMDXComponent=!0;const Lk={toc:[]},Zk="wrapper";function bk(t){let{components:e,...n}=t;return(0,s.kt)(Zk,(0,p.Z)({},Lk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}bk.isMDXComponent=!0;const Nk={toc:[]},zk="wrapper";function Ak(t){let{components:e,...n}=t;return(0,s.kt)(zk,(0,p.Z)({},Nk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Ak.isMDXComponent=!0;const Pk={toc:[]},Wk="wrapper";function Rk(t){let{components:e,...n}=t;return(0,s.kt)(Wk,(0,p.Z)({},Pk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Rk.isMDXComponent=!0;const Ik={toc:[]},Sk="wrapper";function Bk(t){let{components:e,...n}=t;return(0,s.kt)(Sk,(0,p.Z)({},Ik,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Bk.isMDXComponent=!0;const Gk={toc:[]},Ek="wrapper";function Ok(t){let{components:e,...n}=t;return(0,s.kt)(Ek,(0,p.Z)({},Gk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Ok.isMDXComponent=!0;const Fk={toc:[]},Uk="wrapper";function Vk(t){let{components:e,...n}=t;return(0,s.kt)(Uk,(0,p.Z)({},Fk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Vk.isMDXComponent=!0;const qk={toc:[]},jk="wrapper";function Yk(t){let{components:e,...n}=t;return(0,s.kt)(jk,(0,p.Z)({},qk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}Yk.isMDXComponent=!0;const Qk={toc:[]},Hk="wrapper";function Kk(t){let{components:e,...n}=t;return(0,s.kt)(Hk,(0,p.Z)({},Qk,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}Kk.isMDXComponent=!0;const $k={toc:[]},Jk="wrapper";function ty(t){let{components:e,...n}=t;return(0,s.kt)(Jk,(0,p.Z)({},$k,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}ty.isMDXComponent=!0;const ey={toc:[]},ny="wrapper";function oy(t){let{components:e,...n}=t;return(0,s.kt)(ny,(0,p.Z)({},ey,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}oy.isMDXComponent=!0;const py={toc:[]},ry="wrapper";function sy(t){let{components:e,...n}=t;return(0,s.kt)(ry,(0,p.Z)({},py,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}sy.isMDXComponent=!0;const cy={toc:[]},ay="wrapper";function iy(t){let{components:e,...n}=t;return(0,s.kt)(ay,(0,p.Z)({},cy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}iy.isMDXComponent=!0;const ly={toc:[]},uy="wrapper";function my(t){let{components:e,...n}=t;return(0,s.kt)(uy,(0,p.Z)({},ly,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}my.isMDXComponent=!0;const dy={toc:[]},hy="wrapper";function fy(t){let{components:e,...n}=t;return(0,s.kt)(hy,(0,p.Z)({},dy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}fy.isMDXComponent=!0;const ky={toc:[]},yy="wrapper";function Dy(t){let{components:e,...n}=t;return(0,s.kt)(yy,(0,p.Z)({},ky,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}Dy.isMDXComponent=!0;const My={toc:[]},Xy="wrapper";function _y(t){let{components:e,...n}=t;return(0,s.kt)(Xy,(0,p.Z)({},My,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the exporter configuration."))}_y.isMDXComponent=!0;const wy={toc:[]},Ty="wrapper";function Cy(t){let{components:e,...n}=t;return(0,s.kt)(Ty,(0,p.Z)({},wy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Cy.isMDXComponent=!0;const xy={toc:[]},gy="wrapper";function vy(t){let{components:e,...n}=t;return(0,s.kt)(gy,(0,p.Z)({},xy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}vy.isMDXComponent=!0;const Ly={toc:[]},Zy="wrapper";function by(t){let{components:e,...n}=t;return(0,s.kt)(Zy,(0,p.Z)({},Ly,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}by.isMDXComponent=!0;const Ny={toc:[]},zy="wrapper";function Ay(t){let{components:e,...n}=t;return(0,s.kt)(zy,(0,p.Z)({},Ny,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Ay.isMDXComponent=!0;const Py={toc:[]},Wy="wrapper";function Ry(t){let{components:e,...n}=t;return(0,s.kt)(Wy,(0,p.Z)({},Py,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Ry.isMDXComponent=!0;const Iy={toc:[]},Sy="wrapper";function By(t){let{components:e,...n}=t;return(0,s.kt)(Sy,(0,p.Z)({},Iy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the nested fields change."))}By.isMDXComponent=!0;const Gy={toc:[]},Ey="wrapper";function Oy(t){let{components:e,...n}=t;return(0,s.kt)(Ey,(0,p.Z)({},Gy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Oy.isMDXComponent=!0;const Fy={toc:[]},Uy="wrapper";function Vy(t){let{components:e,...n}=t;return(0,s.kt)(Uy,(0,p.Z)({},Fy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}Vy.isMDXComponent=!0;const qy={toc:[]},jy="wrapper";function Yy(t){let{components:e,...n}=t;return(0,s.kt)(jy,(0,p.Z)({},qy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}Yy.isMDXComponent=!0;const Qy={toc:[]},Hy="wrapper";function Ky(t){let{components:e,...n}=t;return(0,s.kt)(Hy,(0,p.Z)({},Qy,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}Ky.isMDXComponent=!0;const $y={toc:[]},Jy="wrapper";function tD(t){let{components:e,...n}=t;return(0,s.kt)(Jy,(0,p.Z)({},$y,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}tD.isMDXComponent=!0;const eD={toc:[]},nD="wrapper";function oD(t){let{components:e,...n}=t;return(0,s.kt)(nD,(0,p.Z)({},eD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}oD.isMDXComponent=!0;const pD={toc:[]},rD="wrapper";function sD(t){let{components:e,...n}=t;return(0,s.kt)(rD,(0,p.Z)({},pD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}sD.isMDXComponent=!0;const cD={toc:[]},aD="wrapper";function iD(t){let{components:e,...n}=t;return(0,s.kt)(aD,(0,p.Z)({},cD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}iD.isMDXComponent=!0;const lD={toc:[]},uD="wrapper";function mD(t){let{components:e,...n}=t;return(0,s.kt)(uD,(0,p.Z)({},lD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}mD.isMDXComponent=!0;const dD={toc:[]},hD="wrapper";function fD(t){let{components:e,...n}=t;return(0,s.kt)(hD,(0,p.Z)({},dD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}fD.isMDXComponent=!0;const kD={toc:[]},yD="wrapper";function DD(t){let{components:e,...n}=t;return(0,s.kt)(yD,(0,p.Z)({},kD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}DD.isMDXComponent=!0;const MD={toc:[]},XD="wrapper";function _D(t){let{components:e,...n}=t;return(0,s.kt)(XD,(0,p.Z)({},MD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}_D.isMDXComponent=!0;const wD={toc:[]},TD="wrapper";function CD(t){let{components:e,...n}=t;return(0,s.kt)(TD,(0,p.Z)({},wD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}CD.isMDXComponent=!0;const xD={toc:[]},gD="wrapper";function vD(t){let{components:e,...n}=t;return(0,s.kt)(gD,(0,p.Z)({},xD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an entry in the meta file."))}vD.isMDXComponent=!0;const LD={toc:[]},ZD="wrapper";function bD(t){let{components:e,...n}=t;return(0,s.kt)(ZD,(0,p.Z)({},LD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}bD.isMDXComponent=!0;const ND={toc:[]},zD="wrapper";function AD(t){let{components:e,...n}=t;return(0,s.kt)(zD,(0,p.Z)({},ND,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}AD.isMDXComponent=!0;const PD={toc:[]},WD="wrapper";function RD(t){let{components:e,...n}=t;return(0,s.kt)(WD,(0,p.Z)({},PD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}RD.isMDXComponent=!0;const ID={toc:[]},SD="wrapper";function BD(t){let{components:e,...n}=t;return(0,s.kt)(SD,(0,p.Z)({},ID,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}BD.isMDXComponent=!0;const GD={toc:[]},ED="wrapper";function OD(t){let{components:e,...n}=t;return(0,s.kt)(ED,(0,p.Z)({},GD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}OD.isMDXComponent=!0;const FD={toc:[]},UD="wrapper";function VD(t){let{components:e,...n}=t;return(0,s.kt)(UD,(0,p.Z)({},FD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}VD.isMDXComponent=!0;const qD={toc:[]},jD="wrapper";function YD(t){let{components:e,...n}=t;return(0,s.kt)(jD,(0,p.Z)({},qD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}YD.isMDXComponent=!0;const QD={toc:[]},HD="wrapper";function KD(t){let{components:e,...n}=t;return(0,s.kt)(HD,(0,p.Z)({},QD,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}KD.isMDXComponent=!0;const $D={toc:[]},JD="wrapper";function tM(t){let{components:e,...n}=t;return(0,s.kt)(JD,(0,p.Z)({},$D,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}tM.isMDXComponent=!0;const eM={toc:[]},nM="wrapper";function oM(t){let{components:e,...n}=t;return(0,s.kt)(nM,(0,p.Z)({},eM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}oM.isMDXComponent=!0;const pM={toc:[]},rM="wrapper";function sM(t){let{components:e,...n}=t;return(0,s.kt)(rM,(0,p.Z)({},pM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}sM.isMDXComponent=!0;const cM={toc:[]},aM="wrapper";function iM(t){let{components:e,...n}=t;return(0,s.kt)(aM,(0,p.Z)({},cM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}iM.isMDXComponent=!0;const lM={toc:[]},uM="wrapper";function mM(t){let{components:e,...n}=t;return(0,s.kt)(uM,(0,p.Z)({},lM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}mM.isMDXComponent=!0;const dM={toc:[]},hM="wrapper";function fM(t){let{components:e,...n}=t;return(0,s.kt)(hM,(0,p.Z)({},dM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}fM.isMDXComponent=!0;const kM={toc:[]},yM="wrapper";function DM(t){let{components:e,...n}=t;return(0,s.kt)(yM,(0,p.Z)({},kM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}DM.isMDXComponent=!0;const MM={toc:[]},XM="wrapper";function _M(t){let{components:e,...n}=t;return(0,s.kt)(XM,(0,p.Z)({},MM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}_M.isMDXComponent=!0;const wM={toc:[]},TM="wrapper";function CM(t){let{components:e,...n}=t;return(0,s.kt)(TM,(0,p.Z)({},wM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}CM.isMDXComponent=!0;const xM={toc:[]},gM="wrapper";function vM(t){let{components:e,...n}=t;return(0,s.kt)(gM,(0,p.Z)({},xM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}vM.isMDXComponent=!0;const LM={toc:[]},ZM="wrapper";function bM(t){let{components:e,...n}=t;return(0,s.kt)(ZM,(0,p.Z)({},LM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}bM.isMDXComponent=!0;const NM={toc:[]},zM="wrapper";function AM(t){let{components:e,...n}=t;return(0,s.kt)(zM,(0,p.Z)({},NM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}AM.isMDXComponent=!0;const PM={toc:[]},WM="wrapper";function RM(t){let{components:e,...n}=t;return(0,s.kt)(WM,(0,p.Z)({},PM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type used to store this field in the meta\nfile."))}RM.isMDXComponent=!0;const IM={toc:[]},SM="wrapper";function BM(t){let{components:e,...n}=t;return(0,s.kt)(SM,(0,p.Z)({},IM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The runtime type of this field."))}BM.isMDXComponent=!0;const GM={toc:[]},EM="wrapper";function OM(t){let{components:e,...n}=t;return(0,s.kt)(EM,(0,p.Z)({},GM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a number stored in a meta file."))}OM.isMDXComponent=!0;const FM={toc:[]},UM="wrapper";function VM(t){let{components:e,...n}=t;return(0,s.kt)(UM,(0,p.Z)({},FM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}VM.isMDXComponent=!0;const qM={toc:[]},jM="wrapper";function YM(t){let{components:e,...n}=t;return(0,s.kt)(jM,(0,p.Z)({},qM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}YM.isMDXComponent=!0;const QM={toc:[]},HM="wrapper";function KM(t){let{components:e,...n}=t;return(0,s.kt)(HM,(0,p.Z)({},QM,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}KM.isMDXComponent=!0;const $M={toc:[]},JM="wrapper";function tX(t){let{components:e,...n}=t;return(0,s.kt)(JM,(0,p.Z)({},$M,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}tX.isMDXComponent=!0;const eX={toc:[]},nX="wrapper";function oX(t){let{components:e,...n}=t;return(0,s.kt)(nX,(0,p.Z)({},eX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}oX.isMDXComponent=!0;const pX={toc:[]},rX="wrapper";function sX(t){let{components:e,...n}=t;return(0,s.kt)(rX,(0,p.Z)({},pX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}sX.isMDXComponent=!0;const cX={toc:[]},aX="wrapper";function iX(t){let{components:e,...n}=t;return(0,s.kt)(aX,(0,p.Z)({},cX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}iX.isMDXComponent=!0;const lX={toc:[]},uX="wrapper";function mX(t){let{components:e,...n}=t;return(0,s.kt)(uX,(0,p.Z)({},lX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}mX.isMDXComponent=!0;const dX={toc:[]},hX="wrapper";function fX(t){let{components:e,...n}=t;return(0,s.kt)(hX,(0,p.Z)({},dX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}fX.isMDXComponent=!0;const kX={toc:[]},yX="wrapper";function DX(t){let{components:e,...n}=t;return(0,s.kt)(yX,(0,p.Z)({},kX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}DX.isMDXComponent=!0;const MX={toc:[]},XX="wrapper";function _X(t){let{components:e,...n}=t;return(0,s.kt)(XX,(0,p.Z)({},MX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}_X.isMDXComponent=!0;const wX={toc:[]},TX="wrapper";function CX(t){let{components:e,...n}=t;return(0,s.kt)(TX,(0,p.Z)({},wX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}CX.isMDXComponent=!0;const xX={toc:[]},gX="wrapper";function vX(t){let{components:e,...n}=t;return(0,s.kt)(gX,(0,p.Z)({},xX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}vX.isMDXComponent=!0;const LX={toc:[]},ZX="wrapper";function bX(t){let{components:e,...n}=t;return(0,s.kt)(ZX,(0,p.Z)({},LX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}bX.isMDXComponent=!0;const NX={toc:[]},zX="wrapper";function AX(t){let{components:e,...n}=t;return(0,s.kt)(zX,(0,p.Z)({},NX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}AX.isMDXComponent=!0;const PX={toc:[]},WX="wrapper";function RX(t){let{components:e,...n}=t;return(0,s.kt)(WX,(0,p.Z)({},PX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}RX.isMDXComponent=!0;const IX={toc:[]},SX="wrapper";function BX(t){let{components:e,...n}=t;return(0,s.kt)(SX,(0,p.Z)({},IX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}BX.isMDXComponent=!0;const GX={toc:[]},EX="wrapper";function OX(t){let{components:e,...n}=t;return(0,s.kt)(EX,(0,p.Z)({},GX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}OX.isMDXComponent=!0;const FX={toc:[]},UX="wrapper";function VX(t){let{components:e,...n}=t;return(0,s.kt)(UX,(0,p.Z)({},FX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}VX.isMDXComponent=!0;const qX={toc:[]},jX="wrapper";function YX(t){let{components:e,...n}=t;return(0,s.kt)(jX,(0,p.Z)({},qX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}YX.isMDXComponent=!0;const QX={toc:[]},HX="wrapper";function KX(t){let{components:e,...n}=t;return(0,s.kt)(HX,(0,p.Z)({},QX,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Range is an array with two elements denoting the beginning and end of a\nrange, respectively."))}KX.isMDXComponent=!0;const $X={toc:[]},JX="wrapper";function t_(t){let{components:e,...n}=t;return(0,s.kt)(JX,(0,p.Z)({},$X,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a range stored in a meta file."))}t_.isMDXComponent=!0;const e_={toc:[]},n_="wrapper";function o_(t){let{components:e,...n}=t;return(0,s.kt)(n_,(0,p.Z)({},e_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}o_.isMDXComponent=!0;const p_={toc:[]},r_="wrapper";function s_(t){let{components:e,...n}=t;return(0,s.kt)(r_,(0,p.Z)({},p_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}s_.isMDXComponent=!0;const c_={toc:[]},a_="wrapper";function i_(t){let{components:e,...n}=t;return(0,s.kt)(a_,(0,p.Z)({},c_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}i_.isMDXComponent=!0;const l_={toc:[]},u_="wrapper";function m_(t){let{components:e,...n}=t;return(0,s.kt)(u_,(0,p.Z)({},l_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}m_.isMDXComponent=!0;const d_={toc:[]},h_="wrapper";function f_(t){let{components:e,...n}=t;return(0,s.kt)(h_,(0,p.Z)({},d_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}f_.isMDXComponent=!0;const k_={toc:[]},y_="wrapper";function D_(t){let{components:e,...n}=t;return(0,s.kt)(y_,(0,p.Z)({},k_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}D_.isMDXComponent=!0;const M_={toc:[]},X_="wrapper";function __(t){let{components:e,...n}=t;return(0,s.kt)(X_,(0,p.Z)({},M_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}__.isMDXComponent=!0;const w_={toc:[]},T_="wrapper";function C_(t){let{components:e,...n}=t;return(0,s.kt)(T_,(0,p.Z)({},w_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}C_.isMDXComponent=!0;const x_={toc:[]},g_="wrapper";function v_(t){let{components:e,...n}=t;return(0,s.kt)(g_,(0,p.Z)({},x_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}v_.isMDXComponent=!0;const L_={toc:[]},Z_="wrapper";function b_(t){let{components:e,...n}=t;return(0,s.kt)(Z_,(0,p.Z)({},L_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}b_.isMDXComponent=!0;const N_={toc:[]},z_="wrapper";function A_(t){let{components:e,...n}=t;return(0,s.kt)(z_,(0,p.Z)({},N_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}A_.isMDXComponent=!0;const P_={toc:[]},W_="wrapper";function R_(t){let{components:e,...n}=t;return(0,s.kt)(W_,(0,p.Z)({},P_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}R_.isMDXComponent=!0;const I_={toc:[]},S_="wrapper";function B_(t){let{components:e,...n}=t;return(0,s.kt)(S_,(0,p.Z)({},I_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}B_.isMDXComponent=!0;const G_={toc:[]},E_="wrapper";function O_(t){let{components:e,...n}=t;return(0,s.kt)(E_,(0,p.Z)({},G_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}O_.isMDXComponent=!0;const F_={toc:[]},U_="wrapper";function V_(t){let{components:e,...n}=t;return(0,s.kt)(U_,(0,p.Z)({},F_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}V_.isMDXComponent=!0;const q_={toc:[]},j_="wrapper";function Y_(t){let{components:e,...n}=t;return(0,s.kt)(j_,(0,p.Z)({},q_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}Y_.isMDXComponent=!0;const Q_={toc:[]},H_="wrapper";function K_(t){let{components:e,...n}=t;return(0,s.kt)(H_,(0,p.Z)({},Q_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}K_.isMDXComponent=!0;const $_={toc:[]},J_="wrapper";function tw(t){let{components:e,...n}=t;return(0,s.kt)(J_,(0,p.Z)({},$_,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}tw.isMDXComponent=!0;const ew={toc:[]},nw="wrapper";function ow(t){let{components:e,...n}=t;return(0,s.kt)(nw,(0,p.Z)({},ew,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}ow.isMDXComponent=!0;const pw={toc:[]},rw="wrapper";function sw(t){let{components:e,...n}=t;return(0,s.kt)(rw,(0,p.Z)({},pw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}sw.isMDXComponent=!0;const cw={toc:[]},aw="wrapper";function iw(t){let{components:e,...n}=t;return(0,s.kt)(aw,(0,p.Z)({},cw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This helper method applies additional validation to the range, preventing\nit from overflowing the timeline."))}iw.isMDXComponent=!0;const lw={toc:[]},uw="wrapper";function mw(t){let{components:e,...n}=t;return(0,s.kt)(uw,(0,p.Z)({},lw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given range from frames to seconds and update this field."))}mw.isMDXComponent=!0;const dw={toc:[]},hw="wrapper";function fw(t){let{components:e,...n}=t;return(0,s.kt)(hw,(0,p.Z)({},dw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The beginning of the range."))}fw.isMDXComponent=!0;const kw={toc:[]},yw="wrapper";function Dw(t){let{components:e,...n}=t;return(0,s.kt)(yw,(0,p.Z)({},kw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}Dw.isMDXComponent=!0;const Mw={toc:[]},Xw="wrapper";function _w(t){let{components:e,...n}=t;return(0,s.kt)(Xw,(0,p.Z)({},Mw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current duration in frames."))}_w.isMDXComponent=!0;const ww={toc:[]},Tw="wrapper";function Cw(t){let{components:e,...n}=t;return(0,s.kt)(Tw,(0,p.Z)({},ww,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current framerate."))}Cw.isMDXComponent=!0;const xw={toc:[]},gw="wrapper";function vw(t){let{components:e,...n}=t;return(0,s.kt)(gw,(0,p.Z)({},xw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a string stored in a meta file."))}vw.isMDXComponent=!0;const Lw={toc:[]},Zw="wrapper";function bw(t){let{components:e,...n}=t;return(0,s.kt)(Zw,(0,p.Z)({},Lw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}bw.isMDXComponent=!0;const Nw={toc:[]},zw="wrapper";function Aw(t){let{components:e,...n}=t;return(0,s.kt)(zw,(0,p.Z)({},Nw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Aw.isMDXComponent=!0;const Pw={toc:[]},Ww="wrapper";function Rw(t){let{components:e,...n}=t;return(0,s.kt)(Ww,(0,p.Z)({},Pw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}Rw.isMDXComponent=!0;const Iw={toc:[]},Sw="wrapper";function Bw(t){let{components:e,...n}=t;return(0,s.kt)(Sw,(0,p.Z)({},Iw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}Bw.isMDXComponent=!0;const Gw={toc:[]},Ew="wrapper";function Ow(t){let{components:e,...n}=t;return(0,s.kt)(Ew,(0,p.Z)({},Gw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}Ow.isMDXComponent=!0;const Fw={toc:[]},Uw="wrapper";function Vw(t){let{components:e,...n}=t;return(0,s.kt)(Uw,(0,p.Z)({},Fw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}Vw.isMDXComponent=!0;const qw={toc:[]},jw="wrapper";function Yw(t){let{components:e,...n}=t;return(0,s.kt)(jw,(0,p.Z)({},qw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}Yw.isMDXComponent=!0;const Qw={toc:[]},Hw="wrapper";function Kw(t){let{components:e,...n}=t;return(0,s.kt)(Hw,(0,p.Z)({},Qw,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}Kw.isMDXComponent=!0;const $w={toc:[]},Jw="wrapper";function tT(t){let{components:e,...n}=t;return(0,s.kt)(Jw,(0,p.Z)({},$w,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}tT.isMDXComponent=!0;const eT={toc:[]},nT="wrapper";function oT(t){let{components:e,...n}=t;return(0,s.kt)(nT,(0,p.Z)({},eT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}oT.isMDXComponent=!0;const pT={toc:[]},rT="wrapper";function sT(t){let{components:e,...n}=t;return(0,s.kt)(rT,(0,p.Z)({},pT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}sT.isMDXComponent=!0;const cT={toc:[]},aT="wrapper";function iT(t){let{components:e,...n}=t;return(0,s.kt)(aT,(0,p.Z)({},cT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}iT.isMDXComponent=!0;const lT={toc:[]},uT="wrapper";function mT(t){let{components:e,...n}=t;return(0,s.kt)(uT,(0,p.Z)({},lT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}mT.isMDXComponent=!0;const dT={toc:[]},hT="wrapper";function fT(t){let{components:e,...n}=t;return(0,s.kt)(hT,(0,p.Z)({},dT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}fT.isMDXComponent=!0;const kT={toc:[]},yT="wrapper";function DT(t){let{components:e,...n}=t;return(0,s.kt)(yT,(0,p.Z)({},kT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}DT.isMDXComponent=!0;const MT={toc:[]},XT="wrapper";function _T(t){let{components:e,...n}=t;return(0,s.kt)(XT,(0,p.Z)({},MT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}_T.isMDXComponent=!0;const wT={toc:[]},TT="wrapper";function CT(t){let{components:e,...n}=t;return(0,s.kt)(TT,(0,p.Z)({},wT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}CT.isMDXComponent=!0;const xT={toc:[]},gT="wrapper";function vT(t){let{components:e,...n}=t;return(0,s.kt)(gT,(0,p.Z)({},xT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}vT.isMDXComponent=!0;const LT={toc:[]},ZT="wrapper";function bT(t){let{components:e,...n}=t;return(0,s.kt)(ZT,(0,p.Z)({},LT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}bT.isMDXComponent=!0;const NT={toc:[]},zT="wrapper";function AT(t){let{components:e,...n}=t;return(0,s.kt)(zT,(0,p.Z)({},NT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}AT.isMDXComponent=!0;const PT={toc:[]},WT="wrapper";function RT(t){let{components:e,...n}=t;return(0,s.kt)(WT,(0,p.Z)({},PT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector stored in a meta file."))}RT.isMDXComponent=!0;const IT={toc:[]},ST="wrapper";function BT(t){let{components:e,...n}=t;return(0,s.kt)(ST,(0,p.Z)({},IT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}BT.isMDXComponent=!0;const GT={toc:[]},ET="wrapper";function OT(t){let{components:e,...n}=t;return(0,s.kt)(ET,(0,p.Z)({},GT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}OT.isMDXComponent=!0;const FT={toc:[]},UT="wrapper";function VT(t){let{components:e,...n}=t;return(0,s.kt)(UT,(0,p.Z)({},FT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of this field."))}VT.isMDXComponent=!0;const qT={toc:[]},jT="wrapper";function YT(t){let{components:e,...n}=t;return(0,s.kt)(jT,(0,p.Z)({},qT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of this field displayed in the editor."))}YT.isMDXComponent=!0;const QT={toc:[]},HT="wrapper";function KT(t){let{components:e,...n}=t;return(0,s.kt)(HT,(0,p.Z)({},QT,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of this field used by the editor to display the correct input."))}KT.isMDXComponent=!0;const $T={toc:[]},JT="wrapper";function tC(t){let{components:e,...n}=t;return(0,s.kt)(JT,(0,p.Z)({},$T,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the data of this field changes."))}tC.isMDXComponent=!0;const eC={toc:[]},nC="wrapper";function oC(t){let{components:e,...n}=t;return(0,s.kt)(nC,(0,p.Z)({},eC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the field becomes disabled or enabled."))}oC.isMDXComponent=!0;const pC={toc:[]},rC="wrapper";function sC(t){let{components:e,...n}=t;return(0,s.kt)(rC,(0,p.Z)({},pC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a clone of this field."))}sC.isMDXComponent=!0;const cC={toc:[]},aC="wrapper";function iC(t){let{components:e,...n}=t;return(0,s.kt)(aC,(0,p.Z)({},cC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the description of this field."))}iC.isMDXComponent=!0;const lC={toc:[]},uC="wrapper";function mC(t){let{components:e,...n}=t;return(0,s.kt)(uC,(0,p.Z)({},lC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The description."))}mC.isMDXComponent=!0;const dC={toc:[]},hC="wrapper";function fC(t){let{components:e,...n}=t;return(0,s.kt)(hC,(0,p.Z)({},dC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Disable or enable the field in the editor."))}fC.isMDXComponent=!0;const kC={toc:[]},yC="wrapper";function DC(t){let{components:e,...n}=t;return(0,s.kt)(yC,(0,p.Z)({},kC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the field should be disabled."))}DC.isMDXComponent=!0;const MC={toc:[]},XC="wrapper";function _C(t){let{components:e,...n}=t;return(0,s.kt)(XC,(0,p.Z)({},MC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the current value."))}_C.isMDXComponent=!0;const wC={toc:[]},TC="wrapper";function CC(t){let{components:e,...n}=t;return(0,s.kt)(TC,(0,p.Z)({},wC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a serialized value into a runtime type."))}CC.isMDXComponent=!0;const xC={toc:[]},gC="wrapper";function vC(t){let{components:e,...n}=t;return(0,s.kt)(gC,(0,p.Z)({},xC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The serialized value."))}vC.isMDXComponent=!0;const LC={toc:[]},ZC="wrapper";function bC(t){let{components:e,...n}=t;return(0,s.kt)(ZC,(0,p.Z)({},LC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Serialize the value of this field."))}bC.isMDXComponent=!0;const NC={toc:[]},zC="wrapper";function AC(t){let{components:e,...n}=t;return(0,s.kt)(zC,(0,p.Z)({},NC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the current value."))}AC.isMDXComponent=!0;const PC={toc:[]},WC="wrapper";function RC(t){let{components:e,...n}=t;return(0,s.kt)(WC,(0,p.Z)({},PC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new value."))}RC.isMDXComponent=!0;const IC={toc:[]},SC="wrapper";function BC(t){let{components:e,...n}=t;return(0,s.kt)(SC,(0,p.Z)({},IC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add or remove spacing at the beginning of this field."))}BC.isMDXComponent=!0;const GC={toc:[]},EC="wrapper";function OC(t){let{components:e,...n}=t;return(0,s.kt)(EC,(0,p.Z)({},GC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to include the spacing."))}OC.isMDXComponent=!0;const FC={toc:[]},UC="wrapper";function VC(t){let{components:e,...n}=t;return(0,s.kt)(UC,(0,p.Z)({},FC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}VC.isMDXComponent=!0;const qC={toc:[]},jC="wrapper";function YC(t){let{components:e,...n}=t;return(0,s.kt)(jC,(0,p.Z)({},qC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"ObjectMetaFieldInternal"))}YC.isMDXComponent=!0;const QC={toc:[]},HC="wrapper";function KC(t){let{components:e,...n}=t;return(0,s.kt)(HC,(0,p.Z)({},QC,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a runtime Motion Canvas plugin."))}KC.isMDXComponent=!0;const $C={toc:[]},JC="wrapper";function tx(t){let{components:e,...n}=t;return(0,s.kt)(JC,(0,p.Z)({},$C,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name should be unique across the entire ecosystem of Motion Canvas.\nIf a plugin with the same name has already been registered, this plugin\nwill be ignored."),(0,s.kt)("p",null,"If you intend to publish your plugin to npm, it is recommended to prefix\nthis name with the name of your npm package."),(0,s.kt)("p",null,"Other identifiers defined by the plugin, such as a tab id, will be\nautomatically prefixed with this name and as such don't have to be unique."))}tx.isMDXComponent=!0;const ex={toc:[]},nx="wrapper";function ox(t){let{components:e,...n}=t;return(0,s.kt)(nx,(0,p.Z)({},ex,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unique name of the plugin."))}ox.isMDXComponent=!0;const px={toc:[]},rx="wrapper";function sx(t){let{components:e,...n}=t;return(0,s.kt)(rx,(0,p.Z)({},px,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide custom exporters for the project."))}sx.isMDXComponent=!0;const cx={toc:[]},ax="wrapper";function ix(t){let{components:e,...n}=t;return(0,s.kt)(ax,(0,p.Z)({},cx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}ix.isMDXComponent=!0;const lx={toc:[]},ux="wrapper";function mx(t){let{components:e,...n}=t;return(0,s.kt)(ux,(0,p.Z)({},lx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the player instance right after it is initialized."))}mx.isMDXComponent=!0;const dx={toc:[]},hx="wrapper";function fx(t){let{components:e,...n}=t;return(0,s.kt)(hx,(0,p.Z)({},dx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The player instance."))}fx.isMDXComponent=!0;const kx={toc:[]},yx="wrapper";function Dx(t){let{components:e,...n}=t;return(0,s.kt)(yx,(0,p.Z)({},kx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the presenter instance right after it is initialized."))}Dx.isMDXComponent=!0;const Mx={toc:[]},Xx="wrapper";function _x(t){let{components:e,...n}=t;return(0,s.kt)(Xx,(0,p.Z)({},Mx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The presenter instance."))}_x.isMDXComponent=!0;const wx={toc:[]},Tx="wrapper";function Cx(t){let{components:e,...n}=t;return(0,s.kt)(Tx,(0,p.Z)({},wx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the project instance right after it is initialized."))}Cx.isMDXComponent=!0;const xx={toc:[]},gx="wrapper";function vx(t){let{components:e,...n}=t;return(0,s.kt)(gx,(0,p.Z)({},xx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project instance."))}vx.isMDXComponent=!0;const Lx={toc:[]},Zx="wrapper";function bx(t){let{components:e,...n}=t;return(0,s.kt)(Zx,(0,p.Z)({},Lx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Receive the renderer instance right after it is initialized."))}bx.isMDXComponent=!0;const Nx={toc:[]},zx="wrapper";function Ax(t){let{components:e,...n}=t;return(0,s.kt)(zx,(0,p.Z)({},Nx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The renderer instance."))}Ax.isMDXComponent=!0;const Px={toc:[]},Wx="wrapper";function Rx(t){let{components:e,...n}=t;return(0,s.kt)(Wx,(0,p.Z)({},Px,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Modify the project settings before the project is initialized."))}Rx.isMDXComponent=!0;const Ix={toc:[]},Sx="wrapper";function Bx(t){let{components:e,...n}=t;return(0,s.kt)(Sx,(0,p.Z)({},Ix,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The project settings."))}Bx.isMDXComponent=!0;const Gx={toc:[]},Ex="wrapper";function Ox(t){let{components:e,...n}=t;return(0,s.kt)(Ex,(0,p.Z)({},Gx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makePlugin({\n  name: 'my-custom-plugin',\n});\n")))}Ox.isMDXComponent=!0;const Fx={toc:[]},Ux="wrapper";function Vx(t){let{components:e,...n}=t;return(0,s.kt)(Ux,(0,p.Z)({},Fx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper function for exporting Motion Canvas plugins."))}Vx.isMDXComponent=!0;const qx={toc:[]},jx="wrapper";function Yx(t){let{components:e,...n}=t;return(0,s.kt)(jx,(0,p.Z)({},qx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The plugin configuration."))}Yx.isMDXComponent=!0;const Qx={toc:[]},Hx="wrapper";function Kx(t){let{components:e,...n}=t;return(0,s.kt)(Hx,(0,p.Z)({},Qx,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Abstract scene representations and related utilities."))}Kx.isMDXComponent=!0;const $x={toc:[]},Jx="wrapper";function tg(t){let{components:e,...n}=t;return(0,s.kt)(Jx,(0,p.Z)({},$x,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Signifies the various stages of a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}tg.isMDXComponent=!0;const eg={toc:[]},ng="wrapper";function og(t){let{components:e,...n}=t;return(0,s.kt)(ng,(0,p.Z)({},eg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs after a render ends."))}og.isMDXComponent=!0;const pg={toc:[]},rg="wrapper";function sg(t){let{components:e,...n}=t;return(0,s.kt)(rg,(0,p.Z)({},pg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}sg.isMDXComponent=!0;const cg={toc:[]},ag="wrapper";function ig(t){let{components:e,...n}=t;return(0,s.kt)(ag,(0,p.Z)({},cg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,s.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}ig.isMDXComponent=!0;const lg={toc:[]},ug="wrapper";function mg(t){let{components:e,...n}=t;return(0,s.kt)(ug,(0,p.Z)({},lg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,s.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}mg.isMDXComponent=!0;const dg={toc:[]},hg="wrapper";function fg(t){let{components:e,...n}=t;return(0,s.kt)(hg,(0,p.Z)({},dg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes the state of a scene."))}fg.isMDXComponent=!0;const kg={toc:[]},yg="wrapper";function Dg(t){let{components:e,...n}=t;return(0,s.kt)(yg,(0,p.Z)({},kg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}Dg.isMDXComponent=!0;const Mg={toc:[]},Xg="wrapper";function _g(t){let{components:e,...n}=t;return(0,s.kt)(Xg,(0,p.Z)({},Mg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished transitioning in."))}_g.isMDXComponent=!0;const wg={toc:[]},Tg="wrapper";function Cg(t){let{components:e,...n}=t;return(0,s.kt)(Tg,(0,p.Z)({},wg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Cg.isMDXComponent=!0;const xg={toc:[]},gg="wrapper";function vg(t){let{components:e,...n}=t;return(0,s.kt)(gg,(0,p.Z)({},xg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene is ready to transition out."))}vg.isMDXComponent=!0;const Lg={toc:[]},Zg="wrapper";function bg(t){let{components:e,...n}=t;return(0,s.kt)(Zg,(0,p.Z)({},Lg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoking ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,s.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}bg.isMDXComponent=!0;const Ng={toc:[]},zg="wrapper";function Ag(t){let{components:e,...n}=t;return(0,s.kt)(zg,(0,p.Z)({},Ng,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has finished."))}Ag.isMDXComponent=!0;const Pg={toc:[]},Wg="wrapper";function Rg(t){let{components:e,...n}=t;return(0,s.kt)(Wg,(0,p.Z)({},Pg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene has just been created/reset."))}Rg.isMDXComponent=!0;const Ig={toc:[]},Sg="wrapper";function Bg(t){let{components:e,...n}=t;return(0,s.kt)(Sg,(0,p.Z)({},Ig,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The default implementation of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,s.kt)("p",null,"Uses generators to control the animation."))}Bg.isMDXComponent=!0;const Gg={toc:[]},Eg="wrapper";function Og(t){let{components:e,...n}=t;return(0,s.kt)(Eg,(0,p.Z)({},Gg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}Og.isMDXComponent=!0;const Fg={toc:[]},Ug="wrapper";function Vg(t){let{components:e,...n}=t;return(0,s.kt)(Ug,(0,p.Z)({},Fg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}Vg.isMDXComponent=!0;const qg={toc:[]},jg="wrapper";function Yg(t){let{components:e,...n}=t;return(0,s.kt)(jg,(0,p.Z)({},qg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}Yg.isMDXComponent=!0;const Qg={toc:[]},Hg="wrapper";function Kg(t){let{components:e,...n}=t;return(0,s.kt)(Hg,(0,p.Z)({},Qg,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Should this scene be rendered below the previous scene during a transition?"))}Kg.isMDXComponent=!0;const $g={toc:[]},Jg="wrapper";function tv(t){let{components:e,...n}=t;return(0,s.kt)(Jg,(0,p.Z)({},$g,n,{components:e,mdxType:"MDXLayout"}))}tv.isMDXComponent=!0;const ev={toc:[]},nv="wrapper";function ov(t){let{components:e,...n}=t;return(0,s.kt)(nv,(0,p.Z)({},ev,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}ov.isMDXComponent=!0;const pv={toc:[]},rv="wrapper";function sv(t){let{components:e,...n}=t;return(0,s.kt)(rv,(0,p.Z)({},pv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}sv.isMDXComponent=!0;const cv={toc:[]},av="wrapper";function iv(t){let{components:e,...n}=t;return(0,s.kt)(av,(0,p.Z)({},cv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}iv.isMDXComponent=!0;const lv={toc:[]},uv="wrapper";function mv(t){let{components:e,...n}=t;return(0,s.kt)(uv,(0,p.Z)({},lv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}mv.isMDXComponent=!0;const dv={toc:[]},hv="wrapper";function fv(t){let{components:e,...n}=t;return(0,s.kt)(hv,(0,p.Z)({},dv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}fv.isMDXComponent=!0;const kv={toc:[]},yv="wrapper";function Dv(t){let{components:e,...n}=t;return(0,s.kt)(yv,(0,p.Z)({},kv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}Dv.isMDXComponent=!0;const Mv={toc:[]},Xv="wrapper";function _v(t){let{components:e,...n}=t;return(0,s.kt)(Xv,(0,p.Z)({},Mv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}_v.isMDXComponent=!0;const wv={toc:[]},Tv="wrapper";function Cv(t){let{components:e,...n}=t;return(0,s.kt)(Tv,(0,p.Z)({},wv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Cv.isMDXComponent=!0;const xv={toc:[]},gv="wrapper";function vv(t){let{components:e,...n}=t;return(0,s.kt)(gv,(0,p.Z)({},xv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}vv.isMDXComponent=!0;const Lv={toc:[]},Zv="wrapper";function bv(t){let{components:e,...n}=t;return(0,s.kt)(Zv,(0,p.Z)({},Lv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}bv.isMDXComponent=!0;const Nv={toc:[]},zv="wrapper";function Av(t){let{components:e,...n}=t;return(0,s.kt)(zv,(0,p.Z)({},Nv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Av.isMDXComponent=!0;const Pv={toc:[]},Wv="wrapper";function Rv(t){let{components:e,...n}=t;return(0,s.kt)(Wv,(0,p.Z)({},Pv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Rv.isMDXComponent=!0;const Iv={toc:[]},Sv="wrapper";function Bv(t){let{components:e,...n}=t;return(0,s.kt)(Sv,(0,p.Z)({},Iv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Bv.isMDXComponent=!0;const Gv={toc:[]},Ev="wrapper";function Ov(t){let{components:e,...n}=t;return(0,s.kt)(Ev,(0,p.Z)({},Gv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}Ov.isMDXComponent=!0;const Fv={toc:[]},Uv="wrapper";function Vv(t){let{components:e,...n}=t;return(0,s.kt)(Uv,(0,p.Z)({},Fv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}Vv.isMDXComponent=!0;const qv={toc:[]},jv="wrapper";function Yv(t){let{components:e,...n}=t;return(0,s.kt)(jv,(0,p.Z)({},qv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}Yv.isMDXComponent=!0;const Qv={toc:[]},Hv="wrapper";function Kv(t){let{components:e,...n}=t;return(0,s.kt)(Hv,(0,p.Z)({},Qv,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}Kv.isMDXComponent=!0;const $v={toc:[]},Jv="wrapper";function tL(t){let{components:e,...n}=t;return(0,s.kt)(Jv,(0,p.Z)({},$v,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}tL.isMDXComponent=!0;const eL={toc:[]},nL="wrapper";function oL(t){let{components:e,...n}=t;return(0,s.kt)(nL,(0,p.Z)({},eL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the size of the scene multiplied by the resolution scale.\nThis is the actual size of the canvas onto which the scene is rendered."))}oL.isMDXComponent=!0;const pL={toc:[]},rL="wrapper";function sL(t){let{components:e,...n}=t;return(0,s.kt)(rL,(0,p.Z)({},pL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real size of this scene."))}sL.isMDXComponent=!0;const cL={toc:[]},aL="wrapper";function iL(t){let{components:e,...n}=t;return(0,s.kt)(aL,(0,p.Z)({},cL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually returns ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}iL.isMDXComponent=!0;const lL={toc:[]},uL="wrapper";function mL(t){let{components:e,...n}=t;return(0,s.kt)(uL,(0,p.Z)({},lL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."))}mL.isMDXComponent=!0;const dL={toc:[]},hL="wrapper";function fL(t){let{components:e,...n}=t;return(0,s.kt)(hL,(0,p.Z)({},dL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}fL.isMDXComponent=!0;const kL={toc:[]},yL="wrapper";function DL(t){let{components:e,...n}=t;return(0,s.kt)(yL,(0,p.Z)({},kL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}DL.isMDXComponent=!0;const ML={toc:[]},XL="wrapper";function _L(t){let{components:e,...n}=t;return(0,s.kt)(XL,(0,p.Z)({},ML,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"))}_L.isMDXComponent=!0;const wL={toc:[]},TL="wrapper";function CL(t){let{components:e,...n}=t;return(0,s.kt)(TL,(0,p.Z)({},wL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}CL.isMDXComponent=!0;const xL={toc:[]},gL="wrapper";function vL(t){let{components:e,...n}=t;return(0,s.kt)(gL,(0,p.Z)({},xL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}vL.isMDXComponent=!0;const LL={toc:[]},ZL="wrapper";function bL(t){let{components:e,...n}=t;return(0,s.kt)(ZL,(0,p.Z)({},LL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}bL.isMDXComponent=!0;const NL={toc:[]},zL="wrapper";function AL(t){let{components:e,...n}=t;return(0,s.kt)(zL,(0,p.Z)({},NL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}AL.isMDXComponent=!0;const PL={toc:[]},WL="wrapper";function RL(t){let{components:e,...n}=t;return(0,s.kt)(WL,(0,p.Z)({},PL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}RL.isMDXComponent=!0;const IL={toc:[]},SL="wrapper";function BL(t){let{components:e,...n}=t;return(0,s.kt)(SL,(0,p.Z)({},IL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}BL.isMDXComponent=!0;const GL={toc:[]},EL="wrapper";function OL(t){let{components:e,...n}=t;return(0,s.kt)(EL,(0,p.Z)({},GL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}OL.isMDXComponent=!0;const FL={toc:[]},UL="wrapper";function VL(t){let{components:e,...n}=t;return(0,s.kt)(UL,(0,p.Z)({},FL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}VL.isMDXComponent=!0;const qL={toc:[]},jL="wrapper";function YL(t){let{components:e,...n}=t;return(0,s.kt)(jL,(0,p.Z)({},qL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}YL.isMDXComponent=!0;const QL={toc:[]},HL="wrapper";function KL(t){let{components:e,...n}=t;return(0,s.kt)(HL,(0,p.Z)({},QL,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}KL.isMDXComponent=!0;const $L={toc:[]},JL="wrapper";function tZ(t){let{components:e,...n}=t;return(0,s.kt)(JL,(0,p.Z)({},$L,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}tZ.isMDXComponent=!0;const eZ={toc:[]},nZ="wrapper";function oZ(t){let{components:e,...n}=t;return(0,s.kt)(nZ,(0,p.Z)({},eZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}oZ.isMDXComponent=!0;const pZ={toc:[]},rZ="wrapper";function sZ(t){let{components:e,...n}=t;return(0,s.kt)(rZ,(0,p.Z)({},pZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Lifecycle events for ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}sZ.isMDXComponent=!0;const cZ={toc:[]},aZ="wrapper";function iZ(t){let{components:e,...n}=t;return(0,s.kt)(aZ,(0,p.Z)({},cZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A random number generator based on\n",(0,s.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,s.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}iZ.isMDXComponent=!0;const lZ={toc:[]},uZ="wrapper";function mZ(t){let{components:e,...n}=t;return(0,s.kt)(uZ,(0,p.Z)({},lZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random floats in the given range."))}mZ.isMDXComponent=!0;const dZ={toc:[]},hZ="wrapper";function fZ(t){let{components:e,...n}=t;return(0,s.kt)(hZ,(0,p.Z)({},dZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."))}fZ.isMDXComponent=!0;const kZ={toc:[]},yZ="wrapper";function DZ(t){let{components:e,...n}=t;return(0,s.kt)(yZ,(0,p.Z)({},kZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}DZ.isMDXComponent=!0;const MZ={toc:[]},XZ="wrapper";function _Z(t){let{components:e,...n}=t;return(0,s.kt)(XZ,(0,p.Z)({},MZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}_Z.isMDXComponent=!0;const wZ={toc:[]},TZ="wrapper";function CZ(t){let{components:e,...n}=t;return(0,s.kt)(TZ,(0,p.Z)({},wZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a random float from a gaussian distribution."))}CZ.isMDXComponent=!0;const xZ={toc:[]},gZ="wrapper";function vZ(t){let{components:e,...n}=t;return(0,s.kt)(gZ,(0,p.Z)({},xZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The mean of the distribution."))}vZ.isMDXComponent=!0;const LZ={toc:[]},ZZ="wrapper";function bZ(t){let{components:e,...n}=t;return(0,s.kt)(ZZ,(0,p.Z)({},LZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The standard deviation of the distribution."))}bZ.isMDXComponent=!0;const NZ={toc:[]},zZ="wrapper";function AZ(t){let{components:e,...n}=t;return(0,s.kt)(zZ,(0,p.Z)({},NZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get an array filled with random integers in the given range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"}),(0,s.kt)("li",{parentName:"ul"})))}AZ.isMDXComponent=!0;const PZ={toc:[]},WZ="wrapper";function RZ(t){let{components:e,...n}=t;return(0,s.kt)(WZ,(0,p.Z)({},PZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The size of the array."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}RZ.isMDXComponent=!0;const IZ={toc:[]},SZ="wrapper";function BZ(t){let{components:e,...n}=t;return(0,s.kt)(SZ,(0,p.Z)({},IZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}BZ.isMDXComponent=!0;const GZ={toc:[]},EZ="wrapper";function OZ(t){let{components:e,...n}=t;return(0,s.kt)(EZ,(0,p.Z)({},GZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}OZ.isMDXComponent=!0;const FZ={toc:[]},UZ="wrapper";function VZ(t){let{components:e,...n}=t;return(0,s.kt)(UZ,(0,p.Z)({},FZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random float in the given range."))}VZ.isMDXComponent=!0;const qZ={toc:[]},jZ="wrapper";function YZ(t){let{components:e,...n}=t;return(0,s.kt)(jZ,(0,p.Z)({},qZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}YZ.isMDXComponent=!0;const QZ={toc:[]},HZ="wrapper";function KZ(t){let{components:e,...n}=t;return(0,s.kt)(HZ,(0,p.Z)({},QZ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range."))}KZ.isMDXComponent=!0;const $Z={toc:[]},JZ="wrapper";function tb(t){let{components:e,...n}=t;return(0,s.kt)(JZ,(0,p.Z)({},$Z,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the next random integer in the given range."))}tb.isMDXComponent=!0;const eb={toc:[]},nb="wrapper";function ob(t){let{components:e,...n}=t;return(0,s.kt)(nb,(0,p.Z)({},eb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}ob.isMDXComponent=!0;const pb={toc:[]},rb="wrapper";function sb(t){let{components:e,...n}=t;return(0,s.kt)(rb,(0,p.Z)({},pb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. Exclusive."))}sb.isMDXComponent=!0;const cb={toc:[]},ab="wrapper";function ib(t){let{components:e,...n}=t;return(0,s.kt)(ab,(0,p.Z)({},cb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a new independent generator."))}ib.isMDXComponent=!0;const lb={toc:[]},ub="wrapper";function mb(t){let{components:e,...n}=t;return(0,s.kt)(ub,(0,p.Z)({},lb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}mb.isMDXComponent=!0;const db={toc:[]},hb="wrapper";function fb(t){let{components:e,...n}=t;return(0,s.kt)(hb,(0,p.Z)({},db,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the variable."))}fb.isMDXComponent=!0;const kb={toc:[]},yb="wrapper";function Db(t){let{components:e,...n}=t;return(0,s.kt)(yb,(0,p.Z)({},kb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the variable. It will be used if the\nvariable was not configured from the outside."))}Db.isMDXComponent=!0;const Mb={toc:[]},Xb="wrapper";function _b(t){let{components:e,...n}=t;return(0,s.kt)(Xb,(0,p.Z)({},Mb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get variable signal if exists or create signal if not"))}_b.isMDXComponent=!0;const wb={toc:[]},Tb="wrapper";function Cb(t){let{components:e,...n}=t;return(0,s.kt)(Tb,(0,p.Z)({},wb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset all stored signals."))}Cb.isMDXComponent=!0;const xb={toc:[]},gb="wrapper";function vb(t){let{components:e,...n}=t;return(0,s.kt)(gb,(0,p.Z)({},xb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update all signals with new project variable values."))}vb.isMDXComponent=!0;const Lb={toc:[]},Zb="wrapper";function bb(t){let{components:e,...n}=t;return(0,s.kt)(Zb,(0,p.Z)({},Lb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes cached information about the timing of a scene."))}bb.isMDXComponent=!0;const Nb={toc:[]},zb="wrapper";function Ab(t){let{components:e,...n}=t;return(0,s.kt)(zb,(0,p.Z)({},Nb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a complete scene together with the meta file."))}Ab.isMDXComponent=!0;const Pb={toc:[]},Wb="wrapper";function Rb(t){let{components:e,...n}=t;return(0,s.kt)(Wb,(0,p.Z)({},Pb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}Rb.isMDXComponent=!0;const Ib={toc:[]},Sb="wrapper";function Bb(t){let{components:e,...n}=t;return(0,s.kt)(Sb,(0,p.Z)({},Ib,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}Bb.isMDXComponent=!0;const Gb={toc:[]},Eb="wrapper";function Ob(t){let{components:e,...n}=t;return(0,s.kt)(Eb,(0,p.Z)({},Gb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of plugins to include in the project."))}Ob.isMDXComponent=!0;const Fb={toc:[]},Ub="wrapper";function Vb(t){let{components:e,...n}=t;return(0,s.kt)(Ub,(0,p.Z)({},Fb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}Vb.isMDXComponent=!0;const qb={toc:[]},jb="wrapper";function Yb(t){let{components:e,...n}=t;return(0,s.kt)(jb,(0,p.Z)({},qb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}Yb.isMDXComponent=!0;const Qb={toc:[]},Hb="wrapper";function Kb(t){let{components:e,...n}=t;return(0,s.kt)(Hb,(0,p.Z)({},Qb,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Kb.isMDXComponent=!0;const $b={toc:[]},Jb="wrapper";function tN(t){let{components:e,...n}=t;return(0,s.kt)(Jb,(0,p.Z)({},$b,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}tN.isMDXComponent=!0;const eN={toc:[]},nN="wrapper";function oN(t){let{components:e,...n}=t;return(0,s.kt)(nN,(0,p.Z)({},eN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for the inspected element."))}oN.isMDXComponent=!0;const pN={toc:[]},rN="wrapper";function sN(t){let{components:e,...n}=t;return(0,s.kt)(rN,(0,p.Z)({},pN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element for which to draw an overlay."))}sN.isMDXComponent=!0;const cN={toc:[]},aN="wrapper";function iN(t){let{components:e,...n}=t;return(0,s.kt)(aN,(0,p.Z)({},cN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}iN.isMDXComponent=!0;const lN={toc:[]},uN="wrapper";function mN(t){let{components:e,...n}=t;return(0,s.kt)(uN,(0,p.Z)({},lN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}mN.isMDXComponent=!0;const dN={toc:[]},hN="wrapper";function fN(t){let{components:e,...n}=t;return(0,s.kt)(hN,(0,p.Z)({},dN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}fN.isMDXComponent=!0;const kN={toc:[]},yN="wrapper";function DN(t){let{components:e,...n}=t;return(0,s.kt)(yN,(0,p.Z)({},kN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the attributes of the inspected element."))}DN.isMDXComponent=!0;const MN={toc:[]},XN="wrapper";function _N(t){let{components:e,...n}=t;return(0,s.kt)(XN,(0,p.Z)({},MN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to inspect."))}_N.isMDXComponent=!0;const wN={toc:[]},TN="wrapper";function CN(t){let{components:e,...n}=t;return(0,s.kt)(TN,(0,p.Z)({},wN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a possible element to inspect at a given position."))}CN.isMDXComponent=!0;const xN={toc:[]},gN="wrapper";function vN(t){let{components:e,...n}=t;return(0,s.kt)(gN,(0,p.Z)({},xN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}vN.isMDXComponent=!0;const LN={toc:[]},ZN="wrapper";function bN(t){let{components:e,...n}=t;return(0,s.kt)(ZN,(0,p.Z)({},LN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}bN.isMDXComponent=!0;const NN={toc:[]},zN="wrapper";function AN(t){let{components:e,...n}=t;return(0,s.kt)(zN,(0,p.Z)({},NN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transform the absolute mouse coordinates into the scene's coordinate system."))}AN.isMDXComponent=!0;const PN={toc:[]},WN="wrapper";function RN(t){let{components:e,...n}=t;return(0,s.kt)(WN,(0,p.Z)({},PN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x coordinate."))}RN.isMDXComponent=!0;const IN={toc:[]},SN="wrapper";function BN(t){let{components:e,...n}=t;return(0,s.kt)(SN,(0,p.Z)({},IN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y coordinate."))}BN.isMDXComponent=!0;const GN={toc:[]},EN="wrapper";function ON(t){let{components:e,...n}=t;return(0,s.kt)(EN,(0,p.Z)({},GN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}ON.isMDXComponent=!0;const FN={toc:[]},UN="wrapper";function VN(t){let{components:e,...n}=t;return(0,s.kt)(UN,(0,p.Z)({},FN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the inspected element is still valid."))}VN.isMDXComponent=!0;const qN={toc:[]},jN="wrapper";function YN(t){let{components:e,...n}=t;return(0,s.kt)(jN,(0,p.Z)({},qN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The element to validate."))}YN.isMDXComponent=!0;const QN={toc:[]},HN="wrapper";function KN(t){let{components:e,...n}=t;return(0,s.kt)(HN,(0,p.Z)({},QN,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}KN.isMDXComponent=!0;const $N={toc:[]},JN="wrapper";function tz(t){let{components:e,...n}=t;return(0,s.kt)(JN,(0,p.Z)({},$N,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main interface for scenes."))}tz.isMDXComponent=!0;const ez={toc:[]},nz="wrapper";function oz(t){let{components:e,...n}=t;return(0,s.kt)(nz,(0,p.Z)({},ez,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Will be passed as the second argument to the constructor."))}oz.isMDXComponent=!0;const pz={toc:[]},rz="wrapper";function sz(t){let{components:e,...n}=t;return(0,s.kt)(rz,(0,p.Z)({},pz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Name of the scene."))}sz.isMDXComponent=!0;const cz={toc:[]},az="wrapper";function iz(t){let{components:e,...n}=t;return(0,s.kt)(az,(0,p.Z)({},cz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reference to the project."))}iz.isMDXComponent=!0;const lz={toc:[]},uz="wrapper";function mz(t){let{components:e,...n}=t;return(0,s.kt)(uz,(0,p.Z)({},lz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Should this scene be rendered below the previous scene during a transition?"))}mz.isMDXComponent=!0;const dz={toc:[]},hz="wrapper";function fz(t){let{components:e,...n}=t;return(0,s.kt)(hz,(0,p.Z)({},dz,n,{components:e,mdxType:"MDXLayout"}))}fz.isMDXComponent=!0;const kz={toc:[]},yz="wrapper";function Dz(t){let{components:e,...n}=t;return(0,s.kt)(yz,(0,p.Z)({},kz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"lifecycleEvents"))," instead."))}Dz.isMDXComponent=!0;const Mz={toc:[]},Xz="wrapper";function _z(t){let{components:e,...n}=t;return(0,s.kt)(Xz,(0,p.Z)({},Mz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}_z.isMDXComponent=!0;const wz={toc:[]},Tz="wrapper";function Cz(t){let{components:e,...n}=t;return(0,s.kt)(Tz,(0,p.Z)({},wz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether experimental features are enabled."))}Cz.isMDXComponent=!0;const xz={toc:[]},gz="wrapper";function vz(t){let{components:e,...n}=t;return(0,s.kt)(gz,(0,p.Z)({},xz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene starts."))}vz.isMDXComponent=!0;const Lz={toc:[]},Zz="wrapper";function bz(t){let{components:e,...n}=t;return(0,s.kt)(Zz,(0,p.Z)({},Lz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The frame at which this scene ends."))}bz.isMDXComponent=!0;const Nz={toc:[]},zz="wrapper";function Az(t){let{components:e,...n}=t;return(0,s.kt)(zz,(0,p.Z)({},Nz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,s.kt)("inlineCode",{parentName:"a"},"LifecycleEvents"))," of this scene."))}Az.isMDXComponent=!0;const Pz={toc:[]},Wz="wrapper";function Rz(t){let{components:e,...n}=t;return(0,s.kt)(Wz,(0,p.Z)({},Pz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the cached data changes."))}Rz.isMDXComponent=!0;const Iz={toc:[]},Sz="wrapper";function Bz(t){let{components:e,...n}=t;return(0,s.kt)(Sz,(0,p.Z)({},Iz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered after scene is recalculated."))}Bz.isMDXComponent=!0;const Gz={toc:[]},Ez="wrapper";function Oz(t){let{components:e,...n}=t;return(0,s.kt)(Ez,(0,p.Z)({},Gz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reloaded."))}Oz.isMDXComponent=!0;const Fz={toc:[]},Uz="wrapper";function Vz(t){let{components:e,...n}=t;return(0,s.kt)(Uz,(0,p.Z)({},Fz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Vz.isMDXComponent=!0;const qz={toc:[]},jz="wrapper";function Yz(t){let{components:e,...n}=t;return(0,s.kt)(jz,(0,p.Z)({},qz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the scene is reset."))}Yz.isMDXComponent=!0;const Qz={toc:[]},Hz="wrapper";function Kz(t){let{components:e,...n}=t;return(0,s.kt)(Hz,(0,p.Z)({},Qz,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Kz.isMDXComponent=!0;const $z={toc:[]},Jz="wrapper";function tA(t){let{components:e,...n}=t;return(0,s.kt)(Jz,(0,p.Z)({},$z,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}tA.isMDXComponent=!0;const eA={toc:[]},nA="wrapper";function oA(t){let{components:e,...n}=t;return(0,s.kt)(nA,(0,p.Z)({},eA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}oA.isMDXComponent=!0;const pA={toc:[]},rA="wrapper";function sA(t){let{components:e,...n}=t;return(0,s.kt)(rA,(0,p.Z)({},pA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,s.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}sA.isMDXComponent=!0;const cA={toc:[]},aA="wrapper";function iA(t){let{components:e,...n}=t;return(0,s.kt)(aA,(0,p.Z)({},cA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enter the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Initial"},(0,s.kt)("inlineCode",{parentName:"a"},"Initial"))," state."))}iA.isMDXComponent=!0;const lA={toc:[]},uA="wrapper";function mA(t){let{components:e,...n}=t;return(0,s.kt)(uA,(0,p.Z)({},lA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the size of the scene multiplied by the resolution scale.\nThis is the actual size of the canvas onto which the scene is rendered."))}mA.isMDXComponent=!0;const dA={toc:[]},hA="wrapper";function fA(t){let{components:e,...n}=t;return(0,s.kt)(hA,(0,p.Z)({},dA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real size of this scene."))}fA.isMDXComponent=!0;const kA={toc:[]},yA="wrapper";function DA(t){let{components:e,...n}=t;return(0,s.kt)(yA,(0,p.Z)({},kA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually returns ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}DA.isMDXComponent=!0;const MA={toc:[]},XA="wrapper";function _A(t){let{components:e,...n}=t;return(0,s.kt)(XA,(0,p.Z)({},MA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the size of this scene."))}_A.isMDXComponent=!0;const wA={toc:[]},TA="wrapper";function CA(t){let{components:e,...n}=t;return(0,s.kt)(TA,(0,p.Z)({},wA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,s.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}CA.isMDXComponent=!0;const xA={toc:[]},gA="wrapper";function vA(t){let{components:e,...n}=t;return(0,s.kt)(gA,(0,p.Z)({},xA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used only by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,s.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,s.kt)("p",null,"Should always return ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."))}vA.isMDXComponent=!0;const LA={toc:[]},ZA="wrapper";function bA(t){let{components:e,...n}=t;return(0,s.kt)(ZA,(0,p.Z)({},LA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene cached?"))}bA.isMDXComponent=!0;const NA={toc:[]},zA="wrapper";function AA(t){let{components:e,...n}=t;return(0,s.kt)(zA,(0,p.Z)({},NA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is this scene in the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,s.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}AA.isMDXComponent=!0;const PA={toc:[]},WA="wrapper";function RA(t){let{components:e,...n}=t;return(0,s.kt)(WA,(0,p.Z)({},PA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress this scene one frame forward."))}RA.isMDXComponent=!0;const IA={toc:[]},SA="wrapper";function BA(t){let{components:e,...n}=t;return(0,s.kt)(SA,(0,p.Z)({},IA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,s.kt)("p",null,"At the end of execution, this method should set ",(0,s.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,s.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,s.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}BA.isMDXComponent=!0;const GA={toc:[]},EA="wrapper";function OA(t){let{components:e,...n}=t;return(0,s.kt)(EA,(0,p.Z)({},GA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Recalculate the scene."))}OA.isMDXComponent=!0;const FA={toc:[]},UA="wrapper";function VA(t){let{components:e,...n}=t;return(0,s.kt)(UA,(0,p.Z)({},FA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,s.kt)("p",null,"Should trigger ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,s.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}VA.isMDXComponent=!0;const qA={toc:[]},jA="wrapper";function YA(t){let{components:e,...n}=t;return(0,s.kt)(jA,(0,p.Z)({},qA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reload the scene."))}YA.isMDXComponent=!0;const QA={toc:[]},HA="wrapper";function KA(t){let{components:e,...n}=t;return(0,s.kt)(HA,(0,p.Z)({},QA,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, an updated version of the description."))}KA.isMDXComponent=!0;const $A={toc:[]},JA="wrapper";function tP(t){let{components:e,...n}=t;return(0,s.kt)(JA,(0,p.Z)({},$A,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render the scene onto a canvas."))}tP.isMDXComponent=!0;const eP={toc:[]},nP="wrapper";function oP(t){let{components:e,...n}=t;return(0,s.kt)(nP,(0,p.Z)({},eP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to used when rendering."))}oP.isMDXComponent=!0;const pP={toc:[]},rP="wrapper";function sP(t){let{components:e,...n}=t;return(0,s.kt)(rP,(0,p.Z)({},pP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset this scene to its initial state."))}sP.isMDXComponent=!0;const cP={toc:[]},aP="wrapper";function iP(t){let{components:e,...n}=t;return(0,s.kt)(aP,(0,p.Z)({},cP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If present, the previous scene."))}iP.isMDXComponent=!0;const lP={toc:[]},uP="wrapper";function mP(t){let{components:e,...n}=t;return(0,s.kt)(uP,(0,p.Z)({},lP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}mP.isMDXComponent=!0;const dP={toc:[]},hP="wrapper";function fP(t){let{components:e,...n}=t;return(0,s.kt)(hP,(0,p.Z)({},dP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Each class implementing the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,s.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}fP.isMDXComponent=!0;const kP={toc:[]},yP="wrapper";function DP(t){let{components:e,...n}=t;return(0,s.kt)(yP,(0,p.Z)({},kP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constructor used when creating new scenes."))}DP.isMDXComponent=!0;const MP={toc:[]},XP="wrapper";function _P(t){let{components:e,...n}=t;return(0,s.kt)(XP,(0,p.Z)({},MP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,s.kt)("inlineCode",{parentName:"a"},"config")),"."))}_P.isMDXComponent=!0;const wP={toc:[]},TP="wrapper";function CP(t){let{components:e,...n}=t;return(0,s.kt)(TP,(0,p.Z)({},wP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Describes a scene exposed by scene files."))}CP.isMDXComponent=!0;const xP={toc:[]},gP="wrapper";function vP(t){let{components:e,...n}=t;return(0,s.kt)(gP,(0,p.Z)({},xP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Configuration object."))}vP.isMDXComponent=!0;const LP={toc:[]},ZP="wrapper";function bP(t){let{components:e,...n}=t;return(0,s.kt)(ZP,(0,p.Z)({},LP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class used to instantiate the scene."))}bP.isMDXComponent=!0;const NP={toc:[]},zP="wrapper";function AP(t){let{components:e,...n}=t;return(0,s.kt)(zP,(0,p.Z)({},NP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of plugins to include in the project."))}AP.isMDXComponent=!0;const PP={toc:[]},WP="wrapper";function RP(t){let{components:e,...n}=t;return(0,s.kt)(WP,(0,p.Z)({},PP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The stack trace at the moment of creation."))}RP.isMDXComponent=!0;const IP={toc:[]},SP="wrapper";function BP(t){let{components:e,...n}=t;return(0,s.kt)(SP,(0,p.Z)({},IP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}BP.isMDXComponent=!0;const GP={toc:[]},EP="wrapper";function OP(t){let{components:e,...n}=t;return(0,s.kt)(EP,(0,p.Z)({},GP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A part of the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription"},(0,s.kt)("inlineCode",{parentName:"a"},"SceneDescription"))," that can be updated during reload."))}OP.isMDXComponent=!0;const FP={toc:[]},UP="wrapper";function VP(t){let{components:e,...n}=t;return(0,s.kt)(UP,(0,p.Z)({},FP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type of the configuration object."))}VP.isMDXComponent=!0;const qP={toc:[]},jP="wrapper";function YP(t){let{components:e,...n}=t;return(0,s.kt)(jP,(0,p.Z)({},qP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}YP.isMDXComponent=!0;const QP={toc:[]},HP="wrapper";function KP(t){let{components:e,...n}=t;return(0,s.kt)(HP,(0,p.Z)({},QP,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}KP.isMDXComponent=!0;const $P={toc:[]},JP="wrapper";function tW(t){let{components:e,...n}=t;return(0,s.kt)(JP,(0,p.Z)({},$P,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Triggered when the main thread changes."))}tW.isMDXComponent=!0;const eW={toc:[]},nW="wrapper";function oW(t){let{components:e,...n}=t;return(0,s.kt)(nW,(0,p.Z)({},eW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents attributes of an inspected element."))}oW.isMDXComponent=!0;const pW={toc:[]},rW="wrapper";function sW(t){let{components:e,...n}=t;return(0,s.kt)(rW,(0,p.Z)({},pW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}sW.isMDXComponent=!0;const cW={toc:[]},aW="wrapper";function iW(t){let{components:e,...n}=t;return(0,s.kt)(aW,(0,p.Z)({},cW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents an element to inspect."))}iW.isMDXComponent=!0;const lW={toc:[]},uW="wrapper";function mW(t){let{components:e,...n}=t;return(0,s.kt)(uW,(0,p.Z)({},lW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A runtime representation of the scene metadata."))}mW.isMDXComponent=!0;const dW={toc:[]},hW="wrapper";function fW(t){let{components:e,...n}=t;return(0,s.kt)(hW,(0,p.Z)({},dW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a runtime representation of the scene metadata."))}fW.isMDXComponent=!0;const kW={toc:[]},yW="wrapper";function DW(t){let{components:e,...n}=t;return(0,s.kt)(yW,(0,p.Z)({},kW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}DW.isMDXComponent=!0;const MW={toc:[]},XW="wrapper";function _W(t){let{components:e,...n}=t;return(0,s.kt)(XW,(0,p.Z)({},MW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the initial value of this signal."))}_W.isMDXComponent=!0;const wW={toc:[]},TW="wrapper";function CW(t){let{components:e,...n}=t;return(0,s.kt)(TW,(0,p.Z)({},wW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}CW.isMDXComponent=!0;const xW={toc:[]},gW="wrapper";function vW(t){let{components:e,...n}=t;return(0,s.kt)(gW,(0,p.Z)({},xW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}vW.isMDXComponent=!0;const LW={toc:[]},ZW="wrapper";function bW(t){let{components:e,...n}=t;return(0,s.kt)(ZW,(0,p.Z)({},LW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is the signal undergoing a tween?"))}bW.isMDXComponent=!0;const NW={toc:[]},zW="wrapper";function AW(t){let{components:e,...n}=t;return(0,s.kt)(zW,(0,p.Z)({},NW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}AW.isMDXComponent=!0;const PW={toc:[]},WW="wrapper";function RW(t){let{components:e,...n}=t;return(0,s.kt)(WW,(0,p.Z)({},PW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}RW.isMDXComponent=!0;const IW={toc:[]},SW="wrapper";function BW(t){let{components:e,...n}=t;return(0,s.kt)(SW,(0,p.Z)({},IW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}BW.isMDXComponent=!0;const GW={toc:[]},EW="wrapper";function OW(t){let{components:e,...n}=t;return(0,s.kt)(EW,(0,p.Z)({},GW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}OW.isMDXComponent=!0;const FW={toc:[]},UW="wrapper";function VW(t){let{components:e,...n}=t;return(0,s.kt)(UW,(0,p.Z)({},FW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}VW.isMDXComponent=!0;const qW={toc:[]},jW="wrapper";function YW(t){let{components:e,...n}=t;return(0,s.kt)(jW,(0,p.Z)({},qW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}YW.isMDXComponent=!0;const QW={toc:[]},HW="wrapper";function KW(t){let{components:e,...n}=t;return(0,s.kt)(HW,(0,p.Z)({},QW,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}KW.isMDXComponent=!0;const $W={toc:[]},JW="wrapper";function tR(t){let{components:e,...n}=t;return(0,s.kt)(JW,(0,p.Z)({},$W,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}tR.isMDXComponent=!0;const eR={toc:[]},nR="wrapper";function oR(t){let{components:e,...n}=t;return(0,s.kt)(nR,(0,p.Z)({},eR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the initial value of this signal."))}oR.isMDXComponent=!0;const pR={toc:[]},rR="wrapper";function sR(t){let{components:e,...n}=t;return(0,s.kt)(rR,(0,p.Z)({},pR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}sR.isMDXComponent=!0;const cR={toc:[]},aR="wrapper";function iR(t){let{components:e,...n}=t;return(0,s.kt)(aR,(0,p.Z)({},cR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}iR.isMDXComponent=!0;const lR={toc:[]},uR="wrapper";function mR(t){let{components:e,...n}=t;return(0,s.kt)(uR,(0,p.Z)({},lR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is the signal undergoing a tween?"))}mR.isMDXComponent=!0;const dR={toc:[]},hR="wrapper";function fR(t){let{components:e,...n}=t;return(0,s.kt)(hR,(0,p.Z)({},dR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}fR.isMDXComponent=!0;const kR={toc:[]},yR="wrapper";function DR(t){let{components:e,...n}=t;return(0,s.kt)(yR,(0,p.Z)({},kR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}DR.isMDXComponent=!0;const MR={toc:[]},XR="wrapper";function _R(t){let{components:e,...n}=t;return(0,s.kt)(XR,(0,p.Z)({},MR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}_R.isMDXComponent=!0;const wR={toc:[]},TR="wrapper";function CR(t){let{components:e,...n}=t;return(0,s.kt)(TR,(0,p.Z)({},wR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}CR.isMDXComponent=!0;const xR={toc:[]},gR="wrapper";function vR(t){let{components:e,...n}=t;return(0,s.kt)(gR,(0,p.Z)({},xR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}vR.isMDXComponent=!0;const LR={toc:[]},ZR="wrapper";function bR(t){let{components:e,...n}=t;return(0,s.kt)(ZR,(0,p.Z)({},LR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}bR.isMDXComponent=!0;const NR={toc:[]},zR="wrapper";function AR(t){let{components:e,...n}=t;return(0,s.kt)(zR,(0,p.Z)({},NR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}AR.isMDXComponent=!0;const PR={toc:[]},WR="wrapper";function RR(t){let{components:e,...n}=t;return(0,s.kt)(WR,(0,p.Z)({},PR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}RR.isMDXComponent=!0;const IR={toc:[]},SR="wrapper";function BR(t){let{components:e,...n}=t;return(0,s.kt)(SR,(0,p.Z)({},IR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}BR.isMDXComponent=!0;const GR={toc:[]},ER="wrapper";function OR(t){let{components:e,...n}=t;return(0,s.kt)(ER,(0,p.Z)({},GR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}OR.isMDXComponent=!0;const FR={toc:[]},UR="wrapper";function VR(t){let{components:e,...n}=t;return(0,s.kt)(UR,(0,p.Z)({},FR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}VR.isMDXComponent=!0;const qR={toc:[]},jR="wrapper";function YR(t){let{components:e,...n}=t;return(0,s.kt)(jR,(0,p.Z)({},qR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}YR.isMDXComponent=!0;const QR={toc:[]},HR="wrapper";function KR(t){let{components:e,...n}=t;return(0,s.kt)(HR,(0,p.Z)({},QR,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween back to the original value."))}KR.isMDXComponent=!0;const $R={toc:[]},JR="wrapper";function tI(t){let{components:e,...n}=t;return(0,s.kt)(JR,(0,p.Z)({},$R,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}tI.isMDXComponent=!0;const eI={toc:[]},nI="wrapper";function oI(t){let{components:e,...n}=t;return(0,s.kt)(nI,(0,p.Z)({},eI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function of the tween."))}oI.isMDXComponent=!0;const pI={toc:[]},rI="wrapper";function sI(t){let{components:e,...n}=t;return(0,s.kt)(rI,(0,p.Z)({},pI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function of the tween."))}sI.isMDXComponent=!0;const cI={toc:[]},aI="wrapper";function iI(t){let{components:e,...n}=t;return(0,s.kt)(aI,(0,p.Z)({},cI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback."))}iI.isMDXComponent=!0;const lI={toc:[]},uI="wrapper";function mI(t){let{components:e,...n}=t;return(0,s.kt)(uI,(0,p.Z)({},lI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}mI.isMDXComponent=!0;const dI={toc:[]},hI="wrapper";function fI(t){let{components:e,...n}=t;return(0,s.kt)(hI,(0,p.Z)({},dI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Run the given task."))}fI.isMDXComponent=!0;const kI={toc:[]},yI="wrapper";function DI(t){let{components:e,...n}=t;return(0,s.kt)(yI,(0,p.Z)({},kI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator to run."))}DI.isMDXComponent=!0;const MI={toc:[]},XI="wrapper";function _I(t){let{components:e,...n}=t;return(0,s.kt)(XI,(0,p.Z)({},MI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween to the specified value."))}_I.isMDXComponent=!0;const wI={toc:[]},TI="wrapper";function CI(t){let{components:e,...n}=t;return(0,s.kt)(TI,(0,p.Z)({},wI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for the specified duration."))}CI.isMDXComponent=!0;const xI={toc:[]},gI="wrapper";function vI(t){let{components:e,...n}=t;return(0,s.kt)(gI,(0,p.Z)({},xI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration to wait."))}vI.isMDXComponent=!0;const LI={toc:[]},ZI="wrapper";function bI(t){let{components:e,...n}=t;return(0,s.kt)(ZI,(0,p.Z)({},LI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread management."))}bI.isMDXComponent=!0;const NI={toc:[]},zI="wrapper";function AI(t){let{components:e,...n}=t;return(0,s.kt)(zI,(0,p.Z)({},NI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,s.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}AI.isMDXComponent=!0;const PI={toc:[]},WI="wrapper";function RI(t){let{components:e,...n}=t;return(0,s.kt)(WI,(0,p.Z)({},PI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A class representing an individual thread."))}RI.isMDXComponent=!0;const II={toc:[]},SI="wrapper";function BI(t){let{components:e,...n}=t;return(0,s.kt)(SI,(0,p.Z)({},II,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}BI.isMDXComponent=!0;const GI={toc:[]},EI="wrapper";function OI(t){let{components:e,...n}=t;return(0,s.kt)(EI,(0,p.Z)({},GI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The generator wrapped by this thread."))}OI.isMDXComponent=!0;const FI={toc:[]},UI="wrapper";function VI(t){let{components:e,...n}=t;return(0,s.kt)(UI,(0,p.Z)({},FI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Used by ",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}VI.isMDXComponent=!0;const qI={toc:[]},jI="wrapper";function YI(t){let{components:e,...n}=t;return(0,s.kt)(jI,(0,p.Z)({},qI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The current time of this thread."))}YI.isMDXComponent=!0;const QI={toc:[]},HI="wrapper";function KI(t){let{components:e,...n}=t;return(0,s.kt)(HI,(0,p.Z)({},QI,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The next value to be passed to the wrapped generator."))}KI.isMDXComponent=!0;const $I={toc:[]},JI="wrapper";function tS(t){let{components:e,...n}=t;return(0,s.kt)(JI,(0,p.Z)({},$I,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}tS.isMDXComponent=!0;const eS={toc:[]},nS="wrapper";function oS(t){let{components:e,...n}=t;return(0,s.kt)(nS,(0,p.Z)({},eS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Fixed time is a multiple of the frame duration. It can be used to account\nfor the difference between this thread's ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading/Thread#time"},(0,s.kt)("inlineCode",{parentName:"a"},"time"))," and the time of the\ncurrent animation frame."))}oS.isMDXComponent=!0;const pS={toc:[]},rS="wrapper";function sS(t){let{components:e,...n}=t;return(0,s.kt)(rS,(0,p.Z)({},pS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The fixed time of this thread."))}sS.isMDXComponent=!0;const cS={toc:[]},aS="wrapper";function iS(t){let{components:e,...n}=t;return(0,s.kt)(aS,(0,p.Z)({},cS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Progress the wrapped generator once."))}iS.isMDXComponent=!0;const lS={toc:[]},uS="wrapper";function mS(t){let{components:e,...n}=t;return(0,s.kt)(uS,(0,p.Z)({},lS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the thread for the next update cycle."))}mS.isMDXComponent=!0;const dS={toc:[]},hS="wrapper";function fS(t){let{components:e,...n}=t;return(0,s.kt)(hS,(0,p.Z)({},dS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The delta time of the next cycle."))}fS.isMDXComponent=!0;const kS={toc:[]},yS="wrapper";function DS(t){let{components:e,...n}=t;return(0,s.kt)(yS,(0,p.Z)({},kS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A generator function or a normal function that returns a generator."))}DS.isMDXComponent=!0;const MS={toc:[]},XS="wrapper";function _S(t){let{components:e,...n}=t;return(0,s.kt)(XS,(0,p.Z)({},MS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,s.kt)("p",null,"Progress to the next frame:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,s.kt)("p",null,"Run another generator synchronously:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,s.kt)("p",null,"Run another generator concurrently:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,s.kt)("p",null,"Await a Promise:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}_S.isMDXComponent=!0;const wS={toc:[]},TS="wrapper";function CS(t){let{components:e,...n}=t;return(0,s.kt)(TS,(0,p.Z)({},wS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}CS.isMDXComponent=!0;const xS={toc:[]},gS="wrapper";function vS(t){let{components:e,...n}=t;return(0,s.kt)(gS,(0,p.Z)({},xS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Cancel all listed tasks."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}vS.isMDXComponent=!0;const LS={toc:[]},ZS="wrapper";function bS(t){let{components:e,...n}=t;return(0,s.kt)(ZS,(0,p.Z)({},LS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to cancel."))}bS.isMDXComponent=!0;const NS={toc:[]},zS="wrapper";function AS(t){let{components:e,...n}=t;return(0,s.kt)(zS,(0,p.Z)({},NS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}AS.isMDXComponent=!0;const PS={toc:[]},WS="wrapper";function RS(t){let{components:e,...n}=t;return(0,s.kt)(WS,(0,p.Z)({},PS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}RS.isMDXComponent=!0;const IS={toc:[]},SS="wrapper";function BS(t){let{components:e,...n}=t;return(0,s.kt)(SS,(0,p.Z)({},IS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the given value is a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}BS.isMDXComponent=!0;const GS={toc:[]},ES="wrapper";function OS(t){let{components:e,...n}=t;return(0,s.kt)(ES,(0,p.Z)({},GS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A possible thread ",(0,s.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,s.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}OS.isMDXComponent=!0;const FS={toc:[]},US="wrapper";function VS(t){let{components:e,...n}=t;return(0,s.kt)(US,(0,p.Z)({},FS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}VS.isMDXComponent=!0;const qS={toc:[]},jS="wrapper";function YS(t){let{components:e,...n}=t;return(0,s.kt)(jS,(0,p.Z)({},qS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}YS.isMDXComponent=!0;const QS={toc:[]},HS="wrapper";function KS(t){let{components:e,...n}=t;return(0,s.kt)(HS,(0,p.Z)({},QS,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}KS.isMDXComponent=!0;const $S={toc:[]},JS="wrapper";function tB(t){let{components:e,...n}=t;return(0,s.kt)(JS,(0,p.Z)({},$S,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}tB.isMDXComponent=!0;const eB={toc:[]},nB="wrapper";function oB(t){let{components:e,...n}=t;return(0,s.kt)(nB,(0,p.Z)({},eB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Pause the current generator until listed tasks are finished."))}oB.isMDXComponent=!0;const pB={toc:[]},rB="wrapper";function sB(t){let{components:e,...n}=t;return(0,s.kt)(rB,(0,p.Z)({},pB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}sB.isMDXComponent=!0;const cB={toc:[]},aB="wrapper";function iB(t){let{components:e,...n}=t;return(0,s.kt)(aB,(0,p.Z)({},cB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A list of tasks to join."))}iB.isMDXComponent=!0;const lB={toc:[]},uB="wrapper";function mB(t){let{components:e,...n}=t;return(0,s.kt)(uB,(0,p.Z)({},lB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"From the perspective of the external generator, ",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,s.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}mB.isMDXComponent=!0;const dB={toc:[]},hB="wrapper";function fB(t){let{components:e,...n}=t;return(0,s.kt)(hB,(0,p.Z)({},dB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}fB.isMDXComponent=!0;const kB={toc:[]},yB="wrapper";function DB(t){let{components:e,...n}=t;return(0,s.kt)(yB,(0,p.Z)({},kB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a context in which generators can be run concurrently."))}DB.isMDXComponent=!0;const MB={toc:[]},XB="wrapper";function _B(t){let{components:e,...n}=t;return(0,s.kt)(XB,(0,p.Z)({},MB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns the generator to run."))}_B.isMDXComponent=!0;const wB={toc:[]},TB="wrapper";function CB(t){let{components:e,...n}=t;return(0,s.kt)(TB,(0,p.Z)({},wB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}CB.isMDXComponent=!0;const xB={toc:[]},gB="wrapper";function vB(t){let{components:e,...n}=t;return(0,s.kt)(gB,(0,p.Z)({},xB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transitions between scenes."))}vB.isMDXComponent=!0;const LB={toc:[]},ZB="wrapper";function bB(t){let{components:e,...n}=t;return(0,s.kt)(ZB,(0,p.Z)({},LB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that fades between the scenes."))}bB.isMDXComponent=!0;const NB={toc:[]},zB="wrapper";function AB(t){let{components:e,...n}=t;return(0,s.kt)(zB,(0,p.Z)({},NB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}AB.isMDXComponent=!0;const PB={toc:[]},WB="wrapper";function RB(t){let{components:e,...n}=t;return(0,s.kt)(WB,(0,p.Z)({},PB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene in the given direction."))}RB.isMDXComponent=!0;const IB={toc:[]},SB="wrapper";function BB(t){let{components:e,...n}=t;return(0,s.kt)(SB,(0,p.Z)({},IB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The direction in which to slide."))}BB.isMDXComponent=!0;const GB={toc:[]},EB="wrapper";function OB(t){let{components:e,...n}=t;return(0,s.kt)(EB,(0,p.Z)({},GB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}OB.isMDXComponent=!0;const FB={toc:[]},UB="wrapper";function VB(t){let{components:e,...n}=t;return(0,s.kt)(UB,(0,p.Z)({},FB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that slides the scene towards the given origin."))}VB.isMDXComponent=!0;const qB={toc:[]},jB="wrapper";function YB(t){let{components:e,...n}=t;return(0,s.kt)(jB,(0,p.Z)({},qB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin towards which to slide."))}YB.isMDXComponent=!0;const QB={toc:[]},HB="wrapper";function KB(t){let{components:e,...n}=t;return(0,s.kt)(HB,(0,p.Z)({},QB,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}KB.isMDXComponent=!0;const $B={toc:[]},JB="wrapper";function tG(t){let{components:e,...n}=t;return(0,s.kt)(JB,(0,p.Z)({},$B,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}tG.isMDXComponent=!0;const eG={toc:[]},nG="wrapper";function oG(t){let{components:e,...n}=t;return(0,s.kt)(nG,(0,p.Z)({},eG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the current scene is rendered."))}oG.isMDXComponent=!0;const pG={toc:[]},rG="wrapper";function sG(t){let{components:e,...n}=t;return(0,s.kt)(rG,(0,p.Z)({},pG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to use before the previous scene is rendered."))}sG.isMDXComponent=!0;const cG={toc:[]},aG="wrapper";function iG(t){let{components:e,...n}=t;return(0,s.kt)(aG,(0,p.Z)({},cG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the previous scene should be rendered on top."))}iG.isMDXComponent=!0;const lG={toc:[]},uG="wrapper";function mG(t){let{components:e,...n}=t;return(0,s.kt)(uG,(0,p.Z)({},lG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}mG.isMDXComponent=!0;const dG={toc:[]},hG="wrapper";function fG(t){let{components:e,...n}=t;return(0,s.kt)(hG,(0,p.Z)({},dG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area on which to zoom in."))}fG.isMDXComponent=!0;const kG={toc:[]},yG="wrapper";function DG(t){let{components:e,...n}=t;return(0,s.kt)(yG,(0,p.Z)({},kG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}DG.isMDXComponent=!0;const MG={toc:[]},XG="wrapper";function _G(t){let{components:e,...n}=t;return(0,s.kt)(XG,(0,p.Z)({},MG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}_G.isMDXComponent=!0;const wG={toc:[]},TG="wrapper";function CG(t){let{components:e,...n}=t;return(0,s.kt)(TG,(0,p.Z)({},wG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The area from which to zoom out."))}CG.isMDXComponent=!0;const xG={toc:[]},gG="wrapper";function vG(t){let{components:e,...n}=t;return(0,s.kt)(gG,(0,p.Z)({},xG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}vG.isMDXComponent=!0;const LG={toc:[]},ZG="wrapper";function bG(t){let{components:e,...n}=t;return(0,s.kt)(ZG,(0,p.Z)({},LG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolation and timing of tweens."))}bG.isMDXComponent=!0;const NG={toc:[]},zG="wrapper";function AG(t){let{components:e,...n}=t;return(0,s.kt)(zG,(0,p.Z)({},NG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Any old key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,s.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"})))}AG.isMDXComponent=!0;const PG={toc:[]},WG="wrapper";function RG(t){let{components:e,...n}=t;return(0,s.kt)(WG,(0,p.Z)({},PG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}RG.isMDXComponent=!0;const IG={toc:[]},SG="wrapper";function BG(t){let{components:e,...n}=t;return(0,s.kt)(SG,(0,p.Z)({},IG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}BG.isMDXComponent=!0;const GG={toc:[]},EG="wrapper";function OG(t){let{components:e,...n}=t;return(0,s.kt)(EG,(0,p.Z)({},GG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}OG.isMDXComponent=!0;const FG={toc:[]},UG="wrapper";function VG(t){let{components:e,...n}=t;return(0,s.kt)(UG,(0,p.Z)({},FG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}VG.isMDXComponent=!0;const qG={toc:[]},jG="wrapper";function YG(t){let{components:e,...n}=t;return(0,s.kt)(jG,(0,p.Z)({},qG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}YG.isMDXComponent=!0;const QG={toc:[]},HG="wrapper";function KG(t){let{components:e,...n}=t;return(0,s.kt)(HG,(0,p.Z)({},QG,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A value matching the structure of from and to."))}KG.isMDXComponent=!0;const $G={toc:[]},JG="wrapper";function tE(t){let{components:e,...n}=t;return(0,s.kt)(JG,(0,p.Z)({},$G,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}tE.isMDXComponent=!0;const eE={toc:[]},nE="wrapper";function oE(t){let{components:e,...n}=t;return(0,s.kt)(nE,(0,p.Z)({},eE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 0."))}oE.isMDXComponent=!0;const pE={toc:[]},rE="wrapper";function sE(t){let{components:e,...n}=t;return(0,s.kt)(rE,(0,p.Z)({},pE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The input to favor when value is 1."))}sE.isMDXComponent=!0;const cE={toc:[]},aE="wrapper";function iE(t){let{components:e,...n}=t;return(0,s.kt)(aE,(0,p.Z)({},cE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}iE.isMDXComponent=!0;const lE={toc:[]},uE="wrapper";function mE(t){let{components:e,...n}=t;return(0,s.kt)(uE,(0,p.Z)({},lE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Complex types used in animations."))}mE.isMDXComponent=!0;const dE={toc:[]},hE="wrapper";function fE(t){let{components:e,...n}=t;return(0,s.kt)(hE,(0,p.Z)({},dE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,s.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,s.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,s.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,s.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,s.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}fE.isMDXComponent=!0;const kE={toc:[]},yE="wrapper";function DE(t){let{components:e,...n}=t;return(0,s.kt)(yE,(0,p.Z)({},kE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the determinant of the matrix."))}DE.isMDXComponent=!0;const ME={toc:[]},XE="wrapper";function _E(t){let{components:e,...n}=t;return(0,s.kt)(XE,(0,p.Z)({},ME,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}_E.isMDXComponent=!0;const wE={toc:[]},TE="wrapper";function CE(t){let{components:e,...n}=t;return(0,s.kt)(TE,(0,p.Z)({},wE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}CE.isMDXComponent=!0;const xE={toc:[]},gE="wrapper";function vE(t){let{components:e,...n}=t;return(0,s.kt)(gE,(0,p.Z)({},xE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the inverse of the matrix."))}vE.isMDXComponent=!0;const LE={toc:[]},ZE="wrapper";function bE(t){let{components:e,...n}=t;return(0,s.kt)(ZE,(0,p.Z)({},LE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}bE.isMDXComponent=!0;const NE={toc:[]},zE="wrapper";function AE(t){let{components:e,...n}=t;return(0,s.kt)(zE,(0,p.Z)({},NE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}AE.isMDXComponent=!0;const PE={toc:[]},WE="wrapper";function RE(t){let{components:e,...n}=t;return(0,s.kt)(WE,(0,p.Z)({},PE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the provided matrix to this matrix."))}RE.isMDXComponent=!0;const IE={toc:[]},SE="wrapper";function BE(t){let{components:e,...n}=t;return(0,s.kt)(SE,(0,p.Z)({},IE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to add"))}BE.isMDXComponent=!0;const GE={toc:[]},EE="wrapper";function OE(t){let{components:e,...n}=t;return(0,s.kt)(EE,(0,p.Z)({},GE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}OE.isMDXComponent=!0;const FE={toc:[]},UE="wrapper";function VE(t){let{components:e,...n}=t;return(0,s.kt)(UE,(0,p.Z)({},FE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}VE.isMDXComponent=!0;const qE={toc:[]},jE="wrapper";function YE(t){let{components:e,...n}=t;return(0,s.kt)(jE,(0,p.Z)({},qE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the component vector to retrieve."))}YE.isMDXComponent=!0;const QE={toc:[]},HE="wrapper";function KE(t){let{components:e,...n}=t;return(0,s.kt)(HE,(0,p.Z)({},QE,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}KE.isMDXComponent=!0;const $E={toc:[]},JE="wrapper";function tO(t){let{components:e,...n}=t;return(0,s.kt)(JE,(0,p.Z)({},$E,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}tO.isMDXComponent=!0;const eO={toc:[]},nO="wrapper";function oO(t){let{components:e,...n}=t;return(0,s.kt)(nO,(0,p.Z)({},eO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}oO.isMDXComponent=!0;const pO={toc:[]},rO="wrapper";function sO(t){let{components:e,...n}=t;return(0,s.kt)(rO,(0,p.Z)({},pO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to multiply with"))}sO.isMDXComponent=!0;const cO={toc:[]},aO="wrapper";function iO(t){let{components:e,...n}=t;return(0,s.kt)(aO,(0,p.Z)({},cO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}iO.isMDXComponent=!0;const lO={toc:[]},uO="wrapper";function mO(t){let{components:e,...n}=t;return(0,s.kt)(uO,(0,p.Z)({},lO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"})))}mO.isMDXComponent=!0;const dO={toc:[]},hO="wrapper";function fO(t){let{components:e,...n}=t;return(0,s.kt)(hO,(0,p.Z)({},dO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to scale each term"))}fO.isMDXComponent=!0;const kO={toc:[]},yO="wrapper";function DO(t){let{components:e,...n}=t;return(0,s.kt)(yO,(0,p.Z)({},kO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}DO.isMDXComponent=!0;const MO={toc:[]},XO="wrapper";function _O(t){let{components:e,...n}=t;return(0,s.kt)(XO,(0,p.Z)({},MO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}_O.isMDXComponent=!0;const wO={toc:[]},TO="wrapper";function CO(t){let{components:e,...n}=t;return(0,s.kt)(TO,(0,p.Z)({},wO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}CO.isMDXComponent=!0;const xO={toc:[]},gO="wrapper";function vO(t){let{components:e,...n}=t;return(0,s.kt)(gO,(0,p.Z)({},xO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate the matrix."))}vO.isMDXComponent=!0;const LO={toc:[]},ZO="wrapper";function bO(t){let{components:e,...n}=t;return(0,s.kt)(ZO,(0,p.Z)({},LO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the angle is provided in degrees."))}bO.isMDXComponent=!0;const NO={toc:[]},zO="wrapper";function AO(t){let{components:e,...n}=t;return(0,s.kt)(zO,(0,p.Z)({},NO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}AO.isMDXComponent=!0;const PO={toc:[]},WO="wrapper";function RO(t){let{components:e,...n}=t;return(0,s.kt)(WO,(0,p.Z)({},PO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}RO.isMDXComponent=!0;const IO={toc:[]},SO="wrapper";function BO(t){let{components:e,...n}=t;return(0,s.kt)(SO,(0,p.Z)({},IO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the row to retrieve."))}BO.isMDXComponent=!0;const GO={toc:[]},EO="wrapper";function OO(t){let{components:e,...n}=t;return(0,s.kt)(EO,(0,p.Z)({},GO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}OO.isMDXComponent=!0;const FO={toc:[]},UO="wrapper";function VO(t){let{components:e,...n}=t;return(0,s.kt)(UO,(0,p.Z)({},FO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}VO.isMDXComponent=!0;const qO={toc:[]},jO="wrapper";function YO(t){let{components:e,...n}=t;return(0,s.kt)(jO,(0,p.Z)({},qO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Scale the x and y component vectors of the matrix."))}YO.isMDXComponent=!0;const QO={toc:[]},HO="wrapper";function KO(t){let{components:e,...n}=t;return(0,s.kt)(HO,(0,p.Z)({},QO,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The factor by which to scale the matrix"))}KO.isMDXComponent=!0;const $O={toc:[]},JO="wrapper";function tF(t){let{components:e,...n}=t;return(0,s.kt)(JO,(0,p.Z)({},$O,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}tF.isMDXComponent=!0;const eF={toc:[]},nF="wrapper";function oF(t){let{components:e,...n}=t;return(0,s.kt)(nF,(0,p.Z)({},eF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}oF.isMDXComponent=!0;const pF={toc:[]},rF="wrapper";function sF(t){let{components:e,...n}=t;return(0,s.kt)(rF,(0,p.Z)({},pF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Subtract the provided matrix from this matrix."))}sF.isMDXComponent=!0;const cF={toc:[]},aF="wrapper";function iF(t){let{components:e,...n}=t;return(0,s.kt)(aF,(0,p.Z)({},cF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The matrix to subract"))}iF.isMDXComponent=!0;const lF={toc:[]},uF="wrapper";function mF(t){let{components:e,...n}=t;return(0,s.kt)(uF,(0,p.Z)({},lF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,s.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}mF.isMDXComponent=!0;const dF={toc:[]},hF="wrapper";function fF(t){let{components:e,...n}=t;return(0,s.kt)(hF,(0,p.Z)({},dF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}fF.isMDXComponent=!0;const kF={toc:[]},yF="wrapper";function DF(t){let{components:e,...n}=t;return(0,s.kt)(yF,(0,p.Z)({},kF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}DF.isMDXComponent=!0;const MF={toc:[]},XF="wrapper";function _F(t){let{components:e,...n}=t;return(0,s.kt)(XF,(0,p.Z)({},MF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector by which to translate the matrix"))}_F.isMDXComponent=!0;const wF={toc:[]},TF="wrapper";function CF(t){let{components:e,...n}=t;return(0,s.kt)(TF,(0,p.Z)({},wF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a two-dimensional vector."))}CF.isMDXComponent=!0;const xF={toc:[]},gF="wrapper";function vF(t){let{components:e,...n}=t;return(0,s.kt)(gF,(0,p.Z)({},xF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(0, 1)")))}vF.isMDXComponent=!0;const LF={toc:[]},ZF="wrapper";function bF(t){let{components:e,...n}=t;return(0,s.kt)(ZF,(0,p.Z)({},LF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(-1, 1)")))}bF.isMDXComponent=!0;const NF={toc:[]},zF="wrapper";function AF(t){let{components:e,...n}=t;return(0,s.kt)(zF,(0,p.Z)({},NF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(1, 1)")))}AF.isMDXComponent=!0;const PF={toc:[]},WF="wrapper";function RF(t){let{components:e,...n}=t;return(0,s.kt)(WF,(0,p.Z)({},PF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(0, -1)")))}RF.isMDXComponent=!0;const IF={toc:[]},SF="wrapper";function BF(t){let{components:e,...n}=t;return(0,s.kt)(SF,(0,p.Z)({},IF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(-1, -1)")))}BF.isMDXComponent=!0;const GF={toc:[]},EF="wrapper";function OF(t){let{components:e,...n}=t;return(0,s.kt)(EF,(0,p.Z)({},GF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"Vector2(1, -1)")))}OF.isMDXComponent=!0;const FF={toc:[]},UF="wrapper";function VF(t){let{components:e,...n}=t;return(0,s.kt)(UF,(0,p.Z)({},FF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}VF.isMDXComponent=!0;const qF={toc:[]},jF="wrapper";function YF(t){let{components:e,...n}=t;return(0,s.kt)(jF,(0,p.Z)({},qF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector and the positive x-axis."))}YF.isMDXComponent=!0;const QF={toc:[]},HF="wrapper";function KF(t){let{components:e,...n}=t;return(0,s.kt)(HF,(0,p.Z)({},QF,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector and the positive x-axis."))}KF.isMDXComponent=!0;const $F={toc:[]},JF="wrapper";function tU(t){let{components:e,...n}=t;return(0,s.kt)(JF,(0,p.Z)({},$F,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method allows passing an allowed error margin when comparing vectors\nto compensate for floating point inaccuracies. To check if two vectors are\nexactly equal, use the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#exactlyEquals"},(0,s.kt)("inlineCode",{parentName:"a"},"exactlyEquals"))," method, instead."))}tU.isMDXComponent=!0;const eU={toc:[]},nU="wrapper";function oU(t){let{components:e,...n}=t;return(0,s.kt)(nU,(0,p.Z)({},eU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are equal to each other."))}oU.isMDXComponent=!0;const pU={toc:[]},rU="wrapper";function sU(t){let{components:e,...n}=t;return(0,s.kt)(rU,(0,p.Z)({},pU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}sU.isMDXComponent=!0;const cU={toc:[]},aU="wrapper";function iU(t){let{components:e,...n}=t;return(0,s.kt)(aU,(0,p.Z)({},cU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The allowed error threshold when comparing the vectors."))}iU.isMDXComponent=!0;const lU={toc:[]},uU="wrapper";function mU(t){let{components:e,...n}=t;return(0,s.kt)(uU,(0,p.Z)({},lU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you need to compensate for floating point inaccuracies, use the\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#equals"},(0,s.kt)("inlineCode",{parentName:"a"},"equals"))," method, instead."))}mU.isMDXComponent=!0;const dU={toc:[]},hU="wrapper";function fU(t){let{components:e,...n}=t;return(0,s.kt)(hU,(0,p.Z)({},dU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if two vectors are exactly equal to each other."))}fU.isMDXComponent=!0;const kU={toc:[]},yU="wrapper";function DU(t){let{components:e,...n}=t;return(0,s.kt)(yU,(0,p.Z)({},kU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The vector to compare."))}DU.isMDXComponent=!0;const MU={toc:[]},XU="wrapper";function _U(t){let{components:e,...n}=t;return(0,s.kt)(XU,(0,p.Z)({},MU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotates the vector around a point by the provided angle."))}_U.isMDXComponent=!0;const wU={toc:[]},TU="wrapper";function CU(t){let{components:e,...n}=t;return(0,s.kt)(TU,(0,p.Z)({},wU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The angle by which to rotate in degrees."))}CU.isMDXComponent=!0;const xU={toc:[]},gU="wrapper";function vU(t){let{components:e,...n}=t;return(0,s.kt)(gU,(0,p.Z)({},xU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}vU.isMDXComponent=!0;const LU={toc:[]},ZU="wrapper";function bU(t){let{components:e,...n}=t;return(0,s.kt)(ZU,(0,p.Z)({},LU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Helper function to create a ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#static-polarLerp"},(0,s.kt)("inlineCode",{parentName:"a"},"polarLerp"))," interpolation\nfunction with additional parameters."))}bU.isMDXComponent=!0;const NU={toc:[]},zU="wrapper";function AU(t){let{components:e,...n}=t;return(0,s.kt)(zU,(0,p.Z)({},NU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the point should get rotated\ncounterclockwise."))}AU.isMDXComponent=!0;const PU={toc:[]},WU="wrapper";function RU(t){let{components:e,...n}=t;return(0,s.kt)(WU,(0,p.Z)({},PU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}RU.isMDXComponent=!0;const IU={toc:[]},SU="wrapper";function BU(t){let{components:e,...n}=t;return(0,s.kt)(SU,(0,p.Z)({},IU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned angle will be between -180 and 180 degrees."))}BU.isMDXComponent=!0;const GU={toc:[]},EU="wrapper";function OU(t){let{components:e,...n}=t;return(0,s.kt)(EU,(0,p.Z)({},GU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in degrees between the vector described by x and y and the\npositive x-axis."))}OU.isMDXComponent=!0;const FU={toc:[]},UU="wrapper";function VU(t){let{components:e,...n}=t;return(0,s.kt)(UU,(0,p.Z)({},FU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}VU.isMDXComponent=!0;const qU={toc:[]},jU="wrapper";function YU(t){let{components:e,...n}=t;return(0,s.kt)(jU,(0,p.Z)({},qU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}YU.isMDXComponent=!0;const QU={toc:[]},HU="wrapper";function KU(t){let{components:e,...n}=t;return(0,s.kt)(HU,(0,p.Z)({},QU,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This function is useful when used in conjunction with ",(0,s.kt)("a",{parentName:"p",href:"/api/core/types/Vector2#rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"rotate"))," to\nanimate an object's position on a circular arc (see examples)."))}KU.isMDXComponent=!0;const $U={toc:[]},JU="wrapper";function tV(t){let{components:e,...n}=t;return(0,s.kt)(JU,(0,p.Z)({},$U,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Animating an object in a circle around the origin"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.polarLerp\n);\n")))}tV.isMDXComponent=!0;const eV={toc:[]},nV="wrapper";function oV(t){let{components:e,...n}=t;return(0,s.kt)(nV,(0,p.Z)({},eV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotating an object around the point ",(0,s.kt)("inlineCode",{parentName:"p"},"[-200, 100]")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180, [-200, 100]),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(false, [-200, 100]),\n);\n")))}oV.isMDXComponent=!0;const pV={toc:[]},rV="wrapper";function sV(t){let{components:e,...n}=t;return(0,s.kt)(rV,(0,p.Z)({},pV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rotating an object counterclockwise around the origin"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"circle().position(\n  circle().position().rotate(180),\n  1,\n  easeInOutCubic,\n  Vector2.createPolarLerp(true),\n);\n")))}sV.isMDXComponent=!0;const cV={toc:[]},aV="wrapper";function iV(t){let{components:e,...n}=t;return(0,s.kt)(aV,(0,p.Z)({},cV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Interpolates between two vectors on the polar plane by interpolating\nthe angles and magnitudes of the vectors individually."))}iV.isMDXComponent=!0;const lV={toc:[]},uV="wrapper";function mV(t){let{components:e,...n}=t;return(0,s.kt)(uV,(0,p.Z)({},lV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting vector."))}mV.isMDXComponent=!0;const dV={toc:[]},hV="wrapper";function fV(t){let{components:e,...n}=t;return(0,s.kt)(hV,(0,p.Z)({},dV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The target vector."))}fV.isMDXComponent=!0;const kV={toc:[]},yV="wrapper";function DV(t){let{components:e,...n}=t;return(0,s.kt)(yV,(0,p.Z)({},kV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t-value of the interpolation."))}DV.isMDXComponent=!0;const MV={toc:[]},XV="wrapper";function _V(t){let{components:e,...n}=t;return(0,s.kt)(XV,(0,p.Z)({},MV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the vector should get rotated\ncounterclockwise. Defaults to ",(0,s.kt)("inlineCode",{parentName:"p"},"false"),"."))}_V.isMDXComponent=!0;const wV={toc:[]},TV="wrapper";function CV(t){let{components:e,...n}=t;return(0,s.kt)(TV,(0,p.Z)({},wV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The center of rotation. Defaults to the origin."))}CV.isMDXComponent=!0;const xV={toc:[]},gV="wrapper";function vV(t){let{components:e,...n}=t;return(0,s.kt)(gV,(0,p.Z)({},xV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the angle in radians between the vector described by x and y and the\npositive x-axis."))}vV.isMDXComponent=!0;const LV={toc:[]},ZV="wrapper";function bV(t){let{components:e,...n}=t;return(0,s.kt)(ZV,(0,p.Z)({},LV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The x component of the vector."))}bV.isMDXComponent=!0;const NV={toc:[]},zV="wrapper";function AV(t){let{components:e,...n}=t;return(0,s.kt)(zV,(0,p.Z)({},NV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The y component of the vector."))}AV.isMDXComponent=!0;const PV={toc:[]},WV="wrapper";function RV(t){let{components:e,...n}=t;return(0,s.kt)(WV,(0,p.Z)({},PV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same class as the one created by\n",(0,s.kt)("a",{parentName:"p",href:"https://gka.github.io/chroma.js/"},(0,s.kt)("inlineCode",{parentName:"a"},"chroma.js")),". Check out their\ndocumentation for more information on how to use it."))}RV.isMDXComponent=!0;const IV={toc:[]},SV="wrapper";function BV(t){let{components:e,...n}=t;return(0,s.kt)(SV,(0,p.Z)({},IV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a color."))}BV.isMDXComponent=!0;const GV={toc:[]},EV="wrapper";function OV(t){let{components:e,...n}=t;return(0,s.kt)(EV,(0,p.Z)({},GV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}OV.isMDXComponent=!0;const FV={toc:[]},UV="wrapper";function VV(t){let{components:e,...n}=t;return(0,s.kt)(UV,(0,p.Z)({},FV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert the given origin to a vector representing its offset."))}VV.isMDXComponent=!0;const qV={toc:[]},jV="wrapper";function YV(t){let{components:e,...n}=t;return(0,s.kt)(jV,(0,p.Z)({},qV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The origin to convert."))}YV.isMDXComponent=!0;const QV={toc:[]},HV="wrapper";function KV(t){let{components:e,...n}=t;return(0,s.kt)(HV,(0,p.Z)({},QV,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"General utilities and helper functions."))}KV.isMDXComponent=!0;const $V={toc:[]},JV="wrapper";function tq(t){let{components:e,...n}=t;return(0,s.kt)(JV,(0,p.Z)({},$V,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}tq.isMDXComponent=!0;const eq={toc:[]},nq="wrapper";function oq(t){let{components:e,...n}=t;return(0,s.kt)(nq,(0,p.Z)({},eq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional duration in milliseconds."))}oq.isMDXComponent=!0;const pq={toc:[]},rq="wrapper";function sq(t){let{components:e,...n}=t;return(0,s.kt)(rq,(0,p.Z)({},pq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This will be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.kt)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}sq.isMDXComponent=!0;const cq={toc:[]},aq="wrapper";function iq(t){let{components:e,...n}=t;return(0,s.kt)(aq,(0,p.Z)({},cq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional key used to inspect a related object."))}iq.isMDXComponent=!0;const lq={toc:[]},uq="wrapper";function mq(t){let{components:e,...n}=t;return(0,s.kt)(uq,(0,p.Z)({},lq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded."))}mq.isMDXComponent=!0;const dq={toc:[]},hq="wrapper";function fq(t){let{components:e,...n}=t;return(0,s.kt)(hq,(0,p.Z)({},dq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An object that will be serialized as JSON and displayed under the message."))}fq.isMDXComponent=!0;const kq={toc:[]},yq="wrapper";function Dq(t){let{components:e,...n}=t;return(0,s.kt)(yq,(0,p.Z)({},kq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Always visible."))}Dq.isMDXComponent=!0;const Mq={toc:[]},Xq="wrapper";function _q(t){let{components:e,...n}=t;return(0,s.kt)(Xq,(0,p.Z)({},Mq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main message of the log."))}_q.isMDXComponent=!0;const wq={toc:[]},Tq="wrapper";function Cq(t){let{components:e,...n}=t;return(0,s.kt)(Tq,(0,p.Z)({},wq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}Cq.isMDXComponent=!0;const xq={toc:[]},gq="wrapper";function vq(t){let{components:e,...n}=t;return(0,s.kt)(gq,(0,p.Z)({},xq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}vq.isMDXComponent=!0;const Lq={toc:[]},Zq="wrapper";function bq(t){let{components:e,...n}=t;return(0,s.kt)(Zq,(0,p.Z)({},Lq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}bq.isMDXComponent=!0;const Nq={toc:[]},zq="wrapper";function Aq(t){let{components:e,...n}=t;return(0,s.kt)(zq,(0,p.Z)({},Nq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Can be used to display any duration related to the log.\nThe value is always visible next to the message."))}Aq.isMDXComponent=!0;const Pq={toc:[]},Wq="wrapper";function Rq(t){let{components:e,...n}=t;return(0,s.kt)(Wq,(0,p.Z)({},Pq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional duration in milliseconds."))}Rq.isMDXComponent=!0;const Iq={toc:[]},Sq="wrapper";function Bq(t){let{components:e,...n}=t;return(0,s.kt)(Sq,(0,p.Z)({},Iq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This will be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/core/scenes/Inspectable"},(0,s.kt)("inlineCode",{parentName:"a"},"Inspectable")),' interface to\ndisplay additional information about the inspected object.\nWhen specified, the log will have an "inspect" button that will open the\n"Properties" tab and select the inspected object.'))}Bq.isMDXComponent=!0;const Gq={toc:[]},Eq="wrapper";function Oq(t){let{components:e,...n}=t;return(0,s.kt)(Eq,(0,p.Z)({},Gq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An optional key used to inspect a related object."))}Oq.isMDXComponent=!0;const Fq={toc:[]},Uq="wrapper";function Vq(t){let{components:e,...n}=t;return(0,s.kt)(Uq,(0,p.Z)({},Fq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Visible only when the log is expanded."))}Vq.isMDXComponent=!0;const qq={toc:[]},jq="wrapper";function Yq(t){let{components:e,...n}=t;return(0,s.kt)(jq,(0,p.Z)({},qq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An object that will be serialized as JSON and displayed under the message."))}Yq.isMDXComponent=!0;const Qq={toc:[]},Hq="wrapper";function Kq(t){let{components:e,...n}=t;return(0,s.kt)(Hq,(0,p.Z)({},Qq,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Always visible."))}Kq.isMDXComponent=!0;const $q={toc:[]},Jq="wrapper";function tj(t){let{components:e,...n}=t;return(0,s.kt)(Jq,(0,p.Z)({},$q,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The main message of the log."))}tj.isMDXComponent=!0;const ej={toc:[]},nj="wrapper";function oj(t){let{components:e,...n}=t;return(0,s.kt)(nj,(0,p.Z)({},ej,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}oj.isMDXComponent=!0;const pj={toc:[]},rj="wrapper";function sj(t){let{components:e,...n}=t;return(0,s.kt)(rj,(0,p.Z)({},pj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Optional override for formatting stack traces"))}sj.isMDXComponent=!0;const cj={toc:[]},aj="wrapper";function ij(t){let{components:e,...n}=t;return(0,s.kt)(aj,(0,p.Z)({},cj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create .stack property on a target object"))}ij.isMDXComponent=!0;const lj={toc:[]},uj="wrapper";function mj(t){let{components:e,...n}=t;return(0,s.kt)(uj,(0,p.Z)({},lj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An array of the transformed references."))}mj.isMDXComponent=!0;const dj={toc:[]},hj="wrapper";function fj(t){let{components:e,...n}=t;return(0,s.kt)(hj,(0,p.Z)({},dj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Maps the references in this group to a new array."))}fj.isMDXComponent=!0;const kj={toc:[]},yj="wrapper";function Dj(t){let{components:e,...n}=t;return(0,s.kt)(yj,(0,p.Z)({},kj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to transform each reference."))}Dj.isMDXComponent=!0;const Mj={toc:[]},Xj="wrapper";function _j(t){let{components:e,...n}=t;return(0,s.kt)(Xj,(0,p.Z)({},Mj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const radians = 30 * DEG2RAD;\n")))}_j.isMDXComponent=!0;const wj={toc:[]},Tj="wrapper";function Cj(t){let{components:e,...n}=t;return(0,s.kt)(Tj,(0,p.Z)({},wj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting degrees to radians"))}Cj.isMDXComponent=!0;const xj={toc:[]},gj="wrapper";function vj(t){let{components:e,...n}=t;return(0,s.kt)(gj,(0,p.Z)({},xj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const degrees = 0.6 * RAD2DEG;\n")))}vj.isMDXComponent=!0;const Lj={toc:[]},Zj="wrapper";function bj(t){let{components:e,...n}=t;return(0,s.kt)(Zj,(0,p.Z)({},Lj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A constant for converting radians to degrees"))}bj.isMDXComponent=!0;const Nj={toc:[]},zj="wrapper";function Aj(t){let{components:e,...n}=t;return(0,s.kt)(zj,(0,p.Z)({},Nj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned object is both an array and a reference that can be passed\ndirectly to the ",(0,s.kt)("inlineCode",{parentName:"p"},"ref")," property of a node."))}Aj.isMDXComponent=!0;const Pj={toc:[]},Wj="wrapper";function Rj(t){let{components:e,...n}=t;return(0,s.kt)(Wj,(0,p.Z)({},Pj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefArray<Txt>();\n\nview.add(['A', 'B'].map(text => <Txt ref={labels}>{text}</Txt>));\nview.add(<Txt ref={labels}>C</Txt>);\n\n// accessing the references individually:\nyield* labels[0].text('A changes', 0.3);\nyield* labels[1].text('B changes', 0.3);\nyield* labels[2].text('C changes', 0.3);\n\n// accessing all references at once:\nyield* all(...labels.map(label => label.fill('white', 0.3)));\n")))}Rj.isMDXComponent=!0;const Ij={toc:[]},Sj="wrapper";function Bj(t){let{components:e,...n}=t;return(0,s.kt)(Sj,(0,p.Z)({},Ij,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array of references."))}Bj.isMDXComponent=!0;const Gj={toc:[]},Ej="wrapper";function Oj(t){let{components:e,...n}=t;return(0,s.kt)(Ej,(0,p.Z)({},Gj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned object lets you easily create multiple references to the same\ntype without initializing them individually."),(0,s.kt)("p",null,"You can retrieve references by accessing the object's properties. If the\nreference for a given property does not exist, it will be created\nautomatically."))}Oj.isMDXComponent=!0;const Fj={toc:[]},Uj="wrapper";function Vj(t){let{components:e,...n}=t;return(0,s.kt)(Uj,(0,p.Z)({},Fj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const labels = createRefMap<Txt>();\n\nview.add(\n  <>\n    <Txt ref={labels.a}>A</Txt>\n    <Txt ref={labels.b}>B</Txt>\n    <Txt ref={labels.c}>C</Txt>\n  </>,\n);\n\n// accessing the references individually:\nyield* labels.a().text('A changes', 0.3);\nyield* labels.b().text('B changes', 0.3);\nyield* labels.c().text('C changes', 0.3);\n\n// checking if the given reference exists:\nif ('d' in labels) {\n  yield* labels.d().text('D changes', 0.3);\n}\n\n// accessing all references at once:\nyield* all(...labels.mapRefs(label => label.fill('white', 0.3)));\n")))}Vj.isMDXComponent=!0;const qj={toc:[]},jj="wrapper";function Yj(t){let{components:e,...n}=t;return(0,s.kt)(jj,(0,p.Z)({},qj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a group of references."))}Yj.isMDXComponent=!0;const Qj={toc:[]},Hj="wrapper";function Kj(t){let{components:e,...n}=t;return(0,s.kt)(Hj,(0,p.Z)({},Qj,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is a shortcut for calling ",(0,s.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}Kj.isMDXComponent=!0;const $j={toc:[]},Jj="wrapper";function tY(t){let{components:e,...n}=t;return(0,s.kt)(Jj,(0,p.Z)({},$j,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}tY.isMDXComponent=!0;const eY={toc:[]},nY="wrapper";function oY(t){let{components:e,...n}=t;return(0,s.kt)(nY,(0,p.Z)({},eY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Logs a debug message with an arbitrary payload."))}oY.isMDXComponent=!0;const pY={toc:[]},rY="wrapper";function sY(t){let{components:e,...n}=t;return(0,s.kt)(rY,(0,p.Z)({},pY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The payload to log"))}sY.isMDXComponent=!0;const cY={toc:[]},aY="wrapper";function iY(t){let{components:e,...n}=t;return(0,s.kt)(aY,(0,p.Z)({},cY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the given function as deprecated."))}iY.isMDXComponent=!0;const lY={toc:[]},uY="wrapper";function mY(t){let{components:e,...n}=t;return(0,s.kt)(uY,(0,p.Z)({},lY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function to deprecate."))}mY.isMDXComponent=!0;const dY={toc:[]},hY="wrapper";function fY(t){let{components:e,...n}=t;return(0,s.kt)(hY,(0,p.Z)({},dY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The log message."))}fY.isMDXComponent=!0;const kY={toc:[]},yY="wrapper";function DY(t){let{components:e,...n}=t;return(0,s.kt)(yY,(0,p.Z)({},kY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The optional log remarks."))}DY.isMDXComponent=!0;const MY={toc:[]},XY="wrapper";function _Y(t){let{components:e,...n}=t;return(0,s.kt)(XY,(0,p.Z)({},MY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}_Y.isMDXComponent=!0;const wY={toc:[]},TY="wrapper";function CY(t){let{components:e,...n}=t;return(0,s.kt)(TY,(0,p.Z)({},wY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mark the current scene as ready to transition out."))}CY.isMDXComponent=!0;const xY={toc:[]},gY="wrapper";function vY(t){let{components:e,...n}=t;return(0,s.kt)(gY,(0,p.Z)({},xY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can either be 'true' of 'false'\n(as strings) if present, or be undefined if not run\nfrom a vite context or run without the MC Plugin."))}vY.isMDXComponent=!0;const LY={toc:[]},ZY="wrapper";function bY(t){let{components:e,...n}=t;return(0,s.kt)(ZY,(0,p.Z)({},LY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the proxy is enabled via the plugin by checking\nfor ",(0,s.kt)("inlineCode",{parentName:"p"},"import.meta.env.VITE_MC_PROXY_ENABLED")))}bY.isMDXComponent=!0;const NY={toc:[]},zY="wrapper";function AY(t){let{components:e,...n}=t;return(0,s.kt)(zY,(0,p.Z)({},NY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3); // [0, 1, 2]\nconst array2 = range(-3); // [0, -1, -2]\n")))}AY.isMDXComponent=!0;const PY={toc:[]},WY="wrapper";function RY(t){let{components:e,...n}=t;return(0,s.kt)(WY,(0,p.Z)({},PY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}RY.isMDXComponent=!0;const IY={toc:[]},SY="wrapper";function BY(t){let{components:e,...n}=t;return(0,s.kt)(SY,(0,p.Z)({},IY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The length of the array."))}BY.isMDXComponent=!0;const GY={toc:[]},EY="wrapper";function OY(t){let{components:e,...n}=t;return(0,s.kt)(EY,(0,p.Z)({},GY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(3, 7); // [3, 4, 5, 6]\nconst array2 = range(7, 3); // [7, 6, 5, 4]\n")))}OY.isMDXComponent=!0;const FY={toc:[]},UY="wrapper";function VY(t){let{components:e,...n}=t;return(0,s.kt)(UY,(0,p.Z)({},FY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}VY.isMDXComponent=!0;const qY={toc:[]},jY="wrapper";function YY(t){let{components:e,...n}=t;return(0,s.kt)(jY,(0,p.Z)({},qY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}YY.isMDXComponent=!0;const QY={toc:[]},HY="wrapper";function KY(t){let{components:e,...n}=t;return(0,s.kt)(HY,(0,p.Z)({},QY,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}KY.isMDXComponent=!0;const $Y={toc:[]},JY="wrapper";function tQ(t){let{components:e,...n}=t;return(0,s.kt)(JY,(0,p.Z)({},$Y,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\nconst array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n")))}tQ.isMDXComponent=!0;const eQ={toc:[]},nQ="wrapper";function oQ(t){let{components:e,...n}=t;return(0,s.kt)(nQ,(0,p.Z)({},eQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an array containing a range of numbers."))}oQ.isMDXComponent=!0;const pQ={toc:[]},rQ="wrapper";function sQ(t){let{components:e,...n}=t;return(0,s.kt)(rQ,(0,p.Z)({},pQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start of the range."))}sQ.isMDXComponent=!0;const cQ={toc:[]},aQ="wrapper";function iQ(t){let{components:e,...n}=t;return(0,s.kt)(aQ,(0,p.Z)({},cQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end of the range. ",(0,s.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}iQ.isMDXComponent=!0;const lQ={toc:[]},uQ="wrapper";function mQ(t){let{components:e,...n}=t;return(0,s.kt)(uQ,(0,p.Z)({},lQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value by which to increment or decrement."))}mQ.isMDXComponent=!0;const dQ={toc:[]},hQ="wrapper";function fQ(t){let{components:e,...n}=t;return(0,s.kt)(hQ,(0,p.Z)({},dQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}fQ.isMDXComponent=!0;const kQ={toc:[]},yQ="wrapper";function DQ(t){let{components:e,...n}=t;return(0,s.kt)(yQ,(0,p.Z)({},kQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context before render."))}DQ.isMDXComponent=!0;const MQ={toc:[]},XQ="wrapper";function _Q(t){let{components:e,...n}=t;return(0,s.kt)(XQ,(0,p.Z)({},MQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}_Q.isMDXComponent=!0;const wQ={toc:[]},TQ="wrapper";function CQ(t){let{components:e,...n}=t;return(0,s.kt)(TQ,(0,p.Z)({},wQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The function that will be provided the context after render."))}CQ.isMDXComponent=!0;const xQ={toc:[]},gQ="wrapper";function vQ(t){let{components:e,...n}=t;return(0,s.kt)(gQ,(0,p.Z)({},xQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}vQ.isMDXComponent=!0;const LQ={toc:[]},ZQ="wrapper";function bQ(t){let{components:e,...n}=t;return(0,s.kt)(ZQ,(0,p.Z)({},LQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}bQ.isMDXComponent=!0;const NQ={toc:[]},zQ="wrapper";function AQ(t){let{components:e,...n}=t;return(0,s.kt)(zQ,(0,p.Z)({},NQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the event in seconds."))}AQ.isMDXComponent=!0;const PQ={toc:[]},WQ="wrapper";function RQ(t){let{components:e,...n}=t;return(0,s.kt)(WQ,(0,p.Z)({},PQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Register a time event and get its duration in seconds."))}RQ.isMDXComponent=!0;const IQ={toc:[]},SQ="wrapper";function BQ(t){let{components:e,...n}=t;return(0,s.kt)(SQ,(0,p.Z)({},IQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The name of the event."))}BQ.isMDXComponent=!0;const GQ={toc:[]},EQ="wrapper";function OQ(t){let{components:e,...n}=t;return(0,s.kt)(EQ,(0,p.Z)({},GQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the playback status."))}OQ.isMDXComponent=!0;const FQ={toc:[]},UQ="wrapper";function VQ(t){let{components:e,...n}=t;return(0,s.kt)(UQ,(0,p.Z)({},FQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the current scene."))}VQ.isMDXComponent=!0;const qQ={toc:[]},jQ="wrapper";function YQ(t){let{components:e,...n}=t;return(0,s.kt)(jQ,(0,p.Z)({},qQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the random number generator for the given seed."))}YQ.isMDXComponent=!0;const QQ={toc:[]},HQ="wrapper";function KQ(t){let{components:e,...n}=t;return(0,s.kt)(HQ,(0,p.Z)({},QQ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The seed for the generator."))}KQ.isMDXComponent=!0;const $Q={toc:[]},JQ="wrapper";function tH(t){let{components:e,...n}=t;return(0,s.kt)(JQ,(0,p.Z)({},$Q,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}tH.isMDXComponent=!0;const eH={toc:[]},nH="wrapper";function oH(t){let{components:e,...n}=t;return(0,s.kt)(nH,(0,p.Z)({},eH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current scene."))}oH.isMDXComponent=!0;const pH={toc:[]},rH="wrapper";function sH(t){let{components:e,...n}=t;return(0,s.kt)(rH,(0,p.Z)({},pH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a reference to the current thread."))}sH.isMDXComponent=!0;const cH={toc:[]},aH="wrapper";function iH(t){let{components:e,...n}=t;return(0,s.kt)(aH,(0,p.Z)({},cH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,s.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,s.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}iH.isMDXComponent=!0;const lH={toc:[]},uH="wrapper";function mH(t){let{components:e,...n}=t;return(0,s.kt)(uH,(0,p.Z)({},lH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}mH.isMDXComponent=!0;const dH={toc:[]},hH="wrapper";function fH(t){let{components:e,...n}=t;return(0,s.kt)(hH,(0,p.Z)({},dH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the real time since the start of the animation."))}fH.isMDXComponent=!0;const kH={toc:[]},yH="wrapper";function DH(t){let{components:e,...n}=t;return(0,s.kt)(yH,(0,p.Z)({},kH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This rewrites a remote url like ",(0,s.kt)("inlineCode",{parentName:"p"},"https://via.placeholder.com/300.png/09f/fff"),"\ninto a URI-Component-Encoded string like\n",(0,s.kt)("inlineCode",{parentName:"p"},"/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff")))}DH.isMDXComponent=!0;const MH={toc:[]},XH="wrapper";function _H(t){let{components:e,...n}=t;return(0,s.kt)(XH,(0,p.Z)({},MH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Route the given url through a local proxy."))}_H.isMDXComponent=!0;const wH={toc:[]},TH="wrapper";function CH(t){let{components:e,...n}=t;return(0,s.kt)(TH,(0,p.Z)({},wH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}CH.isMDXComponent=!0;const xH={toc:[]},gH="wrapper";function vH(t){let{components:e,...n}=t;return(0,s.kt)(gH,(0,p.Z)({},xH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}vH.isMDXComponent=!0;const LH={toc:[]},ZH="wrapper";function bH(t){let{components:e,...n}=t;return(0,s.kt)(ZH,(0,p.Z)({},LH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}bH.isMDXComponent=!0;const NH={toc:[]},zH="wrapper";function AH(t){let{components:e,...n}=t;return(0,s.kt)(zH,(0,p.Z)({},NH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}AH.isMDXComponent=!0;const PH={toc:[]},WH="wrapper";function RH(t){let{components:e,...n}=t;return(0,s.kt)(WH,(0,p.Z)({},PH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}RH.isMDXComponent=!0;const IH={toc:[]},SH="wrapper";function BH(t){let{components:e,...n}=t;return(0,s.kt)(SH,(0,p.Z)({},IH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}BH.isMDXComponent=!0;const GH={toc:[]},EH="wrapper";function OH(t){let{components:e,...n}=t;return(0,s.kt)(EH,(0,p.Z)({},GH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}OH.isMDXComponent=!0;const FH={toc:[]},UH="wrapper";function VH(t){let{components:e,...n}=t;return(0,s.kt)(UH,(0,p.Z)({},FH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}VH.isMDXComponent=!0;const qH={toc:[]},jH="wrapper";function YH(t){let{components:e,...n}=t;return(0,s.kt)(jH,(0,p.Z)({},qH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}YH.isMDXComponent=!0;const QH={toc:[]},HH="wrapper";function KH(t){let{components:e,...n}=t;return(0,s.kt)(HH,(0,p.Z)({},QH,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}KH.isMDXComponent=!0;const $H={toc:[]},JH="wrapper";function tK(t){let{components:e,...n}=t;return(0,s.kt)(JH,(0,p.Z)({},$H,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}tK.isMDXComponent=!0;const eK={toc:[]},nK="wrapper";function oK(t){let{components:e,...n}=t;return(0,s.kt)(nK,(0,p.Z)({},eK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}oK.isMDXComponent=!0;const pK={toc:[]},rK="wrapper";function sK(t){let{components:e,...n}=t;return(0,s.kt)(rK,(0,p.Z)({},pK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}sK.isMDXComponent=!0;const cK={toc:[]},aK="wrapper";function iK(t){let{components:e,...n}=t;return(0,s.kt)(aK,(0,p.Z)({},cK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}iK.isMDXComponent=!0;const lK={toc:[]},uK="wrapper";function mK(t){let{components:e,...n}=t;return(0,s.kt)(uK,(0,p.Z)({},lK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}mK.isMDXComponent=!0;const dK={toc:[]},hK="wrapper";function fK(t){let{components:e,...n}=t;return(0,s.kt)(hK,(0,p.Z)({},dK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}fK.isMDXComponent=!0;const kK={toc:[]},yK="wrapper";function DK(t){let{components:e,...n}=t;return(0,s.kt)(yK,(0,p.Z)({},kK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}DK.isMDXComponent=!0;const MK={toc:[]},XK="wrapper";function _K(t){let{components:e,...n}=t;return(0,s.kt)(XK,(0,p.Z)({},MK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}_K.isMDXComponent=!0;const wK={toc:[]},TK="wrapper";function CK(t){let{components:e,...n}=t;return(0,s.kt)(TK,(0,p.Z)({},wK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}CK.isMDXComponent=!0;const xK={toc:[]},gK="wrapper";function vK(t){let{components:e,...n}=t;return(0,s.kt)(gK,(0,p.Z)({},xK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}vK.isMDXComponent=!0;const LK={toc:[]},ZK="wrapper";function bK(t){let{components:e,...n}=t;return(0,s.kt)(ZK,(0,p.Z)({},LK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}bK.isMDXComponent=!0;const NK={toc:[]},zK="wrapper";function AK(t){let{components:e,...n}=t;return(0,s.kt)(zK,(0,p.Z)({},NK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}AK.isMDXComponent=!0;const PK={toc:[]},WK="wrapper";function RK(t){let{components:e,...n}=t;return(0,s.kt)(WK,(0,p.Z)({},PK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}RK.isMDXComponent=!0;const IK={toc:[]},SK="wrapper";function BK(t){let{components:e,...n}=t;return(0,s.kt)(SK,(0,p.Z)({},IK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}BK.isMDXComponent=!0;const GK={toc:[]},EK="wrapper";function OK(t){let{components:e,...n}=t;return(0,s.kt)(EK,(0,p.Z)({},GK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}OK.isMDXComponent=!0;const FK={toc:[]},UK="wrapper";function VK(t){let{components:e,...n}=t;return(0,s.kt)(UK,(0,p.Z)({},FK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}VK.isMDXComponent=!0;const qK={toc:[]},jK="wrapper";function YK(t){let{components:e,...n}=t;return(0,s.kt)(jK,(0,p.Z)({},qK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}YK.isMDXComponent=!0;const QK={toc:[]},HK="wrapper";function KK(t){let{components:e,...n}=t;return(0,s.kt)(HK,(0,p.Z)({},QK,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}KK.isMDXComponent=!0;const $K={toc:[]},JK="wrapper";function t$(t){let{components:e,...n}=t;return(0,s.kt)(JK,(0,p.Z)({},$K,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}t$.isMDXComponent=!0;const e$={toc:[]},n$="wrapper";function o$(t){let{components:e,...n}=t;return(0,s.kt)(n$,(0,p.Z)({},e$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}o$.isMDXComponent=!0;const p$={toc:[]},r$="wrapper";function s$(t){let{components:e,...n}=t;return(0,s.kt)(r$,(0,p.Z)({},p$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}s$.isMDXComponent=!0;const c$={toc:[]},a$="wrapper";function i$(t){let{components:e,...n}=t;return(0,s.kt)(a$,(0,p.Z)({},c$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}i$.isMDXComponent=!0;const l$={toc:[]},u$="wrapper";function m$(t){let{components:e,...n}=t;return(0,s.kt)(u$,(0,p.Z)({},l$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}m$.isMDXComponent=!0;const d$={toc:[]},h$="wrapper";function f$(t){let{components:e,...n}=t;return(0,s.kt)(h$,(0,p.Z)({},d$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}f$.isMDXComponent=!0;const k$={toc:[]},y$="wrapper";function D$(t){let{components:e,...n}=t;return(0,s.kt)(y$,(0,p.Z)({},k$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}D$.isMDXComponent=!0;const M$={toc:[]},X$="wrapper";function _$(t){let{components:e,...n}=t;return(0,s.kt)(X$,(0,p.Z)({},M$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}_$.isMDXComponent=!0;const w$={toc:[]},T$="wrapper";function C$(t){let{components:e,...n}=t;return(0,s.kt)(T$,(0,p.Z)({},w$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}C$.isMDXComponent=!0;const x$={toc:[]},g$="wrapper";function v$(t){let{components:e,...n}=t;return(0,s.kt)(g$,(0,p.Z)({},x$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}v$.isMDXComponent=!0;const L$={toc:[]},Z$="wrapper";function b$(t){let{components:e,...n}=t;return(0,s.kt)(Z$,(0,p.Z)({},L$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}b$.isMDXComponent=!0;const N$={toc:[]},z$="wrapper";function A$(t){let{components:e,...n}=t;return(0,s.kt)(z$,(0,p.Z)({},N$,n,{components:e,mdxType:"MDXLayout"}))}A$.isMDXComponent=!0;const P$={toc:[]},W$="wrapper";function R$(t){let{components:e,...n}=t;return(0,s.kt)(W$,(0,p.Z)({},P$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}R$.isMDXComponent=!0;const I$={toc:[]},S$="wrapper";function B$(t){let{components:e,...n}=t;return(0,s.kt)(S$,(0,p.Z)({},I$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}B$.isMDXComponent=!0;const G$={toc:[]},E$="wrapper";function O$(t){let{components:e,...n}=t;return(0,s.kt)(E$,(0,p.Z)({},G$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}O$.isMDXComponent=!0;const F$={toc:[]},U$="wrapper";function V$(t){let{components:e,...n}=t;return(0,s.kt)(U$,(0,p.Z)({},F$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}V$.isMDXComponent=!0;const q$={toc:[]},j$="wrapper";function Y$(t){let{components:e,...n}=t;return(0,s.kt)(j$,(0,p.Z)({},q$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Y$.isMDXComponent=!0;const Q$={toc:[]},H$="wrapper";function K$(t){let{components:e,...n}=t;return(0,s.kt)(H$,(0,p.Z)({},Q$,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}K$.isMDXComponent=!0;const $$={toc:[]},J$="wrapper";function tJ(t){let{components:e,...n}=t;return(0,s.kt)(J$,(0,p.Z)({},$$,n,{components:e,mdxType:"MDXLayout"}))}tJ.isMDXComponent=!0;const eJ={toc:[]},nJ="wrapper";function oJ(t){let{components:e,...n}=t;return(0,s.kt)(nJ,(0,p.Z)({},eJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}oJ.isMDXComponent=!0;const pJ={toc:[]},rJ="wrapper";function sJ(t){let{components:e,...n}=t;return(0,s.kt)(rJ,(0,p.Z)({},pJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}sJ.isMDXComponent=!0;const cJ={toc:[]},aJ="wrapper";function iJ(t){let{components:e,...n}=t;return(0,s.kt)(aJ,(0,p.Z)({},cJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}iJ.isMDXComponent=!0;const lJ={toc:[]},uJ="wrapper";function mJ(t){let{components:e,...n}=t;return(0,s.kt)(uJ,(0,p.Z)({},lJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}mJ.isMDXComponent=!0;const dJ={toc:[]},hJ="wrapper";function fJ(t){let{components:e,...n}=t;return(0,s.kt)(hJ,(0,p.Z)({},dJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}fJ.isMDXComponent=!0;const kJ={toc:[]},yJ="wrapper";function DJ(t){let{components:e,...n}=t;return(0,s.kt)(yJ,(0,p.Z)({},kJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}DJ.isMDXComponent=!0;const MJ={toc:[]},XJ="wrapper";function _J(t){let{components:e,...n}=t;return(0,s.kt)(XJ,(0,p.Z)({},MJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}_J.isMDXComponent=!0;const wJ={toc:[]},TJ="wrapper";function CJ(t){let{components:e,...n}=t;return(0,s.kt)(TJ,(0,p.Z)({},wJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}CJ.isMDXComponent=!0;const xJ={toc:[]},gJ="wrapper";function vJ(t){let{components:e,...n}=t;return(0,s.kt)(gJ,(0,p.Z)({},xJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}vJ.isMDXComponent=!0;const LJ={toc:[]},ZJ="wrapper";function bJ(t){let{components:e,...n}=t;return(0,s.kt)(ZJ,(0,p.Z)({},LJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}bJ.isMDXComponent=!0;const NJ={toc:[]},zJ="wrapper";function AJ(t){let{components:e,...n}=t;return(0,s.kt)(zJ,(0,p.Z)({},NJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}AJ.isMDXComponent=!0;const PJ={toc:[]},WJ="wrapper";function RJ(t){let{components:e,...n}=t;return(0,s.kt)(WJ,(0,p.Z)({},PJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}RJ.isMDXComponent=!0;const IJ={toc:[]},SJ="wrapper";function BJ(t){let{components:e,...n}=t;return(0,s.kt)(SJ,(0,p.Z)({},IJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}BJ.isMDXComponent=!0;const GJ={toc:[]},EJ="wrapper";function OJ(t){let{components:e,...n}=t;return(0,s.kt)(EJ,(0,p.Z)({},GJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}OJ.isMDXComponent=!0;const FJ={toc:[]},UJ="wrapper";function VJ(t){let{components:e,...n}=t;return(0,s.kt)(UJ,(0,p.Z)({},FJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}VJ.isMDXComponent=!0;const qJ={toc:[]},jJ="wrapper";function YJ(t){let{components:e,...n}=t;return(0,s.kt)(jJ,(0,p.Z)({},qJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}YJ.isMDXComponent=!0;const QJ={toc:[]},HJ="wrapper";function KJ(t){let{components:e,...n}=t;return(0,s.kt)(HJ,(0,p.Z)({},QJ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}KJ.isMDXComponent=!0;const $J={toc:[]},JJ="wrapper";function t0(t){let{components:e,...n}=t;return(0,s.kt)(JJ,(0,p.Z)({},$J,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}t0.isMDXComponent=!0;const e0={toc:[]},n0="wrapper";function o0(t){let{components:e,...n}=t;return(0,s.kt)(n0,(0,p.Z)({},e0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}o0.isMDXComponent=!0;const p0={toc:[]},r0="wrapper";function s0(t){let{components:e,...n}=t;return(0,s.kt)(r0,(0,p.Z)({},p0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}s0.isMDXComponent=!0;const c0={toc:[]},a0="wrapper";function i0(t){let{components:e,...n}=t;return(0,s.kt)(a0,(0,p.Z)({},c0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}i0.isMDXComponent=!0;const l0={toc:[]},u0="wrapper";function m0(t){let{components:e,...n}=t;return(0,s.kt)(u0,(0,p.Z)({},l0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}m0.isMDXComponent=!0;const d0={toc:[]},h0="wrapper";function f0(t){let{components:e,...n}=t;return(0,s.kt)(h0,(0,p.Z)({},d0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}f0.isMDXComponent=!0;const k0={toc:[]},y0="wrapper";function D0(t){let{components:e,...n}=t;return(0,s.kt)(y0,(0,p.Z)({},k0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}D0.isMDXComponent=!0;const M0={toc:[]},X0="wrapper";function _0(t){let{components:e,...n}=t;return(0,s.kt)(X0,(0,p.Z)({},M0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}_0.isMDXComponent=!0;const w0={toc:[]},T0="wrapper";function C0(t){let{components:e,...n}=t;return(0,s.kt)(T0,(0,p.Z)({},w0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}C0.isMDXComponent=!0;const x0={toc:[]},g0="wrapper";function v0(t){let{components:e,...n}=t;return(0,s.kt)(g0,(0,p.Z)({},x0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}v0.isMDXComponent=!0;const L0={toc:[]},Z0="wrapper";function b0(t){let{components:e,...n}=t;return(0,s.kt)(Z0,(0,p.Z)({},L0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}b0.isMDXComponent=!0;const N0={toc:[]},z0="wrapper";function A0(t){let{components:e,...n}=t;return(0,s.kt)(z0,(0,p.Z)({},N0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}A0.isMDXComponent=!0;const P0={toc:[]},W0="wrapper";function R0(t){let{components:e,...n}=t;return(0,s.kt)(W0,(0,p.Z)({},P0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}R0.isMDXComponent=!0;const I0={toc:[]},S0="wrapper";function B0(t){let{components:e,...n}=t;return(0,s.kt)(S0,(0,p.Z)({},I0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}B0.isMDXComponent=!0;const G0={toc:[]},E0="wrapper";function O0(t){let{components:e,...n}=t;return(0,s.kt)(E0,(0,p.Z)({},G0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}O0.isMDXComponent=!0;const F0={toc:[]},U0="wrapper";function V0(t){let{components:e,...n}=t;return(0,s.kt)(U0,(0,p.Z)({},F0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}V0.isMDXComponent=!0;const q0={toc:[]},j0="wrapper";function Y0(t){let{components:e,...n}=t;return(0,s.kt)(j0,(0,p.Z)({},q0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Y0.isMDXComponent=!0;const Q0={toc:[]},H0="wrapper";function K0(t){let{components:e,...n}=t;return(0,s.kt)(H0,(0,p.Z)({},Q0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}K0.isMDXComponent=!0;const $0={toc:[]},J0="wrapper";function t4(t){let{components:e,...n}=t;return(0,s.kt)(J0,(0,p.Z)({},$0,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}t4.isMDXComponent=!0;const e4={toc:[]},n4="wrapper";function o4(t){let{components:e,...n}=t;return(0,s.kt)(n4,(0,p.Z)({},e4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}o4.isMDXComponent=!0;const p4={toc:[]},r4="wrapper";function s4(t){let{components:e,...n}=t;return(0,s.kt)(r4,(0,p.Z)({},p4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}s4.isMDXComponent=!0;const c4={toc:[]},a4="wrapper";function i4(t){let{components:e,...n}=t;return(0,s.kt)(a4,(0,p.Z)({},c4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}i4.isMDXComponent=!0;const l4={toc:[]},u4="wrapper";function m4(t){let{components:e,...n}=t;return(0,s.kt)(u4,(0,p.Z)({},l4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}m4.isMDXComponent=!0;const d4={toc:[]},h4="wrapper";function f4(t){let{components:e,...n}=t;return(0,s.kt)(h4,(0,p.Z)({},d4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}f4.isMDXComponent=!0;const k4={toc:[]},y4="wrapper";function D4(t){let{components:e,...n}=t;return(0,s.kt)(y4,(0,p.Z)({},k4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}D4.isMDXComponent=!0;const M4={toc:[]},X4="wrapper";function _4(t){let{components:e,...n}=t;return(0,s.kt)(X4,(0,p.Z)({},M4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}_4.isMDXComponent=!0;const w4={toc:[]},T4="wrapper";function C4(t){let{components:e,...n}=t;return(0,s.kt)(T4,(0,p.Z)({},w4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}C4.isMDXComponent=!0;const x4={toc:[]},g4="wrapper";function v4(t){let{components:e,...n}=t;return(0,s.kt)(g4,(0,p.Z)({},x4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}v4.isMDXComponent=!0;const L4={toc:[]},Z4="wrapper";function b4(t){let{components:e,...n}=t;return(0,s.kt)(Z4,(0,p.Z)({},L4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}b4.isMDXComponent=!0;const N4={toc:[]},z4="wrapper";function A4(t){let{components:e,...n}=t;return(0,s.kt)(z4,(0,p.Z)({},N4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}A4.isMDXComponent=!0;const P4={toc:[]},W4="wrapper";function R4(t){let{components:e,...n}=t;return(0,s.kt)(W4,(0,p.Z)({},P4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}R4.isMDXComponent=!0;const I4={toc:[]},S4="wrapper";function B4(t){let{components:e,...n}=t;return(0,s.kt)(S4,(0,p.Z)({},I4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}B4.isMDXComponent=!0;const G4={toc:[]},E4="wrapper";function O4(t){let{components:e,...n}=t;return(0,s.kt)(E4,(0,p.Z)({},G4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}O4.isMDXComponent=!0;const F4={toc:[]},U4="wrapper";function V4(t){let{components:e,...n}=t;return(0,s.kt)(U4,(0,p.Z)({},F4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}V4.isMDXComponent=!0;const q4={toc:[]},j4="wrapper";function Y4(t){let{components:e,...n}=t;return(0,s.kt)(j4,(0,p.Z)({},q4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Y4.isMDXComponent=!0;const Q4={toc:[]},H4="wrapper";function K4(t){let{components:e,...n}=t;return(0,s.kt)(H4,(0,p.Z)({},Q4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}K4.isMDXComponent=!0;const $4={toc:[]},J4="wrapper";function t6(t){let{components:e,...n}=t;return(0,s.kt)(J4,(0,p.Z)({},$4,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}t6.isMDXComponent=!0;const e6={toc:[]},n6="wrapper";function o6(t){let{components:e,...n}=t;return(0,s.kt)(n6,(0,p.Z)({},e6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}o6.isMDXComponent=!0;const p6={toc:[]},r6="wrapper";function s6(t){let{components:e,...n}=t;return(0,s.kt)(r6,(0,p.Z)({},p6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}s6.isMDXComponent=!0;const c6={toc:[]},a6="wrapper";function i6(t){let{components:e,...n}=t;return(0,s.kt)(a6,(0,p.Z)({},c6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}i6.isMDXComponent=!0;const l6={toc:[]},u6="wrapper";function m6(t){let{components:e,...n}=t;return(0,s.kt)(u6,(0,p.Z)({},l6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}m6.isMDXComponent=!0;const d6={toc:[]},h6="wrapper";function f6(t){let{components:e,...n}=t;return(0,s.kt)(h6,(0,p.Z)({},d6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}f6.isMDXComponent=!0;const k6={toc:[]},y6="wrapper";function D6(t){let{components:e,...n}=t;return(0,s.kt)(y6,(0,p.Z)({},k6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}D6.isMDXComponent=!0;const M6={toc:[]},X6="wrapper";function _6(t){let{components:e,...n}=t;return(0,s.kt)(X6,(0,p.Z)({},M6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}_6.isMDXComponent=!0;const w6={toc:[]},T6="wrapper";function C6(t){let{components:e,...n}=t;return(0,s.kt)(T6,(0,p.Z)({},w6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}C6.isMDXComponent=!0;const x6={toc:[]},g6="wrapper";function v6(t){let{components:e,...n}=t;return(0,s.kt)(g6,(0,p.Z)({},x6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}v6.isMDXComponent=!0;const L6={toc:[]},Z6="wrapper";function b6(t){let{components:e,...n}=t;return(0,s.kt)(Z6,(0,p.Z)({},L6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}b6.isMDXComponent=!0;const N6={toc:[]},z6="wrapper";function A6(t){let{components:e,...n}=t;return(0,s.kt)(z6,(0,p.Z)({},N6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}A6.isMDXComponent=!0;const P6={toc:[]},W6="wrapper";function R6(t){let{components:e,...n}=t;return(0,s.kt)(W6,(0,p.Z)({},P6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}R6.isMDXComponent=!0;const I6={toc:[]},S6="wrapper";function B6(t){let{components:e,...n}=t;return(0,s.kt)(S6,(0,p.Z)({},I6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}B6.isMDXComponent=!0;const G6={toc:[]},E6="wrapper";function O6(t){let{components:e,...n}=t;return(0,s.kt)(E6,(0,p.Z)({},G6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}O6.isMDXComponent=!0;const F6={toc:[]},U6="wrapper";function V6(t){let{components:e,...n}=t;return(0,s.kt)(U6,(0,p.Z)({},F6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}V6.isMDXComponent=!0;const q6={toc:[]},j6="wrapper";function Y6(t){let{components:e,...n}=t;return(0,s.kt)(j6,(0,p.Z)({},q6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Y6.isMDXComponent=!0;const Q6={toc:[]},H6="wrapper";function K6(t){let{components:e,...n}=t;return(0,s.kt)(H6,(0,p.Z)({},Q6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}K6.isMDXComponent=!0;const $6={toc:[]},J6="wrapper";function t3(t){let{components:e,...n}=t;return(0,s.kt)(J6,(0,p.Z)({},$6,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}t3.isMDXComponent=!0;const e3={toc:[]},n3="wrapper";function o3(t){let{components:e,...n}=t;return(0,s.kt)(n3,(0,p.Z)({},e3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}o3.isMDXComponent=!0;const p3={toc:[]},r3="wrapper";function s3(t){let{components:e,...n}=t;return(0,s.kt)(r3,(0,p.Z)({},p3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}s3.isMDXComponent=!0;const c3={toc:[]},a3="wrapper";function i3(t){let{components:e,...n}=t;return(0,s.kt)(a3,(0,p.Z)({},c3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}i3.isMDXComponent=!0;const l3={toc:[]},u3="wrapper";function m3(t){let{components:e,...n}=t;return(0,s.kt)(u3,(0,p.Z)({},l3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}m3.isMDXComponent=!0;const d3={toc:[]},h3="wrapper";function f3(t){let{components:e,...n}=t;return(0,s.kt)(h3,(0,p.Z)({},d3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}f3.isMDXComponent=!0;const k3={toc:[]},y3="wrapper";function D3(t){let{components:e,...n}=t;return(0,s.kt)(y3,(0,p.Z)({},k3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}D3.isMDXComponent=!0;const M3={toc:[]},X3="wrapper";function _3(t){let{components:e,...n}=t;return(0,s.kt)(X3,(0,p.Z)({},M3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}_3.isMDXComponent=!0;const w3={toc:[]},T3="wrapper";function C3(t){let{components:e,...n}=t;return(0,s.kt)(T3,(0,p.Z)({},w3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}C3.isMDXComponent=!0;const x3={toc:[]},g3="wrapper";function v3(t){let{components:e,...n}=t;return(0,s.kt)(g3,(0,p.Z)({},x3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}v3.isMDXComponent=!0;const L3={toc:[]},Z3="wrapper";function b3(t){let{components:e,...n}=t;return(0,s.kt)(Z3,(0,p.Z)({},L3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}b3.isMDXComponent=!0;const N3={toc:[]},z3="wrapper";function A3(t){let{components:e,...n}=t;return(0,s.kt)(z3,(0,p.Z)({},N3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}A3.isMDXComponent=!0;const P3={toc:[]},W3="wrapper";function R3(t){let{components:e,...n}=t;return(0,s.kt)(W3,(0,p.Z)({},P3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}R3.isMDXComponent=!0;const I3={toc:[]},S3="wrapper";function B3(t){let{components:e,...n}=t;return(0,s.kt)(S3,(0,p.Z)({},I3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}B3.isMDXComponent=!0;const G3={toc:[]},E3="wrapper";function O3(t){let{components:e,...n}=t;return(0,s.kt)(E3,(0,p.Z)({},G3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}O3.isMDXComponent=!0;const F3={toc:[]},U3="wrapper";function V3(t){let{components:e,...n}=t;return(0,s.kt)(U3,(0,p.Z)({},F3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}V3.isMDXComponent=!0;const q3={toc:[]},j3="wrapper";function Y3(t){let{components:e,...n}=t;return(0,s.kt)(j3,(0,p.Z)({},q3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Y3.isMDXComponent=!0;const Q3={toc:[]},H3="wrapper";function K3(t){let{components:e,...n}=t;return(0,s.kt)(H3,(0,p.Z)({},Q3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}K3.isMDXComponent=!0;const $3={toc:[]},J3="wrapper";function t7(t){let{components:e,...n}=t;return(0,s.kt)(J3,(0,p.Z)({},$3,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}t7.isMDXComponent=!0;const e7={toc:[]},n7="wrapper";function o7(t){let{components:e,...n}=t;return(0,s.kt)(n7,(0,p.Z)({},e7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}o7.isMDXComponent=!0;const p7={toc:[]},r7="wrapper";function s7(t){let{components:e,...n}=t;return(0,s.kt)(r7,(0,p.Z)({},p7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}s7.isMDXComponent=!0;const c7={toc:[]},a7="wrapper";function i7(t){let{components:e,...n}=t;return(0,s.kt)(a7,(0,p.Z)({},c7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}i7.isMDXComponent=!0;const l7={toc:[]},u7="wrapper";function m7(t){let{components:e,...n}=t;return(0,s.kt)(u7,(0,p.Z)({},l7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}m7.isMDXComponent=!0;const d7={toc:[]},h7="wrapper";function f7(t){let{components:e,...n}=t;return(0,s.kt)(h7,(0,p.Z)({},d7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}f7.isMDXComponent=!0;const k7={toc:[]},y7="wrapper";function D7(t){let{components:e,...n}=t;return(0,s.kt)(y7,(0,p.Z)({},k7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}D7.isMDXComponent=!0;const M7={toc:[]},X7="wrapper";function _7(t){let{components:e,...n}=t;return(0,s.kt)(X7,(0,p.Z)({},M7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}_7.isMDXComponent=!0;const w7={toc:[]},T7="wrapper";function C7(t){let{components:e,...n}=t;return(0,s.kt)(T7,(0,p.Z)({},w7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}C7.isMDXComponent=!0;const x7={toc:[]},g7="wrapper";function v7(t){let{components:e,...n}=t;return(0,s.kt)(g7,(0,p.Z)({},x7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}v7.isMDXComponent=!0;const L7={toc:[]},Z7="wrapper";function b7(t){let{components:e,...n}=t;return(0,s.kt)(Z7,(0,p.Z)({},L7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}b7.isMDXComponent=!0;const N7={toc:[]},z7="wrapper";function A7(t){let{components:e,...n}=t;return(0,s.kt)(z7,(0,p.Z)({},N7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}A7.isMDXComponent=!0;const P7={toc:[]},W7="wrapper";function R7(t){let{components:e,...n}=t;return(0,s.kt)(W7,(0,p.Z)({},P7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}R7.isMDXComponent=!0;const I7={toc:[]},S7="wrapper";function B7(t){let{components:e,...n}=t;return(0,s.kt)(S7,(0,p.Z)({},I7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}B7.isMDXComponent=!0;const G7={toc:[]},E7="wrapper";function O7(t){let{components:e,...n}=t;return(0,s.kt)(E7,(0,p.Z)({},G7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}O7.isMDXComponent=!0;const F7={toc:[]},U7="wrapper";function V7(t){let{components:e,...n}=t;return(0,s.kt)(U7,(0,p.Z)({},F7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}V7.isMDXComponent=!0;const q7={toc:[]},j7="wrapper";function Y7(t){let{components:e,...n}=t;return(0,s.kt)(j7,(0,p.Z)({},q7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Y7.isMDXComponent=!0;const Q7={toc:[]},H7="wrapper";function K7(t){let{components:e,...n}=t;return(0,s.kt)(H7,(0,p.Z)({},Q7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}K7.isMDXComponent=!0;const $7={toc:[]},J7="wrapper";function t2(t){let{components:e,...n}=t;return(0,s.kt)(J7,(0,p.Z)({},$7,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}t2.isMDXComponent=!0;const e2={toc:[]},n2="wrapper";function o2(t){let{components:e,...n}=t;return(0,s.kt)(n2,(0,p.Z)({},e2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}o2.isMDXComponent=!0;const p2={toc:[]},r2="wrapper";function s2(t){let{components:e,...n}=t;return(0,s.kt)(r2,(0,p.Z)({},p2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}s2.isMDXComponent=!0;const c2={toc:[]},a2="wrapper";function i2(t){let{components:e,...n}=t;return(0,s.kt)(a2,(0,p.Z)({},c2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}i2.isMDXComponent=!0;const l2={toc:[]},u2="wrapper";function m2(t){let{components:e,...n}=t;return(0,s.kt)(u2,(0,p.Z)({},l2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}m2.isMDXComponent=!0;const d2={toc:[]},h2="wrapper";function f2(t){let{components:e,...n}=t;return(0,s.kt)(h2,(0,p.Z)({},d2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}f2.isMDXComponent=!0;const k2={toc:[]},y2="wrapper";function D2(t){let{components:e,...n}=t;return(0,s.kt)(y2,(0,p.Z)({},k2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}D2.isMDXComponent=!0;const M2={toc:[]},X2="wrapper";function _2(t){let{components:e,...n}=t;return(0,s.kt)(X2,(0,p.Z)({},M2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}_2.isMDXComponent=!0;const w2={toc:[]},T2="wrapper";function C2(t){let{components:e,...n}=t;return(0,s.kt)(T2,(0,p.Z)({},w2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}C2.isMDXComponent=!0;const x2={toc:[]},g2="wrapper";function v2(t){let{components:e,...n}=t;return(0,s.kt)(g2,(0,p.Z)({},x2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}v2.isMDXComponent=!0;const L2={toc:[]},Z2="wrapper";function b2(t){let{components:e,...n}=t;return(0,s.kt)(Z2,(0,p.Z)({},L2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}b2.isMDXComponent=!0;const N2={toc:[]},z2="wrapper";function A2(t){let{components:e,...n}=t;return(0,s.kt)(z2,(0,p.Z)({},N2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}A2.isMDXComponent=!0;const P2={toc:[]},W2="wrapper";function R2(t){let{components:e,...n}=t;return(0,s.kt)(W2,(0,p.Z)({},P2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}R2.isMDXComponent=!0;const I2={toc:[]},S2="wrapper";function B2(t){let{components:e,...n}=t;return(0,s.kt)(S2,(0,p.Z)({},I2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}B2.isMDXComponent=!0;const G2={toc:[]},E2="wrapper";function O2(t){let{components:e,...n}=t;return(0,s.kt)(E2,(0,p.Z)({},G2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}O2.isMDXComponent=!0;const F2={toc:[]},U2="wrapper";function V2(t){let{components:e,...n}=t;return(0,s.kt)(U2,(0,p.Z)({},F2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}V2.isMDXComponent=!0;const q2={toc:[]},j2="wrapper";function Y2(t){let{components:e,...n}=t;return(0,s.kt)(j2,(0,p.Z)({},q2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Y2.isMDXComponent=!0;const Q2={toc:[]},H2="wrapper";function K2(t){let{components:e,...n}=t;return(0,s.kt)(H2,(0,p.Z)({},Q2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}K2.isMDXComponent=!0;const $2={toc:[]},J2="wrapper";function t1(t){let{components:e,...n}=t;return(0,s.kt)(J2,(0,p.Z)({},$2,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}t1.isMDXComponent=!0;const e1={toc:[]},n1="wrapper";function o1(t){let{components:e,...n}=t;return(0,s.kt)(n1,(0,p.Z)({},e1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}o1.isMDXComponent=!0;const p1={toc:[]},r1="wrapper";function s1(t){let{components:e,...n}=t;return(0,s.kt)(r1,(0,p.Z)({},p1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}s1.isMDXComponent=!0;const c1={toc:[]},a1="wrapper";function i1(t){let{components:e,...n}=t;return(0,s.kt)(a1,(0,p.Z)({},c1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}i1.isMDXComponent=!0;const l1={toc:[]},u1="wrapper";function m1(t){let{components:e,...n}=t;return(0,s.kt)(u1,(0,p.Z)({},l1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}m1.isMDXComponent=!0;const d1={toc:[]},h1="wrapper";function f1(t){let{components:e,...n}=t;return(0,s.kt)(h1,(0,p.Z)({},d1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}f1.isMDXComponent=!0;const k1={toc:[]},y1="wrapper";function D1(t){let{components:e,...n}=t;return(0,s.kt)(y1,(0,p.Z)({},k1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}D1.isMDXComponent=!0;const M1={toc:[]},X1="wrapper";function _1(t){let{components:e,...n}=t;return(0,s.kt)(X1,(0,p.Z)({},M1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}_1.isMDXComponent=!0;const w1={toc:[]},T1="wrapper";function C1(t){let{components:e,...n}=t;return(0,s.kt)(T1,(0,p.Z)({},w1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}C1.isMDXComponent=!0;const x1={toc:[]},g1="wrapper";function v1(t){let{components:e,...n}=t;return(0,s.kt)(g1,(0,p.Z)({},x1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}v1.isMDXComponent=!0;const L1={toc:[]},Z1="wrapper";function b1(t){let{components:e,...n}=t;return(0,s.kt)(Z1,(0,p.Z)({},L1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}b1.isMDXComponent=!0;const N1={toc:[]},z1="wrapper";function A1(t){let{components:e,...n}=t;return(0,s.kt)(z1,(0,p.Z)({},N1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}A1.isMDXComponent=!0;const P1={toc:[]},W1="wrapper";function R1(t){let{components:e,...n}=t;return(0,s.kt)(W1,(0,p.Z)({},P1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}R1.isMDXComponent=!0;const I1={toc:[]},S1="wrapper";function B1(t){let{components:e,...n}=t;return(0,s.kt)(S1,(0,p.Z)({},I1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}B1.isMDXComponent=!0;const G1={toc:[]},E1="wrapper";function O1(t){let{components:e,...n}=t;return(0,s.kt)(E1,(0,p.Z)({},G1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}O1.isMDXComponent=!0;const F1={toc:[]},U1="wrapper";function V1(t){let{components:e,...n}=t;return(0,s.kt)(U1,(0,p.Z)({},F1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}V1.isMDXComponent=!0;const q1={toc:[]},j1="wrapper";function Y1(t){let{components:e,...n}=t;return(0,s.kt)(j1,(0,p.Z)({},q1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Y1.isMDXComponent=!0;const Q1={toc:[]},H1="wrapper";function K1(t){let{components:e,...n}=t;return(0,s.kt)(H1,(0,p.Z)({},Q1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}K1.isMDXComponent=!0;const $1={toc:[]},J1="wrapper";function t8(t){let{components:e,...n}=t;return(0,s.kt)(J1,(0,p.Z)({},$1,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}t8.isMDXComponent=!0;const e8={toc:[]},n8="wrapper";function o8(t){let{components:e,...n}=t;return(0,s.kt)(n8,(0,p.Z)({},e8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}o8.isMDXComponent=!0;const p8={toc:[]},r8="wrapper";function s8(t){let{components:e,...n}=t;return(0,s.kt)(r8,(0,p.Z)({},p8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}s8.isMDXComponent=!0;const c8={toc:[]},a8="wrapper";function i8(t){let{components:e,...n}=t;return(0,s.kt)(a8,(0,p.Z)({},c8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}i8.isMDXComponent=!0;const l8={toc:[]},u8="wrapper";function m8(t){let{components:e,...n}=t;return(0,s.kt)(u8,(0,p.Z)({},l8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}m8.isMDXComponent=!0;const d8={toc:[]},h8="wrapper";function f8(t){let{components:e,...n}=t;return(0,s.kt)(h8,(0,p.Z)({},d8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}f8.isMDXComponent=!0;const k8={toc:[]},y8="wrapper";function D8(t){let{components:e,...n}=t;return(0,s.kt)(y8,(0,p.Z)({},k8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}D8.isMDXComponent=!0;const M8={toc:[]},X8="wrapper";function _8(t){let{components:e,...n}=t;return(0,s.kt)(X8,(0,p.Z)({},M8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}_8.isMDXComponent=!0;const w8={toc:[]},T8="wrapper";function C8(t){let{components:e,...n}=t;return(0,s.kt)(T8,(0,p.Z)({},w8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}C8.isMDXComponent=!0;const x8={toc:[]},g8="wrapper";function v8(t){let{components:e,...n}=t;return(0,s.kt)(g8,(0,p.Z)({},x8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}v8.isMDXComponent=!0;const L8={toc:[]},Z8="wrapper";function b8(t){let{components:e,...n}=t;return(0,s.kt)(Z8,(0,p.Z)({},L8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}b8.isMDXComponent=!0;const N8={toc:[]},z8="wrapper";function A8(t){let{components:e,...n}=t;return(0,s.kt)(z8,(0,p.Z)({},N8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}A8.isMDXComponent=!0;const P8={toc:[]},W8="wrapper";function R8(t){let{components:e,...n}=t;return(0,s.kt)(W8,(0,p.Z)({},P8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}R8.isMDXComponent=!0;const I8={toc:[]},S8="wrapper";function B8(t){let{components:e,...n}=t;return(0,s.kt)(S8,(0,p.Z)({},I8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}B8.isMDXComponent=!0;const G8={toc:[]},E8="wrapper";function O8(t){let{components:e,...n}=t;return(0,s.kt)(E8,(0,p.Z)({},G8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}O8.isMDXComponent=!0;const F8={toc:[]},U8="wrapper";function V8(t){let{components:e,...n}=t;return(0,s.kt)(U8,(0,p.Z)({},F8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}V8.isMDXComponent=!0;const q8={toc:[]},j8="wrapper";function Y8(t){let{components:e,...n}=t;return(0,s.kt)(j8,(0,p.Z)({},q8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Bezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Y8.isMDXComponent=!0;const Q8={toc:[]},H8="wrapper";function K8(t){let{components:e,...n}=t;return(0,s.kt)(H8,(0,p.Z)({},Q8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}K8.isMDXComponent=!0;const $8={toc:[]},J8="wrapper";function t5(t){let{components:e,...n}=t;return(0,s.kt)(J8,(0,p.Z)({},$8,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}t5.isMDXComponent=!0;const e5={toc:[]},n5="wrapper";function o5(t){let{components:e,...n}=t;return(0,s.kt)(n5,(0,p.Z)({},e5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}o5.isMDXComponent=!0;const p5={toc:[]},r5="wrapper";function s5(t){let{components:e,...n}=t;return(0,s.kt)(r5,(0,p.Z)({},p5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}s5.isMDXComponent=!0;const c5={toc:[]},a5="wrapper";function i5(t){let{components:e,...n}=t;return(0,s.kt)(a5,(0,p.Z)({},c5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}i5.isMDXComponent=!0;const l5={toc:[]},u5="wrapper";function m5(t){let{components:e,...n}=t;return(0,s.kt)(u5,(0,p.Z)({},l5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}m5.isMDXComponent=!0;const d5={toc:[]},h5="wrapper";function f5(t){let{components:e,...n}=t;return(0,s.kt)(h5,(0,p.Z)({},d5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: circle, ellipse, arc, and\nsector (pie chart)."))}f5.isMDXComponent=!0;const k5={toc:[]},y5="wrapper";function D5(t){let{components:e,...n}=t;return(0,s.kt)(y5,(0,p.Z)({},k5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple circle\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      size={160}\n      fill={'lightseagreen'}\n    />\n   );\n});\n\n// snippet Ellipse\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Circle\n      width={160}\n      height={80}\n      fill={'lightseagreen'}\n    />\n  );\n});\n\n// snippet Sector (pie chart):\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      fill={'lightseagreen'}\n      startAngle={30}\n      endAngle={270}\n      closed={true}\n    />\n  );\n\n  yield* ref().startAngle(270, 2).to(30, 2);\n});\n\n// snippet Arc:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      startAngle={-90}\n      endAngle={90}\n    />\n  );\n\n  yield* ref().startAngle(-270, 2).to(-90, 2);\n});\n\n// snippet Curve properties:\nimport {makeScene2D, Circle} from '@motion-canvas/2d';\nimport {all, createRef, easeInCubic, easeOutCubic} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Circle>();\n  view.add(\n    <Circle\n      ref={ref}\n      size={160}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      endAngle={270}\n      endArrow\n    />,\n  );\n\n  yield* all(ref().start(1, 1), ref().rotation(180, 1, easeInCubic));\n  ref().start(0).end(0);\n  yield* all(ref().end(1, 1), ref().rotation(360, 1, easeOutCubic));\n});\n")))}D5.isMDXComponent=!0;const M5={toc:[]},X5="wrapper";function _5(t){let{components:e,...n}=t;return(0,s.kt)(X5,(0,p.Z)({},M5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing circular shapes."))}_5.isMDXComponent=!0;const w5={toc:[]},T5="wrapper";function C5(t){let{components:e,...n}=t;return(0,s.kt)(T5,(0,p.Z)({},w5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}C5.isMDXComponent=!0;const x5={toc:[]},g5="wrapper";function v5(t){let{components:e,...n}=t;return(0,s.kt)(g5,(0,p.Z)({},x5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}v5.isMDXComponent=!0;const L5={toc:[]},Z5="wrapper";function b5(t){let{components:e,...n}=t;return(0,s.kt)(Z5,(0,p.Z)({},L5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}b5.isMDXComponent=!0;const N5={toc:[]},z5="wrapper";function A5(t){let{components:e,...n}=t;return(0,s.kt)(z5,(0,p.Z)({},N5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}A5.isMDXComponent=!0;const P5={toc:[]},W5="wrapper";function R5(t){let{components:e,...n}=t;return(0,s.kt)(W5,(0,p.Z)({},P5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}R5.isMDXComponent=!0;const I5={toc:[]},S5="wrapper";function B5(t){let{components:e,...n}=t;return(0,s.kt)(S5,(0,p.Z)({},I5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}B5.isMDXComponent=!0;const G5={toc:[]},E5="wrapper";function O5(t){let{components:e,...n}=t;return(0,s.kt)(E5,(0,p.Z)({},G5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}O5.isMDXComponent=!0;const F5={toc:[]},U5="wrapper";function V5(t){let{components:e,...n}=t;return(0,s.kt)(U5,(0,p.Z)({},F5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}V5.isMDXComponent=!0;const q5={toc:[]},j5="wrapper";function Y5(t){let{components:e,...n}=t;return(0,s.kt)(j5,(0,p.Z)({},q5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Y5.isMDXComponent=!0;const Q5={toc:[]},H5="wrapper";function K5(t){let{components:e,...n}=t;return(0,s.kt)(H5,(0,p.Z)({},Q5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}K5.isMDXComponent=!0;const $5={toc:[]},J5="wrapper";function t9(t){let{components:e,...n}=t;return(0,s.kt)(J5,(0,p.Z)({},$5,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}t9.isMDXComponent=!0;const e9={toc:[]},n9="wrapper";function o9(t){let{components:e,...n}=t;return(0,s.kt)(n9,(0,p.Z)({},e9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}o9.isMDXComponent=!0;const p9={toc:[]},r9="wrapper";function s9(t){let{components:e,...n}=t;return(0,s.kt)(r9,(0,p.Z)({},p9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}s9.isMDXComponent=!0;const c9={toc:[]},a9="wrapper";function i9(t){let{components:e,...n}=t;return(0,s.kt)(a9,(0,p.Z)({},c9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}i9.isMDXComponent=!0;const l9={toc:[]},u9="wrapper";function m9(t){let{components:e,...n}=t;return(0,s.kt)(u9,(0,p.Z)({},l9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}m9.isMDXComponent=!0;const d9={toc:[]},h9="wrapper";function f9(t){let{components:e,...n}=t;return(0,s.kt)(h9,(0,p.Z)({},d9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}f9.isMDXComponent=!0;const k9={toc:[]},y9="wrapper";function D9(t){let{components:e,...n}=t;return(0,s.kt)(y9,(0,p.Z)({},k9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}D9.isMDXComponent=!0;const M9={toc:[]},X9="wrapper";function _9(t){let{components:e,...n}=t;return(0,s.kt)(X9,(0,p.Z)({},M9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A closed circle will look like a pie chart:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  fill={'lightseagreen'}\n  endAngle={230}\n  closed={true}\n/>\n")),(0,s.kt)("p",null,"An open one will look like an arc:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Circle\n  size={300}\n  stroke={'lightseagreen'}\n  lineWidth={8}\n  endAngle={230}\n  closed={false}\n/>\n")))}_9.isMDXComponent=!0;const w9={toc:[]},T9="wrapper";function C9(t){let{components:e,...n}=t;return(0,s.kt)(T9,(0,p.Z)({},w9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"false"))}C9.isMDXComponent=!0;const x9={toc:[]},g9="wrapper";function v9(t){let{components:e,...n}=t;return(0,s.kt)(g9,(0,p.Z)({},x9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}v9.isMDXComponent=!0;const L9={toc:[]},Z9="wrapper";function b9(t){let{components:e,...n}=t;return(0,s.kt)(Z9,(0,p.Z)({},L9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the circle begins at ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}b9.isMDXComponent=!0;const N9={toc:[]},z9="wrapper";function A9(t){let{components:e,...n}=t;return(0,s.kt)(z9,(0,p.Z)({},N9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the circle sector should be drawn counterclockwise."))}A9.isMDXComponent=!0;const P9={toc:[]},W9="wrapper";function R9(t){let{components:e,...n}=t;return(0,s.kt)(W9,(0,p.Z)({},P9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}R9.isMDXComponent=!0;const I9={toc:[]},S9="wrapper";function B9(t){let{components:e,...n}=t;return(0,s.kt)(S9,(0,p.Z)({},I9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}B9.isMDXComponent=!0;const G9={toc:[]},E9="wrapper";function O9(t){let{components:e,...n}=t;return(0,s.kt)(E9,(0,p.Z)({},G9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}O9.isMDXComponent=!0;const F9={toc:[]},U9="wrapper";function V9(t){let{components:e,...n}=t;return(0,s.kt)(U9,(0,p.Z)({},F9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"360"))}V9.isMDXComponent=!0;const q9={toc:[]},j9="wrapper";function Y9(t){let{components:e,...n}=t;return(0,s.kt)(j9,(0,p.Z)({},q9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}Y9.isMDXComponent=!0;const Q9={toc:[]},H9="wrapper";function K9(t){let{components:e,...n}=t;return(0,s.kt)(H9,(0,p.Z)({},Q9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}K9.isMDXComponent=!0;const $9={toc:[]},J9="wrapper";function ttt(t){let{components:e,...n}=t;return(0,s.kt)(J9,(0,p.Z)({},$9,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}ttt.isMDXComponent=!0;const ett={toc:[]},ntt="wrapper";function ott(t){let{components:e,...n}=t;return(0,s.kt)(ntt,(0,p.Z)({},ett,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}ott.isMDXComponent=!0;const ptt={toc:[]},rtt="wrapper";function stt(t){let{components:e,...n}=t;return(0,s.kt)(rtt,(0,p.Z)({},ptt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}stt.isMDXComponent=!0;const ctt={toc:[]},att="wrapper";function itt(t){let{components:e,...n}=t;return(0,s.kt)(att,(0,p.Z)({},ctt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}itt.isMDXComponent=!0;const ltt={toc:[]},utt="wrapper";function mtt(t){let{components:e,...n}=t;return(0,s.kt)(utt,(0,p.Z)({},ltt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}mtt.isMDXComponent=!0;const dtt={toc:[]},htt="wrapper";function ftt(t){let{components:e,...n}=t;return(0,s.kt)(htt,(0,p.Z)({},dtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}ftt.isMDXComponent=!0;const ktt={toc:[]},ytt="wrapper";function Dtt(t){let{components:e,...n}=t;return(0,s.kt)(ytt,(0,p.Z)({},ktt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Dtt.isMDXComponent=!0;const Mtt={toc:[]},Xtt="wrapper";function _tt(t){let{components:e,...n}=t;return(0,s.kt)(Xtt,(0,p.Z)({},Mtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}_tt.isMDXComponent=!0;const wtt={toc:[]},Ttt="wrapper";function Ctt(t){let{components:e,...n}=t;return(0,s.kt)(Ttt,(0,p.Z)({},wtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Ctt.isMDXComponent=!0;const xtt={toc:[]},gtt="wrapper";function vtt(t){let{components:e,...n}=t;return(0,s.kt)(gtt,(0,p.Z)({},xtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}vtt.isMDXComponent=!0;const Ltt={toc:[]},Ztt="wrapper";function btt(t){let{components:e,...n}=t;return(0,s.kt)(Ztt,(0,p.Z)({},Ltt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}btt.isMDXComponent=!0;const Ntt={toc:[]},ztt="wrapper";function Att(t){let{components:e,...n}=t;return(0,s.kt)(ztt,(0,p.Z)({},Ntt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Att.isMDXComponent=!0;const Ptt={toc:[]},Wtt="wrapper";function Rtt(t){let{components:e,...n}=t;return(0,s.kt)(Wtt,(0,p.Z)({},Ptt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Rtt.isMDXComponent=!0;const Itt={toc:[]},Stt="wrapper";function Btt(t){let{components:e,...n}=t;return(0,s.kt)(Stt,(0,p.Z)({},Itt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}Btt.isMDXComponent=!0;const Gtt={toc:[]},Ett="wrapper";function Ott(t){let{components:e,...n}=t;return(0,s.kt)(Ett,(0,p.Z)({},Gtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Ott.isMDXComponent=!0;const Ftt={toc:[]},Utt="wrapper";function Vtt(t){let{components:e,...n}=t;return(0,s.kt)(Utt,(0,p.Z)({},Ftt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Vtt.isMDXComponent=!0;const qtt={toc:[]},jtt="wrapper";function Ytt(t){let{components:e,...n}=t;return(0,s.kt)(jtt,(0,p.Z)({},qtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Ytt.isMDXComponent=!0;const Qtt={toc:[]},Htt="wrapper";function Ktt(t){let{components:e,...n}=t;return(0,s.kt)(Htt,(0,p.Z)({},Qtt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Ktt.isMDXComponent=!0;const $tt={toc:[]},Jtt="wrapper";function tet(t){let{components:e,...n}=t;return(0,s.kt)(Jtt,(0,p.Z)({},$tt,n,{components:e,mdxType:"MDXLayout"}))}tet.isMDXComponent=!0;const eet={toc:[]},net="wrapper";function oet(t){let{components:e,...n}=t;return(0,s.kt)(net,(0,p.Z)({},eet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}oet.isMDXComponent=!0;const pet={toc:[]},ret="wrapper";function set(t){let{components:e,...n}=t;return(0,s.kt)(ret,(0,p.Z)({},pet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}set.isMDXComponent=!0;const cet={toc:[]},aet="wrapper";function iet(t){let{components:e,...n}=t;return(0,s.kt)(aet,(0,p.Z)({},cet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}iet.isMDXComponent=!0;const uet={toc:[]},met="wrapper";function det(t){let{components:e,...n}=t;return(0,s.kt)(met,(0,p.Z)({},uet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}det.isMDXComponent=!0;const het={toc:[]},fet="wrapper";function ket(t){let{components:e,...n}=t;return(0,s.kt)(fet,(0,p.Z)({},het,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}ket.isMDXComponent=!0;const yet={toc:[]},Det="wrapper";function Met(t){let{components:e,...n}=t;return(0,s.kt)(Det,(0,p.Z)({},yet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Met.isMDXComponent=!0;const Xet={toc:[]},_et="wrapper";function wet(t){let{components:e,...n}=t;return(0,s.kt)(_et,(0,p.Z)({},Xet,n,{components:e,mdxType:"MDXLayout"}))}wet.isMDXComponent=!0;const Tet={toc:[]},Cet="wrapper";function xet(t){let{components:e,...n}=t;return(0,s.kt)(Cet,(0,p.Z)({},Tet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}xet.isMDXComponent=!0;const get={toc:[]},vet="wrapper";function Let(t){let{components:e,...n}=t;return(0,s.kt)(vet,(0,p.Z)({},get,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Let.isMDXComponent=!0;const Zet={toc:[]},bet="wrapper";function Net(t){let{components:e,...n}=t;return(0,s.kt)(bet,(0,p.Z)({},Zet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}Net.isMDXComponent=!0;const zet={toc:[]},Aet="wrapper";function Pet(t){let{components:e,...n}=t;return(0,s.kt)(Aet,(0,p.Z)({},zet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}Pet.isMDXComponent=!0;const Wet={toc:[]},Ret="wrapper";function Iet(t){let{components:e,...n}=t;return(0,s.kt)(Ret,(0,p.Z)({},Wet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}Iet.isMDXComponent=!0;const Set={toc:[]},Bet="wrapper";function Get(t){let{components:e,...n}=t;return(0,s.kt)(Bet,(0,p.Z)({},Set,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Get.isMDXComponent=!0;const Eet={toc:[]},Oet="wrapper";function Fet(t){let{components:e,...n}=t;return(0,s.kt)(Oet,(0,p.Z)({},Eet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Fet.isMDXComponent=!0;const Uet={toc:[]},Vet="wrapper";function qet(t){let{components:e,...n}=t;return(0,s.kt)(Vet,(0,p.Z)({},Uet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}qet.isMDXComponent=!0;const jet={toc:[]},Yet="wrapper";function Qet(t){let{components:e,...n}=t;return(0,s.kt)(Yet,(0,p.Z)({},jet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Qet.isMDXComponent=!0;const Het={toc:[]},Ket="wrapper";function $et(t){let{components:e,...n}=t;return(0,s.kt)(Ket,(0,p.Z)({},Het,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}$et.isMDXComponent=!0;const Jet={toc:[]},tnt="wrapper";function ent(t){let{components:e,...n}=t;return(0,s.kt)(tnt,(0,p.Z)({},Jet,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}ent.isMDXComponent=!0;const nnt={toc:[]},ont="wrapper";function pnt(t){let{components:e,...n}=t;return(0,s.kt)(ont,(0,p.Z)({},nnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}pnt.isMDXComponent=!0;const rnt={toc:[]},snt="wrapper";function cnt(t){let{components:e,...n}=t;return(0,s.kt)(snt,(0,p.Z)({},rnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}cnt.isMDXComponent=!0;const ant={toc:[]},int="wrapper";function lnt(t){let{components:e,...n}=t;return(0,s.kt)(int,(0,p.Z)({},ant,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}lnt.isMDXComponent=!0;const unt={toc:[]},mnt="wrapper";function dnt(t){let{components:e,...n}=t;return(0,s.kt)(mnt,(0,p.Z)({},unt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}dnt.isMDXComponent=!0;const hnt={toc:[]},fnt="wrapper";function knt(t){let{components:e,...n}=t;return(0,s.kt)(fnt,(0,p.Z)({},hnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}knt.isMDXComponent=!0;const ynt={toc:[]},Dnt="wrapper";function Mnt(t){let{components:e,...n}=t;return(0,s.kt)(Dnt,(0,p.Z)({},ynt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Mnt.isMDXComponent=!0;const Xnt={toc:[]},_nt="wrapper";function wnt(t){let{components:e,...n}=t;return(0,s.kt)(_nt,(0,p.Z)({},Xnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}wnt.isMDXComponent=!0;const Tnt={toc:[]},Cnt="wrapper";function xnt(t){let{components:e,...n}=t;return(0,s.kt)(Cnt,(0,p.Z)({},Tnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}xnt.isMDXComponent=!0;const gnt={toc:[]},vnt="wrapper";function Lnt(t){let{components:e,...n}=t;return(0,s.kt)(vnt,(0,p.Z)({},gnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Lnt.isMDXComponent=!0;const Znt={toc:[]},bnt="wrapper";function Nnt(t){let{components:e,...n}=t;return(0,s.kt)(bnt,(0,p.Z)({},Znt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Nnt.isMDXComponent=!0;const znt={toc:[]},Ant="wrapper";function Pnt(t){let{components:e,...n}=t;return(0,s.kt)(Ant,(0,p.Z)({},znt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Pnt.isMDXComponent=!0;const Wnt={toc:[]},Rnt="wrapper";function Int(t){let{components:e,...n}=t;return(0,s.kt)(Rnt,(0,p.Z)({},Wnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Int.isMDXComponent=!0;const Snt={toc:[]},Bnt="wrapper";function Gnt(t){let{components:e,...n}=t;return(0,s.kt)(Bnt,(0,p.Z)({},Snt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Gnt.isMDXComponent=!0;const Ent={toc:[]},Ont="wrapper";function Fnt(t){let{components:e,...n}=t;return(0,s.kt)(Ont,(0,p.Z)({},Ent,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Fnt.isMDXComponent=!0;const Unt={toc:[]},Vnt="wrapper";function qnt(t){let{components:e,...n}=t;return(0,s.kt)(Vnt,(0,p.Z)({},Unt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}qnt.isMDXComponent=!0;const jnt={toc:[]},Ynt="wrapper";function Qnt(t){let{components:e,...n}=t;return(0,s.kt)(Ynt,(0,p.Z)({},jnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Qnt.isMDXComponent=!0;const Hnt={toc:[]},Knt="wrapper";function $nt(t){let{components:e,...n}=t;return(0,s.kt)(Knt,(0,p.Z)({},Hnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}$nt.isMDXComponent=!0;const Jnt={toc:[]},tot="wrapper";function eot(t){let{components:e,...n}=t;return(0,s.kt)(tot,(0,p.Z)({},Jnt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}eot.isMDXComponent=!0;const not={toc:[]},oot="wrapper";function pot(t){let{components:e,...n}=t;return(0,s.kt)(oot,(0,p.Z)({},not,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}pot.isMDXComponent=!0;const rot={toc:[]},sot="wrapper";function cot(t){let{components:e,...n}=t;return(0,s.kt)(sot,(0,p.Z)({},rot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}cot.isMDXComponent=!0;const aot={toc:[]},iot="wrapper";function lot(t){let{components:e,...n}=t;return(0,s.kt)(iot,(0,p.Z)({},aot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}lot.isMDXComponent=!0;const uot={toc:[]},mot="wrapper";function dot(t){let{components:e,...n}=t;return(0,s.kt)(mot,(0,p.Z)({},uot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}dot.isMDXComponent=!0;const hot={toc:[]},fot="wrapper";function kot(t){let{components:e,...n}=t;return(0,s.kt)(fot,(0,p.Z)({},hot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}kot.isMDXComponent=!0;const yot={toc:[]},Dot="wrapper";function Mot(t){let{components:e,...n}=t;return(0,s.kt)(Dot,(0,p.Z)({},yot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Mot.isMDXComponent=!0;const Xot={toc:[]},_ot="wrapper";function wot(t){let{components:e,...n}=t;return(0,s.kt)(_ot,(0,p.Z)({},Xot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wot.isMDXComponent=!0;const Tot={toc:[]},Cot="wrapper";function xot(t){let{components:e,...n}=t;return(0,s.kt)(Cot,(0,p.Z)({},Tot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}xot.isMDXComponent=!0;const got={toc:[]},vot="wrapper";function Lot(t){let{components:e,...n}=t;return(0,s.kt)(vot,(0,p.Z)({},got,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Lot.isMDXComponent=!0;const Zot={toc:[]},bot="wrapper";function Not(t){let{components:e,...n}=t;return(0,s.kt)(bot,(0,p.Z)({},Zot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Not.isMDXComponent=!0;const zot={toc:[]},Aot="wrapper";function Pot(t){let{components:e,...n}=t;return(0,s.kt)(Aot,(0,p.Z)({},zot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Pot.isMDXComponent=!0;const Wot={toc:[]},Rot="wrapper";function Iot(t){let{components:e,...n}=t;return(0,s.kt)(Rot,(0,p.Z)({},Wot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Iot.isMDXComponent=!0;const Sot={toc:[]},Bot="wrapper";function Got(t){let{components:e,...n}=t;return(0,s.kt)(Bot,(0,p.Z)({},Sot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Got.isMDXComponent=!0;const Eot={toc:[]},Oot="wrapper";function Fot(t){let{components:e,...n}=t;return(0,s.kt)(Oot,(0,p.Z)({},Eot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Fot.isMDXComponent=!0;const Uot={toc:[]},Vot="wrapper";function qot(t){let{components:e,...n}=t;return(0,s.kt)(Vot,(0,p.Z)({},Uot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}qot.isMDXComponent=!0;const jot={toc:[]},Yot="wrapper";function Qot(t){let{components:e,...n}=t;return(0,s.kt)(Yot,(0,p.Z)({},jot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Qot.isMDXComponent=!0;const Hot={toc:[]},Kot="wrapper";function $ot(t){let{components:e,...n}=t;return(0,s.kt)(Kot,(0,p.Z)({},Hot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}$ot.isMDXComponent=!0;const Jot={toc:[]},tpt="wrapper";function ept(t){let{components:e,...n}=t;return(0,s.kt)(tpt,(0,p.Z)({},Jot,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}ept.isMDXComponent=!0;const npt={toc:[]},opt="wrapper";function ppt(t){let{components:e,...n}=t;return(0,s.kt)(opt,(0,p.Z)({},npt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}ppt.isMDXComponent=!0;const rpt={toc:[]},spt="wrapper";function cpt(t){let{components:e,...n}=t;return(0,s.kt)(spt,(0,p.Z)({},rpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}cpt.isMDXComponent=!0;const apt={toc:[]},ipt="wrapper";function lpt(t){let{components:e,...n}=t;return(0,s.kt)(ipt,(0,p.Z)({},apt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}lpt.isMDXComponent=!0;const upt={toc:[]},mpt="wrapper";function dpt(t){let{components:e,...n}=t;return(0,s.kt)(mpt,(0,p.Z)({},upt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}dpt.isMDXComponent=!0;const hpt={toc:[]},fpt="wrapper";function kpt(t){let{components:e,...n}=t;return(0,s.kt)(fpt,(0,p.Z)({},hpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}kpt.isMDXComponent=!0;const ypt={toc:[]},Dpt="wrapper";function Mpt(t){let{components:e,...n}=t;return(0,s.kt)(Dpt,(0,p.Z)({},ypt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Mpt.isMDXComponent=!0;const Xpt={toc:[]},_pt="wrapper";function wpt(t){let{components:e,...n}=t;return(0,s.kt)(_pt,(0,p.Z)({},Xpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wpt.isMDXComponent=!0;const Tpt={toc:[]},Cpt="wrapper";function xpt(t){let{components:e,...n}=t;return(0,s.kt)(Cpt,(0,p.Z)({},Tpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}xpt.isMDXComponent=!0;const gpt={toc:[]},vpt="wrapper";function Lpt(t){let{components:e,...n}=t;return(0,s.kt)(vpt,(0,p.Z)({},gpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Lpt.isMDXComponent=!0;const Zpt={toc:[]},bpt="wrapper";function Npt(t){let{components:e,...n}=t;return(0,s.kt)(bpt,(0,p.Z)({},Zpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Npt.isMDXComponent=!0;const zpt={toc:[]},Apt="wrapper";function Ppt(t){let{components:e,...n}=t;return(0,s.kt)(Apt,(0,p.Z)({},zpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Ppt.isMDXComponent=!0;const Wpt={toc:[]},Rpt="wrapper";function Ipt(t){let{components:e,...n}=t;return(0,s.kt)(Rpt,(0,p.Z)({},Wpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ipt.isMDXComponent=!0;const Spt={toc:[]},Bpt="wrapper";function Gpt(t){let{components:e,...n}=t;return(0,s.kt)(Bpt,(0,p.Z)({},Spt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Gpt.isMDXComponent=!0;const Ept={toc:[]},Opt="wrapper";function Fpt(t){let{components:e,...n}=t;return(0,s.kt)(Opt,(0,p.Z)({},Ept,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Fpt.isMDXComponent=!0;const Upt={toc:[]},Vpt="wrapper";function qpt(t){let{components:e,...n}=t;return(0,s.kt)(Vpt,(0,p.Z)({},Upt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}qpt.isMDXComponent=!0;const jpt={toc:[]},Ypt="wrapper";function Qpt(t){let{components:e,...n}=t;return(0,s.kt)(Ypt,(0,p.Z)({},jpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Qpt.isMDXComponent=!0;const Hpt={toc:[]},Kpt="wrapper";function $pt(t){let{components:e,...n}=t;return(0,s.kt)(Kpt,(0,p.Z)({},Hpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}$pt.isMDXComponent=!0;const Jpt={toc:[]},trt="wrapper";function ert(t){let{components:e,...n}=t;return(0,s.kt)(trt,(0,p.Z)({},Jpt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}ert.isMDXComponent=!0;const nrt={toc:[]},ort="wrapper";function prt(t){let{components:e,...n}=t;return(0,s.kt)(ort,(0,p.Z)({},nrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}prt.isMDXComponent=!0;const rrt={toc:[]},srt="wrapper";function crt(t){let{components:e,...n}=t;return(0,s.kt)(srt,(0,p.Z)({},rrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}crt.isMDXComponent=!0;const art={toc:[]},irt="wrapper";function lrt(t){let{components:e,...n}=t;return(0,s.kt)(irt,(0,p.Z)({},art,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}lrt.isMDXComponent=!0;const urt={toc:[]},mrt="wrapper";function drt(t){let{components:e,...n}=t;return(0,s.kt)(mrt,(0,p.Z)({},urt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}drt.isMDXComponent=!0;const hrt={toc:[]},frt="wrapper";function krt(t){let{components:e,...n}=t;return(0,s.kt)(frt,(0,p.Z)({},hrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}krt.isMDXComponent=!0;const yrt={toc:[]},Drt="wrapper";function Mrt(t){let{components:e,...n}=t;return(0,s.kt)(Drt,(0,p.Z)({},yrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Mrt.isMDXComponent=!0;const Xrt={toc:[]},_rt="wrapper";function wrt(t){let{components:e,...n}=t;return(0,s.kt)(_rt,(0,p.Z)({},Xrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}wrt.isMDXComponent=!0;const Trt={toc:[]},Crt="wrapper";function xrt(t){let{components:e,...n}=t;return(0,s.kt)(Crt,(0,p.Z)({},Trt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}xrt.isMDXComponent=!0;const grt={toc:[]},vrt="wrapper";function Lrt(t){let{components:e,...n}=t;return(0,s.kt)(vrt,(0,p.Z)({},grt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Lrt.isMDXComponent=!0;const Zrt={toc:[]},brt="wrapper";function Nrt(t){let{components:e,...n}=t;return(0,s.kt)(brt,(0,p.Z)({},Zrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Nrt.isMDXComponent=!0;const zrt={toc:[]},Art="wrapper";function Prt(t){let{components:e,...n}=t;return(0,s.kt)(Art,(0,p.Z)({},zrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Prt.isMDXComponent=!0;const Wrt={toc:[]},Rrt="wrapper";function Irt(t){let{components:e,...n}=t;return(0,s.kt)(Rrt,(0,p.Z)({},Wrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Irt.isMDXComponent=!0;const Srt={toc:[]},Brt="wrapper";function Grt(t){let{components:e,...n}=t;return(0,s.kt)(Brt,(0,p.Z)({},Srt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Grt.isMDXComponent=!0;const Ert={toc:[]},Ort="wrapper";function Frt(t){let{components:e,...n}=t;return(0,s.kt)(Ort,(0,p.Z)({},Ert,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Frt.isMDXComponent=!0;const Urt={toc:[]},Vrt="wrapper";function qrt(t){let{components:e,...n}=t;return(0,s.kt)(Vrt,(0,p.Z)({},Urt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}qrt.isMDXComponent=!0;const jrt={toc:[]},Yrt="wrapper";function Qrt(t){let{components:e,...n}=t;return(0,s.kt)(Yrt,(0,p.Z)({},jrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Qrt.isMDXComponent=!0;const Hrt={toc:[]},Krt="wrapper";function $rt(t){let{components:e,...n}=t;return(0,s.kt)(Krt,(0,p.Z)({},Hrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}$rt.isMDXComponent=!0;const Jrt={toc:[]},tst="wrapper";function est(t){let{components:e,...n}=t;return(0,s.kt)(tst,(0,p.Z)({},Jrt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}est.isMDXComponent=!0;const nst={toc:[]},ost="wrapper";function pst(t){let{components:e,...n}=t;return(0,s.kt)(ost,(0,p.Z)({},nst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}pst.isMDXComponent=!0;const rst={toc:[]},sst="wrapper";function cst(t){let{components:e,...n}=t;return(0,s.kt)(sst,(0,p.Z)({},rst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}cst.isMDXComponent=!0;const ast={toc:[]},ist="wrapper";function lst(t){let{components:e,...n}=t;return(0,s.kt)(ist,(0,p.Z)({},ast,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}lst.isMDXComponent=!0;const ust={toc:[]},mst="wrapper";function dst(t){let{components:e,...n}=t;return(0,s.kt)(mst,(0,p.Z)({},ust,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}dst.isMDXComponent=!0;const hst={toc:[]},fst="wrapper";function kst(t){let{components:e,...n}=t;return(0,s.kt)(fst,(0,p.Z)({},hst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}kst.isMDXComponent=!0;const yst={toc:[]},Dst="wrapper";function Mst(t){let{components:e,...n}=t;return(0,s.kt)(Dst,(0,p.Z)({},yst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Mst.isMDXComponent=!0;const Xst={toc:[]},_st="wrapper";function wst(t){let{components:e,...n}=t;return(0,s.kt)(_st,(0,p.Z)({},Xst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wst.isMDXComponent=!0;const Tst={toc:[]},Cst="wrapper";function xst(t){let{components:e,...n}=t;return(0,s.kt)(Cst,(0,p.Z)({},Tst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}xst.isMDXComponent=!0;const gst={toc:[]},vst="wrapper";function Lst(t){let{components:e,...n}=t;return(0,s.kt)(vst,(0,p.Z)({},gst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Lst.isMDXComponent=!0;const Zst={toc:[]},bst="wrapper";function Nst(t){let{components:e,...n}=t;return(0,s.kt)(bst,(0,p.Z)({},Zst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Nst.isMDXComponent=!0;const zst={toc:[]},Ast="wrapper";function Pst(t){let{components:e,...n}=t;return(0,s.kt)(Ast,(0,p.Z)({},zst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Pst.isMDXComponent=!0;const Wst={toc:[]},Rst="wrapper";function Ist(t){let{components:e,...n}=t;return(0,s.kt)(Rst,(0,p.Z)({},Wst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Ist.isMDXComponent=!0;const Sst={toc:[]},Bst="wrapper";function Gst(t){let{components:e,...n}=t;return(0,s.kt)(Bst,(0,p.Z)({},Sst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Gst.isMDXComponent=!0;const Est={toc:[]},Ost="wrapper";function Fst(t){let{components:e,...n}=t;return(0,s.kt)(Ost,(0,p.Z)({},Est,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Fst.isMDXComponent=!0;const Ust={toc:[]},Vst="wrapper";function qst(t){let{components:e,...n}=t;return(0,s.kt)(Vst,(0,p.Z)({},Ust,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}qst.isMDXComponent=!0;const jst={toc:[]},Yst="wrapper";function Qst(t){let{components:e,...n}=t;return(0,s.kt)(Yst,(0,p.Z)({},jst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Qst.isMDXComponent=!0;const Hst={toc:[]},Kst="wrapper";function $st(t){let{components:e,...n}=t;return(0,s.kt)(Kst,(0,p.Z)({},Hst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}$st.isMDXComponent=!0;const Jst={toc:[]},tct="wrapper";function ect(t){let{components:e,...n}=t;return(0,s.kt)(tct,(0,p.Z)({},Jst,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}ect.isMDXComponent=!0;const nct={toc:[]},oct="wrapper";function pct(t){let{components:e,...n}=t;return(0,s.kt)(oct,(0,p.Z)({},nct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}pct.isMDXComponent=!0;const rct={toc:[]},sct="wrapper";function cct(t){let{components:e,...n}=t;return(0,s.kt)(sct,(0,p.Z)({},rct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}cct.isMDXComponent=!0;const act={toc:[]},ict="wrapper";function lct(t){let{components:e,...n}=t;return(0,s.kt)(ict,(0,p.Z)({},act,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lct.isMDXComponent=!0;const uct={toc:[]},mct="wrapper";function dct(t){let{components:e,...n}=t;return(0,s.kt)(mct,(0,p.Z)({},uct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}dct.isMDXComponent=!0;const hct={toc:[]},fct="wrapper";function kct(t){let{components:e,...n}=t;return(0,s.kt)(fct,(0,p.Z)({},hct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}kct.isMDXComponent=!0;const yct={toc:[]},Dct="wrapper";function Mct(t){let{components:e,...n}=t;return(0,s.kt)(Dct,(0,p.Z)({},yct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Mct.isMDXComponent=!0;const Xct={toc:[]},_ct="wrapper";function wct(t){let{components:e,...n}=t;return(0,s.kt)(_ct,(0,p.Z)({},Xct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}wct.isMDXComponent=!0;const Tct={toc:[]},Cct="wrapper";function xct(t){let{components:e,...n}=t;return(0,s.kt)(Cct,(0,p.Z)({},Tct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}xct.isMDXComponent=!0;const gct={toc:[]},vct="wrapper";function Lct(t){let{components:e,...n}=t;return(0,s.kt)(vct,(0,p.Z)({},gct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Lct.isMDXComponent=!0;const Zct={toc:[]},bct="wrapper";function Nct(t){let{components:e,...n}=t;return(0,s.kt)(bct,(0,p.Z)({},Zct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Nct.isMDXComponent=!0;const zct={toc:[]},Act="wrapper";function Pct(t){let{components:e,...n}=t;return(0,s.kt)(Act,(0,p.Z)({},zct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Pct.isMDXComponent=!0;const Wct={toc:[]},Rct="wrapper";function Ict(t){let{components:e,...n}=t;return(0,s.kt)(Rct,(0,p.Z)({},Wct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Ict.isMDXComponent=!0;const Sct={toc:[]},Bct="wrapper";function Gct(t){let{components:e,...n}=t;return(0,s.kt)(Bct,(0,p.Z)({},Sct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}Gct.isMDXComponent=!0;const Ect={toc:[]},Oct="wrapper";function Fct(t){let{components:e,...n}=t;return(0,s.kt)(Oct,(0,p.Z)({},Ect,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Fct.isMDXComponent=!0;const Uct={toc:[]},Vct="wrapper";function qct(t){let{components:e,...n}=t;return(0,s.kt)(Vct,(0,p.Z)({},Uct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}qct.isMDXComponent=!0;const jct={toc:[]},Yct="wrapper";function Qct(t){let{components:e,...n}=t;return(0,s.kt)(Yct,(0,p.Z)({},jct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Qct.isMDXComponent=!0;const Hct={toc:[]},Kct="wrapper";function $ct(t){let{components:e,...n}=t;return(0,s.kt)(Kct,(0,p.Z)({},Hct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}$ct.isMDXComponent=!0;const Jct={toc:[]},tat="wrapper";function eat(t){let{components:e,...n}=t;return(0,s.kt)(tat,(0,p.Z)({},Jct,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}eat.isMDXComponent=!0;const nat={toc:[]},oat="wrapper";function pat(t){let{components:e,...n}=t;return(0,s.kt)(oat,(0,p.Z)({},nat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}pat.isMDXComponent=!0;const rat={toc:[]},sat="wrapper";function cat(t){let{components:e,...n}=t;return(0,s.kt)(sat,(0,p.Z)({},rat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}cat.isMDXComponent=!0;const aat={toc:[]},iat="wrapper";function lat(t){let{components:e,...n}=t;return(0,s.kt)(iat,(0,p.Z)({},aat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}lat.isMDXComponent=!0;const uat={toc:[]},mat="wrapper";function dat(t){let{components:e,...n}=t;return(0,s.kt)(mat,(0,p.Z)({},uat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}dat.isMDXComponent=!0;const hat={toc:[]},fat="wrapper";function kat(t){let{components:e,...n}=t;return(0,s.kt)(fat,(0,p.Z)({},hat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}kat.isMDXComponent=!0;const yat={toc:[]},Dat="wrapper";function Mat(t){let{components:e,...n}=t;return(0,s.kt)(Dat,(0,p.Z)({},yat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Mat.isMDXComponent=!0;const Xat={toc:[]},_at="wrapper";function wat(t){let{components:e,...n}=t;return(0,s.kt)(_at,(0,p.Z)({},Xat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}wat.isMDXComponent=!0;const Tat={toc:[]},Cat="wrapper";function xat(t){let{components:e,...n}=t;return(0,s.kt)(Cat,(0,p.Z)({},Tat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}xat.isMDXComponent=!0;const gat={toc:[]},vat="wrapper";function Lat(t){let{components:e,...n}=t;return(0,s.kt)(vat,(0,p.Z)({},gat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Lat.isMDXComponent=!0;const Zat={toc:[]},bat="wrapper";function Nat(t){let{components:e,...n}=t;return(0,s.kt)(bat,(0,p.Z)({},Zat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Nat.isMDXComponent=!0;const zat={toc:[]},Aat="wrapper";function Pat(t){let{components:e,...n}=t;return(0,s.kt)(Aat,(0,p.Z)({},zat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Pat.isMDXComponent=!0;const Wat={toc:[]},Rat="wrapper";function Iat(t){let{components:e,...n}=t;return(0,s.kt)(Rat,(0,p.Z)({},Wat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Iat.isMDXComponent=!0;const Sat={toc:[]},Bat="wrapper";function Gat(t){let{components:e,...n}=t;return(0,s.kt)(Bat,(0,p.Z)({},Sat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Gat.isMDXComponent=!0;const Eat={toc:[]},Oat="wrapper";function Fat(t){let{components:e,...n}=t;return(0,s.kt)(Oat,(0,p.Z)({},Eat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Fat.isMDXComponent=!0;const Uat={toc:[]},Vat="wrapper";function qat(t){let{components:e,...n}=t;return(0,s.kt)(Vat,(0,p.Z)({},Uat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}qat.isMDXComponent=!0;const jat={toc:[]},Yat="wrapper";function Qat(t){let{components:e,...n}=t;return(0,s.kt)(Yat,(0,p.Z)({},jat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Qat.isMDXComponent=!0;const Hat={toc:[]},Kat="wrapper";function $at(t){let{components:e,...n}=t;return(0,s.kt)(Kat,(0,p.Z)({},Hat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}$at.isMDXComponent=!0;const Jat={toc:[]},tit="wrapper";function eit(t){let{components:e,...n}=t;return(0,s.kt)(tit,(0,p.Z)({},Jat,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}eit.isMDXComponent=!0;const nit={toc:[]},oit="wrapper";function pit(t){let{components:e,...n}=t;return(0,s.kt)(oit,(0,p.Z)({},nit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}pit.isMDXComponent=!0;const rit={toc:[]},sit="wrapper";function cit(t){let{components:e,...n}=t;return(0,s.kt)(sit,(0,p.Z)({},rit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}cit.isMDXComponent=!0;const ait={toc:[]},iit="wrapper";function lit(t){let{components:e,...n}=t;return(0,s.kt)(iit,(0,p.Z)({},ait,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}lit.isMDXComponent=!0;const uit={toc:[]},mit="wrapper";function dit(t){let{components:e,...n}=t;return(0,s.kt)(mit,(0,p.Z)({},uit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}dit.isMDXComponent=!0;const hit={toc:[]},fit="wrapper";function kit(t){let{components:e,...n}=t;return(0,s.kt)(fit,(0,p.Z)({},hit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}kit.isMDXComponent=!0;const yit={toc:[]},Dit="wrapper";function Mit(t){let{components:e,...n}=t;return(0,s.kt)(Dit,(0,p.Z)({},yit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Mit.isMDXComponent=!0;const Xit={toc:[]},_it="wrapper";function wit(t){let{components:e,...n}=t;return(0,s.kt)(_it,(0,p.Z)({},Xit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}wit.isMDXComponent=!0;const Tit={toc:[]},Cit="wrapper";function xit(t){let{components:e,...n}=t;return(0,s.kt)(Cit,(0,p.Z)({},Tit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}xit.isMDXComponent=!0;const git={toc:[]},vit="wrapper";function Lit(t){let{components:e,...n}=t;return(0,s.kt)(vit,(0,p.Z)({},git,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}Lit.isMDXComponent=!0;const Zit={toc:[]},bit="wrapper";function Nit(t){let{components:e,...n}=t;return(0,s.kt)(bit,(0,p.Z)({},Zit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Nit.isMDXComponent=!0;const zit={toc:[]},Ait="wrapper";function Pit(t){let{components:e,...n}=t;return(0,s.kt)(Ait,(0,p.Z)({},zit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Pit.isMDXComponent=!0;const Wit={toc:[]},Rit="wrapper";function Iit(t){let{components:e,...n}=t;return(0,s.kt)(Rit,(0,p.Z)({},Wit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Iit.isMDXComponent=!0;const Sit={toc:[]},Bit="wrapper";function Git(t){let{components:e,...n}=t;return(0,s.kt)(Bit,(0,p.Z)({},Sit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Git.isMDXComponent=!0;const Eit={toc:[]},Oit="wrapper";function Fit(t){let{components:e,...n}=t;return(0,s.kt)(Oit,(0,p.Z)({},Eit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Fit.isMDXComponent=!0;const Uit={toc:[]},Vit="wrapper";function qit(t){let{components:e,...n}=t;return(0,s.kt)(Vit,(0,p.Z)({},Uit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}qit.isMDXComponent=!0;const jit={toc:[]},Yit="wrapper";function Qit(t){let{components:e,...n}=t;return(0,s.kt)(Yit,(0,p.Z)({},jit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Qit.isMDXComponent=!0;const Hit={toc:[]},Kit="wrapper";function $it(t){let{components:e,...n}=t;return(0,s.kt)(Kit,(0,p.Z)({},Hit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}$it.isMDXComponent=!0;const Jit={toc:[]},tlt="wrapper";function elt(t){let{components:e,...n}=t;return(0,s.kt)(tlt,(0,p.Z)({},Jit,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}elt.isMDXComponent=!0;const nlt={toc:[]},olt="wrapper";function plt(t){let{components:e,...n}=t;return(0,s.kt)(olt,(0,p.Z)({},nlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}plt.isMDXComponent=!0;const rlt={toc:[]},slt="wrapper";function clt(t){let{components:e,...n}=t;return(0,s.kt)(slt,(0,p.Z)({},rlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}clt.isMDXComponent=!0;const alt={toc:[]},ilt="wrapper";function llt(t){let{components:e,...n}=t;return(0,s.kt)(ilt,(0,p.Z)({},alt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}llt.isMDXComponent=!0;const ult={toc:[]},mlt="wrapper";function dlt(t){let{components:e,...n}=t;return(0,s.kt)(mlt,(0,p.Z)({},ult,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dlt.isMDXComponent=!0;const hlt={toc:[]},flt="wrapper";function klt(t){let{components:e,...n}=t;return(0,s.kt)(flt,(0,p.Z)({},hlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}klt.isMDXComponent=!0;const ylt={toc:[]},Dlt="wrapper";function Mlt(t){let{components:e,...n}=t;return(0,s.kt)(Dlt,(0,p.Z)({},ylt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Mlt.isMDXComponent=!0;const Xlt={toc:[]},_lt="wrapper";function wlt(t){let{components:e,...n}=t;return(0,s.kt)(_lt,(0,p.Z)({},Xlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}wlt.isMDXComponent=!0;const Tlt={toc:[]},Clt="wrapper";function xlt(t){let{components:e,...n}=t;return(0,s.kt)(Clt,(0,p.Z)({},Tlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}xlt.isMDXComponent=!0;const glt={toc:[]},vlt="wrapper";function Llt(t){let{components:e,...n}=t;return(0,s.kt)(vlt,(0,p.Z)({},glt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Llt.isMDXComponent=!0;const Zlt={toc:[]},blt="wrapper";function Nlt(t){let{components:e,...n}=t;return(0,s.kt)(blt,(0,p.Z)({},Zlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Nlt.isMDXComponent=!0;const zlt={toc:[]},Alt="wrapper";function Plt(t){let{components:e,...n}=t;return(0,s.kt)(Alt,(0,p.Z)({},zlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Plt.isMDXComponent=!0;const Wlt={toc:[]},Rlt="wrapper";function Ilt(t){let{components:e,...n}=t;return(0,s.kt)(Rlt,(0,p.Z)({},Wlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Ilt.isMDXComponent=!0;const Slt={toc:[]},Blt="wrapper";function Glt(t){let{components:e,...n}=t;return(0,s.kt)(Blt,(0,p.Z)({},Slt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Glt.isMDXComponent=!0;const Elt={toc:[]},Olt="wrapper";function Flt(t){let{components:e,...n}=t;return(0,s.kt)(Olt,(0,p.Z)({},Elt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Flt.isMDXComponent=!0;const Ult={toc:[]},Vlt="wrapper";function qlt(t){let{components:e,...n}=t;return(0,s.kt)(Vlt,(0,p.Z)({},Ult,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, CubicBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<CubicBezier>();\n\n  view.add(\n    <CubicBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, -100]}\n      p1={[100, -100]}\n      p2={[-100, 100]}\n      p3={[200, 100]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}qlt.isMDXComponent=!0;const jlt={toc:[]},Ylt="wrapper";function Qlt(t){let{components:e,...n}=t;return(0,s.kt)(Ylt,(0,p.Z)({},jlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a cubic B\xe9zier curve."))}Qlt.isMDXComponent=!0;const Hlt={toc:[]},Klt="wrapper";function $lt(t){let{components:e,...n}=t;return(0,s.kt)(Klt,(0,p.Z)({},Hlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}$lt.isMDXComponent=!0;const Jlt={toc:[]},tut="wrapper";function eut(t){let{components:e,...n}=t;return(0,s.kt)(tut,(0,p.Z)({},Jlt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}eut.isMDXComponent=!0;const nut={toc:[]},out="wrapper";function put(t){let{components:e,...n}=t;return(0,s.kt)(out,(0,p.Z)({},nut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}put.isMDXComponent=!0;const rut={toc:[]},sut="wrapper";function cut(t){let{components:e,...n}=t;return(0,s.kt)(sut,(0,p.Z)({},rut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}cut.isMDXComponent=!0;const aut={toc:[]},iut="wrapper";function lut(t){let{components:e,...n}=t;return(0,s.kt)(iut,(0,p.Z)({},aut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}lut.isMDXComponent=!0;const uut={toc:[]},mut="wrapper";function dut(t){let{components:e,...n}=t;return(0,s.kt)(mut,(0,p.Z)({},uut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}dut.isMDXComponent=!0;const hut={toc:[]},fut="wrapper";function kut(t){let{components:e,...n}=t;return(0,s.kt)(fut,(0,p.Z)({},hut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}kut.isMDXComponent=!0;const yut={toc:[]},Dut="wrapper";function Mut(t){let{components:e,...n}=t;return(0,s.kt)(Dut,(0,p.Z)({},yut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Mut.isMDXComponent=!0;const Xut={toc:[]},_ut="wrapper";function wut(t){let{components:e,...n}=t;return(0,s.kt)(_ut,(0,p.Z)({},Xut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}wut.isMDXComponent=!0;const Tut={toc:[]},Cut="wrapper";function xut(t){let{components:e,...n}=t;return(0,s.kt)(Cut,(0,p.Z)({},Tut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}xut.isMDXComponent=!0;const gut={toc:[]},vut="wrapper";function Lut(t){let{components:e,...n}=t;return(0,s.kt)(vut,(0,p.Z)({},gut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Lut.isMDXComponent=!0;const Zut={toc:[]},but="wrapper";function Nut(t){let{components:e,...n}=t;return(0,s.kt)(but,(0,p.Z)({},Zut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Nut.isMDXComponent=!0;const zut={toc:[]},Aut="wrapper";function Put(t){let{components:e,...n}=t;return(0,s.kt)(Aut,(0,p.Z)({},zut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Put.isMDXComponent=!0;const Wut={toc:[]},Rut="wrapper";function Iut(t){let{components:e,...n}=t;return(0,s.kt)(Rut,(0,p.Z)({},Wut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Iut.isMDXComponent=!0;const Sut={toc:[]},But="wrapper";function Gut(t){let{components:e,...n}=t;return(0,s.kt)(But,(0,p.Z)({},Sut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Gut.isMDXComponent=!0;const Eut={toc:[]},Out="wrapper";function Fut(t){let{components:e,...n}=t;return(0,s.kt)(Out,(0,p.Z)({},Eut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Fut.isMDXComponent=!0;const Uut={toc:[]},Vut="wrapper";function qut(t){let{components:e,...n}=t;return(0,s.kt)(Vut,(0,p.Z)({},Uut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}qut.isMDXComponent=!0;const jut={toc:[]},Yut="wrapper";function Qut(t){let{components:e,...n}=t;return(0,s.kt)(Yut,(0,p.Z)({},jut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Qut.isMDXComponent=!0;const Hut={toc:[]},Kut="wrapper";function $ut(t){let{components:e,...n}=t;return(0,s.kt)(Kut,(0,p.Z)({},Hut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}$ut.isMDXComponent=!0;const Jut={toc:[]},tmt="wrapper";function emt(t){let{components:e,...n}=t;return(0,s.kt)(tmt,(0,p.Z)({},Jut,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}emt.isMDXComponent=!0;const nmt={toc:[]},omt="wrapper";function pmt(t){let{components:e,...n}=t;return(0,s.kt)(omt,(0,p.Z)({},nmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pmt.isMDXComponent=!0;const rmt={toc:[]},smt="wrapper";function cmt(t){let{components:e,...n}=t;return(0,s.kt)(smt,(0,p.Z)({},rmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}cmt.isMDXComponent=!0;const amt={toc:[]},imt="wrapper";function lmt(t){let{components:e,...n}=t;return(0,s.kt)(imt,(0,p.Z)({},amt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}lmt.isMDXComponent=!0;const umt={toc:[]},mmt="wrapper";function dmt(t){let{components:e,...n}=t;return(0,s.kt)(mmt,(0,p.Z)({},umt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}dmt.isMDXComponent=!0;const hmt={toc:[]},fmt="wrapper";function kmt(t){let{components:e,...n}=t;return(0,s.kt)(fmt,(0,p.Z)({},hmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}kmt.isMDXComponent=!0;const ymt={toc:[]},Dmt="wrapper";function Mmt(t){let{components:e,...n}=t;return(0,s.kt)(Dmt,(0,p.Z)({},ymt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Mmt.isMDXComponent=!0;const Xmt={toc:[]},_mt="wrapper";function wmt(t){let{components:e,...n}=t;return(0,s.kt)(_mt,(0,p.Z)({},Xmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}wmt.isMDXComponent=!0;const Tmt={toc:[]},Cmt="wrapper";function xmt(t){let{components:e,...n}=t;return(0,s.kt)(Cmt,(0,p.Z)({},Tmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}xmt.isMDXComponent=!0;const gmt={toc:[]},vmt="wrapper";function Lmt(t){let{components:e,...n}=t;return(0,s.kt)(vmt,(0,p.Z)({},gmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Lmt.isMDXComponent=!0;const Zmt={toc:[]},bmt="wrapper";function Nmt(t){let{components:e,...n}=t;return(0,s.kt)(bmt,(0,p.Z)({},Zmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Nmt.isMDXComponent=!0;const zmt={toc:[]},Amt="wrapper";function Pmt(t){let{components:e,...n}=t;return(0,s.kt)(Amt,(0,p.Z)({},zmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Pmt.isMDXComponent=!0;const Wmt={toc:[]},Rmt="wrapper";function Imt(t){let{components:e,...n}=t;return(0,s.kt)(Rmt,(0,p.Z)({},Wmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Imt.isMDXComponent=!0;const Smt={toc:[]},Bmt="wrapper";function Gmt(t){let{components:e,...n}=t;return(0,s.kt)(Bmt,(0,p.Z)({},Smt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}Gmt.isMDXComponent=!0;const Emt={toc:[]},Omt="wrapper";function Fmt(t){let{components:e,...n}=t;return(0,s.kt)(Omt,(0,p.Z)({},Emt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The first control point of the B\xe9zier curve."))}Fmt.isMDXComponent=!0;const Umt={toc:[]},Vmt="wrapper";function qmt(t){let{components:e,...n}=t;return(0,s.kt)(Vmt,(0,p.Z)({},Umt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The second control point of the B\xe9zier curve."))}qmt.isMDXComponent=!0;const jmt={toc:[]},Ymt="wrapper";function Qmt(t){let{components:e,...n}=t;return(0,s.kt)(Ymt,(0,p.Z)({},jmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}Qmt.isMDXComponent=!0;const Hmt={toc:[]},Kmt="wrapper";function $mt(t){let{components:e,...n}=t;return(0,s.kt)(Kmt,(0,p.Z)({},Hmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}$mt.isMDXComponent=!0;const Jmt={toc:[]},tdt="wrapper";function edt(t){let{components:e,...n}=t;return(0,s.kt)(tdt,(0,p.Z)({},Jmt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}edt.isMDXComponent=!0;const ndt={toc:[]},odt="wrapper";function pdt(t){let{components:e,...n}=t;return(0,s.kt)(odt,(0,p.Z)({},ndt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}pdt.isMDXComponent=!0;const rdt={toc:[]},sdt="wrapper";function cdt(t){let{components:e,...n}=t;return(0,s.kt)(sdt,(0,p.Z)({},rdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}cdt.isMDXComponent=!0;const adt={toc:[]},idt="wrapper";function ldt(t){let{components:e,...n}=t;return(0,s.kt)(idt,(0,p.Z)({},adt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}ldt.isMDXComponent=!0;const udt={toc:[]},mdt="wrapper";function ddt(t){let{components:e,...n}=t;return(0,s.kt)(mdt,(0,p.Z)({},udt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ddt.isMDXComponent=!0;const hdt={toc:[]},fdt="wrapper";function kdt(t){let{components:e,...n}=t;return(0,s.kt)(fdt,(0,p.Z)({},hdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}kdt.isMDXComponent=!0;const ydt={toc:[]},Ddt="wrapper";function Mdt(t){let{components:e,...n}=t;return(0,s.kt)(Ddt,(0,p.Z)({},ydt,n,{components:e,mdxType:"MDXLayout"}))}Mdt.isMDXComponent=!0;const Xdt={toc:[]},_dt="wrapper";function wdt(t){let{components:e,...n}=t;return(0,s.kt)(_dt,(0,p.Z)({},Xdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}wdt.isMDXComponent=!0;const Tdt={toc:[]},Cdt="wrapper";function xdt(t){let{components:e,...n}=t;return(0,s.kt)(Cdt,(0,p.Z)({},Tdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}xdt.isMDXComponent=!0;const gdt={toc:[]},vdt="wrapper";function Ldt(t){let{components:e,...n}=t;return(0,s.kt)(vdt,(0,p.Z)({},gdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Ldt.isMDXComponent=!0;const Zdt={toc:[]},bdt="wrapper";function Ndt(t){let{components:e,...n}=t;return(0,s.kt)(bdt,(0,p.Z)({},Zdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Ndt.isMDXComponent=!0;const zdt={toc:[]},Adt="wrapper";function Pdt(t){let{components:e,...n}=t;return(0,s.kt)(Adt,(0,p.Z)({},zdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Pdt.isMDXComponent=!0;const Wdt={toc:[]},Rdt="wrapper";function Idt(t){let{components:e,...n}=t;return(0,s.kt)(Rdt,(0,p.Z)({},Wdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Idt.isMDXComponent=!0;const Sdt={toc:[]},Bdt="wrapper";function Gdt(t){let{components:e,...n}=t;return(0,s.kt)(Bdt,(0,p.Z)({},Sdt,n,{components:e,mdxType:"MDXLayout"}))}Gdt.isMDXComponent=!0;const Edt={toc:[]},Odt="wrapper";function Fdt(t){let{components:e,...n}=t;return(0,s.kt)(Odt,(0,p.Z)({},Edt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Fdt.isMDXComponent=!0;const Udt={toc:[]},Vdt="wrapper";function qdt(t){let{components:e,...n}=t;return(0,s.kt)(Vdt,(0,p.Z)({},Udt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}qdt.isMDXComponent=!0;const jdt={toc:[]},Ydt="wrapper";function Qdt(t){let{components:e,...n}=t;return(0,s.kt)(Ydt,(0,p.Z)({},jdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Qdt.isMDXComponent=!0;const Hdt={toc:[]},Kdt="wrapper";function $dt(t){let{components:e,...n}=t;return(0,s.kt)(Kdt,(0,p.Z)({},Hdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}$dt.isMDXComponent=!0;const Jdt={toc:[]},tht="wrapper";function eht(t){let{components:e,...n}=t;return(0,s.kt)(tht,(0,p.Z)({},Jdt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}eht.isMDXComponent=!0;const nht={toc:[]},oht="wrapper";function pht(t){let{components:e,...n}=t;return(0,s.kt)(oht,(0,p.Z)({},nht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}pht.isMDXComponent=!0;const rht={toc:[]},sht="wrapper";function cht(t){let{components:e,...n}=t;return(0,s.kt)(sht,(0,p.Z)({},rht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}cht.isMDXComponent=!0;const aht={toc:[]},iht="wrapper";function lht(t){let{components:e,...n}=t;return(0,s.kt)(iht,(0,p.Z)({},aht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}lht.isMDXComponent=!0;const uht={toc:[]},mht="wrapper";function dht(t){let{components:e,...n}=t;return(0,s.kt)(mht,(0,p.Z)({},uht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}dht.isMDXComponent=!0;const hht={toc:[]},fht="wrapper";function kht(t){let{components:e,...n}=t;return(0,s.kt)(fht,(0,p.Z)({},hht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}kht.isMDXComponent=!0;const yht={toc:[]},Dht="wrapper";function Mht(t){let{components:e,...n}=t;return(0,s.kt)(Dht,(0,p.Z)({},yht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Mht.isMDXComponent=!0;const Xht={toc:[]},_ht="wrapper";function wht(t){let{components:e,...n}=t;return(0,s.kt)(_ht,(0,p.Z)({},Xht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}wht.isMDXComponent=!0;const Tht={toc:[]},Cht="wrapper";function xht(t){let{components:e,...n}=t;return(0,s.kt)(Cht,(0,p.Z)({},Tht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}xht.isMDXComponent=!0;const ght={toc:[]},vht="wrapper";function Lht(t){let{components:e,...n}=t;return(0,s.kt)(vht,(0,p.Z)({},ght,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Lht.isMDXComponent=!0;const Zht={toc:[]},bht="wrapper";function Nht(t){let{components:e,...n}=t;return(0,s.kt)(bht,(0,p.Z)({},Zht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Nht.isMDXComponent=!0;const zht={toc:[]},Aht="wrapper";function Pht(t){let{components:e,...n}=t;return(0,s.kt)(Aht,(0,p.Z)({},zht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Pht.isMDXComponent=!0;const Wht={toc:[]},Rht="wrapper";function Iht(t){let{components:e,...n}=t;return(0,s.kt)(Rht,(0,p.Z)({},Wht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Iht.isMDXComponent=!0;const Sht={toc:[]},Bht="wrapper";function Ght(t){let{components:e,...n}=t;return(0,s.kt)(Bht,(0,p.Z)({},Sht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Ght.isMDXComponent=!0;const Eht={toc:[]},Oht="wrapper";function Fht(t){let{components:e,...n}=t;return(0,s.kt)(Oht,(0,p.Z)({},Eht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Fht.isMDXComponent=!0;const Uht={toc:[]},Vht="wrapper";function qht(t){let{components:e,...n}=t;return(0,s.kt)(Vht,(0,p.Z)({},Uht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}qht.isMDXComponent=!0;const jht={toc:[]},Yht="wrapper";function Qht(t){let{components:e,...n}=t;return(0,s.kt)(Yht,(0,p.Z)({},jht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Qht.isMDXComponent=!0;const Hht={toc:[]},Kht="wrapper";function $ht(t){let{components:e,...n}=t;return(0,s.kt)(Kht,(0,p.Z)({},Hht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}$ht.isMDXComponent=!0;const Jht={toc:[]},tft="wrapper";function eft(t){let{components:e,...n}=t;return(0,s.kt)(tft,(0,p.Z)({},Jht,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}eft.isMDXComponent=!0;const nft={toc:[]},oft="wrapper";function pft(t){let{components:e,...n}=t;return(0,s.kt)(oft,(0,p.Z)({},nft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}pft.isMDXComponent=!0;const rft={toc:[]},sft="wrapper";function cft(t){let{components:e,...n}=t;return(0,s.kt)(sft,(0,p.Z)({},rft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}cft.isMDXComponent=!0;const aft={toc:[]},ift="wrapper";function lft(t){let{components:e,...n}=t;return(0,s.kt)(ift,(0,p.Z)({},aft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}lft.isMDXComponent=!0;const uft={toc:[]},mft="wrapper";function dft(t){let{components:e,...n}=t;return(0,s.kt)(mft,(0,p.Z)({},uft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}dft.isMDXComponent=!0;const hft={toc:[]},fft="wrapper";function kft(t){let{components:e,...n}=t;return(0,s.kt)(fft,(0,p.Z)({},hft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}kft.isMDXComponent=!0;const yft={toc:[]},Dft="wrapper";function Mft(t){let{components:e,...n}=t;return(0,s.kt)(Dft,(0,p.Z)({},yft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Mft.isMDXComponent=!0;const Xft={toc:[]},_ft="wrapper";function wft(t){let{components:e,...n}=t;return(0,s.kt)(_ft,(0,p.Z)({},Xft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}wft.isMDXComponent=!0;const Tft={toc:[]},Cft="wrapper";function xft(t){let{components:e,...n}=t;return(0,s.kt)(Cft,(0,p.Z)({},Tft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}xft.isMDXComponent=!0;const gft={toc:[]},vft="wrapper";function Lft(t){let{components:e,...n}=t;return(0,s.kt)(vft,(0,p.Z)({},gft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Lft.isMDXComponent=!0;const Zft={toc:[]},bft="wrapper";function Nft(t){let{components:e,...n}=t;return(0,s.kt)(bft,(0,p.Z)({},Zft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Nft.isMDXComponent=!0;const zft={toc:[]},Aft="wrapper";function Pft(t){let{components:e,...n}=t;return(0,s.kt)(Aft,(0,p.Z)({},zft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Pft.isMDXComponent=!0;const Wft={toc:[]},Rft="wrapper";function Ift(t){let{components:e,...n}=t;return(0,s.kt)(Rft,(0,p.Z)({},Wft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Ift.isMDXComponent=!0;const Sft={toc:[]},Bft="wrapper";function Gft(t){let{components:e,...n}=t;return(0,s.kt)(Bft,(0,p.Z)({},Sft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Gft.isMDXComponent=!0;const Eft={toc:[]},Oft="wrapper";function Fft(t){let{components:e,...n}=t;return(0,s.kt)(Oft,(0,p.Z)({},Eft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Fft.isMDXComponent=!0;const Uft={toc:[]},Vft="wrapper";function qft(t){let{components:e,...n}=t;return(0,s.kt)(Vft,(0,p.Z)({},Uft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}qft.isMDXComponent=!0;const jft={toc:[]},Yft="wrapper";function Qft(t){let{components:e,...n}=t;return(0,s.kt)(Yft,(0,p.Z)({},jft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Qft.isMDXComponent=!0;const Hft={toc:[]},Kft="wrapper";function $ft(t){let{components:e,...n}=t;return(0,s.kt)(Kft,(0,p.Z)({},Hft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}$ft.isMDXComponent=!0;const Jft={toc:[]},tkt="wrapper";function ekt(t){let{components:e,...n}=t;return(0,s.kt)(tkt,(0,p.Z)({},Jft,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}ekt.isMDXComponent=!0;const nkt={toc:[]},okt="wrapper";function pkt(t){let{components:e,...n}=t;return(0,s.kt)(okt,(0,p.Z)({},nkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}pkt.isMDXComponent=!0;const rkt={toc:[]},skt="wrapper";function ckt(t){let{components:e,...n}=t;return(0,s.kt)(skt,(0,p.Z)({},rkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}ckt.isMDXComponent=!0;const akt={toc:[]},ikt="wrapper";function lkt(t){let{components:e,...n}=t;return(0,s.kt)(ikt,(0,p.Z)({},akt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}lkt.isMDXComponent=!0;const ukt={toc:[]},mkt="wrapper";function dkt(t){let{components:e,...n}=t;return(0,s.kt)(mkt,(0,p.Z)({},ukt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}dkt.isMDXComponent=!0;const hkt={toc:[]},fkt="wrapper";function kkt(t){let{components:e,...n}=t;return(0,s.kt)(fkt,(0,p.Z)({},hkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}kkt.isMDXComponent=!0;const ykt={toc:[]},Dkt="wrapper";function Mkt(t){let{components:e,...n}=t;return(0,s.kt)(Dkt,(0,p.Z)({},ykt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Mkt.isMDXComponent=!0;const Xkt={toc:[]},_kt="wrapper";function wkt(t){let{components:e,...n}=t;return(0,s.kt)(_kt,(0,p.Z)({},Xkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wkt.isMDXComponent=!0;const Tkt={toc:[]},Ckt="wrapper";function xkt(t){let{components:e,...n}=t;return(0,s.kt)(Ckt,(0,p.Z)({},Tkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}xkt.isMDXComponent=!0;const gkt={toc:[]},vkt="wrapper";function Lkt(t){let{components:e,...n}=t;return(0,s.kt)(vkt,(0,p.Z)({},gkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Lkt.isMDXComponent=!0;const Zkt={toc:[]},bkt="wrapper";function Nkt(t){let{components:e,...n}=t;return(0,s.kt)(bkt,(0,p.Z)({},Zkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Nkt.isMDXComponent=!0;const zkt={toc:[]},Akt="wrapper";function Pkt(t){let{components:e,...n}=t;return(0,s.kt)(Akt,(0,p.Z)({},zkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Pkt.isMDXComponent=!0;const Wkt={toc:[]},Rkt="wrapper";function Ikt(t){let{components:e,...n}=t;return(0,s.kt)(Rkt,(0,p.Z)({},Wkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Ikt.isMDXComponent=!0;const Skt={toc:[]},Bkt="wrapper";function Gkt(t){let{components:e,...n}=t;return(0,s.kt)(Bkt,(0,p.Z)({},Skt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Gkt.isMDXComponent=!0;const Ekt={toc:[]},Okt="wrapper";function Fkt(t){let{components:e,...n}=t;return(0,s.kt)(Okt,(0,p.Z)({},Ekt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Fkt.isMDXComponent=!0;const Ukt={toc:[]},Vkt="wrapper";function qkt(t){let{components:e,...n}=t;return(0,s.kt)(Vkt,(0,p.Z)({},Ukt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qkt.isMDXComponent=!0;const jkt={toc:[]},Ykt="wrapper";function Qkt(t){let{components:e,...n}=t;return(0,s.kt)(Ykt,(0,p.Z)({},jkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Qkt.isMDXComponent=!0;const Hkt={toc:[]},Kkt="wrapper";function $kt(t){let{components:e,...n}=t;return(0,s.kt)(Kkt,(0,p.Z)({},Hkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}$kt.isMDXComponent=!0;const Jkt={toc:[]},tyt="wrapper";function eyt(t){let{components:e,...n}=t;return(0,s.kt)(tyt,(0,p.Z)({},Jkt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}eyt.isMDXComponent=!0;const nyt={toc:[]},oyt="wrapper";function pyt(t){let{components:e,...n}=t;return(0,s.kt)(oyt,(0,p.Z)({},nyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pyt.isMDXComponent=!0;const ryt={toc:[]},syt="wrapper";function cyt(t){let{components:e,...n}=t;return(0,s.kt)(syt,(0,p.Z)({},ryt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}cyt.isMDXComponent=!0;const ayt={toc:[]},iyt="wrapper";function lyt(t){let{components:e,...n}=t;return(0,s.kt)(iyt,(0,p.Z)({},ayt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lyt.isMDXComponent=!0;const uyt={toc:[]},myt="wrapper";function dyt(t){let{components:e,...n}=t;return(0,s.kt)(myt,(0,p.Z)({},uyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}dyt.isMDXComponent=!0;const hyt={toc:[]},fyt="wrapper";function kyt(t){let{components:e,...n}=t;return(0,s.kt)(fyt,(0,p.Z)({},hyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kyt.isMDXComponent=!0;const yyt={toc:[]},Dyt="wrapper";function Myt(t){let{components:e,...n}=t;return(0,s.kt)(Dyt,(0,p.Z)({},yyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Myt.isMDXComponent=!0;const Xyt={toc:[]},_yt="wrapper";function wyt(t){let{components:e,...n}=t;return(0,s.kt)(_yt,(0,p.Z)({},Xyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wyt.isMDXComponent=!0;const Tyt={toc:[]},Cyt="wrapper";function xyt(t){let{components:e,...n}=t;return(0,s.kt)(Cyt,(0,p.Z)({},Tyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}xyt.isMDXComponent=!0;const gyt={toc:[]},vyt="wrapper";function Lyt(t){let{components:e,...n}=t;return(0,s.kt)(vyt,(0,p.Z)({},gyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lyt.isMDXComponent=!0;const Zyt={toc:[]},byt="wrapper";function Nyt(t){let{components:e,...n}=t;return(0,s.kt)(byt,(0,p.Z)({},Zyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Nyt.isMDXComponent=!0;const zyt={toc:[]},Ayt="wrapper";function Pyt(t){let{components:e,...n}=t;return(0,s.kt)(Ayt,(0,p.Z)({},zyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Pyt.isMDXComponent=!0;const Wyt={toc:[]},Ryt="wrapper";function Iyt(t){let{components:e,...n}=t;return(0,s.kt)(Ryt,(0,p.Z)({},Wyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Iyt.isMDXComponent=!0;const Syt={toc:[]},Byt="wrapper";function Gyt(t){let{components:e,...n}=t;return(0,s.kt)(Byt,(0,p.Z)({},Syt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Gyt.isMDXComponent=!0;const Eyt={toc:[]},Oyt="wrapper";function Fyt(t){let{components:e,...n}=t;return(0,s.kt)(Oyt,(0,p.Z)({},Eyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Fyt.isMDXComponent=!0;const Uyt={toc:[]},Vyt="wrapper";function qyt(t){let{components:e,...n}=t;return(0,s.kt)(Vyt,(0,p.Z)({},Uyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}qyt.isMDXComponent=!0;const jyt={toc:[]},Yyt="wrapper";function Qyt(t){let{components:e,...n}=t;return(0,s.kt)(Yyt,(0,p.Z)({},jyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Qyt.isMDXComponent=!0;const Hyt={toc:[]},Kyt="wrapper";function $yt(t){let{components:e,...n}=t;return(0,s.kt)(Kyt,(0,p.Z)({},Hyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}$yt.isMDXComponent=!0;const Jyt={toc:[]},tDt="wrapper";function eDt(t){let{components:e,...n}=t;return(0,s.kt)(tDt,(0,p.Z)({},Jyt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}eDt.isMDXComponent=!0;const nDt={toc:[]},oDt="wrapper";function pDt(t){let{components:e,...n}=t;return(0,s.kt)(oDt,(0,p.Z)({},nDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}pDt.isMDXComponent=!0;const rDt={toc:[]},sDt="wrapper";function cDt(t){let{components:e,...n}=t;return(0,s.kt)(sDt,(0,p.Z)({},rDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}cDt.isMDXComponent=!0;const aDt={toc:[]},iDt="wrapper";function lDt(t){let{components:e,...n}=t;return(0,s.kt)(iDt,(0,p.Z)({},aDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}lDt.isMDXComponent=!0;const uDt={toc:[]},mDt="wrapper";function dDt(t){let{components:e,...n}=t;return(0,s.kt)(mDt,(0,p.Z)({},uDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}dDt.isMDXComponent=!0;const hDt={toc:[]},fDt="wrapper";function kDt(t){let{components:e,...n}=t;return(0,s.kt)(fDt,(0,p.Z)({},hDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}kDt.isMDXComponent=!0;const yDt={toc:[]},DDt="wrapper";function MDt(t){let{components:e,...n}=t;return(0,s.kt)(DDt,(0,p.Z)({},yDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}MDt.isMDXComponent=!0;const XDt={toc:[]},_Dt="wrapper";function wDt(t){let{components:e,...n}=t;return(0,s.kt)(_Dt,(0,p.Z)({},XDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}wDt.isMDXComponent=!0;const TDt={toc:[]},CDt="wrapper";function xDt(t){let{components:e,...n}=t;return(0,s.kt)(CDt,(0,p.Z)({},TDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}xDt.isMDXComponent=!0;const gDt={toc:[]},vDt="wrapper";function LDt(t){let{components:e,...n}=t;return(0,s.kt)(vDt,(0,p.Z)({},gDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}LDt.isMDXComponent=!0;const ZDt={toc:[]},bDt="wrapper";function NDt(t){let{components:e,...n}=t;return(0,s.kt)(bDt,(0,p.Z)({},ZDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}NDt.isMDXComponent=!0;const zDt={toc:[]},ADt="wrapper";function PDt(t){let{components:e,...n}=t;return(0,s.kt)(ADt,(0,p.Z)({},zDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}PDt.isMDXComponent=!0;const WDt={toc:[]},RDt="wrapper";function IDt(t){let{components:e,...n}=t;return(0,s.kt)(RDt,(0,p.Z)({},WDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}IDt.isMDXComponent=!0;const SDt={toc:[]},BDt="wrapper";function GDt(t){let{components:e,...n}=t;return(0,s.kt)(BDt,(0,p.Z)({},SDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}GDt.isMDXComponent=!0;const EDt={toc:[]},ODt="wrapper";function FDt(t){let{components:e,...n}=t;return(0,s.kt)(ODt,(0,p.Z)({},EDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}FDt.isMDXComponent=!0;const UDt={toc:[]},VDt="wrapper";function qDt(t){let{components:e,...n}=t;return(0,s.kt)(VDt,(0,p.Z)({},UDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}qDt.isMDXComponent=!0;const jDt={toc:[]},YDt="wrapper";function QDt(t){let{components:e,...n}=t;return(0,s.kt)(YDt,(0,p.Z)({},jDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}QDt.isMDXComponent=!0;const HDt={toc:[]},KDt="wrapper";function $Dt(t){let{components:e,...n}=t;return(0,s.kt)(KDt,(0,p.Z)({},HDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}$Dt.isMDXComponent=!0;const JDt={toc:[]},tMt="wrapper";function eMt(t){let{components:e,...n}=t;return(0,s.kt)(tMt,(0,p.Z)({},JDt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}eMt.isMDXComponent=!0;const nMt={toc:[]},oMt="wrapper";function pMt(t){let{components:e,...n}=t;return(0,s.kt)(oMt,(0,p.Z)({},nMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}pMt.isMDXComponent=!0;const rMt={toc:[]},sMt="wrapper";function cMt(t){let{components:e,...n}=t;return(0,s.kt)(sMt,(0,p.Z)({},rMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}cMt.isMDXComponent=!0;const aMt={toc:[]},iMt="wrapper";function lMt(t){let{components:e,...n}=t;return(0,s.kt)(iMt,(0,p.Z)({},aMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}lMt.isMDXComponent=!0;const uMt={toc:[]},mMt="wrapper";function dMt(t){let{components:e,...n}=t;return(0,s.kt)(mMt,(0,p.Z)({},uMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}dMt.isMDXComponent=!0;const hMt={toc:[]},fMt="wrapper";function kMt(t){let{components:e,...n}=t;return(0,s.kt)(fMt,(0,p.Z)({},hMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}kMt.isMDXComponent=!0;const yMt={toc:[]},DMt="wrapper";function MMt(t){let{components:e,...n}=t;return(0,s.kt)(DMt,(0,p.Z)({},yMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}MMt.isMDXComponent=!0;const XMt={toc:[]},_Mt="wrapper";function wMt(t){let{components:e,...n}=t;return(0,s.kt)(_Mt,(0,p.Z)({},XMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}wMt.isMDXComponent=!0;const TMt={toc:[]},CMt="wrapper";function xMt(t){let{components:e,...n}=t;return(0,s.kt)(CMt,(0,p.Z)({},TMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}xMt.isMDXComponent=!0;const gMt={toc:[]},vMt="wrapper";function LMt(t){let{components:e,...n}=t;return(0,s.kt)(vMt,(0,p.Z)({},gMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}LMt.isMDXComponent=!0;const ZMt={toc:[]},bMt="wrapper";function NMt(t){let{components:e,...n}=t;return(0,s.kt)(bMt,(0,p.Z)({},ZMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}NMt.isMDXComponent=!0;const zMt={toc:[]},AMt="wrapper";function PMt(t){let{components:e,...n}=t;return(0,s.kt)(AMt,(0,p.Z)({},zMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}PMt.isMDXComponent=!0;const WMt={toc:[]},RMt="wrapper";function IMt(t){let{components:e,...n}=t;return(0,s.kt)(RMt,(0,p.Z)({},WMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}IMt.isMDXComponent=!0;const SMt={toc:[]},BMt="wrapper";function GMt(t){let{components:e,...n}=t;return(0,s.kt)(BMt,(0,p.Z)({},SMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}GMt.isMDXComponent=!0;const EMt={toc:[]},OMt="wrapper";function FMt(t){let{components:e,...n}=t;return(0,s.kt)(OMt,(0,p.Z)({},EMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}FMt.isMDXComponent=!0;const UMt={toc:[]},VMt="wrapper";function qMt(t){let{components:e,...n}=t;return(0,s.kt)(VMt,(0,p.Z)({},UMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}qMt.isMDXComponent=!0;const jMt={toc:[]},YMt="wrapper";function QMt(t){let{components:e,...n}=t;return(0,s.kt)(YMt,(0,p.Z)({},jMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}QMt.isMDXComponent=!0;const HMt={toc:[]},KMt="wrapper";function $Mt(t){let{components:e,...n}=t;return(0,s.kt)(KMt,(0,p.Z)({},HMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}$Mt.isMDXComponent=!0;const JMt={toc:[]},tXt="wrapper";function eXt(t){let{components:e,...n}=t;return(0,s.kt)(tXt,(0,p.Z)({},JMt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}eXt.isMDXComponent=!0;const nXt={toc:[]},oXt="wrapper";function pXt(t){let{components:e,...n}=t;return(0,s.kt)(oXt,(0,p.Z)({},nXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}pXt.isMDXComponent=!0;const rXt={toc:[]},sXt="wrapper";function cXt(t){let{components:e,...n}=t;return(0,s.kt)(sXt,(0,p.Z)({},rXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}cXt.isMDXComponent=!0;const aXt={toc:[]},iXt="wrapper";function lXt(t){let{components:e,...n}=t;return(0,s.kt)(iXt,(0,p.Z)({},aXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}lXt.isMDXComponent=!0;const uXt={toc:[]},mXt="wrapper";function dXt(t){let{components:e,...n}=t;return(0,s.kt)(mXt,(0,p.Z)({},uXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}dXt.isMDXComponent=!0;const hXt={toc:[]},fXt="wrapper";function kXt(t){let{components:e,...n}=t;return(0,s.kt)(fXt,(0,p.Z)({},hXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}kXt.isMDXComponent=!0;const yXt={toc:[]},DXt="wrapper";function MXt(t){let{components:e,...n}=t;return(0,s.kt)(DXt,(0,p.Z)({},yXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}MXt.isMDXComponent=!0;const XXt={toc:[]},_Xt="wrapper";function wXt(t){let{components:e,...n}=t;return(0,s.kt)(_Xt,(0,p.Z)({},XXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}wXt.isMDXComponent=!0;const TXt={toc:[]},CXt="wrapper";function xXt(t){let{components:e,...n}=t;return(0,s.kt)(CXt,(0,p.Z)({},TXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}xXt.isMDXComponent=!0;const gXt={toc:[]},vXt="wrapper";function LXt(t){let{components:e,...n}=t;return(0,s.kt)(vXt,(0,p.Z)({},gXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}LXt.isMDXComponent=!0;const ZXt={toc:[]},bXt="wrapper";function NXt(t){let{components:e,...n}=t;return(0,s.kt)(bXt,(0,p.Z)({},ZXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}NXt.isMDXComponent=!0;const zXt={toc:[]},AXt="wrapper";function PXt(t){let{components:e,...n}=t;return(0,s.kt)(AXt,(0,p.Z)({},zXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}PXt.isMDXComponent=!0;const WXt={toc:[]},RXt="wrapper";function IXt(t){let{components:e,...n}=t;return(0,s.kt)(RXt,(0,p.Z)({},WXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}IXt.isMDXComponent=!0;const SXt={toc:[]},BXt="wrapper";function GXt(t){let{components:e,...n}=t;return(0,s.kt)(BXt,(0,p.Z)({},SXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}GXt.isMDXComponent=!0;const EXt={toc:[]},OXt="wrapper";function FXt(t){let{components:e,...n}=t;return(0,s.kt)(OXt,(0,p.Z)({},EXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}FXt.isMDXComponent=!0;const UXt={toc:[]},VXt="wrapper";function qXt(t){let{components:e,...n}=t;return(0,s.kt)(VXt,(0,p.Z)({},UXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}qXt.isMDXComponent=!0;const jXt={toc:[]},YXt="wrapper";function QXt(t){let{components:e,...n}=t;return(0,s.kt)(YXt,(0,p.Z)({},jXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}QXt.isMDXComponent=!0;const HXt={toc:[]},KXt="wrapper";function $Xt(t){let{components:e,...n}=t;return(0,s.kt)(KXt,(0,p.Z)({},HXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}$Xt.isMDXComponent=!0;const JXt={toc:[]},t_t="wrapper";function e_t(t){let{components:e,...n}=t;return(0,s.kt)(t_t,(0,p.Z)({},JXt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}e_t.isMDXComponent=!0;const n_t={toc:[]},o_t="wrapper";function p_t(t){let{components:e,...n}=t;return(0,s.kt)(o_t,(0,p.Z)({},n_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}p_t.isMDXComponent=!0;const r_t={toc:[]},s_t="wrapper";function c_t(t){let{components:e,...n}=t;return(0,s.kt)(s_t,(0,p.Z)({},r_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}c_t.isMDXComponent=!0;const a_t={toc:[]},i_t="wrapper";function l_t(t){let{components:e,...n}=t;return(0,s.kt)(i_t,(0,p.Z)({},a_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}l_t.isMDXComponent=!0;const u_t={toc:[]},m_t="wrapper";function d_t(t){let{components:e,...n}=t;return(0,s.kt)(m_t,(0,p.Z)({},u_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}d_t.isMDXComponent=!0;const h_t={toc:[]},f_t="wrapper";function k_t(t){let{components:e,...n}=t;return(0,s.kt)(f_t,(0,p.Z)({},h_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}k_t.isMDXComponent=!0;const y_t={toc:[]},D_t="wrapper";function M_t(t){let{components:e,...n}=t;return(0,s.kt)(D_t,(0,p.Z)({},y_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}M_t.isMDXComponent=!0;const X_t={toc:[]},__t="wrapper";function w_t(t){let{components:e,...n}=t;return(0,s.kt)(__t,(0,p.Z)({},X_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}w_t.isMDXComponent=!0;const T_t={toc:[]},C_t="wrapper";function x_t(t){let{components:e,...n}=t;return(0,s.kt)(C_t,(0,p.Z)({},T_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}x_t.isMDXComponent=!0;const g_t={toc:[]},v_t="wrapper";function L_t(t){let{components:e,...n}=t;return(0,s.kt)(v_t,(0,p.Z)({},g_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}L_t.isMDXComponent=!0;const Z_t={toc:[]},b_t="wrapper";function N_t(t){let{components:e,...n}=t;return(0,s.kt)(b_t,(0,p.Z)({},Z_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}N_t.isMDXComponent=!0;const z_t={toc:[]},A_t="wrapper";function P_t(t){let{components:e,...n}=t;return(0,s.kt)(A_t,(0,p.Z)({},z_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}P_t.isMDXComponent=!0;const W_t={toc:[]},R_t="wrapper";function I_t(t){let{components:e,...n}=t;return(0,s.kt)(R_t,(0,p.Z)({},W_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}I_t.isMDXComponent=!0;const S_t={toc:[]},B_t="wrapper";function G_t(t){let{components:e,...n}=t;return(0,s.kt)(B_t,(0,p.Z)({},S_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}G_t.isMDXComponent=!0;const E_t={toc:[]},O_t="wrapper";function F_t(t){let{components:e,...n}=t;return(0,s.kt)(O_t,(0,p.Z)({},E_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}F_t.isMDXComponent=!0;const U_t={toc:[]},V_t="wrapper";function q_t(t){let{components:e,...n}=t;return(0,s.kt)(V_t,(0,p.Z)({},U_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}q_t.isMDXComponent=!0;const j_t={toc:[]},Y_t="wrapper";function Q_t(t){let{components:e,...n}=t;return(0,s.kt)(Y_t,(0,p.Z)({},j_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Q_t.isMDXComponent=!0;const H_t={toc:[]},K_t="wrapper";function $_t(t){let{components:e,...n}=t;return(0,s.kt)(K_t,(0,p.Z)({},H_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}$_t.isMDXComponent=!0;const J_t={toc:[]},twt="wrapper";function ewt(t){let{components:e,...n}=t;return(0,s.kt)(twt,(0,p.Z)({},J_t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}ewt.isMDXComponent=!0;const nwt={toc:[]},owt="wrapper";function pwt(t){let{components:e,...n}=t;return(0,s.kt)(owt,(0,p.Z)({},nwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}pwt.isMDXComponent=!0;const rwt={toc:[]},swt="wrapper";function cwt(t){let{components:e,...n}=t;return(0,s.kt)(swt,(0,p.Z)({},rwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}cwt.isMDXComponent=!0;const awt={toc:[]},iwt="wrapper";function lwt(t){let{components:e,...n}=t;return(0,s.kt)(iwt,(0,p.Z)({},awt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}lwt.isMDXComponent=!0;const uwt={toc:[]},mwt="wrapper";function dwt(t){let{components:e,...n}=t;return(0,s.kt)(mwt,(0,p.Z)({},uwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}dwt.isMDXComponent=!0;const hwt={toc:[]},fwt="wrapper";function kwt(t){let{components:e,...n}=t;return(0,s.kt)(fwt,(0,p.Z)({},hwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}kwt.isMDXComponent=!0;const ywt={toc:[]},Dwt="wrapper";function Mwt(t){let{components:e,...n}=t;return(0,s.kt)(Dwt,(0,p.Z)({},ywt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Mwt.isMDXComponent=!0;const Xwt={toc:[]},_wt="wrapper";function wwt(t){let{components:e,...n}=t;return(0,s.kt)(_wt,(0,p.Z)({},Xwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wwt.isMDXComponent=!0;const Twt={toc:[]},Cwt="wrapper";function xwt(t){let{components:e,...n}=t;return(0,s.kt)(Cwt,(0,p.Z)({},Twt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}xwt.isMDXComponent=!0;const gwt={toc:[]},vwt="wrapper";function Lwt(t){let{components:e,...n}=t;return(0,s.kt)(vwt,(0,p.Z)({},gwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Lwt.isMDXComponent=!0;const Zwt={toc:[]},bwt="wrapper";function Nwt(t){let{components:e,...n}=t;return(0,s.kt)(bwt,(0,p.Z)({},Zwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Nwt.isMDXComponent=!0;const zwt={toc:[]},Awt="wrapper";function Pwt(t){let{components:e,...n}=t;return(0,s.kt)(Awt,(0,p.Z)({},zwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Pwt.isMDXComponent=!0;const Wwt={toc:[]},Rwt="wrapper";function Iwt(t){let{components:e,...n}=t;return(0,s.kt)(Rwt,(0,p.Z)({},Wwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Iwt.isMDXComponent=!0;const Swt={toc:[]},Bwt="wrapper";function Gwt(t){let{components:e,...n}=t;return(0,s.kt)(Bwt,(0,p.Z)({},Swt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Gwt.isMDXComponent=!0;const Ewt={toc:[]},Owt="wrapper";function Fwt(t){let{components:e,...n}=t;return(0,s.kt)(Owt,(0,p.Z)({},Ewt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Fwt.isMDXComponent=!0;const Uwt={toc:[]},Vwt="wrapper";function qwt(t){let{components:e,...n}=t;return(0,s.kt)(Vwt,(0,p.Z)({},Uwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}qwt.isMDXComponent=!0;const jwt={toc:[]},Ywt="wrapper";function Qwt(t){let{components:e,...n}=t;return(0,s.kt)(Ywt,(0,p.Z)({},jwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Qwt.isMDXComponent=!0;const Hwt={toc:[]},Kwt="wrapper";function $wt(t){let{components:e,...n}=t;return(0,s.kt)(Kwt,(0,p.Z)({},Hwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}$wt.isMDXComponent=!0;const Jwt={toc:[]},tTt="wrapper";function eTt(t){let{components:e,...n}=t;return(0,s.kt)(tTt,(0,p.Z)({},Jwt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}eTt.isMDXComponent=!0;const nTt={toc:[]},oTt="wrapper";function pTt(t){let{components:e,...n}=t;return(0,s.kt)(oTt,(0,p.Z)({},nTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}pTt.isMDXComponent=!0;const rTt={toc:[]},sTt="wrapper";function cTt(t){let{components:e,...n}=t;return(0,s.kt)(sTt,(0,p.Z)({},rTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}cTt.isMDXComponent=!0;const aTt={toc:[]},iTt="wrapper";function lTt(t){let{components:e,...n}=t;return(0,s.kt)(iTt,(0,p.Z)({},aTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}lTt.isMDXComponent=!0;const uTt={toc:[]},mTt="wrapper";function dTt(t){let{components:e,...n}=t;return(0,s.kt)(mTt,(0,p.Z)({},uTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}dTt.isMDXComponent=!0;const hTt={toc:[]},fTt="wrapper";function kTt(t){let{components:e,...n}=t;return(0,s.kt)(fTt,(0,p.Z)({},hTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}kTt.isMDXComponent=!0;const yTt={toc:[]},DTt="wrapper";function MTt(t){let{components:e,...n}=t;return(0,s.kt)(DTt,(0,p.Z)({},yTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}MTt.isMDXComponent=!0;const XTt={toc:[]},_Tt="wrapper";function wTt(t){let{components:e,...n}=t;return(0,s.kt)(_Tt,(0,p.Z)({},XTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}wTt.isMDXComponent=!0;const TTt={toc:[]},CTt="wrapper";function xTt(t){let{components:e,...n}=t;return(0,s.kt)(CTt,(0,p.Z)({},TTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}xTt.isMDXComponent=!0;const gTt={toc:[]},vTt="wrapper";function LTt(t){let{components:e,...n}=t;return(0,s.kt)(vTt,(0,p.Z)({},gTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}LTt.isMDXComponent=!0;const ZTt={toc:[]},bTt="wrapper";function NTt(t){let{components:e,...n}=t;return(0,s.kt)(bTt,(0,p.Z)({},ZTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}NTt.isMDXComponent=!0;const zTt={toc:[]},ATt="wrapper";function PTt(t){let{components:e,...n}=t;return(0,s.kt)(ATt,(0,p.Z)({},zTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}PTt.isMDXComponent=!0;const WTt={toc:[]},RTt="wrapper";function ITt(t){let{components:e,...n}=t;return(0,s.kt)(RTt,(0,p.Z)({},WTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}ITt.isMDXComponent=!0;const STt={toc:[]},BTt="wrapper";function GTt(t){let{components:e,...n}=t;return(0,s.kt)(BTt,(0,p.Z)({},STt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}GTt.isMDXComponent=!0;const ETt={toc:[]},OTt="wrapper";function FTt(t){let{components:e,...n}=t;return(0,s.kt)(OTt,(0,p.Z)({},ETt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}FTt.isMDXComponent=!0;const UTt={toc:[]},VTt="wrapper";function qTt(t){let{components:e,...n}=t;return(0,s.kt)(VTt,(0,p.Z)({},UTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}qTt.isMDXComponent=!0;const jTt={toc:[]},YTt="wrapper";function QTt(t){let{components:e,...n}=t;return(0,s.kt)(YTt,(0,p.Z)({},jTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}QTt.isMDXComponent=!0;const HTt={toc:[]},KTt="wrapper";function $Tt(t){let{components:e,...n}=t;return(0,s.kt)(KTt,(0,p.Z)({},HTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}$Tt.isMDXComponent=!0;const JTt={toc:[]},tCt="wrapper";function eCt(t){let{components:e,...n}=t;return(0,s.kt)(tCt,(0,p.Z)({},JTt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}eCt.isMDXComponent=!0;const nCt={toc:[]},oCt="wrapper";function pCt(t){let{components:e,...n}=t;return(0,s.kt)(oCt,(0,p.Z)({},nCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}pCt.isMDXComponent=!0;const rCt={toc:[]},sCt="wrapper";function cCt(t){let{components:e,...n}=t;return(0,s.kt)(sCt,(0,p.Z)({},rCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}cCt.isMDXComponent=!0;const aCt={toc:[]},iCt="wrapper";function lCt(t){let{components:e,...n}=t;return(0,s.kt)(iCt,(0,p.Z)({},aCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}lCt.isMDXComponent=!0;const uCt={toc:[]},mCt="wrapper";function dCt(t){let{components:e,...n}=t;return(0,s.kt)(mCt,(0,p.Z)({},uCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}dCt.isMDXComponent=!0;const hCt={toc:[]},fCt="wrapper";function kCt(t){let{components:e,...n}=t;return(0,s.kt)(fCt,(0,p.Z)({},hCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}kCt.isMDXComponent=!0;const yCt={toc:[]},DCt="wrapper";function MCt(t){let{components:e,...n}=t;return(0,s.kt)(DCt,(0,p.Z)({},yCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}MCt.isMDXComponent=!0;const XCt={toc:[]},_Ct="wrapper";function wCt(t){let{components:e,...n}=t;return(0,s.kt)(_Ct,(0,p.Z)({},XCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}wCt.isMDXComponent=!0;const TCt={toc:[]},CCt="wrapper";function xCt(t){let{components:e,...n}=t;return(0,s.kt)(CCt,(0,p.Z)({},TCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}xCt.isMDXComponent=!0;const gCt={toc:[]},vCt="wrapper";function LCt(t){let{components:e,...n}=t;return(0,s.kt)(vCt,(0,p.Z)({},gCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}LCt.isMDXComponent=!0;const ZCt={toc:[]},bCt="wrapper";function NCt(t){let{components:e,...n}=t;return(0,s.kt)(bCt,(0,p.Z)({},ZCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}NCt.isMDXComponent=!0;const zCt={toc:[]},ACt="wrapper";function PCt(t){let{components:e,...n}=t;return(0,s.kt)(ACt,(0,p.Z)({},zCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}PCt.isMDXComponent=!0;const WCt={toc:[]},RCt="wrapper";function ICt(t){let{components:e,...n}=t;return(0,s.kt)(RCt,(0,p.Z)({},WCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}ICt.isMDXComponent=!0;const SCt={toc:[]},BCt="wrapper";function GCt(t){let{components:e,...n}=t;return(0,s.kt)(BCt,(0,p.Z)({},SCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}GCt.isMDXComponent=!0;const ECt={toc:[]},OCt="wrapper";function FCt(t){let{components:e,...n}=t;return(0,s.kt)(OCt,(0,p.Z)({},ECt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}FCt.isMDXComponent=!0;const UCt={toc:[]},VCt="wrapper";function qCt(t){let{components:e,...n}=t;return(0,s.kt)(VCt,(0,p.Z)({},UCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}qCt.isMDXComponent=!0;const jCt={toc:[]},YCt="wrapper";function QCt(t){let{components:e,...n}=t;return(0,s.kt)(YCt,(0,p.Z)({},jCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}QCt.isMDXComponent=!0;const HCt={toc:[]},KCt="wrapper";function $Ct(t){let{components:e,...n}=t;return(0,s.kt)(KCt,(0,p.Z)({},HCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}$Ct.isMDXComponent=!0;const JCt={toc:[]},txt="wrapper";function ext(t){let{components:e,...n}=t;return(0,s.kt)(txt,(0,p.Z)({},JCt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}ext.isMDXComponent=!0;const nxt={toc:[]},oxt="wrapper";function pxt(t){let{components:e,...n}=t;return(0,s.kt)(oxt,(0,p.Z)({},nxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}pxt.isMDXComponent=!0;const rxt={toc:[]},sxt="wrapper";function cxt(t){let{components:e,...n}=t;return(0,s.kt)(sxt,(0,p.Z)({},rxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}cxt.isMDXComponent=!0;const axt={toc:[]},ixt="wrapper";function lxt(t){let{components:e,...n}=t;return(0,s.kt)(ixt,(0,p.Z)({},axt,n,{components:e,mdxType:"MDXLayout"}))}lxt.isMDXComponent=!0;const uxt={toc:[]},mxt="wrapper";function dxt(t){let{components:e,...n}=t;return(0,s.kt)(mxt,(0,p.Z)({},uxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}dxt.isMDXComponent=!0;const hxt={toc:[]},fxt="wrapper";function kxt(t){let{components:e,...n}=t;return(0,s.kt)(fxt,(0,p.Z)({},hxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}kxt.isMDXComponent=!0;const yxt={toc:[]},Dxt="wrapper";function Mxt(t){let{components:e,...n}=t;return(0,s.kt)(Dxt,(0,p.Z)({},yxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Mxt.isMDXComponent=!0;const Xxt={toc:[]},_xt="wrapper";function wxt(t){let{components:e,...n}=t;return(0,s.kt)(_xt,(0,p.Z)({},Xxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}wxt.isMDXComponent=!0;const Txt={toc:[]},Cxt="wrapper";function xxt(t){let{components:e,...n}=t;return(0,s.kt)(Cxt,(0,p.Z)({},Txt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}xxt.isMDXComponent=!0;const gxt={toc:[]},vxt="wrapper";function Lxt(t){let{components:e,...n}=t;return(0,s.kt)(vxt,(0,p.Z)({},gxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Lxt.isMDXComponent=!0;const Zxt={toc:[]},bxt="wrapper";function Nxt(t){let{components:e,...n}=t;return(0,s.kt)(bxt,(0,p.Z)({},Zxt,n,{components:e,mdxType:"MDXLayout"}))}Nxt.isMDXComponent=!0;const zxt={toc:[]},Axt="wrapper";function Pxt(t){let{components:e,...n}=t;return(0,s.kt)(Axt,(0,p.Z)({},zxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Pxt.isMDXComponent=!0;const Wxt={toc:[]},Rxt="wrapper";function Ixt(t){let{components:e,...n}=t;return(0,s.kt)(Rxt,(0,p.Z)({},Wxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Ixt.isMDXComponent=!0;const Sxt={toc:[]},Bxt="wrapper";function Gxt(t){let{components:e,...n}=t;return(0,s.kt)(Bxt,(0,p.Z)({},Sxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Gxt.isMDXComponent=!0;const Ext={toc:[]},Oxt="wrapper";function Fxt(t){let{components:e,...n}=t;return(0,s.kt)(Oxt,(0,p.Z)({},Ext,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Fxt.isMDXComponent=!0;const Uxt={toc:[]},Vxt="wrapper";function qxt(t){let{components:e,...n}=t;return(0,s.kt)(Vxt,(0,p.Z)({},Uxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}qxt.isMDXComponent=!0;const jxt={toc:[]},Yxt="wrapper";function Qxt(t){let{components:e,...n}=t;return(0,s.kt)(Yxt,(0,p.Z)({},jxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Qxt.isMDXComponent=!0;const Hxt={toc:[]},Kxt="wrapper";function $xt(t){let{components:e,...n}=t;return(0,s.kt)(Kxt,(0,p.Z)({},Hxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}$xt.isMDXComponent=!0;const Jxt={toc:[]},tgt="wrapper";function egt(t){let{components:e,...n}=t;return(0,s.kt)(tgt,(0,p.Z)({},Jxt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}egt.isMDXComponent=!0;const ngt={toc:[]},ogt="wrapper";function pgt(t){let{components:e,...n}=t;return(0,s.kt)(ogt,(0,p.Z)({},ngt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}pgt.isMDXComponent=!0;const rgt={toc:[]},sgt="wrapper";function cgt(t){let{components:e,...n}=t;return(0,s.kt)(sgt,(0,p.Z)({},rgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}cgt.isMDXComponent=!0;const agt={toc:[]},igt="wrapper";function lgt(t){let{components:e,...n}=t;return(0,s.kt)(igt,(0,p.Z)({},agt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}lgt.isMDXComponent=!0;const ugt={toc:[]},mgt="wrapper";function dgt(t){let{components:e,...n}=t;return(0,s.kt)(mgt,(0,p.Z)({},ugt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}dgt.isMDXComponent=!0;const hgt={toc:[]},fgt="wrapper";function kgt(t){let{components:e,...n}=t;return(0,s.kt)(fgt,(0,p.Z)({},hgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}kgt.isMDXComponent=!0;const ygt={toc:[]},Dgt="wrapper";function Mgt(t){let{components:e,...n}=t;return(0,s.kt)(Dgt,(0,p.Z)({},ygt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Mgt.isMDXComponent=!0;const Xgt={toc:[]},_gt="wrapper";function wgt(t){let{components:e,...n}=t;return(0,s.kt)(_gt,(0,p.Z)({},Xgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}wgt.isMDXComponent=!0;const Tgt={toc:[]},Cgt="wrapper";function xgt(t){let{components:e,...n}=t;return(0,s.kt)(Cgt,(0,p.Z)({},Tgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}xgt.isMDXComponent=!0;const ggt={toc:[]},vgt="wrapper";function Lgt(t){let{components:e,...n}=t;return(0,s.kt)(vgt,(0,p.Z)({},ggt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Lgt.isMDXComponent=!0;const Zgt={toc:[]},bgt="wrapper";function Ngt(t){let{components:e,...n}=t;return(0,s.kt)(bgt,(0,p.Z)({},Zgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Ngt.isMDXComponent=!0;const zgt={toc:[]},Agt="wrapper";function Pgt(t){let{components:e,...n}=t;return(0,s.kt)(Agt,(0,p.Z)({},zgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Pgt.isMDXComponent=!0;const Wgt={toc:[]},Rgt="wrapper";function Igt(t){let{components:e,...n}=t;return(0,s.kt)(Rgt,(0,p.Z)({},Wgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Igt.isMDXComponent=!0;const Sgt={toc:[]},Bgt="wrapper";function Ggt(t){let{components:e,...n}=t;return(0,s.kt)(Bgt,(0,p.Z)({},Sgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Ggt.isMDXComponent=!0;const Egt={toc:[]},Ogt="wrapper";function Fgt(t){let{components:e,...n}=t;return(0,s.kt)(Ogt,(0,p.Z)({},Egt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Fgt.isMDXComponent=!0;const Ugt={toc:[]},Vgt="wrapper";function qgt(t){let{components:e,...n}=t;return(0,s.kt)(Vgt,(0,p.Z)({},Ugt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}qgt.isMDXComponent=!0;const jgt={toc:[]},Ygt="wrapper";function Qgt(t){let{components:e,...n}=t;return(0,s.kt)(Ygt,(0,p.Z)({},jgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Qgt.isMDXComponent=!0;const Hgt={toc:[]},Kgt="wrapper";function $gt(t){let{components:e,...n}=t;return(0,s.kt)(Kgt,(0,p.Z)({},Hgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}$gt.isMDXComponent=!0;const Jgt={toc:[]},tvt="wrapper";function evt(t){let{components:e,...n}=t;return(0,s.kt)(tvt,(0,p.Z)({},Jgt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}evt.isMDXComponent=!0;const nvt={toc:[]},ovt="wrapper";function pvt(t){let{components:e,...n}=t;return(0,s.kt)(ovt,(0,p.Z)({},nvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}pvt.isMDXComponent=!0;const rvt={toc:[]},svt="wrapper";function cvt(t){let{components:e,...n}=t;return(0,s.kt)(svt,(0,p.Z)({},rvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}cvt.isMDXComponent=!0;const avt={toc:[]},ivt="wrapper";function lvt(t){let{components:e,...n}=t;return(0,s.kt)(ivt,(0,p.Z)({},avt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}lvt.isMDXComponent=!0;const uvt={toc:[]},mvt="wrapper";function dvt(t){let{components:e,...n}=t;return(0,s.kt)(mvt,(0,p.Z)({},uvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}dvt.isMDXComponent=!0;const hvt={toc:[]},fvt="wrapper";function kvt(t){let{components:e,...n}=t;return(0,s.kt)(fvt,(0,p.Z)({},hvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}kvt.isMDXComponent=!0;const yvt={toc:[]},Dvt="wrapper";function Mvt(t){let{components:e,...n}=t;return(0,s.kt)(Dvt,(0,p.Z)({},yvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Mvt.isMDXComponent=!0;const Xvt={toc:[]},_vt="wrapper";function wvt(t){let{components:e,...n}=t;return(0,s.kt)(_vt,(0,p.Z)({},Xvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wvt.isMDXComponent=!0;const Tvt={toc:[]},Cvt="wrapper";function xvt(t){let{components:e,...n}=t;return(0,s.kt)(Cvt,(0,p.Z)({},Tvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}xvt.isMDXComponent=!0;const gvt={toc:[]},vvt="wrapper";function Lvt(t){let{components:e,...n}=t;return(0,s.kt)(vvt,(0,p.Z)({},gvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Lvt.isMDXComponent=!0;const Zvt={toc:[]},bvt="wrapper";function Nvt(t){let{components:e,...n}=t;return(0,s.kt)(bvt,(0,p.Z)({},Zvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Nvt.isMDXComponent=!0;const zvt={toc:[]},Avt="wrapper";function Pvt(t){let{components:e,...n}=t;return(0,s.kt)(Avt,(0,p.Z)({},zvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Pvt.isMDXComponent=!0;const Wvt={toc:[]},Rvt="wrapper";function Ivt(t){let{components:e,...n}=t;return(0,s.kt)(Rvt,(0,p.Z)({},Wvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Ivt.isMDXComponent=!0;const Svt={toc:[]},Bvt="wrapper";function Gvt(t){let{components:e,...n}=t;return(0,s.kt)(Bvt,(0,p.Z)({},Svt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Gvt.isMDXComponent=!0;const Evt={toc:[]},Ovt="wrapper";function Fvt(t){let{components:e,...n}=t;return(0,s.kt)(Ovt,(0,p.Z)({},Evt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Fvt.isMDXComponent=!0;const Uvt={toc:[]},Vvt="wrapper";function qvt(t){let{components:e,...n}=t;return(0,s.kt)(Vvt,(0,p.Z)({},Uvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}qvt.isMDXComponent=!0;const jvt={toc:[]},Yvt="wrapper";function Qvt(t){let{components:e,...n}=t;return(0,s.kt)(Yvt,(0,p.Z)({},jvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Qvt.isMDXComponent=!0;const Hvt={toc:[]},Kvt="wrapper";function $vt(t){let{components:e,...n}=t;return(0,s.kt)(Kvt,(0,p.Z)({},Hvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}$vt.isMDXComponent=!0;const Jvt={toc:[]},tLt="wrapper";function eLt(t){let{components:e,...n}=t;return(0,s.kt)(tLt,(0,p.Z)({},Jvt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}eLt.isMDXComponent=!0;const nLt={toc:[]},oLt="wrapper";function pLt(t){let{components:e,...n}=t;return(0,s.kt)(oLt,(0,p.Z)({},nLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}pLt.isMDXComponent=!0;const rLt={toc:[]},sLt="wrapper";function cLt(t){let{components:e,...n}=t;return(0,s.kt)(sLt,(0,p.Z)({},rLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}cLt.isMDXComponent=!0;const aLt={toc:[]},iLt="wrapper";function lLt(t){let{components:e,...n}=t;return(0,s.kt)(iLt,(0,p.Z)({},aLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}lLt.isMDXComponent=!0;const uLt={toc:[]},mLt="wrapper";function dLt(t){let{components:e,...n}=t;return(0,s.kt)(mLt,(0,p.Z)({},uLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}dLt.isMDXComponent=!0;const hLt={toc:[]},fLt="wrapper";function kLt(t){let{components:e,...n}=t;return(0,s.kt)(fLt,(0,p.Z)({},hLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}kLt.isMDXComponent=!0;const yLt={toc:[]},DLt="wrapper";function MLt(t){let{components:e,...n}=t;return(0,s.kt)(DLt,(0,p.Z)({},yLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}MLt.isMDXComponent=!0;const XLt={toc:[]},_Lt="wrapper";function wLt(t){let{components:e,...n}=t;return(0,s.kt)(_Lt,(0,p.Z)({},XLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wLt.isMDXComponent=!0;const TLt={toc:[]},CLt="wrapper";function xLt(t){let{components:e,...n}=t;return(0,s.kt)(CLt,(0,p.Z)({},TLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}xLt.isMDXComponent=!0;const gLt={toc:[]},vLt="wrapper";function LLt(t){let{components:e,...n}=t;return(0,s.kt)(vLt,(0,p.Z)({},gLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}LLt.isMDXComponent=!0;const ZLt={toc:[]},bLt="wrapper";function NLt(t){let{components:e,...n}=t;return(0,s.kt)(bLt,(0,p.Z)({},ZLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NLt.isMDXComponent=!0;const zLt={toc:[]},ALt="wrapper";function PLt(t){let{components:e,...n}=t;return(0,s.kt)(ALt,(0,p.Z)({},zLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}PLt.isMDXComponent=!0;const WLt={toc:[]},RLt="wrapper";function ILt(t){let{components:e,...n}=t;return(0,s.kt)(RLt,(0,p.Z)({},WLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}ILt.isMDXComponent=!0;const SLt={toc:[]},BLt="wrapper";function GLt(t){let{components:e,...n}=t;return(0,s.kt)(BLt,(0,p.Z)({},SLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}GLt.isMDXComponent=!0;const ELt={toc:[]},OLt="wrapper";function FLt(t){let{components:e,...n}=t;return(0,s.kt)(OLt,(0,p.Z)({},ELt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}FLt.isMDXComponent=!0;const ULt={toc:[]},VLt="wrapper";function qLt(t){let{components:e,...n}=t;return(0,s.kt)(VLt,(0,p.Z)({},ULt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}qLt.isMDXComponent=!0;const jLt={toc:[]},YLt="wrapper";function QLt(t){let{components:e,...n}=t;return(0,s.kt)(YLt,(0,p.Z)({},jLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}QLt.isMDXComponent=!0;const HLt={toc:[]},KLt="wrapper";function $Lt(t){let{components:e,...n}=t;return(0,s.kt)(KLt,(0,p.Z)({},HLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}$Lt.isMDXComponent=!0;const JLt={toc:[]},tZt="wrapper";function eZt(t){let{components:e,...n}=t;return(0,s.kt)(tZt,(0,p.Z)({},JLt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}eZt.isMDXComponent=!0;const nZt={toc:[]},oZt="wrapper";function pZt(t){let{components:e,...n}=t;return(0,s.kt)(oZt,(0,p.Z)({},nZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}pZt.isMDXComponent=!0;const rZt={toc:[]},sZt="wrapper";function cZt(t){let{components:e,...n}=t;return(0,s.kt)(sZt,(0,p.Z)({},rZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cZt.isMDXComponent=!0;const aZt={toc:[]},iZt="wrapper";function lZt(t){let{components:e,...n}=t;return(0,s.kt)(iZt,(0,p.Z)({},aZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}lZt.isMDXComponent=!0;const uZt={toc:[]},mZt="wrapper";function dZt(t){let{components:e,...n}=t;return(0,s.kt)(mZt,(0,p.Z)({},uZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dZt.isMDXComponent=!0;const hZt={toc:[]},fZt="wrapper";function kZt(t){let{components:e,...n}=t;return(0,s.kt)(fZt,(0,p.Z)({},hZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}kZt.isMDXComponent=!0;const yZt={toc:[]},DZt="wrapper";function MZt(t){let{components:e,...n}=t;return(0,s.kt)(DZt,(0,p.Z)({},yZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}MZt.isMDXComponent=!0;const XZt={toc:[]},_Zt="wrapper";function wZt(t){let{components:e,...n}=t;return(0,s.kt)(_Zt,(0,p.Z)({},XZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}wZt.isMDXComponent=!0;const TZt={toc:[]},CZt="wrapper";function xZt(t){let{components:e,...n}=t;return(0,s.kt)(CZt,(0,p.Z)({},TZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}xZt.isMDXComponent=!0;const gZt={toc:[]},vZt="wrapper";function LZt(t){let{components:e,...n}=t;return(0,s.kt)(vZt,(0,p.Z)({},gZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}LZt.isMDXComponent=!0;const ZZt={toc:[]},bZt="wrapper";function NZt(t){let{components:e,...n}=t;return(0,s.kt)(bZt,(0,p.Z)({},ZZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}NZt.isMDXComponent=!0;const zZt={toc:[]},AZt="wrapper";function PZt(t){let{components:e,...n}=t;return(0,s.kt)(AZt,(0,p.Z)({},zZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}PZt.isMDXComponent=!0;const WZt={toc:[]},RZt="wrapper";function IZt(t){let{components:e,...n}=t;return(0,s.kt)(RZt,(0,p.Z)({},WZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}IZt.isMDXComponent=!0;const SZt={toc:[]},BZt="wrapper";function GZt(t){let{components:e,...n}=t;return(0,s.kt)(BZt,(0,p.Z)({},SZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}GZt.isMDXComponent=!0;const EZt={toc:[]},OZt="wrapper";function FZt(t){let{components:e,...n}=t;return(0,s.kt)(OZt,(0,p.Z)({},EZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}FZt.isMDXComponent=!0;const UZt={toc:[]},VZt="wrapper";function qZt(t){let{components:e,...n}=t;return(0,s.kt)(VZt,(0,p.Z)({},UZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}qZt.isMDXComponent=!0;const jZt={toc:[]},YZt="wrapper";function QZt(t){let{components:e,...n}=t;return(0,s.kt)(YZt,(0,p.Z)({},jZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}QZt.isMDXComponent=!0;const HZt={toc:[]},KZt="wrapper";function $Zt(t){let{components:e,...n}=t;return(0,s.kt)(KZt,(0,p.Z)({},HZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}$Zt.isMDXComponent=!0;const JZt={toc:[]},tbt="wrapper";function ebt(t){let{components:e,...n}=t;return(0,s.kt)(tbt,(0,p.Z)({},JZt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}ebt.isMDXComponent=!0;const nbt={toc:[]},obt="wrapper";function pbt(t){let{components:e,...n}=t;return(0,s.kt)(obt,(0,p.Z)({},nbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}pbt.isMDXComponent=!0;const rbt={toc:[]},sbt="wrapper";function cbt(t){let{components:e,...n}=t;return(0,s.kt)(sbt,(0,p.Z)({},rbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}cbt.isMDXComponent=!0;const abt={toc:[]},ibt="wrapper";function lbt(t){let{components:e,...n}=t;return(0,s.kt)(ibt,(0,p.Z)({},abt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}lbt.isMDXComponent=!0;const ubt={toc:[]},mbt="wrapper";function dbt(t){let{components:e,...n}=t;return(0,s.kt)(mbt,(0,p.Z)({},ubt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}dbt.isMDXComponent=!0;const hbt={toc:[]},fbt="wrapper";function kbt(t){let{components:e,...n}=t;return(0,s.kt)(fbt,(0,p.Z)({},hbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}kbt.isMDXComponent=!0;const ybt={toc:[]},Dbt="wrapper";function Mbt(t){let{components:e,...n}=t;return(0,s.kt)(Dbt,(0,p.Z)({},ybt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Mbt.isMDXComponent=!0;const Xbt={toc:[]},_bt="wrapper";function wbt(t){let{components:e,...n}=t;return(0,s.kt)(_bt,(0,p.Z)({},Xbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}wbt.isMDXComponent=!0;const Tbt={toc:[]},Cbt="wrapper";function xbt(t){let{components:e,...n}=t;return(0,s.kt)(Cbt,(0,p.Z)({},Tbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}xbt.isMDXComponent=!0;const gbt={toc:[]},vbt="wrapper";function Lbt(t){let{components:e,...n}=t;return(0,s.kt)(vbt,(0,p.Z)({},gbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Lbt.isMDXComponent=!0;const Zbt={toc:[]},bbt="wrapper";function Nbt(t){let{components:e,...n}=t;return(0,s.kt)(bbt,(0,p.Z)({},Zbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Nbt.isMDXComponent=!0;const zbt={toc:[]},Abt="wrapper";function Pbt(t){let{components:e,...n}=t;return(0,s.kt)(Abt,(0,p.Z)({},zbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Pbt.isMDXComponent=!0;const Wbt={toc:[]},Rbt="wrapper";function Ibt(t){let{components:e,...n}=t;return(0,s.kt)(Rbt,(0,p.Z)({},Wbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Ibt.isMDXComponent=!0;const Sbt={toc:[]},Bbt="wrapper";function Gbt(t){let{components:e,...n}=t;return(0,s.kt)(Bbt,(0,p.Z)({},Sbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Gbt.isMDXComponent=!0;const Ebt={toc:[]},Obt="wrapper";function Fbt(t){let{components:e,...n}=t;return(0,s.kt)(Obt,(0,p.Z)({},Ebt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Fbt.isMDXComponent=!0;const Ubt={toc:[]},Vbt="wrapper";function qbt(t){let{components:e,...n}=t;return(0,s.kt)(Vbt,(0,p.Z)({},Ubt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}qbt.isMDXComponent=!0;const jbt={toc:[]},Ybt="wrapper";function Qbt(t){let{components:e,...n}=t;return(0,s.kt)(Ybt,(0,p.Z)({},jbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Qbt.isMDXComponent=!0;const Hbt={toc:[]},Kbt="wrapper";function $bt(t){let{components:e,...n}=t;return(0,s.kt)(Kbt,(0,p.Z)({},Hbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}$bt.isMDXComponent=!0;const Jbt={toc:[]},tNt="wrapper";function eNt(t){let{components:e,...n}=t;return(0,s.kt)(tNt,(0,p.Z)({},Jbt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}eNt.isMDXComponent=!0;const nNt={toc:[]},oNt="wrapper";function pNt(t){let{components:e,...n}=t;return(0,s.kt)(oNt,(0,p.Z)({},nNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}pNt.isMDXComponent=!0;const rNt={toc:[]},sNt="wrapper";function cNt(t){let{components:e,...n}=t;return(0,s.kt)(sNt,(0,p.Z)({},rNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}cNt.isMDXComponent=!0;const aNt={toc:[]},iNt="wrapper";function lNt(t){let{components:e,...n}=t;return(0,s.kt)(iNt,(0,p.Z)({},aNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lNt.isMDXComponent=!0;const uNt={toc:[]},mNt="wrapper";function dNt(t){let{components:e,...n}=t;return(0,s.kt)(mNt,(0,p.Z)({},uNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}dNt.isMDXComponent=!0;const hNt={toc:[]},fNt="wrapper";function kNt(t){let{components:e,...n}=t;return(0,s.kt)(fNt,(0,p.Z)({},hNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}kNt.isMDXComponent=!0;const yNt={toc:[]},DNt="wrapper";function MNt(t){let{components:e,...n}=t;return(0,s.kt)(DNt,(0,p.Z)({},yNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}MNt.isMDXComponent=!0;const XNt={toc:[]},_Nt="wrapper";function wNt(t){let{components:e,...n}=t;return(0,s.kt)(_Nt,(0,p.Z)({},XNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}wNt.isMDXComponent=!0;const TNt={toc:[]},CNt="wrapper";function xNt(t){let{components:e,...n}=t;return(0,s.kt)(CNt,(0,p.Z)({},TNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}xNt.isMDXComponent=!0;const gNt={toc:[]},vNt="wrapper";function LNt(t){let{components:e,...n}=t;return(0,s.kt)(vNt,(0,p.Z)({},gNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}LNt.isMDXComponent=!0;const ZNt={toc:[]},bNt="wrapper";function NNt(t){let{components:e,...n}=t;return(0,s.kt)(bNt,(0,p.Z)({},ZNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}NNt.isMDXComponent=!0;const zNt={toc:[]},ANt="wrapper";function PNt(t){let{components:e,...n}=t;return(0,s.kt)(ANt,(0,p.Z)({},zNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}PNt.isMDXComponent=!0;const WNt={toc:[]},RNt="wrapper";function INt(t){let{components:e,...n}=t;return(0,s.kt)(RNt,(0,p.Z)({},WNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}INt.isMDXComponent=!0;const SNt={toc:[]},BNt="wrapper";function GNt(t){let{components:e,...n}=t;return(0,s.kt)(BNt,(0,p.Z)({},SNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}GNt.isMDXComponent=!0;const ENt={toc:[]},ONt="wrapper";function FNt(t){let{components:e,...n}=t;return(0,s.kt)(ONt,(0,p.Z)({},ENt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}FNt.isMDXComponent=!0;const UNt={toc:[]},VNt="wrapper";function qNt(t){let{components:e,...n}=t;return(0,s.kt)(VNt,(0,p.Z)({},UNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}qNt.isMDXComponent=!0;const jNt={toc:[]},YNt="wrapper";function QNt(t){let{components:e,...n}=t;return(0,s.kt)(YNt,(0,p.Z)({},jNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}QNt.isMDXComponent=!0;const HNt={toc:[]},KNt="wrapper";function $Nt(t){let{components:e,...n}=t;return(0,s.kt)(KNt,(0,p.Z)({},HNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}$Nt.isMDXComponent=!0;const JNt={toc:[]},tzt="wrapper";function ezt(t){let{components:e,...n}=t;return(0,s.kt)(tzt,(0,p.Z)({},JNt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}ezt.isMDXComponent=!0;const nzt={toc:[]},ozt="wrapper";function pzt(t){let{components:e,...n}=t;return(0,s.kt)(ozt,(0,p.Z)({},nzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}pzt.isMDXComponent=!0;const rzt={toc:[]},szt="wrapper";function czt(t){let{components:e,...n}=t;return(0,s.kt)(szt,(0,p.Z)({},rzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}czt.isMDXComponent=!0;const azt={toc:[]},izt="wrapper";function lzt(t){let{components:e,...n}=t;return(0,s.kt)(izt,(0,p.Z)({},azt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}lzt.isMDXComponent=!0;const uzt={toc:[]},mzt="wrapper";function dzt(t){let{components:e,...n}=t;return(0,s.kt)(mzt,(0,p.Z)({},uzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}dzt.isMDXComponent=!0;const hzt={toc:[]},fzt="wrapper";function kzt(t){let{components:e,...n}=t;return(0,s.kt)(fzt,(0,p.Z)({},hzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}kzt.isMDXComponent=!0;const yzt={toc:[]},Dzt="wrapper";function Mzt(t){let{components:e,...n}=t;return(0,s.kt)(Dzt,(0,p.Z)({},yzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Mzt.isMDXComponent=!0;const Xzt={toc:[]},_zt="wrapper";function wzt(t){let{components:e,...n}=t;return(0,s.kt)(_zt,(0,p.Z)({},Xzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}wzt.isMDXComponent=!0;const Tzt={toc:[]},Czt="wrapper";function xzt(t){let{components:e,...n}=t;return(0,s.kt)(Czt,(0,p.Z)({},Tzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}xzt.isMDXComponent=!0;const gzt={toc:[]},vzt="wrapper";function Lzt(t){let{components:e,...n}=t;return(0,s.kt)(vzt,(0,p.Z)({},gzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Lzt.isMDXComponent=!0;const Zzt={toc:[]},bzt="wrapper";function Nzt(t){let{components:e,...n}=t;return(0,s.kt)(bzt,(0,p.Z)({},Zzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Nzt.isMDXComponent=!0;const zzt={toc:[]},Azt="wrapper";function Pzt(t){let{components:e,...n}=t;return(0,s.kt)(Azt,(0,p.Z)({},zzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Pzt.isMDXComponent=!0;const Wzt={toc:[]},Rzt="wrapper";function Izt(t){let{components:e,...n}=t;return(0,s.kt)(Rzt,(0,p.Z)({},Wzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Izt.isMDXComponent=!0;const Szt={toc:[]},Bzt="wrapper";function Gzt(t){let{components:e,...n}=t;return(0,s.kt)(Bzt,(0,p.Z)({},Szt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Gzt.isMDXComponent=!0;const Ezt={toc:[]},Ozt="wrapper";function Fzt(t){let{components:e,...n}=t;return(0,s.kt)(Ozt,(0,p.Z)({},Ezt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Fzt.isMDXComponent=!0;const Uzt={toc:[]},Vzt="wrapper";function qzt(t){let{components:e,...n}=t;return(0,s.kt)(Vzt,(0,p.Z)({},Uzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}qzt.isMDXComponent=!0;const jzt={toc:[]},Yzt="wrapper";function Qzt(t){let{components:e,...n}=t;return(0,s.kt)(Yzt,(0,p.Z)({},jzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Qzt.isMDXComponent=!0;const Hzt={toc:[]},Kzt="wrapper";function $zt(t){let{components:e,...n}=t;return(0,s.kt)(Kzt,(0,p.Z)({},Hzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}$zt.isMDXComponent=!0;const Jzt={toc:[]},tAt="wrapper";function eAt(t){let{components:e,...n}=t;return(0,s.kt)(tAt,(0,p.Z)({},Jzt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}eAt.isMDXComponent=!0;const nAt={toc:[]},oAt="wrapper";function pAt(t){let{components:e,...n}=t;return(0,s.kt)(oAt,(0,p.Z)({},nAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}pAt.isMDXComponent=!0;const rAt={toc:[]},sAt="wrapper";function cAt(t){let{components:e,...n}=t;return(0,s.kt)(sAt,(0,p.Z)({},rAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}cAt.isMDXComponent=!0;const aAt={toc:[]},iAt="wrapper";function lAt(t){let{components:e,...n}=t;return(0,s.kt)(iAt,(0,p.Z)({},aAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}lAt.isMDXComponent=!0;const uAt={toc:[]},mAt="wrapper";function dAt(t){let{components:e,...n}=t;return(0,s.kt)(mAt,(0,p.Z)({},uAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}dAt.isMDXComponent=!0;const hAt={toc:[]},fAt="wrapper";function kAt(t){let{components:e,...n}=t;return(0,s.kt)(fAt,(0,p.Z)({},hAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}kAt.isMDXComponent=!0;const yAt={toc:[]},DAt="wrapper";function MAt(t){let{components:e,...n}=t;return(0,s.kt)(DAt,(0,p.Z)({},yAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}MAt.isMDXComponent=!0;const XAt={toc:[]},_At="wrapper";function wAt(t){let{components:e,...n}=t;return(0,s.kt)(_At,(0,p.Z)({},XAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}wAt.isMDXComponent=!0;const TAt={toc:[]},CAt="wrapper";function xAt(t){let{components:e,...n}=t;return(0,s.kt)(CAt,(0,p.Z)({},TAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}xAt.isMDXComponent=!0;const gAt={toc:[]},vAt="wrapper";function LAt(t){let{components:e,...n}=t;return(0,s.kt)(vAt,(0,p.Z)({},gAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}LAt.isMDXComponent=!0;const ZAt={toc:[]},bAt="wrapper";function NAt(t){let{components:e,...n}=t;return(0,s.kt)(bAt,(0,p.Z)({},ZAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}NAt.isMDXComponent=!0;const zAt={toc:[]},AAt="wrapper";function PAt(t){let{components:e,...n}=t;return(0,s.kt)(AAt,(0,p.Z)({},zAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}PAt.isMDXComponent=!0;const WAt={toc:[]},RAt="wrapper";function IAt(t){let{components:e,...n}=t;return(0,s.kt)(RAt,(0,p.Z)({},WAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}IAt.isMDXComponent=!0;const SAt={toc:[]},BAt="wrapper";function GAt(t){let{components:e,...n}=t;return(0,s.kt)(BAt,(0,p.Z)({},SAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}GAt.isMDXComponent=!0;const EAt={toc:[]},OAt="wrapper";function FAt(t){let{components:e,...n}=t;return(0,s.kt)(OAt,(0,p.Z)({},EAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}FAt.isMDXComponent=!0;const UAt={toc:[]},VAt="wrapper";function qAt(t){let{components:e,...n}=t;return(0,s.kt)(VAt,(0,p.Z)({},UAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}qAt.isMDXComponent=!0;const jAt={toc:[]},YAt="wrapper";function QAt(t){let{components:e,...n}=t;return(0,s.kt)(YAt,(0,p.Z)({},jAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}QAt.isMDXComponent=!0;const HAt={toc:[]},KAt="wrapper";function $At(t){let{components:e,...n}=t;return(0,s.kt)(KAt,(0,p.Z)({},HAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}$At.isMDXComponent=!0;const JAt={toc:[]},tPt="wrapper";function ePt(t){let{components:e,...n}=t;return(0,s.kt)(tPt,(0,p.Z)({},JAt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}ePt.isMDXComponent=!0;const nPt={toc:[]},oPt="wrapper";function pPt(t){let{components:e,...n}=t;return(0,s.kt)(oPt,(0,p.Z)({},nPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}pPt.isMDXComponent=!0;const rPt={toc:[]},sPt="wrapper";function cPt(t){let{components:e,...n}=t;return(0,s.kt)(sPt,(0,p.Z)({},rPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}cPt.isMDXComponent=!0;const aPt={toc:[]},iPt="wrapper";function lPt(t){let{components:e,...n}=t;return(0,s.kt)(iPt,(0,p.Z)({},aPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}lPt.isMDXComponent=!0;const uPt={toc:[]},mPt="wrapper";function dPt(t){let{components:e,...n}=t;return(0,s.kt)(mPt,(0,p.Z)({},uPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dPt.isMDXComponent=!0;const hPt={toc:[]},fPt="wrapper";function kPt(t){let{components:e,...n}=t;return(0,s.kt)(fPt,(0,p.Z)({},hPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}kPt.isMDXComponent=!0;const yPt={toc:[]},DPt="wrapper";function MPt(t){let{components:e,...n}=t;return(0,s.kt)(DPt,(0,p.Z)({},yPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}MPt.isMDXComponent=!0;const XPt={toc:[]},_Pt="wrapper";function wPt(t){let{components:e,...n}=t;return(0,s.kt)(_Pt,(0,p.Z)({},XPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}wPt.isMDXComponent=!0;const TPt={toc:[]},CPt="wrapper";function xPt(t){let{components:e,...n}=t;return(0,s.kt)(CPt,(0,p.Z)({},TPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Curve#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}xPt.isMDXComponent=!0;const gPt={toc:[]},vPt="wrapper";function LPt(t){let{components:e,...n}=t;return(0,s.kt)(vPt,(0,p.Z)({},gPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}LPt.isMDXComponent=!0;const ZPt={toc:[]},bPt="wrapper";function NPt(t){let{components:e,...n}=t;return(0,s.kt)(bPt,(0,p.Z)({},ZPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}NPt.isMDXComponent=!0;const zPt={toc:[]},APt="wrapper";function PPt(t){let{components:e,...n}=t;return(0,s.kt)(APt,(0,p.Z)({},zPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}PPt.isMDXComponent=!0;const WPt={toc:[]},RPt="wrapper";function IPt(t){let{components:e,...n}=t;return(0,s.kt)(RPt,(0,p.Z)({},WPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}IPt.isMDXComponent=!0;const SPt={toc:[]},BPt="wrapper";function GPt(t){let{components:e,...n}=t;return(0,s.kt)(BPt,(0,p.Z)({},SPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}GPt.isMDXComponent=!0;const EPt={toc:[]},OPt="wrapper";function FPt(t){let{components:e,...n}=t;return(0,s.kt)(OPt,(0,p.Z)({},EPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}FPt.isMDXComponent=!0;const UPt={toc:[]},VPt="wrapper";function qPt(t){let{components:e,...n}=t;return(0,s.kt)(VPt,(0,p.Z)({},UPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Grid, makeScene2D} from '@motion-canvas/2d';\nimport {all, createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const grid = createRef<Grid>();\n\n  view.add(\n    <Grid\n      ref={grid}\n      width={'100%'}\n      height={'100%'}\n      stroke={'#666'}\n      start={0}\n      end={1}\n    />,\n  );\n\n  yield* all(\n    grid().end(0.5, 1).to(1, 1).wait(1),\n    grid().start(0.5, 1).to(0, 1).wait(1),\n  );\n});\n")))}qPt.isMDXComponent=!0;const jPt={toc:[]},YPt="wrapper";function QPt(t){let{components:e,...n}=t;return(0,s.kt)(YPt,(0,p.Z)({},jPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a two-dimensional grid."))}QPt.isMDXComponent=!0;const HPt={toc:[]},KPt="wrapper";function $Pt(t){let{components:e,...n}=t;return(0,s.kt)(KPt,(0,p.Z)({},HPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}$Pt.isMDXComponent=!0;const JPt={toc:[]},tWt="wrapper";function eWt(t){let{components:e,...n}=t;return(0,s.kt)(tWt,(0,p.Z)({},JPt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}eWt.isMDXComponent=!0;const nWt={toc:[]},oWt="wrapper";function pWt(t){let{components:e,...n}=t;return(0,s.kt)(oWt,(0,p.Z)({},nWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}pWt.isMDXComponent=!0;const rWt={toc:[]},sWt="wrapper";function cWt(t){let{components:e,...n}=t;return(0,s.kt)(sWt,(0,p.Z)({},rWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}cWt.isMDXComponent=!0;const aWt={toc:[]},iWt="wrapper";function lWt(t){let{components:e,...n}=t;return(0,s.kt)(iWt,(0,p.Z)({},aWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}lWt.isMDXComponent=!0;const uWt={toc:[]},mWt="wrapper";function dWt(t){let{components:e,...n}=t;return(0,s.kt)(mWt,(0,p.Z)({},uWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}dWt.isMDXComponent=!0;const hWt={toc:[]},fWt="wrapper";function kWt(t){let{components:e,...n}=t;return(0,s.kt)(fWt,(0,p.Z)({},hWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}kWt.isMDXComponent=!0;const yWt={toc:[]},DWt="wrapper";function MWt(t){let{components:e,...n}=t;return(0,s.kt)(DWt,(0,p.Z)({},yWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}MWt.isMDXComponent=!0;const XWt={toc:[]},_Wt="wrapper";function wWt(t){let{components:e,...n}=t;return(0,s.kt)(_Wt,(0,p.Z)({},XWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}wWt.isMDXComponent=!0;const TWt={toc:[]},CWt="wrapper";function xWt(t){let{components:e,...n}=t;return(0,s.kt)(CWt,(0,p.Z)({},TWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}xWt.isMDXComponent=!0;const gWt={toc:[]},vWt="wrapper";function LWt(t){let{components:e,...n}=t;return(0,s.kt)(vWt,(0,p.Z)({},gWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}LWt.isMDXComponent=!0;const ZWt={toc:[]},bWt="wrapper";function NWt(t){let{components:e,...n}=t;return(0,s.kt)(bWt,(0,p.Z)({},ZWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}NWt.isMDXComponent=!0;const zWt={toc:[]},AWt="wrapper";function PWt(t){let{components:e,...n}=t;return(0,s.kt)(AWt,(0,p.Z)({},zWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}PWt.isMDXComponent=!0;const WWt={toc:[]},RWt="wrapper";function IWt(t){let{components:e,...n}=t;return(0,s.kt)(RWt,(0,p.Z)({},WWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}IWt.isMDXComponent=!0;const SWt={toc:[]},BWt="wrapper";function GWt(t){let{components:e,...n}=t;return(0,s.kt)(BWt,(0,p.Z)({},SWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}GWt.isMDXComponent=!0;const EWt={toc:[]},OWt="wrapper";function FWt(t){let{components:e,...n}=t;return(0,s.kt)(OWt,(0,p.Z)({},EWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the end of each grid line."))}FWt.isMDXComponent=!0;const UWt={toc:[]},VWt="wrapper";function qWt(t){let{components:e,...n}=t;return(0,s.kt)(VWt,(0,p.Z)({},UWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}qWt.isMDXComponent=!0;const jWt={toc:[]},YWt="wrapper";function QWt(t){let{components:e,...n}=t;return(0,s.kt)(YWt,(0,p.Z)({},jWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}QWt.isMDXComponent=!0;const HWt={toc:[]},KWt="wrapper";function $Wt(t){let{components:e,...n}=t;return(0,s.kt)(KWt,(0,p.Z)({},HWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}$Wt.isMDXComponent=!0;const JWt={toc:[]},tRt="wrapper";function eRt(t){let{components:e,...n}=t;return(0,s.kt)(tRt,(0,p.Z)({},JWt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}eRt.isMDXComponent=!0;const nRt={toc:[]},oRt="wrapper";function pRt(t){let{components:e,...n}=t;return(0,s.kt)(oRt,(0,p.Z)({},nRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}pRt.isMDXComponent=!0;const rRt={toc:[]},sRt="wrapper";function cRt(t){let{components:e,...n}=t;return(0,s.kt)(sRt,(0,p.Z)({},rRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}cRt.isMDXComponent=!0;const aRt={toc:[]},iRt="wrapper";function lRt(t){let{components:e,...n}=t;return(0,s.kt)(iRt,(0,p.Z)({},aRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}lRt.isMDXComponent=!0;const uRt={toc:[]},mRt="wrapper";function dRt(t){let{components:e,...n}=t;return(0,s.kt)(mRt,(0,p.Z)({},uRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}dRt.isMDXComponent=!0;const hRt={toc:[]},fRt="wrapper";function kRt(t){let{components:e,...n}=t;return(0,s.kt)(fRt,(0,p.Z)({},hRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}kRt.isMDXComponent=!0;const yRt={toc:[]},DRt="wrapper";function MRt(t){let{components:e,...n}=t;return(0,s.kt)(DRt,(0,p.Z)({},yRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}MRt.isMDXComponent=!0;const XRt={toc:[]},_Rt="wrapper";function wRt(t){let{components:e,...n}=t;return(0,s.kt)(_Rt,(0,p.Z)({},XRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}wRt.isMDXComponent=!0;const TRt={toc:[]},CRt="wrapper";function xRt(t){let{components:e,...n}=t;return(0,s.kt)(CRt,(0,p.Z)({},TRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}xRt.isMDXComponent=!0;const gRt={toc:[]},vRt="wrapper";function LRt(t){let{components:e,...n}=t;return(0,s.kt)(vRt,(0,p.Z)({},gRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}LRt.isMDXComponent=!0;const ZRt={toc:[]},bRt="wrapper";function NRt(t){let{components:e,...n}=t;return(0,s.kt)(bRt,(0,p.Z)({},ZRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}NRt.isMDXComponent=!0;const zRt={toc:[]},ARt="wrapper";function PRt(t){let{components:e,...n}=t;return(0,s.kt)(ARt,(0,p.Z)({},zRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}PRt.isMDXComponent=!0;const WRt={toc:[]},RRt="wrapper";function IRt(t){let{components:e,...n}=t;return(0,s.kt)(RRt,(0,p.Z)({},WRt,n,{components:e,mdxType:"MDXLayout"}))}IRt.isMDXComponent=!0;const SRt={toc:[]},BRt="wrapper";function GRt(t){let{components:e,...n}=t;return(0,s.kt)(BRt,(0,p.Z)({},SRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}GRt.isMDXComponent=!0;const ERt={toc:[]},ORt="wrapper";function FRt(t){let{components:e,...n}=t;return(0,s.kt)(ORt,(0,p.Z)({},ERt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}FRt.isMDXComponent=!0;const URt={toc:[]},VRt="wrapper";function qRt(t){let{components:e,...n}=t;return(0,s.kt)(VRt,(0,p.Z)({},URt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}qRt.isMDXComponent=!0;const jRt={toc:[]},YRt="wrapper";function QRt(t){let{components:e,...n}=t;return(0,s.kt)(YRt,(0,p.Z)({},jRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}QRt.isMDXComponent=!0;const HRt={toc:[]},KRt="wrapper";function $Rt(t){let{components:e,...n}=t;return(0,s.kt)(KRt,(0,p.Z)({},HRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}$Rt.isMDXComponent=!0;const JRt={toc:[]},tIt="wrapper";function eIt(t){let{components:e,...n}=t;return(0,s.kt)(tIt,(0,p.Z)({},JRt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The spacing between the grid lines."))}eIt.isMDXComponent=!0;const nIt={toc:[]},oIt="wrapper";function pIt(t){let{components:e,...n}=t;return(0,s.kt)(oIt,(0,p.Z)({},nIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}pIt.isMDXComponent=!0;const rIt={toc:[]},sIt="wrapper";function cIt(t){let{components:e,...n}=t;return(0,s.kt)(sIt,(0,p.Z)({},rIt,n,{components:e,mdxType:"MDXLayout"}))}cIt.isMDXComponent=!0;const aIt={toc:[]},iIt="wrapper";function lIt(t){let{components:e,...n}=t;return(0,s.kt)(iIt,(0,p.Z)({},aIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}lIt.isMDXComponent=!0;const uIt={toc:[]},mIt="wrapper";function dIt(t){let{components:e,...n}=t;return(0,s.kt)(mIt,(0,p.Z)({},uIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}dIt.isMDXComponent=!0;const hIt={toc:[]},fIt="wrapper";function kIt(t){let{components:e,...n}=t;return(0,s.kt)(fIt,(0,p.Z)({},hIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}kIt.isMDXComponent=!0;const yIt={toc:[]},DIt="wrapper";function MIt(t){let{components:e,...n}=t;return(0,s.kt)(DIt,(0,p.Z)({},yIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}MIt.isMDXComponent=!0;const XIt={toc:[]},_It="wrapper";function wIt(t){let{components:e,...n}=t;return(0,s.kt)(_It,(0,p.Z)({},XIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}wIt.isMDXComponent=!0;const TIt={toc:[]},CIt="wrapper";function xIt(t){let{components:e,...n}=t;return(0,s.kt)(CIt,(0,p.Z)({},TIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}xIt.isMDXComponent=!0;const gIt={toc:[]},vIt="wrapper";function LIt(t){let{components:e,...n}=t;return(0,s.kt)(vIt,(0,p.Z)({},gIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}LIt.isMDXComponent=!0;const ZIt={toc:[]},bIt="wrapper";function NIt(t){let{components:e,...n}=t;return(0,s.kt)(bIt,(0,p.Z)({},ZIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}NIt.isMDXComponent=!0;const zIt={toc:[]},AIt="wrapper";function PIt(t){let{components:e,...n}=t;return(0,s.kt)(AIt,(0,p.Z)({},zIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}PIt.isMDXComponent=!0;const WIt={toc:[]},RIt="wrapper";function IIt(t){let{components:e,...n}=t;return(0,s.kt)(RIt,(0,p.Z)({},WIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}IIt.isMDXComponent=!0;const SIt={toc:[]},BIt="wrapper";function GIt(t){let{components:e,...n}=t;return(0,s.kt)(BIt,(0,p.Z)({},SIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}GIt.isMDXComponent=!0;const EIt={toc:[]},OIt="wrapper";function FIt(t){let{components:e,...n}=t;return(0,s.kt)(OIt,(0,p.Z)({},EIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}FIt.isMDXComponent=!0;const UIt={toc:[]},VIt="wrapper";function qIt(t){let{components:e,...n}=t;return(0,s.kt)(VIt,(0,p.Z)({},UIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}qIt.isMDXComponent=!0;const jIt={toc:[]},YIt="wrapper";function QIt(t){let{components:e,...n}=t;return(0,s.kt)(YIt,(0,p.Z)({},jIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}QIt.isMDXComponent=!0;const HIt={toc:[]},KIt="wrapper";function $It(t){let{components:e,...n}=t;return(0,s.kt)(KIt,(0,p.Z)({},HIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}$It.isMDXComponent=!0;const JIt={toc:[]},tSt="wrapper";function eSt(t){let{components:e,...n}=t;return(0,s.kt)(tSt,(0,p.Z)({},JIt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}eSt.isMDXComponent=!0;const nSt={toc:[]},oSt="wrapper";function pSt(t){let{components:e,...n}=t;return(0,s.kt)(oSt,(0,p.Z)({},nSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}pSt.isMDXComponent=!0;const rSt={toc:[]},sSt="wrapper";function cSt(t){let{components:e,...n}=t;return(0,s.kt)(sSt,(0,p.Z)({},rSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}cSt.isMDXComponent=!0;const aSt={toc:[]},iSt="wrapper";function lSt(t){let{components:e,...n}=t;return(0,s.kt)(iSt,(0,p.Z)({},aSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}lSt.isMDXComponent=!0;const uSt={toc:[]},mSt="wrapper";function dSt(t){let{components:e,...n}=t;return(0,s.kt)(mSt,(0,p.Z)({},uSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}dSt.isMDXComponent=!0;const hSt={toc:[]},fSt="wrapper";function kSt(t){let{components:e,...n}=t;return(0,s.kt)(fSt,(0,p.Z)({},hSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}kSt.isMDXComponent=!0;const ySt={toc:[]},DSt="wrapper";function MSt(t){let{components:e,...n}=t;return(0,s.kt)(DSt,(0,p.Z)({},ySt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}MSt.isMDXComponent=!0;const XSt={toc:[]},_St="wrapper";function wSt(t){let{components:e,...n}=t;return(0,s.kt)(_St,(0,p.Z)({},XSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}wSt.isMDXComponent=!0;const TSt={toc:[]},CSt="wrapper";function xSt(t){let{components:e,...n}=t;return(0,s.kt)(CSt,(0,p.Z)({},TSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}xSt.isMDXComponent=!0;const gSt={toc:[]},vSt="wrapper";function LSt(t){let{components:e,...n}=t;return(0,s.kt)(vSt,(0,p.Z)({},gSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}LSt.isMDXComponent=!0;const ZSt={toc:[]},bSt="wrapper";function NSt(t){let{components:e,...n}=t;return(0,s.kt)(bSt,(0,p.Z)({},ZSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}NSt.isMDXComponent=!0;const zSt={toc:[]},ASt="wrapper";function PSt(t){let{components:e,...n}=t;return(0,s.kt)(ASt,(0,p.Z)({},zSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}PSt.isMDXComponent=!0;const WSt={toc:[]},RSt="wrapper";function ISt(t){let{components:e,...n}=t;return(0,s.kt)(RSt,(0,p.Z)({},WSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}ISt.isMDXComponent=!0;const SSt={toc:[]},BSt="wrapper";function GSt(t){let{components:e,...n}=t;return(0,s.kt)(BSt,(0,p.Z)({},SSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}GSt.isMDXComponent=!0;const ESt={toc:[]},OSt="wrapper";function FSt(t){let{components:e,...n}=t;return(0,s.kt)(OSt,(0,p.Z)({},ESt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}FSt.isMDXComponent=!0;const USt={toc:[]},VSt="wrapper";function qSt(t){let{components:e,...n}=t;return(0,s.kt)(VSt,(0,p.Z)({},USt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}qSt.isMDXComponent=!0;const jSt={toc:[]},YSt="wrapper";function QSt(t){let{components:e,...n}=t;return(0,s.kt)(YSt,(0,p.Z)({},jSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}QSt.isMDXComponent=!0;const HSt={toc:[]},KSt="wrapper";function $St(t){let{components:e,...n}=t;return(0,s.kt)(KSt,(0,p.Z)({},HSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}$St.isMDXComponent=!0;const JSt={toc:[]},tBt="wrapper";function eBt(t){let{components:e,...n}=t;return(0,s.kt)(tBt,(0,p.Z)({},JSt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}eBt.isMDXComponent=!0;const nBt={toc:[]},oBt="wrapper";function pBt(t){let{components:e,...n}=t;return(0,s.kt)(oBt,(0,p.Z)({},nBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pBt.isMDXComponent=!0;const rBt={toc:[]},sBt="wrapper";function cBt(t){let{components:e,...n}=t;return(0,s.kt)(sBt,(0,p.Z)({},rBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}cBt.isMDXComponent=!0;const aBt={toc:[]},iBt="wrapper";function lBt(t){let{components:e,...n}=t;return(0,s.kt)(iBt,(0,p.Z)({},aBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}lBt.isMDXComponent=!0;const uBt={toc:[]},mBt="wrapper";function dBt(t){let{components:e,...n}=t;return(0,s.kt)(mBt,(0,p.Z)({},uBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}dBt.isMDXComponent=!0;const hBt={toc:[]},fBt="wrapper";function kBt(t){let{components:e,...n}=t;return(0,s.kt)(fBt,(0,p.Z)({},hBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}kBt.isMDXComponent=!0;const yBt={toc:[]},DBt="wrapper";function MBt(t){let{components:e,...n}=t;return(0,s.kt)(DBt,(0,p.Z)({},yBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}MBt.isMDXComponent=!0;const XBt={toc:[]},_Bt="wrapper";function wBt(t){let{components:e,...n}=t;return(0,s.kt)(_Bt,(0,p.Z)({},XBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wBt.isMDXComponent=!0;const TBt={toc:[]},CBt="wrapper";function xBt(t){let{components:e,...n}=t;return(0,s.kt)(CBt,(0,p.Z)({},TBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}xBt.isMDXComponent=!0;const gBt={toc:[]},vBt="wrapper";function LBt(t){let{components:e,...n}=t;return(0,s.kt)(vBt,(0,p.Z)({},gBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}LBt.isMDXComponent=!0;const ZBt={toc:[]},bBt="wrapper";function NBt(t){let{components:e,...n}=t;return(0,s.kt)(bBt,(0,p.Z)({},ZBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}NBt.isMDXComponent=!0;const zBt={toc:[]},ABt="wrapper";function PBt(t){let{components:e,...n}=t;return(0,s.kt)(ABt,(0,p.Z)({},zBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}PBt.isMDXComponent=!0;const WBt={toc:[]},RBt="wrapper";function IBt(t){let{components:e,...n}=t;return(0,s.kt)(RBt,(0,p.Z)({},WBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}IBt.isMDXComponent=!0;const SBt={toc:[]},BBt="wrapper";function GBt(t){let{components:e,...n}=t;return(0,s.kt)(BBt,(0,p.Z)({},SBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}GBt.isMDXComponent=!0;const EBt={toc:[]},OBt="wrapper";function FBt(t){let{components:e,...n}=t;return(0,s.kt)(OBt,(0,p.Z)({},EBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}FBt.isMDXComponent=!0;const UBt={toc:[]},VBt="wrapper";function qBt(t){let{components:e,...n}=t;return(0,s.kt)(VBt,(0,p.Z)({},UBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qBt.isMDXComponent=!0;const jBt={toc:[]},YBt="wrapper";function QBt(t){let{components:e,...n}=t;return(0,s.kt)(YBt,(0,p.Z)({},jBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}QBt.isMDXComponent=!0;const HBt={toc:[]},KBt="wrapper";function $Bt(t){let{components:e,...n}=t;return(0,s.kt)(KBt,(0,p.Z)({},HBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}$Bt.isMDXComponent=!0;const JBt={toc:[]},tGt="wrapper";function eGt(t){let{components:e,...n}=t;return(0,s.kt)(tGt,(0,p.Z)({},JBt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}eGt.isMDXComponent=!0;const nGt={toc:[]},oGt="wrapper";function pGt(t){let{components:e,...n}=t;return(0,s.kt)(oGt,(0,p.Z)({},nGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pGt.isMDXComponent=!0;const rGt={toc:[]},sGt="wrapper";function cGt(t){let{components:e,...n}=t;return(0,s.kt)(sGt,(0,p.Z)({},rGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}cGt.isMDXComponent=!0;const aGt={toc:[]},iGt="wrapper";function lGt(t){let{components:e,...n}=t;return(0,s.kt)(iGt,(0,p.Z)({},aGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lGt.isMDXComponent=!0;const uGt={toc:[]},mGt="wrapper";function dGt(t){let{components:e,...n}=t;return(0,s.kt)(mGt,(0,p.Z)({},uGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}dGt.isMDXComponent=!0;const hGt={toc:[]},fGt="wrapper";function kGt(t){let{components:e,...n}=t;return(0,s.kt)(fGt,(0,p.Z)({},hGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kGt.isMDXComponent=!0;const yGt={toc:[]},DGt="wrapper";function MGt(t){let{components:e,...n}=t;return(0,s.kt)(DGt,(0,p.Z)({},yGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}MGt.isMDXComponent=!0;const XGt={toc:[]},_Gt="wrapper";function wGt(t){let{components:e,...n}=t;return(0,s.kt)(_Gt,(0,p.Z)({},XGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}wGt.isMDXComponent=!0;const TGt={toc:[]},CGt="wrapper";function xGt(t){let{components:e,...n}=t;return(0,s.kt)(CGt,(0,p.Z)({},TGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}xGt.isMDXComponent=!0;const gGt={toc:[]},vGt="wrapper";function LGt(t){let{components:e,...n}=t;return(0,s.kt)(vGt,(0,p.Z)({},gGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}LGt.isMDXComponent=!0;const ZGt={toc:[]},bGt="wrapper";function NGt(t){let{components:e,...n}=t;return(0,s.kt)(bGt,(0,p.Z)({},ZGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}NGt.isMDXComponent=!0;const zGt={toc:[]},AGt="wrapper";function PGt(t){let{components:e,...n}=t;return(0,s.kt)(AGt,(0,p.Z)({},zGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}PGt.isMDXComponent=!0;const WGt={toc:[]},RGt="wrapper";function IGt(t){let{components:e,...n}=t;return(0,s.kt)(RGt,(0,p.Z)({},WGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}IGt.isMDXComponent=!0;const SGt={toc:[]},BGt="wrapper";function GGt(t){let{components:e,...n}=t;return(0,s.kt)(BGt,(0,p.Z)({},SGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}GGt.isMDXComponent=!0;const EGt={toc:[]},OGt="wrapper";function FGt(t){let{components:e,...n}=t;return(0,s.kt)(OGt,(0,p.Z)({},EGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}FGt.isMDXComponent=!0;const UGt={toc:[]},VGt="wrapper";function qGt(t){let{components:e,...n}=t;return(0,s.kt)(VGt,(0,p.Z)({},UGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}qGt.isMDXComponent=!0;const jGt={toc:[]},YGt="wrapper";function QGt(t){let{components:e,...n}=t;return(0,s.kt)(YGt,(0,p.Z)({},jGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}QGt.isMDXComponent=!0;const HGt={toc:[]},KGt="wrapper";function $Gt(t){let{components:e,...n}=t;return(0,s.kt)(KGt,(0,p.Z)({},HGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}$Gt.isMDXComponent=!0;const JGt={toc:[]},tEt="wrapper";function eEt(t){let{components:e,...n}=t;return(0,s.kt)(tEt,(0,p.Z)({},JGt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}eEt.isMDXComponent=!0;const nEt={toc:[]},oEt="wrapper";function pEt(t){let{components:e,...n}=t;return(0,s.kt)(oEt,(0,p.Z)({},nEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}pEt.isMDXComponent=!0;const rEt={toc:[]},sEt="wrapper";function cEt(t){let{components:e,...n}=t;return(0,s.kt)(sEt,(0,p.Z)({},rEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}cEt.isMDXComponent=!0;const aEt={toc:[]},iEt="wrapper";function lEt(t){let{components:e,...n}=t;return(0,s.kt)(iEt,(0,p.Z)({},aEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}lEt.isMDXComponent=!0;const uEt={toc:[]},mEt="wrapper";function dEt(t){let{components:e,...n}=t;return(0,s.kt)(mEt,(0,p.Z)({},uEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}dEt.isMDXComponent=!0;const hEt={toc:[]},fEt="wrapper";function kEt(t){let{components:e,...n}=t;return(0,s.kt)(fEt,(0,p.Z)({},hEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}kEt.isMDXComponent=!0;const yEt={toc:[]},DEt="wrapper";function MEt(t){let{components:e,...n}=t;return(0,s.kt)(DEt,(0,p.Z)({},yEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}MEt.isMDXComponent=!0;const XEt={toc:[]},_Et="wrapper";function wEt(t){let{components:e,...n}=t;return(0,s.kt)(_Et,(0,p.Z)({},XEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}wEt.isMDXComponent=!0;const TEt={toc:[]},CEt="wrapper";function xEt(t){let{components:e,...n}=t;return(0,s.kt)(CEt,(0,p.Z)({},TEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}xEt.isMDXComponent=!0;const gEt={toc:[]},vEt="wrapper";function LEt(t){let{components:e,...n}=t;return(0,s.kt)(vEt,(0,p.Z)({},gEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}LEt.isMDXComponent=!0;const ZEt={toc:[]},bEt="wrapper";function NEt(t){let{components:e,...n}=t;return(0,s.kt)(bEt,(0,p.Z)({},ZEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}NEt.isMDXComponent=!0;const zEt={toc:[]},AEt="wrapper";function PEt(t){let{components:e,...n}=t;return(0,s.kt)(AEt,(0,p.Z)({},zEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}PEt.isMDXComponent=!0;const WEt={toc:[]},REt="wrapper";function IEt(t){let{components:e,...n}=t;return(0,s.kt)(REt,(0,p.Z)({},WEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}IEt.isMDXComponent=!0;const SEt={toc:[]},BEt="wrapper";function GEt(t){let{components:e,...n}=t;return(0,s.kt)(BEt,(0,p.Z)({},SEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}GEt.isMDXComponent=!0;const EEt={toc:[]},OEt="wrapper";function FEt(t){let{components:e,...n}=t;return(0,s.kt)(OEt,(0,p.Z)({},EEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}FEt.isMDXComponent=!0;const UEt={toc:[]},VEt="wrapper";function qEt(t){let{components:e,...n}=t;return(0,s.kt)(VEt,(0,p.Z)({},UEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}qEt.isMDXComponent=!0;const jEt={toc:[]},YEt="wrapper";function QEt(t){let{components:e,...n}=t;return(0,s.kt)(YEt,(0,p.Z)({},jEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}QEt.isMDXComponent=!0;const HEt={toc:[]},KEt="wrapper";function $Et(t){let{components:e,...n}=t;return(0,s.kt)(KEt,(0,p.Z)({},HEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}$Et.isMDXComponent=!0;const JEt={toc:[]},tOt="wrapper";function eOt(t){let{components:e,...n}=t;return(0,s.kt)(tOt,(0,p.Z)({},JEt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}eOt.isMDXComponent=!0;const nOt={toc:[]},oOt="wrapper";function pOt(t){let{components:e,...n}=t;return(0,s.kt)(oOt,(0,p.Z)({},nOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}pOt.isMDXComponent=!0;const rOt={toc:[]},sOt="wrapper";function cOt(t){let{components:e,...n}=t;return(0,s.kt)(sOt,(0,p.Z)({},rOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}cOt.isMDXComponent=!0;const aOt={toc:[]},iOt="wrapper";function lOt(t){let{components:e,...n}=t;return(0,s.kt)(iOt,(0,p.Z)({},aOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}lOt.isMDXComponent=!0;const uOt={toc:[]},mOt="wrapper";function dOt(t){let{components:e,...n}=t;return(0,s.kt)(mOt,(0,p.Z)({},uOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}dOt.isMDXComponent=!0;const hOt={toc:[]},fOt="wrapper";function kOt(t){let{components:e,...n}=t;return(0,s.kt)(fOt,(0,p.Z)({},hOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}kOt.isMDXComponent=!0;const yOt={toc:[]},DOt="wrapper";function MOt(t){let{components:e,...n}=t;return(0,s.kt)(DOt,(0,p.Z)({},yOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}MOt.isMDXComponent=!0;const XOt={toc:[]},_Ot="wrapper";function wOt(t){let{components:e,...n}=t;return(0,s.kt)(_Ot,(0,p.Z)({},XOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}wOt.isMDXComponent=!0;const TOt={toc:[]},COt="wrapper";function xOt(t){let{components:e,...n}=t;return(0,s.kt)(COt,(0,p.Z)({},TOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}xOt.isMDXComponent=!0;const gOt={toc:[]},vOt="wrapper";function LOt(t){let{components:e,...n}=t;return(0,s.kt)(vOt,(0,p.Z)({},gOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}LOt.isMDXComponent=!0;const ZOt={toc:[]},bOt="wrapper";function NOt(t){let{components:e,...n}=t;return(0,s.kt)(bOt,(0,p.Z)({},ZOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}NOt.isMDXComponent=!0;const zOt={toc:[]},AOt="wrapper";function POt(t){let{components:e,...n}=t;return(0,s.kt)(AOt,(0,p.Z)({},zOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}POt.isMDXComponent=!0;const WOt={toc:[]},ROt="wrapper";function IOt(t){let{components:e,...n}=t;return(0,s.kt)(ROt,(0,p.Z)({},WOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}IOt.isMDXComponent=!0;const SOt={toc:[]},BOt="wrapper";function GOt(t){let{components:e,...n}=t;return(0,s.kt)(BOt,(0,p.Z)({},SOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}GOt.isMDXComponent=!0;const EOt={toc:[]},OOt="wrapper";function FOt(t){let{components:e,...n}=t;return(0,s.kt)(OOt,(0,p.Z)({},EOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}FOt.isMDXComponent=!0;const UOt={toc:[]},VOt="wrapper";function qOt(t){let{components:e,...n}=t;return(0,s.kt)(VOt,(0,p.Z)({},UOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}qOt.isMDXComponent=!0;const jOt={toc:[]},YOt="wrapper";function QOt(t){let{components:e,...n}=t;return(0,s.kt)(YOt,(0,p.Z)({},jOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}QOt.isMDXComponent=!0;const HOt={toc:[]},KOt="wrapper";function $Ot(t){let{components:e,...n}=t;return(0,s.kt)(KOt,(0,p.Z)({},HOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}$Ot.isMDXComponent=!0;const JOt={toc:[]},tFt="wrapper";function eFt(t){let{components:e,...n}=t;return(0,s.kt)(tFt,(0,p.Z)({},JOt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}eFt.isMDXComponent=!0;const nFt={toc:[]},oFt="wrapper";function pFt(t){let{components:e,...n}=t;return(0,s.kt)(oFt,(0,p.Z)({},nFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}pFt.isMDXComponent=!0;const rFt={toc:[]},sFt="wrapper";function cFt(t){let{components:e,...n}=t;return(0,s.kt)(sFt,(0,p.Z)({},rFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}cFt.isMDXComponent=!0;const aFt={toc:[]},iFt="wrapper";function lFt(t){let{components:e,...n}=t;return(0,s.kt)(iFt,(0,p.Z)({},aFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}lFt.isMDXComponent=!0;const uFt={toc:[]},mFt="wrapper";function dFt(t){let{components:e,...n}=t;return(0,s.kt)(mFt,(0,p.Z)({},uFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}dFt.isMDXComponent=!0;const hFt={toc:[]},fFt="wrapper";function kFt(t){let{components:e,...n}=t;return(0,s.kt)(fFt,(0,p.Z)({},hFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kFt.isMDXComponent=!0;const yFt={toc:[]},DFt="wrapper";function MFt(t){let{components:e,...n}=t;return(0,s.kt)(DFt,(0,p.Z)({},yFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}MFt.isMDXComponent=!0;const XFt={toc:[]},_Ft="wrapper";function wFt(t){let{components:e,...n}=t;return(0,s.kt)(_Ft,(0,p.Z)({},XFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}wFt.isMDXComponent=!0;const TFt={toc:[]},CFt="wrapper";function xFt(t){let{components:e,...n}=t;return(0,s.kt)(CFt,(0,p.Z)({},TFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}xFt.isMDXComponent=!0;const gFt={toc:[]},vFt="wrapper";function LFt(t){let{components:e,...n}=t;return(0,s.kt)(vFt,(0,p.Z)({},gFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}LFt.isMDXComponent=!0;const ZFt={toc:[]},bFt="wrapper";function NFt(t){let{components:e,...n}=t;return(0,s.kt)(bFt,(0,p.Z)({},ZFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}NFt.isMDXComponent=!0;const zFt={toc:[]},AFt="wrapper";function PFt(t){let{components:e,...n}=t;return(0,s.kt)(AFt,(0,p.Z)({},zFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}PFt.isMDXComponent=!0;const WFt={toc:[]},RFt="wrapper";function IFt(t){let{components:e,...n}=t;return(0,s.kt)(RFt,(0,p.Z)({},WFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}IFt.isMDXComponent=!0;const SFt={toc:[]},BFt="wrapper";function GFt(t){let{components:e,...n}=t;return(0,s.kt)(BFt,(0,p.Z)({},SFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}GFt.isMDXComponent=!0;const EFt={toc:[]},OFt="wrapper";function FFt(t){let{components:e,...n}=t;return(0,s.kt)(OFt,(0,p.Z)({},EFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}FFt.isMDXComponent=!0;const UFt={toc:[]},VFt="wrapper";function qFt(t){let{components:e,...n}=t;return(0,s.kt)(VFt,(0,p.Z)({},UFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qFt.isMDXComponent=!0;const jFt={toc:[]},YFt="wrapper";function QFt(t){let{components:e,...n}=t;return(0,s.kt)(YFt,(0,p.Z)({},jFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}QFt.isMDXComponent=!0;const HFt={toc:[]},KFt="wrapper";function $Ft(t){let{components:e,...n}=t;return(0,s.kt)(KFt,(0,p.Z)({},HFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}$Ft.isMDXComponent=!0;const JFt={toc:[]},tUt="wrapper";function eUt(t){let{components:e,...n}=t;return(0,s.kt)(tUt,(0,p.Z)({},JFt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}eUt.isMDXComponent=!0;const nUt={toc:[]},oUt="wrapper";function pUt(t){let{components:e,...n}=t;return(0,s.kt)(oUt,(0,p.Z)({},nUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}pUt.isMDXComponent=!0;const rUt={toc:[]},sUt="wrapper";function cUt(t){let{components:e,...n}=t;return(0,s.kt)(sUt,(0,p.Z)({},rUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}cUt.isMDXComponent=!0;const aUt={toc:[]},iUt="wrapper";function lUt(t){let{components:e,...n}=t;return(0,s.kt)(iUt,(0,p.Z)({},aUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}lUt.isMDXComponent=!0;const uUt={toc:[]},mUt="wrapper";function dUt(t){let{components:e,...n}=t;return(0,s.kt)(mUt,(0,p.Z)({},uUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}dUt.isMDXComponent=!0;const hUt={toc:[]},fUt="wrapper";function kUt(t){let{components:e,...n}=t;return(0,s.kt)(fUt,(0,p.Z)({},hUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}kUt.isMDXComponent=!0;const yUt={toc:[]},DUt="wrapper";function MUt(t){let{components:e,...n}=t;return(0,s.kt)(DUt,(0,p.Z)({},yUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}MUt.isMDXComponent=!0;const XUt={toc:[]},_Ut="wrapper";function wUt(t){let{components:e,...n}=t;return(0,s.kt)(_Ut,(0,p.Z)({},XUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wUt.isMDXComponent=!0;const TUt={toc:[]},CUt="wrapper";function xUt(t){let{components:e,...n}=t;return(0,s.kt)(CUt,(0,p.Z)({},TUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}xUt.isMDXComponent=!0;const gUt={toc:[]},vUt="wrapper";function LUt(t){let{components:e,...n}=t;return(0,s.kt)(vUt,(0,p.Z)({},gUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}LUt.isMDXComponent=!0;const ZUt={toc:[]},bUt="wrapper";function NUt(t){let{components:e,...n}=t;return(0,s.kt)(bUt,(0,p.Z)({},ZUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}NUt.isMDXComponent=!0;const zUt={toc:[]},AUt="wrapper";function PUt(t){let{components:e,...n}=t;return(0,s.kt)(AUt,(0,p.Z)({},zUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}PUt.isMDXComponent=!0;const WUt={toc:[]},RUt="wrapper";function IUt(t){let{components:e,...n}=t;return(0,s.kt)(RUt,(0,p.Z)({},WUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}IUt.isMDXComponent=!0;const SUt={toc:[]},BUt="wrapper";function GUt(t){let{components:e,...n}=t;return(0,s.kt)(BUt,(0,p.Z)({},SUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}GUt.isMDXComponent=!0;const EUt={toc:[]},OUt="wrapper";function FUt(t){let{components:e,...n}=t;return(0,s.kt)(OUt,(0,p.Z)({},EUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}FUt.isMDXComponent=!0;const UUt={toc:[]},VUt="wrapper";function qUt(t){let{components:e,...n}=t;return(0,s.kt)(VUt,(0,p.Z)({},UUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}qUt.isMDXComponent=!0;const jUt={toc:[]},YUt="wrapper";function QUt(t){let{components:e,...n}=t;return(0,s.kt)(YUt,(0,p.Z)({},jUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}QUt.isMDXComponent=!0;const HUt={toc:[]},KUt="wrapper";function $Ut(t){let{components:e,...n}=t;return(0,s.kt)(KUt,(0,p.Z)({},HUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}$Ut.isMDXComponent=!0;const JUt={toc:[]},tVt="wrapper";function eVt(t){let{components:e,...n}=t;return(0,s.kt)(tVt,(0,p.Z)({},JUt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}eVt.isMDXComponent=!0;const nVt={toc:[]},oVt="wrapper";function pVt(t){let{components:e,...n}=t;return(0,s.kt)(oVt,(0,p.Z)({},nVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}pVt.isMDXComponent=!0;const rVt={toc:[]},sVt="wrapper";function cVt(t){let{components:e,...n}=t;return(0,s.kt)(sVt,(0,p.Z)({},rVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}cVt.isMDXComponent=!0;const aVt={toc:[]},iVt="wrapper";function lVt(t){let{components:e,...n}=t;return(0,s.kt)(iVt,(0,p.Z)({},aVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lVt.isMDXComponent=!0;const uVt={toc:[]},mVt="wrapper";function dVt(t){let{components:e,...n}=t;return(0,s.kt)(mVt,(0,p.Z)({},uVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}dVt.isMDXComponent=!0;const hVt={toc:[]},fVt="wrapper";function kVt(t){let{components:e,...n}=t;return(0,s.kt)(fVt,(0,p.Z)({},hVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An Icon Component that provides easy access to over 150k icons.\nSee ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org/collection/all"},"https://icones.js.org/collection/all")," for all available Icons."))}kVt.isMDXComponent=!0;const yVt={toc:[]},DVt="wrapper";function MVt(t){let{components:e,...n}=t;return(0,s.kt)(DVt,(0,p.Z)({},yVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}MVt.isMDXComponent=!0;const XVt={toc:[]},_Vt="wrapper";function wVt(t){let{components:e,...n}=t;return(0,s.kt)(_Vt,(0,p.Z)({},XVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}wVt.isMDXComponent=!0;const TVt={toc:[]},CVt="wrapper";function xVt(t){let{components:e,...n}=t;return(0,s.kt)(CVt,(0,p.Z)({},TVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}xVt.isMDXComponent=!0;const gVt={toc:[]},vVt="wrapper";function LVt(t){let{components:e,...n}=t;return(0,s.kt)(vVt,(0,p.Z)({},gVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}LVt.isMDXComponent=!0;const ZVt={toc:[]},bVt="wrapper";function NVt(t){let{components:e,...n}=t;return(0,s.kt)(bVt,(0,p.Z)({},ZVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}NVt.isMDXComponent=!0;const zVt={toc:[]},AVt="wrapper";function PVt(t){let{components:e,...n}=t;return(0,s.kt)(AVt,(0,p.Z)({},zVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}PVt.isMDXComponent=!0;const WVt={toc:[]},RVt="wrapper";function IVt(t){let{components:e,...n}=t;return(0,s.kt)(RVt,(0,p.Z)({},WVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}IVt.isMDXComponent=!0;const SVt={toc:[]},BVt="wrapper";function GVt(t){let{components:e,...n}=t;return(0,s.kt)(BVt,(0,p.Z)({},SVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}GVt.isMDXComponent=!0;const EVt={toc:[]},OVt="wrapper";function FVt(t){let{components:e,...n}=t;return(0,s.kt)(OVt,(0,p.Z)({},EVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}FVt.isMDXComponent=!0;const UVt={toc:[]},VVt="wrapper";function qVt(t){let{components:e,...n}=t;return(0,s.kt)(VVt,(0,p.Z)({},UVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}qVt.isMDXComponent=!0;const jVt={toc:[]},YVt="wrapper";function QVt(t){let{components:e,...n}=t;return(0,s.kt)(YVt,(0,p.Z)({},jVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}QVt.isMDXComponent=!0;const HVt={toc:[]},KVt="wrapper";function $Vt(t){let{components:e,...n}=t;return(0,s.kt)(KVt,(0,p.Z)({},HVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}$Vt.isMDXComponent=!0;const JVt={toc:[]},tqt="wrapper";function eqt(t){let{components:e,...n}=t;return(0,s.kt)(tqt,(0,p.Z)({},JVt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}eqt.isMDXComponent=!0;const nqt={toc:[]},oqt="wrapper";function pqt(t){let{components:e,...n}=t;return(0,s.kt)(oqt,(0,p.Z)({},nqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}pqt.isMDXComponent=!0;const rqt={toc:[]},sqt="wrapper";function cqt(t){let{components:e,...n}=t;return(0,s.kt)(sqt,(0,p.Z)({},rqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}cqt.isMDXComponent=!0;const aqt={toc:[]},iqt="wrapper";function lqt(t){let{components:e,...n}=t;return(0,s.kt)(iqt,(0,p.Z)({},aqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lqt.isMDXComponent=!0;const uqt={toc:[]},mqt="wrapper";function dqt(t){let{components:e,...n}=t;return(0,s.kt)(mqt,(0,p.Z)({},uqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}dqt.isMDXComponent=!0;const hqt={toc:[]},fqt="wrapper";function kqt(t){let{components:e,...n}=t;return(0,s.kt)(fqt,(0,p.Z)({},hqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}kqt.isMDXComponent=!0;const yqt={toc:[]},Dqt="wrapper";function Mqt(t){let{components:e,...n}=t;return(0,s.kt)(Dqt,(0,p.Z)({},yqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Mqt.isMDXComponent=!0;const Xqt={toc:[]},_qt="wrapper";function wqt(t){let{components:e,...n}=t;return(0,s.kt)(_qt,(0,p.Z)({},Xqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}wqt.isMDXComponent=!0;const Tqt={toc:[]},Cqt="wrapper";function xqt(t){let{components:e,...n}=t;return(0,s.kt)(Cqt,(0,p.Z)({},Tqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}xqt.isMDXComponent=!0;const gqt={toc:[]},vqt="wrapper";function Lqt(t){let{components:e,...n}=t;return(0,s.kt)(vqt,(0,p.Z)({},gqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"'white'"))}Lqt.isMDXComponent=!0;const Zqt={toc:[]},bqt="wrapper";function Nqt(t){let{components:e,...n}=t;return(0,s.kt)(bqt,(0,p.Z)({},Zqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}Nqt.isMDXComponent=!0;const zqt={toc:[]},Aqt="wrapper";function Pqt(t){let{components:e,...n}=t;return(0,s.kt)(Aqt,(0,p.Z)({},zqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Pqt.isMDXComponent=!0;const Wqt={toc:[]},Rqt="wrapper";function Iqt(t){let{components:e,...n}=t;return(0,s.kt)(Rqt,(0,p.Z)({},Wqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}Iqt.isMDXComponent=!0;const Sqt={toc:[]},Bqt="wrapper";function Gqt(t){let{components:e,...n}=t;return(0,s.kt)(Bqt,(0,p.Z)({},Sqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Gqt.isMDXComponent=!0;const Eqt={toc:[]},Oqt="wrapper";function Fqt(t){let{components:e,...n}=t;return(0,s.kt)(Oqt,(0,p.Z)({},Eqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Fqt.isMDXComponent=!0;const Uqt={toc:[]},Vqt="wrapper";function qqt(t){let{components:e,...n}=t;return(0,s.kt)(Vqt,(0,p.Z)({},Uqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}qqt.isMDXComponent=!0;const jqt={toc:[]},Yqt="wrapper";function Qqt(t){let{components:e,...n}=t;return(0,s.kt)(Yqt,(0,p.Z)({},jqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Qqt.isMDXComponent=!0;const Hqt={toc:[]},Kqt="wrapper";function $qt(t){let{components:e,...n}=t;return(0,s.kt)(Kqt,(0,p.Z)({},Hqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}$qt.isMDXComponent=!0;const Jqt={toc:[]},tjt="wrapper";function ejt(t){let{components:e,...n}=t;return(0,s.kt)(tjt,(0,p.Z)({},Jqt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}ejt.isMDXComponent=!0;const njt={toc:[]},ojt="wrapper";function pjt(t){let{components:e,...n}=t;return(0,s.kt)(ojt,(0,p.Z)({},njt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}pjt.isMDXComponent=!0;const rjt={toc:[]},sjt="wrapper";function cjt(t){let{components:e,...n}=t;return(0,s.kt)(sjt,(0,p.Z)({},rjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}cjt.isMDXComponent=!0;const ajt={toc:[]},ijt="wrapper";function ljt(t){let{components:e,...n}=t;return(0,s.kt)(ijt,(0,p.Z)({},ajt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}ljt.isMDXComponent=!0;const ujt={toc:[]},mjt="wrapper";function djt(t){let{components:e,...n}=t;return(0,s.kt)(mjt,(0,p.Z)({},ujt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}djt.isMDXComponent=!0;const hjt={toc:[]},fjt="wrapper";function kjt(t){let{components:e,...n}=t;return(0,s.kt)(fjt,(0,p.Z)({},hjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}kjt.isMDXComponent=!0;const yjt={toc:[]},Djt="wrapper";function Mjt(t){let{components:e,...n}=t;return(0,s.kt)(Djt,(0,p.Z)({},yjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Mjt.isMDXComponent=!0;const Xjt={toc:[]},_jt="wrapper";function wjt(t){let{components:e,...n}=t;return(0,s.kt)(_jt,(0,p.Z)({},Xjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}wjt.isMDXComponent=!0;const Tjt={toc:[]},Cjt="wrapper";function xjt(t){let{components:e,...n}=t;return(0,s.kt)(Cjt,(0,p.Z)({},Tjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}xjt.isMDXComponent=!0;const gjt={toc:[]},vjt="wrapper";function Ljt(t){let{components:e,...n}=t;return(0,s.kt)(vjt,(0,p.Z)({},gjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Ljt.isMDXComponent=!0;const Zjt={toc:[]},bjt="wrapper";function Njt(t){let{components:e,...n}=t;return(0,s.kt)(bjt,(0,p.Z)({},Zjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Njt.isMDXComponent=!0;const zjt={toc:[]},Ajt="wrapper";function Pjt(t){let{components:e,...n}=t;return(0,s.kt)(Ajt,(0,p.Z)({},zjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Pjt.isMDXComponent=!0;const Wjt={toc:[]},Rjt="wrapper";function Ijt(t){let{components:e,...n}=t;return(0,s.kt)(Rjt,(0,p.Z)({},Wjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Ijt.isMDXComponent=!0;const Sjt={toc:[]},Bjt="wrapper";function Gjt(t){let{components:e,...n}=t;return(0,s.kt)(Bjt,(0,p.Z)({},Sjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Gjt.isMDXComponent=!0;const Ejt={toc:[]},Ojt="wrapper";function Fjt(t){let{components:e,...n}=t;return(0,s.kt)(Ojt,(0,p.Z)({},Ejt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Fjt.isMDXComponent=!0;const Ujt={toc:[]},Vjt="wrapper";function qjt(t){let{components:e,...n}=t;return(0,s.kt)(Vjt,(0,p.Z)({},Ujt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}qjt.isMDXComponent=!0;const jjt={toc:[]},Yjt="wrapper";function Qjt(t){let{components:e,...n}=t;return(0,s.kt)(Yjt,(0,p.Z)({},jjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}Qjt.isMDXComponent=!0;const Hjt={toc:[]},Kjt="wrapper";function $jt(t){let{components:e,...n}=t;return(0,s.kt)(Kjt,(0,p.Z)({},Hjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}$jt.isMDXComponent=!0;const Jjt={toc:[]},tYt="wrapper";function eYt(t){let{components:e,...n}=t;return(0,s.kt)(tYt,(0,p.Z)({},Jjt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}eYt.isMDXComponent=!0;const nYt={toc:[]},oYt="wrapper";function pYt(t){let{components:e,...n}=t;return(0,s.kt)(oYt,(0,p.Z)({},nYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pYt.isMDXComponent=!0;const rYt={toc:[]},sYt="wrapper";function cYt(t){let{components:e,...n}=t;return(0,s.kt)(sYt,(0,p.Z)({},rYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}cYt.isMDXComponent=!0;const aYt={toc:[]},iYt="wrapper";function lYt(t){let{components:e,...n}=t;return(0,s.kt)(iYt,(0,p.Z)({},aYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}lYt.isMDXComponent=!0;const uYt={toc:[]},mYt="wrapper";function dYt(t){let{components:e,...n}=t;return(0,s.kt)(mYt,(0,p.Z)({},uYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}dYt.isMDXComponent=!0;const hYt={toc:[]},fYt="wrapper";function kYt(t){let{components:e,...n}=t;return(0,s.kt)(fYt,(0,p.Z)({},hYt,n,{components:e,mdxType:"MDXLayout"}))}kYt.isMDXComponent=!0;const yYt={toc:[]},DYt="wrapper";function MYt(t){let{components:e,...n}=t;return(0,s.kt)(DYt,(0,p.Z)({},yYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}MYt.isMDXComponent=!0;const XYt={toc:[]},_Yt="wrapper";function wYt(t){let{components:e,...n}=t;return(0,s.kt)(_Yt,(0,p.Z)({},XYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}wYt.isMDXComponent=!0;const TYt={toc:[]},CYt="wrapper";function xYt(t){let{components:e,...n}=t;return(0,s.kt)(CYt,(0,p.Z)({},TYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}xYt.isMDXComponent=!0;const gYt={toc:[]},vYt="wrapper";function LYt(t){let{components:e,...n}=t;return(0,s.kt)(vYt,(0,p.Z)({},gYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}LYt.isMDXComponent=!0;const ZYt={toc:[]},bYt="wrapper";function NYt(t){let{components:e,...n}=t;return(0,s.kt)(bYt,(0,p.Z)({},ZYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}NYt.isMDXComponent=!0;const zYt={toc:[]},AYt="wrapper";function PYt(t){let{components:e,...n}=t;return(0,s.kt)(AYt,(0,p.Z)({},zYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}PYt.isMDXComponent=!0;const WYt={toc:[]},RYt="wrapper";function IYt(t){let{components:e,...n}=t;return(0,s.kt)(RYt,(0,p.Z)({},WYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}IYt.isMDXComponent=!0;const SYt={toc:[]},BYt="wrapper";function GYt(t){let{components:e,...n}=t;return(0,s.kt)(BYt,(0,p.Z)({},SYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}GYt.isMDXComponent=!0;const EYt={toc:[]},OYt="wrapper";function FYt(t){let{components:e,...n}=t;return(0,s.kt)(OYt,(0,p.Z)({},EYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}FYt.isMDXComponent=!0;const UYt={toc:[]},VYt="wrapper";function qYt(t){let{components:e,...n}=t;return(0,s.kt)(VYt,(0,p.Z)({},UYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}qYt.isMDXComponent=!0;const jYt={toc:[]},YYt="wrapper";function QYt(t){let{components:e,...n}=t;return(0,s.kt)(YYt,(0,p.Z)({},jYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}QYt.isMDXComponent=!0;const HYt={toc:[]},KYt="wrapper";function $Yt(t){let{components:e,...n}=t;return(0,s.kt)(KYt,(0,p.Z)({},HYt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}$Yt.isMDXComponent=!0;const JYt={toc:[]},tQt="wrapper";function eQt(t){let{components:e,...n}=t;return(0,s.kt)(tQt,(0,p.Z)({},JYt,n,{components:e,mdxType:"MDXLayout"}))}eQt.isMDXComponent=!0;const nQt={toc:[]},oQt="wrapper";function pQt(t){let{components:e,...n}=t;return(0,s.kt)(oQt,(0,p.Z)({},nQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}pQt.isMDXComponent=!0;const rQt={toc:[]},sQt="wrapper";function cQt(t){let{components:e,...n}=t;return(0,s.kt)(sQt,(0,p.Z)({},rQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}cQt.isMDXComponent=!0;const aQt={toc:[]},iQt="wrapper";function lQt(t){let{components:e,...n}=t;return(0,s.kt)(iQt,(0,p.Z)({},aQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}lQt.isMDXComponent=!0;const uQt={toc:[]},mQt="wrapper";function dQt(t){let{components:e,...n}=t;return(0,s.kt)(mQt,(0,p.Z)({},uQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}dQt.isMDXComponent=!0;const hQt={toc:[]},fQt="wrapper";function kQt(t){let{components:e,...n}=t;return(0,s.kt)(fQt,(0,p.Z)({},hQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kQt.isMDXComponent=!0;const yQt={toc:[]},DQt="wrapper";function MQt(t){let{components:e,...n}=t;return(0,s.kt)(DQt,(0,p.Z)({},yQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}MQt.isMDXComponent=!0;const XQt={toc:[]},_Qt="wrapper";function wQt(t){let{components:e,...n}=t;return(0,s.kt)(_Qt,(0,p.Z)({},XQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}wQt.isMDXComponent=!0;const TQt={toc:[]},CQt="wrapper";function xQt(t){let{components:e,...n}=t;return(0,s.kt)(CQt,(0,p.Z)({},TQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}xQt.isMDXComponent=!0;const gQt={toc:[]},vQt="wrapper";function LQt(t){let{components:e,...n}=t;return(0,s.kt)(vQt,(0,p.Z)({},gQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}LQt.isMDXComponent=!0;const ZQt={toc:[]},bQt="wrapper";function NQt(t){let{components:e,...n}=t;return(0,s.kt)(bQt,(0,p.Z)({},ZQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}NQt.isMDXComponent=!0;const zQt={toc:[]},AQt="wrapper";function PQt(t){let{components:e,...n}=t;return(0,s.kt)(AQt,(0,p.Z)({},zQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}PQt.isMDXComponent=!0;const WQt={toc:[]},RQt="wrapper";function IQt(t){let{components:e,...n}=t;return(0,s.kt)(RQt,(0,p.Z)({},WQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}IQt.isMDXComponent=!0;const SQt={toc:[]},BQt="wrapper";function GQt(t){let{components:e,...n}=t;return(0,s.kt)(BQt,(0,p.Z)({},SQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}GQt.isMDXComponent=!0;const EQt={toc:[]},OQt="wrapper";function FQt(t){let{components:e,...n}=t;return(0,s.kt)(OQt,(0,p.Z)({},EQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}FQt.isMDXComponent=!0;const UQt={toc:[]},VQt="wrapper";function qQt(t){let{components:e,...n}=t;return(0,s.kt)(VQt,(0,p.Z)({},UQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}qQt.isMDXComponent=!0;const jQt={toc:[]},YQt="wrapper";function QQt(t){let{components:e,...n}=t;return(0,s.kt)(YQt,(0,p.Z)({},jQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}QQt.isMDXComponent=!0;const HQt={toc:[]},KQt="wrapper";function $Qt(t){let{components:e,...n}=t;return(0,s.kt)(KQt,(0,p.Z)({},HQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}$Qt.isMDXComponent=!0;const JQt={toc:[]},tHt="wrapper";function eHt(t){let{components:e,...n}=t;return(0,s.kt)(tHt,(0,p.Z)({},JQt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}eHt.isMDXComponent=!0;const nHt={toc:[]},oHt="wrapper";function pHt(t){let{components:e,...n}=t;return(0,s.kt)(oHt,(0,p.Z)({},nHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}pHt.isMDXComponent=!0;const rHt={toc:[]},sHt="wrapper";function cHt(t){let{components:e,...n}=t;return(0,s.kt)(sHt,(0,p.Z)({},rHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}cHt.isMDXComponent=!0;const aHt={toc:[]},iHt="wrapper";function lHt(t){let{components:e,...n}=t;return(0,s.kt)(iHt,(0,p.Z)({},aHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}lHt.isMDXComponent=!0;const uHt={toc:[]},mHt="wrapper";function dHt(t){let{components:e,...n}=t;return(0,s.kt)(mHt,(0,p.Z)({},uHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}dHt.isMDXComponent=!0;const hHt={toc:[]},fHt="wrapper";function kHt(t){let{components:e,...n}=t;return(0,s.kt)(fHt,(0,p.Z)({},hHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}kHt.isMDXComponent=!0;const yHt={toc:[]},DHt="wrapper";function MHt(t){let{components:e,...n}=t;return(0,s.kt)(DHt,(0,p.Z)({},yHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}MHt.isMDXComponent=!0;const XHt={toc:[]},_Ht="wrapper";function wHt(t){let{components:e,...n}=t;return(0,s.kt)(_Ht,(0,p.Z)({},XHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}wHt.isMDXComponent=!0;const THt={toc:[]},CHt="wrapper";function xHt(t){let{components:e,...n}=t;return(0,s.kt)(CHt,(0,p.Z)({},THt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}xHt.isMDXComponent=!0;const gHt={toc:[]},vHt="wrapper";function LHt(t){let{components:e,...n}=t;return(0,s.kt)(vHt,(0,p.Z)({},gHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}LHt.isMDXComponent=!0;const ZHt={toc:[]},bHt="wrapper";function NHt(t){let{components:e,...n}=t;return(0,s.kt)(bHt,(0,p.Z)({},ZHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}NHt.isMDXComponent=!0;const zHt={toc:[]},AHt="wrapper";function PHt(t){let{components:e,...n}=t;return(0,s.kt)(AHt,(0,p.Z)({},zHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}PHt.isMDXComponent=!0;const WHt={toc:[]},RHt="wrapper";function IHt(t){let{components:e,...n}=t;return(0,s.kt)(RHt,(0,p.Z)({},WHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}IHt.isMDXComponent=!0;const SHt={toc:[]},BHt="wrapper";function GHt(t){let{components:e,...n}=t;return(0,s.kt)(BHt,(0,p.Z)({},SHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}GHt.isMDXComponent=!0;const EHt={toc:[]},OHt="wrapper";function FHt(t){let{components:e,...n}=t;return(0,s.kt)(OHt,(0,p.Z)({},EHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}FHt.isMDXComponent=!0;const UHt={toc:[]},VHt="wrapper";function qHt(t){let{components:e,...n}=t;return(0,s.kt)(VHt,(0,p.Z)({},UHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}qHt.isMDXComponent=!0;const jHt={toc:[]},YHt="wrapper";function QHt(t){let{components:e,...n}=t;return(0,s.kt)(YHt,(0,p.Z)({},jHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}QHt.isMDXComponent=!0;const HHt={toc:[]},KHt="wrapper";function $Ht(t){let{components:e,...n}=t;return(0,s.kt)(KHt,(0,p.Z)({},HHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}$Ht.isMDXComponent=!0;const JHt={toc:[]},tKt="wrapper";function eKt(t){let{components:e,...n}=t;return(0,s.kt)(tKt,(0,p.Z)({},JHt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}eKt.isMDXComponent=!0;const nKt={toc:[]},oKt="wrapper";function pKt(t){let{components:e,...n}=t;return(0,s.kt)(oKt,(0,p.Z)({},nKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}pKt.isMDXComponent=!0;const rKt={toc:[]},sKt="wrapper";function cKt(t){let{components:e,...n}=t;return(0,s.kt)(sKt,(0,p.Z)({},rKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}cKt.isMDXComponent=!0;const aKt={toc:[]},iKt="wrapper";function lKt(t){let{components:e,...n}=t;return(0,s.kt)(iKt,(0,p.Z)({},aKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}lKt.isMDXComponent=!0;const uKt={toc:[]},mKt="wrapper";function dKt(t){let{components:e,...n}=t;return(0,s.kt)(mKt,(0,p.Z)({},uKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}dKt.isMDXComponent=!0;const hKt={toc:[]},fKt="wrapper";function kKt(t){let{components:e,...n}=t;return(0,s.kt)(fKt,(0,p.Z)({},hKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}kKt.isMDXComponent=!0;const yKt={toc:[]},DKt="wrapper";function MKt(t){let{components:e,...n}=t;return(0,s.kt)(DKt,(0,p.Z)({},yKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}MKt.isMDXComponent=!0;const XKt={toc:[]},_Kt="wrapper";function wKt(t){let{components:e,...n}=t;return(0,s.kt)(_Kt,(0,p.Z)({},XKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}wKt.isMDXComponent=!0;const TKt={toc:[]},CKt="wrapper";function xKt(t){let{components:e,...n}=t;return(0,s.kt)(CKt,(0,p.Z)({},TKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}xKt.isMDXComponent=!0;const gKt={toc:[]},vKt="wrapper";function LKt(t){let{components:e,...n}=t;return(0,s.kt)(vKt,(0,p.Z)({},gKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}LKt.isMDXComponent=!0;const ZKt={toc:[]},bKt="wrapper";function NKt(t){let{components:e,...n}=t;return(0,s.kt)(bKt,(0,p.Z)({},ZKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}NKt.isMDXComponent=!0;const zKt={toc:[]},AKt="wrapper";function PKt(t){let{components:e,...n}=t;return(0,s.kt)(AKt,(0,p.Z)({},zKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}PKt.isMDXComponent=!0;const WKt={toc:[]},RKt="wrapper";function IKt(t){let{components:e,...n}=t;return(0,s.kt)(RKt,(0,p.Z)({},WKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}IKt.isMDXComponent=!0;const SKt={toc:[]},BKt="wrapper";function GKt(t){let{components:e,...n}=t;return(0,s.kt)(BKt,(0,p.Z)({},SKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}GKt.isMDXComponent=!0;const EKt={toc:[]},OKt="wrapper";function FKt(t){let{components:e,...n}=t;return(0,s.kt)(OKt,(0,p.Z)({},EKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}FKt.isMDXComponent=!0;const UKt={toc:[]},VKt="wrapper";function qKt(t){let{components:e,...n}=t;return(0,s.kt)(VKt,(0,p.Z)({},UKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}qKt.isMDXComponent=!0;const jKt={toc:[]},YKt="wrapper";function QKt(t){let{components:e,...n}=t;return(0,s.kt)(YKt,(0,p.Z)({},jKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}QKt.isMDXComponent=!0;const HKt={toc:[]},KKt="wrapper";function $Kt(t){let{components:e,...n}=t;return(0,s.kt)(KKt,(0,p.Z)({},HKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$Kt.isMDXComponent=!0;const JKt={toc:[]},t$t="wrapper";function e$t(t){let{components:e,...n}=t;return(0,s.kt)(t$t,(0,p.Z)({},JKt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}e$t.isMDXComponent=!0;const n$t={toc:[]},o$t="wrapper";function p$t(t){let{components:e,...n}=t;return(0,s.kt)(o$t,(0,p.Z)({},n$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}p$t.isMDXComponent=!0;const r$t={toc:[]},s$t="wrapper";function c$t(t){let{components:e,...n}=t;return(0,s.kt)(s$t,(0,p.Z)({},r$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}c$t.isMDXComponent=!0;const a$t={toc:[]},i$t="wrapper";function l$t(t){let{components:e,...n}=t;return(0,s.kt)(i$t,(0,p.Z)({},a$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}l$t.isMDXComponent=!0;const u$t={toc:[]},m$t="wrapper";function d$t(t){let{components:e,...n}=t;return(0,s.kt)(m$t,(0,p.Z)({},u$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}d$t.isMDXComponent=!0;const h$t={toc:[]},f$t="wrapper";function k$t(t){let{components:e,...n}=t;return(0,s.kt)(f$t,(0,p.Z)({},h$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}k$t.isMDXComponent=!0;const y$t={toc:[]},D$t="wrapper";function M$t(t){let{components:e,...n}=t;return(0,s.kt)(D$t,(0,p.Z)({},y$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}M$t.isMDXComponent=!0;const X$t={toc:[]},_$t="wrapper";function w$t(t){let{components:e,...n}=t;return(0,s.kt)(_$t,(0,p.Z)({},X$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}w$t.isMDXComponent=!0;const T$t={toc:[]},C$t="wrapper";function x$t(t){let{components:e,...n}=t;return(0,s.kt)(C$t,(0,p.Z)({},T$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}x$t.isMDXComponent=!0;const g$t={toc:[]},v$t="wrapper";function L$t(t){let{components:e,...n}=t;return(0,s.kt)(v$t,(0,p.Z)({},g$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}L$t.isMDXComponent=!0;const Z$t={toc:[]},b$t="wrapper";function N$t(t){let{components:e,...n}=t;return(0,s.kt)(b$t,(0,p.Z)({},Z$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}N$t.isMDXComponent=!0;const z$t={toc:[]},A$t="wrapper";function P$t(t){let{components:e,...n}=t;return(0,s.kt)(A$t,(0,p.Z)({},z$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}P$t.isMDXComponent=!0;const W$t={toc:[]},R$t="wrapper";function I$t(t){let{components:e,...n}=t;return(0,s.kt)(R$t,(0,p.Z)({},W$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}I$t.isMDXComponent=!0;const S$t={toc:[]},B$t="wrapper";function G$t(t){let{components:e,...n}=t;return(0,s.kt)(B$t,(0,p.Z)({},S$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}G$t.isMDXComponent=!0;const E$t={toc:[]},O$t="wrapper";function F$t(t){let{components:e,...n}=t;return(0,s.kt)(O$t,(0,p.Z)({},E$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}F$t.isMDXComponent=!0;const U$t={toc:[]},V$t="wrapper";function q$t(t){let{components:e,...n}=t;return(0,s.kt)(V$t,(0,p.Z)({},U$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}q$t.isMDXComponent=!0;const j$t={toc:[]},Y$t="wrapper";function Q$t(t){let{components:e,...n}=t;return(0,s.kt)(Y$t,(0,p.Z)({},j$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Q$t.isMDXComponent=!0;const H$t={toc:[]},K$t="wrapper";function $$t(t){let{components:e,...n}=t;return(0,s.kt)(K$t,(0,p.Z)({},H$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}$$t.isMDXComponent=!0;const J$t={toc:[]},tJt="wrapper";function eJt(t){let{components:e,...n}=t;return(0,s.kt)(tJt,(0,p.Z)({},J$t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}eJt.isMDXComponent=!0;const nJt={toc:[]},oJt="wrapper";function pJt(t){let{components:e,...n}=t;return(0,s.kt)(oJt,(0,p.Z)({},nJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pJt.isMDXComponent=!0;const rJt={toc:[]},sJt="wrapper";function cJt(t){let{components:e,...n}=t;return(0,s.kt)(sJt,(0,p.Z)({},rJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}cJt.isMDXComponent=!0;const aJt={toc:[]},iJt="wrapper";function lJt(t){let{components:e,...n}=t;return(0,s.kt)(iJt,(0,p.Z)({},aJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}lJt.isMDXComponent=!0;const uJt={toc:[]},mJt="wrapper";function dJt(t){let{components:e,...n}=t;return(0,s.kt)(mJt,(0,p.Z)({},uJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}dJt.isMDXComponent=!0;const hJt={toc:[]},fJt="wrapper";function kJt(t){let{components:e,...n}=t;return(0,s.kt)(fJt,(0,p.Z)({},hJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}kJt.isMDXComponent=!0;const yJt={toc:[]},DJt="wrapper";function MJt(t){let{components:e,...n}=t;return(0,s.kt)(DJt,(0,p.Z)({},yJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}MJt.isMDXComponent=!0;const XJt={toc:[]},_Jt="wrapper";function wJt(t){let{components:e,...n}=t;return(0,s.kt)(_Jt,(0,p.Z)({},XJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," getter"))}wJt.isMDXComponent=!0;const TJt={toc:[]},CJt="wrapper";function xJt(t){let{components:e,...n}=t;return(0,s.kt)(CJt,(0,p.Z)({},TJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}xJt.isMDXComponent=!0;const gJt={toc:[]},vJt="wrapper";function LJt(t){let{components:e,...n}=t;return(0,s.kt)(vJt,(0,p.Z)({},gJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}LJt.isMDXComponent=!0;const ZJt={toc:[]},bJt="wrapper";function NJt(t){let{components:e,...n}=t;return(0,s.kt)(bJt,(0,p.Z)({},ZJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}NJt.isMDXComponent=!0;const zJt={toc:[]},AJt="wrapper";function PJt(t){let{components:e,...n}=t;return(0,s.kt)(AJt,(0,p.Z)({},zJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}PJt.isMDXComponent=!0;const WJt={toc:[]},RJt="wrapper";function IJt(t){let{components:e,...n}=t;return(0,s.kt)(RJt,(0,p.Z)({},WJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}IJt.isMDXComponent=!0;const SJt={toc:[]},BJt="wrapper";function GJt(t){let{components:e,...n}=t;return(0,s.kt)(BJt,(0,p.Z)({},SJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}GJt.isMDXComponent=!0;const EJt={toc:[]},OJt="wrapper";function FJt(t){let{components:e,...n}=t;return(0,s.kt)(OJt,(0,p.Z)({},EJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}FJt.isMDXComponent=!0;const UJt={toc:[]},VJt="wrapper";function qJt(t){let{components:e,...n}=t;return(0,s.kt)(VJt,(0,p.Z)({},UJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}qJt.isMDXComponent=!0;const jJt={toc:[]},YJt="wrapper";function QJt(t){let{components:e,...n}=t;return(0,s.kt)(YJt,(0,p.Z)({},jJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}QJt.isMDXComponent=!0;const HJt={toc:[]},KJt="wrapper";function $Jt(t){let{components:e,...n}=t;return(0,s.kt)(KJt,(0,p.Z)({},HJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}$Jt.isMDXComponent=!0;const JJt={toc:[]},t0t="wrapper";function e0t(t){let{components:e,...n}=t;return(0,s.kt)(t0t,(0,p.Z)({},JJt,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}e0t.isMDXComponent=!0;const n0t={toc:[]},o0t="wrapper";function p0t(t){let{components:e,...n}=t;return(0,s.kt)(o0t,(0,p.Z)({},n0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}p0t.isMDXComponent=!0;const r0t={toc:[]},s0t="wrapper";function c0t(t){let{components:e,...n}=t;return(0,s.kt)(s0t,(0,p.Z)({},r0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}c0t.isMDXComponent=!0;const a0t={toc:[]},i0t="wrapper";function l0t(t){let{components:e,...n}=t;return(0,s.kt)(i0t,(0,p.Z)({},a0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}l0t.isMDXComponent=!0;const u0t={toc:[]},m0t="wrapper";function d0t(t){let{components:e,...n}=t;return(0,s.kt)(m0t,(0,p.Z)({},u0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}d0t.isMDXComponent=!0;const h0t={toc:[]},f0t="wrapper";function k0t(t){let{components:e,...n}=t;return(0,s.kt)(f0t,(0,p.Z)({},h0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}k0t.isMDXComponent=!0;const y0t={toc:[]},D0t="wrapper";function M0t(t){let{components:e,...n}=t;return(0,s.kt)(D0t,(0,p.Z)({},y0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}M0t.isMDXComponent=!0;const X0t={toc:[]},_0t="wrapper";function w0t(t){let{components:e,...n}=t;return(0,s.kt)(_0t,(0,p.Z)({},X0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}w0t.isMDXComponent=!0;const T0t={toc:[]},C0t="wrapper";function x0t(t){let{components:e,...n}=t;return(0,s.kt)(C0t,(0,p.Z)({},T0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}x0t.isMDXComponent=!0;const g0t={toc:[]},v0t="wrapper";function L0t(t){let{components:e,...n}=t;return(0,s.kt)(v0t,(0,p.Z)({},g0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}L0t.isMDXComponent=!0;const Z0t={toc:[]},b0t="wrapper";function N0t(t){let{components:e,...n}=t;return(0,s.kt)(b0t,(0,p.Z)({},Z0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}N0t.isMDXComponent=!0;const z0t={toc:[]},A0t="wrapper";function P0t(t){let{components:e,...n}=t;return(0,s.kt)(A0t,(0,p.Z)({},z0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}P0t.isMDXComponent=!0;const W0t={toc:[]},R0t="wrapper";function I0t(t){let{components:e,...n}=t;return(0,s.kt)(R0t,(0,p.Z)({},W0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}I0t.isMDXComponent=!0;const S0t={toc:[]},B0t="wrapper";function G0t(t){let{components:e,...n}=t;return(0,s.kt)(B0t,(0,p.Z)({},S0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}G0t.isMDXComponent=!0;const E0t={toc:[]},O0t="wrapper";function F0t(t){let{components:e,...n}=t;return(0,s.kt)(O0t,(0,p.Z)({},E0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}F0t.isMDXComponent=!0;const U0t={toc:[]},V0t="wrapper";function q0t(t){let{components:e,...n}=t;return(0,s.kt)(V0t,(0,p.Z)({},U0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}q0t.isMDXComponent=!0;const j0t={toc:[]},Y0t="wrapper";function Q0t(t){let{components:e,...n}=t;return(0,s.kt)(Y0t,(0,p.Z)({},j0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Q0t.isMDXComponent=!0;const H0t={toc:[]},K0t="wrapper";function $0t(t){let{components:e,...n}=t;return(0,s.kt)(K0t,(0,p.Z)({},H0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}$0t.isMDXComponent=!0;const J0t={toc:[]},t4t="wrapper";function e4t(t){let{components:e,...n}=t;return(0,s.kt)(t4t,(0,p.Z)({},J0t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}e4t.isMDXComponent=!0;const n4t={toc:[]},o4t="wrapper";function p4t(t){let{components:e,...n}=t;return(0,s.kt)(o4t,(0,p.Z)({},n4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}p4t.isMDXComponent=!0;const r4t={toc:[]},s4t="wrapper";function c4t(t){let{components:e,...n}=t;return(0,s.kt)(s4t,(0,p.Z)({},r4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}c4t.isMDXComponent=!0;const a4t={toc:[]},i4t="wrapper";function l4t(t){let{components:e,...n}=t;return(0,s.kt)(i4t,(0,p.Z)({},a4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}l4t.isMDXComponent=!0;const u4t={toc:[]},m4t="wrapper";function d4t(t){let{components:e,...n}=t;return(0,s.kt)(m4t,(0,p.Z)({},u4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}d4t.isMDXComponent=!0;const h4t={toc:[]},f4t="wrapper";function k4t(t){let{components:e,...n}=t;return(0,s.kt)(f4t,(0,p.Z)({},h4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}k4t.isMDXComponent=!0;const y4t={toc:[]},D4t="wrapper";function M4t(t){let{components:e,...n}=t;return(0,s.kt)(D4t,(0,p.Z)({},y4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}M4t.isMDXComponent=!0;const X4t={toc:[]},_4t="wrapper";function w4t(t){let{components:e,...n}=t;return(0,s.kt)(_4t,(0,p.Z)({},X4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}w4t.isMDXComponent=!0;const T4t={toc:[]},C4t="wrapper";function x4t(t){let{components:e,...n}=t;return(0,s.kt)(C4t,(0,p.Z)({},T4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}x4t.isMDXComponent=!0;const g4t={toc:[]},v4t="wrapper";function L4t(t){let{components:e,...n}=t;return(0,s.kt)(v4t,(0,p.Z)({},g4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}L4t.isMDXComponent=!0;const Z4t={toc:[]},b4t="wrapper";function N4t(t){let{components:e,...n}=t;return(0,s.kt)(b4t,(0,p.Z)({},Z4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}N4t.isMDXComponent=!0;const z4t={toc:[]},A4t="wrapper";function P4t(t){let{components:e,...n}=t;return(0,s.kt)(A4t,(0,p.Z)({},z4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}P4t.isMDXComponent=!0;const W4t={toc:[]},R4t="wrapper";function I4t(t){let{components:e,...n}=t;return(0,s.kt)(R4t,(0,p.Z)({},W4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}I4t.isMDXComponent=!0;const S4t={toc:[]},B4t="wrapper";function G4t(t){let{components:e,...n}=t;return(0,s.kt)(B4t,(0,p.Z)({},S4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}G4t.isMDXComponent=!0;const E4t={toc:[]},O4t="wrapper";function F4t(t){let{components:e,...n}=t;return(0,s.kt)(O4t,(0,p.Z)({},E4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}F4t.isMDXComponent=!0;const U4t={toc:[]},V4t="wrapper";function q4t(t){let{components:e,...n}=t;return(0,s.kt)(V4t,(0,p.Z)({},U4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}q4t.isMDXComponent=!0;const j4t={toc:[]},Y4t="wrapper";function Q4t(t){let{components:e,...n}=t;return(0,s.kt)(Y4t,(0,p.Z)({},j4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Q4t.isMDXComponent=!0;const H4t={toc:[]},K4t="wrapper";function $4t(t){let{components:e,...n}=t;return(0,s.kt)(K4t,(0,p.Z)({},H4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}$4t.isMDXComponent=!0;const J4t={toc:[]},t6t="wrapper";function e6t(t){let{components:e,...n}=t;return(0,s.kt)(t6t,(0,p.Z)({},J4t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}e6t.isMDXComponent=!0;const n6t={toc:[]},o6t="wrapper";function p6t(t){let{components:e,...n}=t;return(0,s.kt)(o6t,(0,p.Z)({},n6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}p6t.isMDXComponent=!0;const r6t={toc:[]},s6t="wrapper";function c6t(t){let{components:e,...n}=t;return(0,s.kt)(s6t,(0,p.Z)({},r6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}c6t.isMDXComponent=!0;const a6t={toc:[]},i6t="wrapper";function l6t(t){let{components:e,...n}=t;return(0,s.kt)(i6t,(0,p.Z)({},a6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}l6t.isMDXComponent=!0;const u6t={toc:[]},m6t="wrapper";function d6t(t){let{components:e,...n}=t;return(0,s.kt)(m6t,(0,p.Z)({},u6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}d6t.isMDXComponent=!0;const h6t={toc:[]},f6t="wrapper";function k6t(t){let{components:e,...n}=t;return(0,s.kt)(f6t,(0,p.Z)({},h6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}k6t.isMDXComponent=!0;const y6t={toc:[]},D6t="wrapper";function M6t(t){let{components:e,...n}=t;return(0,s.kt)(D6t,(0,p.Z)({},y6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}M6t.isMDXComponent=!0;const X6t={toc:[]},_6t="wrapper";function w6t(t){let{components:e,...n}=t;return(0,s.kt)(_6t,(0,p.Z)({},X6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}w6t.isMDXComponent=!0;const T6t={toc:[]},C6t="wrapper";function x6t(t){let{components:e,...n}=t;return(0,s.kt)(C6t,(0,p.Z)({},T6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}x6t.isMDXComponent=!0;const g6t={toc:[]},v6t="wrapper";function L6t(t){let{components:e,...n}=t;return(0,s.kt)(v6t,(0,p.Z)({},g6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}L6t.isMDXComponent=!0;const Z6t={toc:[]},b6t="wrapper";function N6t(t){let{components:e,...n}=t;return(0,s.kt)(b6t,(0,p.Z)({},Z6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}N6t.isMDXComponent=!0;const z6t={toc:[]},A6t="wrapper";function P6t(t){let{components:e,...n}=t;return(0,s.kt)(A6t,(0,p.Z)({},z6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}P6t.isMDXComponent=!0;const W6t={toc:[]},R6t="wrapper";function I6t(t){let{components:e,...n}=t;return(0,s.kt)(R6t,(0,p.Z)({},W6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}I6t.isMDXComponent=!0;const S6t={toc:[]},B6t="wrapper";function G6t(t){let{components:e,...n}=t;return(0,s.kt)(B6t,(0,p.Z)({},S6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}G6t.isMDXComponent=!0;const E6t={toc:[]},O6t="wrapper";function F6t(t){let{components:e,...n}=t;return(0,s.kt)(O6t,(0,p.Z)({},E6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}F6t.isMDXComponent=!0;const U6t={toc:[]},V6t="wrapper";function q6t(t){let{components:e,...n}=t;return(0,s.kt)(V6t,(0,p.Z)({},U6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}q6t.isMDXComponent=!0;const j6t={toc:[]},Y6t="wrapper";function Q6t(t){let{components:e,...n}=t;return(0,s.kt)(Y6t,(0,p.Z)({},j6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Q6t.isMDXComponent=!0;const H6t={toc:[]},K6t="wrapper";function $6t(t){let{components:e,...n}=t;return(0,s.kt)(K6t,(0,p.Z)({},H6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}$6t.isMDXComponent=!0;const J6t={toc:[]},t3t="wrapper";function e3t(t){let{components:e,...n}=t;return(0,s.kt)(t3t,(0,p.Z)({},J6t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}e3t.isMDXComponent=!0;const n3t={toc:[]},o3t="wrapper";function p3t(t){let{components:e,...n}=t;return(0,s.kt)(o3t,(0,p.Z)({},n3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}p3t.isMDXComponent=!0;const r3t={toc:[]},s3t="wrapper";function c3t(t){let{components:e,...n}=t;return(0,s.kt)(s3t,(0,p.Z)({},r3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}c3t.isMDXComponent=!0;const a3t={toc:[]},i3t="wrapper";function l3t(t){let{components:e,...n}=t;return(0,s.kt)(i3t,(0,p.Z)({},a3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}l3t.isMDXComponent=!0;const u3t={toc:[]},m3t="wrapper";function d3t(t){let{components:e,...n}=t;return(0,s.kt)(m3t,(0,p.Z)({},u3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}d3t.isMDXComponent=!0;const h3t={toc:[]},f3t="wrapper";function k3t(t){let{components:e,...n}=t;return(0,s.kt)(f3t,(0,p.Z)({},h3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}k3t.isMDXComponent=!0;const y3t={toc:[]},D3t="wrapper";function M3t(t){let{components:e,...n}=t;return(0,s.kt)(D3t,(0,p.Z)({},y3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}M3t.isMDXComponent=!0;const X3t={toc:[]},_3t="wrapper";function w3t(t){let{components:e,...n}=t;return(0,s.kt)(_3t,(0,p.Z)({},X3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}w3t.isMDXComponent=!0;const T3t={toc:[]},C3t="wrapper";function x3t(t){let{components:e,...n}=t;return(0,s.kt)(C3t,(0,p.Z)({},T3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}x3t.isMDXComponent=!0;const g3t={toc:[]},v3t="wrapper";function L3t(t){let{components:e,...n}=t;return(0,s.kt)(v3t,(0,p.Z)({},g3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}L3t.isMDXComponent=!0;const Z3t={toc:[]},b3t="wrapper";function N3t(t){let{components:e,...n}=t;return(0,s.kt)(b3t,(0,p.Z)({},Z3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}N3t.isMDXComponent=!0;const z3t={toc:[]},A3t="wrapper";function P3t(t){let{components:e,...n}=t;return(0,s.kt)(A3t,(0,p.Z)({},z3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}P3t.isMDXComponent=!0;const W3t={toc:[]},R3t="wrapper";function I3t(t){let{components:e,...n}=t;return(0,s.kt)(R3t,(0,p.Z)({},W3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}I3t.isMDXComponent=!0;const S3t={toc:[]},B3t="wrapper";function G3t(t){let{components:e,...n}=t;return(0,s.kt)(B3t,(0,p.Z)({},S3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}G3t.isMDXComponent=!0;const E3t={toc:[]},O3t="wrapper";function F3t(t){let{components:e,...n}=t;return(0,s.kt)(O3t,(0,p.Z)({},E3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}F3t.isMDXComponent=!0;const U3t={toc:[]},V3t="wrapper";function q3t(t){let{components:e,...n}=t;return(0,s.kt)(V3t,(0,p.Z)({},U3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}q3t.isMDXComponent=!0;const j3t={toc:[]},Y3t="wrapper";function Q3t(t){let{components:e,...n}=t;return(0,s.kt)(Y3t,(0,p.Z)({},j3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"overrides ",(0,s.kt)("inlineCode",{parentName:"p"},"Image.src")," setter to warn the user that the value\nis not used"))}Q3t.isMDXComponent=!0;const H3t={toc:[]},K3t="wrapper";function $3t(t){let{components:e,...n}=t;return(0,s.kt)(K3t,(0,p.Z)({},H3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}$3t.isMDXComponent=!0;const J3t={toc:[]},t7t="wrapper";function e7t(t){let{components:e,...n}=t;return(0,s.kt)(t7t,(0,p.Z)({},J3t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}e7t.isMDXComponent=!0;const n7t={toc:[]},o7t="wrapper";function p7t(t){let{components:e,...n}=t;return(0,s.kt)(o7t,(0,p.Z)({},n7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}p7t.isMDXComponent=!0;const r7t={toc:[]},s7t="wrapper";function c7t(t){let{components:e,...n}=t;return(0,s.kt)(s7t,(0,p.Z)({},r7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}c7t.isMDXComponent=!0;const a7t={toc:[]},i7t="wrapper";function l7t(t){let{components:e,...n}=t;return(0,s.kt)(i7t,(0,p.Z)({},a7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}l7t.isMDXComponent=!0;const u7t={toc:[]},m7t="wrapper";function d7t(t){let{components:e,...n}=t;return(0,s.kt)(m7t,(0,p.Z)({},u7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}d7t.isMDXComponent=!0;const h7t={toc:[]},f7t="wrapper";function k7t(t){let{components:e,...n}=t;return(0,s.kt)(f7t,(0,p.Z)({},h7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Address to Iconify API for the requested Icon."))}k7t.isMDXComponent=!0;const y7t={toc:[]},D7t="wrapper";function M7t(t){let{components:e,...n}=t;return(0,s.kt)(D7t,(0,p.Z)({},y7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create the URL that will be used as the Image source"))}M7t.isMDXComponent=!0;const X7t={toc:[]},_7t="wrapper";function w7t(t){let{components:e,...n}=t;return(0,s.kt)(_7t,(0,p.Z)({},X7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}w7t.isMDXComponent=!0;const T7t={toc:[]},C7t="wrapper";function x7t(t){let{components:e,...n}=t;return(0,s.kt)(C7t,(0,p.Z)({},T7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}x7t.isMDXComponent=!0;const g7t={toc:[]},v7t="wrapper";function L7t(t){let{components:e,...n}=t;return(0,s.kt)(v7t,(0,p.Z)({},g7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}L7t.isMDXComponent=!0;const Z7t={toc:[]},b7t="wrapper";function N7t(t){let{components:e,...n}=t;return(0,s.kt)(b7t,(0,p.Z)({},Z7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Icon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}N7t.isMDXComponent=!0;const z7t={toc:[]},A7t="wrapper";function P7t(t){let{components:e,...n}=t;return(0,s.kt)(A7t,(0,p.Z)({},z7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}P7t.isMDXComponent=!0;const W7t={toc:[]},R7t="wrapper";function I7t(t){let{components:e,...n}=t;return(0,s.kt)(R7t,(0,p.Z)({},W7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}I7t.isMDXComponent=!0;const S7t={toc:[]},B7t="wrapper";function G7t(t){let{components:e,...n}=t;return(0,s.kt)(B7t,(0,p.Z)({},S7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}G7t.isMDXComponent=!0;const E7t={toc:[]},O7t="wrapper";function F7t(t){let{components:e,...n}=t;return(0,s.kt)(O7t,(0,p.Z)({},E7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}F7t.isMDXComponent=!0;const U7t={toc:[]},V7t="wrapper";function q7t(t){let{components:e,...n}=t;return(0,s.kt)(V7t,(0,p.Z)({},U7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}q7t.isMDXComponent=!0;const j7t={toc:[]},Y7t="wrapper";function Q7t(t){let{components:e,...n}=t;return(0,s.kt)(Y7t,(0,p.Z)({},j7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Q7t.isMDXComponent=!0;const H7t={toc:[]},K7t="wrapper";function $7t(t){let{components:e,...n}=t;return(0,s.kt)(K7t,(0,p.Z)({},H7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Img} from '@motion-canvas/2d';\nimport {all, waitFor} from '@motion-canvas/core';\nimport {createRef} from '@motion-canvas/core';\nimport {makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Img>();\n  yield view.add(\n    <Img\n      ref={ref}\n      src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n      width={300}\n      radius={20}\n    />,\n  );\n\n  // set the background using the color sampled from the image:\n  ref().fill(ref().getColorAtPoint(0));\n\n  yield* all(\n    ref().size([100, 100], 1).to([300, null], 1),\n    ref().radius(50, 1).to(20, 1),\n    ref().alpha(0, 1).to(1, 1),\n  );\n  yield* waitFor(0.5);\n});\n")))}$7t.isMDXComponent=!0;const J7t={toc:[]},t2t="wrapper";function e2t(t){let{components:e,...n}=t;return(0,s.kt)(t2t,(0,p.Z)({},J7t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for displaying images."))}e2t.isMDXComponent=!0;const n2t={toc:[]},o2t="wrapper";function p2t(t){let{components:e,...n}=t;return(0,s.kt)(o2t,(0,p.Z)({},n2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}p2t.isMDXComponent=!0;const r2t={toc:[]},s2t="wrapper";function c2t(t){let{components:e,...n}=t;return(0,s.kt)(s2t,(0,p.Z)({},r2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}c2t.isMDXComponent=!0;const a2t={toc:[]},i2t="wrapper";function l2t(t){let{components:e,...n}=t;return(0,s.kt)(i2t,(0,p.Z)({},a2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}l2t.isMDXComponent=!0;const u2t={toc:[]},m2t="wrapper";function d2t(t){let{components:e,...n}=t;return(0,s.kt)(m2t,(0,p.Z)({},u2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}d2t.isMDXComponent=!0;const h2t={toc:[]},f2t="wrapper";function k2t(t){let{components:e,...n}=t;return(0,s.kt)(f2t,(0,p.Z)({},h2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}k2t.isMDXComponent=!0;const y2t={toc:[]},D2t="wrapper";function M2t(t){let{components:e,...n}=t;return(0,s.kt)(D2t,(0,p.Z)({},y2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}M2t.isMDXComponent=!0;const X2t={toc:[]},_2t="wrapper";function w2t(t){let{components:e,...n}=t;return(0,s.kt)(_2t,(0,p.Z)({},X2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}w2t.isMDXComponent=!0;const T2t={toc:[]},C2t="wrapper";function x2t(t){let{components:e,...n}=t;return(0,s.kt)(C2t,(0,p.Z)({},T2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}x2t.isMDXComponent=!0;const g2t={toc:[]},v2t="wrapper";function L2t(t){let{components:e,...n}=t;return(0,s.kt)(v2t,(0,p.Z)({},g2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}L2t.isMDXComponent=!0;const Z2t={toc:[]},b2t="wrapper";function N2t(t){let{components:e,...n}=t;return(0,s.kt)(b2t,(0,p.Z)({},Z2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}N2t.isMDXComponent=!0;const z2t={toc:[]},A2t="wrapper";function P2t(t){let{components:e,...n}=t;return(0,s.kt)(A2t,(0,p.Z)({},z2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}P2t.isMDXComponent=!0;const W2t={toc:[]},R2t="wrapper";function I2t(t){let{components:e,...n}=t;return(0,s.kt)(R2t,(0,p.Z)({},W2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}I2t.isMDXComponent=!0;const S2t={toc:[]},B2t="wrapper";function G2t(t){let{components:e,...n}=t;return(0,s.kt)(B2t,(0,p.Z)({},S2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}G2t.isMDXComponent=!0;const E2t={toc:[]},O2t="wrapper";function F2t(t){let{components:e,...n}=t;return(0,s.kt)(O2t,(0,p.Z)({},E2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}F2t.isMDXComponent=!0;const U2t={toc:[]},V2t="wrapper";function q2t(t){let{components:e,...n}=t;return(0,s.kt)(V2t,(0,p.Z)({},U2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}q2t.isMDXComponent=!0;const j2t={toc:[]},Y2t="wrapper";function Q2t(t){let{components:e,...n}=t;return(0,s.kt)(Y2t,(0,p.Z)({},j2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Q2t.isMDXComponent=!0;const H2t={toc:[]},K2t="wrapper";function $2t(t){let{components:e,...n}=t;return(0,s.kt)(K2t,(0,p.Z)({},H2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}$2t.isMDXComponent=!0;const J2t={toc:[]},t1t="wrapper";function e1t(t){let{components:e,...n}=t;return(0,s.kt)(t1t,(0,p.Z)({},J2t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}e1t.isMDXComponent=!0;const n1t={toc:[]},o1t="wrapper";function p1t(t){let{components:e,...n}=t;return(0,s.kt)(o1t,(0,p.Z)({},n1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}p1t.isMDXComponent=!0;const r1t={toc:[]},s1t="wrapper";function c1t(t){let{components:e,...n}=t;return(0,s.kt)(s1t,(0,p.Z)({},r1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}c1t.isMDXComponent=!0;const a1t={toc:[]},i1t="wrapper";function l1t(t){let{components:e,...n}=t;return(0,s.kt)(i1t,(0,p.Z)({},a1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}l1t.isMDXComponent=!0;const u1t={toc:[]},m1t="wrapper";function d1t(t){let{components:e,...n}=t;return(0,s.kt)(m1t,(0,p.Z)({},u1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}d1t.isMDXComponent=!0;const h1t={toc:[]},f1t="wrapper";function k1t(t){let{components:e,...n}=t;return(0,s.kt)(f1t,(0,p.Z)({},h1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}k1t.isMDXComponent=!0;const y1t={toc:[]},D1t="wrapper";function M1t(t){let{components:e,...n}=t;return(0,s.kt)(D1t,(0,p.Z)({},y1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}M1t.isMDXComponent=!0;const X1t={toc:[]},_1t="wrapper";function w1t(t){let{components:e,...n}=t;return(0,s.kt)(_1t,(0,p.Z)({},X1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}w1t.isMDXComponent=!0;const T1t={toc:[]},C1t="wrapper";function x1t(t){let{components:e,...n}=t;return(0,s.kt)(C1t,(0,p.Z)({},T1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}x1t.isMDXComponent=!0;const g1t={toc:[]},v1t="wrapper";function L1t(t){let{components:e,...n}=t;return(0,s.kt)(v1t,(0,p.Z)({},g1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}L1t.isMDXComponent=!0;const Z1t={toc:[]},b1t="wrapper";function N1t(t){let{components:e,...n}=t;return(0,s.kt)(b1t,(0,p.Z)({},Z1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}N1t.isMDXComponent=!0;const z1t={toc:[]},A1t="wrapper";function P1t(t){let{components:e,...n}=t;return(0,s.kt)(A1t,(0,p.Z)({},z1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}P1t.isMDXComponent=!0;const W1t={toc:[]},R1t="wrapper";function I1t(t){let{components:e,...n}=t;return(0,s.kt)(R1t,(0,p.Z)({},W1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}I1t.isMDXComponent=!0;const S1t={toc:[]},B1t="wrapper";function G1t(t){let{components:e,...n}=t;return(0,s.kt)(B1t,(0,p.Z)({},S1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}G1t.isMDXComponent=!0;const E1t={toc:[]},O1t="wrapper";function F1t(t){let{components:e,...n}=t;return(0,s.kt)(O1t,(0,p.Z)({},E1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}F1t.isMDXComponent=!0;const U1t={toc:[]},V1t="wrapper";function q1t(t){let{components:e,...n}=t;return(0,s.kt)(V1t,(0,p.Z)({},U1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}q1t.isMDXComponent=!0;const j1t={toc:[]},Y1t="wrapper";function Q1t(t){let{components:e,...n}=t;return(0,s.kt)(Y1t,(0,p.Z)({},j1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Q1t.isMDXComponent=!0;const H1t={toc:[]},K1t="wrapper";function $1t(t){let{components:e,...n}=t;return(0,s.kt)(K1t,(0,p.Z)({},H1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}$1t.isMDXComponent=!0;const J1t={toc:[]},t8t="wrapper";function e8t(t){let{components:e,...n}=t;return(0,s.kt)(t8t,(0,p.Z)({},J1t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}e8t.isMDXComponent=!0;const n8t={toc:[]},o8t="wrapper";function p8t(t){let{components:e,...n}=t;return(0,s.kt)(o8t,(0,p.Z)({},n8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}p8t.isMDXComponent=!0;const r8t={toc:[]},s8t="wrapper";function c8t(t){let{components:e,...n}=t;return(0,s.kt)(s8t,(0,p.Z)({},r8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}c8t.isMDXComponent=!0;const a8t={toc:[]},i8t="wrapper";function l8t(t){let{components:e,...n}=t;return(0,s.kt)(i8t,(0,p.Z)({},a8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}l8t.isMDXComponent=!0;const u8t={toc:[]},m8t="wrapper";function d8t(t){let{components:e,...n}=t;return(0,s.kt)(m8t,(0,p.Z)({},u8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}d8t.isMDXComponent=!0;const h8t={toc:[]},f8t="wrapper";function k8t(t){let{components:e,...n}=t;return(0,s.kt)(f8t,(0,p.Z)({},h8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}k8t.isMDXComponent=!0;const y8t={toc:[]},D8t="wrapper";function M8t(t){let{components:e,...n}=t;return(0,s.kt)(D8t,(0,p.Z)({},y8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}M8t.isMDXComponent=!0;const X8t={toc:[]},_8t="wrapper";function w8t(t){let{components:e,...n}=t;return(0,s.kt)(_8t,(0,p.Z)({},X8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}w8t.isMDXComponent=!0;const T8t={toc:[]},C8t="wrapper";function x8t(t){let{components:e,...n}=t;return(0,s.kt)(C8t,(0,p.Z)({},T8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}x8t.isMDXComponent=!0;const g8t={toc:[]},v8t="wrapper";function L8t(t){let{components:e,...n}=t;return(0,s.kt)(v8t,(0,p.Z)({},g8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}L8t.isMDXComponent=!0;const Z8t={toc:[]},b8t="wrapper";function N8t(t){let{components:e,...n}=t;return(0,s.kt)(b8t,(0,p.Z)({},Z8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}N8t.isMDXComponent=!0;const z8t={toc:[]},A8t="wrapper";function P8t(t){let{components:e,...n}=t;return(0,s.kt)(A8t,(0,p.Z)({},z8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}P8t.isMDXComponent=!0;const W8t={toc:[]},R8t="wrapper";function I8t(t){let{components:e,...n}=t;return(0,s.kt)(R8t,(0,p.Z)({},W8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}I8t.isMDXComponent=!0;const S8t={toc:[]},B8t="wrapper";function G8t(t){let{components:e,...n}=t;return(0,s.kt)(B8t,(0,p.Z)({},S8t,n,{components:e,mdxType:"MDXLayout"}))}G8t.isMDXComponent=!0;const E8t={toc:[]},O8t="wrapper";function F8t(t){let{components:e,...n}=t;return(0,s.kt)(O8t,(0,p.Z)({},E8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}F8t.isMDXComponent=!0;const U8t={toc:[]},V8t="wrapper";function q8t(t){let{components:e,...n}=t;return(0,s.kt)(V8t,(0,p.Z)({},U8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}q8t.isMDXComponent=!0;const j8t={toc:[]},Y8t="wrapper";function Q8t(t){let{components:e,...n}=t;return(0,s.kt)(Y8t,(0,p.Z)({},j8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Q8t.isMDXComponent=!0;const H8t={toc:[]},K8t="wrapper";function $8t(t){let{components:e,...n}=t;return(0,s.kt)(K8t,(0,p.Z)({},H8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}$8t.isMDXComponent=!0;const J8t={toc:[]},t5t="wrapper";function e5t(t){let{components:e,...n}=t;return(0,s.kt)(t5t,(0,p.Z)({},J8t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}e5t.isMDXComponent=!0;const n5t={toc:[]},o5t="wrapper";function p5t(t){let{components:e,...n}=t;return(0,s.kt)(o5t,(0,p.Z)({},n5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}p5t.isMDXComponent=!0;const r5t={toc:[]},s5t="wrapper";function c5t(t){let{components:e,...n}=t;return(0,s.kt)(s5t,(0,p.Z)({},r5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}c5t.isMDXComponent=!0;const a5t={toc:[]},i5t="wrapper";function l5t(t){let{components:e,...n}=t;return(0,s.kt)(i5t,(0,p.Z)({},a5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}l5t.isMDXComponent=!0;const u5t={toc:[]},m5t="wrapper";function d5t(t){let{components:e,...n}=t;return(0,s.kt)(m5t,(0,p.Z)({},u5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}d5t.isMDXComponent=!0;const h5t={toc:[]},f5t="wrapper";function k5t(t){let{components:e,...n}=t;return(0,s.kt)(f5t,(0,p.Z)({},h5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}k5t.isMDXComponent=!0;const y5t={toc:[]},D5t="wrapper";function M5t(t){let{components:e,...n}=t;return(0,s.kt)(D5t,(0,p.Z)({},y5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}M5t.isMDXComponent=!0;const X5t={toc:[]},_5t="wrapper";function w5t(t){let{components:e,...n}=t;return(0,s.kt)(_5t,(0,p.Z)({},X5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}w5t.isMDXComponent=!0;const T5t={toc:[]},C5t="wrapper";function x5t(t){let{components:e,...n}=t;return(0,s.kt)(C5t,(0,p.Z)({},T5t,n,{components:e,mdxType:"MDXLayout"}))}x5t.isMDXComponent=!0;const g5t={toc:[]},v5t="wrapper";function L5t(t){let{components:e,...n}=t;return(0,s.kt)(v5t,(0,p.Z)({},g5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}L5t.isMDXComponent=!0;const Z5t={toc:[]},b5t="wrapper";function N5t(t){let{components:e,...n}=t;return(0,s.kt)(b5t,(0,p.Z)({},Z5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}N5t.isMDXComponent=!0;const z5t={toc:[]},A5t="wrapper";function P5t(t){let{components:e,...n}=t;return(0,s.kt)(A5t,(0,p.Z)({},z5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}P5t.isMDXComponent=!0;const W5t={toc:[]},R5t="wrapper";function I5t(t){let{components:e,...n}=t;return(0,s.kt)(R5t,(0,p.Z)({},W5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}I5t.isMDXComponent=!0;const S5t={toc:[]},B5t="wrapper";function G5t(t){let{components:e,...n}=t;return(0,s.kt)(B5t,(0,p.Z)({},S5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}G5t.isMDXComponent=!0;const E5t={toc:[]},O5t="wrapper";function F5t(t){let{components:e,...n}=t;return(0,s.kt)(O5t,(0,p.Z)({},E5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}F5t.isMDXComponent=!0;const U5t={toc:[]},V5t="wrapper";function q5t(t){let{components:e,...n}=t;return(0,s.kt)(V5t,(0,p.Z)({},U5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}q5t.isMDXComponent=!0;const j5t={toc:[]},Y5t="wrapper";function Q5t(t){let{components:e,...n}=t;return(0,s.kt)(Y5t,(0,p.Z)({},j5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Q5t.isMDXComponent=!0;const H5t={toc:[]},K5t="wrapper";function $5t(t){let{components:e,...n}=t;return(0,s.kt)(K5t,(0,p.Z)({},H5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}$5t.isMDXComponent=!0;const J5t={toc:[]},t9t="wrapper";function e9t(t){let{components:e,...n}=t;return(0,s.kt)(t9t,(0,p.Z)({},J5t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}e9t.isMDXComponent=!0;const n9t={toc:[]},o9t="wrapper";function p9t(t){let{components:e,...n}=t;return(0,s.kt)(o9t,(0,p.Z)({},n9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}p9t.isMDXComponent=!0;const r9t={toc:[]},s9t="wrapper";function c9t(t){let{components:e,...n}=t;return(0,s.kt)(s9t,(0,p.Z)({},r9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}c9t.isMDXComponent=!0;const a9t={toc:[]},i9t="wrapper";function l9t(t){let{components:e,...n}=t;return(0,s.kt)(i9t,(0,p.Z)({},a9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}l9t.isMDXComponent=!0;const u9t={toc:[]},m9t="wrapper";function d9t(t){let{components:e,...n}=t;return(0,s.kt)(m9t,(0,p.Z)({},u9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}d9t.isMDXComponent=!0;const h9t={toc:[]},f9t="wrapper";function k9t(t){let{components:e,...n}=t;return(0,s.kt)(f9t,(0,p.Z)({},h9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}k9t.isMDXComponent=!0;const y9t={toc:[]},D9t="wrapper";function M9t(t){let{components:e,...n}=t;return(0,s.kt)(D9t,(0,p.Z)({},y9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}M9t.isMDXComponent=!0;const X9t={toc:[]},_9t="wrapper";function w9t(t){let{components:e,...n}=t;return(0,s.kt)(_9t,(0,p.Z)({},X9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}w9t.isMDXComponent=!0;const T9t={toc:[]},C9t="wrapper";function x9t(t){let{components:e,...n}=t;return(0,s.kt)(C9t,(0,p.Z)({},T9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}x9t.isMDXComponent=!0;const g9t={toc:[]},v9t="wrapper";function L9t(t){let{components:e,...n}=t;return(0,s.kt)(v9t,(0,p.Z)({},g9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}L9t.isMDXComponent=!0;const Z9t={toc:[]},b9t="wrapper";function N9t(t){let{components:e,...n}=t;return(0,s.kt)(b9t,(0,p.Z)({},Z9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}N9t.isMDXComponent=!0;const z9t={toc:[]},A9t="wrapper";function P9t(t){let{components:e,...n}=t;return(0,s.kt)(A9t,(0,p.Z)({},z9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}P9t.isMDXComponent=!0;const W9t={toc:[]},R9t="wrapper";function I9t(t){let{components:e,...n}=t;return(0,s.kt)(R9t,(0,p.Z)({},W9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}I9t.isMDXComponent=!0;const S9t={toc:[]},B9t="wrapper";function G9t(t){let{components:e,...n}=t;return(0,s.kt)(B9t,(0,p.Z)({},S9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}G9t.isMDXComponent=!0;const E9t={toc:[]},O9t="wrapper";function F9t(t){let{components:e,...n}=t;return(0,s.kt)(O9t,(0,p.Z)({},E9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}F9t.isMDXComponent=!0;const U9t={toc:[]},V9t="wrapper";function q9t(t){let{components:e,...n}=t;return(0,s.kt)(V9t,(0,p.Z)({},U9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}q9t.isMDXComponent=!0;const j9t={toc:[]},Y9t="wrapper";function Q9t(t){let{components:e,...n}=t;return(0,s.kt)(Y9t,(0,p.Z)({},j9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Q9t.isMDXComponent=!0;const H9t={toc:[]},K9t="wrapper";function $9t(t){let{components:e,...n}=t;return(0,s.kt)(K9t,(0,p.Z)({},H9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}$9t.isMDXComponent=!0;const J9t={toc:[]},tte="wrapper";function ete(t){let{components:e,...n}=t;return(0,s.kt)(tte,(0,p.Z)({},J9t,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}ete.isMDXComponent=!0;const nte={toc:[]},ote="wrapper";function pte(t){let{components:e,...n}=t;return(0,s.kt)(ote,(0,p.Z)({},nte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}pte.isMDXComponent=!0;const rte={toc:[]},ste="wrapper";function cte(t){let{components:e,...n}=t;return(0,s.kt)(ste,(0,p.Z)({},rte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}cte.isMDXComponent=!0;const ate={toc:[]},ite="wrapper";function lte(t){let{components:e,...n}=t;return(0,s.kt)(ite,(0,p.Z)({},ate,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}lte.isMDXComponent=!0;const ute={toc:[]},mte="wrapper";function dte(t){let{components:e,...n}=t;return(0,s.kt)(mte,(0,p.Z)({},ute,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}dte.isMDXComponent=!0;const hte={toc:[]},fte="wrapper";function kte(t){let{components:e,...n}=t;return(0,s.kt)(fte,(0,p.Z)({},hte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}kte.isMDXComponent=!0;const yte={toc:[]},Dte="wrapper";function Mte(t){let{components:e,...n}=t;return(0,s.kt)(Dte,(0,p.Z)({},yte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Mte.isMDXComponent=!0;const Xte={toc:[]},_te="wrapper";function wte(t){let{components:e,...n}=t;return(0,s.kt)(_te,(0,p.Z)({},Xte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}wte.isMDXComponent=!0;const Tte={toc:[]},Cte="wrapper";function xte(t){let{components:e,...n}=t;return(0,s.kt)(Cte,(0,p.Z)({},Tte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}xte.isMDXComponent=!0;const gte={toc:[]},vte="wrapper";function Lte(t){let{components:e,...n}=t;return(0,s.kt)(vte,(0,p.Z)({},gte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Lte.isMDXComponent=!0;const Zte={toc:[]},bte="wrapper";function Nte(t){let{components:e,...n}=t;return(0,s.kt)(bte,(0,p.Z)({},Zte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Nte.isMDXComponent=!0;const zte={toc:[]},Ate="wrapper";function Pte(t){let{components:e,...n}=t;return(0,s.kt)(Ate,(0,p.Z)({},zte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Pte.isMDXComponent=!0;const Wte={toc:[]},Rte="wrapper";function Ite(t){let{components:e,...n}=t;return(0,s.kt)(Rte,(0,p.Z)({},Wte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Ite.isMDXComponent=!0;const Ste={toc:[]},Bte="wrapper";function Gte(t){let{components:e,...n}=t;return(0,s.kt)(Bte,(0,p.Z)({},Ste,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Gte.isMDXComponent=!0;const Ete={toc:[]},Ote="wrapper";function Fte(t){let{components:e,...n}=t;return(0,s.kt)(Ote,(0,p.Z)({},Ete,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Fte.isMDXComponent=!0;const Ute={toc:[]},Vte="wrapper";function qte(t){let{components:e,...n}=t;return(0,s.kt)(Vte,(0,p.Z)({},Ute,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}qte.isMDXComponent=!0;const jte={toc:[]},Yte="wrapper";function Qte(t){let{components:e,...n}=t;return(0,s.kt)(Yte,(0,p.Z)({},jte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Qte.isMDXComponent=!0;const Hte={toc:[]},Kte="wrapper";function $te(t){let{components:e,...n}=t;return(0,s.kt)(Kte,(0,p.Z)({},Hte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}$te.isMDXComponent=!0;const Jte={toc:[]},tee="wrapper";function eee(t){let{components:e,...n}=t;return(0,s.kt)(tee,(0,p.Z)({},Jte,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}eee.isMDXComponent=!0;const nee={toc:[]},oee="wrapper";function pee(t){let{components:e,...n}=t;return(0,s.kt)(oee,(0,p.Z)({},nee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}pee.isMDXComponent=!0;const ree={toc:[]},see="wrapper";function cee(t){let{components:e,...n}=t;return(0,s.kt)(see,(0,p.Z)({},ree,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}cee.isMDXComponent=!0;const aee={toc:[]},iee="wrapper";function lee(t){let{components:e,...n}=t;return(0,s.kt)(iee,(0,p.Z)({},aee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}lee.isMDXComponent=!0;const uee={toc:[]},mee="wrapper";function dee(t){let{components:e,...n}=t;return(0,s.kt)(mee,(0,p.Z)({},uee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}dee.isMDXComponent=!0;const hee={toc:[]},fee="wrapper";function kee(t){let{components:e,...n}=t;return(0,s.kt)(fee,(0,p.Z)({},hee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}kee.isMDXComponent=!0;const yee={toc:[]},Dee="wrapper";function Mee(t){let{components:e,...n}=t;return(0,s.kt)(Dee,(0,p.Z)({},yee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Mee.isMDXComponent=!0;const Xee={toc:[]},_ee="wrapper";function wee(t){let{components:e,...n}=t;return(0,s.kt)(_ee,(0,p.Z)({},Xee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wee.isMDXComponent=!0;const Tee={toc:[]},Cee="wrapper";function xee(t){let{components:e,...n}=t;return(0,s.kt)(Cee,(0,p.Z)({},Tee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}xee.isMDXComponent=!0;const gee={toc:[]},vee="wrapper";function Lee(t){let{components:e,...n}=t;return(0,s.kt)(vee,(0,p.Z)({},gee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Lee.isMDXComponent=!0;const Zee={toc:[]},bee="wrapper";function Nee(t){let{components:e,...n}=t;return(0,s.kt)(bee,(0,p.Z)({},Zee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Nee.isMDXComponent=!0;const zee={toc:[]},Aee="wrapper";function Pee(t){let{components:e,...n}=t;return(0,s.kt)(Aee,(0,p.Z)({},zee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Pee.isMDXComponent=!0;const Wee={toc:[]},Ree="wrapper";function Iee(t){let{components:e,...n}=t;return(0,s.kt)(Ree,(0,p.Z)({},Wee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Iee.isMDXComponent=!0;const See={toc:[]},Bee="wrapper";function Gee(t){let{components:e,...n}=t;return(0,s.kt)(Bee,(0,p.Z)({},See,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Gee.isMDXComponent=!0;const Eee={toc:[]},Oee="wrapper";function Fee(t){let{components:e,...n}=t;return(0,s.kt)(Oee,(0,p.Z)({},Eee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Fee.isMDXComponent=!0;const Uee={toc:[]},Vee="wrapper";function qee(t){let{components:e,...n}=t;return(0,s.kt)(Vee,(0,p.Z)({},Uee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}qee.isMDXComponent=!0;const jee={toc:[]},Yee="wrapper";function Qee(t){let{components:e,...n}=t;return(0,s.kt)(Yee,(0,p.Z)({},jee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Qee.isMDXComponent=!0;const Hee={toc:[]},Kee="wrapper";function $ee(t){let{components:e,...n}=t;return(0,s.kt)(Kee,(0,p.Z)({},Hee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}$ee.isMDXComponent=!0;const Jee={toc:[]},tne="wrapper";function ene(t){let{components:e,...n}=t;return(0,s.kt)(tne,(0,p.Z)({},Jee,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}ene.isMDXComponent=!0;const nne={toc:[]},one="wrapper";function pne(t){let{components:e,...n}=t;return(0,s.kt)(one,(0,p.Z)({},nne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}pne.isMDXComponent=!0;const rne={toc:[]},sne="wrapper";function cne(t){let{components:e,...n}=t;return(0,s.kt)(sne,(0,p.Z)({},rne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cne.isMDXComponent=!0;const ane={toc:[]},ine="wrapper";function lne(t){let{components:e,...n}=t;return(0,s.kt)(ine,(0,p.Z)({},ane,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}lne.isMDXComponent=!0;const une={toc:[]},mne="wrapper";function dne(t){let{components:e,...n}=t;return(0,s.kt)(mne,(0,p.Z)({},une,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dne.isMDXComponent=!0;const hne={toc:[]},fne="wrapper";function kne(t){let{components:e,...n}=t;return(0,s.kt)(fne,(0,p.Z)({},hne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}kne.isMDXComponent=!0;const yne={toc:[]},Dne="wrapper";function Mne(t){let{components:e,...n}=t;return(0,s.kt)(Dne,(0,p.Z)({},yne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Mne.isMDXComponent=!0;const Xne={toc:[]},_ne="wrapper";function wne(t){let{components:e,...n}=t;return(0,s.kt)(_ne,(0,p.Z)({},Xne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}wne.isMDXComponent=!0;const Tne={toc:[]},Cne="wrapper";function xne(t){let{components:e,...n}=t;return(0,s.kt)(Cne,(0,p.Z)({},Tne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}xne.isMDXComponent=!0;const gne={toc:[]},vne="wrapper";function Lne(t){let{components:e,...n}=t;return(0,s.kt)(vne,(0,p.Z)({},gne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Lne.isMDXComponent=!0;const Zne={toc:[]},bne="wrapper";function Nne(t){let{components:e,...n}=t;return(0,s.kt)(bne,(0,p.Z)({},Zne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Nne.isMDXComponent=!0;const zne={toc:[]},Ane="wrapper";function Pne(t){let{components:e,...n}=t;return(0,s.kt)(Ane,(0,p.Z)({},zne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}Pne.isMDXComponent=!0;const Wne={toc:[]},Rne="wrapper";function Ine(t){let{components:e,...n}=t;return(0,s.kt)(Rne,(0,p.Z)({},Wne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}Ine.isMDXComponent=!0;const Sne={toc:[]},Bne="wrapper";function Gne(t){let{components:e,...n}=t;return(0,s.kt)(Bne,(0,p.Z)({},Sne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}Gne.isMDXComponent=!0;const Ene={toc:[]},One="wrapper";function Fne(t){let{components:e,...n}=t;return(0,s.kt)(One,(0,p.Z)({},Ene,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}Fne.isMDXComponent=!0;const Une={toc:[]},Vne="wrapper";function qne(t){let{components:e,...n}=t;return(0,s.kt)(Vne,(0,p.Z)({},Une,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}qne.isMDXComponent=!0;const jne={toc:[]},Yne="wrapper";function Qne(t){let{components:e,...n}=t;return(0,s.kt)(Yne,(0,p.Z)({},jne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Qne.isMDXComponent=!0;const Hne={toc:[]},Kne="wrapper";function $ne(t){let{components:e,...n}=t;return(0,s.kt)(Kne,(0,p.Z)({},Hne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}$ne.isMDXComponent=!0;const Jne={toc:[]},toe="wrapper";function eoe(t){let{components:e,...n}=t;return(0,s.kt)(toe,(0,p.Z)({},Jne,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}eoe.isMDXComponent=!0;const noe={toc:[]},ooe="wrapper";function poe(t){let{components:e,...n}=t;return(0,s.kt)(ooe,(0,p.Z)({},noe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}poe.isMDXComponent=!0;const roe={toc:[]},soe="wrapper";function coe(t){let{components:e,...n}=t;return(0,s.kt)(soe,(0,p.Z)({},roe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}coe.isMDXComponent=!0;const aoe={toc:[]},ioe="wrapper";function loe(t){let{components:e,...n}=t;return(0,s.kt)(ioe,(0,p.Z)({},aoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}loe.isMDXComponent=!0;const uoe={toc:[]},moe="wrapper";function doe(t){let{components:e,...n}=t;return(0,s.kt)(moe,(0,p.Z)({},uoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}doe.isMDXComponent=!0;const hoe={toc:[]},foe="wrapper";function koe(t){let{components:e,...n}=t;return(0,s.kt)(foe,(0,p.Z)({},hoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}koe.isMDXComponent=!0;const yoe={toc:[]},Doe="wrapper";function Moe(t){let{components:e,...n}=t;return(0,s.kt)(Doe,(0,p.Z)({},yoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Moe.isMDXComponent=!0;const Xoe={toc:[]},_oe="wrapper";function woe(t){let{components:e,...n}=t;return(0,s.kt)(_oe,(0,p.Z)({},Xoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}woe.isMDXComponent=!0;const Toe={toc:[]},Coe="wrapper";function xoe(t){let{components:e,...n}=t;return(0,s.kt)(Coe,(0,p.Z)({},Toe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}xoe.isMDXComponent=!0;const goe={toc:[]},voe="wrapper";function Loe(t){let{components:e,...n}=t;return(0,s.kt)(voe,(0,p.Z)({},goe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Loe.isMDXComponent=!0;const Zoe={toc:[]},boe="wrapper";function Noe(t){let{components:e,...n}=t;return(0,s.kt)(boe,(0,p.Z)({},Zoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Noe.isMDXComponent=!0;const zoe={toc:[]},Aoe="wrapper";function Poe(t){let{components:e,...n}=t;return(0,s.kt)(Aoe,(0,p.Z)({},zoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Poe.isMDXComponent=!0;const Woe={toc:[]},Roe="wrapper";function Ioe(t){let{components:e,...n}=t;return(0,s.kt)(Roe,(0,p.Z)({},Woe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Ioe.isMDXComponent=!0;const Soe={toc:[]},Boe="wrapper";function Goe(t){let{components:e,...n}=t;return(0,s.kt)(Boe,(0,p.Z)({},Soe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Goe.isMDXComponent=!0;const Eoe={toc:[]},Ooe="wrapper";function Foe(t){let{components:e,...n}=t;return(0,s.kt)(Ooe,(0,p.Z)({},Eoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Foe.isMDXComponent=!0;const Uoe={toc:[]},Voe="wrapper";function qoe(t){let{components:e,...n}=t;return(0,s.kt)(Voe,(0,p.Z)({},Uoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}qoe.isMDXComponent=!0;const joe={toc:[]},Yoe="wrapper";function Qoe(t){let{components:e,...n}=t;return(0,s.kt)(Yoe,(0,p.Z)({},joe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Qoe.isMDXComponent=!0;const Hoe={toc:[]},Koe="wrapper";function $oe(t){let{components:e,...n}=t;return(0,s.kt)(Koe,(0,p.Z)({},Hoe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}$oe.isMDXComponent=!0;const Joe={toc:[]},tpe="wrapper";function epe(t){let{components:e,...n}=t;return(0,s.kt)(tpe,(0,p.Z)({},Joe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}epe.isMDXComponent=!0;const npe={toc:[]},ope="wrapper";function ppe(t){let{components:e,...n}=t;return(0,s.kt)(ope,(0,p.Z)({},npe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}ppe.isMDXComponent=!0;const rpe={toc:[]},spe="wrapper";function cpe(t){let{components:e,...n}=t;return(0,s.kt)(spe,(0,p.Z)({},rpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}cpe.isMDXComponent=!0;const ape={toc:[]},ipe="wrapper";function lpe(t){let{components:e,...n}=t;return(0,s.kt)(ipe,(0,p.Z)({},ape,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}lpe.isMDXComponent=!0;const upe={toc:[]},mpe="wrapper";function dpe(t){let{components:e,...n}=t;return(0,s.kt)(mpe,(0,p.Z)({},upe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}dpe.isMDXComponent=!0;const hpe={toc:[]},fpe="wrapper";function kpe(t){let{components:e,...n}=t;return(0,s.kt)(fpe,(0,p.Z)({},hpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}kpe.isMDXComponent=!0;const ype={toc:[]},Dpe="wrapper";function Mpe(t){let{components:e,...n}=t;return(0,s.kt)(Dpe,(0,p.Z)({},ype,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Mpe.isMDXComponent=!0;const Xpe={toc:[]},_pe="wrapper";function wpe(t){let{components:e,...n}=t;return(0,s.kt)(_pe,(0,p.Z)({},Xpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}wpe.isMDXComponent=!0;const Tpe={toc:[]},Cpe="wrapper";function xpe(t){let{components:e,...n}=t;return(0,s.kt)(Cpe,(0,p.Z)({},Tpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}xpe.isMDXComponent=!0;const gpe={toc:[]},vpe="wrapper";function Lpe(t){let{components:e,...n}=t;return(0,s.kt)(vpe,(0,p.Z)({},gpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Lpe.isMDXComponent=!0;const Zpe={toc:[]},bpe="wrapper";function Npe(t){let{components:e,...n}=t;return(0,s.kt)(bpe,(0,p.Z)({},Zpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Npe.isMDXComponent=!0;const zpe={toc:[]},Ape="wrapper";function Ppe(t){let{components:e,...n}=t;return(0,s.kt)(Ape,(0,p.Z)({},zpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Ppe.isMDXComponent=!0;const Wpe={toc:[]},Rpe="wrapper";function Ipe(t){let{components:e,...n}=t;return(0,s.kt)(Rpe,(0,p.Z)({},Wpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Ipe.isMDXComponent=!0;const Spe={toc:[]},Bpe="wrapper";function Gpe(t){let{components:e,...n}=t;return(0,s.kt)(Bpe,(0,p.Z)({},Spe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Gpe.isMDXComponent=!0;const Epe={toc:[]},Ope="wrapper";function Fpe(t){let{components:e,...n}=t;return(0,s.kt)(Ope,(0,p.Z)({},Epe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Fpe.isMDXComponent=!0;const Upe={toc:[]},Vpe="wrapper";function qpe(t){let{components:e,...n}=t;return(0,s.kt)(Vpe,(0,p.Z)({},Upe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}qpe.isMDXComponent=!0;const jpe={toc:[]},Ype="wrapper";function Qpe(t){let{components:e,...n}=t;return(0,s.kt)(Ype,(0,p.Z)({},jpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Qpe.isMDXComponent=!0;const Hpe={toc:[]},Kpe="wrapper";function $pe(t){let{components:e,...n}=t;return(0,s.kt)(Kpe,(0,p.Z)({},Hpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}$pe.isMDXComponent=!0;const Jpe={toc:[]},tre="wrapper";function ere(t){let{components:e,...n}=t;return(0,s.kt)(tre,(0,p.Z)({},Jpe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}ere.isMDXComponent=!0;const nre={toc:[]},ore="wrapper";function pre(t){let{components:e,...n}=t;return(0,s.kt)(ore,(0,p.Z)({},nre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}pre.isMDXComponent=!0;const rre={toc:[]},sre="wrapper";function cre(t){let{components:e,...n}=t;return(0,s.kt)(sre,(0,p.Z)({},rre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}cre.isMDXComponent=!0;const are={toc:[]},ire="wrapper";function lre(t){let{components:e,...n}=t;return(0,s.kt)(ire,(0,p.Z)({},are,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}lre.isMDXComponent=!0;const ure={toc:[]},mre="wrapper";function dre(t){let{components:e,...n}=t;return(0,s.kt)(mre,(0,p.Z)({},ure,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}dre.isMDXComponent=!0;const hre={toc:[]},fre="wrapper";function kre(t){let{components:e,...n}=t;return(0,s.kt)(fre,(0,p.Z)({},hre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}kre.isMDXComponent=!0;const yre={toc:[]},Dre="wrapper";function Mre(t){let{components:e,...n}=t;return(0,s.kt)(Dre,(0,p.Z)({},yre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Mre.isMDXComponent=!0;const Xre={toc:[]},_re="wrapper";function wre(t){let{components:e,...n}=t;return(0,s.kt)(_re,(0,p.Z)({},Xre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}wre.isMDXComponent=!0;const Tre={toc:[]},Cre="wrapper";function xre(t){let{components:e,...n}=t;return(0,s.kt)(Cre,(0,p.Z)({},Tre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}xre.isMDXComponent=!0;const gre={toc:[]},vre="wrapper";function Lre(t){let{components:e,...n}=t;return(0,s.kt)(vre,(0,p.Z)({},gre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Lre.isMDXComponent=!0;const Zre={toc:[]},bre="wrapper";function Nre(t){let{components:e,...n}=t;return(0,s.kt)(bre,(0,p.Z)({},Zre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Nre.isMDXComponent=!0;const zre={toc:[]},Are="wrapper";function Pre(t){let{components:e,...n}=t;return(0,s.kt)(Are,(0,p.Z)({},zre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Pre.isMDXComponent=!0;const Wre={toc:[]},Rre="wrapper";function Ire(t){let{components:e,...n}=t;return(0,s.kt)(Rre,(0,p.Z)({},Wre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Ire.isMDXComponent=!0;const Sre={toc:[]},Bre="wrapper";function Gre(t){let{components:e,...n}=t;return(0,s.kt)(Bre,(0,p.Z)({},Sre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Gre.isMDXComponent=!0;const Ere={toc:[]},Ore="wrapper";function Fre(t){let{components:e,...n}=t;return(0,s.kt)(Ore,(0,p.Z)({},Ere,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Fre.isMDXComponent=!0;const Ure={toc:[]},Vre="wrapper";function qre(t){let{components:e,...n}=t;return(0,s.kt)(Vre,(0,p.Z)({},Ure,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}qre.isMDXComponent=!0;const jre={toc:[]},Yre="wrapper";function Qre(t){let{components:e,...n}=t;return(0,s.kt)(Yre,(0,p.Z)({},jre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Qre.isMDXComponent=!0;const Hre={toc:[]},Kre="wrapper";function $re(t){let{components:e,...n}=t;return(0,s.kt)(Kre,(0,p.Z)({},Hre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}$re.isMDXComponent=!0;const Jre={toc:[]},tse="wrapper";function ese(t){let{components:e,...n}=t;return(0,s.kt)(tse,(0,p.Z)({},Jre,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}ese.isMDXComponent=!0;const nse={toc:[]},ose="wrapper";function pse(t){let{components:e,...n}=t;return(0,s.kt)(ose,(0,p.Z)({},nse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pse.isMDXComponent=!0;const rse={toc:[]},sse="wrapper";function cse(t){let{components:e,...n}=t;return(0,s.kt)(sse,(0,p.Z)({},rse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}cse.isMDXComponent=!0;const ase={toc:[]},ise="wrapper";function lse(t){let{components:e,...n}=t;return(0,s.kt)(ise,(0,p.Z)({},ase,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}lse.isMDXComponent=!0;const use={toc:[]},mse="wrapper";function dse(t){let{components:e,...n}=t;return(0,s.kt)(mse,(0,p.Z)({},use,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}dse.isMDXComponent=!0;const hse={toc:[]},fse="wrapper";function kse(t){let{components:e,...n}=t;return(0,s.kt)(fse,(0,p.Z)({},hse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}kse.isMDXComponent=!0;const yse={toc:[]},Dse="wrapper";function Mse(t){let{components:e,...n}=t;return(0,s.kt)(Dse,(0,p.Z)({},yse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Mse.isMDXComponent=!0;const Xse={toc:[]},_se="wrapper";function wse(t){let{components:e,...n}=t;return(0,s.kt)(_se,(0,p.Z)({},Xse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}wse.isMDXComponent=!0;const Tse={toc:[]},Cse="wrapper";function xse(t){let{components:e,...n}=t;return(0,s.kt)(Cse,(0,p.Z)({},Tse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}xse.isMDXComponent=!0;const gse={toc:[]},vse="wrapper";function Lse(t){let{components:e,...n}=t;return(0,s.kt)(vse,(0,p.Z)({},gse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Lse.isMDXComponent=!0;const Zse={toc:[]},bse="wrapper";function Nse(t){let{components:e,...n}=t;return(0,s.kt)(bse,(0,p.Z)({},Zse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Nse.isMDXComponent=!0;const zse={toc:[]},Ase="wrapper";function Pse(t){let{components:e,...n}=t;return(0,s.kt)(Ase,(0,p.Z)({},zse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Pse.isMDXComponent=!0;const Wse={toc:[]},Rse="wrapper";function Ise(t){let{components:e,...n}=t;return(0,s.kt)(Rse,(0,p.Z)({},Wse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Ise.isMDXComponent=!0;const Sse={toc:[]},Bse="wrapper";function Gse(t){let{components:e,...n}=t;return(0,s.kt)(Bse,(0,p.Z)({},Sse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Gse.isMDXComponent=!0;const Ese={toc:[]},Ose="wrapper";function Fse(t){let{components:e,...n}=t;return(0,s.kt)(Ose,(0,p.Z)({},Ese,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Fse.isMDXComponent=!0;const Use={toc:[]},Vse="wrapper";function qse(t){let{components:e,...n}=t;return(0,s.kt)(Vse,(0,p.Z)({},Use,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}qse.isMDXComponent=!0;const jse={toc:[]},Yse="wrapper";function Qse(t){let{components:e,...n}=t;return(0,s.kt)(Yse,(0,p.Z)({},jse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Qse.isMDXComponent=!0;const Hse={toc:[]},Kse="wrapper";function $se(t){let{components:e,...n}=t;return(0,s.kt)(Kse,(0,p.Z)({},Hse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}$se.isMDXComponent=!0;const Jse={toc:[]},tce="wrapper";function ece(t){let{components:e,...n}=t;return(0,s.kt)(tce,(0,p.Z)({},Jse,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}ece.isMDXComponent=!0;const nce={toc:[]},oce="wrapper";function pce(t){let{components:e,...n}=t;return(0,s.kt)(oce,(0,p.Z)({},nce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}pce.isMDXComponent=!0;const rce={toc:[]},sce="wrapper";function cce(t){let{components:e,...n}=t;return(0,s.kt)(sce,(0,p.Z)({},rce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}cce.isMDXComponent=!0;const ace={toc:[]},ice="wrapper";function lce(t){let{components:e,...n}=t;return(0,s.kt)(ice,(0,p.Z)({},ace,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}lce.isMDXComponent=!0;const uce={toc:[]},mce="wrapper";function dce(t){let{components:e,...n}=t;return(0,s.kt)(mce,(0,p.Z)({},uce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}dce.isMDXComponent=!0;const hce={toc:[]},fce="wrapper";function kce(t){let{components:e,...n}=t;return(0,s.kt)(fce,(0,p.Z)({},hce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}kce.isMDXComponent=!0;const yce={toc:[]},Dce="wrapper";function Mce(t){let{components:e,...n}=t;return(0,s.kt)(Dce,(0,p.Z)({},yce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Mce.isMDXComponent=!0;const Xce={toc:[]},_ce="wrapper";function wce(t){let{components:e,...n}=t;return(0,s.kt)(_ce,(0,p.Z)({},Xce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}wce.isMDXComponent=!0;const Tce={toc:[]},Cce="wrapper";function xce(t){let{components:e,...n}=t;return(0,s.kt)(Cce,(0,p.Z)({},Tce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}xce.isMDXComponent=!0;const gce={toc:[]},vce="wrapper";function Lce(t){let{components:e,...n}=t;return(0,s.kt)(vce,(0,p.Z)({},gce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Lce.isMDXComponent=!0;const Zce={toc:[]},bce="wrapper";function Nce(t){let{components:e,...n}=t;return(0,s.kt)(bce,(0,p.Z)({},Zce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Nce.isMDXComponent=!0;const zce={toc:[]},Ace="wrapper";function Pce(t){let{components:e,...n}=t;return(0,s.kt)(Ace,(0,p.Z)({},zce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Pce.isMDXComponent=!0;const Wce={toc:[]},Rce="wrapper";function Ice(t){let{components:e,...n}=t;return(0,s.kt)(Rce,(0,p.Z)({},Wce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Ice.isMDXComponent=!0;const Sce={toc:[]},Bce="wrapper";function Gce(t){let{components:e,...n}=t;return(0,s.kt)(Bce,(0,p.Z)({},Sce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Gce.isMDXComponent=!0;const Ece={toc:[]},Oce="wrapper";function Fce(t){let{components:e,...n}=t;return(0,s.kt)(Oce,(0,p.Z)({},Ece,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Fce.isMDXComponent=!0;const Uce={toc:[]},Vce="wrapper";function qce(t){let{components:e,...n}=t;return(0,s.kt)(Vce,(0,p.Z)({},Uce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}qce.isMDXComponent=!0;const jce={toc:[]},Yce="wrapper";function Qce(t){let{components:e,...n}=t;return(0,s.kt)(Yce,(0,p.Z)({},jce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Qce.isMDXComponent=!0;const Hce={toc:[]},Kce="wrapper";function $ce(t){let{components:e,...n}=t;return(0,s.kt)(Kce,(0,p.Z)({},Hce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}$ce.isMDXComponent=!0;const Jce={toc:[]},tae="wrapper";function eae(t){let{components:e,...n}=t;return(0,s.kt)(tae,(0,p.Z)({},Jce,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}eae.isMDXComponent=!0;const nae={toc:[]},oae="wrapper";function pae(t){let{components:e,...n}=t;return(0,s.kt)(oae,(0,p.Z)({},nae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}pae.isMDXComponent=!0;const rae={toc:[]},sae="wrapper";function cae(t){let{components:e,...n}=t;return(0,s.kt)(sae,(0,p.Z)({},rae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}cae.isMDXComponent=!0;const aae={toc:[]},iae="wrapper";function lae(t){let{components:e,...n}=t;return(0,s.kt)(iae,(0,p.Z)({},aae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node representing a knot of a ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline"},(0,s.kt)("inlineCode",{parentName:"a"},"Spline")),"."))}lae.isMDXComponent=!0;const uae={toc:[]},mae="wrapper";function dae(t){let{components:e,...n}=t;return(0,s.kt)(mae,(0,p.Z)({},uae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}dae.isMDXComponent=!0;const hae={toc:[]},fae="wrapper";function kae(t){let{components:e,...n}=t;return(0,s.kt)(fae,(0,p.Z)({},hae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}kae.isMDXComponent=!0;const yae={toc:[]},Dae="wrapper";function Mae(t){let{components:e,...n}=t;return(0,s.kt)(Dae,(0,p.Z)({},yae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Mae.isMDXComponent=!0;const Xae={toc:[]},_ae="wrapper";function wae(t){let{components:e,...n}=t;return(0,s.kt)(_ae,(0,p.Z)({},Xae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}wae.isMDXComponent=!0;const Tae={toc:[]},Cae="wrapper";function xae(t){let{components:e,...n}=t;return(0,s.kt)(Cae,(0,p.Z)({},Tae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}xae.isMDXComponent=!0;const gae={toc:[]},vae="wrapper";function Lae(t){let{components:e,...n}=t;return(0,s.kt)(vae,(0,p.Z)({},gae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Lae.isMDXComponent=!0;const Zae={toc:[]},bae="wrapper";function Nae(t){let{components:e,...n}=t;return(0,s.kt)(bae,(0,p.Z)({},Zae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}Nae.isMDXComponent=!0;const zae={toc:[]},Aae="wrapper";function Pae(t){let{components:e,...n}=t;return(0,s.kt)(Aae,(0,p.Z)({},zae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0"))}Pae.isMDXComponent=!0;const Wae={toc:[]},Rae="wrapper";function Iae(t){let{components:e,...n}=t;return(0,s.kt)(Rae,(0,p.Z)({},Wae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}Iae.isMDXComponent=!0;const Sae={toc:[]},Bae="wrapper";function Gae(t){let{components:e,...n}=t;return(0,s.kt)(Bae,(0,p.Z)({},Sae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Gae.isMDXComponent=!0;const Eae={toc:[]},Oae="wrapper";function Fae(t){let{components:e,...n}=t;return(0,s.kt)(Oae,(0,p.Z)({},Eae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Fae.isMDXComponent=!0;const Uae={toc:[]},Vae="wrapper";function qae(t){let{components:e,...n}=t;return(0,s.kt)(Vae,(0,p.Z)({},Uae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}qae.isMDXComponent=!0;const jae={toc:[]},Yae="wrapper";function Qae(t){let{components:e,...n}=t;return(0,s.kt)(Yae,(0,p.Z)({},jae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the startHandle."))}Qae.isMDXComponent=!0;const Hae={toc:[]},Kae="wrapper";function $ae(t){let{components:e,...n}=t;return(0,s.kt)(Kae,(0,p.Z)({},Hae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}$ae.isMDXComponent=!0;const Jae={toc:[]},tie="wrapper";function eie(t){let{components:e,...n}=t;return(0,s.kt)(tie,(0,p.Z)({},Jae,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}eie.isMDXComponent=!0;const nie={toc:[]},oie="wrapper";function pie(t){let{components:e,...n}=t;return(0,s.kt)(oie,(0,p.Z)({},nie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}pie.isMDXComponent=!0;const rie={toc:[]},sie="wrapper";function cie(t){let{components:e,...n}=t;return(0,s.kt)(sie,(0,p.Z)({},rie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}cie.isMDXComponent=!0;const aie={toc:[]},iie="wrapper";function lie(t){let{components:e,...n}=t;return(0,s.kt)(iie,(0,p.Z)({},aie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}lie.isMDXComponent=!0;const uie={toc:[]},mie="wrapper";function die(t){let{components:e,...n}=t;return(0,s.kt)(mie,(0,p.Z)({},uie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}die.isMDXComponent=!0;const hie={toc:[]},fie="wrapper";function kie(t){let{components:e,...n}=t;return(0,s.kt)(fie,(0,p.Z)({},hie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}kie.isMDXComponent=!0;const yie={toc:[]},Die="wrapper";function Mie(t){let{components:e,...n}=t;return(0,s.kt)(Die,(0,p.Z)({},yie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Mie.isMDXComponent=!0;const Xie={toc:[]},_ie="wrapper";function wie(t){let{components:e,...n}=t;return(0,s.kt)(_ie,(0,p.Z)({},Xie,n,{components:e,mdxType:"MDXLayout"}))}wie.isMDXComponent=!0;const Tie={toc:[]},Cie="wrapper";function xie(t){let{components:e,...n}=t;return(0,s.kt)(Cie,(0,p.Z)({},Tie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}xie.isMDXComponent=!0;const gie={toc:[]},vie="wrapper";function Lie(t){let{components:e,...n}=t;return(0,s.kt)(vie,(0,p.Z)({},gie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Lie.isMDXComponent=!0;const Zie={toc:[]},bie="wrapper";function Nie(t){let{components:e,...n}=t;return(0,s.kt)(bie,(0,p.Z)({},Zie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Nie.isMDXComponent=!0;const zie={toc:[]},Aie="wrapper";function Pie(t){let{components:e,...n}=t;return(0,s.kt)(Aie,(0,p.Z)({},zie,n,{components:e,mdxType:"MDXLayout"}))}Pie.isMDXComponent=!0;const Wie={toc:[]},Rie="wrapper";function Iie(t){let{components:e,...n}=t;return(0,s.kt)(Rie,(0,p.Z)({},Wie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Iie.isMDXComponent=!0;const Sie={toc:[]},Bie="wrapper";function Gie(t){let{components:e,...n}=t;return(0,s.kt)(Bie,(0,p.Z)({},Sie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mirrored position of the endHandle."))}Gie.isMDXComponent=!0;const Eie={toc:[]},Oie="wrapper";function Fie(t){let{components:e,...n}=t;return(0,s.kt)(Oie,(0,p.Z)({},Eie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}Fie.isMDXComponent=!0;const Uie={toc:[]},Vie="wrapper";function qie(t){let{components:e,...n}=t;return(0,s.kt)(Vie,(0,p.Z)({},Uie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}qie.isMDXComponent=!0;const jie={toc:[]},Yie="wrapper";function Qie(t){let{components:e,...n}=t;return(0,s.kt)(Yie,(0,p.Z)({},jie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Qie.isMDXComponent=!0;const Hie={toc:[]},Kie="wrapper";function $ie(t){let{components:e,...n}=t;return(0,s.kt)(Kie,(0,p.Z)({},Hie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}$ie.isMDXComponent=!0;const Jie={toc:[]},tle="wrapper";function ele(t){let{components:e,...n}=t;return(0,s.kt)(tle,(0,p.Z)({},Jie,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}ele.isMDXComponent=!0;const nle={toc:[]},ole="wrapper";function ple(t){let{components:e,...n}=t;return(0,s.kt)(ole,(0,p.Z)({},nle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}ple.isMDXComponent=!0;const rle={toc:[]},sle="wrapper";function cle(t){let{components:e,...n}=t;return(0,s.kt)(sle,(0,p.Z)({},rle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}cle.isMDXComponent=!0;const ale={toc:[]},ile="wrapper";function lle(t){let{components:e,...n}=t;return(0,s.kt)(ile,(0,p.Z)({},ale,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}lle.isMDXComponent=!0;const ule={toc:[]},mle="wrapper";function dle(t){let{components:e,...n}=t;return(0,s.kt)(mle,(0,p.Z)({},ule,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}dle.isMDXComponent=!0;const hle={toc:[]},fle="wrapper";function kle(t){let{components:e,...n}=t;return(0,s.kt)(fle,(0,p.Z)({},hle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}kle.isMDXComponent=!0;const yle={toc:[]},Dle="wrapper";function Mle(t){let{components:e,...n}=t;return(0,s.kt)(Dle,(0,p.Z)({},yle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Mle.isMDXComponent=!0;const Xle={toc:[]},_le="wrapper";function wle(t){let{components:e,...n}=t;return(0,s.kt)(_le,(0,p.Z)({},Xle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}wle.isMDXComponent=!0;const Tle={toc:[]},Cle="wrapper";function xle(t){let{components:e,...n}=t;return(0,s.kt)(Cle,(0,p.Z)({},Tle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}xle.isMDXComponent=!0;const gle={toc:[]},vle="wrapper";function Lle(t){let{components:e,...n}=t;return(0,s.kt)(vle,(0,p.Z)({},gle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Lle.isMDXComponent=!0;const Zle={toc:[]},ble="wrapper";function Nle(t){let{components:e,...n}=t;return(0,s.kt)(ble,(0,p.Z)({},Zle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Nle.isMDXComponent=!0;const zle={toc:[]},Ale="wrapper";function Ple(t){let{components:e,...n}=t;return(0,s.kt)(Ale,(0,p.Z)({},zle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Ple.isMDXComponent=!0;const Wle={toc:[]},Rle="wrapper";function Ile(t){let{components:e,...n}=t;return(0,s.kt)(Rle,(0,p.Z)({},Wle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Ile.isMDXComponent=!0;const Sle={toc:[]},Ble="wrapper";function Gle(t){let{components:e,...n}=t;return(0,s.kt)(Ble,(0,p.Z)({},Sle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Gle.isMDXComponent=!0;const Ele={toc:[]},Ole="wrapper";function Fle(t){let{components:e,...n}=t;return(0,s.kt)(Ole,(0,p.Z)({},Ele,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Fle.isMDXComponent=!0;const Ule={toc:[]},Vle="wrapper";function qle(t){let{components:e,...n}=t;return(0,s.kt)(Vle,(0,p.Z)({},Ule,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}qle.isMDXComponent=!0;const jle={toc:[]},Yle="wrapper";function Qle(t){let{components:e,...n}=t;return(0,s.kt)(Yle,(0,p.Z)({},jle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Qle.isMDXComponent=!0;const Hle={toc:[]},Kle="wrapper";function $le(t){let{components:e,...n}=t;return(0,s.kt)(Kle,(0,p.Z)({},Hle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}$le.isMDXComponent=!0;const Jle={toc:[]},tue="wrapper";function eue(t){let{components:e,...n}=t;return(0,s.kt)(tue,(0,p.Z)({},Jle,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}eue.isMDXComponent=!0;const nue={toc:[]},oue="wrapper";function pue(t){let{components:e,...n}=t;return(0,s.kt)(oue,(0,p.Z)({},nue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pue.isMDXComponent=!0;const rue={toc:[]},sue="wrapper";function cue(t){let{components:e,...n}=t;return(0,s.kt)(sue,(0,p.Z)({},rue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}cue.isMDXComponent=!0;const aue={toc:[]},iue="wrapper";function lue(t){let{components:e,...n}=t;return(0,s.kt)(iue,(0,p.Z)({},aue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lue.isMDXComponent=!0;const uue={toc:[]},mue="wrapper";function due(t){let{components:e,...n}=t;return(0,s.kt)(mue,(0,p.Z)({},uue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}due.isMDXComponent=!0;const hue={toc:[]},fue="wrapper";function kue(t){let{components:e,...n}=t;return(0,s.kt)(fue,(0,p.Z)({},hue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}kue.isMDXComponent=!0;const yue={toc:[]},Due="wrapper";function Mue(t){let{components:e,...n}=t;return(0,s.kt)(Due,(0,p.Z)({},yue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Mue.isMDXComponent=!0;const Xue={toc:[]},_ue="wrapper";function wue(t){let{components:e,...n}=t;return(0,s.kt)(_ue,(0,p.Z)({},Xue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}wue.isMDXComponent=!0;const Tue={toc:[]},Cue="wrapper";function xue(t){let{components:e,...n}=t;return(0,s.kt)(Cue,(0,p.Z)({},Tue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}xue.isMDXComponent=!0;const gue={toc:[]},vue="wrapper";function Lue(t){let{components:e,...n}=t;return(0,s.kt)(vue,(0,p.Z)({},gue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lue.isMDXComponent=!0;const Zue={toc:[]},bue="wrapper";function Nue(t){let{components:e,...n}=t;return(0,s.kt)(bue,(0,p.Z)({},Zue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Nue.isMDXComponent=!0;const zue={toc:[]},Aue="wrapper";function Pue(t){let{components:e,...n}=t;return(0,s.kt)(Aue,(0,p.Z)({},zue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Pue.isMDXComponent=!0;const Wue={toc:[]},Rue="wrapper";function Iue(t){let{components:e,...n}=t;return(0,s.kt)(Rue,(0,p.Z)({},Wue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Iue.isMDXComponent=!0;const Sue={toc:[]},Bue="wrapper";function Gue(t){let{components:e,...n}=t;return(0,s.kt)(Bue,(0,p.Z)({},Sue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Gue.isMDXComponent=!0;const Eue={toc:[]},Oue="wrapper";function Fue(t){let{components:e,...n}=t;return(0,s.kt)(Oue,(0,p.Z)({},Eue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Fue.isMDXComponent=!0;const Uue={toc:[]},Vue="wrapper";function que(t){let{components:e,...n}=t;return(0,s.kt)(Vue,(0,p.Z)({},Uue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}que.isMDXComponent=!0;const jue={toc:[]},Yue="wrapper";function Que(t){let{components:e,...n}=t;return(0,s.kt)(Yue,(0,p.Z)({},jue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Que.isMDXComponent=!0;const Hue={toc:[]},Kue="wrapper";function $ue(t){let{components:e,...n}=t;return(0,s.kt)(Kue,(0,p.Z)({},Hue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}$ue.isMDXComponent=!0;const Jue={toc:[]},tme="wrapper";function eme(t){let{components:e,...n}=t;return(0,s.kt)(tme,(0,p.Z)({},Jue,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}eme.isMDXComponent=!0;const nme={toc:[]},ome="wrapper";function pme(t){let{components:e,...n}=t;return(0,s.kt)(ome,(0,p.Z)({},nme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pme.isMDXComponent=!0;const rme={toc:[]},sme="wrapper";function cme(t){let{components:e,...n}=t;return(0,s.kt)(sme,(0,p.Z)({},rme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}cme.isMDXComponent=!0;const ame={toc:[]},ime="wrapper";function lme(t){let{components:e,...n}=t;return(0,s.kt)(ime,(0,p.Z)({},ame,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lme.isMDXComponent=!0;const ume={toc:[]},mme="wrapper";function dme(t){let{components:e,...n}=t;return(0,s.kt)(mme,(0,p.Z)({},ume,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}dme.isMDXComponent=!0;const hme={toc:[]},fme="wrapper";function kme(t){let{components:e,...n}=t;return(0,s.kt)(fme,(0,p.Z)({},hme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kme.isMDXComponent=!0;const yme={toc:[]},Dme="wrapper";function Mme(t){let{components:e,...n}=t;return(0,s.kt)(Dme,(0,p.Z)({},yme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Mme.isMDXComponent=!0;const Xme={toc:[]},_me="wrapper";function wme(t){let{components:e,...n}=t;return(0,s.kt)(_me,(0,p.Z)({},Xme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}wme.isMDXComponent=!0;const Tme={toc:[]},Cme="wrapper";function xme(t){let{components:e,...n}=t;return(0,s.kt)(Cme,(0,p.Z)({},Tme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}xme.isMDXComponent=!0;const gme={toc:[]},vme="wrapper";function Lme(t){let{components:e,...n}=t;return(0,s.kt)(vme,(0,p.Z)({},gme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Lme.isMDXComponent=!0;const Zme={toc:[]},bme="wrapper";function Nme(t){let{components:e,...n}=t;return(0,s.kt)(bme,(0,p.Z)({},Zme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Nme.isMDXComponent=!0;const zme={toc:[]},Ame="wrapper";function Pme(t){let{components:e,...n}=t;return(0,s.kt)(Ame,(0,p.Z)({},zme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Pme.isMDXComponent=!0;const Wme={toc:[]},Rme="wrapper";function Ime(t){let{components:e,...n}=t;return(0,s.kt)(Rme,(0,p.Z)({},Wme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Ime.isMDXComponent=!0;const Sme={toc:[]},Bme="wrapper";function Gme(t){let{components:e,...n}=t;return(0,s.kt)(Bme,(0,p.Z)({},Sme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Gme.isMDXComponent=!0;const Eme={toc:[]},Ome="wrapper";function Fme(t){let{components:e,...n}=t;return(0,s.kt)(Ome,(0,p.Z)({},Eme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Fme.isMDXComponent=!0;const Ume={toc:[]},Vme="wrapper";function qme(t){let{components:e,...n}=t;return(0,s.kt)(Vme,(0,p.Z)({},Ume,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}qme.isMDXComponent=!0;const jme={toc:[]},Yme="wrapper";function Qme(t){let{components:e,...n}=t;return(0,s.kt)(Yme,(0,p.Z)({},jme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Qme.isMDXComponent=!0;const Hme={toc:[]},Kme="wrapper";function $me(t){let{components:e,...n}=t;return(0,s.kt)(Kme,(0,p.Z)({},Hme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}$me.isMDXComponent=!0;const Jme={toc:[]},tde="wrapper";function ede(t){let{components:e,...n}=t;return(0,s.kt)(tde,(0,p.Z)({},Jme,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}ede.isMDXComponent=!0;const nde={toc:[]},ode="wrapper";function pde(t){let{components:e,...n}=t;return(0,s.kt)(ode,(0,p.Z)({},nde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}pde.isMDXComponent=!0;const rde={toc:[]},sde="wrapper";function cde(t){let{components:e,...n}=t;return(0,s.kt)(sde,(0,p.Z)({},rde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}cde.isMDXComponent=!0;const ade={toc:[]},ide="wrapper";function lde(t){let{components:e,...n}=t;return(0,s.kt)(ide,(0,p.Z)({},ade,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}lde.isMDXComponent=!0;const ude={toc:[]},mde="wrapper";function dde(t){let{components:e,...n}=t;return(0,s.kt)(mde,(0,p.Z)({},ude,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}dde.isMDXComponent=!0;const hde={toc:[]},fde="wrapper";function kde(t){let{components:e,...n}=t;return(0,s.kt)(fde,(0,p.Z)({},hde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}kde.isMDXComponent=!0;const yde={toc:[]},Dde="wrapper";function Mde(t){let{components:e,...n}=t;return(0,s.kt)(Dde,(0,p.Z)({},yde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Mde.isMDXComponent=!0;const Xde={toc:[]},_de="wrapper";function wde(t){let{components:e,...n}=t;return(0,s.kt)(_de,(0,p.Z)({},Xde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}wde.isMDXComponent=!0;const Tde={toc:[]},Cde="wrapper";function xde(t){let{components:e,...n}=t;return(0,s.kt)(Cde,(0,p.Z)({},Tde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}xde.isMDXComponent=!0;const gde={toc:[]},vde="wrapper";function Lde(t){let{components:e,...n}=t;return(0,s.kt)(vde,(0,p.Z)({},gde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Lde.isMDXComponent=!0;const Zde={toc:[]},bde="wrapper";function Nde(t){let{components:e,...n}=t;return(0,s.kt)(bde,(0,p.Z)({},Zde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Nde.isMDXComponent=!0;const zde={toc:[]},Ade="wrapper";function Pde(t){let{components:e,...n}=t;return(0,s.kt)(Ade,(0,p.Z)({},zde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Pde.isMDXComponent=!0;const Wde={toc:[]},Rde="wrapper";function Ide(t){let{components:e,...n}=t;return(0,s.kt)(Rde,(0,p.Z)({},Wde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Ide.isMDXComponent=!0;const Sde={toc:[]},Bde="wrapper";function Gde(t){let{components:e,...n}=t;return(0,s.kt)(Bde,(0,p.Z)({},Sde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Gde.isMDXComponent=!0;const Ede={toc:[]},Ode="wrapper";function Fde(t){let{components:e,...n}=t;return(0,s.kt)(Ode,(0,p.Z)({},Ede,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Fde.isMDXComponent=!0;const Ude={toc:[]},Vde="wrapper";function qde(t){let{components:e,...n}=t;return(0,s.kt)(Vde,(0,p.Z)({},Ude,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}qde.isMDXComponent=!0;const jde={toc:[]},Yde="wrapper";function Qde(t){let{components:e,...n}=t;return(0,s.kt)(Yde,(0,p.Z)({},jde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Qde.isMDXComponent=!0;const Hde={toc:[]},Kde="wrapper";function $de(t){let{components:e,...n}=t;return(0,s.kt)(Kde,(0,p.Z)({},Hde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}$de.isMDXComponent=!0;const Jde={toc:[]},the="wrapper";function ehe(t){let{components:e,...n}=t;return(0,s.kt)(the,(0,p.Z)({},Jde,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}ehe.isMDXComponent=!0;const nhe={toc:[]},ohe="wrapper";function phe(t){let{components:e,...n}=t;return(0,s.kt)(ohe,(0,p.Z)({},nhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}phe.isMDXComponent=!0;const rhe={toc:[]},she="wrapper";function che(t){let{components:e,...n}=t;return(0,s.kt)(she,(0,p.Z)({},rhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}che.isMDXComponent=!0;const ahe={toc:[]},ihe="wrapper";function lhe(t){let{components:e,...n}=t;return(0,s.kt)(ihe,(0,p.Z)({},ahe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}lhe.isMDXComponent=!0;const uhe={toc:[]},mhe="wrapper";function dhe(t){let{components:e,...n}=t;return(0,s.kt)(mhe,(0,p.Z)({},uhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}dhe.isMDXComponent=!0;const hhe={toc:[]},fhe="wrapper";function khe(t){let{components:e,...n}=t;return(0,s.kt)(fhe,(0,p.Z)({},hhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}khe.isMDXComponent=!0;const yhe={toc:[]},Dhe="wrapper";function Mhe(t){let{components:e,...n}=t;return(0,s.kt)(Dhe,(0,p.Z)({},yhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Mhe.isMDXComponent=!0;const Xhe={toc:[]},_he="wrapper";function whe(t){let{components:e,...n}=t;return(0,s.kt)(_he,(0,p.Z)({},Xhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}whe.isMDXComponent=!0;const The={toc:[]},Che="wrapper";function xhe(t){let{components:e,...n}=t;return(0,s.kt)(Che,(0,p.Z)({},The,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}xhe.isMDXComponent=!0;const ghe={toc:[]},vhe="wrapper";function Lhe(t){let{components:e,...n}=t;return(0,s.kt)(vhe,(0,p.Z)({},ghe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Lhe.isMDXComponent=!0;const Zhe={toc:[]},bhe="wrapper";function Nhe(t){let{components:e,...n}=t;return(0,s.kt)(bhe,(0,p.Z)({},Zhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Nhe.isMDXComponent=!0;const zhe={toc:[]},Ahe="wrapper";function Phe(t){let{components:e,...n}=t;return(0,s.kt)(Ahe,(0,p.Z)({},zhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Phe.isMDXComponent=!0;const Whe={toc:[]},Rhe="wrapper";function Ihe(t){let{components:e,...n}=t;return(0,s.kt)(Rhe,(0,p.Z)({},Whe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Ihe.isMDXComponent=!0;const She={toc:[]},Bhe="wrapper";function Ghe(t){let{components:e,...n}=t;return(0,s.kt)(Bhe,(0,p.Z)({},She,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Ghe.isMDXComponent=!0;const Ehe={toc:[]},Ohe="wrapper";function Fhe(t){let{components:e,...n}=t;return(0,s.kt)(Ohe,(0,p.Z)({},Ehe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Fhe.isMDXComponent=!0;const Uhe={toc:[]},Vhe="wrapper";function qhe(t){let{components:e,...n}=t;return(0,s.kt)(Vhe,(0,p.Z)({},Uhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}qhe.isMDXComponent=!0;const jhe={toc:[]},Yhe="wrapper";function Qhe(t){let{components:e,...n}=t;return(0,s.kt)(Yhe,(0,p.Z)({},jhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Qhe.isMDXComponent=!0;const Hhe={toc:[]},Khe="wrapper";function $he(t){let{components:e,...n}=t;return(0,s.kt)(Khe,(0,p.Z)({},Hhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}$he.isMDXComponent=!0;const Jhe={toc:[]},tfe="wrapper";function efe(t){let{components:e,...n}=t;return(0,s.kt)(tfe,(0,p.Z)({},Jhe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}efe.isMDXComponent=!0;const nfe={toc:[]},ofe="wrapper";function pfe(t){let{components:e,...n}=t;return(0,s.kt)(ofe,(0,p.Z)({},nfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}pfe.isMDXComponent=!0;const rfe={toc:[]},sfe="wrapper";function cfe(t){let{components:e,...n}=t;return(0,s.kt)(sfe,(0,p.Z)({},rfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}cfe.isMDXComponent=!0;const afe={toc:[]},ife="wrapper";function lfe(t){let{components:e,...n}=t;return(0,s.kt)(ife,(0,p.Z)({},afe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}lfe.isMDXComponent=!0;const ufe={toc:[]},mfe="wrapper";function dfe(t){let{components:e,...n}=t;return(0,s.kt)(mfe,(0,p.Z)({},ufe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}dfe.isMDXComponent=!0;const hfe={toc:[]},ffe="wrapper";function kfe(t){let{components:e,...n}=t;return(0,s.kt)(ffe,(0,p.Z)({},hfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}kfe.isMDXComponent=!0;const yfe={toc:[]},Dfe="wrapper";function Mfe(t){let{components:e,...n}=t;return(0,s.kt)(Dfe,(0,p.Z)({},yfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Mfe.isMDXComponent=!0;const Xfe={toc:[]},_fe="wrapper";function wfe(t){let{components:e,...n}=t;return(0,s.kt)(_fe,(0,p.Z)({},Xfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}wfe.isMDXComponent=!0;const Tfe={toc:[]},Cfe="wrapper";function xfe(t){let{components:e,...n}=t;return(0,s.kt)(Cfe,(0,p.Z)({},Tfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}xfe.isMDXComponent=!0;const gfe={toc:[]},vfe="wrapper";function Lfe(t){let{components:e,...n}=t;return(0,s.kt)(vfe,(0,p.Z)({},gfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Lfe.isMDXComponent=!0;const Zfe={toc:[]},bfe="wrapper";function Nfe(t){let{components:e,...n}=t;return(0,s.kt)(bfe,(0,p.Z)({},Zfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Nfe.isMDXComponent=!0;const zfe={toc:[]},Afe="wrapper";function Pfe(t){let{components:e,...n}=t;return(0,s.kt)(Afe,(0,p.Z)({},zfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Pfe.isMDXComponent=!0;const Wfe={toc:[]},Rfe="wrapper";function Ife(t){let{components:e,...n}=t;return(0,s.kt)(Rfe,(0,p.Z)({},Wfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Ife.isMDXComponent=!0;const Sfe={toc:[]},Bfe="wrapper";function Gfe(t){let{components:e,...n}=t;return(0,s.kt)(Bfe,(0,p.Z)({},Sfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}Gfe.isMDXComponent=!0;const Efe={toc:[]},Ofe="wrapper";function Ffe(t){let{components:e,...n}=t;return(0,s.kt)(Ofe,(0,p.Z)({},Efe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Ffe.isMDXComponent=!0;const Ufe={toc:[]},Vfe="wrapper";function qfe(t){let{components:e,...n}=t;return(0,s.kt)(Vfe,(0,p.Z)({},Ufe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}qfe.isMDXComponent=!0;const jfe={toc:[]},Yfe="wrapper";function Qfe(t){let{components:e,...n}=t;return(0,s.kt)(Yfe,(0,p.Z)({},jfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Qfe.isMDXComponent=!0;const Hfe={toc:[]},Kfe="wrapper";function $fe(t){let{components:e,...n}=t;return(0,s.kt)(Kfe,(0,p.Z)({},Hfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}$fe.isMDXComponent=!0;const Jfe={toc:[]},tke="wrapper";function eke(t){let{components:e,...n}=t;return(0,s.kt)(tke,(0,p.Z)({},Jfe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}eke.isMDXComponent=!0;const nke={toc:[]},oke="wrapper";function pke(t){let{components:e,...n}=t;return(0,s.kt)(oke,(0,p.Z)({},nke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}pke.isMDXComponent=!0;const rke={toc:[]},ske="wrapper";function cke(t){let{components:e,...n}=t;return(0,s.kt)(ske,(0,p.Z)({},rke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}cke.isMDXComponent=!0;const ake={toc:[]},ike="wrapper";function lke(t){let{components:e,...n}=t;return(0,s.kt)(ike,(0,p.Z)({},ake,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}lke.isMDXComponent=!0;const uke={toc:[]},mke="wrapper";function dke(t){let{components:e,...n}=t;return(0,s.kt)(mke,(0,p.Z)({},uke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}dke.isMDXComponent=!0;const hke={toc:[]},fke="wrapper";function kke(t){let{components:e,...n}=t;return(0,s.kt)(fke,(0,p.Z)({},hke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}kke.isMDXComponent=!0;const yke={toc:[]},Dke="wrapper";function Mke(t){let{components:e,...n}=t;return(0,s.kt)(Dke,(0,p.Z)({},yke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Mke.isMDXComponent=!0;const Xke={toc:[]},_ke="wrapper";function wke(t){let{components:e,...n}=t;return(0,s.kt)(_ke,(0,p.Z)({},Xke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wke.isMDXComponent=!0;const Tke={toc:[]},Cke="wrapper";function xke(t){let{components:e,...n}=t;return(0,s.kt)(Cke,(0,p.Z)({},Tke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}xke.isMDXComponent=!0;const gke={toc:[]},vke="wrapper";function Lke(t){let{components:e,...n}=t;return(0,s.kt)(vke,(0,p.Z)({},gke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Lke.isMDXComponent=!0;const Zke={toc:[]},bke="wrapper";function Nke(t){let{components:e,...n}=t;return(0,s.kt)(bke,(0,p.Z)({},Zke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Nke.isMDXComponent=!0;const zke={toc:[]},Ake="wrapper";function Pke(t){let{components:e,...n}=t;return(0,s.kt)(Ake,(0,p.Z)({},zke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Pke.isMDXComponent=!0;const Wke={toc:[]},Rke="wrapper";function Ike(t){let{components:e,...n}=t;return(0,s.kt)(Rke,(0,p.Z)({},Wke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Ike.isMDXComponent=!0;const Ske={toc:[]},Bke="wrapper";function Gke(t){let{components:e,...n}=t;return(0,s.kt)(Bke,(0,p.Z)({},Ske,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Gke.isMDXComponent=!0;const Eke={toc:[]},Oke="wrapper";function Fke(t){let{components:e,...n}=t;return(0,s.kt)(Oke,(0,p.Z)({},Eke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Fke.isMDXComponent=!0;const Uke={toc:[]},Vke="wrapper";function qke(t){let{components:e,...n}=t;return(0,s.kt)(Vke,(0,p.Z)({},Uke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}qke.isMDXComponent=!0;const jke={toc:[]},Yke="wrapper";function Qke(t){let{components:e,...n}=t;return(0,s.kt)(Yke,(0,p.Z)({},jke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Qke.isMDXComponent=!0;const Hke={toc:[]},Kke="wrapper";function $ke(t){let{components:e,...n}=t;return(0,s.kt)(Kke,(0,p.Z)({},Hke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}$ke.isMDXComponent=!0;const Jke={toc:[]},tye="wrapper";function eye(t){let{components:e,...n}=t;return(0,s.kt)(tye,(0,p.Z)({},Jke,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {Latex, makeScene2D} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Latex\n      // Note how this uses \\color to set the color.\n      tex=\"{\\color{white} ax^2+bx+c=0 \\implies x=\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}}\"\n      width={600} // height and width can calculate based on each other\n    />,\n  );\n});\n")))}eye.isMDXComponent=!0;const nye={toc:[]},oye="wrapper";function pye(t){let{components:e,...n}=t;return(0,s.kt)(oye,(0,p.Z)({},nye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for rendering equations with LaTeX."))}pye.isMDXComponent=!0;const rye={toc:[]},sye="wrapper";function cye(t){let{components:e,...n}=t;return(0,s.kt)(sye,(0,p.Z)({},rye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}cye.isMDXComponent=!0;const aye={toc:[]},iye="wrapper";function lye(t){let{components:e,...n}=t;return(0,s.kt)(iye,(0,p.Z)({},aye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}lye.isMDXComponent=!0;const uye={toc:[]},mye="wrapper";function dye(t){let{components:e,...n}=t;return(0,s.kt)(mye,(0,p.Z)({},uye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}dye.isMDXComponent=!0;const hye={toc:[]},fye="wrapper";function kye(t){let{components:e,...n}=t;return(0,s.kt)(fye,(0,p.Z)({},hye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}kye.isMDXComponent=!0;const yye={toc:[]},Dye="wrapper";function Mye(t){let{components:e,...n}=t;return(0,s.kt)(Dye,(0,p.Z)({},yye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Mye.isMDXComponent=!0;const Xye={toc:[]},_ye="wrapper";function wye(t){let{components:e,...n}=t;return(0,s.kt)(_ye,(0,p.Z)({},Xye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}wye.isMDXComponent=!0;const Tye={toc:[]},Cye="wrapper";function xye(t){let{components:e,...n}=t;return(0,s.kt)(Cye,(0,p.Z)({},Tye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}xye.isMDXComponent=!0;const gye={toc:[]},vye="wrapper";function Lye(t){let{components:e,...n}=t;return(0,s.kt)(vye,(0,p.Z)({},gye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Lye.isMDXComponent=!0;const Zye={toc:[]},bye="wrapper";function Nye(t){let{components:e,...n}=t;return(0,s.kt)(bye,(0,p.Z)({},Zye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Nye.isMDXComponent=!0;const zye={toc:[]},Aye="wrapper";function Pye(t){let{components:e,...n}=t;return(0,s.kt)(Aye,(0,p.Z)({},zye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Pye.isMDXComponent=!0;const Wye={toc:[]},Rye="wrapper";function Iye(t){let{components:e,...n}=t;return(0,s.kt)(Rye,(0,p.Z)({},Wye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Iye.isMDXComponent=!0;const Sye={toc:[]},Bye="wrapper";function Gye(t){let{components:e,...n}=t;return(0,s.kt)(Bye,(0,p.Z)({},Sye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Gye.isMDXComponent=!0;const Eye={toc:[]},Oye="wrapper";function Fye(t){let{components:e,...n}=t;return(0,s.kt)(Oye,(0,p.Z)({},Eye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Fye.isMDXComponent=!0;const Uye={toc:[]},Vye="wrapper";function qye(t){let{components:e,...n}=t;return(0,s.kt)(Vye,(0,p.Z)({},Uye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}qye.isMDXComponent=!0;const jye={toc:[]},Yye="wrapper";function Qye(t){let{components:e,...n}=t;return(0,s.kt)(Yye,(0,p.Z)({},jye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Qye.isMDXComponent=!0;const Hye={toc:[]},Kye="wrapper";function $ye(t){let{components:e,...n}=t;return(0,s.kt)(Kye,(0,p.Z)({},Hye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}$ye.isMDXComponent=!0;const Jye={toc:[]},tDe="wrapper";function eDe(t){let{components:e,...n}=t;return(0,s.kt)(tDe,(0,p.Z)({},Jye,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}eDe.isMDXComponent=!0;const nDe={toc:[]},oDe="wrapper";function pDe(t){let{components:e,...n}=t;return(0,s.kt)(oDe,(0,p.Z)({},nDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}pDe.isMDXComponent=!0;const rDe={toc:[]},sDe="wrapper";function cDe(t){let{components:e,...n}=t;return(0,s.kt)(sDe,(0,p.Z)({},rDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}cDe.isMDXComponent=!0;const aDe={toc:[]},iDe="wrapper";function lDe(t){let{components:e,...n}=t;return(0,s.kt)(iDe,(0,p.Z)({},aDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}lDe.isMDXComponent=!0;const uDe={toc:[]},mDe="wrapper";function dDe(t){let{components:e,...n}=t;return(0,s.kt)(mDe,(0,p.Z)({},uDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}dDe.isMDXComponent=!0;const hDe={toc:[]},fDe="wrapper";function kDe(t){let{components:e,...n}=t;return(0,s.kt)(fDe,(0,p.Z)({},hDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}kDe.isMDXComponent=!0;const yDe={toc:[]},DDe="wrapper";function MDe(t){let{components:e,...n}=t;return(0,s.kt)(DDe,(0,p.Z)({},yDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}MDe.isMDXComponent=!0;const XDe={toc:[]},_De="wrapper";function wDe(t){let{components:e,...n}=t;return(0,s.kt)(_De,(0,p.Z)({},XDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wDe.isMDXComponent=!0;const TDe={toc:[]},CDe="wrapper";function xDe(t){let{components:e,...n}=t;return(0,s.kt)(CDe,(0,p.Z)({},TDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}xDe.isMDXComponent=!0;const gDe={toc:[]},vDe="wrapper";function LDe(t){let{components:e,...n}=t;return(0,s.kt)(vDe,(0,p.Z)({},gDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}LDe.isMDXComponent=!0;const ZDe={toc:[]},bDe="wrapper";function NDe(t){let{components:e,...n}=t;return(0,s.kt)(bDe,(0,p.Z)({},ZDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}NDe.isMDXComponent=!0;const zDe={toc:[]},ADe="wrapper";function PDe(t){let{components:e,...n}=t;return(0,s.kt)(ADe,(0,p.Z)({},zDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}PDe.isMDXComponent=!0;const WDe={toc:[]},RDe="wrapper";function IDe(t){let{components:e,...n}=t;return(0,s.kt)(RDe,(0,p.Z)({},WDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}IDe.isMDXComponent=!0;const SDe={toc:[]},BDe="wrapper";function GDe(t){let{components:e,...n}=t;return(0,s.kt)(BDe,(0,p.Z)({},SDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}GDe.isMDXComponent=!0;const EDe={toc:[]},ODe="wrapper";function FDe(t){let{components:e,...n}=t;return(0,s.kt)(ODe,(0,p.Z)({},EDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}FDe.isMDXComponent=!0;const UDe={toc:[]},VDe="wrapper";function qDe(t){let{components:e,...n}=t;return(0,s.kt)(VDe,(0,p.Z)({},UDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}qDe.isMDXComponent=!0;const jDe={toc:[]},YDe="wrapper";function QDe(t){let{components:e,...n}=t;return(0,s.kt)(YDe,(0,p.Z)({},jDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}QDe.isMDXComponent=!0;const HDe={toc:[]},KDe="wrapper";function $De(t){let{components:e,...n}=t;return(0,s.kt)(KDe,(0,p.Z)({},HDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}$De.isMDXComponent=!0;const JDe={toc:[]},tMe="wrapper";function eMe(t){let{components:e,...n}=t;return(0,s.kt)(tMe,(0,p.Z)({},JDe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}eMe.isMDXComponent=!0;const nMe={toc:[]},oMe="wrapper";function pMe(t){let{components:e,...n}=t;return(0,s.kt)(oMe,(0,p.Z)({},nMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}pMe.isMDXComponent=!0;const rMe={toc:[]},sMe="wrapper";function cMe(t){let{components:e,...n}=t;return(0,s.kt)(sMe,(0,p.Z)({},rMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}cMe.isMDXComponent=!0;const aMe={toc:[]},iMe="wrapper";function lMe(t){let{components:e,...n}=t;return(0,s.kt)(iMe,(0,p.Z)({},aMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lMe.isMDXComponent=!0;const uMe={toc:[]},mMe="wrapper";function dMe(t){let{components:e,...n}=t;return(0,s.kt)(mMe,(0,p.Z)({},uMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}dMe.isMDXComponent=!0;const hMe={toc:[]},fMe="wrapper";function kMe(t){let{components:e,...n}=t;return(0,s.kt)(fMe,(0,p.Z)({},hMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}kMe.isMDXComponent=!0;const yMe={toc:[]},DMe="wrapper";function MMe(t){let{components:e,...n}=t;return(0,s.kt)(DMe,(0,p.Z)({},yMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}MMe.isMDXComponent=!0;const XMe={toc:[]},_Me="wrapper";function wMe(t){let{components:e,...n}=t;return(0,s.kt)(_Me,(0,p.Z)({},XMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}wMe.isMDXComponent=!0;const TMe={toc:[]},CMe="wrapper";function xMe(t){let{components:e,...n}=t;return(0,s.kt)(CMe,(0,p.Z)({},TMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}xMe.isMDXComponent=!0;const gMe={toc:[]},vMe="wrapper";function LMe(t){let{components:e,...n}=t;return(0,s.kt)(vMe,(0,p.Z)({},gMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}LMe.isMDXComponent=!0;const ZMe={toc:[]},bMe="wrapper";function NMe(t){let{components:e,...n}=t;return(0,s.kt)(bMe,(0,p.Z)({},ZMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}NMe.isMDXComponent=!0;const zMe={toc:[]},AMe="wrapper";function PMe(t){let{components:e,...n}=t;return(0,s.kt)(AMe,(0,p.Z)({},zMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}PMe.isMDXComponent=!0;const WMe={toc:[]},RMe="wrapper";function IMe(t){let{components:e,...n}=t;return(0,s.kt)(RMe,(0,p.Z)({},WMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}IMe.isMDXComponent=!0;const SMe={toc:[]},BMe="wrapper";function GMe(t){let{components:e,...n}=t;return(0,s.kt)(BMe,(0,p.Z)({},SMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}GMe.isMDXComponent=!0;const EMe={toc:[]},OMe="wrapper";function FMe(t){let{components:e,...n}=t;return(0,s.kt)(OMe,(0,p.Z)({},EMe,n,{components:e,mdxType:"MDXLayout"}))}FMe.isMDXComponent=!0;const UMe={toc:[]},VMe="wrapper";function qMe(t){let{components:e,...n}=t;return(0,s.kt)(VMe,(0,p.Z)({},UMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}qMe.isMDXComponent=!0;const jMe={toc:[]},YMe="wrapper";function QMe(t){let{components:e,...n}=t;return(0,s.kt)(YMe,(0,p.Z)({},jMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}QMe.isMDXComponent=!0;const HMe={toc:[]},KMe="wrapper";function $Me(t){let{components:e,...n}=t;return(0,s.kt)(KMe,(0,p.Z)({},HMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}$Me.isMDXComponent=!0;const JMe={toc:[]},tXe="wrapper";function eXe(t){let{components:e,...n}=t;return(0,s.kt)(tXe,(0,p.Z)({},JMe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}eXe.isMDXComponent=!0;const nXe={toc:[]},oXe="wrapper";function pXe(t){let{components:e,...n}=t;return(0,s.kt)(oXe,(0,p.Z)({},nXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}pXe.isMDXComponent=!0;const rXe={toc:[]},sXe="wrapper";function cXe(t){let{components:e,...n}=t;return(0,s.kt)(sXe,(0,p.Z)({},rXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}cXe.isMDXComponent=!0;const aXe={toc:[]},iXe="wrapper";function lXe(t){let{components:e,...n}=t;return(0,s.kt)(iXe,(0,p.Z)({},aXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}lXe.isMDXComponent=!0;const uXe={toc:[]},mXe="wrapper";function dXe(t){let{components:e,...n}=t;return(0,s.kt)(mXe,(0,p.Z)({},uXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}dXe.isMDXComponent=!0;const hXe={toc:[]},fXe="wrapper";function kXe(t){let{components:e,...n}=t;return(0,s.kt)(fXe,(0,p.Z)({},hXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}kXe.isMDXComponent=!0;const yXe={toc:[]},DXe="wrapper";function MXe(t){let{components:e,...n}=t;return(0,s.kt)(DXe,(0,p.Z)({},yXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}MXe.isMDXComponent=!0;const XXe={toc:[]},_Xe="wrapper";function wXe(t){let{components:e,...n}=t;return(0,s.kt)(_Xe,(0,p.Z)({},XXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}wXe.isMDXComponent=!0;const TXe={toc:[]},CXe="wrapper";function xXe(t){let{components:e,...n}=t;return(0,s.kt)(CXe,(0,p.Z)({},TXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}xXe.isMDXComponent=!0;const gXe={toc:[]},vXe="wrapper";function LXe(t){let{components:e,...n}=t;return(0,s.kt)(vXe,(0,p.Z)({},gXe,n,{components:e,mdxType:"MDXLayout"}))}LXe.isMDXComponent=!0;const ZXe={toc:[]},bXe="wrapper";function NXe(t){let{components:e,...n}=t;return(0,s.kt)(bXe,(0,p.Z)({},ZXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local image:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import image from './example.png';\n// ...\nview.add(<Img src={image} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Img src="https://example.com/image.png" />)\n')))}NXe.isMDXComponent=!0;const zXe={toc:[]},AXe="wrapper";function PXe(t){let{components:e,...n}=t;return(0,s.kt)(AXe,(0,p.Z)({},zXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}PXe.isMDXComponent=!0;const WXe={toc:[]},RXe="wrapper";function IXe(t){let{components:e,...n}=t;return(0,s.kt)(RXe,(0,p.Z)({},WXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}IXe.isMDXComponent=!0;const SXe={toc:[]},BXe="wrapper";function GXe(t){let{components:e,...n}=t;return(0,s.kt)(BXe,(0,p.Z)({},SXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}GXe.isMDXComponent=!0;const EXe={toc:[]},OXe="wrapper";function FXe(t){let{components:e,...n}=t;return(0,s.kt)(OXe,(0,p.Z)({},EXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}FXe.isMDXComponent=!0;const UXe={toc:[]},VXe="wrapper";function qXe(t){let{components:e,...n}=t;return(0,s.kt)(VXe,(0,p.Z)({},UXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}qXe.isMDXComponent=!0;const jXe={toc:[]},YXe="wrapper";function QXe(t){let{components:e,...n}=t;return(0,s.kt)(YXe,(0,p.Z)({},jXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}QXe.isMDXComponent=!0;const HXe={toc:[]},KXe="wrapper";function $Xe(t){let{components:e,...n}=t;return(0,s.kt)(KXe,(0,p.Z)({},HXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}$Xe.isMDXComponent=!0;const JXe={toc:[]},t_e="wrapper";function e_e(t){let{components:e,...n}=t;return(0,s.kt)(t_e,(0,p.Z)({},JXe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}e_e.isMDXComponent=!0;const n_e={toc:[]},o_e="wrapper";function p_e(t){let{components:e,...n}=t;return(0,s.kt)(o_e,(0,p.Z)({},n_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}p_e.isMDXComponent=!0;const r_e={toc:[]},s_e="wrapper";function c_e(t){let{components:e,...n}=t;return(0,s.kt)(s_e,(0,p.Z)({},r_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}c_e.isMDXComponent=!0;const a_e={toc:[]},i_e="wrapper";function l_e(t){let{components:e,...n}=t;return(0,s.kt)(i_e,(0,p.Z)({},a_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}l_e.isMDXComponent=!0;const u_e={toc:[]},m_e="wrapper";function d_e(t){let{components:e,...n}=t;return(0,s.kt)(m_e,(0,p.Z)({},u_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}d_e.isMDXComponent=!0;const h_e={toc:[]},f_e="wrapper";function k_e(t){let{components:e,...n}=t;return(0,s.kt)(f_e,(0,p.Z)({},h_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}k_e.isMDXComponent=!0;const y_e={toc:[]},D_e="wrapper";function M_e(t){let{components:e,...n}=t;return(0,s.kt)(D_e,(0,p.Z)({},y_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}M_e.isMDXComponent=!0;const X_e={toc:[]},__e="wrapper";function w_e(t){let{components:e,...n}=t;return(0,s.kt)(__e,(0,p.Z)({},X_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}w_e.isMDXComponent=!0;const T_e={toc:[]},C_e="wrapper";function x_e(t){let{components:e,...n}=t;return(0,s.kt)(C_e,(0,p.Z)({},T_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}x_e.isMDXComponent=!0;const g_e={toc:[]},v_e="wrapper";function L_e(t){let{components:e,...n}=t;return(0,s.kt)(v_e,(0,p.Z)({},g_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}L_e.isMDXComponent=!0;const Z_e={toc:[]},b_e="wrapper";function N_e(t){let{components:e,...n}=t;return(0,s.kt)(b_e,(0,p.Z)({},Z_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}N_e.isMDXComponent=!0;const z_e={toc:[]},A_e="wrapper";function P_e(t){let{components:e,...n}=t;return(0,s.kt)(A_e,(0,p.Z)({},z_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}P_e.isMDXComponent=!0;const W_e={toc:[]},R_e="wrapper";function I_e(t){let{components:e,...n}=t;return(0,s.kt)(R_e,(0,p.Z)({},W_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}I_e.isMDXComponent=!0;const S_e={toc:[]},B_e="wrapper";function G_e(t){let{components:e,...n}=t;return(0,s.kt)(B_e,(0,p.Z)({},S_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}G_e.isMDXComponent=!0;const E_e={toc:[]},O_e="wrapper";function F_e(t){let{components:e,...n}=t;return(0,s.kt)(O_e,(0,p.Z)({},E_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}F_e.isMDXComponent=!0;const U_e={toc:[]},V_e="wrapper";function q_e(t){let{components:e,...n}=t;return(0,s.kt)(V_e,(0,p.Z)({},U_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}q_e.isMDXComponent=!0;const j_e={toc:[]},Y_e="wrapper";function Q_e(t){let{components:e,...n}=t;return(0,s.kt)(Y_e,(0,p.Z)({},j_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Q_e.isMDXComponent=!0;const H_e={toc:[]},K_e="wrapper";function $_e(t){let{components:e,...n}=t;return(0,s.kt)(K_e,(0,p.Z)({},H_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}$_e.isMDXComponent=!0;const J_e={toc:[]},twe="wrapper";function ewe(t){let{components:e,...n}=t;return(0,s.kt)(twe,(0,p.Z)({},J_e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}ewe.isMDXComponent=!0;const nwe={toc:[]},owe="wrapper";function pwe(t){let{components:e,...n}=t;return(0,s.kt)(owe,(0,p.Z)({},nwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}pwe.isMDXComponent=!0;const rwe={toc:[]},swe="wrapper";function cwe(t){let{components:e,...n}=t;return(0,s.kt)(swe,(0,p.Z)({},rwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}cwe.isMDXComponent=!0;const awe={toc:[]},iwe="wrapper";function lwe(t){let{components:e,...n}=t;return(0,s.kt)(iwe,(0,p.Z)({},awe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lwe.isMDXComponent=!0;const uwe={toc:[]},mwe="wrapper";function dwe(t){let{components:e,...n}=t;return(0,s.kt)(mwe,(0,p.Z)({},uwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}dwe.isMDXComponent=!0;const hwe={toc:[]},fwe="wrapper";function kwe(t){let{components:e,...n}=t;return(0,s.kt)(fwe,(0,p.Z)({},hwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}kwe.isMDXComponent=!0;const ywe={toc:[]},Dwe="wrapper";function Mwe(t){let{components:e,...n}=t;return(0,s.kt)(Dwe,(0,p.Z)({},ywe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Mwe.isMDXComponent=!0;const Xwe={toc:[]},_we="wrapper";function wwe(t){let{components:e,...n}=t;return(0,s.kt)(_we,(0,p.Z)({},Xwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wwe.isMDXComponent=!0;const Twe={toc:[]},Cwe="wrapper";function xwe(t){let{components:e,...n}=t;return(0,s.kt)(Cwe,(0,p.Z)({},Twe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}xwe.isMDXComponent=!0;const gwe={toc:[]},vwe="wrapper";function Lwe(t){let{components:e,...n}=t;return(0,s.kt)(vwe,(0,p.Z)({},gwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Lwe.isMDXComponent=!0;const Zwe={toc:[]},bwe="wrapper";function Nwe(t){let{components:e,...n}=t;return(0,s.kt)(bwe,(0,p.Z)({},Zwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Nwe.isMDXComponent=!0;const zwe={toc:[]},Awe="wrapper";function Pwe(t){let{components:e,...n}=t;return(0,s.kt)(Awe,(0,p.Z)({},zwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Pwe.isMDXComponent=!0;const Wwe={toc:[]},Rwe="wrapper";function Iwe(t){let{components:e,...n}=t;return(0,s.kt)(Rwe,(0,p.Z)({},Wwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Iwe.isMDXComponent=!0;const Swe={toc:[]},Bwe="wrapper";function Gwe(t){let{components:e,...n}=t;return(0,s.kt)(Bwe,(0,p.Z)({},Swe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Gwe.isMDXComponent=!0;const Ewe={toc:[]},Owe="wrapper";function Fwe(t){let{components:e,...n}=t;return(0,s.kt)(Owe,(0,p.Z)({},Ewe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Fwe.isMDXComponent=!0;const Uwe={toc:[]},Vwe="wrapper";function qwe(t){let{components:e,...n}=t;return(0,s.kt)(Vwe,(0,p.Z)({},Uwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}qwe.isMDXComponent=!0;const jwe={toc:[]},Ywe="wrapper";function Qwe(t){let{components:e,...n}=t;return(0,s.kt)(Ywe,(0,p.Z)({},jwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Qwe.isMDXComponent=!0;const Hwe={toc:[]},Kwe="wrapper";function $we(t){let{components:e,...n}=t;return(0,s.kt)(Kwe,(0,p.Z)({},Hwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}$we.isMDXComponent=!0;const Jwe={toc:[]},tTe="wrapper";function eTe(t){let{components:e,...n}=t;return(0,s.kt)(tTe,(0,p.Z)({},Jwe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}eTe.isMDXComponent=!0;const nTe={toc:[]},oTe="wrapper";function pTe(t){let{components:e,...n}=t;return(0,s.kt)(oTe,(0,p.Z)({},nTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}pTe.isMDXComponent=!0;const rTe={toc:[]},sTe="wrapper";function cTe(t){let{components:e,...n}=t;return(0,s.kt)(sTe,(0,p.Z)({},rTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}cTe.isMDXComponent=!0;const aTe={toc:[]},iTe="wrapper";function lTe(t){let{components:e,...n}=t;return(0,s.kt)(iTe,(0,p.Z)({},aTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}lTe.isMDXComponent=!0;const uTe={toc:[]},mTe="wrapper";function dTe(t){let{components:e,...n}=t;return(0,s.kt)(mTe,(0,p.Z)({},uTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}dTe.isMDXComponent=!0;const hTe={toc:[]},fTe="wrapper";function kTe(t){let{components:e,...n}=t;return(0,s.kt)(fTe,(0,p.Z)({},hTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kTe.isMDXComponent=!0;const yTe={toc:[]},DTe="wrapper";function MTe(t){let{components:e,...n}=t;return(0,s.kt)(DTe,(0,p.Z)({},yTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}MTe.isMDXComponent=!0;const XTe={toc:[]},_Te="wrapper";function wTe(t){let{components:e,...n}=t;return(0,s.kt)(_Te,(0,p.Z)({},XTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}wTe.isMDXComponent=!0;const TTe={toc:[]},CTe="wrapper";function xTe(t){let{components:e,...n}=t;return(0,s.kt)(CTe,(0,p.Z)({},TTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}xTe.isMDXComponent=!0;const gTe={toc:[]},vTe="wrapper";function LTe(t){let{components:e,...n}=t;return(0,s.kt)(vTe,(0,p.Z)({},gTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}LTe.isMDXComponent=!0;const ZTe={toc:[]},bTe="wrapper";function NTe(t){let{components:e,...n}=t;return(0,s.kt)(bTe,(0,p.Z)({},ZTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}NTe.isMDXComponent=!0;const zTe={toc:[]},ATe="wrapper";function PTe(t){let{components:e,...n}=t;return(0,s.kt)(ATe,(0,p.Z)({},zTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}PTe.isMDXComponent=!0;const WTe={toc:[]},RTe="wrapper";function ITe(t){let{components:e,...n}=t;return(0,s.kt)(RTe,(0,p.Z)({},WTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}ITe.isMDXComponent=!0;const STe={toc:[]},BTe="wrapper";function GTe(t){let{components:e,...n}=t;return(0,s.kt)(BTe,(0,p.Z)({},STe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}GTe.isMDXComponent=!0;const ETe={toc:[]},OTe="wrapper";function FTe(t){let{components:e,...n}=t;return(0,s.kt)(OTe,(0,p.Z)({},ETe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}FTe.isMDXComponent=!0;const UTe={toc:[]},VTe="wrapper";function qTe(t){let{components:e,...n}=t;return(0,s.kt)(VTe,(0,p.Z)({},UTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qTe.isMDXComponent=!0;const jTe={toc:[]},YTe="wrapper";function QTe(t){let{components:e,...n}=t;return(0,s.kt)(YTe,(0,p.Z)({},jTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}QTe.isMDXComponent=!0;const HTe={toc:[]},KTe="wrapper";function $Te(t){let{components:e,...n}=t;return(0,s.kt)(KTe,(0,p.Z)({},HTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}$Te.isMDXComponent=!0;const JTe={toc:[]},tCe="wrapper";function eCe(t){let{components:e,...n}=t;return(0,s.kt)(tCe,(0,p.Z)({},JTe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}eCe.isMDXComponent=!0;const nCe={toc:[]},oCe="wrapper";function pCe(t){let{components:e,...n}=t;return(0,s.kt)(oCe,(0,p.Z)({},nCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pCe.isMDXComponent=!0;const rCe={toc:[]},sCe="wrapper";function cCe(t){let{components:e,...n}=t;return(0,s.kt)(sCe,(0,p.Z)({},rCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}cCe.isMDXComponent=!0;const aCe={toc:[]},iCe="wrapper";function lCe(t){let{components:e,...n}=t;return(0,s.kt)(iCe,(0,p.Z)({},aCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lCe.isMDXComponent=!0;const uCe={toc:[]},mCe="wrapper";function dCe(t){let{components:e,...n}=t;return(0,s.kt)(mCe,(0,p.Z)({},uCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}dCe.isMDXComponent=!0;const hCe={toc:[]},fCe="wrapper";function kCe(t){let{components:e,...n}=t;return(0,s.kt)(fCe,(0,p.Z)({},hCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kCe.isMDXComponent=!0;const yCe={toc:[]},DCe="wrapper";function MCe(t){let{components:e,...n}=t;return(0,s.kt)(DCe,(0,p.Z)({},yCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}MCe.isMDXComponent=!0;const XCe={toc:[]},_Ce="wrapper";function wCe(t){let{components:e,...n}=t;return(0,s.kt)(_Ce,(0,p.Z)({},XCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wCe.isMDXComponent=!0;const TCe={toc:[]},CCe="wrapper";function xCe(t){let{components:e,...n}=t;return(0,s.kt)(CCe,(0,p.Z)({},TCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}xCe.isMDXComponent=!0;const gCe={toc:[]},vCe="wrapper";function LCe(t){let{components:e,...n}=t;return(0,s.kt)(vCe,(0,p.Z)({},gCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}LCe.isMDXComponent=!0;const ZCe={toc:[]},bCe="wrapper";function NCe(t){let{components:e,...n}=t;return(0,s.kt)(bCe,(0,p.Z)({},ZCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}NCe.isMDXComponent=!0;const zCe={toc:[]},ACe="wrapper";function PCe(t){let{components:e,...n}=t;return(0,s.kt)(ACe,(0,p.Z)({},zCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}PCe.isMDXComponent=!0;const WCe={toc:[]},RCe="wrapper";function ICe(t){let{components:e,...n}=t;return(0,s.kt)(RCe,(0,p.Z)({},WCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given position."))}ICe.isMDXComponent=!0;const SCe={toc:[]},BCe="wrapper";function GCe(t){let{components:e,...n}=t;return(0,s.kt)(BCe,(0,p.Z)({},SCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position in local space at which to sample the color."))}GCe.isMDXComponent=!0;const ECe={toc:[]},OCe="wrapper";function FCe(t){let{components:e,...n}=t;return(0,s.kt)(OCe,(0,p.Z)({},ECe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get color of the image at the given pixel."))}FCe.isMDXComponent=!0;const UCe={toc:[]},VCe="wrapper";function qCe(t){let{components:e,...n}=t;return(0,s.kt)(VCe,(0,p.Z)({},UCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The pixel's position."))}qCe.isMDXComponent=!0;const jCe={toc:[]},YCe="wrapper";function QCe(t){let{components:e,...n}=t;return(0,s.kt)(YCe,(0,p.Z)({},jCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}QCe.isMDXComponent=!0;const HCe={toc:[]},KCe="wrapper";function $Ce(t){let{components:e,...n}=t;return(0,s.kt)(KCe,(0,p.Z)({},HCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}$Ce.isMDXComponent=!0;const JCe={toc:[]},txe="wrapper";function exe(t){let{components:e,...n}=t;return(0,s.kt)(txe,(0,p.Z)({},JCe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}exe.isMDXComponent=!0;const nxe={toc:[]},oxe="wrapper";function pxe(t){let{components:e,...n}=t;return(0,s.kt)(oxe,(0,p.Z)({},nxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}pxe.isMDXComponent=!0;const rxe={toc:[]},sxe="wrapper";function cxe(t){let{components:e,...n}=t;return(0,s.kt)(sxe,(0,p.Z)({},rxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}cxe.isMDXComponent=!0;const axe={toc:[]},ixe="wrapper";function lxe(t){let{components:e,...n}=t;return(0,s.kt)(ixe,(0,p.Z)({},axe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}lxe.isMDXComponent=!0;const uxe={toc:[]},mxe="wrapper";function dxe(t){let{components:e,...n}=t;return(0,s.kt)(mxe,(0,p.Z)({},uxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}dxe.isMDXComponent=!0;const hxe={toc:[]},fxe="wrapper";function kxe(t){let{components:e,...n}=t;return(0,s.kt)(fxe,(0,p.Z)({},hxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}kxe.isMDXComponent=!0;const yxe={toc:[]},Dxe="wrapper";function Mxe(t){let{components:e,...n}=t;return(0,s.kt)(Dxe,(0,p.Z)({},yxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Mxe.isMDXComponent=!0;const Xxe={toc:[]},_xe="wrapper";function wxe(t){let{components:e,...n}=t;return(0,s.kt)(_xe,(0,p.Z)({},Xxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}wxe.isMDXComponent=!0;const Txe={toc:[]},Cxe="wrapper";function xxe(t){let{components:e,...n}=t;return(0,s.kt)(Cxe,(0,p.Z)({},Txe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}xxe.isMDXComponent=!0;const gxe={toc:[]},vxe="wrapper";function Lxe(t){let{components:e,...n}=t;return(0,s.kt)(vxe,(0,p.Z)({},gxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Lxe.isMDXComponent=!0;const Zxe={toc:[]},bxe="wrapper";function Nxe(t){let{components:e,...n}=t;return(0,s.kt)(bxe,(0,p.Z)({},Zxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Nxe.isMDXComponent=!0;const zxe={toc:[]},Axe="wrapper";function Pxe(t){let{components:e,...n}=t;return(0,s.kt)(Axe,(0,p.Z)({},zxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Pxe.isMDXComponent=!0;const Wxe={toc:[]},Rxe="wrapper";function Ixe(t){let{components:e,...n}=t;return(0,s.kt)(Rxe,(0,p.Z)({},Wxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Ixe.isMDXComponent=!0;const Sxe={toc:[]},Bxe="wrapper";function Gxe(t){let{components:e,...n}=t;return(0,s.kt)(Bxe,(0,p.Z)({},Sxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Gxe.isMDXComponent=!0;const Exe={toc:[]},Oxe="wrapper";function Fxe(t){let{components:e,...n}=t;return(0,s.kt)(Oxe,(0,p.Z)({},Exe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Fxe.isMDXComponent=!0;const Uxe={toc:[]},Vxe="wrapper";function qxe(t){let{components:e,...n}=t;return(0,s.kt)(Vxe,(0,p.Z)({},Uxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}qxe.isMDXComponent=!0;const jxe={toc:[]},Yxe="wrapper";function Qxe(t){let{components:e,...n}=t;return(0,s.kt)(Yxe,(0,p.Z)({},jxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Qxe.isMDXComponent=!0;const Hxe={toc:[]},Kxe="wrapper";function $xe(t){let{components:e,...n}=t;return(0,s.kt)(Kxe,(0,p.Z)({},Hxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}$xe.isMDXComponent=!0;const Jxe={toc:[]},tge="wrapper";function ege(t){let{components:e,...n}=t;return(0,s.kt)(tge,(0,p.Z)({},Jxe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}ege.isMDXComponent=!0;const nge={toc:[]},oge="wrapper";function pge(t){let{components:e,...n}=t;return(0,s.kt)(oge,(0,p.Z)({},nge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}pge.isMDXComponent=!0;const rge={toc:[]},sge="wrapper";function cge(t){let{components:e,...n}=t;return(0,s.kt)(sge,(0,p.Z)({},rge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}cge.isMDXComponent=!0;const age={toc:[]},ige="wrapper";function lge(t){let{components:e,...n}=t;return(0,s.kt)(ige,(0,p.Z)({},age,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}lge.isMDXComponent=!0;const uge={toc:[]},mge="wrapper";function dge(t){let{components:e,...n}=t;return(0,s.kt)(mge,(0,p.Z)({},uge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}dge.isMDXComponent=!0;const hge={toc:[]},fge="wrapper";function kge(t){let{components:e,...n}=t;return(0,s.kt)(fge,(0,p.Z)({},hge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}kge.isMDXComponent=!0;const yge={toc:[]},Dge="wrapper";function Mge(t){let{components:e,...n}=t;return(0,s.kt)(Dge,(0,p.Z)({},yge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Mge.isMDXComponent=!0;const Xge={toc:[]},_ge="wrapper";function wge(t){let{components:e,...n}=t;return(0,s.kt)(_ge,(0,p.Z)({},Xge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}wge.isMDXComponent=!0;const Tge={toc:[]},Cge="wrapper";function xge(t){let{components:e,...n}=t;return(0,s.kt)(Cge,(0,p.Z)({},Tge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}xge.isMDXComponent=!0;const gge={toc:[]},vge="wrapper";function Lge(t){let{components:e,...n}=t;return(0,s.kt)(vge,(0,p.Z)({},gge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Lge.isMDXComponent=!0;const Zge={toc:[]},bge="wrapper";function Nge(t){let{components:e,...n}=t;return(0,s.kt)(bge,(0,p.Z)({},Zge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Nge.isMDXComponent=!0;const zge={toc:[]},Age="wrapper";function Pge(t){let{components:e,...n}=t;return(0,s.kt)(Age,(0,p.Z)({},zge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Pge.isMDXComponent=!0;const Wge={toc:[]},Rge="wrapper";function Ige(t){let{components:e,...n}=t;return(0,s.kt)(Rge,(0,p.Z)({},Wge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Ige.isMDXComponent=!0;const Sge={toc:[]},Bge="wrapper";function Gge(t){let{components:e,...n}=t;return(0,s.kt)(Bge,(0,p.Z)({},Sge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Gge.isMDXComponent=!0;const Ege={toc:[]},Oge="wrapper";function Fge(t){let{components:e,...n}=t;return(0,s.kt)(Oge,(0,p.Z)({},Ege,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Fge.isMDXComponent=!0;const Uge={toc:[]},Vge="wrapper";function qge(t){let{components:e,...n}=t;return(0,s.kt)(Vge,(0,p.Z)({},Uge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}qge.isMDXComponent=!0;const jge={toc:[]},Yge="wrapper";function Qge(t){let{components:e,...n}=t;return(0,s.kt)(Yge,(0,p.Z)({},jge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Qge.isMDXComponent=!0;const Hge={toc:[]},Kge="wrapper";function $ge(t){let{components:e,...n}=t;return(0,s.kt)(Kge,(0,p.Z)({},Hge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}$ge.isMDXComponent=!0;const Jge={toc:[]},tve="wrapper";function eve(t){let{components:e,...n}=t;return(0,s.kt)(tve,(0,p.Z)({},Jge,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}eve.isMDXComponent=!0;const nve={toc:[]},ove="wrapper";function pve(t){let{components:e,...n}=t;return(0,s.kt)(ove,(0,p.Z)({},nve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}pve.isMDXComponent=!0;const rve={toc:[]},sve="wrapper";function cve(t){let{components:e,...n}=t;return(0,s.kt)(sve,(0,p.Z)({},rve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}cve.isMDXComponent=!0;const ave={toc:[]},ive="wrapper";function lve(t){let{components:e,...n}=t;return(0,s.kt)(ive,(0,p.Z)({},ave,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size is the size of the source image unaffected by the size\nand scale properties."))}lve.isMDXComponent=!0;const uve={toc:[]},mve="wrapper";function dve(t){let{components:e,...n}=t;return(0,s.kt)(mve,(0,p.Z)({},uve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The natural size of this image."))}dve.isMDXComponent=!0;const hve={toc:[]},fve="wrapper";function kve(t){let{components:e,...n}=t;return(0,s.kt)(fve,(0,p.Z)({},hve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}kve.isMDXComponent=!0;const yve={toc:[]},Dve="wrapper";function Mve(t){let{components:e,...n}=t;return(0,s.kt)(Dve,(0,p.Z)({},yve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Mve.isMDXComponent=!0;const Xve={toc:[]},_ve="wrapper";function wve(t){let{components:e,...n}=t;return(0,s.kt)(_ve,(0,p.Z)({},Xve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}wve.isMDXComponent=!0;const Tve={toc:[]},Cve="wrapper";function xve(t){let{components:e,...n}=t;return(0,s.kt)(Cve,(0,p.Z)({},Tve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}xve.isMDXComponent=!0;const gve={toc:[]},vve="wrapper";function Lve(t){let{components:e,...n}=t;return(0,s.kt)(vve,(0,p.Z)({},gve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Lve.isMDXComponent=!0;const Zve={toc:[]},bve="wrapper";function Nve(t){let{components:e,...n}=t;return(0,s.kt)(bve,(0,p.Z)({},Zve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Nve.isMDXComponent=!0;const zve={toc:[]},Ave="wrapper";function Pve(t){let{components:e,...n}=t;return(0,s.kt)(Ave,(0,p.Z)({},zve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Pve.isMDXComponent=!0;const Wve={toc:[]},Rve="wrapper";function Ive(t){let{components:e,...n}=t;return(0,s.kt)(Rve,(0,p.Z)({},Wve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Ive.isMDXComponent=!0;const Sve={toc:[]},Bve="wrapper";function Gve(t){let{components:e,...n}=t;return(0,s.kt)(Bve,(0,p.Z)({},Sve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Gve.isMDXComponent=!0;const Eve={toc:[]},Ove="wrapper";function Fve(t){let{components:e,...n}=t;return(0,s.kt)(Ove,(0,p.Z)({},Eve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Fve.isMDXComponent=!0;const Uve={toc:[]},Vve="wrapper";function qve(t){let{components:e,...n}=t;return(0,s.kt)(Vve,(0,p.Z)({},Uve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qve.isMDXComponent=!0;const jve={toc:[]},Yve="wrapper";function Qve(t){let{components:e,...n}=t;return(0,s.kt)(Yve,(0,p.Z)({},jve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Qve.isMDXComponent=!0;const Hve={toc:[]},Kve="wrapper";function $ve(t){let{components:e,...n}=t;return(0,s.kt)(Kve,(0,p.Z)({},Hve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}$ve.isMDXComponent=!0;const Jve={toc:[]},tLe="wrapper";function eLe(t){let{components:e,...n}=t;return(0,s.kt)(tLe,(0,p.Z)({},Jve,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}eLe.isMDXComponent=!0;const nLe={toc:[]},oLe="wrapper";function pLe(t){let{components:e,...n}=t;return(0,s.kt)(oLe,(0,p.Z)({},nLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}pLe.isMDXComponent=!0;const rLe={toc:[]},sLe="wrapper";function cLe(t){let{components:e,...n}=t;return(0,s.kt)(sLe,(0,p.Z)({},rLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cLe.isMDXComponent=!0;const aLe={toc:[]},iLe="wrapper";function lLe(t){let{components:e,...n}=t;return(0,s.kt)(iLe,(0,p.Z)({},aLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lLe.isMDXComponent=!0;const uLe={toc:[]},mLe="wrapper";function dLe(t){let{components:e,...n}=t;return(0,s.kt)(mLe,(0,p.Z)({},uLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}dLe.isMDXComponent=!0;const hLe={toc:[]},fLe="wrapper";function kLe(t){let{components:e,...n}=t;return(0,s.kt)(fLe,(0,p.Z)({},hLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}kLe.isMDXComponent=!0;const yLe={toc:[]},DLe="wrapper";function MLe(t){let{components:e,...n}=t;return(0,s.kt)(DLe,(0,p.Z)({},yLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}MLe.isMDXComponent=!0;const XLe={toc:[]},_Le="wrapper";function wLe(t){let{components:e,...n}=t;return(0,s.kt)(_Le,(0,p.Z)({},XLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}wLe.isMDXComponent=!0;const TLe={toc:[]},CLe="wrapper";function xLe(t){let{components:e,...n}=t;return(0,s.kt)(CLe,(0,p.Z)({},TLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}xLe.isMDXComponent=!0;const gLe={toc:[]},vLe="wrapper";function LLe(t){let{components:e,...n}=t;return(0,s.kt)(vLe,(0,p.Z)({},gLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}LLe.isMDXComponent=!0;const ZLe={toc:[]},bLe="wrapper";function NLe(t){let{components:e,...n}=t;return(0,s.kt)(bLe,(0,p.Z)({},ZLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}NLe.isMDXComponent=!0;const zLe={toc:[]},ALe="wrapper";function PLe(t){let{components:e,...n}=t;return(0,s.kt)(ALe,(0,p.Z)({},zLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}PLe.isMDXComponent=!0;const WLe={toc:[]},RLe="wrapper";function ILe(t){let{components:e,...n}=t;return(0,s.kt)(RLe,(0,p.Z)({},WLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}ILe.isMDXComponent=!0;const SLe={toc:[]},BLe="wrapper";function GLe(t){let{components:e,...n}=t;return(0,s.kt)(BLe,(0,p.Z)({},SLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}GLe.isMDXComponent=!0;const ELe={toc:[]},OLe="wrapper";function FLe(t){let{components:e,...n}=t;return(0,s.kt)(OLe,(0,p.Z)({},ELe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}FLe.isMDXComponent=!0;const ULe={toc:[]},VLe="wrapper";function qLe(t){let{components:e,...n}=t;return(0,s.kt)(VLe,(0,p.Z)({},ULe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}qLe.isMDXComponent=!0;const jLe={toc:[]},YLe="wrapper";function QLe(t){let{components:e,...n}=t;return(0,s.kt)(YLe,(0,p.Z)({},jLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}QLe.isMDXComponent=!0;const HLe={toc:[]},KLe="wrapper";function $Le(t){let{components:e,...n}=t;return(0,s.kt)(KLe,(0,p.Z)({},HLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}$Le.isMDXComponent=!0;const JLe={toc:[]},tZe="wrapper";function eZe(t){let{components:e,...n}=t;return(0,s.kt)(tZe,(0,p.Z)({},JLe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}eZe.isMDXComponent=!0;const nZe={toc:[]},oZe="wrapper";function pZe(t){let{components:e,...n}=t;return(0,s.kt)(oZe,(0,p.Z)({},nZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}pZe.isMDXComponent=!0;const rZe={toc:[]},sZe="wrapper";function cZe(t){let{components:e,...n}=t;return(0,s.kt)(sZe,(0,p.Z)({},rZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}cZe.isMDXComponent=!0;const aZe={toc:[]},iZe="wrapper";function lZe(t){let{components:e,...n}=t;return(0,s.kt)(iZe,(0,p.Z)({},aZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}lZe.isMDXComponent=!0;const uZe={toc:[]},mZe="wrapper";function dZe(t){let{components:e,...n}=t;return(0,s.kt)(mZe,(0,p.Z)({},uZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}dZe.isMDXComponent=!0;const hZe={toc:[]},fZe="wrapper";function kZe(t){let{components:e,...n}=t;return(0,s.kt)(fZe,(0,p.Z)({},hZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}kZe.isMDXComponent=!0;const yZe={toc:[]},DZe="wrapper";function MZe(t){let{components:e,...n}=t;return(0,s.kt)(DZe,(0,p.Z)({},yZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}MZe.isMDXComponent=!0;const XZe={toc:[]},_Ze="wrapper";function wZe(t){let{components:e,...n}=t;return(0,s.kt)(_Ze,(0,p.Z)({},XZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}wZe.isMDXComponent=!0;const TZe={toc:[]},CZe="wrapper";function xZe(t){let{components:e,...n}=t;return(0,s.kt)(CZe,(0,p.Z)({},TZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}xZe.isMDXComponent=!0;const gZe={toc:[]},vZe="wrapper";function LZe(t){let{components:e,...n}=t;return(0,s.kt)(vZe,(0,p.Z)({},gZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}LZe.isMDXComponent=!0;const ZZe={toc:[]},bZe="wrapper";function NZe(t){let{components:e,...n}=t;return(0,s.kt)(bZe,(0,p.Z)({},ZZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}NZe.isMDXComponent=!0;const zZe={toc:[]},AZe="wrapper";function PZe(t){let{components:e,...n}=t;return(0,s.kt)(AZe,(0,p.Z)({},zZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}PZe.isMDXComponent=!0;const WZe={toc:[]},RZe="wrapper";function IZe(t){let{components:e,...n}=t;return(0,s.kt)(RZe,(0,p.Z)({},WZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}IZe.isMDXComponent=!0;const SZe={toc:[]},BZe="wrapper";function GZe(t){let{components:e,...n}=t;return(0,s.kt)(BZe,(0,p.Z)({},SZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}GZe.isMDXComponent=!0;const EZe={toc:[]},OZe="wrapper";function FZe(t){let{components:e,...n}=t;return(0,s.kt)(OZe,(0,p.Z)({},EZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}FZe.isMDXComponent=!0;const UZe={toc:[]},VZe="wrapper";function qZe(t){let{components:e,...n}=t;return(0,s.kt)(VZe,(0,p.Z)({},UZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}qZe.isMDXComponent=!0;const jZe={toc:[]},YZe="wrapper";function QZe(t){let{components:e,...n}=t;return(0,s.kt)(YZe,(0,p.Z)({},jZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}QZe.isMDXComponent=!0;const HZe={toc:[]},KZe="wrapper";function $Ze(t){let{components:e,...n}=t;return(0,s.kt)(KZe,(0,p.Z)({},HZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}$Ze.isMDXComponent=!0;const JZe={toc:[]},tbe="wrapper";function ebe(t){let{components:e,...n}=t;return(0,s.kt)(tbe,(0,p.Z)({},JZe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}ebe.isMDXComponent=!0;const nbe={toc:[]},obe="wrapper";function pbe(t){let{components:e,...n}=t;return(0,s.kt)(obe,(0,p.Z)({},nbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}pbe.isMDXComponent=!0;const rbe={toc:[]},sbe="wrapper";function cbe(t){let{components:e,...n}=t;return(0,s.kt)(sbe,(0,p.Z)({},rbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}cbe.isMDXComponent=!0;const abe={toc:[]},ibe="wrapper";function lbe(t){let{components:e,...n}=t;return(0,s.kt)(ibe,(0,p.Z)({},abe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}lbe.isMDXComponent=!0;const ube={toc:[]},mbe="wrapper";function dbe(t){let{components:e,...n}=t;return(0,s.kt)(mbe,(0,p.Z)({},ube,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}dbe.isMDXComponent=!0;const hbe={toc:[]},fbe="wrapper";function kbe(t){let{components:e,...n}=t;return(0,s.kt)(fbe,(0,p.Z)({},hbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}kbe.isMDXComponent=!0;const ybe={toc:[]},Dbe="wrapper";function Mbe(t){let{components:e,...n}=t;return(0,s.kt)(Dbe,(0,p.Z)({},ybe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Mbe.isMDXComponent=!0;const Xbe={toc:[]},_be="wrapper";function wbe(t){let{components:e,...n}=t;return(0,s.kt)(_be,(0,p.Z)({},Xbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}wbe.isMDXComponent=!0;const Tbe={toc:[]},Cbe="wrapper";function xbe(t){let{components:e,...n}=t;return(0,s.kt)(Cbe,(0,p.Z)({},Tbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}xbe.isMDXComponent=!0;const gbe={toc:[]},vbe="wrapper";function Lbe(t){let{components:e,...n}=t;return(0,s.kt)(vbe,(0,p.Z)({},gbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Lbe.isMDXComponent=!0;const Zbe={toc:[]},bbe="wrapper";function Nbe(t){let{components:e,...n}=t;return(0,s.kt)(bbe,(0,p.Z)({},Zbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Nbe.isMDXComponent=!0;const zbe={toc:[]},Abe="wrapper";function Pbe(t){let{components:e,...n}=t;return(0,s.kt)(Abe,(0,p.Z)({},zbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Pbe.isMDXComponent=!0;const Wbe={toc:[]},Rbe="wrapper";function Ibe(t){let{components:e,...n}=t;return(0,s.kt)(Rbe,(0,p.Z)({},Wbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Ibe.isMDXComponent=!0;const Sbe={toc:[]},Bbe="wrapper";function Gbe(t){let{components:e,...n}=t;return(0,s.kt)(Bbe,(0,p.Z)({},Sbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Gbe.isMDXComponent=!0;const Ebe={toc:[]},Obe="wrapper";function Fbe(t){let{components:e,...n}=t;return(0,s.kt)(Obe,(0,p.Z)({},Ebe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Fbe.isMDXComponent=!0;const Ube={toc:[]},Vbe="wrapper";function qbe(t){let{components:e,...n}=t;return(0,s.kt)(Vbe,(0,p.Z)({},Ube,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}qbe.isMDXComponent=!0;const jbe={toc:[]},Ybe="wrapper";function Qbe(t){let{components:e,...n}=t;return(0,s.kt)(Ybe,(0,p.Z)({},jbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Qbe.isMDXComponent=!0;const Hbe={toc:[]},Kbe="wrapper";function $be(t){let{components:e,...n}=t;return(0,s.kt)(Kbe,(0,p.Z)({},Hbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}$be.isMDXComponent=!0;const Jbe={toc:[]},tNe="wrapper";function eNe(t){let{components:e,...n}=t;return(0,s.kt)(tNe,(0,p.Z)({},Jbe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}eNe.isMDXComponent=!0;const nNe={toc:[]},oNe="wrapper";function pNe(t){let{components:e,...n}=t;return(0,s.kt)(oNe,(0,p.Z)({},nNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}pNe.isMDXComponent=!0;const rNe={toc:[]},sNe="wrapper";function cNe(t){let{components:e,...n}=t;return(0,s.kt)(sNe,(0,p.Z)({},rNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}cNe.isMDXComponent=!0;const aNe={toc:[]},iNe="wrapper";function lNe(t){let{components:e,...n}=t;return(0,s.kt)(iNe,(0,p.Z)({},aNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}lNe.isMDXComponent=!0;const uNe={toc:[]},mNe="wrapper";function dNe(t){let{components:e,...n}=t;return(0,s.kt)(mNe,(0,p.Z)({},uNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}dNe.isMDXComponent=!0;const hNe={toc:[]},fNe="wrapper";function kNe(t){let{components:e,...n}=t;return(0,s.kt)(fNe,(0,p.Z)({},hNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}kNe.isMDXComponent=!0;const yNe={toc:[]},DNe="wrapper";function MNe(t){let{components:e,...n}=t;return(0,s.kt)(DNe,(0,p.Z)({},yNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}MNe.isMDXComponent=!0;const XNe={toc:[]},_Ne="wrapper";function wNe(t){let{components:e,...n}=t;return(0,s.kt)(_Ne,(0,p.Z)({},XNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}wNe.isMDXComponent=!0;const TNe={toc:[]},CNe="wrapper";function xNe(t){let{components:e,...n}=t;return(0,s.kt)(CNe,(0,p.Z)({},TNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}xNe.isMDXComponent=!0;const gNe={toc:[]},vNe="wrapper";function LNe(t){let{components:e,...n}=t;return(0,s.kt)(vNe,(0,p.Z)({},gNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}LNe.isMDXComponent=!0;const ZNe={toc:[]},bNe="wrapper";function NNe(t){let{components:e,...n}=t;return(0,s.kt)(bNe,(0,p.Z)({},ZNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}NNe.isMDXComponent=!0;const zNe={toc:[]},ANe="wrapper";function PNe(t){let{components:e,...n}=t;return(0,s.kt)(ANe,(0,p.Z)({},zNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}PNe.isMDXComponent=!0;const WNe={toc:[]},RNe="wrapper";function INe(t){let{components:e,...n}=t;return(0,s.kt)(RNe,(0,p.Z)({},WNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}INe.isMDXComponent=!0;const SNe={toc:[]},BNe="wrapper";function GNe(t){let{components:e,...n}=t;return(0,s.kt)(BNe,(0,p.Z)({},SNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}GNe.isMDXComponent=!0;const ENe={toc:[]},ONe="wrapper";function FNe(t){let{components:e,...n}=t;return(0,s.kt)(ONe,(0,p.Z)({},ENe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}FNe.isMDXComponent=!0;const UNe={toc:[]},VNe="wrapper";function qNe(t){let{components:e,...n}=t;return(0,s.kt)(VNe,(0,p.Z)({},UNe,n,{components:e,mdxType:"MDXLayout"}))}qNe.isMDXComponent=!0;const jNe={toc:[]},YNe="wrapper";function QNe(t){let{components:e,...n}=t;return(0,s.kt)(YNe,(0,p.Z)({},jNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}QNe.isMDXComponent=!0;const HNe={toc:[]},KNe="wrapper";function $Ne(t){let{components:e,...n}=t;return(0,s.kt)(KNe,(0,p.Z)({},HNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}$Ne.isMDXComponent=!0;const JNe={toc:[]},tze="wrapper";function eze(t){let{components:e,...n}=t;return(0,s.kt)(tze,(0,p.Z)({},JNe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}eze.isMDXComponent=!0;const nze={toc:[]},oze="wrapper";function pze(t){let{components:e,...n}=t;return(0,s.kt)(oze,(0,p.Z)({},nze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}pze.isMDXComponent=!0;const rze={toc:[]},sze="wrapper";function cze(t){let{components:e,...n}=t;return(0,s.kt)(sze,(0,p.Z)({},rze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}cze.isMDXComponent=!0;const aze={toc:[]},ize="wrapper";function lze(t){let{components:e,...n}=t;return(0,s.kt)(ize,(0,p.Z)({},aze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}lze.isMDXComponent=!0;const uze={toc:[]},mze="wrapper";function dze(t){let{components:e,...n}=t;return(0,s.kt)(mze,(0,p.Z)({},uze,n,{components:e,mdxType:"MDXLayout"}))}dze.isMDXComponent=!0;const hze={toc:[]},fze="wrapper";function kze(t){let{components:e,...n}=t;return(0,s.kt)(fze,(0,p.Z)({},hze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}kze.isMDXComponent=!0;const yze={toc:[]},Dze="wrapper";function Mze(t){let{components:e,...n}=t;return(0,s.kt)(Dze,(0,p.Z)({},yze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Mze.isMDXComponent=!0;const Xze={toc:[]},_ze="wrapper";function wze(t){let{components:e,...n}=t;return(0,s.kt)(_ze,(0,p.Z)({},Xze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}wze.isMDXComponent=!0;const Tze={toc:[]},Cze="wrapper";function xze(t){let{components:e,...n}=t;return(0,s.kt)(Cze,(0,p.Z)({},Tze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}xze.isMDXComponent=!0;const gze={toc:[]},vze="wrapper";function Lze(t){let{components:e,...n}=t;return(0,s.kt)(vze,(0,p.Z)({},gze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Lze.isMDXComponent=!0;const Zze={toc:[]},bze="wrapper";function Nze(t){let{components:e,...n}=t;return(0,s.kt)(bze,(0,p.Z)({},Zze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Nze.isMDXComponent=!0;const zze={toc:[]},Aze="wrapper";function Pze(t){let{components:e,...n}=t;return(0,s.kt)(Aze,(0,p.Z)({},zze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Pze.isMDXComponent=!0;const Wze={toc:[]},Rze="wrapper";function Ize(t){let{components:e,...n}=t;return(0,s.kt)(Rze,(0,p.Z)({},Wze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Ize.isMDXComponent=!0;const Sze={toc:[]},Bze="wrapper";function Gze(t){let{components:e,...n}=t;return(0,s.kt)(Bze,(0,p.Z)({},Sze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Gze.isMDXComponent=!0;const Eze={toc:[]},Oze="wrapper";function Fze(t){let{components:e,...n}=t;return(0,s.kt)(Oze,(0,p.Z)({},Eze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Fze.isMDXComponent=!0;const Uze={toc:[]},Vze="wrapper";function qze(t){let{components:e,...n}=t;return(0,s.kt)(Vze,(0,p.Z)({},Uze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}qze.isMDXComponent=!0;const jze={toc:[]},Yze="wrapper";function Qze(t){let{components:e,...n}=t;return(0,s.kt)(Yze,(0,p.Z)({},jze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Qze.isMDXComponent=!0;const Hze={toc:[]},Kze="wrapper";function $ze(t){let{components:e,...n}=t;return(0,s.kt)(Kze,(0,p.Z)({},Hze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}$ze.isMDXComponent=!0;const Jze={toc:[]},tAe="wrapper";function eAe(t){let{components:e,...n}=t;return(0,s.kt)(tAe,(0,p.Z)({},Jze,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}eAe.isMDXComponent=!0;const nAe={toc:[]},oAe="wrapper";function pAe(t){let{components:e,...n}=t;return(0,s.kt)(oAe,(0,p.Z)({},nAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}pAe.isMDXComponent=!0;const rAe={toc:[]},sAe="wrapper";function cAe(t){let{components:e,...n}=t;return(0,s.kt)(sAe,(0,p.Z)({},rAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}cAe.isMDXComponent=!0;const aAe={toc:[]},iAe="wrapper";function lAe(t){let{components:e,...n}=t;return(0,s.kt)(iAe,(0,p.Z)({},aAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}lAe.isMDXComponent=!0;const uAe={toc:[]},mAe="wrapper";function dAe(t){let{components:e,...n}=t;return(0,s.kt)(mAe,(0,p.Z)({},uAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}dAe.isMDXComponent=!0;const hAe={toc:[]},fAe="wrapper";function kAe(t){let{components:e,...n}=t;return(0,s.kt)(fAe,(0,p.Z)({},hAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}kAe.isMDXComponent=!0;const yAe={toc:[]},DAe="wrapper";function MAe(t){let{components:e,...n}=t;return(0,s.kt)(DAe,(0,p.Z)({},yAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}MAe.isMDXComponent=!0;const XAe={toc:[]},_Ae="wrapper";function wAe(t){let{components:e,...n}=t;return(0,s.kt)(_Ae,(0,p.Z)({},XAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}wAe.isMDXComponent=!0;const TAe={toc:[]},CAe="wrapper";function xAe(t){let{components:e,...n}=t;return(0,s.kt)(CAe,(0,p.Z)({},TAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}xAe.isMDXComponent=!0;const gAe={toc:[]},vAe="wrapper";function LAe(t){let{components:e,...n}=t;return(0,s.kt)(vAe,(0,p.Z)({},gAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}LAe.isMDXComponent=!0;const ZAe={toc:[]},bAe="wrapper";function NAe(t){let{components:e,...n}=t;return(0,s.kt)(bAe,(0,p.Z)({},ZAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}NAe.isMDXComponent=!0;const zAe={toc:[]},AAe="wrapper";function PAe(t){let{components:e,...n}=t;return(0,s.kt)(AAe,(0,p.Z)({},zAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}PAe.isMDXComponent=!0;const WAe={toc:[]},RAe="wrapper";function IAe(t){let{components:e,...n}=t;return(0,s.kt)(RAe,(0,p.Z)({},WAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}IAe.isMDXComponent=!0;const SAe={toc:[]},BAe="wrapper";function GAe(t){let{components:e,...n}=t;return(0,s.kt)(BAe,(0,p.Z)({},SAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}GAe.isMDXComponent=!0;const EAe={toc:[]},OAe="wrapper";function FAe(t){let{components:e,...n}=t;return(0,s.kt)(OAe,(0,p.Z)({},EAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}FAe.isMDXComponent=!0;const UAe={toc:[]},VAe="wrapper";function qAe(t){let{components:e,...n}=t;return(0,s.kt)(VAe,(0,p.Z)({},UAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}qAe.isMDXComponent=!0;const jAe={toc:[]},YAe="wrapper";function QAe(t){let{components:e,...n}=t;return(0,s.kt)(YAe,(0,p.Z)({},jAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}QAe.isMDXComponent=!0;const HAe={toc:[]},KAe="wrapper";function $Ae(t){let{components:e,...n}=t;return(0,s.kt)(KAe,(0,p.Z)({},HAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}$Ae.isMDXComponent=!0;const JAe={toc:[]},tPe="wrapper";function ePe(t){let{components:e,...n}=t;return(0,s.kt)(tPe,(0,p.Z)({},JAe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}ePe.isMDXComponent=!0;const nPe={toc:[]},oPe="wrapper";function pPe(t){let{components:e,...n}=t;return(0,s.kt)(oPe,(0,p.Z)({},nPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pPe.isMDXComponent=!0;const rPe={toc:[]},sPe="wrapper";function cPe(t){let{components:e,...n}=t;return(0,s.kt)(sPe,(0,p.Z)({},rPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}cPe.isMDXComponent=!0;const aPe={toc:[]},iPe="wrapper";function lPe(t){let{components:e,...n}=t;return(0,s.kt)(iPe,(0,p.Z)({},aPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}lPe.isMDXComponent=!0;const uPe={toc:[]},mPe="wrapper";function dPe(t){let{components:e,...n}=t;return(0,s.kt)(mPe,(0,p.Z)({},uPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}dPe.isMDXComponent=!0;const hPe={toc:[]},fPe="wrapper";function kPe(t){let{components:e,...n}=t;return(0,s.kt)(fPe,(0,p.Z)({},hPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}kPe.isMDXComponent=!0;const yPe={toc:[]},DPe="wrapper";function MPe(t){let{components:e,...n}=t;return(0,s.kt)(DPe,(0,p.Z)({},yPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}MPe.isMDXComponent=!0;const XPe={toc:[]},_Pe="wrapper";function wPe(t){let{components:e,...n}=t;return(0,s.kt)(_Pe,(0,p.Z)({},XPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wPe.isMDXComponent=!0;const TPe={toc:[]},CPe="wrapper";function xPe(t){let{components:e,...n}=t;return(0,s.kt)(CPe,(0,p.Z)({},TPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}xPe.isMDXComponent=!0;const gPe={toc:[]},vPe="wrapper";function LPe(t){let{components:e,...n}=t;return(0,s.kt)(vPe,(0,p.Z)({},gPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}LPe.isMDXComponent=!0;const ZPe={toc:[]},bPe="wrapper";function NPe(t){let{components:e,...n}=t;return(0,s.kt)(bPe,(0,p.Z)({},ZPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}NPe.isMDXComponent=!0;const zPe={toc:[]},APe="wrapper";function PPe(t){let{components:e,...n}=t;return(0,s.kt)(APe,(0,p.Z)({},zPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}PPe.isMDXComponent=!0;const WPe={toc:[]},RPe="wrapper";function IPe(t){let{components:e,...n}=t;return(0,s.kt)(RPe,(0,p.Z)({},WPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}IPe.isMDXComponent=!0;const SPe={toc:[]},BPe="wrapper";function GPe(t){let{components:e,...n}=t;return(0,s.kt)(BPe,(0,p.Z)({},SPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}GPe.isMDXComponent=!0;const EPe={toc:[]},OPe="wrapper";function FPe(t){let{components:e,...n}=t;return(0,s.kt)(OPe,(0,p.Z)({},EPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}FPe.isMDXComponent=!0;const UPe={toc:[]},VPe="wrapper";function qPe(t){let{components:e,...n}=t;return(0,s.kt)(VPe,(0,p.Z)({},UPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qPe.isMDXComponent=!0;const jPe={toc:[]},YPe="wrapper";function QPe(t){let{components:e,...n}=t;return(0,s.kt)(YPe,(0,p.Z)({},jPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}QPe.isMDXComponent=!0;const HPe={toc:[]},KPe="wrapper";function $Pe(t){let{components:e,...n}=t;return(0,s.kt)(KPe,(0,p.Z)({},HPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}$Pe.isMDXComponent=!0;const JPe={toc:[]},tWe="wrapper";function eWe(t){let{components:e,...n}=t;return(0,s.kt)(tWe,(0,p.Z)({},JPe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}eWe.isMDXComponent=!0;const nWe={toc:[]},oWe="wrapper";function pWe(t){let{components:e,...n}=t;return(0,s.kt)(oWe,(0,p.Z)({},nWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pWe.isMDXComponent=!0;const rWe={toc:[]},sWe="wrapper";function cWe(t){let{components:e,...n}=t;return(0,s.kt)(sWe,(0,p.Z)({},rWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}cWe.isMDXComponent=!0;const aWe={toc:[]},iWe="wrapper";function lWe(t){let{components:e,...n}=t;return(0,s.kt)(iWe,(0,p.Z)({},aWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lWe.isMDXComponent=!0;const uWe={toc:[]},mWe="wrapper";function dWe(t){let{components:e,...n}=t;return(0,s.kt)(mWe,(0,p.Z)({},uWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}dWe.isMDXComponent=!0;const hWe={toc:[]},fWe="wrapper";function kWe(t){let{components:e,...n}=t;return(0,s.kt)(fWe,(0,p.Z)({},hWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}kWe.isMDXComponent=!0;const yWe={toc:[]},DWe="wrapper";function MWe(t){let{components:e,...n}=t;return(0,s.kt)(DWe,(0,p.Z)({},yWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}MWe.isMDXComponent=!0;const XWe={toc:[]},_We="wrapper";function wWe(t){let{components:e,...n}=t;return(0,s.kt)(_We,(0,p.Z)({},XWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}wWe.isMDXComponent=!0;const TWe={toc:[]},CWe="wrapper";function xWe(t){let{components:e,...n}=t;return(0,s.kt)(CWe,(0,p.Z)({},TWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}xWe.isMDXComponent=!0;const gWe={toc:[]},vWe="wrapper";function LWe(t){let{components:e,...n}=t;return(0,s.kt)(vWe,(0,p.Z)({},gWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}LWe.isMDXComponent=!0;const ZWe={toc:[]},bWe="wrapper";function NWe(t){let{components:e,...n}=t;return(0,s.kt)(bWe,(0,p.Z)({},ZWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}NWe.isMDXComponent=!0;const zWe={toc:[]},AWe="wrapper";function PWe(t){let{components:e,...n}=t;return(0,s.kt)(AWe,(0,p.Z)({},zWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}PWe.isMDXComponent=!0;const WWe={toc:[]},RWe="wrapper";function IWe(t){let{components:e,...n}=t;return(0,s.kt)(RWe,(0,p.Z)({},WWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}IWe.isMDXComponent=!0;const SWe={toc:[]},BWe="wrapper";function GWe(t){let{components:e,...n}=t;return(0,s.kt)(BWe,(0,p.Z)({},SWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}GWe.isMDXComponent=!0;const EWe={toc:[]},OWe="wrapper";function FWe(t){let{components:e,...n}=t;return(0,s.kt)(OWe,(0,p.Z)({},EWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}FWe.isMDXComponent=!0;const UWe={toc:[]},VWe="wrapper";function qWe(t){let{components:e,...n}=t;return(0,s.kt)(VWe,(0,p.Z)({},UWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}qWe.isMDXComponent=!0;const jWe={toc:[]},YWe="wrapper";function QWe(t){let{components:e,...n}=t;return(0,s.kt)(YWe,(0,p.Z)({},jWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}QWe.isMDXComponent=!0;const HWe={toc:[]},KWe="wrapper";function $We(t){let{components:e,...n}=t;return(0,s.kt)(KWe,(0,p.Z)({},HWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}$We.isMDXComponent=!0;const JWe={toc:[]},tRe="wrapper";function eRe(t){let{components:e,...n}=t;return(0,s.kt)(tRe,(0,p.Z)({},JWe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}eRe.isMDXComponent=!0;const nRe={toc:[]},oRe="wrapper";function pRe(t){let{components:e,...n}=t;return(0,s.kt)(oRe,(0,p.Z)({},nRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}pRe.isMDXComponent=!0;const rRe={toc:[]},sRe="wrapper";function cRe(t){let{components:e,...n}=t;return(0,s.kt)(sRe,(0,p.Z)({},rRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}cRe.isMDXComponent=!0;const aRe={toc:[]},iRe="wrapper";function lRe(t){let{components:e,...n}=t;return(0,s.kt)(iRe,(0,p.Z)({},aRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}lRe.isMDXComponent=!0;const uRe={toc:[]},mRe="wrapper";function dRe(t){let{components:e,...n}=t;return(0,s.kt)(mRe,(0,p.Z)({},uRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}dRe.isMDXComponent=!0;const hRe={toc:[]},fRe="wrapper";function kRe(t){let{components:e,...n}=t;return(0,s.kt)(fRe,(0,p.Z)({},hRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}kRe.isMDXComponent=!0;const yRe={toc:[]},DRe="wrapper";function MRe(t){let{components:e,...n}=t;return(0,s.kt)(DRe,(0,p.Z)({},yRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}MRe.isMDXComponent=!0;const XRe={toc:[]},_Re="wrapper";function wRe(t){let{components:e,...n}=t;return(0,s.kt)(_Re,(0,p.Z)({},XRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}wRe.isMDXComponent=!0;const TRe={toc:[]},CRe="wrapper";function xRe(t){let{components:e,...n}=t;return(0,s.kt)(CRe,(0,p.Z)({},TRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}xRe.isMDXComponent=!0;const gRe={toc:[]},vRe="wrapper";function LRe(t){let{components:e,...n}=t;return(0,s.kt)(vRe,(0,p.Z)({},gRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}LRe.isMDXComponent=!0;const ZRe={toc:[]},bRe="wrapper";function NRe(t){let{components:e,...n}=t;return(0,s.kt)(bRe,(0,p.Z)({},ZRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}NRe.isMDXComponent=!0;const zRe={toc:[]},ARe="wrapper";function PRe(t){let{components:e,...n}=t;return(0,s.kt)(ARe,(0,p.Z)({},zRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}PRe.isMDXComponent=!0;const WRe={toc:[]},RRe="wrapper";function IRe(t){let{components:e,...n}=t;return(0,s.kt)(RRe,(0,p.Z)({},WRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}IRe.isMDXComponent=!0;const SRe={toc:[]},BRe="wrapper";function GRe(t){let{components:e,...n}=t;return(0,s.kt)(BRe,(0,p.Z)({},SRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}GRe.isMDXComponent=!0;const ERe={toc:[]},ORe="wrapper";function FRe(t){let{components:e,...n}=t;return(0,s.kt)(ORe,(0,p.Z)({},ERe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}FRe.isMDXComponent=!0;const URe={toc:[]},VRe="wrapper";function qRe(t){let{components:e,...n}=t;return(0,s.kt)(VRe,(0,p.Z)({},URe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}qRe.isMDXComponent=!0;const jRe={toc:[]},YRe="wrapper";function QRe(t){let{components:e,...n}=t;return(0,s.kt)(YRe,(0,p.Z)({},jRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}QRe.isMDXComponent=!0;const HRe={toc:[]},KRe="wrapper";function $Re(t){let{components:e,...n}=t;return(0,s.kt)(KRe,(0,p.Z)({},HRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}$Re.isMDXComponent=!0;const JRe={toc:[]},tIe="wrapper";function eIe(t){let{components:e,...n}=t;return(0,s.kt)(tIe,(0,p.Z)({},JRe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}eIe.isMDXComponent=!0;const nIe={toc:[]},oIe="wrapper";function pIe(t){let{components:e,...n}=t;return(0,s.kt)(oIe,(0,p.Z)({},nIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}pIe.isMDXComponent=!0;const rIe={toc:[]},sIe="wrapper";function cIe(t){let{components:e,...n}=t;return(0,s.kt)(sIe,(0,p.Z)({},rIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}cIe.isMDXComponent=!0;const aIe={toc:[]},iIe="wrapper";function lIe(t){let{components:e,...n}=t;return(0,s.kt)(iIe,(0,p.Z)({},aIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}lIe.isMDXComponent=!0;const uIe={toc:[]},mIe="wrapper";function dIe(t){let{components:e,...n}=t;return(0,s.kt)(mIe,(0,p.Z)({},uIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}dIe.isMDXComponent=!0;const hIe={toc:[]},fIe="wrapper";function kIe(t){let{components:e,...n}=t;return(0,s.kt)(fIe,(0,p.Z)({},hIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}kIe.isMDXComponent=!0;const yIe={toc:[]},DIe="wrapper";function MIe(t){let{components:e,...n}=t;return(0,s.kt)(DIe,(0,p.Z)({},yIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}MIe.isMDXComponent=!0;const XIe={toc:[]},_Ie="wrapper";function wIe(t){let{components:e,...n}=t;return(0,s.kt)(_Ie,(0,p.Z)({},XIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}wIe.isMDXComponent=!0;const TIe={toc:[]},CIe="wrapper";function xIe(t){let{components:e,...n}=t;return(0,s.kt)(CIe,(0,p.Z)({},TIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}xIe.isMDXComponent=!0;const gIe={toc:[]},vIe="wrapper";function LIe(t){let{components:e,...n}=t;return(0,s.kt)(vIe,(0,p.Z)({},gIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}LIe.isMDXComponent=!0;const ZIe={toc:[]},bIe="wrapper";function NIe(t){let{components:e,...n}=t;return(0,s.kt)(bIe,(0,p.Z)({},ZIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}NIe.isMDXComponent=!0;const zIe={toc:[]},AIe="wrapper";function PIe(t){let{components:e,...n}=t;return(0,s.kt)(AIe,(0,p.Z)({},zIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}PIe.isMDXComponent=!0;const WIe={toc:[]},RIe="wrapper";function IIe(t){let{components:e,...n}=t;return(0,s.kt)(RIe,(0,p.Z)({},WIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}IIe.isMDXComponent=!0;const SIe={toc:[]},BIe="wrapper";function GIe(t){let{components:e,...n}=t;return(0,s.kt)(BIe,(0,p.Z)({},SIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}GIe.isMDXComponent=!0;const EIe={toc:[]},OIe="wrapper";function FIe(t){let{components:e,...n}=t;return(0,s.kt)(OIe,(0,p.Z)({},EIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}FIe.isMDXComponent=!0;const UIe={toc:[]},VIe="wrapper";function qIe(t){let{components:e,...n}=t;return(0,s.kt)(VIe,(0,p.Z)({},UIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}qIe.isMDXComponent=!0;const jIe={toc:[]},YIe="wrapper";function QIe(t){let{components:e,...n}=t;return(0,s.kt)(YIe,(0,p.Z)({},jIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}QIe.isMDXComponent=!0;const HIe={toc:[]},KIe="wrapper";function $Ie(t){let{components:e,...n}=t;return(0,s.kt)(KIe,(0,p.Z)({},HIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}$Ie.isMDXComponent=!0;const JIe={toc:[]},tSe="wrapper";function eSe(t){let{components:e,...n}=t;return(0,s.kt)(tSe,(0,p.Z)({},JIe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}eSe.isMDXComponent=!0;const nSe={toc:[]},oSe="wrapper";function pSe(t){let{components:e,...n}=t;return(0,s.kt)(oSe,(0,p.Z)({},nSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}pSe.isMDXComponent=!0;const rSe={toc:[]},sSe="wrapper";function cSe(t){let{components:e,...n}=t;return(0,s.kt)(sSe,(0,p.Z)({},rSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}cSe.isMDXComponent=!0;const aSe={toc:[]},iSe="wrapper";function lSe(t){let{components:e,...n}=t;return(0,s.kt)(iSe,(0,p.Z)({},aSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}lSe.isMDXComponent=!0;const uSe={toc:[]},mSe="wrapper";function dSe(t){let{components:e,...n}=t;return(0,s.kt)(mSe,(0,p.Z)({},uSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}dSe.isMDXComponent=!0;const hSe={toc:[]},fSe="wrapper";function kSe(t){let{components:e,...n}=t;return(0,s.kt)(fSe,(0,p.Z)({},hSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kSe.isMDXComponent=!0;const ySe={toc:[]},DSe="wrapper";function MSe(t){let{components:e,...n}=t;return(0,s.kt)(DSe,(0,p.Z)({},ySe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}MSe.isMDXComponent=!0;const XSe={toc:[]},_Se="wrapper";function wSe(t){let{components:e,...n}=t;return(0,s.kt)(_Se,(0,p.Z)({},XSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}wSe.isMDXComponent=!0;const TSe={toc:[]},CSe="wrapper";function xSe(t){let{components:e,...n}=t;return(0,s.kt)(CSe,(0,p.Z)({},TSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}xSe.isMDXComponent=!0;const gSe={toc:[]},vSe="wrapper";function LSe(t){let{components:e,...n}=t;return(0,s.kt)(vSe,(0,p.Z)({},gSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}LSe.isMDXComponent=!0;const ZSe={toc:[]},bSe="wrapper";function NSe(t){let{components:e,...n}=t;return(0,s.kt)(bSe,(0,p.Z)({},ZSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}NSe.isMDXComponent=!0;const zSe={toc:[]},ASe="wrapper";function PSe(t){let{components:e,...n}=t;return(0,s.kt)(ASe,(0,p.Z)({},zSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}PSe.isMDXComponent=!0;const WSe={toc:[]},RSe="wrapper";function ISe(t){let{components:e,...n}=t;return(0,s.kt)(RSe,(0,p.Z)({},WSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}ISe.isMDXComponent=!0;const SSe={toc:[]},BSe="wrapper";function GSe(t){let{components:e,...n}=t;return(0,s.kt)(BSe,(0,p.Z)({},SSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}GSe.isMDXComponent=!0;const ESe={toc:[]},OSe="wrapper";function FSe(t){let{components:e,...n}=t;return(0,s.kt)(OSe,(0,p.Z)({},ESe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}FSe.isMDXComponent=!0;const USe={toc:[]},VSe="wrapper";function qSe(t){let{components:e,...n}=t;return(0,s.kt)(VSe,(0,p.Z)({},USe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qSe.isMDXComponent=!0;const jSe={toc:[]},YSe="wrapper";function QSe(t){let{components:e,...n}=t;return(0,s.kt)(YSe,(0,p.Z)({},jSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}QSe.isMDXComponent=!0;const HSe={toc:[]},KSe="wrapper";function $Se(t){let{components:e,...n}=t;return(0,s.kt)(KSe,(0,p.Z)({},HSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}$Se.isMDXComponent=!0;const JSe={toc:[]},tBe="wrapper";function eBe(t){let{components:e,...n}=t;return(0,s.kt)(tBe,(0,p.Z)({},JSe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}eBe.isMDXComponent=!0;const nBe={toc:[]},oBe="wrapper";function pBe(t){let{components:e,...n}=t;return(0,s.kt)(oBe,(0,p.Z)({},nBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}pBe.isMDXComponent=!0;const rBe={toc:[]},sBe="wrapper";function cBe(t){let{components:e,...n}=t;return(0,s.kt)(sBe,(0,p.Z)({},rBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}cBe.isMDXComponent=!0;const aBe={toc:[]},iBe="wrapper";function lBe(t){let{components:e,...n}=t;return(0,s.kt)(iBe,(0,p.Z)({},aBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}lBe.isMDXComponent=!0;const uBe={toc:[]},mBe="wrapper";function dBe(t){let{components:e,...n}=t;return(0,s.kt)(mBe,(0,p.Z)({},uBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}dBe.isMDXComponent=!0;const hBe={toc:[]},fBe="wrapper";function kBe(t){let{components:e,...n}=t;return(0,s.kt)(fBe,(0,p.Z)({},hBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}kBe.isMDXComponent=!0;const yBe={toc:[]},DBe="wrapper";function MBe(t){let{components:e,...n}=t;return(0,s.kt)(DBe,(0,p.Z)({},yBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}MBe.isMDXComponent=!0;const XBe={toc:[]},_Be="wrapper";function wBe(t){let{components:e,...n}=t;return(0,s.kt)(_Be,(0,p.Z)({},XBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}wBe.isMDXComponent=!0;const TBe={toc:[]},CBe="wrapper";function xBe(t){let{components:e,...n}=t;return(0,s.kt)(CBe,(0,p.Z)({},TBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}xBe.isMDXComponent=!0;const gBe={toc:[]},vBe="wrapper";function LBe(t){let{components:e,...n}=t;return(0,s.kt)(vBe,(0,p.Z)({},gBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}LBe.isMDXComponent=!0;const ZBe={toc:[]},bBe="wrapper";function NBe(t){let{components:e,...n}=t;return(0,s.kt)(bBe,(0,p.Z)({},ZBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}NBe.isMDXComponent=!0;const zBe={toc:[]},ABe="wrapper";function PBe(t){let{components:e,...n}=t;return(0,s.kt)(ABe,(0,p.Z)({},zBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}PBe.isMDXComponent=!0;const WBe={toc:[]},RBe="wrapper";function IBe(t){let{components:e,...n}=t;return(0,s.kt)(RBe,(0,p.Z)({},WBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}IBe.isMDXComponent=!0;const SBe={toc:[]},BBe="wrapper";function GBe(t){let{components:e,...n}=t;return(0,s.kt)(BBe,(0,p.Z)({},SBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}GBe.isMDXComponent=!0;const EBe={toc:[]},OBe="wrapper";function FBe(t){let{components:e,...n}=t;return(0,s.kt)(OBe,(0,p.Z)({},EBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}FBe.isMDXComponent=!0;const UBe={toc:[]},VBe="wrapper";function qBe(t){let{components:e,...n}=t;return(0,s.kt)(VBe,(0,p.Z)({},UBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}qBe.isMDXComponent=!0;const jBe={toc:[]},YBe="wrapper";function QBe(t){let{components:e,...n}=t;return(0,s.kt)(YBe,(0,p.Z)({},jBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}QBe.isMDXComponent=!0;const HBe={toc:[]},KBe="wrapper";function $Be(t){let{components:e,...n}=t;return(0,s.kt)(KBe,(0,p.Z)({},HBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}$Be.isMDXComponent=!0;const JBe={toc:[]},tGe="wrapper";function eGe(t){let{components:e,...n}=t;return(0,s.kt)(tGe,(0,p.Z)({},JBe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}eGe.isMDXComponent=!0;const nGe={toc:[]},oGe="wrapper";function pGe(t){let{components:e,...n}=t;return(0,s.kt)(oGe,(0,p.Z)({},nGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}pGe.isMDXComponent=!0;const rGe={toc:[]},sGe="wrapper";function cGe(t){let{components:e,...n}=t;return(0,s.kt)(sGe,(0,p.Z)({},rGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}cGe.isMDXComponent=!0;const aGe={toc:[]},iGe="wrapper";function lGe(t){let{components:e,...n}=t;return(0,s.kt)(iGe,(0,p.Z)({},aGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lGe.isMDXComponent=!0;const uGe={toc:[]},mGe="wrapper";function dGe(t){let{components:e,...n}=t;return(0,s.kt)(mGe,(0,p.Z)({},uGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}dGe.isMDXComponent=!0;const hGe={toc:[]},fGe="wrapper";function kGe(t){let{components:e,...n}=t;return(0,s.kt)(fGe,(0,p.Z)({},hGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render any polygonal shape defined by a set of\npoints."))}kGe.isMDXComponent=!0;const yGe={toc:[]},DGe="wrapper";function MGe(t){let{components:e,...n}=t;return(0,s.kt)(DGe,(0,p.Z)({},yGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Simple line\nimport {makeScene2D, Line} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Line\n      points={[\n        [150, 50],\n        [0, -50],\n        [-150, 50],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      radius={40}\n      startArrow\n    />,\n  );\n});\n\n// snippet Polygon\nimport {makeScene2D, Line} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Line\n      points={[\n        [-200, 70],\n        [150, 70],\n        [100, -70],\n        [-100, -70],\n      ]}\n      fill={'lightseagreen'}\n      closed\n    />,\n  );\n});\n\n// snippet Using signals\nimport {makeScene2D, Line} from '@motion-canvas/2d';\nimport {createSignal} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const tip = createSignal(-150);\n  view.add(\n    <Line\n      points={[\n        [-150, 70],\n        [150, 70],\n        // this point is dynamically calculated based on the signal:\n        () => [tip(), -70],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      closed\n    />,\n  );\n\n  yield* tip(150, 1).back(1);\n});\n\n// snippet Tweening points\nimport {makeScene2D, Line} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const line = createRef<Line>();\n  view.add(\n    <Line\n      ref={line}\n      points={[\n        [-150, 70],\n        [150, 70],\n        [0, -70],\n      ]}\n      stroke={'lightseagreen'}\n      lineWidth={8}\n      radius={20}\n      closed\n    />,\n  );\n\n  yield* line()\n    .points(\n      [\n        [-150, 0],\n        [0, 100],\n        [150, 0],\n        [150, -70],\n        [-150, -70],\n      ],\n      2,\n    )\n    .back(2);\n});\n")))}MGe.isMDXComponent=!0;const XGe={toc:[]},_Ge="wrapper";function wGe(t){let{components:e,...n}=t;return(0,s.kt)(_Ge,(0,p.Z)({},XGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing lines and polygons."))}wGe.isMDXComponent=!0;const TGe={toc:[]},CGe="wrapper";function xGe(t){let{components:e,...n}=t;return(0,s.kt)(CGe,(0,p.Z)({},TGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}xGe.isMDXComponent=!0;const gGe={toc:[]},vGe="wrapper";function LGe(t){let{components:e,...n}=t;return(0,s.kt)(vGe,(0,p.Z)({},gGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}LGe.isMDXComponent=!0;const ZGe={toc:[]},bGe="wrapper";function NGe(t){let{components:e,...n}=t;return(0,s.kt)(bGe,(0,p.Z)({},ZGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}NGe.isMDXComponent=!0;const zGe={toc:[]},AGe="wrapper";function PGe(t){let{components:e,...n}=t;return(0,s.kt)(AGe,(0,p.Z)({},zGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}PGe.isMDXComponent=!0;const WGe={toc:[]},RGe="wrapper";function IGe(t){let{components:e,...n}=t;return(0,s.kt)(RGe,(0,p.Z)({},WGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}IGe.isMDXComponent=!0;const SGe={toc:[]},BGe="wrapper";function GGe(t){let{components:e,...n}=t;return(0,s.kt)(BGe,(0,p.Z)({},SGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}GGe.isMDXComponent=!0;const EGe={toc:[]},OGe="wrapper";function FGe(t){let{components:e,...n}=t;return(0,s.kt)(OGe,(0,p.Z)({},EGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}FGe.isMDXComponent=!0;const UGe={toc:[]},VGe="wrapper";function qGe(t){let{components:e,...n}=t;return(0,s.kt)(VGe,(0,p.Z)({},UGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}qGe.isMDXComponent=!0;const jGe={toc:[]},YGe="wrapper";function QGe(t){let{components:e,...n}=t;return(0,s.kt)(YGe,(0,p.Z)({},jGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}QGe.isMDXComponent=!0;const HGe={toc:[]},KGe="wrapper";function $Ge(t){let{components:e,...n}=t;return(0,s.kt)(KGe,(0,p.Z)({},HGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}$Ge.isMDXComponent=!0;const JGe={toc:[]},tEe="wrapper";function eEe(t){let{components:e,...n}=t;return(0,s.kt)(tEe,(0,p.Z)({},JGe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}eEe.isMDXComponent=!0;const nEe={toc:[]},oEe="wrapper";function pEe(t){let{components:e,...n}=t;return(0,s.kt)(oEe,(0,p.Z)({},nEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}pEe.isMDXComponent=!0;const rEe={toc:[]},sEe="wrapper";function cEe(t){let{components:e,...n}=t;return(0,s.kt)(sEe,(0,p.Z)({},rEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}cEe.isMDXComponent=!0;const aEe={toc:[]},iEe="wrapper";function lEe(t){let{components:e,...n}=t;return(0,s.kt)(iEe,(0,p.Z)({},aEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lEe.isMDXComponent=!0;const uEe={toc:[]},mEe="wrapper";function dEe(t){let{components:e,...n}=t;return(0,s.kt)(mEe,(0,p.Z)({},uEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}dEe.isMDXComponent=!0;const hEe={toc:[]},fEe="wrapper";function kEe(t){let{components:e,...n}=t;return(0,s.kt)(fEe,(0,p.Z)({},hEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}kEe.isMDXComponent=!0;const yEe={toc:[]},DEe="wrapper";function MEe(t){let{components:e,...n}=t;return(0,s.kt)(DEe,(0,p.Z)({},yEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}MEe.isMDXComponent=!0;const XEe={toc:[]},_Ee="wrapper";function wEe(t){let{components:e,...n}=t;return(0,s.kt)(_Ee,(0,p.Z)({},XEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}wEe.isMDXComponent=!0;const TEe={toc:[]},CEe="wrapper";function xEe(t){let{components:e,...n}=t;return(0,s.kt)(CEe,(0,p.Z)({},TEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}xEe.isMDXComponent=!0;const gEe={toc:[]},vEe="wrapper";function LEe(t){let{components:e,...n}=t;return(0,s.kt)(vEe,(0,p.Z)({},gEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}LEe.isMDXComponent=!0;const ZEe={toc:[]},bEe="wrapper";function NEe(t){let{components:e,...n}=t;return(0,s.kt)(bEe,(0,p.Z)({},ZEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}NEe.isMDXComponent=!0;const zEe={toc:[]},AEe="wrapper";function PEe(t){let{components:e,...n}=t;return(0,s.kt)(AEe,(0,p.Z)({},zEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}PEe.isMDXComponent=!0;const WEe={toc:[]},REe="wrapper";function IEe(t){let{components:e,...n}=t;return(0,s.kt)(REe,(0,p.Z)({},WEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}IEe.isMDXComponent=!0;const SEe={toc:[]},BEe="wrapper";function GEe(t){let{components:e,...n}=t;return(0,s.kt)(BEe,(0,p.Z)({},SEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}GEe.isMDXComponent=!0;const EEe={toc:[]},OEe="wrapper";function FEe(t){let{components:e,...n}=t;return(0,s.kt)(OEe,(0,p.Z)({},EEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}FEe.isMDXComponent=!0;const UEe={toc:[]},VEe="wrapper";function qEe(t){let{components:e,...n}=t;return(0,s.kt)(VEe,(0,p.Z)({},UEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qEe.isMDXComponent=!0;const jEe={toc:[]},YEe="wrapper";function QEe(t){let{components:e,...n}=t;return(0,s.kt)(YEe,(0,p.Z)({},jEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}QEe.isMDXComponent=!0;const HEe={toc:[]},KEe="wrapper";function $Ee(t){let{components:e,...n}=t;return(0,s.kt)(KEe,(0,p.Z)({},HEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}$Ee.isMDXComponent=!0;const JEe={toc:[]},tOe="wrapper";function eOe(t){let{components:e,...n}=t;return(0,s.kt)(tOe,(0,p.Z)({},JEe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}eOe.isMDXComponent=!0;const nOe={toc:[]},oOe="wrapper";function pOe(t){let{components:e,...n}=t;return(0,s.kt)(oOe,(0,p.Z)({},nOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}pOe.isMDXComponent=!0;const rOe={toc:[]},sOe="wrapper";function cOe(t){let{components:e,...n}=t;return(0,s.kt)(sOe,(0,p.Z)({},rOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}cOe.isMDXComponent=!0;const aOe={toc:[]},iOe="wrapper";function lOe(t){let{components:e,...n}=t;return(0,s.kt)(iOe,(0,p.Z)({},aOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}lOe.isMDXComponent=!0;const uOe={toc:[]},mOe="wrapper";function dOe(t){let{components:e,...n}=t;return(0,s.kt)(mOe,(0,p.Z)({},uOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", the Line will use the positions of its children as\npoints."))}dOe.isMDXComponent=!0;const hOe={toc:[]},fOe="wrapper";function kOe(t){let{components:e,...n}=t;return(0,s.kt)(fOe,(0,p.Z)({},hOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The points of the line."))}kOe.isMDXComponent=!0;const yOe={toc:[]},DOe="wrapper";function MOe(t){let{components:e,...n}=t;return(0,s.kt)(DOe,(0,p.Z)({},yOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}MOe.isMDXComponent=!0;const XOe={toc:[]},_Oe="wrapper";function wOe(t){let{components:e,...n}=t;return(0,s.kt)(_Oe,(0,p.Z)({},XOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wOe.isMDXComponent=!0;const TOe={toc:[]},COe="wrapper";function xOe(t){let{components:e,...n}=t;return(0,s.kt)(COe,(0,p.Z)({},TOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The radius of the line's corners."))}xOe.isMDXComponent=!0;const gOe={toc:[]},vOe="wrapper";function LOe(t){let{components:e,...n}=t;return(0,s.kt)(vOe,(0,p.Z)({},gOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}LOe.isMDXComponent=!0;const ZOe={toc:[]},bOe="wrapper";function NOe(t){let{components:e,...n}=t;return(0,s.kt)(bOe,(0,p.Z)({},ZOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}NOe.isMDXComponent=!0;const zOe={toc:[]},AOe="wrapper";function POe(t){let{components:e,...n}=t;return(0,s.kt)(AOe,(0,p.Z)({},zOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}POe.isMDXComponent=!0;const WOe={toc:[]},ROe="wrapper";function IOe(t){let{components:e,...n}=t;return(0,s.kt)(ROe,(0,p.Z)({},WOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}IOe.isMDXComponent=!0;const SOe={toc:[]},BOe="wrapper";function GOe(t){let{components:e,...n}=t;return(0,s.kt)(BOe,(0,p.Z)({},SOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}GOe.isMDXComponent=!0;const EOe={toc:[]},OOe="wrapper";function FOe(t){let{components:e,...n}=t;return(0,s.kt)(OOe,(0,p.Z)({},EOe,n,{components:e,mdxType:"MDXLayout"}))}FOe.isMDXComponent=!0;const UOe={toc:[]},VOe="wrapper";function qOe(t){let{components:e,...n}=t;return(0,s.kt)(VOe,(0,p.Z)({},UOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}qOe.isMDXComponent=!0;const jOe={toc:[]},YOe="wrapper";function QOe(t){let{components:e,...n}=t;return(0,s.kt)(YOe,(0,p.Z)({},jOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}QOe.isMDXComponent=!0;const HOe={toc:[]},KOe="wrapper";function $Oe(t){let{components:e,...n}=t;return(0,s.kt)(KOe,(0,p.Z)({},HOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}$Oe.isMDXComponent=!0;const JOe={toc:[]},tFe="wrapper";function eFe(t){let{components:e,...n}=t;return(0,s.kt)(tFe,(0,p.Z)({},JOe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}eFe.isMDXComponent=!0;const nFe={toc:[]},oFe="wrapper";function pFe(t){let{components:e,...n}=t;return(0,s.kt)(oFe,(0,p.Z)({},nFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}pFe.isMDXComponent=!0;const rFe={toc:[]},sFe="wrapper";function cFe(t){let{components:e,...n}=t;return(0,s.kt)(sFe,(0,p.Z)({},rFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}cFe.isMDXComponent=!0;const aFe={toc:[]},iFe="wrapper";function lFe(t){let{components:e,...n}=t;return(0,s.kt)(iFe,(0,p.Z)({},aFe,n,{components:e,mdxType:"MDXLayout"}))}lFe.isMDXComponent=!0;const uFe={toc:[]},mFe="wrapper";function dFe(t){let{components:e,...n}=t;return(0,s.kt)(mFe,(0,p.Z)({},uFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}dFe.isMDXComponent=!0;const hFe={toc:[]},fFe="wrapper";function kFe(t){let{components:e,...n}=t;return(0,s.kt)(fFe,(0,p.Z)({},hFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}kFe.isMDXComponent=!0;const yFe={toc:[]},DFe="wrapper";function MFe(t){let{components:e,...n}=t;return(0,s.kt)(DFe,(0,p.Z)({},yFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}MFe.isMDXComponent=!0;const XFe={toc:[]},_Fe="wrapper";function wFe(t){let{components:e,...n}=t;return(0,s.kt)(_Fe,(0,p.Z)({},XFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}wFe.isMDXComponent=!0;const TFe={toc:[]},CFe="wrapper";function xFe(t){let{components:e,...n}=t;return(0,s.kt)(CFe,(0,p.Z)({},TFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}xFe.isMDXComponent=!0;const gFe={toc:[]},vFe="wrapper";function LFe(t){let{components:e,...n}=t;return(0,s.kt)(vFe,(0,p.Z)({},gFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}LFe.isMDXComponent=!0;const ZFe={toc:[]},bFe="wrapper";function NFe(t){let{components:e,...n}=t;return(0,s.kt)(bFe,(0,p.Z)({},ZFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}NFe.isMDXComponent=!0;const zFe={toc:[]},AFe="wrapper";function PFe(t){let{components:e,...n}=t;return(0,s.kt)(AFe,(0,p.Z)({},zFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}PFe.isMDXComponent=!0;const WFe={toc:[]},RFe="wrapper";function IFe(t){let{components:e,...n}=t;return(0,s.kt)(RFe,(0,p.Z)({},WFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}IFe.isMDXComponent=!0;const SFe={toc:[]},BFe="wrapper";function GFe(t){let{components:e,...n}=t;return(0,s.kt)(BFe,(0,p.Z)({},SFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}GFe.isMDXComponent=!0;const EFe={toc:[]},OFe="wrapper";function FFe(t){let{components:e,...n}=t;return(0,s.kt)(OFe,(0,p.Z)({},EFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}FFe.isMDXComponent=!0;const UFe={toc:[]},VFe="wrapper";function qFe(t){let{components:e,...n}=t;return(0,s.kt)(VFe,(0,p.Z)({},UFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}qFe.isMDXComponent=!0;const jFe={toc:[]},YFe="wrapper";function QFe(t){let{components:e,...n}=t;return(0,s.kt)(YFe,(0,p.Z)({},jFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}QFe.isMDXComponent=!0;const HFe={toc:[]},KFe="wrapper";function $Fe(t){let{components:e,...n}=t;return(0,s.kt)(KFe,(0,p.Z)({},HFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}$Fe.isMDXComponent=!0;const JFe={toc:[]},tUe="wrapper";function eUe(t){let{components:e,...n}=t;return(0,s.kt)(tUe,(0,p.Z)({},JFe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}eUe.isMDXComponent=!0;const nUe={toc:[]},oUe="wrapper";function pUe(t){let{components:e,...n}=t;return(0,s.kt)(oUe,(0,p.Z)({},nUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}pUe.isMDXComponent=!0;const rUe={toc:[]},sUe="wrapper";function cUe(t){let{components:e,...n}=t;return(0,s.kt)(sUe,(0,p.Z)({},rUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}cUe.isMDXComponent=!0;const aUe={toc:[]},iUe="wrapper";function lUe(t){let{components:e,...n}=t;return(0,s.kt)(iUe,(0,p.Z)({},aUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}lUe.isMDXComponent=!0;const uUe={toc:[]},mUe="wrapper";function dUe(t){let{components:e,...n}=t;return(0,s.kt)(mUe,(0,p.Z)({},uUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}dUe.isMDXComponent=!0;const hUe={toc:[]},fUe="wrapper";function kUe(t){let{components:e,...n}=t;return(0,s.kt)(fUe,(0,p.Z)({},hUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}kUe.isMDXComponent=!0;const yUe={toc:[]},DUe="wrapper";function MUe(t){let{components:e,...n}=t;return(0,s.kt)(DUe,(0,p.Z)({},yUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}MUe.isMDXComponent=!0;const XUe={toc:[]},_Ue="wrapper";function wUe(t){let{components:e,...n}=t;return(0,s.kt)(_Ue,(0,p.Z)({},XUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}wUe.isMDXComponent=!0;const TUe={toc:[]},CUe="wrapper";function xUe(t){let{components:e,...n}=t;return(0,s.kt)(CUe,(0,p.Z)({},TUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}xUe.isMDXComponent=!0;const gUe={toc:[]},vUe="wrapper";function LUe(t){let{components:e,...n}=t;return(0,s.kt)(vUe,(0,p.Z)({},gUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}LUe.isMDXComponent=!0;const ZUe={toc:[]},bUe="wrapper";function NUe(t){let{components:e,...n}=t;return(0,s.kt)(bUe,(0,p.Z)({},ZUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}NUe.isMDXComponent=!0;const zUe={toc:[]},AUe="wrapper";function PUe(t){let{components:e,...n}=t;return(0,s.kt)(AUe,(0,p.Z)({},zUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}PUe.isMDXComponent=!0;const WUe={toc:[]},RUe="wrapper";function IUe(t){let{components:e,...n}=t;return(0,s.kt)(RUe,(0,p.Z)({},WUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}IUe.isMDXComponent=!0;const SUe={toc:[]},BUe="wrapper";function GUe(t){let{components:e,...n}=t;return(0,s.kt)(BUe,(0,p.Z)({},SUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}GUe.isMDXComponent=!0;const EUe={toc:[]},OUe="wrapper";function FUe(t){let{components:e,...n}=t;return(0,s.kt)(OUe,(0,p.Z)({},EUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}FUe.isMDXComponent=!0;const UUe={toc:[]},VUe="wrapper";function qUe(t){let{components:e,...n}=t;return(0,s.kt)(VUe,(0,p.Z)({},UUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}qUe.isMDXComponent=!0;const jUe={toc:[]},YUe="wrapper";function QUe(t){let{components:e,...n}=t;return(0,s.kt)(YUe,(0,p.Z)({},jUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}QUe.isMDXComponent=!0;const HUe={toc:[]},KUe="wrapper";function $Ue(t){let{components:e,...n}=t;return(0,s.kt)(KUe,(0,p.Z)({},HUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}$Ue.isMDXComponent=!0;const JUe={toc:[]},tVe="wrapper";function eVe(t){let{components:e,...n}=t;return(0,s.kt)(tVe,(0,p.Z)({},JUe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}eVe.isMDXComponent=!0;const nVe={toc:[]},oVe="wrapper";function pVe(t){let{components:e,...n}=t;return(0,s.kt)(oVe,(0,p.Z)({},nVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}pVe.isMDXComponent=!0;const rVe={toc:[]},sVe="wrapper";function cVe(t){let{components:e,...n}=t;return(0,s.kt)(sVe,(0,p.Z)({},rVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}cVe.isMDXComponent=!0;const aVe={toc:[]},iVe="wrapper";function lVe(t){let{components:e,...n}=t;return(0,s.kt)(iVe,(0,p.Z)({},aVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}lVe.isMDXComponent=!0;const uVe={toc:[]},mVe="wrapper";function dVe(t){let{components:e,...n}=t;return(0,s.kt)(mVe,(0,p.Z)({},uVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}dVe.isMDXComponent=!0;const hVe={toc:[]},fVe="wrapper";function kVe(t){let{components:e,...n}=t;return(0,s.kt)(fVe,(0,p.Z)({},hVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}kVe.isMDXComponent=!0;const yVe={toc:[]},DVe="wrapper";function MVe(t){let{components:e,...n}=t;return(0,s.kt)(DVe,(0,p.Z)({},yVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}MVe.isMDXComponent=!0;const XVe={toc:[]},_Ve="wrapper";function wVe(t){let{components:e,...n}=t;return(0,s.kt)(_Ve,(0,p.Z)({},XVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}wVe.isMDXComponent=!0;const TVe={toc:[]},CVe="wrapper";function xVe(t){let{components:e,...n}=t;return(0,s.kt)(CVe,(0,p.Z)({},TVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}xVe.isMDXComponent=!0;const gVe={toc:[]},vVe="wrapper";function LVe(t){let{components:e,...n}=t;return(0,s.kt)(vVe,(0,p.Z)({},gVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}LVe.isMDXComponent=!0;const ZVe={toc:[]},bVe="wrapper";function NVe(t){let{components:e,...n}=t;return(0,s.kt)(bVe,(0,p.Z)({},ZVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}NVe.isMDXComponent=!0;const zVe={toc:[]},AVe="wrapper";function PVe(t){let{components:e,...n}=t;return(0,s.kt)(AVe,(0,p.Z)({},zVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}PVe.isMDXComponent=!0;const WVe={toc:[]},RVe="wrapper";function IVe(t){let{components:e,...n}=t;return(0,s.kt)(RVe,(0,p.Z)({},WVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}IVe.isMDXComponent=!0;const SVe={toc:[]},BVe="wrapper";function GVe(t){let{components:e,...n}=t;return(0,s.kt)(BVe,(0,p.Z)({},SVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}GVe.isMDXComponent=!0;const EVe={toc:[]},OVe="wrapper";function FVe(t){let{components:e,...n}=t;return(0,s.kt)(OVe,(0,p.Z)({},EVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}FVe.isMDXComponent=!0;const UVe={toc:[]},VVe="wrapper";function qVe(t){let{components:e,...n}=t;return(0,s.kt)(VVe,(0,p.Z)({},UVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qVe.isMDXComponent=!0;const jVe={toc:[]},YVe="wrapper";function QVe(t){let{components:e,...n}=t;return(0,s.kt)(YVe,(0,p.Z)({},jVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}QVe.isMDXComponent=!0;const HVe={toc:[]},KVe="wrapper";function $Ve(t){let{components:e,...n}=t;return(0,s.kt)(KVe,(0,p.Z)({},HVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}$Ve.isMDXComponent=!0;const JVe={toc:[]},tqe="wrapper";function eqe(t){let{components:e,...n}=t;return(0,s.kt)(tqe,(0,p.Z)({},JVe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}eqe.isMDXComponent=!0;const nqe={toc:[]},oqe="wrapper";function pqe(t){let{components:e,...n}=t;return(0,s.kt)(oqe,(0,p.Z)({},nqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}pqe.isMDXComponent=!0;const rqe={toc:[]},sqe="wrapper";function cqe(t){let{components:e,...n}=t;return(0,s.kt)(sqe,(0,p.Z)({},rqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}cqe.isMDXComponent=!0;const aqe={toc:[]},iqe="wrapper";function lqe(t){let{components:e,...n}=t;return(0,s.kt)(iqe,(0,p.Z)({},aqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lqe.isMDXComponent=!0;const uqe={toc:[]},mqe="wrapper";function dqe(t){let{components:e,...n}=t;return(0,s.kt)(mqe,(0,p.Z)({},uqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}dqe.isMDXComponent=!0;const hqe={toc:[]},fqe="wrapper";function kqe(t){let{components:e,...n}=t;return(0,s.kt)(fqe,(0,p.Z)({},hqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kqe.isMDXComponent=!0;const yqe={toc:[]},Dqe="wrapper";function Mqe(t){let{components:e,...n}=t;return(0,s.kt)(Dqe,(0,p.Z)({},yqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Mqe.isMDXComponent=!0;const Xqe={toc:[]},_qe="wrapper";function wqe(t){let{components:e,...n}=t;return(0,s.kt)(_qe,(0,p.Z)({},Xqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wqe.isMDXComponent=!0;const Tqe={toc:[]},Cqe="wrapper";function xqe(t){let{components:e,...n}=t;return(0,s.kt)(Cqe,(0,p.Z)({},Tqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}xqe.isMDXComponent=!0;const gqe={toc:[]},vqe="wrapper";function Lqe(t){let{components:e,...n}=t;return(0,s.kt)(vqe,(0,p.Z)({},gqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lqe.isMDXComponent=!0;const Zqe={toc:[]},bqe="wrapper";function Nqe(t){let{components:e,...n}=t;return(0,s.kt)(bqe,(0,p.Z)({},Zqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Nqe.isMDXComponent=!0;const zqe={toc:[]},Aqe="wrapper";function Pqe(t){let{components:e,...n}=t;return(0,s.kt)(Aqe,(0,p.Z)({},zqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Pqe.isMDXComponent=!0;const Wqe={toc:[]},Rqe="wrapper";function Iqe(t){let{components:e,...n}=t;return(0,s.kt)(Rqe,(0,p.Z)({},Wqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Iqe.isMDXComponent=!0;const Sqe={toc:[]},Bqe="wrapper";function Gqe(t){let{components:e,...n}=t;return(0,s.kt)(Bqe,(0,p.Z)({},Sqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Gqe.isMDXComponent=!0;const Eqe={toc:[]},Oqe="wrapper";function Fqe(t){let{components:e,...n}=t;return(0,s.kt)(Oqe,(0,p.Z)({},Eqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Fqe.isMDXComponent=!0;const Uqe={toc:[]},Vqe="wrapper";function qqe(t){let{components:e,...n}=t;return(0,s.kt)(Vqe,(0,p.Z)({},Uqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qqe.isMDXComponent=!0;const jqe={toc:[]},Yqe="wrapper";function Qqe(t){let{components:e,...n}=t;return(0,s.kt)(Yqe,(0,p.Z)({},jqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Qqe.isMDXComponent=!0;const Hqe={toc:[]},Kqe="wrapper";function $qe(t){let{components:e,...n}=t;return(0,s.kt)(Kqe,(0,p.Z)({},Hqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}$qe.isMDXComponent=!0;const Jqe={toc:[]},tje="wrapper";function eje(t){let{components:e,...n}=t;return(0,s.kt)(tje,(0,p.Z)({},Jqe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}eje.isMDXComponent=!0;const nje={toc:[]},oje="wrapper";function pje(t){let{components:e,...n}=t;return(0,s.kt)(oje,(0,p.Z)({},nje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}pje.isMDXComponent=!0;const rje={toc:[]},sje="wrapper";function cje(t){let{components:e,...n}=t;return(0,s.kt)(sje,(0,p.Z)({},rje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}cje.isMDXComponent=!0;const aje={toc:[]},ije="wrapper";function lje(t){let{components:e,...n}=t;return(0,s.kt)(ije,(0,p.Z)({},aje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}lje.isMDXComponent=!0;const uje={toc:[]},mje="wrapper";function dje(t){let{components:e,...n}=t;return(0,s.kt)(mje,(0,p.Z)({},uje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}dje.isMDXComponent=!0;const hje={toc:[]},fje="wrapper";function kje(t){let{components:e,...n}=t;return(0,s.kt)(fje,(0,p.Z)({},hje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}kje.isMDXComponent=!0;const yje={toc:[]},Dje="wrapper";function Mje(t){let{components:e,...n}=t;return(0,s.kt)(Dje,(0,p.Z)({},yje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}Mje.isMDXComponent=!0;const Xje={toc:[]},_je="wrapper";function wje(t){let{components:e,...n}=t;return(0,s.kt)(_je,(0,p.Z)({},Xje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}wje.isMDXComponent=!0;const Tje={toc:[]},Cje="wrapper";function xje(t){let{components:e,...n}=t;return(0,s.kt)(Cje,(0,p.Z)({},Tje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}xje.isMDXComponent=!0;const gje={toc:[]},vje="wrapper";function Lje(t){let{components:e,...n}=t;return(0,s.kt)(vje,(0,p.Z)({},gje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Lje.isMDXComponent=!0;const Zje={toc:[]},bje="wrapper";function Nje(t){let{components:e,...n}=t;return(0,s.kt)(bje,(0,p.Z)({},Zje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Nje.isMDXComponent=!0;const zje={toc:[]},Aje="wrapper";function Pje(t){let{components:e,...n}=t;return(0,s.kt)(Aje,(0,p.Z)({},zje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Pje.isMDXComponent=!0;const Wje={toc:[]},Rje="wrapper";function Ije(t){let{components:e,...n}=t;return(0,s.kt)(Rje,(0,p.Z)({},Wje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Ije.isMDXComponent=!0;const Sje={toc:[]},Bje="wrapper";function Gje(t){let{components:e,...n}=t;return(0,s.kt)(Bje,(0,p.Z)({},Sje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Gje.isMDXComponent=!0;const Eje={toc:[]},Oje="wrapper";function Fje(t){let{components:e,...n}=t;return(0,s.kt)(Oje,(0,p.Z)({},Eje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Fje.isMDXComponent=!0;const Uje={toc:[]},Vje="wrapper";function qje(t){let{components:e,...n}=t;return(0,s.kt)(Vje,(0,p.Z)({},Uje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}qje.isMDXComponent=!0;const jje={toc:[]},Yje="wrapper";function Qje(t){let{components:e,...n}=t;return(0,s.kt)(Yje,(0,p.Z)({},jje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Qje.isMDXComponent=!0;const Hje={toc:[]},Kje="wrapper";function $je(t){let{components:e,...n}=t;return(0,s.kt)(Kje,(0,p.Z)({},Hje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}$je.isMDXComponent=!0;const Jje={toc:[]},tYe="wrapper";function eYe(t){let{components:e,...n}=t;return(0,s.kt)(tYe,(0,p.Z)({},Jje,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}eYe.isMDXComponent=!0;const nYe={toc:[]},oYe="wrapper";function pYe(t){let{components:e,...n}=t;return(0,s.kt)(oYe,(0,p.Z)({},nYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}pYe.isMDXComponent=!0;const rYe={toc:[]},sYe="wrapper";function cYe(t){let{components:e,...n}=t;return(0,s.kt)(sYe,(0,p.Z)({},rYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}cYe.isMDXComponent=!0;const aYe={toc:[]},iYe="wrapper";function lYe(t){let{components:e,...n}=t;return(0,s.kt)(iYe,(0,p.Z)({},aYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}lYe.isMDXComponent=!0;const uYe={toc:[]},mYe="wrapper";function dYe(t){let{components:e,...n}=t;return(0,s.kt)(mYe,(0,p.Z)({},uYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}dYe.isMDXComponent=!0;const hYe={toc:[]},fYe="wrapper";function kYe(t){let{components:e,...n}=t;return(0,s.kt)(fYe,(0,p.Z)({},hYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}kYe.isMDXComponent=!0;const yYe={toc:[]},DYe="wrapper";function MYe(t){let{components:e,...n}=t;return(0,s.kt)(DYe,(0,p.Z)({},yYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}MYe.isMDXComponent=!0;const XYe={toc:[]},_Ye="wrapper";function wYe(t){let{components:e,...n}=t;return(0,s.kt)(_Ye,(0,p.Z)({},XYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}wYe.isMDXComponent=!0;const TYe={toc:[]},CYe="wrapper";function xYe(t){let{components:e,...n}=t;return(0,s.kt)(CYe,(0,p.Z)({},TYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}xYe.isMDXComponent=!0;const gYe={toc:[]},vYe="wrapper";function LYe(t){let{components:e,...n}=t;return(0,s.kt)(vYe,(0,p.Z)({},gYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}LYe.isMDXComponent=!0;const ZYe={toc:[]},bYe="wrapper";function NYe(t){let{components:e,...n}=t;return(0,s.kt)(bYe,(0,p.Z)({},ZYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}NYe.isMDXComponent=!0;const zYe={toc:[]},AYe="wrapper";function PYe(t){let{components:e,...n}=t;return(0,s.kt)(AYe,(0,p.Z)({},zYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}PYe.isMDXComponent=!0;const WYe={toc:[]},RYe="wrapper";function IYe(t){let{components:e,...n}=t;return(0,s.kt)(RYe,(0,p.Z)({},WYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}IYe.isMDXComponent=!0;const SYe={toc:[]},BYe="wrapper";function GYe(t){let{components:e,...n}=t;return(0,s.kt)(BYe,(0,p.Z)({},SYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}GYe.isMDXComponent=!0;const EYe={toc:[]},OYe="wrapper";function FYe(t){let{components:e,...n}=t;return(0,s.kt)(OYe,(0,p.Z)({},EYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}FYe.isMDXComponent=!0;const UYe={toc:[]},VYe="wrapper";function qYe(t){let{components:e,...n}=t;return(0,s.kt)(VYe,(0,p.Z)({},UYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}qYe.isMDXComponent=!0;const jYe={toc:[]},YYe="wrapper";function QYe(t){let{components:e,...n}=t;return(0,s.kt)(YYe,(0,p.Z)({},jYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}QYe.isMDXComponent=!0;const HYe={toc:[]},KYe="wrapper";function $Ye(t){let{components:e,...n}=t;return(0,s.kt)(KYe,(0,p.Z)({},HYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}$Ye.isMDXComponent=!0;const JYe={toc:[]},tQe="wrapper";function eQe(t){let{components:e,...n}=t;return(0,s.kt)(tQe,(0,p.Z)({},JYe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}eQe.isMDXComponent=!0;const nQe={toc:[]},oQe="wrapper";function pQe(t){let{components:e,...n}=t;return(0,s.kt)(oQe,(0,p.Z)({},nQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}pQe.isMDXComponent=!0;const rQe={toc:[]},sQe="wrapper";function cQe(t){let{components:e,...n}=t;return(0,s.kt)(sQe,(0,p.Z)({},rQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}cQe.isMDXComponent=!0;const aQe={toc:[]},iQe="wrapper";function lQe(t){let{components:e,...n}=t;return(0,s.kt)(iQe,(0,p.Z)({},aQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}lQe.isMDXComponent=!0;const uQe={toc:[]},mQe="wrapper";function dQe(t){let{components:e,...n}=t;return(0,s.kt)(mQe,(0,p.Z)({},uQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}dQe.isMDXComponent=!0;const hQe={toc:[]},fQe="wrapper";function kQe(t){let{components:e,...n}=t;return(0,s.kt)(fQe,(0,p.Z)({},hQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}kQe.isMDXComponent=!0;const yQe={toc:[]},DQe="wrapper";function MQe(t){let{components:e,...n}=t;return(0,s.kt)(DQe,(0,p.Z)({},yQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}MQe.isMDXComponent=!0;const XQe={toc:[]},_Qe="wrapper";function wQe(t){let{components:e,...n}=t;return(0,s.kt)(_Qe,(0,p.Z)({},XQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}wQe.isMDXComponent=!0;const TQe={toc:[]},CQe="wrapper";function xQe(t){let{components:e,...n}=t;return(0,s.kt)(CQe,(0,p.Z)({},TQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}xQe.isMDXComponent=!0;const gQe={toc:[]},vQe="wrapper";function LQe(t){let{components:e,...n}=t;return(0,s.kt)(vQe,(0,p.Z)({},gQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}LQe.isMDXComponent=!0;const ZQe={toc:[]},bQe="wrapper";function NQe(t){let{components:e,...n}=t;return(0,s.kt)(bQe,(0,p.Z)({},ZQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}NQe.isMDXComponent=!0;const zQe={toc:[]},AQe="wrapper";function PQe(t){let{components:e,...n}=t;return(0,s.kt)(AQe,(0,p.Z)({},zQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}PQe.isMDXComponent=!0;const WQe={toc:[]},RQe="wrapper";function IQe(t){let{components:e,...n}=t;return(0,s.kt)(RQe,(0,p.Z)({},WQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}IQe.isMDXComponent=!0;const SQe={toc:[]},BQe="wrapper";function GQe(t){let{components:e,...n}=t;return(0,s.kt)(BQe,(0,p.Z)({},SQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}GQe.isMDXComponent=!0;const EQe={toc:[]},OQe="wrapper";function FQe(t){let{components:e,...n}=t;return(0,s.kt)(OQe,(0,p.Z)({},EQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}FQe.isMDXComponent=!0;const UQe={toc:[]},VQe="wrapper";function qQe(t){let{components:e,...n}=t;return(0,s.kt)(VQe,(0,p.Z)({},UQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}qQe.isMDXComponent=!0;const jQe={toc:[]},YQe="wrapper";function QQe(t){let{components:e,...n}=t;return(0,s.kt)(YQe,(0,p.Z)({},jQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}QQe.isMDXComponent=!0;const HQe={toc:[]},KQe="wrapper";function $Qe(t){let{components:e,...n}=t;return(0,s.kt)(KQe,(0,p.Z)({},HQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}$Qe.isMDXComponent=!0;const JQe={toc:[]},tHe="wrapper";function eHe(t){let{components:e,...n}=t;return(0,s.kt)(tHe,(0,p.Z)({},JQe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}eHe.isMDXComponent=!0;const nHe={toc:[]},oHe="wrapper";function pHe(t){let{components:e,...n}=t;return(0,s.kt)(oHe,(0,p.Z)({},nHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pHe.isMDXComponent=!0;const rHe={toc:[]},sHe="wrapper";function cHe(t){let{components:e,...n}=t;return(0,s.kt)(sHe,(0,p.Z)({},rHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}cHe.isMDXComponent=!0;const aHe={toc:[]},iHe="wrapper";function lHe(t){let{components:e,...n}=t;return(0,s.kt)(iHe,(0,p.Z)({},aHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}lHe.isMDXComponent=!0;const uHe={toc:[]},mHe="wrapper";function dHe(t){let{components:e,...n}=t;return(0,s.kt)(mHe,(0,p.Z)({},uHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}dHe.isMDXComponent=!0;const hHe={toc:[]},fHe="wrapper";function kHe(t){let{components:e,...n}=t;return(0,s.kt)(fHe,(0,p.Z)({},hHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}kHe.isMDXComponent=!0;const yHe={toc:[]},DHe="wrapper";function MHe(t){let{components:e,...n}=t;return(0,s.kt)(DHe,(0,p.Z)({},yHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}MHe.isMDXComponent=!0;const XHe={toc:[]},_He="wrapper";function wHe(t){let{components:e,...n}=t;return(0,s.kt)(_He,(0,p.Z)({},XHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}wHe.isMDXComponent=!0;const THe={toc:[]},CHe="wrapper";function xHe(t){let{components:e,...n}=t;return(0,s.kt)(CHe,(0,p.Z)({},THe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}xHe.isMDXComponent=!0;const gHe={toc:[]},vHe="wrapper";function LHe(t){let{components:e,...n}=t;return(0,s.kt)(vHe,(0,p.Z)({},gHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}LHe.isMDXComponent=!0;const ZHe={toc:[]},bHe="wrapper";function NHe(t){let{components:e,...n}=t;return(0,s.kt)(bHe,(0,p.Z)({},ZHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}NHe.isMDXComponent=!0;const zHe={toc:[]},AHe="wrapper";function PHe(t){let{components:e,...n}=t;return(0,s.kt)(AHe,(0,p.Z)({},zHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}PHe.isMDXComponent=!0;const WHe={toc:[]},RHe="wrapper";function IHe(t){let{components:e,...n}=t;return(0,s.kt)(RHe,(0,p.Z)({},WHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}IHe.isMDXComponent=!0;const SHe={toc:[]},BHe="wrapper";function GHe(t){let{components:e,...n}=t;return(0,s.kt)(BHe,(0,p.Z)({},SHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}GHe.isMDXComponent=!0;const EHe={toc:[]},OHe="wrapper";function FHe(t){let{components:e,...n}=t;return(0,s.kt)(OHe,(0,p.Z)({},EHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}FHe.isMDXComponent=!0;const UHe={toc:[]},VHe="wrapper";function qHe(t){let{components:e,...n}=t;return(0,s.kt)(VHe,(0,p.Z)({},UHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}qHe.isMDXComponent=!0;const jHe={toc:[]},YHe="wrapper";function QHe(t){let{components:e,...n}=t;return(0,s.kt)(YHe,(0,p.Z)({},jHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}QHe.isMDXComponent=!0;const HHe={toc:[]},KHe="wrapper";function $He(t){let{components:e,...n}=t;return(0,s.kt)(KHe,(0,p.Z)({},HHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}$He.isMDXComponent=!0;const JHe={toc:[]},tKe="wrapper";function eKe(t){let{components:e,...n}=t;return(0,s.kt)(tKe,(0,p.Z)({},JHe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}eKe.isMDXComponent=!0;const nKe={toc:[]},oKe="wrapper";function pKe(t){let{components:e,...n}=t;return(0,s.kt)(oKe,(0,p.Z)({},nKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}pKe.isMDXComponent=!0;const rKe={toc:[]},sKe="wrapper";function cKe(t){let{components:e,...n}=t;return(0,s.kt)(sKe,(0,p.Z)({},rKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}cKe.isMDXComponent=!0;const aKe={toc:[]},iKe="wrapper";function lKe(t){let{components:e,...n}=t;return(0,s.kt)(iKe,(0,p.Z)({},aKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}lKe.isMDXComponent=!0;const uKe={toc:[]},mKe="wrapper";function dKe(t){let{components:e,...n}=t;return(0,s.kt)(mKe,(0,p.Z)({},uKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}dKe.isMDXComponent=!0;const hKe={toc:[]},fKe="wrapper";function kKe(t){let{components:e,...n}=t;return(0,s.kt)(fKe,(0,p.Z)({},hKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}kKe.isMDXComponent=!0;const yKe={toc:[]},DKe="wrapper";function MKe(t){let{components:e,...n}=t;return(0,s.kt)(DKe,(0,p.Z)({},yKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}MKe.isMDXComponent=!0;const XKe={toc:[]},_Ke="wrapper";function wKe(t){let{components:e,...n}=t;return(0,s.kt)(_Ke,(0,p.Z)({},XKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}wKe.isMDXComponent=!0;const TKe={toc:[]},CKe="wrapper";function xKe(t){let{components:e,...n}=t;return(0,s.kt)(CKe,(0,p.Z)({},TKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}xKe.isMDXComponent=!0;const gKe={toc:[]},vKe="wrapper";function LKe(t){let{components:e,...n}=t;return(0,s.kt)(vKe,(0,p.Z)({},gKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}LKe.isMDXComponent=!0;const ZKe={toc:[]},bKe="wrapper";function NKe(t){let{components:e,...n}=t;return(0,s.kt)(bKe,(0,p.Z)({},ZKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}NKe.isMDXComponent=!0;const zKe={toc:[]},AKe="wrapper";function PKe(t){let{components:e,...n}=t;return(0,s.kt)(AKe,(0,p.Z)({},zKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}PKe.isMDXComponent=!0;const WKe={toc:[]},RKe="wrapper";function IKe(t){let{components:e,...n}=t;return(0,s.kt)(RKe,(0,p.Z)({},WKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}IKe.isMDXComponent=!0;const SKe={toc:[]},BKe="wrapper";function GKe(t){let{components:e,...n}=t;return(0,s.kt)(BKe,(0,p.Z)({},SKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}GKe.isMDXComponent=!0;const EKe={toc:[]},OKe="wrapper";function FKe(t){let{components:e,...n}=t;return(0,s.kt)(OKe,(0,p.Z)({},EKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}FKe.isMDXComponent=!0;const UKe={toc:[]},VKe="wrapper";function qKe(t){let{components:e,...n}=t;return(0,s.kt)(VKe,(0,p.Z)({},UKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qKe.isMDXComponent=!0;const jKe={toc:[]},YKe="wrapper";function QKe(t){let{components:e,...n}=t;return(0,s.kt)(YKe,(0,p.Z)({},jKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}QKe.isMDXComponent=!0;const HKe={toc:[]},KKe="wrapper";function $Ke(t){let{components:e,...n}=t;return(0,s.kt)(KKe,(0,p.Z)({},HKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}$Ke.isMDXComponent=!0;const JKe={toc:[]},t$e="wrapper";function e$e(t){let{components:e,...n}=t;return(0,s.kt)(t$e,(0,p.Z)({},JKe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}e$e.isMDXComponent=!0;const n$e={toc:[]},o$e="wrapper";function p$e(t){let{components:e,...n}=t;return(0,s.kt)(o$e,(0,p.Z)({},n$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Line#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}p$e.isMDXComponent=!0;const r$e={toc:[]},s$e="wrapper";function c$e(t){let{components:e,...n}=t;return(0,s.kt)(s$e,(0,p.Z)({},r$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}c$e.isMDXComponent=!0;const a$e={toc:[]},i$e="wrapper";function l$e(t){let{components:e,...n}=t;return(0,s.kt)(i$e,(0,p.Z)({},a$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}l$e.isMDXComponent=!0;const u$e={toc:[]},m$e="wrapper";function d$e(t){let{components:e,...n}=t;return(0,s.kt)(m$e,(0,p.Z)({},u$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}d$e.isMDXComponent=!0;const h$e={toc:[]},f$e="wrapper";function k$e(t){let{components:e,...n}=t;return(0,s.kt)(f$e,(0,p.Z)({},h$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}k$e.isMDXComponent=!0;const y$e={toc:[]},D$e="wrapper";function M$e(t){let{components:e,...n}=t;return(0,s.kt)(D$e,(0,p.Z)({},y$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}M$e.isMDXComponent=!0;const X$e={toc:[]},_$e="wrapper";function w$e(t){let{components:e,...n}=t;return(0,s.kt)(_$e,(0,p.Z)({},X$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}w$e.isMDXComponent=!0;const T$e={toc:[]},C$e="wrapper";function x$e(t){let{components:e,...n}=t;return(0,s.kt)(C$e,(0,p.Z)({},T$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}x$e.isMDXComponent=!0;const g$e={toc:[]},v$e="wrapper";function L$e(t){let{components:e,...n}=t;return(0,s.kt)(v$e,(0,p.Z)({},g$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}L$e.isMDXComponent=!0;const Z$e={toc:[]},b$e="wrapper";function N$e(t){let{components:e,...n}=t;return(0,s.kt)(b$e,(0,p.Z)({},Z$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}N$e.isMDXComponent=!0;const z$e={toc:[]},A$e="wrapper";function P$e(t){let{components:e,...n}=t;return(0,s.kt)(A$e,(0,p.Z)({},z$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}P$e.isMDXComponent=!0;const W$e={toc:[]},R$e="wrapper";function I$e(t){let{components:e,...n}=t;return(0,s.kt)(R$e,(0,p.Z)({},W$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}I$e.isMDXComponent=!0;const S$e={toc:[]},B$e="wrapper";function G$e(t){let{components:e,...n}=t;return(0,s.kt)(B$e,(0,p.Z)({},S$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}G$e.isMDXComponent=!0;const E$e={toc:[]},O$e="wrapper";function F$e(t){let{components:e,...n}=t;return(0,s.kt)(O$e,(0,p.Z)({},E$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}F$e.isMDXComponent=!0;const U$e={toc:[]},V$e="wrapper";function q$e(t){let{components:e,...n}=t;return(0,s.kt)(V$e,(0,p.Z)({},U$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}q$e.isMDXComponent=!0;const j$e={toc:[]},Y$e="wrapper";function Q$e(t){let{components:e,...n}=t;return(0,s.kt)(Y$e,(0,p.Z)({},j$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Q$e.isMDXComponent=!0;const H$e={toc:[]},K$e="wrapper";function $$e(t){let{components:e,...n}=t;return(0,s.kt)(K$e,(0,p.Z)({},H$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}$$e.isMDXComponent=!0;const J$e={toc:[]},tJe="wrapper";function eJe(t){let{components:e,...n}=t;return(0,s.kt)(tJe,(0,p.Z)({},J$e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}eJe.isMDXComponent=!0;const nJe={toc:[]},oJe="wrapper";function pJe(t){let{components:e,...n}=t;return(0,s.kt)(oJe,(0,p.Z)({},nJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}pJe.isMDXComponent=!0;const rJe={toc:[]},sJe="wrapper";function cJe(t){let{components:e,...n}=t;return(0,s.kt)(sJe,(0,p.Z)({},rJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}cJe.isMDXComponent=!0;const aJe={toc:[]},iJe="wrapper";function lJe(t){let{components:e,...n}=t;return(0,s.kt)(iJe,(0,p.Z)({},aJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}lJe.isMDXComponent=!0;const uJe={toc:[]},mJe="wrapper";function dJe(t){let{components:e,...n}=t;return(0,s.kt)(mJe,(0,p.Z)({},uJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}dJe.isMDXComponent=!0;const hJe={toc:[]},fJe="wrapper";function kJe(t){let{components:e,...n}=t;return(0,s.kt)(fJe,(0,p.Z)({},hJe,n,{components:e,mdxType:"MDXLayout"}))}kJe.isMDXComponent=!0;const yJe={toc:[]},DJe="wrapper";function MJe(t){let{components:e,...n}=t;return(0,s.kt)(DJe,(0,p.Z)({},yJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}MJe.isMDXComponent=!0;const XJe={toc:[]},_Je="wrapper";function wJe(t){let{components:e,...n}=t;return(0,s.kt)(_Je,(0,p.Z)({},XJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}wJe.isMDXComponent=!0;const TJe={toc:[]},CJe="wrapper";function xJe(t){let{components:e,...n}=t;return(0,s.kt)(CJe,(0,p.Z)({},TJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}xJe.isMDXComponent=!0;const gJe={toc:[]},vJe="wrapper";function LJe(t){let{components:e,...n}=t;return(0,s.kt)(vJe,(0,p.Z)({},gJe,n,{components:e,mdxType:"MDXLayout"}))}LJe.isMDXComponent=!0;const ZJe={toc:[]},bJe="wrapper";function NJe(t){let{components:e,...n}=t;return(0,s.kt)(bJe,(0,p.Z)({},ZJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}NJe.isMDXComponent=!0;const zJe={toc:[]},AJe="wrapper";function PJe(t){let{components:e,...n}=t;return(0,s.kt)(AJe,(0,p.Z)({},zJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}PJe.isMDXComponent=!0;const WJe={toc:[]},RJe="wrapper";function IJe(t){let{components:e,...n}=t;return(0,s.kt)(RJe,(0,p.Z)({},WJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}IJe.isMDXComponent=!0;const SJe={toc:[]},BJe="wrapper";function GJe(t){let{components:e,...n}=t;return(0,s.kt)(BJe,(0,p.Z)({},SJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}GJe.isMDXComponent=!0;const EJe={toc:[]},OJe="wrapper";function FJe(t){let{components:e,...n}=t;return(0,s.kt)(OJe,(0,p.Z)({},EJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}FJe.isMDXComponent=!0;const UJe={toc:[]},VJe="wrapper";function qJe(t){let{components:e,...n}=t;return(0,s.kt)(VJe,(0,p.Z)({},UJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}qJe.isMDXComponent=!0;const jJe={toc:[]},YJe="wrapper";function QJe(t){let{components:e,...n}=t;return(0,s.kt)(YJe,(0,p.Z)({},jJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}QJe.isMDXComponent=!0;const HJe={toc:[]},KJe="wrapper";function $Je(t){let{components:e,...n}=t;return(0,s.kt)(KJe,(0,p.Z)({},HJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}$Je.isMDXComponent=!0;const JJe={toc:[]},t0e="wrapper";function e0e(t){let{components:e,...n}=t;return(0,s.kt)(t0e,(0,p.Z)({},JJe,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}e0e.isMDXComponent=!0;const n0e={toc:[]},o0e="wrapper";function p0e(t){let{components:e,...n}=t;return(0,s.kt)(o0e,(0,p.Z)({},n0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}p0e.isMDXComponent=!0;const r0e={toc:[]},s0e="wrapper";function c0e(t){let{components:e,...n}=t;return(0,s.kt)(s0e,(0,p.Z)({},r0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}c0e.isMDXComponent=!0;const a0e={toc:[]},i0e="wrapper";function l0e(t){let{components:e,...n}=t;return(0,s.kt)(i0e,(0,p.Z)({},a0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}l0e.isMDXComponent=!0;const u0e={toc:[]},m0e="wrapper";function d0e(t){let{components:e,...n}=t;return(0,s.kt)(m0e,(0,p.Z)({},u0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}d0e.isMDXComponent=!0;const h0e={toc:[]},f0e="wrapper";function k0e(t){let{components:e,...n}=t;return(0,s.kt)(f0e,(0,p.Z)({},h0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}k0e.isMDXComponent=!0;const y0e={toc:[]},D0e="wrapper";function M0e(t){let{components:e,...n}=t;return(0,s.kt)(D0e,(0,p.Z)({},y0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}M0e.isMDXComponent=!0;const X0e={toc:[]},_0e="wrapper";function w0e(t){let{components:e,...n}=t;return(0,s.kt)(_0e,(0,p.Z)({},X0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}w0e.isMDXComponent=!0;const T0e={toc:[]},C0e="wrapper";function x0e(t){let{components:e,...n}=t;return(0,s.kt)(C0e,(0,p.Z)({},T0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}x0e.isMDXComponent=!0;const g0e={toc:[]},v0e="wrapper";function L0e(t){let{components:e,...n}=t;return(0,s.kt)(v0e,(0,p.Z)({},g0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}L0e.isMDXComponent=!0;const Z0e={toc:[]},b0e="wrapper";function N0e(t){let{components:e,...n}=t;return(0,s.kt)(b0e,(0,p.Z)({},Z0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}N0e.isMDXComponent=!0;const z0e={toc:[]},A0e="wrapper";function P0e(t){let{components:e,...n}=t;return(0,s.kt)(A0e,(0,p.Z)({},z0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}P0e.isMDXComponent=!0;const W0e={toc:[]},R0e="wrapper";function I0e(t){let{components:e,...n}=t;return(0,s.kt)(R0e,(0,p.Z)({},W0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}I0e.isMDXComponent=!0;const S0e={toc:[]},B0e="wrapper";function G0e(t){let{components:e,...n}=t;return(0,s.kt)(B0e,(0,p.Z)({},S0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}G0e.isMDXComponent=!0;const E0e={toc:[]},O0e="wrapper";function F0e(t){let{components:e,...n}=t;return(0,s.kt)(O0e,(0,p.Z)({},E0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}F0e.isMDXComponent=!0;const U0e={toc:[]},V0e="wrapper";function q0e(t){let{components:e,...n}=t;return(0,s.kt)(V0e,(0,p.Z)({},U0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}q0e.isMDXComponent=!0;const j0e={toc:[]},Y0e="wrapper";function Q0e(t){let{components:e,...n}=t;return(0,s.kt)(Y0e,(0,p.Z)({},j0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Q0e.isMDXComponent=!0;const H0e={toc:[]},K0e="wrapper";function $0e(t){let{components:e,...n}=t;return(0,s.kt)(K0e,(0,p.Z)({},H0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}$0e.isMDXComponent=!0;const J0e={toc:[]},t4e="wrapper";function e4e(t){let{components:e,...n}=t;return(0,s.kt)(t4e,(0,p.Z)({},J0e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}e4e.isMDXComponent=!0;const n4e={toc:[]},o4e="wrapper";function p4e(t){let{components:e,...n}=t;return(0,s.kt)(o4e,(0,p.Z)({},n4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}p4e.isMDXComponent=!0;const r4e={toc:[]},s4e="wrapper";function c4e(t){let{components:e,...n}=t;return(0,s.kt)(s4e,(0,p.Z)({},r4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}c4e.isMDXComponent=!0;const a4e={toc:[]},i4e="wrapper";function l4e(t){let{components:e,...n}=t;return(0,s.kt)(i4e,(0,p.Z)({},a4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}l4e.isMDXComponent=!0;const u4e={toc:[]},m4e="wrapper";function d4e(t){let{components:e,...n}=t;return(0,s.kt)(m4e,(0,p.Z)({},u4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}d4e.isMDXComponent=!0;const h4e={toc:[]},f4e="wrapper";function k4e(t){let{components:e,...n}=t;return(0,s.kt)(f4e,(0,p.Z)({},h4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}k4e.isMDXComponent=!0;const y4e={toc:[]},D4e="wrapper";function M4e(t){let{components:e,...n}=t;return(0,s.kt)(D4e,(0,p.Z)({},y4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}M4e.isMDXComponent=!0;const X4e={toc:[]},_4e="wrapper";function w4e(t){let{components:e,...n}=t;return(0,s.kt)(_4e,(0,p.Z)({},X4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}w4e.isMDXComponent=!0;const T4e={toc:[]},C4e="wrapper";function x4e(t){let{components:e,...n}=t;return(0,s.kt)(C4e,(0,p.Z)({},T4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}x4e.isMDXComponent=!0;const g4e={toc:[]},v4e="wrapper";function L4e(t){let{components:e,...n}=t;return(0,s.kt)(v4e,(0,p.Z)({},g4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}L4e.isMDXComponent=!0;const Z4e={toc:[]},b4e="wrapper";function N4e(t){let{components:e,...n}=t;return(0,s.kt)(b4e,(0,p.Z)({},Z4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}N4e.isMDXComponent=!0;const z4e={toc:[]},A4e="wrapper";function P4e(t){let{components:e,...n}=t;return(0,s.kt)(A4e,(0,p.Z)({},z4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}P4e.isMDXComponent=!0;const W4e={toc:[]},R4e="wrapper";function I4e(t){let{components:e,...n}=t;return(0,s.kt)(R4e,(0,p.Z)({},W4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}I4e.isMDXComponent=!0;const S4e={toc:[]},B4e="wrapper";function G4e(t){let{components:e,...n}=t;return(0,s.kt)(B4e,(0,p.Z)({},S4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}G4e.isMDXComponent=!0;const E4e={toc:[]},O4e="wrapper";function F4e(t){let{components:e,...n}=t;return(0,s.kt)(O4e,(0,p.Z)({},E4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}F4e.isMDXComponent=!0;const U4e={toc:[]},V4e="wrapper";function q4e(t){let{components:e,...n}=t;return(0,s.kt)(V4e,(0,p.Z)({},U4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}q4e.isMDXComponent=!0;const j4e={toc:[]},Y4e="wrapper";function Q4e(t){let{components:e,...n}=t;return(0,s.kt)(Y4e,(0,p.Z)({},j4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Q4e.isMDXComponent=!0;const H4e={toc:[]},K4e="wrapper";function $4e(t){let{components:e,...n}=t;return(0,s.kt)(K4e,(0,p.Z)({},H4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}$4e.isMDXComponent=!0;const J4e={toc:[]},t6e="wrapper";function e6e(t){let{components:e,...n}=t;return(0,s.kt)(t6e,(0,p.Z)({},J4e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}e6e.isMDXComponent=!0;const n6e={toc:[]},o6e="wrapper";function p6e(t){let{components:e,...n}=t;return(0,s.kt)(o6e,(0,p.Z)({},n6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}p6e.isMDXComponent=!0;const r6e={toc:[]},s6e="wrapper";function c6e(t){let{components:e,...n}=t;return(0,s.kt)(s6e,(0,p.Z)({},r6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}c6e.isMDXComponent=!0;const a6e={toc:[]},i6e="wrapper";function l6e(t){let{components:e,...n}=t;return(0,s.kt)(i6e,(0,p.Z)({},a6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}l6e.isMDXComponent=!0;const u6e={toc:[]},m6e="wrapper";function d6e(t){let{components:e,...n}=t;return(0,s.kt)(m6e,(0,p.Z)({},u6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}d6e.isMDXComponent=!0;const h6e={toc:[]},f6e="wrapper";function k6e(t){let{components:e,...n}=t;return(0,s.kt)(f6e,(0,p.Z)({},h6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}k6e.isMDXComponent=!0;const y6e={toc:[]},D6e="wrapper";function M6e(t){let{components:e,...n}=t;return(0,s.kt)(D6e,(0,p.Z)({},y6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}M6e.isMDXComponent=!0;const X6e={toc:[]},_6e="wrapper";function w6e(t){let{components:e,...n}=t;return(0,s.kt)(_6e,(0,p.Z)({},X6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}w6e.isMDXComponent=!0;const T6e={toc:[]},C6e="wrapper";function x6e(t){let{components:e,...n}=t;return(0,s.kt)(C6e,(0,p.Z)({},T6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}x6e.isMDXComponent=!0;const g6e={toc:[]},v6e="wrapper";function L6e(t){let{components:e,...n}=t;return(0,s.kt)(v6e,(0,p.Z)({},g6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}L6e.isMDXComponent=!0;const Z6e={toc:[]},b6e="wrapper";function N6e(t){let{components:e,...n}=t;return(0,s.kt)(b6e,(0,p.Z)({},Z6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}N6e.isMDXComponent=!0;const z6e={toc:[]},A6e="wrapper";function P6e(t){let{components:e,...n}=t;return(0,s.kt)(A6e,(0,p.Z)({},z6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}P6e.isMDXComponent=!0;const W6e={toc:[]},R6e="wrapper";function I6e(t){let{components:e,...n}=t;return(0,s.kt)(R6e,(0,p.Z)({},W6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}I6e.isMDXComponent=!0;const S6e={toc:[]},B6e="wrapper";function G6e(t){let{components:e,...n}=t;return(0,s.kt)(B6e,(0,p.Z)({},S6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}G6e.isMDXComponent=!0;const E6e={toc:[]},O6e="wrapper";function F6e(t){let{components:e,...n}=t;return(0,s.kt)(O6e,(0,p.Z)({},E6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}F6e.isMDXComponent=!0;const U6e={toc:[]},V6e="wrapper";function q6e(t){let{components:e,...n}=t;return(0,s.kt)(V6e,(0,p.Z)({},U6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}q6e.isMDXComponent=!0;const j6e={toc:[]},Y6e="wrapper";function Q6e(t){let{components:e,...n}=t;return(0,s.kt)(Y6e,(0,p.Z)({},j6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Q6e.isMDXComponent=!0;const H6e={toc:[]},K6e="wrapper";function $6e(t){let{components:e,...n}=t;return(0,s.kt)(K6e,(0,p.Z)({},H6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}$6e.isMDXComponent=!0;const J6e={toc:[]},t3e="wrapper";function e3e(t){let{components:e,...n}=t;return(0,s.kt)(t3e,(0,p.Z)({},J6e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}e3e.isMDXComponent=!0;const n3e={toc:[]},o3e="wrapper";function p3e(t){let{components:e,...n}=t;return(0,s.kt)(o3e,(0,p.Z)({},n3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}p3e.isMDXComponent=!0;const r3e={toc:[]},s3e="wrapper";function c3e(t){let{components:e,...n}=t;return(0,s.kt)(s3e,(0,p.Z)({},r3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}c3e.isMDXComponent=!0;const a3e={toc:[]},i3e="wrapper";function l3e(t){let{components:e,...n}=t;return(0,s.kt)(i3e,(0,p.Z)({},a3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}l3e.isMDXComponent=!0;const u3e={toc:[]},m3e="wrapper";function d3e(t){let{components:e,...n}=t;return(0,s.kt)(m3e,(0,p.Z)({},u3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}d3e.isMDXComponent=!0;const h3e={toc:[]},f3e="wrapper";function k3e(t){let{components:e,...n}=t;return(0,s.kt)(f3e,(0,p.Z)({},h3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}k3e.isMDXComponent=!0;const y3e={toc:[]},D3e="wrapper";function M3e(t){let{components:e,...n}=t;return(0,s.kt)(D3e,(0,p.Z)({},y3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}M3e.isMDXComponent=!0;const X3e={toc:[]},_3e="wrapper";function w3e(t){let{components:e,...n}=t;return(0,s.kt)(_3e,(0,p.Z)({},X3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}w3e.isMDXComponent=!0;const T3e={toc:[]},C3e="wrapper";function x3e(t){let{components:e,...n}=t;return(0,s.kt)(C3e,(0,p.Z)({},T3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}x3e.isMDXComponent=!0;const g3e={toc:[]},v3e="wrapper";function L3e(t){let{components:e,...n}=t;return(0,s.kt)(v3e,(0,p.Z)({},g3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}L3e.isMDXComponent=!0;const Z3e={toc:[]},b3e="wrapper";function N3e(t){let{components:e,...n}=t;return(0,s.kt)(b3e,(0,p.Z)({},Z3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}N3e.isMDXComponent=!0;const z3e={toc:[]},A3e="wrapper";function P3e(t){let{components:e,...n}=t;return(0,s.kt)(A3e,(0,p.Z)({},z3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}P3e.isMDXComponent=!0;const W3e={toc:[]},R3e="wrapper";function I3e(t){let{components:e,...n}=t;return(0,s.kt)(R3e,(0,p.Z)({},W3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}I3e.isMDXComponent=!0;const S3e={toc:[]},B3e="wrapper";function G3e(t){let{components:e,...n}=t;return(0,s.kt)(B3e,(0,p.Z)({},S3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}G3e.isMDXComponent=!0;const E3e={toc:[]},O3e="wrapper";function F3e(t){let{components:e,...n}=t;return(0,s.kt)(O3e,(0,p.Z)({},E3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}F3e.isMDXComponent=!0;const U3e={toc:[]},V3e="wrapper";function q3e(t){let{components:e,...n}=t;return(0,s.kt)(V3e,(0,p.Z)({},U3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}q3e.isMDXComponent=!0;const j3e={toc:[]},Y3e="wrapper";function Q3e(t){let{components:e,...n}=t;return(0,s.kt)(Y3e,(0,p.Z)({},j3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Q3e.isMDXComponent=!0;const H3e={toc:[]},K3e="wrapper";function $3e(t){let{components:e,...n}=t;return(0,s.kt)(K3e,(0,p.Z)({},H3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}$3e.isMDXComponent=!0;const J3e={toc:[]},t7e="wrapper";function e7e(t){let{components:e,...n}=t;return(0,s.kt)(t7e,(0,p.Z)({},J3e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}e7e.isMDXComponent=!0;const n7e={toc:[]},o7e="wrapper";function p7e(t){let{components:e,...n}=t;return(0,s.kt)(o7e,(0,p.Z)({},n7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}p7e.isMDXComponent=!0;const r7e={toc:[]},s7e="wrapper";function c7e(t){let{components:e,...n}=t;return(0,s.kt)(s7e,(0,p.Z)({},r7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}c7e.isMDXComponent=!0;const a7e={toc:[]},i7e="wrapper";function l7e(t){let{components:e,...n}=t;return(0,s.kt)(i7e,(0,p.Z)({},a7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}l7e.isMDXComponent=!0;const u7e={toc:[]},m7e="wrapper";function d7e(t){let{components:e,...n}=t;return(0,s.kt)(m7e,(0,p.Z)({},u7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}d7e.isMDXComponent=!0;const h7e={toc:[]},f7e="wrapper";function k7e(t){let{components:e,...n}=t;return(0,s.kt)(f7e,(0,p.Z)({},h7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}k7e.isMDXComponent=!0;const y7e={toc:[]},D7e="wrapper";function M7e(t){let{components:e,...n}=t;return(0,s.kt)(D7e,(0,p.Z)({},y7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}M7e.isMDXComponent=!0;const X7e={toc:[]},_7e="wrapper";function w7e(t){let{components:e,...n}=t;return(0,s.kt)(_7e,(0,p.Z)({},X7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}w7e.isMDXComponent=!0;const T7e={toc:[]},C7e="wrapper";function x7e(t){let{components:e,...n}=t;return(0,s.kt)(C7e,(0,p.Z)({},T7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}x7e.isMDXComponent=!0;const g7e={toc:[]},v7e="wrapper";function L7e(t){let{components:e,...n}=t;return(0,s.kt)(v7e,(0,p.Z)({},g7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}L7e.isMDXComponent=!0;const Z7e={toc:[]},b7e="wrapper";function N7e(t){let{components:e,...n}=t;return(0,s.kt)(b7e,(0,p.Z)({},Z7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}N7e.isMDXComponent=!0;const z7e={toc:[]},A7e="wrapper";function P7e(t){let{components:e,...n}=t;return(0,s.kt)(A7e,(0,p.Z)({},z7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}P7e.isMDXComponent=!0;const W7e={toc:[]},R7e="wrapper";function I7e(t){let{components:e,...n}=t;return(0,s.kt)(R7e,(0,p.Z)({},W7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}I7e.isMDXComponent=!0;const S7e={toc:[]},B7e="wrapper";function G7e(t){let{components:e,...n}=t;return(0,s.kt)(B7e,(0,p.Z)({},S7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}G7e.isMDXComponent=!0;const E7e={toc:[]},O7e="wrapper";function F7e(t){let{components:e,...n}=t;return(0,s.kt)(O7e,(0,p.Z)({},E7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}F7e.isMDXComponent=!0;const U7e={toc:[]},V7e="wrapper";function q7e(t){let{components:e,...n}=t;return(0,s.kt)(V7e,(0,p.Z)({},U7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}q7e.isMDXComponent=!0;const j7e={toc:[]},Y7e="wrapper";function Q7e(t){let{components:e,...n}=t;return(0,s.kt)(Y7e,(0,p.Z)({},j7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Q7e.isMDXComponent=!0;const H7e={toc:[]},K7e="wrapper";function $7e(t){let{components:e,...n}=t;return(0,s.kt)(K7e,(0,p.Z)({},H7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}$7e.isMDXComponent=!0;const J7e={toc:[]},t2e="wrapper";function e2e(t){let{components:e,...n}=t;return(0,s.kt)(t2e,(0,p.Z)({},J7e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}e2e.isMDXComponent=!0;const n2e={toc:[]},o2e="wrapper";function p2e(t){let{components:e,...n}=t;return(0,s.kt)(o2e,(0,p.Z)({},n2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}p2e.isMDXComponent=!0;const r2e={toc:[]},s2e="wrapper";function c2e(t){let{components:e,...n}=t;return(0,s.kt)(s2e,(0,p.Z)({},r2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}c2e.isMDXComponent=!0;const a2e={toc:[]},i2e="wrapper";function l2e(t){let{components:e,...n}=t;return(0,s.kt)(i2e,(0,p.Z)({},a2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}l2e.isMDXComponent=!0;const u2e={toc:[]},m2e="wrapper";function d2e(t){let{components:e,...n}=t;return(0,s.kt)(m2e,(0,p.Z)({},u2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}d2e.isMDXComponent=!0;const h2e={toc:[]},f2e="wrapper";function k2e(t){let{components:e,...n}=t;return(0,s.kt)(f2e,(0,p.Z)({},h2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}k2e.isMDXComponent=!0;const y2e={toc:[]},D2e="wrapper";function M2e(t){let{components:e,...n}=t;return(0,s.kt)(D2e,(0,p.Z)({},y2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}M2e.isMDXComponent=!0;const X2e={toc:[]},_2e="wrapper";function w2e(t){let{components:e,...n}=t;return(0,s.kt)(_2e,(0,p.Z)({},X2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}w2e.isMDXComponent=!0;const T2e={toc:[]},C2e="wrapper";function x2e(t){let{components:e,...n}=t;return(0,s.kt)(C2e,(0,p.Z)({},T2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}x2e.isMDXComponent=!0;const g2e={toc:[]},v2e="wrapper";function L2e(t){let{components:e,...n}=t;return(0,s.kt)(v2e,(0,p.Z)({},g2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}L2e.isMDXComponent=!0;const Z2e={toc:[]},b2e="wrapper";function N2e(t){let{components:e,...n}=t;return(0,s.kt)(b2e,(0,p.Z)({},Z2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}N2e.isMDXComponent=!0;const z2e={toc:[]},A2e="wrapper";function P2e(t){let{components:e,...n}=t;return(0,s.kt)(A2e,(0,p.Z)({},z2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}P2e.isMDXComponent=!0;const W2e={toc:[]},R2e="wrapper";function I2e(t){let{components:e,...n}=t;return(0,s.kt)(R2e,(0,p.Z)({},W2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}I2e.isMDXComponent=!0;const S2e={toc:[]},B2e="wrapper";function G2e(t){let{components:e,...n}=t;return(0,s.kt)(B2e,(0,p.Z)({},S2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}G2e.isMDXComponent=!0;const E2e={toc:[]},O2e="wrapper";function F2e(t){let{components:e,...n}=t;return(0,s.kt)(O2e,(0,p.Z)({},E2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}F2e.isMDXComponent=!0;const U2e={toc:[]},V2e="wrapper";function q2e(t){let{components:e,...n}=t;return(0,s.kt)(V2e,(0,p.Z)({},U2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}q2e.isMDXComponent=!0;const j2e={toc:[]},Y2e="wrapper";function Q2e(t){let{components:e,...n}=t;return(0,s.kt)(Y2e,(0,p.Z)({},j2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Q2e.isMDXComponent=!0;const H2e={toc:[]},K2e="wrapper";function $2e(t){let{components:e,...n}=t;return(0,s.kt)(K2e,(0,p.Z)({},H2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}$2e.isMDXComponent=!0;const J2e={toc:[]},t1e="wrapper";function e1e(t){let{components:e,...n}=t;return(0,s.kt)(t1e,(0,p.Z)({},J2e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}e1e.isMDXComponent=!0;const n1e={toc:[]},o1e="wrapper";function p1e(t){let{components:e,...n}=t;return(0,s.kt)(o1e,(0,p.Z)({},n1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}p1e.isMDXComponent=!0;const r1e={toc:[]},s1e="wrapper";function c1e(t){let{components:e,...n}=t;return(0,s.kt)(s1e,(0,p.Z)({},r1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}c1e.isMDXComponent=!0;const a1e={toc:[]},i1e="wrapper";function l1e(t){let{components:e,...n}=t;return(0,s.kt)(i1e,(0,p.Z)({},a1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}l1e.isMDXComponent=!0;const u1e={toc:[]},m1e="wrapper";function d1e(t){let{components:e,...n}=t;return(0,s.kt)(m1e,(0,p.Z)({},u1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}d1e.isMDXComponent=!0;const h1e={toc:[]},f1e="wrapper";function k1e(t){let{components:e,...n}=t;return(0,s.kt)(f1e,(0,p.Z)({},h1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}k1e.isMDXComponent=!0;const y1e={toc:[]},D1e="wrapper";function M1e(t){let{components:e,...n}=t;return(0,s.kt)(D1e,(0,p.Z)({},y1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Node#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}M1e.isMDXComponent=!0;const X1e={toc:[]},_1e="wrapper";function w1e(t){let{components:e,...n}=t;return(0,s.kt)(_1e,(0,p.Z)({},X1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}w1e.isMDXComponent=!0;const T1e={toc:[]},C1e="wrapper";function x1e(t){let{components:e,...n}=t;return(0,s.kt)(C1e,(0,p.Z)({},T1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}x1e.isMDXComponent=!0;const g1e={toc:[]},v1e="wrapper";function L1e(t){let{components:e,...n}=t;return(0,s.kt)(v1e,(0,p.Z)({},g1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}L1e.isMDXComponent=!0;const Z1e={toc:[]},b1e="wrapper";function N1e(t){let{components:e,...n}=t;return(0,s.kt)(b1e,(0,p.Z)({},Z1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}N1e.isMDXComponent=!0;const z1e={toc:[]},A1e="wrapper";function P1e(t){let{components:e,...n}=t;return(0,s.kt)(A1e,(0,p.Z)({},z1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}P1e.isMDXComponent=!0;const W1e={toc:[]},R1e="wrapper";function I1e(t){let{components:e,...n}=t;return(0,s.kt)(R1e,(0,p.Z)({},W1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}I1e.isMDXComponent=!0;const S1e={toc:[]},B1e="wrapper";function G1e(t){let{components:e,...n}=t;return(0,s.kt)(B1e,(0,p.Z)({},S1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}G1e.isMDXComponent=!0;const E1e={toc:[]},O1e="wrapper";function F1e(t){let{components:e,...n}=t;return(0,s.kt)(O1e,(0,p.Z)({},E1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}F1e.isMDXComponent=!0;const U1e={toc:[]},V1e="wrapper";function q1e(t){let{components:e,...n}=t;return(0,s.kt)(V1e,(0,p.Z)({},U1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}q1e.isMDXComponent=!0;const j1e={toc:[]},Y1e="wrapper";function Q1e(t){let{components:e,...n}=t;return(0,s.kt)(Y1e,(0,p.Z)({},j1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Q1e.isMDXComponent=!0;const H1e={toc:[]},K1e="wrapper";function $1e(t){let{components:e,...n}=t;return(0,s.kt)(K1e,(0,p.Z)({},H1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}$1e.isMDXComponent=!0;const J1e={toc:[]},t8e="wrapper";function e8e(t){let{components:e,...n}=t;return(0,s.kt)(t8e,(0,p.Z)({},J1e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}e8e.isMDXComponent=!0;const n8e={toc:[]},o8e="wrapper";function p8e(t){let{components:e,...n}=t;return(0,s.kt)(o8e,(0,p.Z)({},n8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}p8e.isMDXComponent=!0;const r8e={toc:[]},s8e="wrapper";function c8e(t){let{components:e,...n}=t;return(0,s.kt)(s8e,(0,p.Z)({},r8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}c8e.isMDXComponent=!0;const a8e={toc:[]},i8e="wrapper";function l8e(t){let{components:e,...n}=t;return(0,s.kt)(i8e,(0,p.Z)({},a8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}l8e.isMDXComponent=!0;const u8e={toc:[]},m8e="wrapper";function d8e(t){let{components:e,...n}=t;return(0,s.kt)(m8e,(0,p.Z)({},u8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}d8e.isMDXComponent=!0;const h8e={toc:[]},f8e="wrapper";function k8e(t){let{components:e,...n}=t;return(0,s.kt)(f8e,(0,p.Z)({},h8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}k8e.isMDXComponent=!0;const y8e={toc:[]},D8e="wrapper";function M8e(t){let{components:e,...n}=t;return(0,s.kt)(D8e,(0,p.Z)({},y8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}M8e.isMDXComponent=!0;const X8e={toc:[]},_8e="wrapper";function w8e(t){let{components:e,...n}=t;return(0,s.kt)(_8e,(0,p.Z)({},X8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}w8e.isMDXComponent=!0;const T8e={toc:[]},C8e="wrapper";function x8e(t){let{components:e,...n}=t;return(0,s.kt)(C8e,(0,p.Z)({},T8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}x8e.isMDXComponent=!0;const g8e={toc:[]},v8e="wrapper";function L8e(t){let{components:e,...n}=t;return(0,s.kt)(v8e,(0,p.Z)({},g8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}L8e.isMDXComponent=!0;const Z8e={toc:[]},b8e="wrapper";function N8e(t){let{components:e,...n}=t;return(0,s.kt)(b8e,(0,p.Z)({},Z8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}N8e.isMDXComponent=!0;const z8e={toc:[]},A8e="wrapper";function P8e(t){let{components:e,...n}=t;return(0,s.kt)(A8e,(0,p.Z)({},z8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}P8e.isMDXComponent=!0;const W8e={toc:[]},R8e="wrapper";function I8e(t){let{components:e,...n}=t;return(0,s.kt)(R8e,(0,p.Z)({},W8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}I8e.isMDXComponent=!0;const S8e={toc:[]},B8e="wrapper";function G8e(t){let{components:e,...n}=t;return(0,s.kt)(B8e,(0,p.Z)({},S8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}G8e.isMDXComponent=!0;const E8e={toc:[]},O8e="wrapper";function F8e(t){let{components:e,...n}=t;return(0,s.kt)(O8e,(0,p.Z)({},E8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}F8e.isMDXComponent=!0;const U8e={toc:[]},V8e="wrapper";function q8e(t){let{components:e,...n}=t;return(0,s.kt)(V8e,(0,p.Z)({},U8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}q8e.isMDXComponent=!0;const j8e={toc:[]},Y8e="wrapper";function Q8e(t){let{components:e,...n}=t;return(0,s.kt)(Y8e,(0,p.Z)({},j8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Q8e.isMDXComponent=!0;const H8e={toc:[]},K8e="wrapper";function $8e(t){let{components:e,...n}=t;return(0,s.kt)(K8e,(0,p.Z)({},H8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}$8e.isMDXComponent=!0;const J8e={toc:[]},t5e="wrapper";function e5e(t){let{components:e,...n}=t;return(0,s.kt)(t5e,(0,p.Z)({},J8e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}e5e.isMDXComponent=!0;const n5e={toc:[]},o5e="wrapper";function p5e(t){let{components:e,...n}=t;return(0,s.kt)(o5e,(0,p.Z)({},n5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}p5e.isMDXComponent=!0;const r5e={toc:[]},s5e="wrapper";function c5e(t){let{components:e,...n}=t;return(0,s.kt)(s5e,(0,p.Z)({},r5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}c5e.isMDXComponent=!0;const a5e={toc:[]},i5e="wrapper";function l5e(t){let{components:e,...n}=t;return(0,s.kt)(i5e,(0,p.Z)({},a5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}l5e.isMDXComponent=!0;const u5e={toc:[]},m5e="wrapper";function d5e(t){let{components:e,...n}=t;return(0,s.kt)(m5e,(0,p.Z)({},u5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}d5e.isMDXComponent=!0;const h5e={toc:[]},f5e="wrapper";function k5e(t){let{components:e,...n}=t;return(0,s.kt)(f5e,(0,p.Z)({},h5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}k5e.isMDXComponent=!0;const y5e={toc:[]},D5e="wrapper";function M5e(t){let{components:e,...n}=t;return(0,s.kt)(D5e,(0,p.Z)({},y5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}M5e.isMDXComponent=!0;const X5e={toc:[]},_5e="wrapper";function w5e(t){let{components:e,...n}=t;return(0,s.kt)(_5e,(0,p.Z)({},X5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}w5e.isMDXComponent=!0;const T5e={toc:[]},C5e="wrapper";function x5e(t){let{components:e,...n}=t;return(0,s.kt)(C5e,(0,p.Z)({},T5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}x5e.isMDXComponent=!0;const g5e={toc:[]},v5e="wrapper";function L5e(t){let{components:e,...n}=t;return(0,s.kt)(v5e,(0,p.Z)({},g5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}L5e.isMDXComponent=!0;const Z5e={toc:[]},b5e="wrapper";function N5e(t){let{components:e,...n}=t;return(0,s.kt)(b5e,(0,p.Z)({},Z5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}N5e.isMDXComponent=!0;const z5e={toc:[]},A5e="wrapper";function P5e(t){let{components:e,...n}=t;return(0,s.kt)(A5e,(0,p.Z)({},z5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}P5e.isMDXComponent=!0;const W5e={toc:[]},R5e="wrapper";function I5e(t){let{components:e,...n}=t;return(0,s.kt)(R5e,(0,p.Z)({},W5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}I5e.isMDXComponent=!0;const S5e={toc:[]},B5e="wrapper";function G5e(t){let{components:e,...n}=t;return(0,s.kt)(B5e,(0,p.Z)({},S5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}G5e.isMDXComponent=!0;const E5e={toc:[]},O5e="wrapper";function F5e(t){let{components:e,...n}=t;return(0,s.kt)(O5e,(0,p.Z)({},E5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}F5e.isMDXComponent=!0;const U5e={toc:[]},V5e="wrapper";function q5e(t){let{components:e,...n}=t;return(0,s.kt)(V5e,(0,p.Z)({},U5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}q5e.isMDXComponent=!0;const j5e={toc:[]},Y5e="wrapper";function Q5e(t){let{components:e,...n}=t;return(0,s.kt)(Y5e,(0,p.Z)({},j5e,n,{components:e,mdxType:"MDXLayout"}))}Q5e.isMDXComponent=!0;const H5e={toc:[]},K5e="wrapper";function $5e(t){let{components:e,...n}=t;return(0,s.kt)(K5e,(0,p.Z)({},H5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}$5e.isMDXComponent=!0;const J5e={toc:[]},t9e="wrapper";function e9e(t){let{components:e,...n}=t;return(0,s.kt)(t9e,(0,p.Z)({},J5e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}e9e.isMDXComponent=!0;const n9e={toc:[]},o9e="wrapper";function p9e(t){let{components:e,...n}=t;return(0,s.kt)(o9e,(0,p.Z)({},n9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}p9e.isMDXComponent=!0;const r9e={toc:[]},s9e="wrapper";function c9e(t){let{components:e,...n}=t;return(0,s.kt)(s9e,(0,p.Z)({},r9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}c9e.isMDXComponent=!0;const a9e={toc:[]},i9e="wrapper";function l9e(t){let{components:e,...n}=t;return(0,s.kt)(i9e,(0,p.Z)({},a9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}l9e.isMDXComponent=!0;const u9e={toc:[]},m9e="wrapper";function d9e(t){let{components:e,...n}=t;return(0,s.kt)(m9e,(0,p.Z)({},u9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}d9e.isMDXComponent=!0;const h9e={toc:[]},f9e="wrapper";function k9e(t){let{components:e,...n}=t;return(0,s.kt)(f9e,(0,p.Z)({},h9e,n,{components:e,mdxType:"MDXLayout"}))}k9e.isMDXComponent=!0;const y9e={toc:[]},D9e="wrapper";function M9e(t){let{components:e,...n}=t;return(0,s.kt)(D9e,(0,p.Z)({},y9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}M9e.isMDXComponent=!0;const X9e={toc:[]},_9e="wrapper";function w9e(t){let{components:e,...n}=t;return(0,s.kt)(_9e,(0,p.Z)({},X9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}w9e.isMDXComponent=!0;const T9e={toc:[]},C9e="wrapper";function x9e(t){let{components:e,...n}=t;return(0,s.kt)(C9e,(0,p.Z)({},T9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}x9e.isMDXComponent=!0;const g9e={toc:[]},v9e="wrapper";function L9e(t){let{components:e,...n}=t;return(0,s.kt)(v9e,(0,p.Z)({},g9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}L9e.isMDXComponent=!0;const Z9e={toc:[]},b9e="wrapper";function N9e(t){let{components:e,...n}=t;return(0,s.kt)(b9e,(0,p.Z)({},Z9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}N9e.isMDXComponent=!0;const z9e={toc:[]},A9e="wrapper";function P9e(t){let{components:e,...n}=t;return(0,s.kt)(A9e,(0,p.Z)({},z9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}P9e.isMDXComponent=!0;const W9e={toc:[]},R9e="wrapper";function I9e(t){let{components:e,...n}=t;return(0,s.kt)(R9e,(0,p.Z)({},W9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}I9e.isMDXComponent=!0;const S9e={toc:[]},B9e="wrapper";function G9e(t){let{components:e,...n}=t;return(0,s.kt)(B9e,(0,p.Z)({},S9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}G9e.isMDXComponent=!0;const E9e={toc:[]},O9e="wrapper";function F9e(t){let{components:e,...n}=t;return(0,s.kt)(O9e,(0,p.Z)({},E9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}F9e.isMDXComponent=!0;const U9e={toc:[]},V9e="wrapper";function q9e(t){let{components:e,...n}=t;return(0,s.kt)(V9e,(0,p.Z)({},U9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}q9e.isMDXComponent=!0;const j9e={toc:[]},Y9e="wrapper";function Q9e(t){let{components:e,...n}=t;return(0,s.kt)(Y9e,(0,p.Z)({},j9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Q9e.isMDXComponent=!0;const H9e={toc:[]},K9e="wrapper";function $9e(t){let{components:e,...n}=t;return(0,s.kt)(K9e,(0,p.Z)({},H9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}$9e.isMDXComponent=!0;const J9e={toc:[]},ttn="wrapper";function etn(t){let{components:e,...n}=t;return(0,s.kt)(ttn,(0,p.Z)({},J9e,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}etn.isMDXComponent=!0;const ntn={toc:[]},otn="wrapper";function ptn(t){let{components:e,...n}=t;return(0,s.kt)(otn,(0,p.Z)({},ntn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}ptn.isMDXComponent=!0;const rtn={toc:[]},stn="wrapper";function ctn(t){let{components:e,...n}=t;return(0,s.kt)(stn,(0,p.Z)({},rtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}ctn.isMDXComponent=!0;const atn={toc:[]},itn="wrapper";function ltn(t){let{components:e,...n}=t;return(0,s.kt)(itn,(0,p.Z)({},atn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}ltn.isMDXComponent=!0;const utn={toc:[]},mtn="wrapper";function dtn(t){let{components:e,...n}=t;return(0,s.kt)(mtn,(0,p.Z)({},utn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}dtn.isMDXComponent=!0;const htn={toc:[]},ftn="wrapper";function ktn(t){let{components:e,...n}=t;return(0,s.kt)(ftn,(0,p.Z)({},htn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}ktn.isMDXComponent=!0;const ytn={toc:[]},Dtn="wrapper";function Mtn(t){let{components:e,...n}=t;return(0,s.kt)(Dtn,(0,p.Z)({},ytn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Mtn.isMDXComponent=!0;const Xtn={toc:[]},_tn="wrapper";function wtn(t){let{components:e,...n}=t;return(0,s.kt)(_tn,(0,p.Z)({},Xtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}wtn.isMDXComponent=!0;const Ttn={toc:[]},Ctn="wrapper";function xtn(t){let{components:e,...n}=t;return(0,s.kt)(Ctn,(0,p.Z)({},Ttn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}xtn.isMDXComponent=!0;const gtn={toc:[]},vtn="wrapper";function Ltn(t){let{components:e,...n}=t;return(0,s.kt)(vtn,(0,p.Z)({},gtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Ltn.isMDXComponent=!0;const Ztn={toc:[]},btn="wrapper";function Ntn(t){let{components:e,...n}=t;return(0,s.kt)(btn,(0,p.Z)({},Ztn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Ntn.isMDXComponent=!0;const ztn={toc:[]},Atn="wrapper";function Ptn(t){let{components:e,...n}=t;return(0,s.kt)(Atn,(0,p.Z)({},ztn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Ptn.isMDXComponent=!0;const Wtn={toc:[]},Rtn="wrapper";function Itn(t){let{components:e,...n}=t;return(0,s.kt)(Rtn,(0,p.Z)({},Wtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Itn.isMDXComponent=!0;const Stn={toc:[]},Btn="wrapper";function Gtn(t){let{components:e,...n}=t;return(0,s.kt)(Btn,(0,p.Z)({},Stn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Gtn.isMDXComponent=!0;const Etn={toc:[]},Otn="wrapper";function Ftn(t){let{components:e,...n}=t;return(0,s.kt)(Otn,(0,p.Z)({},Etn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Ftn.isMDXComponent=!0;const Utn={toc:[]},Vtn="wrapper";function qtn(t){let{components:e,...n}=t;return(0,s.kt)(Vtn,(0,p.Z)({},Utn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}qtn.isMDXComponent=!0;const jtn={toc:[]},Ytn="wrapper";function Qtn(t){let{components:e,...n}=t;return(0,s.kt)(Ytn,(0,p.Z)({},jtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Qtn.isMDXComponent=!0;const Htn={toc:[]},Ktn="wrapper";function $tn(t){let{components:e,...n}=t;return(0,s.kt)(Ktn,(0,p.Z)({},Htn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}$tn.isMDXComponent=!0;const Jtn={toc:[]},ten="wrapper";function een(t){let{components:e,...n}=t;return(0,s.kt)(ten,(0,p.Z)({},Jtn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}een.isMDXComponent=!0;const nen={toc:[]},oen="wrapper";function pen(t){let{components:e,...n}=t;return(0,s.kt)(oen,(0,p.Z)({},nen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pen.isMDXComponent=!0;const ren={toc:[]},sen="wrapper";function cen(t){let{components:e,...n}=t;return(0,s.kt)(sen,(0,p.Z)({},ren,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cen.isMDXComponent=!0;const aen={toc:[]},ien="wrapper";function len(t){let{components:e,...n}=t;return(0,s.kt)(ien,(0,p.Z)({},aen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}len.isMDXComponent=!0;const uen={toc:[]},men="wrapper";function den(t){let{components:e,...n}=t;return(0,s.kt)(men,(0,p.Z)({},uen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}den.isMDXComponent=!0;const hen={toc:[]},fen="wrapper";function ken(t){let{components:e,...n}=t;return(0,s.kt)(fen,(0,p.Z)({},hen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}ken.isMDXComponent=!0;const yen={toc:[]},Den="wrapper";function Men(t){let{components:e,...n}=t;return(0,s.kt)(Den,(0,p.Z)({},yen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}Men.isMDXComponent=!0;const Xen={toc:[]},_en="wrapper";function wen(t){let{components:e,...n}=t;return(0,s.kt)(_en,(0,p.Z)({},Xen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}wen.isMDXComponent=!0;const Ten={toc:[]},Cen="wrapper";function xen(t){let{components:e,...n}=t;return(0,s.kt)(Cen,(0,p.Z)({},Ten,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}xen.isMDXComponent=!0;const gen={toc:[]},ven="wrapper";function Len(t){let{components:e,...n}=t;return(0,s.kt)(ven,(0,p.Z)({},gen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}Len.isMDXComponent=!0;const Zen={toc:[]},ben="wrapper";function Nen(t){let{components:e,...n}=t;return(0,s.kt)(ben,(0,p.Z)({},Zen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Nen.isMDXComponent=!0;const zen={toc:[]},Aen="wrapper";function Pen(t){let{components:e,...n}=t;return(0,s.kt)(Aen,(0,p.Z)({},zen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Pen.isMDXComponent=!0;const Wen={toc:[]},Ren="wrapper";function Ien(t){let{components:e,...n}=t;return(0,s.kt)(Ren,(0,p.Z)({},Wen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Ien.isMDXComponent=!0;const Sen={toc:[]},Ben="wrapper";function Gen(t){let{components:e,...n}=t;return(0,s.kt)(Ben,(0,p.Z)({},Sen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}Gen.isMDXComponent=!0;const Een={toc:[]},Oen="wrapper";function Fen(t){let{components:e,...n}=t;return(0,s.kt)(Oen,(0,p.Z)({},Een,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}Fen.isMDXComponent=!0;const Uen={toc:[]},Ven="wrapper";function qen(t){let{components:e,...n}=t;return(0,s.kt)(Ven,(0,p.Z)({},Uen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}qen.isMDXComponent=!0;const jen={toc:[]},Yen="wrapper";function Qen(t){let{components:e,...n}=t;return(0,s.kt)(Yen,(0,p.Z)({},jen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Qen.isMDXComponent=!0;const Hen={toc:[]},Ken="wrapper";function $en(t){let{components:e,...n}=t;return(0,s.kt)(Ken,(0,p.Z)({},Hen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$en.isMDXComponent=!0;const Jen={toc:[]},tnn="wrapper";function enn(t){let{components:e,...n}=t;return(0,s.kt)(tnn,(0,p.Z)({},Jen,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}enn.isMDXComponent=!0;const nnn={toc:[]},onn="wrapper";function pnn(t){let{components:e,...n}=t;return(0,s.kt)(onn,(0,p.Z)({},nnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}pnn.isMDXComponent=!0;const rnn={toc:[]},snn="wrapper";function cnn(t){let{components:e,...n}=t;return(0,s.kt)(snn,(0,p.Z)({},rnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cnn.isMDXComponent=!0;const ann={toc:[]},inn="wrapper";function lnn(t){let{components:e,...n}=t;return(0,s.kt)(inn,(0,p.Z)({},ann,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}lnn.isMDXComponent=!0;const unn={toc:[]},mnn="wrapper";function dnn(t){let{components:e,...n}=t;return(0,s.kt)(mnn,(0,p.Z)({},unn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}dnn.isMDXComponent=!0;const hnn={toc:[]},fnn="wrapper";function knn(t){let{components:e,...n}=t;return(0,s.kt)(fnn,(0,p.Z)({},hnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}knn.isMDXComponent=!0;const ynn={toc:[]},Dnn="wrapper";function Mnn(t){let{components:e,...n}=t;return(0,s.kt)(Dnn,(0,p.Z)({},ynn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}Mnn.isMDXComponent=!0;const Xnn={toc:[]},_nn="wrapper";function wnn(t){let{components:e,...n}=t;return(0,s.kt)(_nn,(0,p.Z)({},Xnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wnn.isMDXComponent=!0;const Tnn={toc:[]},Cnn="wrapper";function xnn(t){let{components:e,...n}=t;return(0,s.kt)(Cnn,(0,p.Z)({},Tnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}xnn.isMDXComponent=!0;const gnn={toc:[]},vnn="wrapper";function Lnn(t){let{components:e,...n}=t;return(0,s.kt)(vnn,(0,p.Z)({},gnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Lnn.isMDXComponent=!0;const Znn={toc:[]},bnn="wrapper";function Nnn(t){let{components:e,...n}=t;return(0,s.kt)(bnn,(0,p.Z)({},Znn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Nnn.isMDXComponent=!0;const znn={toc:[]},Ann="wrapper";function Pnn(t){let{components:e,...n}=t;return(0,s.kt)(Ann,(0,p.Z)({},znn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Pnn.isMDXComponent=!0;const Wnn={toc:[]},Rnn="wrapper";function Inn(t){let{components:e,...n}=t;return(0,s.kt)(Rnn,(0,p.Z)({},Wnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Inn.isMDXComponent=!0;const Snn={toc:[]},Bnn="wrapper";function Gnn(t){let{components:e,...n}=t;return(0,s.kt)(Bnn,(0,p.Z)({},Snn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Gnn.isMDXComponent=!0;const Enn={toc:[]},Onn="wrapper";function Fnn(t){let{components:e,...n}=t;return(0,s.kt)(Onn,(0,p.Z)({},Enn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Fnn.isMDXComponent=!0;const Unn={toc:[]},Vnn="wrapper";function qnn(t){let{components:e,...n}=t;return(0,s.kt)(Vnn,(0,p.Z)({},Unn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qnn.isMDXComponent=!0;const jnn={toc:[]},Ynn="wrapper";function Qnn(t){let{components:e,...n}=t;return(0,s.kt)(Ynn,(0,p.Z)({},jnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Qnn.isMDXComponent=!0;const Hnn={toc:[]},Knn="wrapper";function $nn(t){let{components:e,...n}=t;return(0,s.kt)(Knn,(0,p.Z)({},Hnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}$nn.isMDXComponent=!0;const Jnn={toc:[]},ton="wrapper";function eon(t){let{components:e,...n}=t;return(0,s.kt)(ton,(0,p.Z)({},Jnn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}eon.isMDXComponent=!0;const non={toc:[]},oon="wrapper";function pon(t){let{components:e,...n}=t;return(0,s.kt)(oon,(0,p.Z)({},non,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pon.isMDXComponent=!0;const ron={toc:[]},son="wrapper";function con(t){let{components:e,...n}=t;return(0,s.kt)(son,(0,p.Z)({},ron,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}con.isMDXComponent=!0;const aon={toc:[]},ion="wrapper";function lon(t){let{components:e,...n}=t;return(0,s.kt)(ion,(0,p.Z)({},aon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}lon.isMDXComponent=!0;const uon={toc:[]},mon="wrapper";function don(t){let{components:e,...n}=t;return(0,s.kt)(mon,(0,p.Z)({},uon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}don.isMDXComponent=!0;const hon={toc:[]},fon="wrapper";function kon(t){let{components:e,...n}=t;return(0,s.kt)(fon,(0,p.Z)({},hon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}kon.isMDXComponent=!0;const yon={toc:[]},Don="wrapper";function Mon(t){let{components:e,...n}=t;return(0,s.kt)(Don,(0,p.Z)({},yon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}Mon.isMDXComponent=!0;const Xon={toc:[]},_on="wrapper";function won(t){let{components:e,...n}=t;return(0,s.kt)(_on,(0,p.Z)({},Xon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}won.isMDXComponent=!0;const Ton={toc:[]},Con="wrapper";function xon(t){let{components:e,...n}=t;return(0,s.kt)(Con,(0,p.Z)({},Ton,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}xon.isMDXComponent=!0;const gon={toc:[]},von="wrapper";function Lon(t){let{components:e,...n}=t;return(0,s.kt)(von,(0,p.Z)({},gon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}Lon.isMDXComponent=!0;const Zon={toc:[]},bon="wrapper";function Non(t){let{components:e,...n}=t;return(0,s.kt)(bon,(0,p.Z)({},Zon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Non.isMDXComponent=!0;const zon={toc:[]},Aon="wrapper";function Pon(t){let{components:e,...n}=t;return(0,s.kt)(Aon,(0,p.Z)({},zon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Pon.isMDXComponent=!0;const Won={toc:[]},Ron="wrapper";function Ion(t){let{components:e,...n}=t;return(0,s.kt)(Ron,(0,p.Z)({},Won,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Ion.isMDXComponent=!0;const Son={toc:[]},Bon="wrapper";function Gon(t){let{components:e,...n}=t;return(0,s.kt)(Bon,(0,p.Z)({},Son,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Gon.isMDXComponent=!0;const Eon={toc:[]},Oon="wrapper";function Fon(t){let{components:e,...n}=t;return(0,s.kt)(Oon,(0,p.Z)({},Eon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Fon.isMDXComponent=!0;const Uon={toc:[]},Von="wrapper";function qon(t){let{components:e,...n}=t;return(0,s.kt)(Von,(0,p.Z)({},Uon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}qon.isMDXComponent=!0;const jon={toc:[]},Yon="wrapper";function Qon(t){let{components:e,...n}=t;return(0,s.kt)(Yon,(0,p.Z)({},jon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Qon.isMDXComponent=!0;const Hon={toc:[]},Kon="wrapper";function $on(t){let{components:e,...n}=t;return(0,s.kt)(Kon,(0,p.Z)({},Hon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}$on.isMDXComponent=!0;const Jon={toc:[]},tpn="wrapper";function epn(t){let{components:e,...n}=t;return(0,s.kt)(tpn,(0,p.Z)({},Jon,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}epn.isMDXComponent=!0;const npn={toc:[]},opn="wrapper";function ppn(t){let{components:e,...n}=t;return(0,s.kt)(opn,(0,p.Z)({},npn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}ppn.isMDXComponent=!0;const rpn={toc:[]},spn="wrapper";function cpn(t){let{components:e,...n}=t;return(0,s.kt)(spn,(0,p.Z)({},rpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}cpn.isMDXComponent=!0;const apn={toc:[]},ipn="wrapper";function lpn(t){let{components:e,...n}=t;return(0,s.kt)(ipn,(0,p.Z)({},apn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}lpn.isMDXComponent=!0;const upn={toc:[]},mpn="wrapper";function dpn(t){let{components:e,...n}=t;return(0,s.kt)(mpn,(0,p.Z)({},upn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}dpn.isMDXComponent=!0;const hpn={toc:[]},fpn="wrapper";function kpn(t){let{components:e,...n}=t;return(0,s.kt)(fpn,(0,p.Z)({},hpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}kpn.isMDXComponent=!0;const ypn={toc:[]},Dpn="wrapper";function Mpn(t){let{components:e,...n}=t;return(0,s.kt)(Dpn,(0,p.Z)({},ypn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}Mpn.isMDXComponent=!0;const Xpn={toc:[]},_pn="wrapper";function wpn(t){let{components:e,...n}=t;return(0,s.kt)(_pn,(0,p.Z)({},Xpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}wpn.isMDXComponent=!0;const Tpn={toc:[]},Cpn="wrapper";function xpn(t){let{components:e,...n}=t;return(0,s.kt)(Cpn,(0,p.Z)({},Tpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}xpn.isMDXComponent=!0;const gpn={toc:[]},vpn="wrapper";function Lpn(t){let{components:e,...n}=t;return(0,s.kt)(vpn,(0,p.Z)({},gpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Lpn.isMDXComponent=!0;const Zpn={toc:[]},bpn="wrapper";function Npn(t){let{components:e,...n}=t;return(0,s.kt)(bpn,(0,p.Z)({},Zpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Npn.isMDXComponent=!0;const zpn={toc:[]},Apn="wrapper";function Ppn(t){let{components:e,...n}=t;return(0,s.kt)(Apn,(0,p.Z)({},zpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Ppn.isMDXComponent=!0;const Wpn={toc:[]},Rpn="wrapper";function Ipn(t){let{components:e,...n}=t;return(0,s.kt)(Rpn,(0,p.Z)({},Wpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Ipn.isMDXComponent=!0;const Spn={toc:[]},Bpn="wrapper";function Gpn(t){let{components:e,...n}=t;return(0,s.kt)(Bpn,(0,p.Z)({},Spn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Gpn.isMDXComponent=!0;const Epn={toc:[]},Opn="wrapper";function Fpn(t){let{components:e,...n}=t;return(0,s.kt)(Opn,(0,p.Z)({},Epn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Fpn.isMDXComponent=!0;const Upn={toc:[]},Vpn="wrapper";function qpn(t){let{components:e,...n}=t;return(0,s.kt)(Vpn,(0,p.Z)({},Upn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}qpn.isMDXComponent=!0;const jpn={toc:[]},Ypn="wrapper";function Qpn(t){let{components:e,...n}=t;return(0,s.kt)(Ypn,(0,p.Z)({},jpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Qpn.isMDXComponent=!0;const Hpn={toc:[]},Kpn="wrapper";function $pn(t){let{components:e,...n}=t;return(0,s.kt)(Kpn,(0,p.Z)({},Hpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}$pn.isMDXComponent=!0;const Jpn={toc:[]},trn="wrapper";function ern(t){let{components:e,...n}=t;return(0,s.kt)(trn,(0,p.Z)({},Jpn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ern.isMDXComponent=!0;const nrn={toc:[]},orn="wrapper";function prn(t){let{components:e,...n}=t;return(0,s.kt)(orn,(0,p.Z)({},nrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}prn.isMDXComponent=!0;const rrn={toc:[]},srn="wrapper";function crn(t){let{components:e,...n}=t;return(0,s.kt)(srn,(0,p.Z)({},rrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}crn.isMDXComponent=!0;const arn={toc:[]},irn="wrapper";function lrn(t){let{components:e,...n}=t;return(0,s.kt)(irn,(0,p.Z)({},arn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}lrn.isMDXComponent=!0;const urn={toc:[]},mrn="wrapper";function drn(t){let{components:e,...n}=t;return(0,s.kt)(mrn,(0,p.Z)({},urn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}drn.isMDXComponent=!0;const hrn={toc:[]},frn="wrapper";function krn(t){let{components:e,...n}=t;return(0,s.kt)(frn,(0,p.Z)({},hrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}krn.isMDXComponent=!0;const yrn={toc:[]},Drn="wrapper";function Mrn(t){let{components:e,...n}=t;return(0,s.kt)(Drn,(0,p.Z)({},yrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Mrn.isMDXComponent=!0;const Xrn={toc:[]},_rn="wrapper";function wrn(t){let{components:e,...n}=t;return(0,s.kt)(_rn,(0,p.Z)({},Xrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}wrn.isMDXComponent=!0;const Trn={toc:[]},Crn="wrapper";function xrn(t){let{components:e,...n}=t;return(0,s.kt)(Crn,(0,p.Z)({},Trn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}xrn.isMDXComponent=!0;const grn={toc:[]},vrn="wrapper";function Lrn(t){let{components:e,...n}=t;return(0,s.kt)(vrn,(0,p.Z)({},grn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Lrn.isMDXComponent=!0;const Zrn={toc:[]},brn="wrapper";function Nrn(t){let{components:e,...n}=t;return(0,s.kt)(brn,(0,p.Z)({},Zrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Nrn.isMDXComponent=!0;const zrn={toc:[]},Arn="wrapper";function Prn(t){let{components:e,...n}=t;return(0,s.kt)(Arn,(0,p.Z)({},zrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Prn.isMDXComponent=!0;const Wrn={toc:[]},Rrn="wrapper";function Irn(t){let{components:e,...n}=t;return(0,s.kt)(Rrn,(0,p.Z)({},Wrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}Irn.isMDXComponent=!0;const Srn={toc:[]},Brn="wrapper";function Grn(t){let{components:e,...n}=t;return(0,s.kt)(Brn,(0,p.Z)({},Srn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Grn.isMDXComponent=!0;const Ern={toc:[]},Orn="wrapper";function Frn(t){let{components:e,...n}=t;return(0,s.kt)(Orn,(0,p.Z)({},Ern,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Frn.isMDXComponent=!0;const Urn={toc:[]},Vrn="wrapper";function qrn(t){let{components:e,...n}=t;return(0,s.kt)(Vrn,(0,p.Z)({},Urn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}qrn.isMDXComponent=!0;const jrn={toc:[]},Yrn="wrapper";function Qrn(t){let{components:e,...n}=t;return(0,s.kt)(Yrn,(0,p.Z)({},jrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}Qrn.isMDXComponent=!0;const Hrn={toc:[]},Krn="wrapper";function $rn(t){let{components:e,...n}=t;return(0,s.kt)(Krn,(0,p.Z)({},Hrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}$rn.isMDXComponent=!0;const Jrn={toc:[]},tsn="wrapper";function esn(t){let{components:e,...n}=t;return(0,s.kt)(tsn,(0,p.Z)({},Jrn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}esn.isMDXComponent=!0;const nsn={toc:[]},osn="wrapper";function psn(t){let{components:e,...n}=t;return(0,s.kt)(osn,(0,p.Z)({},nsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}psn.isMDXComponent=!0;const rsn={toc:[]},ssn="wrapper";function csn(t){let{components:e,...n}=t;return(0,s.kt)(ssn,(0,p.Z)({},rsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}csn.isMDXComponent=!0;const asn={toc:[]},isn="wrapper";function lsn(t){let{components:e,...n}=t;return(0,s.kt)(isn,(0,p.Z)({},asn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lsn.isMDXComponent=!0;const usn={toc:[]},msn="wrapper";function dsn(t){let{components:e,...n}=t;return(0,s.kt)(msn,(0,p.Z)({},usn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}dsn.isMDXComponent=!0;const hsn={toc:[]},fsn="wrapper";function ksn(t){let{components:e,...n}=t;return(0,s.kt)(fsn,(0,p.Z)({},hsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}ksn.isMDXComponent=!0;const ysn={toc:[]},Dsn="wrapper";function Msn(t){let{components:e,...n}=t;return(0,s.kt)(Dsn,(0,p.Z)({},ysn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Msn.isMDXComponent=!0;const Xsn={toc:[]},_sn="wrapper";function wsn(t){let{components:e,...n}=t;return(0,s.kt)(_sn,(0,p.Z)({},Xsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}wsn.isMDXComponent=!0;const Tsn={toc:[]},Csn="wrapper";function xsn(t){let{components:e,...n}=t;return(0,s.kt)(Csn,(0,p.Z)({},Tsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}xsn.isMDXComponent=!0;const gsn={toc:[]},vsn="wrapper";function Lsn(t){let{components:e,...n}=t;return(0,s.kt)(vsn,(0,p.Z)({},gsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Lsn.isMDXComponent=!0;const Zsn={toc:[]},bsn="wrapper";function Nsn(t){let{components:e,...n}=t;return(0,s.kt)(bsn,(0,p.Z)({},Zsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Nsn.isMDXComponent=!0;const zsn={toc:[]},Asn="wrapper";function Psn(t){let{components:e,...n}=t;return(0,s.kt)(Asn,(0,p.Z)({},zsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Psn.isMDXComponent=!0;const Wsn={toc:[]},Rsn="wrapper";function Isn(t){let{components:e,...n}=t;return(0,s.kt)(Rsn,(0,p.Z)({},Wsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Isn.isMDXComponent=!0;const Ssn={toc:[]},Bsn="wrapper";function Gsn(t){let{components:e,...n}=t;return(0,s.kt)(Bsn,(0,p.Z)({},Ssn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Gsn.isMDXComponent=!0;const Esn={toc:[]},Osn="wrapper";function Fsn(t){let{components:e,...n}=t;return(0,s.kt)(Osn,(0,p.Z)({},Esn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Fsn.isMDXComponent=!0;const Usn={toc:[]},Vsn="wrapper";function qsn(t){let{components:e,...n}=t;return(0,s.kt)(Vsn,(0,p.Z)({},Usn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}qsn.isMDXComponent=!0;const jsn={toc:[]},Ysn="wrapper";function Qsn(t){let{components:e,...n}=t;return(0,s.kt)(Ysn,(0,p.Z)({},jsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Qsn.isMDXComponent=!0;const Hsn={toc:[]},Ksn="wrapper";function $sn(t){let{components:e,...n}=t;return(0,s.kt)(Ksn,(0,p.Z)({},Hsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}$sn.isMDXComponent=!0;const Jsn={toc:[]},tcn="wrapper";function ecn(t){let{components:e,...n}=t;return(0,s.kt)(tcn,(0,p.Z)({},Jsn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}ecn.isMDXComponent=!0;const ncn={toc:[]},ocn="wrapper";function pcn(t){let{components:e,...n}=t;return(0,s.kt)(ocn,(0,p.Z)({},ncn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}pcn.isMDXComponent=!0;const rcn={toc:[]},scn="wrapper";function ccn(t){let{components:e,...n}=t;return(0,s.kt)(scn,(0,p.Z)({},rcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}ccn.isMDXComponent=!0;const acn={toc:[]},icn="wrapper";function lcn(t){let{components:e,...n}=t;return(0,s.kt)(icn,(0,p.Z)({},acn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}lcn.isMDXComponent=!0;const ucn={toc:[]},mcn="wrapper";function dcn(t){let{components:e,...n}=t;return(0,s.kt)(mcn,(0,p.Z)({},ucn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}dcn.isMDXComponent=!0;const hcn={toc:[]},fcn="wrapper";function kcn(t){let{components:e,...n}=t;return(0,s.kt)(fcn,(0,p.Z)({},hcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}kcn.isMDXComponent=!0;const ycn={toc:[]},Dcn="wrapper";function Mcn(t){let{components:e,...n}=t;return(0,s.kt)(Dcn,(0,p.Z)({},ycn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Mcn.isMDXComponent=!0;const Xcn={toc:[]},_cn="wrapper";function wcn(t){let{components:e,...n}=t;return(0,s.kt)(_cn,(0,p.Z)({},Xcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}wcn.isMDXComponent=!0;const Tcn={toc:[]},Ccn="wrapper";function xcn(t){let{components:e,...n}=t;return(0,s.kt)(Ccn,(0,p.Z)({},Tcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}xcn.isMDXComponent=!0;const gcn={toc:[]},vcn="wrapper";function Lcn(t){let{components:e,...n}=t;return(0,s.kt)(vcn,(0,p.Z)({},gcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Lcn.isMDXComponent=!0;const Zcn={toc:[]},bcn="wrapper";function Ncn(t){let{components:e,...n}=t;return(0,s.kt)(bcn,(0,p.Z)({},Zcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Ncn.isMDXComponent=!0;const zcn={toc:[]},Acn="wrapper";function Pcn(t){let{components:e,...n}=t;return(0,s.kt)(Acn,(0,p.Z)({},zcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Pcn.isMDXComponent=!0;const Wcn={toc:[]},Rcn="wrapper";function Icn(t){let{components:e,...n}=t;return(0,s.kt)(Rcn,(0,p.Z)({},Wcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Icn.isMDXComponent=!0;const Scn={toc:[]},Bcn="wrapper";function Gcn(t){let{components:e,...n}=t;return(0,s.kt)(Bcn,(0,p.Z)({},Scn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Gcn.isMDXComponent=!0;const Ecn={toc:[]},Ocn="wrapper";function Fcn(t){let{components:e,...n}=t;return(0,s.kt)(Ocn,(0,p.Z)({},Ecn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Fcn.isMDXComponent=!0;const Ucn={toc:[]},Vcn="wrapper";function qcn(t){let{components:e,...n}=t;return(0,s.kt)(Vcn,(0,p.Z)({},Ucn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}qcn.isMDXComponent=!0;const jcn={toc:[]},Ycn="wrapper";function Qcn(t){let{components:e,...n}=t;return(0,s.kt)(Ycn,(0,p.Z)({},jcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Qcn.isMDXComponent=!0;const Hcn={toc:[]},Kcn="wrapper";function $cn(t){let{components:e,...n}=t;return(0,s.kt)(Kcn,(0,p.Z)({},Hcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}$cn.isMDXComponent=!0;const Jcn={toc:[]},tan="wrapper";function ean(t){let{components:e,...n}=t;return(0,s.kt)(tan,(0,p.Z)({},Jcn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ean.isMDXComponent=!0;const nan={toc:[]},oan="wrapper";function pan(t){let{components:e,...n}=t;return(0,s.kt)(oan,(0,p.Z)({},nan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}pan.isMDXComponent=!0;const ran={toc:[]},san="wrapper";function can(t){let{components:e,...n}=t;return(0,s.kt)(san,(0,p.Z)({},ran,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}can.isMDXComponent=!0;const aan={toc:[]},ian="wrapper";function lan(t){let{components:e,...n}=t;return(0,s.kt)(ian,(0,p.Z)({},aan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Path#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}lan.isMDXComponent=!0;const uan={toc:[]},man="wrapper";function dan(t){let{components:e,...n}=t;return(0,s.kt)(man,(0,p.Z)({},uan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}dan.isMDXComponent=!0;const han={toc:[]},fan="wrapper";function kan(t){let{components:e,...n}=t;return(0,s.kt)(fan,(0,p.Z)({},han,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}kan.isMDXComponent=!0;const yan={toc:[]},Dan="wrapper";function Man(t){let{components:e,...n}=t;return(0,s.kt)(Dan,(0,p.Z)({},yan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Man.isMDXComponent=!0;const Xan={toc:[]},_an="wrapper";function wan(t){let{components:e,...n}=t;return(0,s.kt)(_an,(0,p.Z)({},Xan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}wan.isMDXComponent=!0;const Tan={toc:[]},Can="wrapper";function xan(t){let{components:e,...n}=t;return(0,s.kt)(Can,(0,p.Z)({},Tan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}xan.isMDXComponent=!0;const gan={toc:[]},van="wrapper";function Lan(t){let{components:e,...n}=t;return(0,s.kt)(van,(0,p.Z)({},gan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}Lan.isMDXComponent=!0;const Zan={toc:[]},ban="wrapper";function Nan(t){let{components:e,...n}=t;return(0,s.kt)(ban,(0,p.Z)({},Zan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node can be used to render shapes such as: triangle, pentagon,\nhexagon and more."),(0,s.kt)("p",null,"Note that the polygon is inscribed in a circle defined by the height\nand width. If height and width are unequal, the polygon is inscribed\nin the resulting ellipse."),(0,s.kt)("p",null,"Since the polygon is inscribed in the circle, the actual displayed\nheight and width may differ somewhat from the bounding rectangle. This\nwill be particularly noticeable if the number of sides is low, e.g. for a\ntriangle."))}Nan.isMDXComponent=!0;const zan={toc:[]},Aan="wrapper";function Pan(t){let{components:e,...n}=t;return(0,s.kt)(Aan,(0,p.Z)({},zan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"// snippet Polygon\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ref = createRef<Polygon>();\n  view.add(\n    <Polygon\n      ref={ref}\n      sides={6}\n      size={160}\n      fill={'lightseagreen'}\n    />\n  );\n\n  yield* ref().sides(3, 2).to(6, 2);\n});\n\n// snippet Pentagon outline\nimport {makeScene2D, Polygon} from '@motion-canvas/2d';\n\nexport default makeScene2D(function* (view) {\n  view.add(\n    <Polygon\n      sides={5}\n      size={160}\n      stroke={'lightblue'}\n      lineWidth={8}\n    />\n  );\n});\n")))}Pan.isMDXComponent=!0;const Wan={toc:[]},Ran="wrapper";function Ian(t){let{components:e,...n}=t;return(0,s.kt)(Ran,(0,p.Z)({},Wan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing regular polygons."))}Ian.isMDXComponent=!0;const San={toc:[]},Ban="wrapper";function Gan(t){let{components:e,...n}=t;return(0,s.kt)(Ban,(0,p.Z)({},San,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}Gan.isMDXComponent=!0;const Ean={toc:[]},Oan="wrapper";function Fan(t){let{components:e,...n}=t;return(0,s.kt)(Oan,(0,p.Z)({},Ean,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Fan.isMDXComponent=!0;const Uan={toc:[]},Van="wrapper";function qan(t){let{components:e,...n}=t;return(0,s.kt)(Van,(0,p.Z)({},Uan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}qan.isMDXComponent=!0;const jan={toc:[]},Yan="wrapper";function Qan(t){let{components:e,...n}=t;return(0,s.kt)(Yan,(0,p.Z)({},jan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Qan.isMDXComponent=!0;const Han={toc:[]},Kan="wrapper";function $an(t){let{components:e,...n}=t;return(0,s.kt)(Kan,(0,p.Z)({},Han,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}$an.isMDXComponent=!0;const Jan={toc:[]},tin="wrapper";function ein(t){let{components:e,...n}=t;return(0,s.kt)(tin,(0,p.Z)({},Jan,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}ein.isMDXComponent=!0;const nin={toc:[]},oin="wrapper";function pin(t){let{components:e,...n}=t;return(0,s.kt)(oin,(0,p.Z)({},nin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}pin.isMDXComponent=!0;const rin={toc:[]},sin="wrapper";function cin(t){let{components:e,...n}=t;return(0,s.kt)(sin,(0,p.Z)({},rin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}cin.isMDXComponent=!0;const ain={toc:[]},iin="wrapper";function lin(t){let{components:e,...n}=t;return(0,s.kt)(iin,(0,p.Z)({},ain,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}lin.isMDXComponent=!0;const uin={toc:[]},min="wrapper";function din(t){let{components:e,...n}=t;return(0,s.kt)(min,(0,p.Z)({},uin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}din.isMDXComponent=!0;const hin={toc:[]},fin="wrapper";function kin(t){let{components:e,...n}=t;return(0,s.kt)(fin,(0,p.Z)({},hin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}kin.isMDXComponent=!0;const yin={toc:[]},Din="wrapper";function Min(t){let{components:e,...n}=t;return(0,s.kt)(Din,(0,p.Z)({},yin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Min.isMDXComponent=!0;const Xin={toc:[]},_in="wrapper";function win(t){let{components:e,...n}=t;return(0,s.kt)(_in,(0,p.Z)({},Xin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}win.isMDXComponent=!0;const Tin={toc:[]},Cin="wrapper";function xin(t){let{components:e,...n}=t;return(0,s.kt)(Cin,(0,p.Z)({},Tin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}xin.isMDXComponent=!0;const gin={toc:[]},vin="wrapper";function Lin(t){let{components:e,...n}=t;return(0,s.kt)(vin,(0,p.Z)({},gin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Lin.isMDXComponent=!0;const Zin={toc:[]},bin="wrapper";function Nin(t){let{components:e,...n}=t;return(0,s.kt)(bin,(0,p.Z)({},Zin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Nin.isMDXComponent=!0;const zin={toc:[]},Ain="wrapper";function Pin(t){let{components:e,...n}=t;return(0,s.kt)(Ain,(0,p.Z)({},zin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Pin.isMDXComponent=!0;const Win={toc:[]},Rin="wrapper";function Iin(t){let{components:e,...n}=t;return(0,s.kt)(Rin,(0,p.Z)({},Win,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Iin.isMDXComponent=!0;const Sin={toc:[]},Bin="wrapper";function Gin(t){let{components:e,...n}=t;return(0,s.kt)(Bin,(0,p.Z)({},Sin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Gin.isMDXComponent=!0;const Ein={toc:[]},Oin="wrapper";function Fin(t){let{components:e,...n}=t;return(0,s.kt)(Oin,(0,p.Z)({},Ein,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Fin.isMDXComponent=!0;const Uin={toc:[]},Vin="wrapper";function qin(t){let{components:e,...n}=t;return(0,s.kt)(Vin,(0,p.Z)({},Uin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}qin.isMDXComponent=!0;const jin={toc:[]},Yin="wrapper";function Qin(t){let{components:e,...n}=t;return(0,s.kt)(Yin,(0,p.Z)({},jin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Qin.isMDXComponent=!0;const Hin={toc:[]},Kin="wrapper";function $in(t){let{components:e,...n}=t;return(0,s.kt)(Kin,(0,p.Z)({},Hin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}$in.isMDXComponent=!0;const Jin={toc:[]},tln="wrapper";function eln(t){let{components:e,...n}=t;return(0,s.kt)(tln,(0,p.Z)({},Jin,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}eln.isMDXComponent=!0;const nln={toc:[]},oln="wrapper";function pln(t){let{components:e,...n}=t;return(0,s.kt)(oln,(0,p.Z)({},nln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}pln.isMDXComponent=!0;const rln={toc:[]},sln="wrapper";function cln(t){let{components:e,...n}=t;return(0,s.kt)(sln,(0,p.Z)({},rln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}cln.isMDXComponent=!0;const aln={toc:[]},iln="wrapper";function lln(t){let{components:e,...n}=t;return(0,s.kt)(iln,(0,p.Z)({},aln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}lln.isMDXComponent=!0;const uln={toc:[]},mln="wrapper";function dln(t){let{components:e,...n}=t;return(0,s.kt)(mln,(0,p.Z)({},uln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}dln.isMDXComponent=!0;const hln={toc:[]},fln="wrapper";function kln(t){let{components:e,...n}=t;return(0,s.kt)(fln,(0,p.Z)({},hln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}kln.isMDXComponent=!0;const yln={toc:[]},Dln="wrapper";function Mln(t){let{components:e,...n}=t;return(0,s.kt)(Dln,(0,p.Z)({},yln,n,{components:e,mdxType:"MDXLayout"}))}Mln.isMDXComponent=!0;const Xln={toc:[]},_ln="wrapper";function wln(t){let{components:e,...n}=t;return(0,s.kt)(_ln,(0,p.Z)({},Xln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}wln.isMDXComponent=!0;const Tln={toc:[]},Cln="wrapper";function xln(t){let{components:e,...n}=t;return(0,s.kt)(Cln,(0,p.Z)({},Tln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Polygon\n  size={320}\n  sides={7}\n  stroke={'#fff'}\n  lineWidth={8}\n  fill={'lightseagreen'}\n/>\n")))}xln.isMDXComponent=!0;const gln={toc:[]},vln="wrapper";function Lln(t){let{components:e,...n}=t;return(0,s.kt)(vln,(0,p.Z)({},gln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}Lln.isMDXComponent=!0;const Zln={toc:[]},bln="wrapper";function Nln(t){let{components:e,...n}=t;return(0,s.kt)(bln,(0,p.Z)({},Zln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Nln.isMDXComponent=!0;const zln={toc:[]},Aln="wrapper";function Pln(t){let{components:e,...n}=t;return(0,s.kt)(Aln,(0,p.Z)({},zln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Pln.isMDXComponent=!0;const Wln={toc:[]},Rln="wrapper";function Iln(t){let{components:e,...n}=t;return(0,s.kt)(Rln,(0,p.Z)({},Wln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Iln.isMDXComponent=!0;const Sln={toc:[]},Bln="wrapper";function Gln(t){let{components:e,...n}=t;return(0,s.kt)(Bln,(0,p.Z)({},Sln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Gln.isMDXComponent=!0;const Eln={toc:[]},Oln="wrapper";function Fln(t){let{components:e,...n}=t;return(0,s.kt)(Oln,(0,p.Z)({},Eln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Fln.isMDXComponent=!0;const Uln={toc:[]},Vln="wrapper";function qln(t){let{components:e,...n}=t;return(0,s.kt)(Vln,(0,p.Z)({},Uln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}qln.isMDXComponent=!0;const jln={toc:[]},Yln="wrapper";function Qln(t){let{components:e,...n}=t;return(0,s.kt)(Yln,(0,p.Z)({},jln,n,{components:e,mdxType:"MDXLayout"}))}Qln.isMDXComponent=!0;const Hln={toc:[]},Kln="wrapper";function $ln(t){let{components:e,...n}=t;return(0,s.kt)(Kln,(0,p.Z)({},Hln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}$ln.isMDXComponent=!0;const Jln={toc:[]},tun="wrapper";function eun(t){let{components:e,...n}=t;return(0,s.kt)(tun,(0,p.Z)({},Jln,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}eun.isMDXComponent=!0;const nun={toc:[]},oun="wrapper";function pun(t){let{components:e,...n}=t;return(0,s.kt)(oun,(0,p.Z)({},nun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}pun.isMDXComponent=!0;const run={toc:[]},sun="wrapper";function cun(t){let{components:e,...n}=t;return(0,s.kt)(sun,(0,p.Z)({},run,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}cun.isMDXComponent=!0;const aun={toc:[]},iun="wrapper";function lun(t){let{components:e,...n}=t;return(0,s.kt)(iun,(0,p.Z)({},aun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}lun.isMDXComponent=!0;const uun={toc:[]},mun="wrapper";function dun(t){let{components:e,...n}=t;return(0,s.kt)(mun,(0,p.Z)({},uun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}dun.isMDXComponent=!0;const hun={toc:[]},fun="wrapper";function kun(t){let{components:e,...n}=t;return(0,s.kt)(fun,(0,p.Z)({},hun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}kun.isMDXComponent=!0;const yun={toc:[]},Dun="wrapper";function Mun(t){let{components:e,...n}=t;return(0,s.kt)(Dun,(0,p.Z)({},yun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Mun.isMDXComponent=!0;const Xun={toc:[]},_un="wrapper";function wun(t){let{components:e,...n}=t;return(0,s.kt)(_un,(0,p.Z)({},Xun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}wun.isMDXComponent=!0;const Tun={toc:[]},Cun="wrapper";function xun(t){let{components:e,...n}=t;return(0,s.kt)(Cun,(0,p.Z)({},Tun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}xun.isMDXComponent=!0;const gun={toc:[]},vun="wrapper";function Lun(t){let{components:e,...n}=t;return(0,s.kt)(vun,(0,p.Z)({},gun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Lun.isMDXComponent=!0;const Zun={toc:[]},bun="wrapper";function Nun(t){let{components:e,...n}=t;return(0,s.kt)(bun,(0,p.Z)({},Zun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Nun.isMDXComponent=!0;const zun={toc:[]},Aun="wrapper";function Pun(t){let{components:e,...n}=t;return(0,s.kt)(Aun,(0,p.Z)({},zun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Pun.isMDXComponent=!0;const Wun={toc:[]},Run="wrapper";function Iun(t){let{components:e,...n}=t;return(0,s.kt)(Run,(0,p.Z)({},Wun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Iun.isMDXComponent=!0;const Sun={toc:[]},Bun="wrapper";function Gun(t){let{components:e,...n}=t;return(0,s.kt)(Bun,(0,p.Z)({},Sun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Gun.isMDXComponent=!0;const Eun={toc:[]},Oun="wrapper";function Fun(t){let{components:e,...n}=t;return(0,s.kt)(Oun,(0,p.Z)({},Eun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Fun.isMDXComponent=!0;const Uun={toc:[]},Vun="wrapper";function qun(t){let{components:e,...n}=t;return(0,s.kt)(Vun,(0,p.Z)({},Uun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}qun.isMDXComponent=!0;const jun={toc:[]},Yun="wrapper";function Qun(t){let{components:e,...n}=t;return(0,s.kt)(Yun,(0,p.Z)({},jun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Qun.isMDXComponent=!0;const Hun={toc:[]},Kun="wrapper";function $un(t){let{components:e,...n}=t;return(0,s.kt)(Kun,(0,p.Z)({},Hun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}$un.isMDXComponent=!0;const Jun={toc:[]},tmn="wrapper";function emn(t){let{components:e,...n}=t;return(0,s.kt)(tmn,(0,p.Z)({},Jun,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}emn.isMDXComponent=!0;const nmn={toc:[]},omn="wrapper";function pmn(t){let{components:e,...n}=t;return(0,s.kt)(omn,(0,p.Z)({},nmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}pmn.isMDXComponent=!0;const rmn={toc:[]},smn="wrapper";function cmn(t){let{components:e,...n}=t;return(0,s.kt)(smn,(0,p.Z)({},rmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}cmn.isMDXComponent=!0;const amn={toc:[]},imn="wrapper";function lmn(t){let{components:e,...n}=t;return(0,s.kt)(imn,(0,p.Z)({},amn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}lmn.isMDXComponent=!0;const umn={toc:[]},mmn="wrapper";function dmn(t){let{components:e,...n}=t;return(0,s.kt)(mmn,(0,p.Z)({},umn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}dmn.isMDXComponent=!0;const hmn={toc:[]},fmn="wrapper";function kmn(t){let{components:e,...n}=t;return(0,s.kt)(fmn,(0,p.Z)({},hmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}kmn.isMDXComponent=!0;const ymn={toc:[]},Dmn="wrapper";function Mmn(t){let{components:e,...n}=t;return(0,s.kt)(Dmn,(0,p.Z)({},ymn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Mmn.isMDXComponent=!0;const Xmn={toc:[]},_mn="wrapper";function wmn(t){let{components:e,...n}=t;return(0,s.kt)(_mn,(0,p.Z)({},Xmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}wmn.isMDXComponent=!0;const Tmn={toc:[]},Cmn="wrapper";function xmn(t){let{components:e,...n}=t;return(0,s.kt)(Cmn,(0,p.Z)({},Tmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}xmn.isMDXComponent=!0;const gmn={toc:[]},vmn="wrapper";function Lmn(t){let{components:e,...n}=t;return(0,s.kt)(vmn,(0,p.Z)({},gmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Lmn.isMDXComponent=!0;const Zmn={toc:[]},bmn="wrapper";function Nmn(t){let{components:e,...n}=t;return(0,s.kt)(bmn,(0,p.Z)({},Zmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Nmn.isMDXComponent=!0;const zmn={toc:[]},Amn="wrapper";function Pmn(t){let{components:e,...n}=t;return(0,s.kt)(Amn,(0,p.Z)({},zmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Pmn.isMDXComponent=!0;const Wmn={toc:[]},Rmn="wrapper";function Imn(t){let{components:e,...n}=t;return(0,s.kt)(Rmn,(0,p.Z)({},Wmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Imn.isMDXComponent=!0;const Smn={toc:[]},Bmn="wrapper";function Gmn(t){let{components:e,...n}=t;return(0,s.kt)(Bmn,(0,p.Z)({},Smn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Gmn.isMDXComponent=!0;const Emn={toc:[]},Omn="wrapper";function Fmn(t){let{components:e,...n}=t;return(0,s.kt)(Omn,(0,p.Z)({},Emn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Fmn.isMDXComponent=!0;const Umn={toc:[]},Vmn="wrapper";function qmn(t){let{components:e,...n}=t;return(0,s.kt)(Vmn,(0,p.Z)({},Umn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}qmn.isMDXComponent=!0;const jmn={toc:[]},Ymn="wrapper";function Qmn(t){let{components:e,...n}=t;return(0,s.kt)(Ymn,(0,p.Z)({},jmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Qmn.isMDXComponent=!0;const Hmn={toc:[]},Kmn="wrapper";function $mn(t){let{components:e,...n}=t;return(0,s.kt)(Kmn,(0,p.Z)({},Hmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}$mn.isMDXComponent=!0;const Jmn={toc:[]},tdn="wrapper";function edn(t){let{components:e,...n}=t;return(0,s.kt)(tdn,(0,p.Z)({},Jmn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}edn.isMDXComponent=!0;const ndn={toc:[]},odn="wrapper";function pdn(t){let{components:e,...n}=t;return(0,s.kt)(odn,(0,p.Z)({},ndn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pdn.isMDXComponent=!0;const rdn={toc:[]},sdn="wrapper";function cdn(t){let{components:e,...n}=t;return(0,s.kt)(sdn,(0,p.Z)({},rdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}cdn.isMDXComponent=!0;const adn={toc:[]},idn="wrapper";function ldn(t){let{components:e,...n}=t;return(0,s.kt)(idn,(0,p.Z)({},adn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}ldn.isMDXComponent=!0;const udn={toc:[]},mdn="wrapper";function ddn(t){let{components:e,...n}=t;return(0,s.kt)(mdn,(0,p.Z)({},udn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}ddn.isMDXComponent=!0;const hdn={toc:[]},fdn="wrapper";function kdn(t){let{components:e,...n}=t;return(0,s.kt)(fdn,(0,p.Z)({},hdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kdn.isMDXComponent=!0;const ydn={toc:[]},Ddn="wrapper";function Mdn(t){let{components:e,...n}=t;return(0,s.kt)(Ddn,(0,p.Z)({},ydn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}Mdn.isMDXComponent=!0;const Xdn={toc:[]},_dn="wrapper";function wdn(t){let{components:e,...n}=t;return(0,s.kt)(_dn,(0,p.Z)({},Xdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wdn.isMDXComponent=!0;const Tdn={toc:[]},Cdn="wrapper";function xdn(t){let{components:e,...n}=t;return(0,s.kt)(Cdn,(0,p.Z)({},Tdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}xdn.isMDXComponent=!0;const gdn={toc:[]},vdn="wrapper";function Ldn(t){let{components:e,...n}=t;return(0,s.kt)(vdn,(0,p.Z)({},gdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ldn.isMDXComponent=!0;const Zdn={toc:[]},bdn="wrapper";function Ndn(t){let{components:e,...n}=t;return(0,s.kt)(bdn,(0,p.Z)({},Zdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Ndn.isMDXComponent=!0;const zdn={toc:[]},Adn="wrapper";function Pdn(t){let{components:e,...n}=t;return(0,s.kt)(Adn,(0,p.Z)({},zdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Pdn.isMDXComponent=!0;const Wdn={toc:[]},Rdn="wrapper";function Idn(t){let{components:e,...n}=t;return(0,s.kt)(Rdn,(0,p.Z)({},Wdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Idn.isMDXComponent=!0;const Sdn={toc:[]},Bdn="wrapper";function Gdn(t){let{components:e,...n}=t;return(0,s.kt)(Bdn,(0,p.Z)({},Sdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Gdn.isMDXComponent=!0;const Edn={toc:[]},Odn="wrapper";function Fdn(t){let{components:e,...n}=t;return(0,s.kt)(Odn,(0,p.Z)({},Edn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Fdn.isMDXComponent=!0;const Udn={toc:[]},Vdn="wrapper";function qdn(t){let{components:e,...n}=t;return(0,s.kt)(Vdn,(0,p.Z)({},Udn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qdn.isMDXComponent=!0;const jdn={toc:[]},Ydn="wrapper";function Qdn(t){let{components:e,...n}=t;return(0,s.kt)(Ydn,(0,p.Z)({},jdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Qdn.isMDXComponent=!0;const Hdn={toc:[]},Kdn="wrapper";function $dn(t){let{components:e,...n}=t;return(0,s.kt)(Kdn,(0,p.Z)({},Hdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}$dn.isMDXComponent=!0;const Jdn={toc:[]},thn="wrapper";function ehn(t){let{components:e,...n}=t;return(0,s.kt)(thn,(0,p.Z)({},Jdn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}ehn.isMDXComponent=!0;const nhn={toc:[]},ohn="wrapper";function phn(t){let{components:e,...n}=t;return(0,s.kt)(ohn,(0,p.Z)({},nhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}phn.isMDXComponent=!0;const rhn={toc:[]},shn="wrapper";function chn(t){let{components:e,...n}=t;return(0,s.kt)(shn,(0,p.Z)({},rhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}chn.isMDXComponent=!0;const ahn={toc:[]},ihn="wrapper";function lhn(t){let{components:e,...n}=t;return(0,s.kt)(ihn,(0,p.Z)({},ahn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}lhn.isMDXComponent=!0;const uhn={toc:[]},mhn="wrapper";function dhn(t){let{components:e,...n}=t;return(0,s.kt)(mhn,(0,p.Z)({},uhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}dhn.isMDXComponent=!0;const hhn={toc:[]},fhn="wrapper";function khn(t){let{components:e,...n}=t;return(0,s.kt)(fhn,(0,p.Z)({},hhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}khn.isMDXComponent=!0;const yhn={toc:[]},Dhn="wrapper";function Mhn(t){let{components:e,...n}=t;return(0,s.kt)(Dhn,(0,p.Z)({},yhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Mhn.isMDXComponent=!0;const Xhn={toc:[]},_hn="wrapper";function whn(t){let{components:e,...n}=t;return(0,s.kt)(_hn,(0,p.Z)({},Xhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}whn.isMDXComponent=!0;const Thn={toc:[]},Chn="wrapper";function xhn(t){let{components:e,...n}=t;return(0,s.kt)(Chn,(0,p.Z)({},Thn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}xhn.isMDXComponent=!0;const ghn={toc:[]},vhn="wrapper";function Lhn(t){let{components:e,...n}=t;return(0,s.kt)(vhn,(0,p.Z)({},ghn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Lhn.isMDXComponent=!0;const Zhn={toc:[]},bhn="wrapper";function Nhn(t){let{components:e,...n}=t;return(0,s.kt)(bhn,(0,p.Z)({},Zhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Nhn.isMDXComponent=!0;const zhn={toc:[]},Ahn="wrapper";function Phn(t){let{components:e,...n}=t;return(0,s.kt)(Ahn,(0,p.Z)({},zhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Phn.isMDXComponent=!0;const Whn={toc:[]},Rhn="wrapper";function Ihn(t){let{components:e,...n}=t;return(0,s.kt)(Rhn,(0,p.Z)({},Whn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Ihn.isMDXComponent=!0;const Shn={toc:[]},Bhn="wrapper";function Ghn(t){let{components:e,...n}=t;return(0,s.kt)(Bhn,(0,p.Z)({},Shn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Ghn.isMDXComponent=!0;const Ehn={toc:[]},Ohn="wrapper";function Fhn(t){let{components:e,...n}=t;return(0,s.kt)(Ohn,(0,p.Z)({},Ehn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Fhn.isMDXComponent=!0;const Uhn={toc:[]},Vhn="wrapper";function qhn(t){let{components:e,...n}=t;return(0,s.kt)(Vhn,(0,p.Z)({},Uhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}qhn.isMDXComponent=!0;const jhn={toc:[]},Yhn="wrapper";function Qhn(t){let{components:e,...n}=t;return(0,s.kt)(Yhn,(0,p.Z)({},jhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Qhn.isMDXComponent=!0;const Hhn={toc:[]},Khn="wrapper";function $hn(t){let{components:e,...n}=t;return(0,s.kt)(Khn,(0,p.Z)({},Hhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}$hn.isMDXComponent=!0;const Jhn={toc:[]},tfn="wrapper";function efn(t){let{components:e,...n}=t;return(0,s.kt)(tfn,(0,p.Z)({},Jhn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}efn.isMDXComponent=!0;const nfn={toc:[]},ofn="wrapper";function pfn(t){let{components:e,...n}=t;return(0,s.kt)(ofn,(0,p.Z)({},nfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}pfn.isMDXComponent=!0;const rfn={toc:[]},sfn="wrapper";function cfn(t){let{components:e,...n}=t;return(0,s.kt)(sfn,(0,p.Z)({},rfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}cfn.isMDXComponent=!0;const afn={toc:[]},ifn="wrapper";function lfn(t){let{components:e,...n}=t;return(0,s.kt)(ifn,(0,p.Z)({},afn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}lfn.isMDXComponent=!0;const ufn={toc:[]},mfn="wrapper";function dfn(t){let{components:e,...n}=t;return(0,s.kt)(mfn,(0,p.Z)({},ufn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}dfn.isMDXComponent=!0;const hfn={toc:[]},ffn="wrapper";function kfn(t){let{components:e,...n}=t;return(0,s.kt)(ffn,(0,p.Z)({},hfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}kfn.isMDXComponent=!0;const yfn={toc:[]},Dfn="wrapper";function Mfn(t){let{components:e,...n}=t;return(0,s.kt)(Dfn,(0,p.Z)({},yfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Mfn.isMDXComponent=!0;const Xfn={toc:[]},_fn="wrapper";function wfn(t){let{components:e,...n}=t;return(0,s.kt)(_fn,(0,p.Z)({},Xfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}wfn.isMDXComponent=!0;const Tfn={toc:[]},Cfn="wrapper";function xfn(t){let{components:e,...n}=t;return(0,s.kt)(Cfn,(0,p.Z)({},Tfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}xfn.isMDXComponent=!0;const gfn={toc:[]},vfn="wrapper";function Lfn(t){let{components:e,...n}=t;return(0,s.kt)(vfn,(0,p.Z)({},gfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Lfn.isMDXComponent=!0;const Zfn={toc:[]},bfn="wrapper";function Nfn(t){let{components:e,...n}=t;return(0,s.kt)(bfn,(0,p.Z)({},Zfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Nfn.isMDXComponent=!0;const zfn={toc:[]},Afn="wrapper";function Pfn(t){let{components:e,...n}=t;return(0,s.kt)(Afn,(0,p.Z)({},zfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Pfn.isMDXComponent=!0;const Wfn={toc:[]},Rfn="wrapper";function Ifn(t){let{components:e,...n}=t;return(0,s.kt)(Rfn,(0,p.Z)({},Wfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Ifn.isMDXComponent=!0;const Sfn={toc:[]},Bfn="wrapper";function Gfn(t){let{components:e,...n}=t;return(0,s.kt)(Bfn,(0,p.Z)({},Sfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Gfn.isMDXComponent=!0;const Efn={toc:[]},Ofn="wrapper";function Ffn(t){let{components:e,...n}=t;return(0,s.kt)(Ofn,(0,p.Z)({},Efn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Ffn.isMDXComponent=!0;const Ufn={toc:[]},Vfn="wrapper";function qfn(t){let{components:e,...n}=t;return(0,s.kt)(Vfn,(0,p.Z)({},Ufn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}qfn.isMDXComponent=!0;const jfn={toc:[]},Yfn="wrapper";function Qfn(t){let{components:e,...n}=t;return(0,s.kt)(Yfn,(0,p.Z)({},jfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Qfn.isMDXComponent=!0;const Hfn={toc:[]},Kfn="wrapper";function $fn(t){let{components:e,...n}=t;return(0,s.kt)(Kfn,(0,p.Z)({},Hfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}$fn.isMDXComponent=!0;const Jfn={toc:[]},tkn="wrapper";function ekn(t){let{components:e,...n}=t;return(0,s.kt)(tkn,(0,p.Z)({},Jfn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}ekn.isMDXComponent=!0;const nkn={toc:[]},okn="wrapper";function pkn(t){let{components:e,...n}=t;return(0,s.kt)(okn,(0,p.Z)({},nkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}pkn.isMDXComponent=!0;const rkn={toc:[]},skn="wrapper";function ckn(t){let{components:e,...n}=t;return(0,s.kt)(skn,(0,p.Z)({},rkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}ckn.isMDXComponent=!0;const akn={toc:[]},ikn="wrapper";function lkn(t){let{components:e,...n}=t;return(0,s.kt)(ikn,(0,p.Z)({},akn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}lkn.isMDXComponent=!0;const ukn={toc:[]},mkn="wrapper";function dkn(t){let{components:e,...n}=t;return(0,s.kt)(mkn,(0,p.Z)({},ukn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}dkn.isMDXComponent=!0;const hkn={toc:[]},fkn="wrapper";function kkn(t){let{components:e,...n}=t;return(0,s.kt)(fkn,(0,p.Z)({},hkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}kkn.isMDXComponent=!0;const ykn={toc:[]},Dkn="wrapper";function Mkn(t){let{components:e,...n}=t;return(0,s.kt)(Dkn,(0,p.Z)({},ykn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Mkn.isMDXComponent=!0;const Xkn={toc:[]},_kn="wrapper";function wkn(t){let{components:e,...n}=t;return(0,s.kt)(_kn,(0,p.Z)({},Xkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}wkn.isMDXComponent=!0;const Tkn={toc:[]},Ckn="wrapper";function xkn(t){let{components:e,...n}=t;return(0,s.kt)(Ckn,(0,p.Z)({},Tkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}xkn.isMDXComponent=!0;const gkn={toc:[]},vkn="wrapper";function Lkn(t){let{components:e,...n}=t;return(0,s.kt)(vkn,(0,p.Z)({},gkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Lkn.isMDXComponent=!0;const Zkn={toc:[]},bkn="wrapper";function Nkn(t){let{components:e,...n}=t;return(0,s.kt)(bkn,(0,p.Z)({},Zkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Nkn.isMDXComponent=!0;const zkn={toc:[]},Akn="wrapper";function Pkn(t){let{components:e,...n}=t;return(0,s.kt)(Akn,(0,p.Z)({},zkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Pkn.isMDXComponent=!0;const Wkn={toc:[]},Rkn="wrapper";function Ikn(t){let{components:e,...n}=t;return(0,s.kt)(Rkn,(0,p.Z)({},Wkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Ikn.isMDXComponent=!0;const Skn={toc:[]},Bkn="wrapper";function Gkn(t){let{components:e,...n}=t;return(0,s.kt)(Bkn,(0,p.Z)({},Skn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Gkn.isMDXComponent=!0;const Ekn={toc:[]},Okn="wrapper";function Fkn(t){let{components:e,...n}=t;return(0,s.kt)(Okn,(0,p.Z)({},Ekn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Fkn.isMDXComponent=!0;const Ukn={toc:[]},Vkn="wrapper";function qkn(t){let{components:e,...n}=t;return(0,s.kt)(Vkn,(0,p.Z)({},Ukn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}qkn.isMDXComponent=!0;const jkn={toc:[]},Ykn="wrapper";function Qkn(t){let{components:e,...n}=t;return(0,s.kt)(Ykn,(0,p.Z)({},jkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Qkn.isMDXComponent=!0;const Hkn={toc:[]},Kkn="wrapper";function $kn(t){let{components:e,...n}=t;return(0,s.kt)(Kkn,(0,p.Z)({},Hkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$kn.isMDXComponent=!0;const Jkn={toc:[]},tyn="wrapper";function eyn(t){let{components:e,...n}=t;return(0,s.kt)(tyn,(0,p.Z)({},Jkn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}eyn.isMDXComponent=!0;const nyn={toc:[]},oyn="wrapper";function pyn(t){let{components:e,...n}=t;return(0,s.kt)(oyn,(0,p.Z)({},nyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}pyn.isMDXComponent=!0;const ryn={toc:[]},syn="wrapper";function cyn(t){let{components:e,...n}=t;return(0,s.kt)(syn,(0,p.Z)({},ryn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}cyn.isMDXComponent=!0;const ayn={toc:[]},iyn="wrapper";function lyn(t){let{components:e,...n}=t;return(0,s.kt)(iyn,(0,p.Z)({},ayn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}lyn.isMDXComponent=!0;const uyn={toc:[]},myn="wrapper";function dyn(t){let{components:e,...n}=t;return(0,s.kt)(myn,(0,p.Z)({},uyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}dyn.isMDXComponent=!0;const hyn={toc:[]},fyn="wrapper";function kyn(t){let{components:e,...n}=t;return(0,s.kt)(fyn,(0,p.Z)({},hyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}kyn.isMDXComponent=!0;const yyn={toc:[]},Dyn="wrapper";function Myn(t){let{components:e,...n}=t;return(0,s.kt)(Dyn,(0,p.Z)({},yyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Myn.isMDXComponent=!0;const Xyn={toc:[]},_yn="wrapper";function wyn(t){let{components:e,...n}=t;return(0,s.kt)(_yn,(0,p.Z)({},Xyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}wyn.isMDXComponent=!0;const Tyn={toc:[]},Cyn="wrapper";function xyn(t){let{components:e,...n}=t;return(0,s.kt)(Cyn,(0,p.Z)({},Tyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}xyn.isMDXComponent=!0;const gyn={toc:[]},vyn="wrapper";function Lyn(t){let{components:e,...n}=t;return(0,s.kt)(vyn,(0,p.Z)({},gyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Lyn.isMDXComponent=!0;const Zyn={toc:[]},byn="wrapper";function Nyn(t){let{components:e,...n}=t;return(0,s.kt)(byn,(0,p.Z)({},Zyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Nyn.isMDXComponent=!0;const zyn={toc:[]},Ayn="wrapper";function Pyn(t){let{components:e,...n}=t;return(0,s.kt)(Ayn,(0,p.Z)({},zyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}Pyn.isMDXComponent=!0;const Wyn={toc:[]},Ryn="wrapper";function Iyn(t){let{components:e,...n}=t;return(0,s.kt)(Ryn,(0,p.Z)({},Wyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Iyn.isMDXComponent=!0;const Syn={toc:[]},Byn="wrapper";function Gyn(t){let{components:e,...n}=t;return(0,s.kt)(Byn,(0,p.Z)({},Syn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Gyn.isMDXComponent=!0;const Eyn={toc:[]},Oyn="wrapper";function Fyn(t){let{components:e,...n}=t;return(0,s.kt)(Oyn,(0,p.Z)({},Eyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Fyn.isMDXComponent=!0;const Uyn={toc:[]},Vyn="wrapper";function qyn(t){let{components:e,...n}=t;return(0,s.kt)(Vyn,(0,p.Z)({},Uyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}qyn.isMDXComponent=!0;const jyn={toc:[]},Yyn="wrapper";function Qyn(t){let{components:e,...n}=t;return(0,s.kt)(Yyn,(0,p.Z)({},jyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Qyn.isMDXComponent=!0;const Hyn={toc:[]},Kyn="wrapper";function $yn(t){let{components:e,...n}=t;return(0,s.kt)(Kyn,(0,p.Z)({},Hyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}$yn.isMDXComponent=!0;const Jyn={toc:[]},tDn="wrapper";function eDn(t){let{components:e,...n}=t;return(0,s.kt)(tDn,(0,p.Z)({},Jyn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}eDn.isMDXComponent=!0;const nDn={toc:[]},oDn="wrapper";function pDn(t){let{components:e,...n}=t;return(0,s.kt)(oDn,(0,p.Z)({},nDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}pDn.isMDXComponent=!0;const rDn={toc:[]},sDn="wrapper";function cDn(t){let{components:e,...n}=t;return(0,s.kt)(sDn,(0,p.Z)({},rDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}cDn.isMDXComponent=!0;const aDn={toc:[]},iDn="wrapper";function lDn(t){let{components:e,...n}=t;return(0,s.kt)(iDn,(0,p.Z)({},aDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}lDn.isMDXComponent=!0;const uDn={toc:[]},mDn="wrapper";function dDn(t){let{components:e,...n}=t;return(0,s.kt)(mDn,(0,p.Z)({},uDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}dDn.isMDXComponent=!0;const hDn={toc:[]},fDn="wrapper";function kDn(t){let{components:e,...n}=t;return(0,s.kt)(fDn,(0,p.Z)({},hDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}kDn.isMDXComponent=!0;const yDn={toc:[]},DDn="wrapper";function MDn(t){let{components:e,...n}=t;return(0,s.kt)(DDn,(0,p.Z)({},yDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}MDn.isMDXComponent=!0;const XDn={toc:[]},_Dn="wrapper";function wDn(t){let{components:e,...n}=t;return(0,s.kt)(_Dn,(0,p.Z)({},XDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}wDn.isMDXComponent=!0;const TDn={toc:[]},CDn="wrapper";function xDn(t){let{components:e,...n}=t;return(0,s.kt)(CDn,(0,p.Z)({},TDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}xDn.isMDXComponent=!0;const gDn={toc:[]},vDn="wrapper";function LDn(t){let{components:e,...n}=t;return(0,s.kt)(vDn,(0,p.Z)({},gDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}LDn.isMDXComponent=!0;const ZDn={toc:[]},bDn="wrapper";function NDn(t){let{components:e,...n}=t;return(0,s.kt)(bDn,(0,p.Z)({},ZDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Polygon#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}NDn.isMDXComponent=!0;const zDn={toc:[]},ADn="wrapper";function PDn(t){let{components:e,...n}=t;return(0,s.kt)(ADn,(0,p.Z)({},zDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}PDn.isMDXComponent=!0;const WDn={toc:[]},RDn="wrapper";function IDn(t){let{components:e,...n}=t;return(0,s.kt)(RDn,(0,p.Z)({},WDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}IDn.isMDXComponent=!0;const SDn={toc:[]},BDn="wrapper";function GDn(t){let{components:e,...n}=t;return(0,s.kt)(BDn,(0,p.Z)({},SDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}GDn.isMDXComponent=!0;const EDn={toc:[]},ODn="wrapper";function FDn(t){let{components:e,...n}=t;return(0,s.kt)(ODn,(0,p.Z)({},EDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}FDn.isMDXComponent=!0;const UDn={toc:[]},VDn="wrapper";function qDn(t){let{components:e,...n}=t;return(0,s.kt)(VDn,(0,p.Z)({},UDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}qDn.isMDXComponent=!0;const jDn={toc:[]},YDn="wrapper";function QDn(t){let{components:e,...n}=t;return(0,s.kt)(YDn,(0,p.Z)({},jDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}QDn.isMDXComponent=!0;const HDn={toc:[]},KDn="wrapper";function $Dn(t){let{components:e,...n}=t;return(0,s.kt)(KDn,(0,p.Z)({},HDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D, QuadBezier} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const bezier = createRef<QuadBezier>();\n\n  view.add(\n    <QuadBezier\n      ref={bezier}\n      lineWidth={4}\n      stroke={'lightseagreen'}\n      p0={[-200, 0]}\n      p1={[0, -200]}\n      p2={[200, 0]}\n      end={0}\n    />\n  );\n\n  yield* bezier().end(1, 1);\n  yield* bezier().start(1, 1).to(0, 1);\n});\n")))}$Dn.isMDXComponent=!0;const JDn={toc:[]},tMn="wrapper";function eMn(t){let{components:e,...n}=t;return(0,s.kt)(tMn,(0,p.Z)({},JDn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a quadratic B\xe9zier curve."))}eMn.isMDXComponent=!0;const nMn={toc:[]},oMn="wrapper";function pMn(t){let{components:e,...n}=t;return(0,s.kt)(oMn,(0,p.Z)({},nMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}pMn.isMDXComponent=!0;const rMn={toc:[]},sMn="wrapper";function cMn(t){let{components:e,...n}=t;return(0,s.kt)(sMn,(0,p.Z)({},rMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}cMn.isMDXComponent=!0;const aMn={toc:[]},iMn="wrapper";function lMn(t){let{components:e,...n}=t;return(0,s.kt)(iMn,(0,p.Z)({},aMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}lMn.isMDXComponent=!0;const uMn={toc:[]},mMn="wrapper";function dMn(t){let{components:e,...n}=t;return(0,s.kt)(mMn,(0,p.Z)({},uMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}dMn.isMDXComponent=!0;const hMn={toc:[]},fMn="wrapper";function kMn(t){let{components:e,...n}=t;return(0,s.kt)(fMn,(0,p.Z)({},hMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}kMn.isMDXComponent=!0;const yMn={toc:[]},DMn="wrapper";function MMn(t){let{components:e,...n}=t;return(0,s.kt)(DMn,(0,p.Z)({},yMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}MMn.isMDXComponent=!0;const XMn={toc:[]},_Mn="wrapper";function wMn(t){let{components:e,...n}=t;return(0,s.kt)(_Mn,(0,p.Z)({},XMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}wMn.isMDXComponent=!0;const TMn={toc:[]},CMn="wrapper";function xMn(t){let{components:e,...n}=t;return(0,s.kt)(CMn,(0,p.Z)({},TMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}xMn.isMDXComponent=!0;const gMn={toc:[]},vMn="wrapper";function LMn(t){let{components:e,...n}=t;return(0,s.kt)(vMn,(0,p.Z)({},gMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}LMn.isMDXComponent=!0;const ZMn={toc:[]},bMn="wrapper";function NMn(t){let{components:e,...n}=t;return(0,s.kt)(bMn,(0,p.Z)({},ZMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}NMn.isMDXComponent=!0;const zMn={toc:[]},AMn="wrapper";function PMn(t){let{components:e,...n}=t;return(0,s.kt)(AMn,(0,p.Z)({},zMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}PMn.isMDXComponent=!0;const WMn={toc:[]},RMn="wrapper";function IMn(t){let{components:e,...n}=t;return(0,s.kt)(RMn,(0,p.Z)({},WMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}IMn.isMDXComponent=!0;const SMn={toc:[]},BMn="wrapper";function GMn(t){let{components:e,...n}=t;return(0,s.kt)(BMn,(0,p.Z)({},SMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}GMn.isMDXComponent=!0;const EMn={toc:[]},OMn="wrapper";function FMn(t){let{components:e,...n}=t;return(0,s.kt)(OMn,(0,p.Z)({},EMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}FMn.isMDXComponent=!0;const UMn={toc:[]},VMn="wrapper";function qMn(t){let{components:e,...n}=t;return(0,s.kt)(VMn,(0,p.Z)({},UMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}qMn.isMDXComponent=!0;const jMn={toc:[]},YMn="wrapper";function QMn(t){let{components:e,...n}=t;return(0,s.kt)(YMn,(0,p.Z)({},jMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}QMn.isMDXComponent=!0;const HMn={toc:[]},KMn="wrapper";function $Mn(t){let{components:e,...n}=t;return(0,s.kt)(KMn,(0,p.Z)({},HMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}$Mn.isMDXComponent=!0;const JMn={toc:[]},tXn="wrapper";function eXn(t){let{components:e,...n}=t;return(0,s.kt)(tXn,(0,p.Z)({},JMn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}eXn.isMDXComponent=!0;const nXn={toc:[]},oXn="wrapper";function pXn(t){let{components:e,...n}=t;return(0,s.kt)(oXn,(0,p.Z)({},nXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pXn.isMDXComponent=!0;const rXn={toc:[]},sXn="wrapper";function cXn(t){let{components:e,...n}=t;return(0,s.kt)(sXn,(0,p.Z)({},rXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}cXn.isMDXComponent=!0;const aXn={toc:[]},iXn="wrapper";function lXn(t){let{components:e,...n}=t;return(0,s.kt)(iXn,(0,p.Z)({},aXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lXn.isMDXComponent=!0;const uXn={toc:[]},mXn="wrapper";function dXn(t){let{components:e,...n}=t;return(0,s.kt)(mXn,(0,p.Z)({},uXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}dXn.isMDXComponent=!0;const hXn={toc:[]},fXn="wrapper";function kXn(t){let{components:e,...n}=t;return(0,s.kt)(fXn,(0,p.Z)({},hXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}kXn.isMDXComponent=!0;const yXn={toc:[]},DXn="wrapper";function MXn(t){let{components:e,...n}=t;return(0,s.kt)(DXn,(0,p.Z)({},yXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}MXn.isMDXComponent=!0;const XXn={toc:[]},_Xn="wrapper";function wXn(t){let{components:e,...n}=t;return(0,s.kt)(_Xn,(0,p.Z)({},XXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}wXn.isMDXComponent=!0;const TXn={toc:[]},CXn="wrapper";function xXn(t){let{components:e,...n}=t;return(0,s.kt)(CXn,(0,p.Z)({},TXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}xXn.isMDXComponent=!0;const gXn={toc:[]},vXn="wrapper";function LXn(t){let{components:e,...n}=t;return(0,s.kt)(vXn,(0,p.Z)({},gXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}LXn.isMDXComponent=!0;const ZXn={toc:[]},bXn="wrapper";function NXn(t){let{components:e,...n}=t;return(0,s.kt)(bXn,(0,p.Z)({},ZXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}NXn.isMDXComponent=!0;const zXn={toc:[]},AXn="wrapper";function PXn(t){let{components:e,...n}=t;return(0,s.kt)(AXn,(0,p.Z)({},zXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}PXn.isMDXComponent=!0;const WXn={toc:[]},RXn="wrapper";function IXn(t){let{components:e,...n}=t;return(0,s.kt)(RXn,(0,p.Z)({},WXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}IXn.isMDXComponent=!0;const SXn={toc:[]},BXn="wrapper";function GXn(t){let{components:e,...n}=t;return(0,s.kt)(BXn,(0,p.Z)({},SXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}GXn.isMDXComponent=!0;const EXn={toc:[]},OXn="wrapper";function FXn(t){let{components:e,...n}=t;return(0,s.kt)(OXn,(0,p.Z)({},EXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}FXn.isMDXComponent=!0;const UXn={toc:[]},VXn="wrapper";function qXn(t){let{components:e,...n}=t;return(0,s.kt)(VXn,(0,p.Z)({},UXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The start point of the B\xe9zier curve."))}qXn.isMDXComponent=!0;const jXn={toc:[]},YXn="wrapper";function QXn(t){let{components:e,...n}=t;return(0,s.kt)(YXn,(0,p.Z)({},jXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The control point of the B\xe9zier curve."))}QXn.isMDXComponent=!0;const HXn={toc:[]},KXn="wrapper";function $Xn(t){let{components:e,...n}=t;return(0,s.kt)(KXn,(0,p.Z)({},HXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The end point of the B\xe9zier curve."))}$Xn.isMDXComponent=!0;const JXn={toc:[]},t_n="wrapper";function e_n(t){let{components:e,...n}=t;return(0,s.kt)(t_n,(0,p.Z)({},JXn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}e_n.isMDXComponent=!0;const n_n={toc:[]},o_n="wrapper";function p_n(t){let{components:e,...n}=t;return(0,s.kt)(o_n,(0,p.Z)({},n_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}p_n.isMDXComponent=!0;const r_n={toc:[]},s_n="wrapper";function c_n(t){let{components:e,...n}=t;return(0,s.kt)(s_n,(0,p.Z)({},r_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}c_n.isMDXComponent=!0;const a_n={toc:[]},i_n="wrapper";function l_n(t){let{components:e,...n}=t;return(0,s.kt)(i_n,(0,p.Z)({},a_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}l_n.isMDXComponent=!0;const u_n={toc:[]},m_n="wrapper";function d_n(t){let{components:e,...n}=t;return(0,s.kt)(m_n,(0,p.Z)({},u_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}d_n.isMDXComponent=!0;const h_n={toc:[]},f_n="wrapper";function k_n(t){let{components:e,...n}=t;return(0,s.kt)(f_n,(0,p.Z)({},h_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}k_n.isMDXComponent=!0;const y_n={toc:[]},D_n="wrapper";function M_n(t){let{components:e,...n}=t;return(0,s.kt)(D_n,(0,p.Z)({},y_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}M_n.isMDXComponent=!0;const X_n={toc:[]},__n="wrapper";function w_n(t){let{components:e,...n}=t;return(0,s.kt)(__n,(0,p.Z)({},X_n,n,{components:e,mdxType:"MDXLayout"}))}w_n.isMDXComponent=!0;const T_n={toc:[]},C_n="wrapper";function x_n(t){let{components:e,...n}=t;return(0,s.kt)(C_n,(0,p.Z)({},T_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}x_n.isMDXComponent=!0;const g_n={toc:[]},v_n="wrapper";function L_n(t){let{components:e,...n}=t;return(0,s.kt)(v_n,(0,p.Z)({},g_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}L_n.isMDXComponent=!0;const Z_n={toc:[]},b_n="wrapper";function N_n(t){let{components:e,...n}=t;return(0,s.kt)(b_n,(0,p.Z)({},Z_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}N_n.isMDXComponent=!0;const z_n={toc:[]},A_n="wrapper";function P_n(t){let{components:e,...n}=t;return(0,s.kt)(A_n,(0,p.Z)({},z_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}P_n.isMDXComponent=!0;const W_n={toc:[]},R_n="wrapper";function I_n(t){let{components:e,...n}=t;return(0,s.kt)(R_n,(0,p.Z)({},W_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}I_n.isMDXComponent=!0;const S_n={toc:[]},B_n="wrapper";function G_n(t){let{components:e,...n}=t;return(0,s.kt)(B_n,(0,p.Z)({},S_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}G_n.isMDXComponent=!0;const E_n={toc:[]},O_n="wrapper";function F_n(t){let{components:e,...n}=t;return(0,s.kt)(O_n,(0,p.Z)({},E_n,n,{components:e,mdxType:"MDXLayout"}))}F_n.isMDXComponent=!0;const U_n={toc:[]},V_n="wrapper";function q_n(t){let{components:e,...n}=t;return(0,s.kt)(V_n,(0,p.Z)({},U_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}q_n.isMDXComponent=!0;const j_n={toc:[]},Y_n="wrapper";function Q_n(t){let{components:e,...n}=t;return(0,s.kt)(Y_n,(0,p.Z)({},j_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Q_n.isMDXComponent=!0;const H_n={toc:[]},K_n="wrapper";function $_n(t){let{components:e,...n}=t;return(0,s.kt)(K_n,(0,p.Z)({},H_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}$_n.isMDXComponent=!0;const J_n={toc:[]},twn="wrapper";function ewn(t){let{components:e,...n}=t;return(0,s.kt)(twn,(0,p.Z)({},J_n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}ewn.isMDXComponent=!0;const nwn={toc:[]},own="wrapper";function pwn(t){let{components:e,...n}=t;return(0,s.kt)(own,(0,p.Z)({},nwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}pwn.isMDXComponent=!0;const rwn={toc:[]},swn="wrapper";function cwn(t){let{components:e,...n}=t;return(0,s.kt)(swn,(0,p.Z)({},rwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}cwn.isMDXComponent=!0;const awn={toc:[]},iwn="wrapper";function lwn(t){let{components:e,...n}=t;return(0,s.kt)(iwn,(0,p.Z)({},awn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}lwn.isMDXComponent=!0;const uwn={toc:[]},mwn="wrapper";function dwn(t){let{components:e,...n}=t;return(0,s.kt)(mwn,(0,p.Z)({},uwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}dwn.isMDXComponent=!0;const hwn={toc:[]},fwn="wrapper";function kwn(t){let{components:e,...n}=t;return(0,s.kt)(fwn,(0,p.Z)({},hwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}kwn.isMDXComponent=!0;const ywn={toc:[]},Dwn="wrapper";function Mwn(t){let{components:e,...n}=t;return(0,s.kt)(Dwn,(0,p.Z)({},ywn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Mwn.isMDXComponent=!0;const Xwn={toc:[]},_wn="wrapper";function wwn(t){let{components:e,...n}=t;return(0,s.kt)(_wn,(0,p.Z)({},Xwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}wwn.isMDXComponent=!0;const Twn={toc:[]},Cwn="wrapper";function xwn(t){let{components:e,...n}=t;return(0,s.kt)(Cwn,(0,p.Z)({},Twn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}xwn.isMDXComponent=!0;const gwn={toc:[]},vwn="wrapper";function Lwn(t){let{components:e,...n}=t;return(0,s.kt)(vwn,(0,p.Z)({},gwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Lwn.isMDXComponent=!0;const Zwn={toc:[]},bwn="wrapper";function Nwn(t){let{components:e,...n}=t;return(0,s.kt)(bwn,(0,p.Z)({},Zwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Nwn.isMDXComponent=!0;const zwn={toc:[]},Awn="wrapper";function Pwn(t){let{components:e,...n}=t;return(0,s.kt)(Awn,(0,p.Z)({},zwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Pwn.isMDXComponent=!0;const Wwn={toc:[]},Rwn="wrapper";function Iwn(t){let{components:e,...n}=t;return(0,s.kt)(Rwn,(0,p.Z)({},Wwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Iwn.isMDXComponent=!0;const Swn={toc:[]},Bwn="wrapper";function Gwn(t){let{components:e,...n}=t;return(0,s.kt)(Bwn,(0,p.Z)({},Swn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Gwn.isMDXComponent=!0;const Ewn={toc:[]},Own="wrapper";function Fwn(t){let{components:e,...n}=t;return(0,s.kt)(Own,(0,p.Z)({},Ewn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Fwn.isMDXComponent=!0;const Uwn={toc:[]},Vwn="wrapper";function qwn(t){let{components:e,...n}=t;return(0,s.kt)(Vwn,(0,p.Z)({},Uwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}qwn.isMDXComponent=!0;const jwn={toc:[]},Ywn="wrapper";function Qwn(t){let{components:e,...n}=t;return(0,s.kt)(Ywn,(0,p.Z)({},jwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Qwn.isMDXComponent=!0;const Hwn={toc:[]},Kwn="wrapper";function $wn(t){let{components:e,...n}=t;return(0,s.kt)(Kwn,(0,p.Z)({},Hwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}$wn.isMDXComponent=!0;const Jwn={toc:[]},tTn="wrapper";function eTn(t){let{components:e,...n}=t;return(0,s.kt)(tTn,(0,p.Z)({},Jwn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}eTn.isMDXComponent=!0;const nTn={toc:[]},oTn="wrapper";function pTn(t){let{components:e,...n}=t;return(0,s.kt)(oTn,(0,p.Z)({},nTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}pTn.isMDXComponent=!0;const rTn={toc:[]},sTn="wrapper";function cTn(t){let{components:e,...n}=t;return(0,s.kt)(sTn,(0,p.Z)({},rTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}cTn.isMDXComponent=!0;const aTn={toc:[]},iTn="wrapper";function lTn(t){let{components:e,...n}=t;return(0,s.kt)(iTn,(0,p.Z)({},aTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}lTn.isMDXComponent=!0;const uTn={toc:[]},mTn="wrapper";function dTn(t){let{components:e,...n}=t;return(0,s.kt)(mTn,(0,p.Z)({},uTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}dTn.isMDXComponent=!0;const hTn={toc:[]},fTn="wrapper";function kTn(t){let{components:e,...n}=t;return(0,s.kt)(fTn,(0,p.Z)({},hTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}kTn.isMDXComponent=!0;const yTn={toc:[]},DTn="wrapper";function MTn(t){let{components:e,...n}=t;return(0,s.kt)(DTn,(0,p.Z)({},yTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}MTn.isMDXComponent=!0;const XTn={toc:[]},_Tn="wrapper";function wTn(t){let{components:e,...n}=t;return(0,s.kt)(_Tn,(0,p.Z)({},XTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}wTn.isMDXComponent=!0;const TTn={toc:[]},CTn="wrapper";function xTn(t){let{components:e,...n}=t;return(0,s.kt)(CTn,(0,p.Z)({},TTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}xTn.isMDXComponent=!0;const gTn={toc:[]},vTn="wrapper";function LTn(t){let{components:e,...n}=t;return(0,s.kt)(vTn,(0,p.Z)({},gTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}LTn.isMDXComponent=!0;const ZTn={toc:[]},bTn="wrapper";function NTn(t){let{components:e,...n}=t;return(0,s.kt)(bTn,(0,p.Z)({},ZTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}NTn.isMDXComponent=!0;const zTn={toc:[]},ATn="wrapper";function PTn(t){let{components:e,...n}=t;return(0,s.kt)(ATn,(0,p.Z)({},zTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}PTn.isMDXComponent=!0;const WTn={toc:[]},RTn="wrapper";function ITn(t){let{components:e,...n}=t;return(0,s.kt)(RTn,(0,p.Z)({},WTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}ITn.isMDXComponent=!0;const STn={toc:[]},BTn="wrapper";function GTn(t){let{components:e,...n}=t;return(0,s.kt)(BTn,(0,p.Z)({},STn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}GTn.isMDXComponent=!0;const ETn={toc:[]},OTn="wrapper";function FTn(t){let{components:e,...n}=t;return(0,s.kt)(OTn,(0,p.Z)({},ETn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}FTn.isMDXComponent=!0;const UTn={toc:[]},VTn="wrapper";function qTn(t){let{components:e,...n}=t;return(0,s.kt)(VTn,(0,p.Z)({},UTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}qTn.isMDXComponent=!0;const jTn={toc:[]},YTn="wrapper";function QTn(t){let{components:e,...n}=t;return(0,s.kt)(YTn,(0,p.Z)({},jTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}QTn.isMDXComponent=!0;const HTn={toc:[]},KTn="wrapper";function $Tn(t){let{components:e,...n}=t;return(0,s.kt)(KTn,(0,p.Z)({},HTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}$Tn.isMDXComponent=!0;const JTn={toc:[]},tCn="wrapper";function eCn(t){let{components:e,...n}=t;return(0,s.kt)(tCn,(0,p.Z)({},JTn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}eCn.isMDXComponent=!0;const nCn={toc:[]},oCn="wrapper";function pCn(t){let{components:e,...n}=t;return(0,s.kt)(oCn,(0,p.Z)({},nCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}pCn.isMDXComponent=!0;const rCn={toc:[]},sCn="wrapper";function cCn(t){let{components:e,...n}=t;return(0,s.kt)(sCn,(0,p.Z)({},rCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}cCn.isMDXComponent=!0;const aCn={toc:[]},iCn="wrapper";function lCn(t){let{components:e,...n}=t;return(0,s.kt)(iCn,(0,p.Z)({},aCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}lCn.isMDXComponent=!0;const uCn={toc:[]},mCn="wrapper";function dCn(t){let{components:e,...n}=t;return(0,s.kt)(mCn,(0,p.Z)({},uCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}dCn.isMDXComponent=!0;const hCn={toc:[]},fCn="wrapper";function kCn(t){let{components:e,...n}=t;return(0,s.kt)(fCn,(0,p.Z)({},hCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}kCn.isMDXComponent=!0;const yCn={toc:[]},DCn="wrapper";function MCn(t){let{components:e,...n}=t;return(0,s.kt)(DCn,(0,p.Z)({},yCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}MCn.isMDXComponent=!0;const XCn={toc:[]},_Cn="wrapper";function wCn(t){let{components:e,...n}=t;return(0,s.kt)(_Cn,(0,p.Z)({},XCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}wCn.isMDXComponent=!0;const TCn={toc:[]},CCn="wrapper";function xCn(t){let{components:e,...n}=t;return(0,s.kt)(CCn,(0,p.Z)({},TCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}xCn.isMDXComponent=!0;const gCn={toc:[]},vCn="wrapper";function LCn(t){let{components:e,...n}=t;return(0,s.kt)(vCn,(0,p.Z)({},gCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}LCn.isMDXComponent=!0;const ZCn={toc:[]},bCn="wrapper";function NCn(t){let{components:e,...n}=t;return(0,s.kt)(bCn,(0,p.Z)({},ZCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}NCn.isMDXComponent=!0;const zCn={toc:[]},ACn="wrapper";function PCn(t){let{components:e,...n}=t;return(0,s.kt)(ACn,(0,p.Z)({},zCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}PCn.isMDXComponent=!0;const WCn={toc:[]},RCn="wrapper";function ICn(t){let{components:e,...n}=t;return(0,s.kt)(RCn,(0,p.Z)({},WCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}ICn.isMDXComponent=!0;const SCn={toc:[]},BCn="wrapper";function GCn(t){let{components:e,...n}=t;return(0,s.kt)(BCn,(0,p.Z)({},SCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}GCn.isMDXComponent=!0;const ECn={toc:[]},OCn="wrapper";function FCn(t){let{components:e,...n}=t;return(0,s.kt)(OCn,(0,p.Z)({},ECn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}FCn.isMDXComponent=!0;const UCn={toc:[]},VCn="wrapper";function qCn(t){let{components:e,...n}=t;return(0,s.kt)(VCn,(0,p.Z)({},UCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}qCn.isMDXComponent=!0;const jCn={toc:[]},YCn="wrapper";function QCn(t){let{components:e,...n}=t;return(0,s.kt)(YCn,(0,p.Z)({},jCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}QCn.isMDXComponent=!0;const HCn={toc:[]},KCn="wrapper";function $Cn(t){let{components:e,...n}=t;return(0,s.kt)(KCn,(0,p.Z)({},HCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}$Cn.isMDXComponent=!0;const JCn={toc:[]},txn="wrapper";function exn(t){let{components:e,...n}=t;return(0,s.kt)(txn,(0,p.Z)({},JCn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}exn.isMDXComponent=!0;const nxn={toc:[]},oxn="wrapper";function pxn(t){let{components:e,...n}=t;return(0,s.kt)(oxn,(0,p.Z)({},nxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}pxn.isMDXComponent=!0;const rxn={toc:[]},sxn="wrapper";function cxn(t){let{components:e,...n}=t;return(0,s.kt)(sxn,(0,p.Z)({},rxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cxn.isMDXComponent=!0;const axn={toc:[]},ixn="wrapper";function lxn(t){let{components:e,...n}=t;return(0,s.kt)(ixn,(0,p.Z)({},axn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}lxn.isMDXComponent=!0;const uxn={toc:[]},mxn="wrapper";function dxn(t){let{components:e,...n}=t;return(0,s.kt)(mxn,(0,p.Z)({},uxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dxn.isMDXComponent=!0;const hxn={toc:[]},fxn="wrapper";function kxn(t){let{components:e,...n}=t;return(0,s.kt)(fxn,(0,p.Z)({},hxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}kxn.isMDXComponent=!0;const yxn={toc:[]},Dxn="wrapper";function Mxn(t){let{components:e,...n}=t;return(0,s.kt)(Dxn,(0,p.Z)({},yxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Mxn.isMDXComponent=!0;const Xxn={toc:[]},_xn="wrapper";function wxn(t){let{components:e,...n}=t;return(0,s.kt)(_xn,(0,p.Z)({},Xxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}wxn.isMDXComponent=!0;const Txn={toc:[]},Cxn="wrapper";function xxn(t){let{components:e,...n}=t;return(0,s.kt)(Cxn,(0,p.Z)({},Txn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}xxn.isMDXComponent=!0;const gxn={toc:[]},vxn="wrapper";function Lxn(t){let{components:e,...n}=t;return(0,s.kt)(vxn,(0,p.Z)({},gxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Lxn.isMDXComponent=!0;const Zxn={toc:[]},bxn="wrapper";function Nxn(t){let{components:e,...n}=t;return(0,s.kt)(bxn,(0,p.Z)({},Zxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Nxn.isMDXComponent=!0;const zxn={toc:[]},Axn="wrapper";function Pxn(t){let{components:e,...n}=t;return(0,s.kt)(Axn,(0,p.Z)({},zxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Pxn.isMDXComponent=!0;const Wxn={toc:[]},Rxn="wrapper";function Ixn(t){let{components:e,...n}=t;return(0,s.kt)(Rxn,(0,p.Z)({},Wxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Ixn.isMDXComponent=!0;const Sxn={toc:[]},Bxn="wrapper";function Gxn(t){let{components:e,...n}=t;return(0,s.kt)(Bxn,(0,p.Z)({},Sxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}Gxn.isMDXComponent=!0;const Exn={toc:[]},Oxn="wrapper";function Fxn(t){let{components:e,...n}=t;return(0,s.kt)(Oxn,(0,p.Z)({},Exn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}Fxn.isMDXComponent=!0;const Uxn={toc:[]},Vxn="wrapper";function qxn(t){let{components:e,...n}=t;return(0,s.kt)(Vxn,(0,p.Z)({},Uxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}qxn.isMDXComponent=!0;const jxn={toc:[]},Yxn="wrapper";function Qxn(t){let{components:e,...n}=t;return(0,s.kt)(Yxn,(0,p.Z)({},jxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Qxn.isMDXComponent=!0;const Hxn={toc:[]},Kxn="wrapper";function $xn(t){let{components:e,...n}=t;return(0,s.kt)(Kxn,(0,p.Z)({},Hxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}$xn.isMDXComponent=!0;const Jxn={toc:[]},tgn="wrapper";function egn(t){let{components:e,...n}=t;return(0,s.kt)(tgn,(0,p.Z)({},Jxn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}egn.isMDXComponent=!0;const ngn={toc:[]},ogn="wrapper";function pgn(t){let{components:e,...n}=t;return(0,s.kt)(ogn,(0,p.Z)({},ngn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}pgn.isMDXComponent=!0;const rgn={toc:[]},sgn="wrapper";function cgn(t){let{components:e,...n}=t;return(0,s.kt)(sgn,(0,p.Z)({},rgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}cgn.isMDXComponent=!0;const agn={toc:[]},ign="wrapper";function lgn(t){let{components:e,...n}=t;return(0,s.kt)(ign,(0,p.Z)({},agn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}lgn.isMDXComponent=!0;const ugn={toc:[]},mgn="wrapper";function dgn(t){let{components:e,...n}=t;return(0,s.kt)(mgn,(0,p.Z)({},ugn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}dgn.isMDXComponent=!0;const hgn={toc:[]},fgn="wrapper";function kgn(t){let{components:e,...n}=t;return(0,s.kt)(fgn,(0,p.Z)({},hgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}kgn.isMDXComponent=!0;const ygn={toc:[]},Dgn="wrapper";function Mgn(t){let{components:e,...n}=t;return(0,s.kt)(Dgn,(0,p.Z)({},ygn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Mgn.isMDXComponent=!0;const Xgn={toc:[]},_gn="wrapper";function wgn(t){let{components:e,...n}=t;return(0,s.kt)(_gn,(0,p.Z)({},Xgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}wgn.isMDXComponent=!0;const Tgn={toc:[]},Cgn="wrapper";function xgn(t){let{components:e,...n}=t;return(0,s.kt)(Cgn,(0,p.Z)({},Tgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}xgn.isMDXComponent=!0;const ggn={toc:[]},vgn="wrapper";function Lgn(t){let{components:e,...n}=t;return(0,s.kt)(vgn,(0,p.Z)({},ggn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Lgn.isMDXComponent=!0;const Zgn={toc:[]},bgn="wrapper";function Ngn(t){let{components:e,...n}=t;return(0,s.kt)(bgn,(0,p.Z)({},Zgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Ngn.isMDXComponent=!0;const zgn={toc:[]},Agn="wrapper";function Pgn(t){let{components:e,...n}=t;return(0,s.kt)(Agn,(0,p.Z)({},zgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Pgn.isMDXComponent=!0;const Wgn={toc:[]},Rgn="wrapper";function Ign(t){let{components:e,...n}=t;return(0,s.kt)(Rgn,(0,p.Z)({},Wgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Ign.isMDXComponent=!0;const Sgn={toc:[]},Bgn="wrapper";function Ggn(t){let{components:e,...n}=t;return(0,s.kt)(Bgn,(0,p.Z)({},Sgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}Ggn.isMDXComponent=!0;const Egn={toc:[]},Ogn="wrapper";function Fgn(t){let{components:e,...n}=t;return(0,s.kt)(Ogn,(0,p.Z)({},Egn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Fgn.isMDXComponent=!0;const Ugn={toc:[]},Vgn="wrapper";function qgn(t){let{components:e,...n}=t;return(0,s.kt)(Vgn,(0,p.Z)({},Ugn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}qgn.isMDXComponent=!0;const jgn={toc:[]},Ygn="wrapper";function Qgn(t){let{components:e,...n}=t;return(0,s.kt)(Ygn,(0,p.Z)({},jgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}Qgn.isMDXComponent=!0;const Hgn={toc:[]},Kgn="wrapper";function $gn(t){let{components:e,...n}=t;return(0,s.kt)(Kgn,(0,p.Z)({},Hgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}$gn.isMDXComponent=!0;const Jgn={toc:[]},tvn="wrapper";function evn(t){let{components:e,...n}=t;return(0,s.kt)(tvn,(0,p.Z)({},Jgn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}evn.isMDXComponent=!0;const nvn={toc:[]},ovn="wrapper";function pvn(t){let{components:e,...n}=t;return(0,s.kt)(ovn,(0,p.Z)({},nvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}pvn.isMDXComponent=!0;const rvn={toc:[]},svn="wrapper";function cvn(t){let{components:e,...n}=t;return(0,s.kt)(svn,(0,p.Z)({},rvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}cvn.isMDXComponent=!0;const avn={toc:[]},ivn="wrapper";function lvn(t){let{components:e,...n}=t;return(0,s.kt)(ivn,(0,p.Z)({},avn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}lvn.isMDXComponent=!0;const uvn={toc:[]},mvn="wrapper";function dvn(t){let{components:e,...n}=t;return(0,s.kt)(mvn,(0,p.Z)({},uvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}dvn.isMDXComponent=!0;const hvn={toc:[]},fvn="wrapper";function kvn(t){let{components:e,...n}=t;return(0,s.kt)(fvn,(0,p.Z)({},hvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}kvn.isMDXComponent=!0;const yvn={toc:[]},Dvn="wrapper";function Mvn(t){let{components:e,...n}=t;return(0,s.kt)(Dvn,(0,p.Z)({},yvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Mvn.isMDXComponent=!0;const Xvn={toc:[]},_vn="wrapper";function wvn(t){let{components:e,...n}=t;return(0,s.kt)(_vn,(0,p.Z)({},Xvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}wvn.isMDXComponent=!0;const Tvn={toc:[]},Cvn="wrapper";function xvn(t){let{components:e,...n}=t;return(0,s.kt)(Cvn,(0,p.Z)({},Tvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}xvn.isMDXComponent=!0;const gvn={toc:[]},vvn="wrapper";function Lvn(t){let{components:e,...n}=t;return(0,s.kt)(vvn,(0,p.Z)({},gvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Lvn.isMDXComponent=!0;const Zvn={toc:[]},bvn="wrapper";function Nvn(t){let{components:e,...n}=t;return(0,s.kt)(bvn,(0,p.Z)({},Zvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Nvn.isMDXComponent=!0;const zvn={toc:[]},Avn="wrapper";function Pvn(t){let{components:e,...n}=t;return(0,s.kt)(Avn,(0,p.Z)({},zvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}Pvn.isMDXComponent=!0;const Wvn={toc:[]},Rvn="wrapper";function Ivn(t){let{components:e,...n}=t;return(0,s.kt)(Rvn,(0,p.Z)({},Wvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Ivn.isMDXComponent=!0;const Svn={toc:[]},Bvn="wrapper";function Gvn(t){let{components:e,...n}=t;return(0,s.kt)(Bvn,(0,p.Z)({},Svn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}Gvn.isMDXComponent=!0;const Evn={toc:[]},Ovn="wrapper";function Fvn(t){let{components:e,...n}=t;return(0,s.kt)(Ovn,(0,p.Z)({},Evn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Fvn.isMDXComponent=!0;const Uvn={toc:[]},Vvn="wrapper";function qvn(t){let{components:e,...n}=t;return(0,s.kt)(Vvn,(0,p.Z)({},Uvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}qvn.isMDXComponent=!0;const jvn={toc:[]},Yvn="wrapper";function Qvn(t){let{components:e,...n}=t;return(0,s.kt)(Yvn,(0,p.Z)({},jvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Qvn.isMDXComponent=!0;const Hvn={toc:[]},Kvn="wrapper";function $vn(t){let{components:e,...n}=t;return(0,s.kt)(Kvn,(0,p.Z)({},Hvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}$vn.isMDXComponent=!0;const Jvn={toc:[]},tLn="wrapper";function eLn(t){let{components:e,...n}=t;return(0,s.kt)(tLn,(0,p.Z)({},Jvn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}eLn.isMDXComponent=!0;const nLn={toc:[]},oLn="wrapper";function pLn(t){let{components:e,...n}=t;return(0,s.kt)(oLn,(0,p.Z)({},nLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}pLn.isMDXComponent=!0;const rLn={toc:[]},sLn="wrapper";function cLn(t){let{components:e,...n}=t;return(0,s.kt)(sLn,(0,p.Z)({},rLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}cLn.isMDXComponent=!0;const aLn={toc:[]},iLn="wrapper";function lLn(t){let{components:e,...n}=t;return(0,s.kt)(iLn,(0,p.Z)({},aLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}lLn.isMDXComponent=!0;const uLn={toc:[]},mLn="wrapper";function dLn(t){let{components:e,...n}=t;return(0,s.kt)(mLn,(0,p.Z)({},uLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}dLn.isMDXComponent=!0;const hLn={toc:[]},fLn="wrapper";function kLn(t){let{components:e,...n}=t;return(0,s.kt)(fLn,(0,p.Z)({},hLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}kLn.isMDXComponent=!0;const yLn={toc:[]},DLn="wrapper";function MLn(t){let{components:e,...n}=t;return(0,s.kt)(DLn,(0,p.Z)({},yLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}MLn.isMDXComponent=!0;const XLn={toc:[]},_Ln="wrapper";function wLn(t){let{components:e,...n}=t;return(0,s.kt)(_Ln,(0,p.Z)({},XLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}wLn.isMDXComponent=!0;const TLn={toc:[]},CLn="wrapper";function xLn(t){let{components:e,...n}=t;return(0,s.kt)(CLn,(0,p.Z)({},TLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}xLn.isMDXComponent=!0;const gLn={toc:[]},vLn="wrapper";function LLn(t){let{components:e,...n}=t;return(0,s.kt)(vLn,(0,p.Z)({},gLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}LLn.isMDXComponent=!0;const ZLn={toc:[]},bLn="wrapper";function NLn(t){let{components:e,...n}=t;return(0,s.kt)(bLn,(0,p.Z)({},ZLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}NLn.isMDXComponent=!0;const zLn={toc:[]},ALn="wrapper";function PLn(t){let{components:e,...n}=t;return(0,s.kt)(ALn,(0,p.Z)({},zLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}PLn.isMDXComponent=!0;const WLn={toc:[]},RLn="wrapper";function ILn(t){let{components:e,...n}=t;return(0,s.kt)(RLn,(0,p.Z)({},WLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}ILn.isMDXComponent=!0;const SLn={toc:[]},BLn="wrapper";function GLn(t){let{components:e,...n}=t;return(0,s.kt)(BLn,(0,p.Z)({},SLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}GLn.isMDXComponent=!0;const ELn={toc:[]},OLn="wrapper";function FLn(t){let{components:e,...n}=t;return(0,s.kt)(OLn,(0,p.Z)({},ELn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}FLn.isMDXComponent=!0;const ULn={toc:[]},VLn="wrapper";function qLn(t){let{components:e,...n}=t;return(0,s.kt)(VLn,(0,p.Z)({},ULn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}qLn.isMDXComponent=!0;const jLn={toc:[]},YLn="wrapper";function QLn(t){let{components:e,...n}=t;return(0,s.kt)(YLn,(0,p.Z)({},jLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}QLn.isMDXComponent=!0;const HLn={toc:[]},KLn="wrapper";function $Ln(t){let{components:e,...n}=t;return(0,s.kt)(KLn,(0,p.Z)({},HLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$Ln.isMDXComponent=!0;const JLn={toc:[]},tZn="wrapper";function eZn(t){let{components:e,...n}=t;return(0,s.kt)(tZn,(0,p.Z)({},JLn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}eZn.isMDXComponent=!0;const nZn={toc:[]},oZn="wrapper";function pZn(t){let{components:e,...n}=t;return(0,s.kt)(oZn,(0,p.Z)({},nZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}pZn.isMDXComponent=!0;const rZn={toc:[]},sZn="wrapper";function cZn(t){let{components:e,...n}=t;return(0,s.kt)(sZn,(0,p.Z)({},rZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}cZn.isMDXComponent=!0;const aZn={toc:[]},iZn="wrapper";function lZn(t){let{components:e,...n}=t;return(0,s.kt)(iZn,(0,p.Z)({},aZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}lZn.isMDXComponent=!0;const uZn={toc:[]},mZn="wrapper";function dZn(t){let{components:e,...n}=t;return(0,s.kt)(mZn,(0,p.Z)({},uZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}dZn.isMDXComponent=!0;const hZn={toc:[]},fZn="wrapper";function kZn(t){let{components:e,...n}=t;return(0,s.kt)(fZn,(0,p.Z)({},hZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}kZn.isMDXComponent=!0;const yZn={toc:[]},DZn="wrapper";function MZn(t){let{components:e,...n}=t;return(0,s.kt)(DZn,(0,p.Z)({},yZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}MZn.isMDXComponent=!0;const XZn={toc:[]},_Zn="wrapper";function wZn(t){let{components:e,...n}=t;return(0,s.kt)(_Zn,(0,p.Z)({},XZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}wZn.isMDXComponent=!0;const TZn={toc:[]},CZn="wrapper";function xZn(t){let{components:e,...n}=t;return(0,s.kt)(CZn,(0,p.Z)({},TZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}xZn.isMDXComponent=!0;const gZn={toc:[]},vZn="wrapper";function LZn(t){let{components:e,...n}=t;return(0,s.kt)(vZn,(0,p.Z)({},gZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}LZn.isMDXComponent=!0;const ZZn={toc:[]},bZn="wrapper";function NZn(t){let{components:e,...n}=t;return(0,s.kt)(bZn,(0,p.Z)({},ZZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}NZn.isMDXComponent=!0;const zZn={toc:[]},AZn="wrapper";function PZn(t){let{components:e,...n}=t;return(0,s.kt)(AZn,(0,p.Z)({},zZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}PZn.isMDXComponent=!0;const WZn={toc:[]},RZn="wrapper";function IZn(t){let{components:e,...n}=t;return(0,s.kt)(RZn,(0,p.Z)({},WZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}IZn.isMDXComponent=!0;const SZn={toc:[]},BZn="wrapper";function GZn(t){let{components:e,...n}=t;return(0,s.kt)(BZn,(0,p.Z)({},SZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}GZn.isMDXComponent=!0;const EZn={toc:[]},OZn="wrapper";function FZn(t){let{components:e,...n}=t;return(0,s.kt)(OZn,(0,p.Z)({},EZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}FZn.isMDXComponent=!0;const UZn={toc:[]},VZn="wrapper";function qZn(t){let{components:e,...n}=t;return(0,s.kt)(VZn,(0,p.Z)({},UZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}qZn.isMDXComponent=!0;const jZn={toc:[]},YZn="wrapper";function QZn(t){let{components:e,...n}=t;return(0,s.kt)(YZn,(0,p.Z)({},jZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}QZn.isMDXComponent=!0;const HZn={toc:[]},KZn="wrapper";function $Zn(t){let{components:e,...n}=t;return(0,s.kt)(KZn,(0,p.Z)({},HZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}$Zn.isMDXComponent=!0;const JZn={toc:[]},tbn="wrapper";function ebn(t){let{components:e,...n}=t;return(0,s.kt)(tbn,(0,p.Z)({},JZn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}ebn.isMDXComponent=!0;const nbn={toc:[]},obn="wrapper";function pbn(t){let{components:e,...n}=t;return(0,s.kt)(obn,(0,p.Z)({},nbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}pbn.isMDXComponent=!0;const rbn={toc:[]},sbn="wrapper";function cbn(t){let{components:e,...n}=t;return(0,s.kt)(sbn,(0,p.Z)({},rbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}cbn.isMDXComponent=!0;const abn={toc:[]},ibn="wrapper";function lbn(t){let{components:e,...n}=t;return(0,s.kt)(ibn,(0,p.Z)({},abn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}lbn.isMDXComponent=!0;const ubn={toc:[]},mbn="wrapper";function dbn(t){let{components:e,...n}=t;return(0,s.kt)(mbn,(0,p.Z)({},ubn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}dbn.isMDXComponent=!0;const hbn={toc:[]},fbn="wrapper";function kbn(t){let{components:e,...n}=t;return(0,s.kt)(fbn,(0,p.Z)({},hbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}kbn.isMDXComponent=!0;const ybn={toc:[]},Dbn="wrapper";function Mbn(t){let{components:e,...n}=t;return(0,s.kt)(Dbn,(0,p.Z)({},ybn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Mbn.isMDXComponent=!0;const Xbn={toc:[]},_bn="wrapper";function wbn(t){let{components:e,...n}=t;return(0,s.kt)(_bn,(0,p.Z)({},Xbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wbn.isMDXComponent=!0;const Tbn={toc:[]},Cbn="wrapper";function xbn(t){let{components:e,...n}=t;return(0,s.kt)(Cbn,(0,p.Z)({},Tbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}xbn.isMDXComponent=!0;const gbn={toc:[]},vbn="wrapper";function Lbn(t){let{components:e,...n}=t;return(0,s.kt)(vbn,(0,p.Z)({},gbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Lbn.isMDXComponent=!0;const Zbn={toc:[]},bbn="wrapper";function Nbn(t){let{components:e,...n}=t;return(0,s.kt)(bbn,(0,p.Z)({},Zbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Nbn.isMDXComponent=!0;const zbn={toc:[]},Abn="wrapper";function Pbn(t){let{components:e,...n}=t;return(0,s.kt)(Abn,(0,p.Z)({},zbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}Pbn.isMDXComponent=!0;const Wbn={toc:[]},Rbn="wrapper";function Ibn(t){let{components:e,...n}=t;return(0,s.kt)(Rbn,(0,p.Z)({},Wbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezier#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Ibn.isMDXComponent=!0;const Sbn={toc:[]},Bbn="wrapper";function Gbn(t){let{components:e,...n}=t;return(0,s.kt)(Bbn,(0,p.Z)({},Sbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Gbn.isMDXComponent=!0;const Ebn={toc:[]},Obn="wrapper";function Fbn(t){let{components:e,...n}=t;return(0,s.kt)(Obn,(0,p.Z)({},Ebn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Fbn.isMDXComponent=!0;const Ubn={toc:[]},Vbn="wrapper";function qbn(t){let{components:e,...n}=t;return(0,s.kt)(Vbn,(0,p.Z)({},Ubn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}qbn.isMDXComponent=!0;const jbn={toc:[]},Ybn="wrapper";function Qbn(t){let{components:e,...n}=t;return(0,s.kt)(Ybn,(0,p.Z)({},jbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Qbn.isMDXComponent=!0;const Hbn={toc:[]},Kbn="wrapper";function $bn(t){let{components:e,...n}=t;return(0,s.kt)(Kbn,(0,p.Z)({},Hbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}$bn.isMDXComponent=!0;const Jbn={toc:[]},tNn="wrapper";function eNn(t){let{components:e,...n}=t;return(0,s.kt)(tNn,(0,p.Z)({},Jbn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}eNn.isMDXComponent=!0;const nNn={toc:[]},oNn="wrapper";function pNn(t){let{components:e,...n}=t;return(0,s.kt)(oNn,(0,p.Z)({},nNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor",editor:!0},"import {makeScene2D} from '@motion-canvas/2d';\nimport {Ray} from '@motion-canvas/2d';\nimport {createRef} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const ray = createRef<Ray>();\n\n  view.add(\n    <Ray\n      ref={ray}\n      lineWidth={8}\n      endArrow\n      stroke={'lightseagreen'}\n      fromX={-200}\n      toX={200}\n    />,\n  );\n\n  yield* ray().start(1, 1);\n  yield* ray().start(0).end(0).start(1, 1);\n});\n")))}pNn.isMDXComponent=!0;const rNn={toc:[]},sNn="wrapper";function cNn(t){let{components:e,...n}=t;return(0,s.kt)(sNn,(0,p.Z)({},rNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing an individual line segment."))}cNn.isMDXComponent=!0;const aNn={toc:[]},iNn="wrapper";function lNn(t){let{components:e,...n}=t;return(0,s.kt)(iNn,(0,p.Z)({},aNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}lNn.isMDXComponent=!0;const uNn={toc:[]},mNn="wrapper";function dNn(t){let{components:e,...n}=t;return(0,s.kt)(mNn,(0,p.Z)({},uNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}dNn.isMDXComponent=!0;const hNn={toc:[]},fNn="wrapper";function kNn(t){let{components:e,...n}=t;return(0,s.kt)(fNn,(0,p.Z)({},hNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}kNn.isMDXComponent=!0;const yNn={toc:[]},DNn="wrapper";function MNn(t){let{components:e,...n}=t;return(0,s.kt)(DNn,(0,p.Z)({},yNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}MNn.isMDXComponent=!0;const XNn={toc:[]},_Nn="wrapper";function wNn(t){let{components:e,...n}=t;return(0,s.kt)(_Nn,(0,p.Z)({},XNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wNn.isMDXComponent=!0;const TNn={toc:[]},CNn="wrapper";function xNn(t){let{components:e,...n}=t;return(0,s.kt)(CNn,(0,p.Z)({},TNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}xNn.isMDXComponent=!0;const gNn={toc:[]},vNn="wrapper";function LNn(t){let{components:e,...n}=t;return(0,s.kt)(vNn,(0,p.Z)({},gNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}LNn.isMDXComponent=!0;const ZNn={toc:[]},bNn="wrapper";function NNn(t){let{components:e,...n}=t;return(0,s.kt)(bNn,(0,p.Z)({},ZNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}NNn.isMDXComponent=!0;const zNn={toc:[]},ANn="wrapper";function PNn(t){let{components:e,...n}=t;return(0,s.kt)(ANn,(0,p.Z)({},zNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}PNn.isMDXComponent=!0;const WNn={toc:[]},RNn="wrapper";function INn(t){let{components:e,...n}=t;return(0,s.kt)(RNn,(0,p.Z)({},WNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}INn.isMDXComponent=!0;const SNn={toc:[]},BNn="wrapper";function GNn(t){let{components:e,...n}=t;return(0,s.kt)(BNn,(0,p.Z)({},SNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}GNn.isMDXComponent=!0;const ENn={toc:[]},ONn="wrapper";function FNn(t){let{components:e,...n}=t;return(0,s.kt)(ONn,(0,p.Z)({},ENn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}FNn.isMDXComponent=!0;const UNn={toc:[]},VNn="wrapper";function qNn(t){let{components:e,...n}=t;return(0,s.kt)(VNn,(0,p.Z)({},UNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}qNn.isMDXComponent=!0;const jNn={toc:[]},YNn="wrapper";function QNn(t){let{components:e,...n}=t;return(0,s.kt)(YNn,(0,p.Z)({},jNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}QNn.isMDXComponent=!0;const HNn={toc:[]},KNn="wrapper";function $Nn(t){let{components:e,...n}=t;return(0,s.kt)(KNn,(0,p.Z)({},HNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}$Nn.isMDXComponent=!0;const JNn={toc:[]},tzn="wrapper";function ezn(t){let{components:e,...n}=t;return(0,s.kt)(tzn,(0,p.Z)({},JNn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}ezn.isMDXComponent=!0;const nzn={toc:[]},ozn="wrapper";function pzn(t){let{components:e,...n}=t;return(0,s.kt)(ozn,(0,p.Z)({},nzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}pzn.isMDXComponent=!0;const rzn={toc:[]},szn="wrapper";function czn(t){let{components:e,...n}=t;return(0,s.kt)(szn,(0,p.Z)({},rzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}czn.isMDXComponent=!0;const azn={toc:[]},izn="wrapper";function lzn(t){let{components:e,...n}=t;return(0,s.kt)(izn,(0,p.Z)({},azn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}lzn.isMDXComponent=!0;const uzn={toc:[]},mzn="wrapper";function dzn(t){let{components:e,...n}=t;return(0,s.kt)(mzn,(0,p.Z)({},uzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}dzn.isMDXComponent=!0;const hzn={toc:[]},fzn="wrapper";function kzn(t){let{components:e,...n}=t;return(0,s.kt)(fzn,(0,p.Z)({},hzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kzn.isMDXComponent=!0;const yzn={toc:[]},Dzn="wrapper";function Mzn(t){let{components:e,...n}=t;return(0,s.kt)(Dzn,(0,p.Z)({},yzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Mzn.isMDXComponent=!0;const Xzn={toc:[]},_zn="wrapper";function wzn(t){let{components:e,...n}=t;return(0,s.kt)(_zn,(0,p.Z)({},Xzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}wzn.isMDXComponent=!0;const Tzn={toc:[]},Czn="wrapper";function xzn(t){let{components:e,...n}=t;return(0,s.kt)(Czn,(0,p.Z)({},Tzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}xzn.isMDXComponent=!0;const gzn={toc:[]},vzn="wrapper";function Lzn(t){let{components:e,...n}=t;return(0,s.kt)(vzn,(0,p.Z)({},gzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}Lzn.isMDXComponent=!0;const Zzn={toc:[]},bzn="wrapper";function Nzn(t){let{components:e,...n}=t;return(0,s.kt)(bzn,(0,p.Z)({},Zzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Nzn.isMDXComponent=!0;const zzn={toc:[]},Azn="wrapper";function Pzn(t){let{components:e,...n}=t;return(0,s.kt)(Azn,(0,p.Z)({},zzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Pzn.isMDXComponent=!0;const Wzn={toc:[]},Rzn="wrapper";function Izn(t){let{components:e,...n}=t;return(0,s.kt)(Rzn,(0,p.Z)({},Wzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Izn.isMDXComponent=!0;const Szn={toc:[]},Bzn="wrapper";function Gzn(t){let{components:e,...n}=t;return(0,s.kt)(Bzn,(0,p.Z)({},Szn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Gzn.isMDXComponent=!0;const Ezn={toc:[]},Ozn="wrapper";function Fzn(t){let{components:e,...n}=t;return(0,s.kt)(Ozn,(0,p.Z)({},Ezn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Fzn.isMDXComponent=!0;const Uzn={toc:[]},Vzn="wrapper";function qzn(t){let{components:e,...n}=t;return(0,s.kt)(Vzn,(0,p.Z)({},Uzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}qzn.isMDXComponent=!0;const jzn={toc:[]},Yzn="wrapper";function Qzn(t){let{components:e,...n}=t;return(0,s.kt)(Yzn,(0,p.Z)({},jzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Qzn.isMDXComponent=!0;const Hzn={toc:[]},Kzn="wrapper";function $zn(t){let{components:e,...n}=t;return(0,s.kt)(Kzn,(0,p.Z)({},Hzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}$zn.isMDXComponent=!0;const Jzn={toc:[]},tAn="wrapper";function eAn(t){let{components:e,...n}=t;return(0,s.kt)(tAn,(0,p.Z)({},Jzn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}eAn.isMDXComponent=!0;const nAn={toc:[]},oAn="wrapper";function pAn(t){let{components:e,...n}=t;return(0,s.kt)(oAn,(0,p.Z)({},nAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}pAn.isMDXComponent=!0;const rAn={toc:[]},sAn="wrapper";function cAn(t){let{components:e,...n}=t;return(0,s.kt)(sAn,(0,p.Z)({},rAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}cAn.isMDXComponent=!0;const aAn={toc:[]},iAn="wrapper";function lAn(t){let{components:e,...n}=t;return(0,s.kt)(iAn,(0,p.Z)({},aAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lAn.isMDXComponent=!0;const uAn={toc:[]},mAn="wrapper";function dAn(t){let{components:e,...n}=t;return(0,s.kt)(mAn,(0,p.Z)({},uAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}dAn.isMDXComponent=!0;const hAn={toc:[]},fAn="wrapper";function kAn(t){let{components:e,...n}=t;return(0,s.kt)(fAn,(0,p.Z)({},hAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}kAn.isMDXComponent=!0;const yAn={toc:[]},DAn="wrapper";function MAn(t){let{components:e,...n}=t;return(0,s.kt)(DAn,(0,p.Z)({},yAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}MAn.isMDXComponent=!0;const XAn={toc:[]},_An="wrapper";function wAn(t){let{components:e,...n}=t;return(0,s.kt)(_An,(0,p.Z)({},XAn,n,{components:e,mdxType:"MDXLayout"}))}wAn.isMDXComponent=!0;const TAn={toc:[]},CAn="wrapper";function xAn(t){let{components:e,...n}=t;return(0,s.kt)(CAn,(0,p.Z)({},TAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}xAn.isMDXComponent=!0;const gAn={toc:[]},vAn="wrapper";function LAn(t){let{components:e,...n}=t;return(0,s.kt)(vAn,(0,p.Z)({},gAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}LAn.isMDXComponent=!0;const ZAn={toc:[]},bAn="wrapper";function NAn(t){let{components:e,...n}=t;return(0,s.kt)(bAn,(0,p.Z)({},ZAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}NAn.isMDXComponent=!0;const zAn={toc:[]},AAn="wrapper";function PAn(t){let{components:e,...n}=t;return(0,s.kt)(AAn,(0,p.Z)({},zAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}PAn.isMDXComponent=!0;const WAn={toc:[]},RAn="wrapper";function IAn(t){let{components:e,...n}=t;return(0,s.kt)(RAn,(0,p.Z)({},WAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}IAn.isMDXComponent=!0;const SAn={toc:[]},BAn="wrapper";function GAn(t){let{components:e,...n}=t;return(0,s.kt)(BAn,(0,p.Z)({},SAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}GAn.isMDXComponent=!0;const EAn={toc:[]},OAn="wrapper";function FAn(t){let{components:e,...n}=t;return(0,s.kt)(OAn,(0,p.Z)({},EAn,n,{components:e,mdxType:"MDXLayout"}))}FAn.isMDXComponent=!0;const UAn={toc:[]},VAn="wrapper";function qAn(t){let{components:e,...n}=t;return(0,s.kt)(VAn,(0,p.Z)({},UAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qAn.isMDXComponent=!0;const jAn={toc:[]},YAn="wrapper";function QAn(t){let{components:e,...n}=t;return(0,s.kt)(YAn,(0,p.Z)({},jAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}QAn.isMDXComponent=!0;const HAn={toc:[]},KAn="wrapper";function $An(t){let{components:e,...n}=t;return(0,s.kt)(KAn,(0,p.Z)({},HAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}$An.isMDXComponent=!0;const JAn={toc:[]},tPn="wrapper";function ePn(t){let{components:e,...n}=t;return(0,s.kt)(tPn,(0,p.Z)({},JAn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}ePn.isMDXComponent=!0;const nPn={toc:[]},oPn="wrapper";function pPn(t){let{components:e,...n}=t;return(0,s.kt)(oPn,(0,p.Z)({},nPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}pPn.isMDXComponent=!0;const rPn={toc:[]},sPn="wrapper";function cPn(t){let{components:e,...n}=t;return(0,s.kt)(sPn,(0,p.Z)({},rPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}cPn.isMDXComponent=!0;const aPn={toc:[]},iPn="wrapper";function lPn(t){let{components:e,...n}=t;return(0,s.kt)(iPn,(0,p.Z)({},aPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}lPn.isMDXComponent=!0;const uPn={toc:[]},mPn="wrapper";function dPn(t){let{components:e,...n}=t;return(0,s.kt)(mPn,(0,p.Z)({},uPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}dPn.isMDXComponent=!0;const hPn={toc:[]},fPn="wrapper";function kPn(t){let{components:e,...n}=t;return(0,s.kt)(fPn,(0,p.Z)({},hPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}kPn.isMDXComponent=!0;const yPn={toc:[]},DPn="wrapper";function MPn(t){let{components:e,...n}=t;return(0,s.kt)(DPn,(0,p.Z)({},yPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}MPn.isMDXComponent=!0;const XPn={toc:[]},_Pn="wrapper";function wPn(t){let{components:e,...n}=t;return(0,s.kt)(_Pn,(0,p.Z)({},XPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}wPn.isMDXComponent=!0;const TPn={toc:[]},CPn="wrapper";function xPn(t){let{components:e,...n}=t;return(0,s.kt)(CPn,(0,p.Z)({},TPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}xPn.isMDXComponent=!0;const gPn={toc:[]},vPn="wrapper";function LPn(t){let{components:e,...n}=t;return(0,s.kt)(vPn,(0,p.Z)({},gPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}LPn.isMDXComponent=!0;const ZPn={toc:[]},bPn="wrapper";function NPn(t){let{components:e,...n}=t;return(0,s.kt)(bPn,(0,p.Z)({},ZPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}NPn.isMDXComponent=!0;const zPn={toc:[]},APn="wrapper";function PPn(t){let{components:e,...n}=t;return(0,s.kt)(APn,(0,p.Z)({},zPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}PPn.isMDXComponent=!0;const WPn={toc:[]},RPn="wrapper";function IPn(t){let{components:e,...n}=t;return(0,s.kt)(RPn,(0,p.Z)({},WPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}IPn.isMDXComponent=!0;const SPn={toc:[]},BPn="wrapper";function GPn(t){let{components:e,...n}=t;return(0,s.kt)(BPn,(0,p.Z)({},SPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}GPn.isMDXComponent=!0;const EPn={toc:[]},OPn="wrapper";function FPn(t){let{components:e,...n}=t;return(0,s.kt)(OPn,(0,p.Z)({},EPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}FPn.isMDXComponent=!0;const UPn={toc:[]},VPn="wrapper";function qPn(t){let{components:e,...n}=t;return(0,s.kt)(VPn,(0,p.Z)({},UPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}qPn.isMDXComponent=!0;const jPn={toc:[]},YPn="wrapper";function QPn(t){let{components:e,...n}=t;return(0,s.kt)(YPn,(0,p.Z)({},jPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}QPn.isMDXComponent=!0;const HPn={toc:[]},KPn="wrapper";function $Pn(t){let{components:e,...n}=t;return(0,s.kt)(KPn,(0,p.Z)({},HPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}$Pn.isMDXComponent=!0;const JPn={toc:[]},tWn="wrapper";function eWn(t){let{components:e,...n}=t;return(0,s.kt)(tWn,(0,p.Z)({},JPn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}eWn.isMDXComponent=!0;const nWn={toc:[]},oWn="wrapper";function pWn(t){let{components:e,...n}=t;return(0,s.kt)(oWn,(0,p.Z)({},nWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}pWn.isMDXComponent=!0;const rWn={toc:[]},sWn="wrapper";function cWn(t){let{components:e,...n}=t;return(0,s.kt)(sWn,(0,p.Z)({},rWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}cWn.isMDXComponent=!0;const aWn={toc:[]},iWn="wrapper";function lWn(t){let{components:e,...n}=t;return(0,s.kt)(iWn,(0,p.Z)({},aWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}lWn.isMDXComponent=!0;const uWn={toc:[]},mWn="wrapper";function dWn(t){let{components:e,...n}=t;return(0,s.kt)(mWn,(0,p.Z)({},uWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}dWn.isMDXComponent=!0;const hWn={toc:[]},fWn="wrapper";function kWn(t){let{components:e,...n}=t;return(0,s.kt)(fWn,(0,p.Z)({},hWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}kWn.isMDXComponent=!0;const yWn={toc:[]},DWn="wrapper";function MWn(t){let{components:e,...n}=t;return(0,s.kt)(DWn,(0,p.Z)({},yWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}MWn.isMDXComponent=!0;const XWn={toc:[]},_Wn="wrapper";function wWn(t){let{components:e,...n}=t;return(0,s.kt)(_Wn,(0,p.Z)({},XWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}wWn.isMDXComponent=!0;const TWn={toc:[]},CWn="wrapper";function xWn(t){let{components:e,...n}=t;return(0,s.kt)(CWn,(0,p.Z)({},TWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}xWn.isMDXComponent=!0;const gWn={toc:[]},vWn="wrapper";function LWn(t){let{components:e,...n}=t;return(0,s.kt)(vWn,(0,p.Z)({},gWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}LWn.isMDXComponent=!0;const ZWn={toc:[]},bWn="wrapper";function NWn(t){let{components:e,...n}=t;return(0,s.kt)(bWn,(0,p.Z)({},ZWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}NWn.isMDXComponent=!0;const zWn={toc:[]},AWn="wrapper";function PWn(t){let{components:e,...n}=t;return(0,s.kt)(AWn,(0,p.Z)({},zWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}PWn.isMDXComponent=!0;const WWn={toc:[]},RWn="wrapper";function IWn(t){let{components:e,...n}=t;return(0,s.kt)(RWn,(0,p.Z)({},WWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}IWn.isMDXComponent=!0;const SWn={toc:[]},BWn="wrapper";function GWn(t){let{components:e,...n}=t;return(0,s.kt)(BWn,(0,p.Z)({},SWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}GWn.isMDXComponent=!0;const EWn={toc:[]},OWn="wrapper";function FWn(t){let{components:e,...n}=t;return(0,s.kt)(OWn,(0,p.Z)({},EWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}FWn.isMDXComponent=!0;const UWn={toc:[]},VWn="wrapper";function qWn(t){let{components:e,...n}=t;return(0,s.kt)(VWn,(0,p.Z)({},UWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}qWn.isMDXComponent=!0;const jWn={toc:[]},YWn="wrapper";function QWn(t){let{components:e,...n}=t;return(0,s.kt)(YWn,(0,p.Z)({},jWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}QWn.isMDXComponent=!0;const HWn={toc:[]},KWn="wrapper";function $Wn(t){let{components:e,...n}=t;return(0,s.kt)(KWn,(0,p.Z)({},HWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}$Wn.isMDXComponent=!0;const JWn={toc:[]},tRn="wrapper";function eRn(t){let{components:e,...n}=t;return(0,s.kt)(tRn,(0,p.Z)({},JWn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}eRn.isMDXComponent=!0;const nRn={toc:[]},oRn="wrapper";function pRn(t){let{components:e,...n}=t;return(0,s.kt)(oRn,(0,p.Z)({},nRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}pRn.isMDXComponent=!0;const rRn={toc:[]},sRn="wrapper";function cRn(t){let{components:e,...n}=t;return(0,s.kt)(sRn,(0,p.Z)({},rRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}cRn.isMDXComponent=!0;const aRn={toc:[]},iRn="wrapper";function lRn(t){let{components:e,...n}=t;return(0,s.kt)(iRn,(0,p.Z)({},aRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}lRn.isMDXComponent=!0;const uRn={toc:[]},mRn="wrapper";function dRn(t){let{components:e,...n}=t;return(0,s.kt)(mRn,(0,p.Z)({},uRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}dRn.isMDXComponent=!0;const hRn={toc:[]},fRn="wrapper";function kRn(t){let{components:e,...n}=t;return(0,s.kt)(fRn,(0,p.Z)({},hRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}kRn.isMDXComponent=!0;const yRn={toc:[]},DRn="wrapper";function MRn(t){let{components:e,...n}=t;return(0,s.kt)(DRn,(0,p.Z)({},yRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}MRn.isMDXComponent=!0;const XRn={toc:[]},_Rn="wrapper";function wRn(t){let{components:e,...n}=t;return(0,s.kt)(_Rn,(0,p.Z)({},XRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}wRn.isMDXComponent=!0;const TRn={toc:[]},CRn="wrapper";function xRn(t){let{components:e,...n}=t;return(0,s.kt)(CRn,(0,p.Z)({},TRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}xRn.isMDXComponent=!0;const gRn={toc:[]},vRn="wrapper";function LRn(t){let{components:e,...n}=t;return(0,s.kt)(vRn,(0,p.Z)({},gRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}LRn.isMDXComponent=!0;const ZRn={toc:[]},bRn="wrapper";function NRn(t){let{components:e,...n}=t;return(0,s.kt)(bRn,(0,p.Z)({},ZRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}NRn.isMDXComponent=!0;const zRn={toc:[]},ARn="wrapper";function PRn(t){let{components:e,...n}=t;return(0,s.kt)(ARn,(0,p.Z)({},zRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}PRn.isMDXComponent=!0;const WRn={toc:[]},RRn="wrapper";function IRn(t){let{components:e,...n}=t;return(0,s.kt)(RRn,(0,p.Z)({},WRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}IRn.isMDXComponent=!0;const SRn={toc:[]},BRn="wrapper";function GRn(t){let{components:e,...n}=t;return(0,s.kt)(BRn,(0,p.Z)({},SRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}GRn.isMDXComponent=!0;const ERn={toc:[]},ORn="wrapper";function FRn(t){let{components:e,...n}=t;return(0,s.kt)(ORn,(0,p.Z)({},ERn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}FRn.isMDXComponent=!0;const URn={toc:[]},VRn="wrapper";function qRn(t){let{components:e,...n}=t;return(0,s.kt)(VRn,(0,p.Z)({},URn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}qRn.isMDXComponent=!0;const jRn={toc:[]},YRn="wrapper";function QRn(t){let{components:e,...n}=t;return(0,s.kt)(YRn,(0,p.Z)({},jRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}QRn.isMDXComponent=!0;const HRn={toc:[]},KRn="wrapper";function $Rn(t){let{components:e,...n}=t;return(0,s.kt)(KRn,(0,p.Z)({},HRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}$Rn.isMDXComponent=!0;const JRn={toc:[]},tIn="wrapper";function eIn(t){let{components:e,...n}=t;return(0,s.kt)(tIn,(0,p.Z)({},JRn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}eIn.isMDXComponent=!0;const nIn={toc:[]},oIn="wrapper";function pIn(t){let{components:e,...n}=t;return(0,s.kt)(oIn,(0,p.Z)({},nIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}pIn.isMDXComponent=!0;const rIn={toc:[]},sIn="wrapper";function cIn(t){let{components:e,...n}=t;return(0,s.kt)(sIn,(0,p.Z)({},rIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}cIn.isMDXComponent=!0;const aIn={toc:[]},iIn="wrapper";function lIn(t){let{components:e,...n}=t;return(0,s.kt)(iIn,(0,p.Z)({},aIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}lIn.isMDXComponent=!0;const uIn={toc:[]},mIn="wrapper";function dIn(t){let{components:e,...n}=t;return(0,s.kt)(mIn,(0,p.Z)({},uIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}dIn.isMDXComponent=!0;const hIn={toc:[]},fIn="wrapper";function kIn(t){let{components:e,...n}=t;return(0,s.kt)(fIn,(0,p.Z)({},hIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}kIn.isMDXComponent=!0;const yIn={toc:[]},DIn="wrapper";function MIn(t){let{components:e,...n}=t;return(0,s.kt)(DIn,(0,p.Z)({},yIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}MIn.isMDXComponent=!0;const XIn={toc:[]},_In="wrapper";function wIn(t){let{components:e,...n}=t;return(0,s.kt)(_In,(0,p.Z)({},XIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}wIn.isMDXComponent=!0;const TIn={toc:[]},CIn="wrapper";function xIn(t){let{components:e,...n}=t;return(0,s.kt)(CIn,(0,p.Z)({},TIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}xIn.isMDXComponent=!0;const gIn={toc:[]},vIn="wrapper";function LIn(t){let{components:e,...n}=t;return(0,s.kt)(vIn,(0,p.Z)({},gIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}LIn.isMDXComponent=!0;const ZIn={toc:[]},bIn="wrapper";function NIn(t){let{components:e,...n}=t;return(0,s.kt)(bIn,(0,p.Z)({},ZIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}NIn.isMDXComponent=!0;const zIn={toc:[]},AIn="wrapper";function PIn(t){let{components:e,...n}=t;return(0,s.kt)(AIn,(0,p.Z)({},zIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}PIn.isMDXComponent=!0;const WIn={toc:[]},RIn="wrapper";function IIn(t){let{components:e,...n}=t;return(0,s.kt)(RIn,(0,p.Z)({},WIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}IIn.isMDXComponent=!0;const SIn={toc:[]},BIn="wrapper";function GIn(t){let{components:e,...n}=t;return(0,s.kt)(BIn,(0,p.Z)({},SIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}GIn.isMDXComponent=!0;const EIn={toc:[]},OIn="wrapper";function FIn(t){let{components:e,...n}=t;return(0,s.kt)(OIn,(0,p.Z)({},EIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}FIn.isMDXComponent=!0;const UIn={toc:[]},VIn="wrapper";function qIn(t){let{components:e,...n}=t;return(0,s.kt)(VIn,(0,p.Z)({},UIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}qIn.isMDXComponent=!0;const jIn={toc:[]},YIn="wrapper";function QIn(t){let{components:e,...n}=t;return(0,s.kt)(YIn,(0,p.Z)({},jIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}QIn.isMDXComponent=!0;const HIn={toc:[]},KIn="wrapper";function $In(t){let{components:e,...n}=t;return(0,s.kt)(KIn,(0,p.Z)({},HIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}$In.isMDXComponent=!0;const JIn={toc:[]},tSn="wrapper";function eSn(t){let{components:e,...n}=t;return(0,s.kt)(tSn,(0,p.Z)({},JIn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}eSn.isMDXComponent=!0;const nSn={toc:[]},oSn="wrapper";function pSn(t){let{components:e,...n}=t;return(0,s.kt)(oSn,(0,p.Z)({},nSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}pSn.isMDXComponent=!0;const rSn={toc:[]},sSn="wrapper";function cSn(t){let{components:e,...n}=t;return(0,s.kt)(sSn,(0,p.Z)({},rSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}cSn.isMDXComponent=!0;const aSn={toc:[]},iSn="wrapper";function lSn(t){let{components:e,...n}=t;return(0,s.kt)(iSn,(0,p.Z)({},aSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}lSn.isMDXComponent=!0;const uSn={toc:[]},mSn="wrapper";function dSn(t){let{components:e,...n}=t;return(0,s.kt)(mSn,(0,p.Z)({},uSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}dSn.isMDXComponent=!0;const hSn={toc:[]},fSn="wrapper";function kSn(t){let{components:e,...n}=t;return(0,s.kt)(fSn,(0,p.Z)({},hSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}kSn.isMDXComponent=!0;const ySn={toc:[]},DSn="wrapper";function MSn(t){let{components:e,...n}=t;return(0,s.kt)(DSn,(0,p.Z)({},ySn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}MSn.isMDXComponent=!0;const XSn={toc:[]},_Sn="wrapper";function wSn(t){let{components:e,...n}=t;return(0,s.kt)(_Sn,(0,p.Z)({},XSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}wSn.isMDXComponent=!0;const TSn={toc:[]},CSn="wrapper";function xSn(t){let{components:e,...n}=t;return(0,s.kt)(CSn,(0,p.Z)({},TSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}xSn.isMDXComponent=!0;const gSn={toc:[]},vSn="wrapper";function LSn(t){let{components:e,...n}=t;return(0,s.kt)(vSn,(0,p.Z)({},gSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}LSn.isMDXComponent=!0;const ZSn={toc:[]},bSn="wrapper";function NSn(t){let{components:e,...n}=t;return(0,s.kt)(bSn,(0,p.Z)({},ZSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}NSn.isMDXComponent=!0;const zSn={toc:[]},ASn="wrapper";function PSn(t){let{components:e,...n}=t;return(0,s.kt)(ASn,(0,p.Z)({},zSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}PSn.isMDXComponent=!0;const WSn={toc:[]},RSn="wrapper";function ISn(t){let{components:e,...n}=t;return(0,s.kt)(RSn,(0,p.Z)({},WSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}ISn.isMDXComponent=!0;const SSn={toc:[]},BSn="wrapper";function GSn(t){let{components:e,...n}=t;return(0,s.kt)(BSn,(0,p.Z)({},SSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}GSn.isMDXComponent=!0;const ESn={toc:[]},OSn="wrapper";function FSn(t){let{components:e,...n}=t;return(0,s.kt)(OSn,(0,p.Z)({},ESn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}FSn.isMDXComponent=!0;const USn={toc:[]},VSn="wrapper";function qSn(t){let{components:e,...n}=t;return(0,s.kt)(VSn,(0,p.Z)({},USn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}qSn.isMDXComponent=!0;const jSn={toc:[]},YSn="wrapper";function QSn(t){let{components:e,...n}=t;return(0,s.kt)(YSn,(0,p.Z)({},jSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}QSn.isMDXComponent=!0;const HSn={toc:[]},KSn="wrapper";function $Sn(t){let{components:e,...n}=t;return(0,s.kt)(KSn,(0,p.Z)({},HSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}$Sn.isMDXComponent=!0;const JSn={toc:[]},tBn="wrapper";function eBn(t){let{components:e,...n}=t;return(0,s.kt)(tBn,(0,p.Z)({},JSn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}eBn.isMDXComponent=!0;const nBn={toc:[]},oBn="wrapper";function pBn(t){let{components:e,...n}=t;return(0,s.kt)(oBn,(0,p.Z)({},nBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}pBn.isMDXComponent=!0;const rBn={toc:[]},sBn="wrapper";function cBn(t){let{components:e,...n}=t;return(0,s.kt)(sBn,(0,p.Z)({},rBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}cBn.isMDXComponent=!0;const aBn={toc:[]},iBn="wrapper";function lBn(t){let{components:e,...n}=t;return(0,s.kt)(iBn,(0,p.Z)({},aBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}lBn.isMDXComponent=!0;const uBn={toc:[]},mBn="wrapper";function dBn(t){let{components:e,...n}=t;return(0,s.kt)(mBn,(0,p.Z)({},uBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}dBn.isMDXComponent=!0;const hBn={toc:[]},fBn="wrapper";function kBn(t){let{components:e,...n}=t;return(0,s.kt)(fBn,(0,p.Z)({},hBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}kBn.isMDXComponent=!0;const yBn={toc:[]},DBn="wrapper";function MBn(t){let{components:e,...n}=t;return(0,s.kt)(DBn,(0,p.Z)({},yBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}MBn.isMDXComponent=!0;const XBn={toc:[]},_Bn="wrapper";function wBn(t){let{components:e,...n}=t;return(0,s.kt)(_Bn,(0,p.Z)({},XBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}wBn.isMDXComponent=!0;const TBn={toc:[]},CBn="wrapper";function xBn(t){let{components:e,...n}=t;return(0,s.kt)(CBn,(0,p.Z)({},TBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}xBn.isMDXComponent=!0;const gBn={toc:[]},vBn="wrapper";function LBn(t){let{components:e,...n}=t;return(0,s.kt)(vBn,(0,p.Z)({},gBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}LBn.isMDXComponent=!0;const ZBn={toc:[]},bBn="wrapper";function NBn(t){let{components:e,...n}=t;return(0,s.kt)(bBn,(0,p.Z)({},ZBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}NBn.isMDXComponent=!0;const zBn={toc:[]},ABn="wrapper";function PBn(t){let{components:e,...n}=t;return(0,s.kt)(ABn,(0,p.Z)({},zBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}PBn.isMDXComponent=!0;const WBn={toc:[]},RBn="wrapper";function IBn(t){let{components:e,...n}=t;return(0,s.kt)(RBn,(0,p.Z)({},WBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}IBn.isMDXComponent=!0;const SBn={toc:[]},BBn="wrapper";function GBn(t){let{components:e,...n}=t;return(0,s.kt)(BBn,(0,p.Z)({},SBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}GBn.isMDXComponent=!0;const EBn={toc:[]},OBn="wrapper";function FBn(t){let{components:e,...n}=t;return(0,s.kt)(OBn,(0,p.Z)({},EBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}FBn.isMDXComponent=!0;const UBn={toc:[]},VBn="wrapper";function qBn(t){let{components:e,...n}=t;return(0,s.kt)(VBn,(0,p.Z)({},UBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}qBn.isMDXComponent=!0;const jBn={toc:[]},YBn="wrapper";function QBn(t){let{components:e,...n}=t;return(0,s.kt)(YBn,(0,p.Z)({},jBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}QBn.isMDXComponent=!0;const HBn={toc:[]},KBn="wrapper";function $Bn(t){let{components:e,...n}=t;return(0,s.kt)(KBn,(0,p.Z)({},HBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}$Bn.isMDXComponent=!0;const JBn={toc:[]},tGn="wrapper";function eGn(t){let{components:e,...n}=t;return(0,s.kt)(tGn,(0,p.Z)({},JBn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}eGn.isMDXComponent=!0;const nGn={toc:[]},oGn="wrapper";function pGn(t){let{components:e,...n}=t;return(0,s.kt)(oGn,(0,p.Z)({},nGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}pGn.isMDXComponent=!0;const rGn={toc:[]},sGn="wrapper";function cGn(t){let{components:e,...n}=t;return(0,s.kt)(sGn,(0,p.Z)({},rGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}cGn.isMDXComponent=!0;const aGn={toc:[]},iGn="wrapper";function lGn(t){let{components:e,...n}=t;return(0,s.kt)(iGn,(0,p.Z)({},aGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}lGn.isMDXComponent=!0;const uGn={toc:[]},mGn="wrapper";function dGn(t){let{components:e,...n}=t;return(0,s.kt)(mGn,(0,p.Z)({},uGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}dGn.isMDXComponent=!0;const hGn={toc:[]},fGn="wrapper";function kGn(t){let{components:e,...n}=t;return(0,s.kt)(fGn,(0,p.Z)({},hGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}kGn.isMDXComponent=!0;const yGn={toc:[]},DGn="wrapper";function MGn(t){let{components:e,...n}=t;return(0,s.kt)(DGn,(0,p.Z)({},yGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}MGn.isMDXComponent=!0;const XGn={toc:[]},_Gn="wrapper";function wGn(t){let{components:e,...n}=t;return(0,s.kt)(_Gn,(0,p.Z)({},XGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}wGn.isMDXComponent=!0;const TGn={toc:[]},CGn="wrapper";function xGn(t){let{components:e,...n}=t;return(0,s.kt)(CGn,(0,p.Z)({},TGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}xGn.isMDXComponent=!0;const gGn={toc:[]},vGn="wrapper";function LGn(t){let{components:e,...n}=t;return(0,s.kt)(vGn,(0,p.Z)({},gGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}LGn.isMDXComponent=!0;const ZGn={toc:[]},bGn="wrapper";function NGn(t){let{components:e,...n}=t;return(0,s.kt)(bGn,(0,p.Z)({},ZGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}NGn.isMDXComponent=!0;const zGn={toc:[]},AGn="wrapper";function PGn(t){let{components:e,...n}=t;return(0,s.kt)(AGn,(0,p.Z)({},zGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}PGn.isMDXComponent=!0;const WGn={toc:[]},RGn="wrapper";function IGn(t){let{components:e,...n}=t;return(0,s.kt)(RGn,(0,p.Z)({},WGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}IGn.isMDXComponent=!0;const SGn={toc:[]},BGn="wrapper";function GGn(t){let{components:e,...n}=t;return(0,s.kt)(BGn,(0,p.Z)({},SGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}GGn.isMDXComponent=!0;const EGn={toc:[]},OGn="wrapper";function FGn(t){let{components:e,...n}=t;return(0,s.kt)(OGn,(0,p.Z)({},EGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}FGn.isMDXComponent=!0;const UGn={toc:[]},VGn="wrapper";function qGn(t){let{components:e,...n}=t;return(0,s.kt)(VGn,(0,p.Z)({},UGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}qGn.isMDXComponent=!0;const jGn={toc:[]},YGn="wrapper";function QGn(t){let{components:e,...n}=t;return(0,s.kt)(YGn,(0,p.Z)({},jGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}QGn.isMDXComponent=!0;const HGn={toc:[]},KGn="wrapper";function $Gn(t){let{components:e,...n}=t;return(0,s.kt)(KGn,(0,p.Z)({},HGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}$Gn.isMDXComponent=!0;const JGn={toc:[]},tEn="wrapper";function eEn(t){let{components:e,...n}=t;return(0,s.kt)(tEn,(0,p.Z)({},JGn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}eEn.isMDXComponent=!0;const nEn={toc:[]},oEn="wrapper";function pEn(t){let{components:e,...n}=t;return(0,s.kt)(oEn,(0,p.Z)({},nEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}pEn.isMDXComponent=!0;const rEn={toc:[]},sEn="wrapper";function cEn(t){let{components:e,...n}=t;return(0,s.kt)(sEn,(0,p.Z)({},rEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}cEn.isMDXComponent=!0;const aEn={toc:[]},iEn="wrapper";function lEn(t){let{components:e,...n}=t;return(0,s.kt)(iEn,(0,p.Z)({},aEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}lEn.isMDXComponent=!0;const uEn={toc:[]},mEn="wrapper";function dEn(t){let{components:e,...n}=t;return(0,s.kt)(mEn,(0,p.Z)({},uEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}dEn.isMDXComponent=!0;const hEn={toc:[]},fEn="wrapper";function kEn(t){let{components:e,...n}=t;return(0,s.kt)(fEn,(0,p.Z)({},hEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}kEn.isMDXComponent=!0;const yEn={toc:[]},DEn="wrapper";function MEn(t){let{components:e,...n}=t;return(0,s.kt)(DEn,(0,p.Z)({},yEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}MEn.isMDXComponent=!0;const XEn={toc:[]},_En="wrapper";function wEn(t){let{components:e,...n}=t;return(0,s.kt)(_En,(0,p.Z)({},XEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}wEn.isMDXComponent=!0;const TEn={toc:[]},CEn="wrapper";function xEn(t){let{components:e,...n}=t;return(0,s.kt)(CEn,(0,p.Z)({},TEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}xEn.isMDXComponent=!0;const gEn={toc:[]},vEn="wrapper";function LEn(t){let{components:e,...n}=t;return(0,s.kt)(vEn,(0,p.Z)({},gEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}LEn.isMDXComponent=!0;const ZEn={toc:[]},bEn="wrapper";function NEn(t){let{components:e,...n}=t;return(0,s.kt)(bEn,(0,p.Z)({},ZEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}NEn.isMDXComponent=!0;const zEn={toc:[]},AEn="wrapper";function PEn(t){let{components:e,...n}=t;return(0,s.kt)(AEn,(0,p.Z)({},zEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}PEn.isMDXComponent=!0;const WEn={toc:[]},REn="wrapper";function IEn(t){let{components:e,...n}=t;return(0,s.kt)(REn,(0,p.Z)({},WEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}IEn.isMDXComponent=!0;const SEn={toc:[]},BEn="wrapper";function GEn(t){let{components:e,...n}=t;return(0,s.kt)(BEn,(0,p.Z)({},SEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}GEn.isMDXComponent=!0;const EEn={toc:[]},OEn="wrapper";function FEn(t){let{components:e,...n}=t;return(0,s.kt)(OEn,(0,p.Z)({},EEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}FEn.isMDXComponent=!0;const UEn={toc:[]},VEn="wrapper";function qEn(t){let{components:e,...n}=t;return(0,s.kt)(VEn,(0,p.Z)({},UEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}qEn.isMDXComponent=!0;const jEn={toc:[]},YEn="wrapper";function QEn(t){let{components:e,...n}=t;return(0,s.kt)(YEn,(0,p.Z)({},jEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}QEn.isMDXComponent=!0;const HEn={toc:[]},KEn="wrapper";function $En(t){let{components:e,...n}=t;return(0,s.kt)(KEn,(0,p.Z)({},HEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}$En.isMDXComponent=!0;const JEn={toc:[]},tOn="wrapper";function eOn(t){let{components:e,...n}=t;return(0,s.kt)(tOn,(0,p.Z)({},JEn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}eOn.isMDXComponent=!0;const nOn={toc:[]},oOn="wrapper";function pOn(t){let{components:e,...n}=t;return(0,s.kt)(oOn,(0,p.Z)({},nOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}pOn.isMDXComponent=!0;const rOn={toc:[]},sOn="wrapper";function cOn(t){let{components:e,...n}=t;return(0,s.kt)(sOn,(0,p.Z)({},rOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}cOn.isMDXComponent=!0;const aOn={toc:[]},iOn="wrapper";function lOn(t){let{components:e,...n}=t;return(0,s.kt)(iOn,(0,p.Z)({},aOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}lOn.isMDXComponent=!0;const uOn={toc:[]},mOn="wrapper";function dOn(t){let{components:e,...n}=t;return(0,s.kt)(mOn,(0,p.Z)({},uOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}dOn.isMDXComponent=!0;const hOn={toc:[]},fOn="wrapper";function kOn(t){let{components:e,...n}=t;return(0,s.kt)(fOn,(0,p.Z)({},hOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}kOn.isMDXComponent=!0;const yOn={toc:[]},DOn="wrapper";function MOn(t){let{components:e,...n}=t;return(0,s.kt)(DOn,(0,p.Z)({},yOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}MOn.isMDXComponent=!0;const XOn={toc:[]},_On="wrapper";function wOn(t){let{components:e,...n}=t;return(0,s.kt)(_On,(0,p.Z)({},XOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}wOn.isMDXComponent=!0;const TOn={toc:[]},COn="wrapper";function xOn(t){let{components:e,...n}=t;return(0,s.kt)(COn,(0,p.Z)({},TOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}xOn.isMDXComponent=!0;const gOn={toc:[]},vOn="wrapper";function LOn(t){let{components:e,...n}=t;return(0,s.kt)(vOn,(0,p.Z)({},gOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}LOn.isMDXComponent=!0;const ZOn={toc:[]},bOn="wrapper";function NOn(t){let{components:e,...n}=t;return(0,s.kt)(bOn,(0,p.Z)({},ZOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}NOn.isMDXComponent=!0;const zOn={toc:[]},AOn="wrapper";function POn(t){let{components:e,...n}=t;return(0,s.kt)(AOn,(0,p.Z)({},zOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}POn.isMDXComponent=!0;const WOn={toc:[]},ROn="wrapper";function IOn(t){let{components:e,...n}=t;return(0,s.kt)(ROn,(0,p.Z)({},WOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}IOn.isMDXComponent=!0;const SOn={toc:[]},BOn="wrapper";function GOn(t){let{components:e,...n}=t;return(0,s.kt)(BOn,(0,p.Z)({},SOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Ray#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}GOn.isMDXComponent=!0;const EOn={toc:[]},OOn="wrapper";function FOn(t){let{components:e,...n}=t;return(0,s.kt)(OOn,(0,p.Z)({},EOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}FOn.isMDXComponent=!0;const UOn={toc:[]},VOn="wrapper";function qOn(t){let{components:e,...n}=t;return(0,s.kt)(VOn,(0,p.Z)({},UOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}qOn.isMDXComponent=!0;const jOn={toc:[]},YOn="wrapper";function QOn(t){let{components:e,...n}=t;return(0,s.kt)(YOn,(0,p.Z)({},jOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}QOn.isMDXComponent=!0;const HOn={toc:[]},KOn="wrapper";function $On(t){let{components:e,...n}=t;return(0,s.kt)(KOn,(0,p.Z)({},HOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}$On.isMDXComponent=!0;const JOn={toc:[]},tFn="wrapper";function eFn(t){let{components:e,...n}=t;return(0,s.kt)(tFn,(0,p.Z)({},JOn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}eFn.isMDXComponent=!0;const nFn={toc:[]},oFn="wrapper";function pFn(t){let{components:e,...n}=t;return(0,s.kt)(oFn,(0,p.Z)({},nFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}pFn.isMDXComponent=!0;const rFn={toc:[]},sFn="wrapper";function cFn(t){let{components:e,...n}=t;return(0,s.kt)(sFn,(0,p.Z)({},rFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}cFn.isMDXComponent=!0;const aFn={toc:[]},iFn="wrapper";function lFn(t){let{components:e,...n}=t;return(0,s.kt)(iFn,(0,p.Z)({},aFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}lFn.isMDXComponent=!0;const uFn={toc:[]},mFn="wrapper";function dFn(t){let{components:e,...n}=t;return(0,s.kt)(mFn,(0,p.Z)({},uFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}dFn.isMDXComponent=!0;const hFn={toc:[]},fFn="wrapper";function kFn(t){let{components:e,...n}=t;return(0,s.kt)(fFn,(0,p.Z)({},hFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}kFn.isMDXComponent=!0;const yFn={toc:[]},DFn="wrapper";function MFn(t){let{components:e,...n}=t;return(0,s.kt)(DFn,(0,p.Z)({},yFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}MFn.isMDXComponent=!0;const XFn={toc:[]},_Fn="wrapper";function wFn(t){let{components:e,...n}=t;return(0,s.kt)(_Fn,(0,p.Z)({},XFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}wFn.isMDXComponent=!0;const TFn={toc:[]},CFn="wrapper";function xFn(t){let{components:e,...n}=t;return(0,s.kt)(CFn,(0,p.Z)({},TFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}xFn.isMDXComponent=!0;const gFn={toc:[]},vFn="wrapper";function LFn(t){let{components:e,...n}=t;return(0,s.kt)(vFn,(0,p.Z)({},gFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}LFn.isMDXComponent=!0;const ZFn={toc:[]},bFn="wrapper";function NFn(t){let{components:e,...n}=t;return(0,s.kt)(bFn,(0,p.Z)({},ZFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}NFn.isMDXComponent=!0;const zFn={toc:[]},AFn="wrapper";function PFn(t){let{components:e,...n}=t;return(0,s.kt)(AFn,(0,p.Z)({},zFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}PFn.isMDXComponent=!0;const WFn={toc:[]},RFn="wrapper";function IFn(t){let{components:e,...n}=t;return(0,s.kt)(RFn,(0,p.Z)({},WFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}IFn.isMDXComponent=!0;const SFn={toc:[]},BFn="wrapper";function GFn(t){let{components:e,...n}=t;return(0,s.kt)(BFn,(0,p.Z)({},SFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}GFn.isMDXComponent=!0;const EFn={toc:[]},OFn="wrapper";function FFn(t){let{components:e,...n}=t;return(0,s.kt)(OFn,(0,p.Z)({},EFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}FFn.isMDXComponent=!0;const UFn={toc:[]},VFn="wrapper";function qFn(t){let{components:e,...n}=t;return(0,s.kt)(VFn,(0,p.Z)({},UFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}qFn.isMDXComponent=!0;const jFn={toc:[]},YFn="wrapper";function QFn(t){let{components:e,...n}=t;return(0,s.kt)(YFn,(0,p.Z)({},jFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}QFn.isMDXComponent=!0;const HFn={toc:[]},KFn="wrapper";function $Fn(t){let{components:e,...n}=t;return(0,s.kt)(KFn,(0,p.Z)({},HFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}$Fn.isMDXComponent=!0;const JFn={toc:[]},tUn="wrapper";function eUn(t){let{components:e,...n}=t;return(0,s.kt)(tUn,(0,p.Z)({},JFn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}eUn.isMDXComponent=!0;const nUn={toc:[]},oUn="wrapper";function pUn(t){let{components:e,...n}=t;return(0,s.kt)(oUn,(0,p.Z)({},nUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}pUn.isMDXComponent=!0;const rUn={toc:[]},sUn="wrapper";function cUn(t){let{components:e,...n}=t;return(0,s.kt)(sUn,(0,p.Z)({},rUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}cUn.isMDXComponent=!0;const aUn={toc:[]},iUn="wrapper";function lUn(t){let{components:e,...n}=t;return(0,s.kt)(iUn,(0,p.Z)({},aUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}lUn.isMDXComponent=!0;const uUn={toc:[]},mUn="wrapper";function dUn(t){let{components:e,...n}=t;return(0,s.kt)(mUn,(0,p.Z)({},uUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}dUn.isMDXComponent=!0;const hUn={toc:[]},fUn="wrapper";function kUn(t){let{components:e,...n}=t;return(0,s.kt)(fUn,(0,p.Z)({},hUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kUn.isMDXComponent=!0;const yUn={toc:[]},DUn="wrapper";function MUn(t){let{components:e,...n}=t;return(0,s.kt)(DUn,(0,p.Z)({},yUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}MUn.isMDXComponent=!0;const XUn={toc:[]},_Un="wrapper";function wUn(t){let{components:e,...n}=t;return(0,s.kt)(_Un,(0,p.Z)({},XUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wUn.isMDXComponent=!0;const TUn={toc:[]},CUn="wrapper";function xUn(t){let{components:e,...n}=t;return(0,s.kt)(CUn,(0,p.Z)({},TUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}xUn.isMDXComponent=!0;const gUn={toc:[]},vUn="wrapper";function LUn(t){let{components:e,...n}=t;return(0,s.kt)(vUn,(0,p.Z)({},gUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}LUn.isMDXComponent=!0;const ZUn={toc:[]},bUn="wrapper";function NUn(t){let{components:e,...n}=t;return(0,s.kt)(bUn,(0,p.Z)({},ZUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}NUn.isMDXComponent=!0;const zUn={toc:[]},AUn="wrapper";function PUn(t){let{components:e,...n}=t;return(0,s.kt)(AUn,(0,p.Z)({},zUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}PUn.isMDXComponent=!0;const WUn={toc:[]},RUn="wrapper";function IUn(t){let{components:e,...n}=t;return(0,s.kt)(RUn,(0,p.Z)({},WUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}IUn.isMDXComponent=!0;const SUn={toc:[]},BUn="wrapper";function GUn(t){let{components:e,...n}=t;return(0,s.kt)(BUn,(0,p.Z)({},SUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}GUn.isMDXComponent=!0;const EUn={toc:[]},OUn="wrapper";function FUn(t){let{components:e,...n}=t;return(0,s.kt)(OUn,(0,p.Z)({},EUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}FUn.isMDXComponent=!0;const UUn={toc:[]},VUn="wrapper";function qUn(t){let{components:e,...n}=t;return(0,s.kt)(VUn,(0,p.Z)({},UUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qUn.isMDXComponent=!0;const jUn={toc:[]},YUn="wrapper";function QUn(t){let{components:e,...n}=t;return(0,s.kt)(YUn,(0,p.Z)({},jUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}QUn.isMDXComponent=!0;const HUn={toc:[]},KUn="wrapper";function $Un(t){let{components:e,...n}=t;return(0,s.kt)(KUn,(0,p.Z)({},HUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}$Un.isMDXComponent=!0;const JUn={toc:[]},tVn="wrapper";function eVn(t){let{components:e,...n}=t;return(0,s.kt)(tVn,(0,p.Z)({},JUn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}eVn.isMDXComponent=!0;const nVn={toc:[]},oVn="wrapper";function pVn(t){let{components:e,...n}=t;return(0,s.kt)(oVn,(0,p.Z)({},nVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}pVn.isMDXComponent=!0;const rVn={toc:[]},sVn="wrapper";function cVn(t){let{components:e,...n}=t;return(0,s.kt)(sVn,(0,p.Z)({},rVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}cVn.isMDXComponent=!0;const aVn={toc:[]},iVn="wrapper";function lVn(t){let{components:e,...n}=t;return(0,s.kt)(iVn,(0,p.Z)({},aVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}lVn.isMDXComponent=!0;const uVn={toc:[]},mVn="wrapper";function dVn(t){let{components:e,...n}=t;return(0,s.kt)(mVn,(0,p.Z)({},uVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}dVn.isMDXComponent=!0;const hVn={toc:[]},fVn="wrapper";function kVn(t){let{components:e,...n}=t;return(0,s.kt)(fVn,(0,p.Z)({},hVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}kVn.isMDXComponent=!0;const yVn={toc:[]},DVn="wrapper";function MVn(t){let{components:e,...n}=t;return(0,s.kt)(DVn,(0,p.Z)({},yVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}MVn.isMDXComponent=!0;const XVn={toc:[]},_Vn="wrapper";function wVn(t){let{components:e,...n}=t;return(0,s.kt)(_Vn,(0,p.Z)({},XVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}wVn.isMDXComponent=!0;const TVn={toc:[]},CVn="wrapper";function xVn(t){let{components:e,...n}=t;return(0,s.kt)(CVn,(0,p.Z)({},TVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}xVn.isMDXComponent=!0;const gVn={toc:[]},vVn="wrapper";function LVn(t){let{components:e,...n}=t;return(0,s.kt)(vVn,(0,p.Z)({},gVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}LVn.isMDXComponent=!0;const ZVn={toc:[]},bVn="wrapper";function NVn(t){let{components:e,...n}=t;return(0,s.kt)(bVn,(0,p.Z)({},ZVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}NVn.isMDXComponent=!0;const zVn={toc:[]},AVn="wrapper";function PVn(t){let{components:e,...n}=t;return(0,s.kt)(AVn,(0,p.Z)({},zVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}PVn.isMDXComponent=!0;const WVn={toc:[]},RVn="wrapper";function IVn(t){let{components:e,...n}=t;return(0,s.kt)(RVn,(0,p.Z)({},WVn,n,{components:e,mdxType:"MDXLayout"}))}IVn.isMDXComponent=!0;const SVn={toc:[]},BVn="wrapper";function GVn(t){let{components:e,...n}=t;return(0,s.kt)(BVn,(0,p.Z)({},SVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}GVn.isMDXComponent=!0;const EVn={toc:[]},OVn="wrapper";function FVn(t){let{components:e,...n}=t;return(0,s.kt)(OVn,(0,p.Z)({},EVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}FVn.isMDXComponent=!0;const UVn={toc:[]},VVn="wrapper";function qVn(t){let{components:e,...n}=t;return(0,s.kt)(VVn,(0,p.Z)({},UVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}qVn.isMDXComponent=!0;const jVn={toc:[]},YVn="wrapper";function QVn(t){let{components:e,...n}=t;return(0,s.kt)(YVn,(0,p.Z)({},jVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}QVn.isMDXComponent=!0;const HVn={toc:[]},KVn="wrapper";function $Vn(t){let{components:e,...n}=t;return(0,s.kt)(KVn,(0,p.Z)({},HVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}$Vn.isMDXComponent=!0;const JVn={toc:[]},tqn="wrapper";function eqn(t){let{components:e,...n}=t;return(0,s.kt)(tqn,(0,p.Z)({},JVn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}eqn.isMDXComponent=!0;const nqn={toc:[]},oqn="wrapper";function pqn(t){let{components:e,...n}=t;return(0,s.kt)(oqn,(0,p.Z)({},nqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}pqn.isMDXComponent=!0;const rqn={toc:[]},sqn="wrapper";function cqn(t){let{components:e,...n}=t;return(0,s.kt)(sqn,(0,p.Z)({},rqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}cqn.isMDXComponent=!0;const aqn={toc:[]},iqn="wrapper";function lqn(t){let{components:e,...n}=t;return(0,s.kt)(iqn,(0,p.Z)({},aqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}lqn.isMDXComponent=!0;const uqn={toc:[]},mqn="wrapper";function dqn(t){let{components:e,...n}=t;return(0,s.kt)(mqn,(0,p.Z)({},uqn,n,{components:e,mdxType:"MDXLayout"}))}dqn.isMDXComponent=!0;const hqn={toc:[]},fqn="wrapper";function kqn(t){let{components:e,...n}=t;return(0,s.kt)(fqn,(0,p.Z)({},hqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kqn.isMDXComponent=!0;const yqn={toc:[]},Dqn="wrapper";function Mqn(t){let{components:e,...n}=t;return(0,s.kt)(Dqn,(0,p.Z)({},yqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Mqn.isMDXComponent=!0;const Xqn={toc:[]},_qn="wrapper";function wqn(t){let{components:e,...n}=t;return(0,s.kt)(_qn,(0,p.Z)({},Xqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wqn.isMDXComponent=!0;const Tqn={toc:[]},Cqn="wrapper";function xqn(t){let{components:e,...n}=t;return(0,s.kt)(Cqn,(0,p.Z)({},Tqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}xqn.isMDXComponent=!0;const gqn={toc:[]},vqn="wrapper";function Lqn(t){let{components:e,...n}=t;return(0,s.kt)(vqn,(0,p.Z)({},gqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Lqn.isMDXComponent=!0;const Zqn={toc:[]},bqn="wrapper";function Nqn(t){let{components:e,...n}=t;return(0,s.kt)(bqn,(0,p.Z)({},Zqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Nqn.isMDXComponent=!0;const zqn={toc:[]},Aqn="wrapper";function Pqn(t){let{components:e,...n}=t;return(0,s.kt)(Aqn,(0,p.Z)({},zqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Pqn.isMDXComponent=!0;const Wqn={toc:[]},Rqn="wrapper";function Iqn(t){let{components:e,...n}=t;return(0,s.kt)(Rqn,(0,p.Z)({},Wqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Iqn.isMDXComponent=!0;const Sqn={toc:[]},Bqn="wrapper";function Gqn(t){let{components:e,...n}=t;return(0,s.kt)(Bqn,(0,p.Z)({},Sqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}Gqn.isMDXComponent=!0;const Eqn={toc:[]},Oqn="wrapper";function Fqn(t){let{components:e,...n}=t;return(0,s.kt)(Oqn,(0,p.Z)({},Eqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Fqn.isMDXComponent=!0;const Uqn={toc:[]},Vqn="wrapper";function qqn(t){let{components:e,...n}=t;return(0,s.kt)(Vqn,(0,p.Z)({},Uqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}qqn.isMDXComponent=!0;const jqn={toc:[]},Yqn="wrapper";function Qqn(t){let{components:e,...n}=t;return(0,s.kt)(Yqn,(0,p.Z)({},jqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Qqn.isMDXComponent=!0;const Hqn={toc:[]},Kqn="wrapper";function $qn(t){let{components:e,...n}=t;return(0,s.kt)(Kqn,(0,p.Z)({},Hqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}$qn.isMDXComponent=!0;const Jqn={toc:[]},tjn="wrapper";function ejn(t){let{components:e,...n}=t;return(0,s.kt)(tjn,(0,p.Z)({},Jqn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}ejn.isMDXComponent=!0;const njn={toc:[]},ojn="wrapper";function pjn(t){let{components:e,...n}=t;return(0,s.kt)(ojn,(0,p.Z)({},njn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}pjn.isMDXComponent=!0;const rjn={toc:[]},sjn="wrapper";function cjn(t){let{components:e,...n}=t;return(0,s.kt)(sjn,(0,p.Z)({},rjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}cjn.isMDXComponent=!0;const ajn={toc:[]},ijn="wrapper";function ljn(t){let{components:e,...n}=t;return(0,s.kt)(ijn,(0,p.Z)({},ajn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}ljn.isMDXComponent=!0;const ujn={toc:[]},mjn="wrapper";function djn(t){let{components:e,...n}=t;return(0,s.kt)(mjn,(0,p.Z)({},ujn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}djn.isMDXComponent=!0;const hjn={toc:[]},fjn="wrapper";function kjn(t){let{components:e,...n}=t;return(0,s.kt)(fjn,(0,p.Z)({},hjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}kjn.isMDXComponent=!0;const yjn={toc:[]},Djn="wrapper";function Mjn(t){let{components:e,...n}=t;return(0,s.kt)(Djn,(0,p.Z)({},yjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Mjn.isMDXComponent=!0;const Xjn={toc:[]},_jn="wrapper";function wjn(t){let{components:e,...n}=t;return(0,s.kt)(_jn,(0,p.Z)({},Xjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}wjn.isMDXComponent=!0;const Tjn={toc:[]},Cjn="wrapper";function xjn(t){let{components:e,...n}=t;return(0,s.kt)(Cjn,(0,p.Z)({},Tjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}xjn.isMDXComponent=!0;const gjn={toc:[]},vjn="wrapper";function Ljn(t){let{components:e,...n}=t;return(0,s.kt)(vjn,(0,p.Z)({},gjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}Ljn.isMDXComponent=!0;const Zjn={toc:[]},bjn="wrapper";function Njn(t){let{components:e,...n}=t;return(0,s.kt)(bjn,(0,p.Z)({},Zjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}Njn.isMDXComponent=!0;const zjn={toc:[]},Ajn="wrapper";function Pjn(t){let{components:e,...n}=t;return(0,s.kt)(Ajn,(0,p.Z)({},zjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Pjn.isMDXComponent=!0;const Wjn={toc:[]},Rjn="wrapper";function Ijn(t){let{components:e,...n}=t;return(0,s.kt)(Rjn,(0,p.Z)({},Wjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}Ijn.isMDXComponent=!0;const Sjn={toc:[]},Bjn="wrapper";function Gjn(t){let{components:e,...n}=t;return(0,s.kt)(Bjn,(0,p.Z)({},Sjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Gjn.isMDXComponent=!0;const Ejn={toc:[]},Ojn="wrapper";function Fjn(t){let{components:e,...n}=t;return(0,s.kt)(Ojn,(0,p.Z)({},Ejn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Fjn.isMDXComponent=!0;const Ujn={toc:[]},Vjn="wrapper";function qjn(t){let{components:e,...n}=t;return(0,s.kt)(Vjn,(0,p.Z)({},Ujn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}qjn.isMDXComponent=!0;const jjn={toc:[]},Yjn="wrapper";function Qjn(t){let{components:e,...n}=t;return(0,s.kt)(Yjn,(0,p.Z)({},jjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}Qjn.isMDXComponent=!0;const Hjn={toc:[]},Kjn="wrapper";function $jn(t){let{components:e,...n}=t;return(0,s.kt)(Kjn,(0,p.Z)({},Hjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}$jn.isMDXComponent=!0;const Jjn={toc:[]},tYn="wrapper";function eYn(t){let{components:e,...n}=t;return(0,s.kt)(tYn,(0,p.Z)({},Jjn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}eYn.isMDXComponent=!0;const nYn={toc:[]},oYn="wrapper";function pYn(t){let{components:e,...n}=t;return(0,s.kt)(oYn,(0,p.Z)({},nYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}pYn.isMDXComponent=!0;const rYn={toc:[]},sYn="wrapper";function cYn(t){let{components:e,...n}=t;return(0,s.kt)(sYn,(0,p.Z)({},rYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}cYn.isMDXComponent=!0;const aYn={toc:[]},iYn="wrapper";function lYn(t){let{components:e,...n}=t;return(0,s.kt)(iYn,(0,p.Z)({},aYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}lYn.isMDXComponent=!0;const uYn={toc:[]},mYn="wrapper";function dYn(t){let{components:e,...n}=t;return(0,s.kt)(mYn,(0,p.Z)({},uYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}dYn.isMDXComponent=!0;const hYn={toc:[]},fYn="wrapper";function kYn(t){let{components:e,...n}=t;return(0,s.kt)(fYn,(0,p.Z)({},hYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}kYn.isMDXComponent=!0;const yYn={toc:[]},DYn="wrapper";function MYn(t){let{components:e,...n}=t;return(0,s.kt)(DYn,(0,p.Z)({},yYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}MYn.isMDXComponent=!0;const XYn={toc:[]},_Yn="wrapper";function wYn(t){let{components:e,...n}=t;return(0,s.kt)(_Yn,(0,p.Z)({},XYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}wYn.isMDXComponent=!0;const TYn={toc:[]},CYn="wrapper";function xYn(t){let{components:e,...n}=t;return(0,s.kt)(CYn,(0,p.Z)({},TYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}xYn.isMDXComponent=!0;const gYn={toc:[]},vYn="wrapper";function LYn(t){let{components:e,...n}=t;return(0,s.kt)(vYn,(0,p.Z)({},gYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}LYn.isMDXComponent=!0;const ZYn={toc:[]},bYn="wrapper";function NYn(t){let{components:e,...n}=t;return(0,s.kt)(bYn,(0,p.Z)({},ZYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}NYn.isMDXComponent=!0;const zYn={toc:[]},AYn="wrapper";function PYn(t){let{components:e,...n}=t;return(0,s.kt)(AYn,(0,p.Z)({},zYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}PYn.isMDXComponent=!0;const WYn={toc:[]},RYn="wrapper";function IYn(t){let{components:e,...n}=t;return(0,s.kt)(RYn,(0,p.Z)({},WYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}IYn.isMDXComponent=!0;const SYn={toc:[]},BYn="wrapper";function GYn(t){let{components:e,...n}=t;return(0,s.kt)(BYn,(0,p.Z)({},SYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}GYn.isMDXComponent=!0;const EYn={toc:[]},OYn="wrapper";function FYn(t){let{components:e,...n}=t;return(0,s.kt)(OYn,(0,p.Z)({},EYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}FYn.isMDXComponent=!0;const UYn={toc:[]},VYn="wrapper";function qYn(t){let{components:e,...n}=t;return(0,s.kt)(VYn,(0,p.Z)({},UYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}qYn.isMDXComponent=!0;const jYn={toc:[]},YYn="wrapper";function QYn(t){let{components:e,...n}=t;return(0,s.kt)(YYn,(0,p.Z)({},jYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}QYn.isMDXComponent=!0;const HYn={toc:[]},KYn="wrapper";function $Yn(t){let{components:e,...n}=t;return(0,s.kt)(KYn,(0,p.Z)({},HYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}$Yn.isMDXComponent=!0;const JYn={toc:[]},tQn="wrapper";function eQn(t){let{components:e,...n}=t;return(0,s.kt)(tQn,(0,p.Z)({},JYn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}eQn.isMDXComponent=!0;const nQn={toc:[]},oQn="wrapper";function pQn(t){let{components:e,...n}=t;return(0,s.kt)(oQn,(0,p.Z)({},nQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pQn.isMDXComponent=!0;const rQn={toc:[]},sQn="wrapper";function cQn(t){let{components:e,...n}=t;return(0,s.kt)(sQn,(0,p.Z)({},rQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}cQn.isMDXComponent=!0;const aQn={toc:[]},iQn="wrapper";function lQn(t){let{components:e,...n}=t;return(0,s.kt)(iQn,(0,p.Z)({},aQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}lQn.isMDXComponent=!0;const uQn={toc:[]},mQn="wrapper";function dQn(t){let{components:e,...n}=t;return(0,s.kt)(mQn,(0,p.Z)({},uQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dQn.isMDXComponent=!0;const hQn={toc:[]},fQn="wrapper";function kQn(t){let{components:e,...n}=t;return(0,s.kt)(fQn,(0,p.Z)({},hQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}kQn.isMDXComponent=!0;const yQn={toc:[]},DQn="wrapper";function MQn(t){let{components:e,...n}=t;return(0,s.kt)(DQn,(0,p.Z)({},yQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}MQn.isMDXComponent=!0;const XQn={toc:[]},_Qn="wrapper";function wQn(t){let{components:e,...n}=t;return(0,s.kt)(_Qn,(0,p.Z)({},XQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wQn.isMDXComponent=!0;const TQn={toc:[]},CQn="wrapper";function xQn(t){let{components:e,...n}=t;return(0,s.kt)(CQn,(0,p.Z)({},TQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}xQn.isMDXComponent=!0;const gQn={toc:[]},vQn="wrapper";function LQn(t){let{components:e,...n}=t;return(0,s.kt)(vQn,(0,p.Z)({},gQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}LQn.isMDXComponent=!0;const ZQn={toc:[]},bQn="wrapper";function NQn(t){let{components:e,...n}=t;return(0,s.kt)(bQn,(0,p.Z)({},ZQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NQn.isMDXComponent=!0;const zQn={toc:[]},AQn="wrapper";function PQn(t){let{components:e,...n}=t;return(0,s.kt)(AQn,(0,p.Z)({},zQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}PQn.isMDXComponent=!0;const WQn={toc:[]},RQn="wrapper";function IQn(t){let{components:e,...n}=t;return(0,s.kt)(RQn,(0,p.Z)({},WQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}IQn.isMDXComponent=!0;const SQn={toc:[]},BQn="wrapper";function GQn(t){let{components:e,...n}=t;return(0,s.kt)(BQn,(0,p.Z)({},SQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}GQn.isMDXComponent=!0;const EQn={toc:[]},OQn="wrapper";function FQn(t){let{components:e,...n}=t;return(0,s.kt)(OQn,(0,p.Z)({},EQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}FQn.isMDXComponent=!0;const UQn={toc:[]},VQn="wrapper";function qQn(t){let{components:e,...n}=t;return(0,s.kt)(VQn,(0,p.Z)({},UQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}qQn.isMDXComponent=!0;const jQn={toc:[]},YQn="wrapper";function QQn(t){let{components:e,...n}=t;return(0,s.kt)(YQn,(0,p.Z)({},jQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}QQn.isMDXComponent=!0;const HQn={toc:[]},KQn="wrapper";function $Qn(t){let{components:e,...n}=t;return(0,s.kt)(KQn,(0,p.Z)({},HQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}$Qn.isMDXComponent=!0;const JQn={toc:[]},tHn="wrapper";function eHn(t){let{components:e,...n}=t;return(0,s.kt)(tHn,(0,p.Z)({},JQn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}eHn.isMDXComponent=!0;const nHn={toc:[]},oHn="wrapper";function pHn(t){let{components:e,...n}=t;return(0,s.kt)(oHn,(0,p.Z)({},nHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pHn.isMDXComponent=!0;const rHn={toc:[]},sHn="wrapper";function cHn(t){let{components:e,...n}=t;return(0,s.kt)(sHn,(0,p.Z)({},rHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}cHn.isMDXComponent=!0;const aHn={toc:[]},iHn="wrapper";function lHn(t){let{components:e,...n}=t;return(0,s.kt)(iHn,(0,p.Z)({},aHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lHn.isMDXComponent=!0;const uHn={toc:[]},mHn="wrapper";function dHn(t){let{components:e,...n}=t;return(0,s.kt)(mHn,(0,p.Z)({},uHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}dHn.isMDXComponent=!0;const hHn={toc:[]},fHn="wrapper";function kHn(t){let{components:e,...n}=t;return(0,s.kt)(fHn,(0,p.Z)({},hHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}kHn.isMDXComponent=!0;const yHn={toc:[]},DHn="wrapper";function MHn(t){let{components:e,...n}=t;return(0,s.kt)(DHn,(0,p.Z)({},yHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}MHn.isMDXComponent=!0;const XHn={toc:[]},_Hn="wrapper";function wHn(t){let{components:e,...n}=t;return(0,s.kt)(_Hn,(0,p.Z)({},XHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}wHn.isMDXComponent=!0;const THn={toc:[]},CHn="wrapper";function xHn(t){let{components:e,...n}=t;return(0,s.kt)(CHn,(0,p.Z)({},THn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}xHn.isMDXComponent=!0;const gHn={toc:[]},vHn="wrapper";function LHn(t){let{components:e,...n}=t;return(0,s.kt)(vHn,(0,p.Z)({},gHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}LHn.isMDXComponent=!0;const ZHn={toc:[]},bHn="wrapper";function NHn(t){let{components:e,...n}=t;return(0,s.kt)(bHn,(0,p.Z)({},ZHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}NHn.isMDXComponent=!0;const zHn={toc:[]},AHn="wrapper";function PHn(t){let{components:e,...n}=t;return(0,s.kt)(AHn,(0,p.Z)({},zHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}PHn.isMDXComponent=!0;const WHn={toc:[]},RHn="wrapper";function IHn(t){let{components:e,...n}=t;return(0,s.kt)(RHn,(0,p.Z)({},WHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}IHn.isMDXComponent=!0;const SHn={toc:[]},BHn="wrapper";function GHn(t){let{components:e,...n}=t;return(0,s.kt)(BHn,(0,p.Z)({},SHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}GHn.isMDXComponent=!0;const EHn={toc:[]},OHn="wrapper";function FHn(t){let{components:e,...n}=t;return(0,s.kt)(OHn,(0,p.Z)({},EHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}FHn.isMDXComponent=!0;const UHn={toc:[]},VHn="wrapper";function qHn(t){let{components:e,...n}=t;return(0,s.kt)(VHn,(0,p.Z)({},UHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}qHn.isMDXComponent=!0;const jHn={toc:[]},YHn="wrapper";function QHn(t){let{components:e,...n}=t;return(0,s.kt)(YHn,(0,p.Z)({},jHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}QHn.isMDXComponent=!0;const HHn={toc:[]},KHn="wrapper";function $Hn(t){let{components:e,...n}=t;return(0,s.kt)(KHn,(0,p.Z)({},HHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}$Hn.isMDXComponent=!0;const JHn={toc:[]},tKn="wrapper";function eKn(t){let{components:e,...n}=t;return(0,s.kt)(tKn,(0,p.Z)({},JHn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}eKn.isMDXComponent=!0;const nKn={toc:[]},oKn="wrapper";function pKn(t){let{components:e,...n}=t;return(0,s.kt)(oKn,(0,p.Z)({},nKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}pKn.isMDXComponent=!0;const rKn={toc:[]},sKn="wrapper";function cKn(t){let{components:e,...n}=t;return(0,s.kt)(sKn,(0,p.Z)({},rKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}cKn.isMDXComponent=!0;const aKn={toc:[]},iKn="wrapper";function lKn(t){let{components:e,...n}=t;return(0,s.kt)(iKn,(0,p.Z)({},aKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}lKn.isMDXComponent=!0;const uKn={toc:[]},mKn="wrapper";function dKn(t){let{components:e,...n}=t;return(0,s.kt)(mKn,(0,p.Z)({},uKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dKn.isMDXComponent=!0;const hKn={toc:[]},fKn="wrapper";function kKn(t){let{components:e,...n}=t;return(0,s.kt)(fKn,(0,p.Z)({},hKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}kKn.isMDXComponent=!0;const yKn={toc:[]},DKn="wrapper";function MKn(t){let{components:e,...n}=t;return(0,s.kt)(DKn,(0,p.Z)({},yKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}MKn.isMDXComponent=!0;const XKn={toc:[]},_Kn="wrapper";function wKn(t){let{components:e,...n}=t;return(0,s.kt)(_Kn,(0,p.Z)({},XKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wKn.isMDXComponent=!0;const TKn={toc:[]},CKn="wrapper";function xKn(t){let{components:e,...n}=t;return(0,s.kt)(CKn,(0,p.Z)({},TKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}xKn.isMDXComponent=!0;const gKn={toc:[]},vKn="wrapper";function LKn(t){let{components:e,...n}=t;return(0,s.kt)(vKn,(0,p.Z)({},gKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}LKn.isMDXComponent=!0;const ZKn={toc:[]},bKn="wrapper";function NKn(t){let{components:e,...n}=t;return(0,s.kt)(bKn,(0,p.Z)({},ZKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}NKn.isMDXComponent=!0;const zKn={toc:[]},AKn="wrapper";function PKn(t){let{components:e,...n}=t;return(0,s.kt)(AKn,(0,p.Z)({},zKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}PKn.isMDXComponent=!0;const WKn={toc:[]},RKn="wrapper";function IKn(t){let{components:e,...n}=t;return(0,s.kt)(RKn,(0,p.Z)({},WKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}IKn.isMDXComponent=!0;const SKn={toc:[]},BKn="wrapper";function GKn(t){let{components:e,...n}=t;return(0,s.kt)(BKn,(0,p.Z)({},SKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}GKn.isMDXComponent=!0;const EKn={toc:[]},OKn="wrapper";function FKn(t){let{components:e,...n}=t;return(0,s.kt)(OKn,(0,p.Z)({},EKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}FKn.isMDXComponent=!0;const UKn={toc:[]},VKn="wrapper";function qKn(t){let{components:e,...n}=t;return(0,s.kt)(VKn,(0,p.Z)({},UKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qKn.isMDXComponent=!0;const jKn={toc:[]},YKn="wrapper";function QKn(t){let{components:e,...n}=t;return(0,s.kt)(YKn,(0,p.Z)({},jKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}QKn.isMDXComponent=!0;const HKn={toc:[]},KKn="wrapper";function $Kn(t){let{components:e,...n}=t;return(0,s.kt)(KKn,(0,p.Z)({},HKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}$Kn.isMDXComponent=!0;const JKn={toc:[]},t$n="wrapper";function e$n(t){let{components:e,...n}=t;return(0,s.kt)(t$n,(0,p.Z)({},JKn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}e$n.isMDXComponent=!0;const n$n={toc:[]},o$n="wrapper";function p$n(t){let{components:e,...n}=t;return(0,s.kt)(o$n,(0,p.Z)({},n$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}p$n.isMDXComponent=!0;const r$n={toc:[]},s$n="wrapper";function c$n(t){let{components:e,...n}=t;return(0,s.kt)(s$n,(0,p.Z)({},r$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}c$n.isMDXComponent=!0;const a$n={toc:[]},i$n="wrapper";function l$n(t){let{components:e,...n}=t;return(0,s.kt)(i$n,(0,p.Z)({},a$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}l$n.isMDXComponent=!0;const u$n={toc:[]},m$n="wrapper";function d$n(t){let{components:e,...n}=t;return(0,s.kt)(m$n,(0,p.Z)({},u$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}d$n.isMDXComponent=!0;const h$n={toc:[]},f$n="wrapper";function k$n(t){let{components:e,...n}=t;return(0,s.kt)(f$n,(0,p.Z)({},h$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}k$n.isMDXComponent=!0;const y$n={toc:[]},D$n="wrapper";function M$n(t){let{components:e,...n}=t;return(0,s.kt)(D$n,(0,p.Z)({},y$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}M$n.isMDXComponent=!0;const X$n={toc:[]},_$n="wrapper";function w$n(t){let{components:e,...n}=t;return(0,s.kt)(_$n,(0,p.Z)({},X$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}w$n.isMDXComponent=!0;const T$n={toc:[]},C$n="wrapper";function x$n(t){let{components:e,...n}=t;return(0,s.kt)(C$n,(0,p.Z)({},T$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}x$n.isMDXComponent=!0;const g$n={toc:[]},v$n="wrapper";function L$n(t){let{components:e,...n}=t;return(0,s.kt)(v$n,(0,p.Z)({},g$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}L$n.isMDXComponent=!0;const Z$n={toc:[]},b$n="wrapper";function N$n(t){let{components:e,...n}=t;return(0,s.kt)(b$n,(0,p.Z)({},Z$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}N$n.isMDXComponent=!0;const z$n={toc:[]},A$n="wrapper";function P$n(t){let{components:e,...n}=t;return(0,s.kt)(A$n,(0,p.Z)({},z$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}P$n.isMDXComponent=!0;const W$n={toc:[]},R$n="wrapper";function I$n(t){let{components:e,...n}=t;return(0,s.kt)(R$n,(0,p.Z)({},W$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}I$n.isMDXComponent=!0;const S$n={toc:[]},B$n="wrapper";function G$n(t){let{components:e,...n}=t;return(0,s.kt)(B$n,(0,p.Z)({},S$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}G$n.isMDXComponent=!0;const E$n={toc:[]},O$n="wrapper";function F$n(t){let{components:e,...n}=t;return(0,s.kt)(O$n,(0,p.Z)({},E$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}F$n.isMDXComponent=!0;const U$n={toc:[]},V$n="wrapper";function q$n(t){let{components:e,...n}=t;return(0,s.kt)(V$n,(0,p.Z)({},U$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}q$n.isMDXComponent=!0;const j$n={toc:[]},Y$n="wrapper";function Q$n(t){let{components:e,...n}=t;return(0,s.kt)(Y$n,(0,p.Z)({},j$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}Q$n.isMDXComponent=!0;const H$n={toc:[]},K$n="wrapper";function $$n(t){let{components:e,...n}=t;return(0,s.kt)(K$n,(0,p.Z)({},H$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}$$n.isMDXComponent=!0;const J$n={toc:[]},tJn="wrapper";function eJn(t){let{components:e,...n}=t;return(0,s.kt)(tJn,(0,p.Z)({},J$n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}eJn.isMDXComponent=!0;const nJn={toc:[]},oJn="wrapper";function pJn(t){let{components:e,...n}=t;return(0,s.kt)(oJn,(0,p.Z)({},nJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}pJn.isMDXComponent=!0;const rJn={toc:[]},sJn="wrapper";function cJn(t){let{components:e,...n}=t;return(0,s.kt)(sJn,(0,p.Z)({},rJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cJn.isMDXComponent=!0;const aJn={toc:[]},iJn="wrapper";function lJn(t){let{components:e,...n}=t;return(0,s.kt)(iJn,(0,p.Z)({},aJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}lJn.isMDXComponent=!0;const uJn={toc:[]},mJn="wrapper";function dJn(t){let{components:e,...n}=t;return(0,s.kt)(mJn,(0,p.Z)({},uJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}dJn.isMDXComponent=!0;const hJn={toc:[]},fJn="wrapper";function kJn(t){let{components:e,...n}=t;return(0,s.kt)(fJn,(0,p.Z)({},hJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}kJn.isMDXComponent=!0;const yJn={toc:[]},DJn="wrapper";function MJn(t){let{components:e,...n}=t;return(0,s.kt)(DJn,(0,p.Z)({},yJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}MJn.isMDXComponent=!0;const XJn={toc:[]},_Jn="wrapper";function wJn(t){let{components:e,...n}=t;return(0,s.kt)(_Jn,(0,p.Z)({},XJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}wJn.isMDXComponent=!0;const TJn={toc:[]},CJn="wrapper";function xJn(t){let{components:e,...n}=t;return(0,s.kt)(CJn,(0,p.Z)({},TJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}xJn.isMDXComponent=!0;const gJn={toc:[]},vJn="wrapper";function LJn(t){let{components:e,...n}=t;return(0,s.kt)(vJn,(0,p.Z)({},gJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}LJn.isMDXComponent=!0;const ZJn={toc:[]},bJn="wrapper";function NJn(t){let{components:e,...n}=t;return(0,s.kt)(bJn,(0,p.Z)({},ZJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}NJn.isMDXComponent=!0;const zJn={toc:[]},AJn="wrapper";function PJn(t){let{components:e,...n}=t;return(0,s.kt)(AJn,(0,p.Z)({},zJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}PJn.isMDXComponent=!0;const WJn={toc:[]},RJn="wrapper";function IJn(t){let{components:e,...n}=t;return(0,s.kt)(RJn,(0,p.Z)({},WJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}IJn.isMDXComponent=!0;const SJn={toc:[]},BJn="wrapper";function GJn(t){let{components:e,...n}=t;return(0,s.kt)(BJn,(0,p.Z)({},SJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}GJn.isMDXComponent=!0;const EJn={toc:[]},OJn="wrapper";function FJn(t){let{components:e,...n}=t;return(0,s.kt)(OJn,(0,p.Z)({},EJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}FJn.isMDXComponent=!0;const UJn={toc:[]},VJn="wrapper";function qJn(t){let{components:e,...n}=t;return(0,s.kt)(VJn,(0,p.Z)({},UJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}qJn.isMDXComponent=!0;const jJn={toc:[]},YJn="wrapper";function QJn(t){let{components:e,...n}=t;return(0,s.kt)(YJn,(0,p.Z)({},jJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}QJn.isMDXComponent=!0;const HJn={toc:[]},KJn="wrapper";function $Jn(t){let{components:e,...n}=t;return(0,s.kt)(KJn,(0,p.Z)({},HJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}$Jn.isMDXComponent=!0;const JJn={toc:[]},t0n="wrapper";function e0n(t){let{components:e,...n}=t;return(0,s.kt)(t0n,(0,p.Z)({},JJn,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}e0n.isMDXComponent=!0;const n0n={toc:[]},o0n="wrapper";function p0n(t){let{components:e,...n}=t;return(0,s.kt)(o0n,(0,p.Z)({},n0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}p0n.isMDXComponent=!0;const r0n={toc:[]},s0n="wrapper";function c0n(t){let{components:e,...n}=t;return(0,s.kt)(s0n,(0,p.Z)({},r0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}c0n.isMDXComponent=!0;const a0n={toc:[]},i0n="wrapper";function l0n(t){let{components:e,...n}=t;return(0,s.kt)(i0n,(0,p.Z)({},a0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}l0n.isMDXComponent=!0;const u0n={toc:[]},m0n="wrapper";function d0n(t){let{components:e,...n}=t;return(0,s.kt)(m0n,(0,p.Z)({},u0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}d0n.isMDXComponent=!0;const h0n={toc:[]},f0n="wrapper";function k0n(t){let{components:e,...n}=t;return(0,s.kt)(f0n,(0,p.Z)({},h0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}k0n.isMDXComponent=!0;const y0n={toc:[]},D0n="wrapper";function M0n(t){let{components:e,...n}=t;return(0,s.kt)(D0n,(0,p.Z)({},y0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}M0n.isMDXComponent=!0;const X0n={toc:[]},_0n="wrapper";function w0n(t){let{components:e,...n}=t;return(0,s.kt)(_0n,(0,p.Z)({},X0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}w0n.isMDXComponent=!0;const T0n={toc:[]},C0n="wrapper";function x0n(t){let{components:e,...n}=t;return(0,s.kt)(C0n,(0,p.Z)({},T0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}x0n.isMDXComponent=!0;const g0n={toc:[]},v0n="wrapper";function L0n(t){let{components:e,...n}=t;return(0,s.kt)(v0n,(0,p.Z)({},g0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}L0n.isMDXComponent=!0;const Z0n={toc:[]},b0n="wrapper";function N0n(t){let{components:e,...n}=t;return(0,s.kt)(b0n,(0,p.Z)({},Z0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}N0n.isMDXComponent=!0;const z0n={toc:[]},A0n="wrapper";function P0n(t){let{components:e,...n}=t;return(0,s.kt)(A0n,(0,p.Z)({},z0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}P0n.isMDXComponent=!0;const W0n={toc:[]},R0n="wrapper";function I0n(t){let{components:e,...n}=t;return(0,s.kt)(R0n,(0,p.Z)({},W0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}I0n.isMDXComponent=!0;const S0n={toc:[]},B0n="wrapper";function G0n(t){let{components:e,...n}=t;return(0,s.kt)(B0n,(0,p.Z)({},S0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}G0n.isMDXComponent=!0;const E0n={toc:[]},O0n="wrapper";function F0n(t){let{components:e,...n}=t;return(0,s.kt)(O0n,(0,p.Z)({},E0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}F0n.isMDXComponent=!0;const U0n={toc:[]},V0n="wrapper";function q0n(t){let{components:e,...n}=t;return(0,s.kt)(V0n,(0,p.Z)({},U0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}q0n.isMDXComponent=!0;const j0n={toc:[]},Y0n="wrapper";function Q0n(t){let{components:e,...n}=t;return(0,s.kt)(Y0n,(0,p.Z)({},j0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Q0n.isMDXComponent=!0;const H0n={toc:[]},K0n="wrapper";function $0n(t){let{components:e,...n}=t;return(0,s.kt)(K0n,(0,p.Z)({},H0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}$0n.isMDXComponent=!0;const J0n={toc:[]},t4n="wrapper";function e4n(t){let{components:e,...n}=t;return(0,s.kt)(t4n,(0,p.Z)({},J0n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}e4n.isMDXComponent=!0;const n4n={toc:[]},o4n="wrapper";function p4n(t){let{components:e,...n}=t;return(0,s.kt)(o4n,(0,p.Z)({},n4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}p4n.isMDXComponent=!0;const r4n={toc:[]},s4n="wrapper";function c4n(t){let{components:e,...n}=t;return(0,s.kt)(s4n,(0,p.Z)({},r4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}c4n.isMDXComponent=!0;const a4n={toc:[]},i4n="wrapper";function l4n(t){let{components:e,...n}=t;return(0,s.kt)(i4n,(0,p.Z)({},a4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}l4n.isMDXComponent=!0;const u4n={toc:[]},m4n="wrapper";function d4n(t){let{components:e,...n}=t;return(0,s.kt)(m4n,(0,p.Z)({},u4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}d4n.isMDXComponent=!0;const h4n={toc:[]},f4n="wrapper";function k4n(t){let{components:e,...n}=t;return(0,s.kt)(f4n,(0,p.Z)({},h4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}k4n.isMDXComponent=!0;const y4n={toc:[]},D4n="wrapper";function M4n(t){let{components:e,...n}=t;return(0,s.kt)(D4n,(0,p.Z)({},y4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}M4n.isMDXComponent=!0;const X4n={toc:[]},_4n="wrapper";function w4n(t){let{components:e,...n}=t;return(0,s.kt)(_4n,(0,p.Z)({},X4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}w4n.isMDXComponent=!0;const T4n={toc:[]},C4n="wrapper";function x4n(t){let{components:e,...n}=t;return(0,s.kt)(C4n,(0,p.Z)({},T4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}x4n.isMDXComponent=!0;const g4n={toc:[]},v4n="wrapper";function L4n(t){let{components:e,...n}=t;return(0,s.kt)(v4n,(0,p.Z)({},g4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If you're not interested in animating SVG, you can use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Img"},(0,s.kt)("inlineCode",{parentName:"a"},"Img"))," instead."))}L4n.isMDXComponent=!0;const Z4n={toc:[]},b4n="wrapper";function N4n(t){let{components:e,...n}=t;return(0,s.kt)(b4n,(0,p.Z)({},Z4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A Node for drawing and animating SVG images."))}N4n.isMDXComponent=!0;const z4n={toc:[]},A4n="wrapper";function P4n(t){let{components:e,...n}=t;return(0,s.kt)(A4n,(0,p.Z)({},z4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}P4n.isMDXComponent=!0;const W4n={toc:[]},R4n="wrapper";function I4n(t){let{components:e,...n}=t;return(0,s.kt)(R4n,(0,p.Z)({},W4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}I4n.isMDXComponent=!0;const S4n={toc:[]},B4n="wrapper";function G4n(t){let{components:e,...n}=t;return(0,s.kt)(B4n,(0,p.Z)({},S4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}G4n.isMDXComponent=!0;const E4n={toc:[]},O4n="wrapper";function F4n(t){let{components:e,...n}=t;return(0,s.kt)(O4n,(0,p.Z)({},E4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}F4n.isMDXComponent=!0;const U4n={toc:[]},V4n="wrapper";function q4n(t){let{components:e,...n}=t;return(0,s.kt)(V4n,(0,p.Z)({},U4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}q4n.isMDXComponent=!0;const j4n={toc:[]},Y4n="wrapper";function Q4n(t){let{components:e,...n}=t;return(0,s.kt)(Y4n,(0,p.Z)({},j4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Q4n.isMDXComponent=!0;const H4n={toc:[]},K4n="wrapper";function $4n(t){let{components:e,...n}=t;return(0,s.kt)(K4n,(0,p.Z)({},H4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}$4n.isMDXComponent=!0;const J4n={toc:[]},t6n="wrapper";function e6n(t){let{components:e,...n}=t;return(0,s.kt)(t6n,(0,p.Z)({},J4n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}e6n.isMDXComponent=!0;const n6n={toc:[]},o6n="wrapper";function p6n(t){let{components:e,...n}=t;return(0,s.kt)(o6n,(0,p.Z)({},n6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}p6n.isMDXComponent=!0;const r6n={toc:[]},s6n="wrapper";function c6n(t){let{components:e,...n}=t;return(0,s.kt)(s6n,(0,p.Z)({},r6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}c6n.isMDXComponent=!0;const a6n={toc:[]},i6n="wrapper";function l6n(t){let{components:e,...n}=t;return(0,s.kt)(i6n,(0,p.Z)({},a6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}l6n.isMDXComponent=!0;const u6n={toc:[]},m6n="wrapper";function d6n(t){let{components:e,...n}=t;return(0,s.kt)(m6n,(0,p.Z)({},u6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}d6n.isMDXComponent=!0;const h6n={toc:[]},f6n="wrapper";function k6n(t){let{components:e,...n}=t;return(0,s.kt)(f6n,(0,p.Z)({},h6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}k6n.isMDXComponent=!0;const y6n={toc:[]},D6n="wrapper";function M6n(t){let{components:e,...n}=t;return(0,s.kt)(D6n,(0,p.Z)({},y6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}M6n.isMDXComponent=!0;const X6n={toc:[]},_6n="wrapper";function w6n(t){let{components:e,...n}=t;return(0,s.kt)(_6n,(0,p.Z)({},X6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}w6n.isMDXComponent=!0;const T6n={toc:[]},C6n="wrapper";function x6n(t){let{components:e,...n}=t;return(0,s.kt)(C6n,(0,p.Z)({},T6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}x6n.isMDXComponent=!0;const g6n={toc:[]},v6n="wrapper";function L6n(t){let{components:e,...n}=t;return(0,s.kt)(v6n,(0,p.Z)({},g6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}L6n.isMDXComponent=!0;const Z6n={toc:[]},b6n="wrapper";function N6n(t){let{components:e,...n}=t;return(0,s.kt)(b6n,(0,p.Z)({},Z6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}N6n.isMDXComponent=!0;const z6n={toc:[]},A6n="wrapper";function P6n(t){let{components:e,...n}=t;return(0,s.kt)(A6n,(0,p.Z)({},z6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}P6n.isMDXComponent=!0;const W6n={toc:[]},R6n="wrapper";function I6n(t){let{components:e,...n}=t;return(0,s.kt)(R6n,(0,p.Z)({},W6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}I6n.isMDXComponent=!0;const S6n={toc:[]},B6n="wrapper";function G6n(t){let{components:e,...n}=t;return(0,s.kt)(B6n,(0,p.Z)({},S6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}G6n.isMDXComponent=!0;const E6n={toc:[]},O6n="wrapper";function F6n(t){let{components:e,...n}=t;return(0,s.kt)(O6n,(0,p.Z)({},E6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}F6n.isMDXComponent=!0;const U6n={toc:[]},V6n="wrapper";function q6n(t){let{components:e,...n}=t;return(0,s.kt)(V6n,(0,p.Z)({},U6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}q6n.isMDXComponent=!0;const j6n={toc:[]},Y6n="wrapper";function Q6n(t){let{components:e,...n}=t;return(0,s.kt)(Y6n,(0,p.Z)({},j6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Q6n.isMDXComponent=!0;const H6n={toc:[]},K6n="wrapper";function $6n(t){let{components:e,...n}=t;return(0,s.kt)(K6n,(0,p.Z)({},H6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}$6n.isMDXComponent=!0;const J6n={toc:[]},t3n="wrapper";function e3n(t){let{components:e,...n}=t;return(0,s.kt)(t3n,(0,p.Z)({},J6n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}e3n.isMDXComponent=!0;const n3n={toc:[]},o3n="wrapper";function p3n(t){let{components:e,...n}=t;return(0,s.kt)(o3n,(0,p.Z)({},n3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}p3n.isMDXComponent=!0;const r3n={toc:[]},s3n="wrapper";function c3n(t){let{components:e,...n}=t;return(0,s.kt)(s3n,(0,p.Z)({},r3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}c3n.isMDXComponent=!0;const a3n={toc:[]},i3n="wrapper";function l3n(t){let{components:e,...n}=t;return(0,s.kt)(i3n,(0,p.Z)({},a3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}l3n.isMDXComponent=!0;const u3n={toc:[]},m3n="wrapper";function d3n(t){let{components:e,...n}=t;return(0,s.kt)(m3n,(0,p.Z)({},u3n,n,{components:e,mdxType:"MDXLayout"}))}d3n.isMDXComponent=!0;const h3n={toc:[]},f3n="wrapper";function k3n(t){let{components:e,...n}=t;return(0,s.kt)(f3n,(0,p.Z)({},h3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}k3n.isMDXComponent=!0;const y3n={toc:[]},D3n="wrapper";function M3n(t){let{components:e,...n}=t;return(0,s.kt)(D3n,(0,p.Z)({},y3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}M3n.isMDXComponent=!0;const X3n={toc:[]},_3n="wrapper";function w3n(t){let{components:e,...n}=t;return(0,s.kt)(_3n,(0,p.Z)({},X3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}w3n.isMDXComponent=!0;const T3n={toc:[]},C3n="wrapper";function x3n(t){let{components:e,...n}=t;return(0,s.kt)(C3n,(0,p.Z)({},T3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}x3n.isMDXComponent=!0;const g3n={toc:[]},v3n="wrapper";function L3n(t){let{components:e,...n}=t;return(0,s.kt)(v3n,(0,p.Z)({},g3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}L3n.isMDXComponent=!0;const Z3n={toc:[]},b3n="wrapper";function N3n(t){let{components:e,...n}=t;return(0,s.kt)(b3n,(0,p.Z)({},Z3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}N3n.isMDXComponent=!0;const z3n={toc:[]},A3n="wrapper";function P3n(t){let{components:e,...n}=t;return(0,s.kt)(A3n,(0,p.Z)({},z3n,n,{components:e,mdxType:"MDXLayout"}))}P3n.isMDXComponent=!0;const W3n={toc:[]},R3n="wrapper";function I3n(t){let{components:e,...n}=t;return(0,s.kt)(R3n,(0,p.Z)({},W3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"SVG string to be rendered"))}I3n.isMDXComponent=!0;const S3n={toc:[]},B3n="wrapper";function G3n(t){let{components:e,...n}=t;return(0,s.kt)(B3n,(0,p.Z)({},S3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}G3n.isMDXComponent=!0;const E3n={toc:[]},O3n="wrapper";function F3n(t){let{components:e,...n}=t;return(0,s.kt)(O3n,(0,p.Z)({},E3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}F3n.isMDXComponent=!0;const U3n={toc:[]},V3n="wrapper";function q3n(t){let{components:e,...n}=t;return(0,s.kt)(V3n,(0,p.Z)({},U3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}q3n.isMDXComponent=!0;const j3n={toc:[]},Y3n="wrapper";function Q3n(t){let{components:e,...n}=t;return(0,s.kt)(Y3n,(0,p.Z)({},j3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Q3n.isMDXComponent=!0;const H3n={toc:[]},K3n="wrapper";function $3n(t){let{components:e,...n}=t;return(0,s.kt)(K3n,(0,p.Z)({},H3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}$3n.isMDXComponent=!0;const J3n={toc:[]},t7n="wrapper";function e7n(t){let{components:e,...n}=t;return(0,s.kt)(t7n,(0,p.Z)({},J3n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}e7n.isMDXComponent=!0;const n7n={toc:[]},o7n="wrapper";function p7n(t){let{components:e,...n}=t;return(0,s.kt)(o7n,(0,p.Z)({},n7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Child to wrap all SVG node"))}p7n.isMDXComponent=!0;const r7n={toc:[]},s7n="wrapper";function c7n(t){let{components:e,...n}=t;return(0,s.kt)(s7n,(0,p.Z)({},r7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}c7n.isMDXComponent=!0;const a7n={toc:[]},i7n="wrapper";function l7n(t){let{components:e,...n}=t;return(0,s.kt)(i7n,(0,p.Z)({},a7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}l7n.isMDXComponent=!0;const u7n={toc:[]},m7n="wrapper";function d7n(t){let{components:e,...n}=t;return(0,s.kt)(m7n,(0,p.Z)({},u7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}d7n.isMDXComponent=!0;const h7n={toc:[]},f7n="wrapper";function k7n(t){let{components:e,...n}=t;return(0,s.kt)(f7n,(0,p.Z)({},h7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}k7n.isMDXComponent=!0;const y7n={toc:[]},D7n="wrapper";function M7n(t){let{components:e,...n}=t;return(0,s.kt)(D7n,(0,p.Z)({},y7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}M7n.isMDXComponent=!0;const X7n={toc:[]},_7n="wrapper";function w7n(t){let{components:e,...n}=t;return(0,s.kt)(_7n,(0,p.Z)({},X7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}w7n.isMDXComponent=!0;const T7n={toc:[]},C7n="wrapper";function x7n(t){let{components:e,...n}=t;return(0,s.kt)(C7n,(0,p.Z)({},T7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}x7n.isMDXComponent=!0;const g7n={toc:[]},v7n="wrapper";function L7n(t){let{components:e,...n}=t;return(0,s.kt)(v7n,(0,p.Z)({},g7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}L7n.isMDXComponent=!0;const Z7n={toc:[]},b7n="wrapper";function N7n(t){let{components:e,...n}=t;return(0,s.kt)(b7n,(0,p.Z)({},Z7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}N7n.isMDXComponent=!0;const z7n={toc:[]},A7n="wrapper";function P7n(t){let{components:e,...n}=t;return(0,s.kt)(A7n,(0,p.Z)({},z7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}P7n.isMDXComponent=!0;const W7n={toc:[]},R7n="wrapper";function I7n(t){let{components:e,...n}=t;return(0,s.kt)(R7n,(0,p.Z)({},W7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}I7n.isMDXComponent=!0;const S7n={toc:[]},B7n="wrapper";function G7n(t){let{components:e,...n}=t;return(0,s.kt)(B7n,(0,p.Z)({},S7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData")," to convert."))}G7n.isMDXComponent=!0;const E7n={toc:[]},O7n="wrapper";function F7n(t){let{components:e,...n}=t;return(0,s.kt)(O7n,(0,p.Z)({},E7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGShapeData")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGShape"),"."))}F7n.isMDXComponent=!0;const U7n={toc:[]},V7n="wrapper";function q7n(t){let{components:e,...n}=t;return(0,s.kt)(V7n,(0,p.Z)({},U7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"SVGShapeData")," to convert."))}q7n.isMDXComponent=!0;const j7n={toc:[]},Y7n="wrapper";function Q7n(t){let{components:e,...n}=t;return(0,s.kt)(Y7n,(0,p.Z)({},j7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Q7n.isMDXComponent=!0;const H7n={toc:[]},K7n="wrapper";function $7n(t){let{components:e,...n}=t;return(0,s.kt)(K7n,(0,p.Z)({},H7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}$7n.isMDXComponent=!0;const J7n={toc:[]},t2n="wrapper";function e2n(t){let{components:e,...n}=t;return(0,s.kt)(t2n,(0,p.Z)({},J7n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}e2n.isMDXComponent=!0;const n2n={toc:[]},o2n="wrapper";function p2n(t){let{components:e,...n}=t;return(0,s.kt)(o2n,(0,p.Z)({},n2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}p2n.isMDXComponent=!0;const r2n={toc:[]},s2n="wrapper";function c2n(t){let{components:e,...n}=t;return(0,s.kt)(s2n,(0,p.Z)({},r2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}c2n.isMDXComponent=!0;const a2n={toc:[]},i2n="wrapper";function l2n(t){let{components:e,...n}=t;return(0,s.kt)(i2n,(0,p.Z)({},a2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}l2n.isMDXComponent=!0;const u2n={toc:[]},m2n="wrapper";function d2n(t){let{components:e,...n}=t;return(0,s.kt)(m2n,(0,p.Z)({},u2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}d2n.isMDXComponent=!0;const h2n={toc:[]},f2n="wrapper";function k2n(t){let{components:e,...n}=t;return(0,s.kt)(f2n,(0,p.Z)({},h2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}k2n.isMDXComponent=!0;const y2n={toc:[]},D2n="wrapper";function M2n(t){let{components:e,...n}=t;return(0,s.kt)(D2n,(0,p.Z)({},y2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}M2n.isMDXComponent=!0;const X2n={toc:[]},_2n="wrapper";function w2n(t){let{components:e,...n}=t;return(0,s.kt)(_2n,(0,p.Z)({},X2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}w2n.isMDXComponent=!0;const T2n={toc:[]},C2n="wrapper";function x2n(t){let{components:e,...n}=t;return(0,s.kt)(C2n,(0,p.Z)({},T2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}x2n.isMDXComponent=!0;const g2n={toc:[]},v2n="wrapper";function L2n(t){let{components:e,...n}=t;return(0,s.kt)(v2n,(0,p.Z)({},g2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}L2n.isMDXComponent=!0;const Z2n={toc:[]},b2n="wrapper";function N2n(t){let{components:e,...n}=t;return(0,s.kt)(b2n,(0,p.Z)({},Z2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}N2n.isMDXComponent=!0;const z2n={toc:[]},A2n="wrapper";function P2n(t){let{components:e,...n}=t;return(0,s.kt)(A2n,(0,p.Z)({},z2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}P2n.isMDXComponent=!0;const W2n={toc:[]},R2n="wrapper";function I2n(t){let{components:e,...n}=t;return(0,s.kt)(R2n,(0,p.Z)({},W2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}I2n.isMDXComponent=!0;const S2n={toc:[]},B2n="wrapper";function G2n(t){let{components:e,...n}=t;return(0,s.kt)(B2n,(0,p.Z)({},S2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}G2n.isMDXComponent=!0;const E2n={toc:[]},O2n="wrapper";function F2n(t){let{components:e,...n}=t;return(0,s.kt)(O2n,(0,p.Z)({},E2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}F2n.isMDXComponent=!0;const U2n={toc:[]},V2n="wrapper";function q2n(t){let{components:e,...n}=t;return(0,s.kt)(V2n,(0,p.Z)({},U2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}q2n.isMDXComponent=!0;const j2n={toc:[]},Y2n="wrapper";function Q2n(t){let{components:e,...n}=t;return(0,s.kt)(Y2n,(0,p.Z)({},j2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Q2n.isMDXComponent=!0;const H2n={toc:[]},K2n="wrapper";function $2n(t){let{components:e,...n}=t;return(0,s.kt)(K2n,(0,p.Z)({},H2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$2n.isMDXComponent=!0;const J2n={toc:[]},t1n="wrapper";function e1n(t){let{components:e,...n}=t;return(0,s.kt)(t1n,(0,p.Z)({},J2n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}e1n.isMDXComponent=!0;const n1n={toc:[]},o1n="wrapper";function p1n(t){let{components:e,...n}=t;return(0,s.kt)(o1n,(0,p.Z)({},n1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}p1n.isMDXComponent=!0;const r1n={toc:[]},s1n="wrapper";function c1n(t){let{components:e,...n}=t;return(0,s.kt)(s1n,(0,p.Z)({},r1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}c1n.isMDXComponent=!0;const a1n={toc:[]},i1n="wrapper";function l1n(t){let{components:e,...n}=t;return(0,s.kt)(i1n,(0,p.Z)({},a1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}l1n.isMDXComponent=!0;const u1n={toc:[]},m1n="wrapper";function d1n(t){let{components:e,...n}=t;return(0,s.kt)(m1n,(0,p.Z)({},u1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}d1n.isMDXComponent=!0;const h1n={toc:[]},f1n="wrapper";function k1n(t){let{components:e,...n}=t;return(0,s.kt)(f1n,(0,p.Z)({},h1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}k1n.isMDXComponent=!0;const y1n={toc:[]},D1n="wrapper";function M1n(t){let{components:e,...n}=t;return(0,s.kt)(D1n,(0,p.Z)({},y1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}M1n.isMDXComponent=!0;const X1n={toc:[]},_1n="wrapper";function w1n(t){let{components:e,...n}=t;return(0,s.kt)(_1n,(0,p.Z)({},X1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}w1n.isMDXComponent=!0;const T1n={toc:[]},C1n="wrapper";function x1n(t){let{components:e,...n}=t;return(0,s.kt)(C1n,(0,p.Z)({},T1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}x1n.isMDXComponent=!0;const g1n={toc:[]},v1n="wrapper";function L1n(t){let{components:e,...n}=t;return(0,s.kt)(v1n,(0,p.Z)({},g1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}L1n.isMDXComponent=!0;const Z1n={toc:[]},b1n="wrapper";function N1n(t){let{components:e,...n}=t;return(0,s.kt)(b1n,(0,p.Z)({},Z1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}N1n.isMDXComponent=!0;const z1n={toc:[]},A1n="wrapper";function P1n(t){let{components:e,...n}=t;return(0,s.kt)(A1n,(0,p.Z)({},z1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}P1n.isMDXComponent=!0;const W1n={toc:[]},R1n="wrapper";function I1n(t){let{components:e,...n}=t;return(0,s.kt)(R1n,(0,p.Z)({},W1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}I1n.isMDXComponent=!0;const S1n={toc:[]},B1n="wrapper";function G1n(t){let{components:e,...n}=t;return(0,s.kt)(B1n,(0,p.Z)({},S1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}G1n.isMDXComponent=!0;const E1n={toc:[]},O1n="wrapper";function F1n(t){let{components:e,...n}=t;return(0,s.kt)(O1n,(0,p.Z)({},E1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}F1n.isMDXComponent=!0;const U1n={toc:[]},V1n="wrapper";function q1n(t){let{components:e,...n}=t;return(0,s.kt)(V1n,(0,p.Z)({},U1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}q1n.isMDXComponent=!0;const j1n={toc:[]},Y1n="wrapper";function Q1n(t){let{components:e,...n}=t;return(0,s.kt)(Y1n,(0,p.Z)({},j1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Q1n.isMDXComponent=!0;const H1n={toc:[]},K1n="wrapper";function $1n(t){let{components:e,...n}=t;return(0,s.kt)(K1n,(0,p.Z)({},H1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}$1n.isMDXComponent=!0;const J1n={toc:[]},t8n="wrapper";function e8n(t){let{components:e,...n}=t;return(0,s.kt)(t8n,(0,p.Z)({},J1n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}e8n.isMDXComponent=!0;const n8n={toc:[]},o8n="wrapper";function p8n(t){let{components:e,...n}=t;return(0,s.kt)(o8n,(0,p.Z)({},n8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a tweening list to tween between two SVG nodes."))}p8n.isMDXComponent=!0;const r8n={toc:[]},s8n="wrapper";function c8n(t){let{components:e,...n}=t;return(0,s.kt)(s8n,(0,p.Z)({},r8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial node,"))}c8n.isMDXComponent=!0;const a8n={toc:[]},i8n="wrapper";function l8n(t){let{components:e,...n}=t;return(0,s.kt)(i8n,(0,p.Z)({},a8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The final node."))}l8n.isMDXComponent=!0;const u8n={toc:[]},m8n="wrapper";function d8n(t){let{components:e,...n}=t;return(0,s.kt)(m8n,(0,p.Z)({},u8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the tween."))}d8n.isMDXComponent=!0;const h8n={toc:[]},f8n="wrapper";function k8n(t){let{components:e,...n}=t;return(0,s.kt)(f8n,(0,p.Z)({},h8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function."))}k8n.isMDXComponent=!0;const y8n={toc:[]},D8n="wrapper";function M8n(t){let{components:e,...n}=t;return(0,s.kt)(D8n,(0,p.Z)({},y8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}M8n.isMDXComponent=!0;const X8n={toc:[]},_8n="wrapper";function w8n(t){let{components:e,...n}=t;return(0,s.kt)(_8n,(0,p.Z)({},X8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}w8n.isMDXComponent=!0;const T8n={toc:[]},C8n="wrapper";function x8n(t){let{components:e,...n}=t;return(0,s.kt)(C8n,(0,p.Z)({},T8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get all SVG nodes with the given id."))}x8n.isMDXComponent=!0;const g8n={toc:[]},v8n="wrapper";function L8n(t){let{components:e,...n}=t;return(0,s.kt)(v8n,(0,p.Z)({},g8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An id to query."))}L8n.isMDXComponent=!0;const Z8n={toc:[]},b8n="wrapper";function N8n(t){let{components:e,...n}=t;return(0,s.kt)(b8n,(0,p.Z)({},Z8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}N8n.isMDXComponent=!0;const z8n={toc:[]},A8n="wrapper";function P8n(t){let{components:e,...n}=t;return(0,s.kt)(A8n,(0,p.Z)({},z8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}P8n.isMDXComponent=!0;const W8n={toc:[]},R8n="wrapper";function I8n(t){let{components:e,...n}=t;return(0,s.kt)(R8n,(0,p.Z)({},W8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}I8n.isMDXComponent=!0;const S8n={toc:[]},B8n="wrapper";function G8n(t){let{components:e,...n}=t;return(0,s.kt)(B8n,(0,p.Z)({},S8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}G8n.isMDXComponent=!0;const E8n={toc:[]},O8n="wrapper";function F8n(t){let{components:e,...n}=t;return(0,s.kt)(O8n,(0,p.Z)({},E8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}F8n.isMDXComponent=!0;const U8n={toc:[]},V8n="wrapper";function q8n(t){let{components:e,...n}=t;return(0,s.kt)(V8n,(0,p.Z)({},U8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}q8n.isMDXComponent=!0;const j8n={toc:[]},Y8n="wrapper";function Q8n(t){let{components:e,...n}=t;return(0,s.kt)(Y8n,(0,p.Z)({},j8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Q8n.isMDXComponent=!0;const H8n={toc:[]},K8n="wrapper";function $8n(t){let{components:e,...n}=t;return(0,s.kt)(K8n,(0,p.Z)({},H8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}$8n.isMDXComponent=!0;const J8n={toc:[]},t5n="wrapper";function e5n(t){let{components:e,...n}=t;return(0,s.kt)(t5n,(0,p.Z)({},J8n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}e5n.isMDXComponent=!0;const n5n={toc:[]},o5n="wrapper";function p5n(t){let{components:e,...n}=t;return(0,s.kt)(o5n,(0,p.Z)({},n5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}p5n.isMDXComponent=!0;const r5n={toc:[]},s5n="wrapper";function c5n(t){let{components:e,...n}=t;return(0,s.kt)(s5n,(0,p.Z)({},r5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}c5n.isMDXComponent=!0;const a5n={toc:[]},i5n="wrapper";function l5n(t){let{components:e,...n}=t;return(0,s.kt)(i5n,(0,p.Z)({},a5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}l5n.isMDXComponent=!0;const u5n={toc:[]},m5n="wrapper";function d5n(t){let{components:e,...n}=t;return(0,s.kt)(m5n,(0,p.Z)({},u5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}d5n.isMDXComponent=!0;const h5n={toc:[]},f5n="wrapper";function k5n(t){let{components:e,...n}=t;return(0,s.kt)(f5n,(0,p.Z)({},h5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}k5n.isMDXComponent=!0;const y5n={toc:[]},D5n="wrapper";function M5n(t){let{components:e,...n}=t;return(0,s.kt)(D5n,(0,p.Z)({},y5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}M5n.isMDXComponent=!0;const X5n={toc:[]},_5n="wrapper";function w5n(t){let{components:e,...n}=t;return(0,s.kt)(_5n,(0,p.Z)({},X5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}w5n.isMDXComponent=!0;const T5n={toc:[]},C5n="wrapper";function x5n(t){let{components:e,...n}=t;return(0,s.kt)(C5n,(0,p.Z)({},T5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}x5n.isMDXComponent=!0;const g5n={toc:[]},v5n="wrapper";function L5n(t){let{components:e,...n}=t;return(0,s.kt)(v5n,(0,p.Z)({},g5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}L5n.isMDXComponent=!0;const Z5n={toc:[]},b5n="wrapper";function N5n(t){let{components:e,...n}=t;return(0,s.kt)(b5n,(0,p.Z)({},Z5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}N5n.isMDXComponent=!0;const z5n={toc:[]},A5n="wrapper";function P5n(t){let{components:e,...n}=t;return(0,s.kt)(A5n,(0,p.Z)({},z5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}P5n.isMDXComponent=!0;const W5n={toc:[]},R5n="wrapper";function I5n(t){let{components:e,...n}=t;return(0,s.kt)(R5n,(0,p.Z)({},W5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}I5n.isMDXComponent=!0;const S5n={toc:[]},B5n="wrapper";function G5n(t){let{components:e,...n}=t;return(0,s.kt)(B5n,(0,p.Z)({},S5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}G5n.isMDXComponent=!0;const E5n={toc:[]},O5n="wrapper";function F5n(t){let{components:e,...n}=t;return(0,s.kt)(O5n,(0,p.Z)({},E5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}F5n.isMDXComponent=!0;const U5n={toc:[]},V5n="wrapper";function q5n(t){let{components:e,...n}=t;return(0,s.kt)(V5n,(0,p.Z)({},U5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}q5n.isMDXComponent=!0;const j5n={toc:[]},Y5n="wrapper";function Q5n(t){let{components:e,...n}=t;return(0,s.kt)(Y5n,(0,p.Z)({},j5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Q5n.isMDXComponent=!0;const H5n={toc:[]},K5n="wrapper";function $5n(t){let{components:e,...n}=t;return(0,s.kt)(K5n,(0,p.Z)({},H5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}$5n.isMDXComponent=!0;const J5n={toc:[]},t9n="wrapper";function e9n(t){let{components:e,...n}=t;return(0,s.kt)(t9n,(0,p.Z)({},J5n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}e9n.isMDXComponent=!0;const n9n={toc:[]},o9n="wrapper";function p9n(t){let{components:e,...n}=t;return(0,s.kt)(o9n,(0,p.Z)({},n9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}p9n.isMDXComponent=!0;const r9n={toc:[]},s9n="wrapper";function c9n(t){let{components:e,...n}=t;return(0,s.kt)(s9n,(0,p.Z)({},r9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}c9n.isMDXComponent=!0;const a9n={toc:[]},i9n="wrapper";function l9n(t){let{components:e,...n}=t;return(0,s.kt)(i9n,(0,p.Z)({},a9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}l9n.isMDXComponent=!0;const u9n={toc:[]},m9n="wrapper";function d9n(t){let{components:e,...n}=t;return(0,s.kt)(m9n,(0,p.Z)({},u9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}d9n.isMDXComponent=!0;const h9n={toc:[]},f9n="wrapper";function k9n(t){let{components:e,...n}=t;return(0,s.kt)(f9n,(0,p.Z)({},h9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}k9n.isMDXComponent=!0;const y9n={toc:[]},D9n="wrapper";function M9n(t){let{components:e,...n}=t;return(0,s.kt)(D9n,(0,p.Z)({},y9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}M9n.isMDXComponent=!0;const X9n={toc:[]},_9n="wrapper";function w9n(t){let{components:e,...n}=t;return(0,s.kt)(_9n,(0,p.Z)({},X9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}w9n.isMDXComponent=!0;const T9n={toc:[]},C9n="wrapper";function x9n(t){let{components:e,...n}=t;return(0,s.kt)(C9n,(0,p.Z)({},T9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}x9n.isMDXComponent=!0;const g9n={toc:[]},v9n="wrapper";function L9n(t){let{components:e,...n}=t;return(0,s.kt)(v9n,(0,p.Z)({},g9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}L9n.isMDXComponent=!0;const Z9n={toc:[]},b9n="wrapper";function N9n(t){let{components:e,...n}=t;return(0,s.kt)(b9n,(0,p.Z)({},Z9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}N9n.isMDXComponent=!0;const z9n={toc:[]},A9n="wrapper";function P9n(t){let{components:e,...n}=t;return(0,s.kt)(A9n,(0,p.Z)({},z9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}P9n.isMDXComponent=!0;const W9n={toc:[]},R9n="wrapper";function I9n(t){let{components:e,...n}=t;return(0,s.kt)(R9n,(0,p.Z)({},W9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}I9n.isMDXComponent=!0;const S9n={toc:[]},B9n="wrapper";function G9n(t){let{components:e,...n}=t;return(0,s.kt)(B9n,(0,p.Z)({},S9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}G9n.isMDXComponent=!0;const E9n={toc:[]},O9n="wrapper";function F9n(t){let{components:e,...n}=t;return(0,s.kt)(O9n,(0,p.Z)({},E9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}F9n.isMDXComponent=!0;const U9n={toc:[]},V9n="wrapper";function q9n(t){let{components:e,...n}=t;return(0,s.kt)(V9n,(0,p.Z)({},U9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}q9n.isMDXComponent=!0;const j9n={toc:[]},Y9n="wrapper";function Q9n(t){let{components:e,...n}=t;return(0,s.kt)(Y9n,(0,p.Z)({},j9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Q9n.isMDXComponent=!0;const H9n={toc:[]},K9n="wrapper";function $9n(t){let{components:e,...n}=t;return(0,s.kt)(K9n,(0,p.Z)({},H9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}$9n.isMDXComponent=!0;const J9n={toc:[]},tto="wrapper";function eto(t){let{components:e,...n}=t;return(0,s.kt)(tto,(0,p.Z)({},J9n,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert an SVG string to ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocument"),"."))}eto.isMDXComponent=!0;const nto={toc:[]},oto="wrapper";function pto(t){let{components:e,...n}=t;return(0,s.kt)(oto,(0,p.Z)({},nto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An SVG string to be parsed."))}pto.isMDXComponent=!0;const rto={toc:[]},sto="wrapper";function cto(t){let{components:e,...n}=t;return(0,s.kt)(sto,(0,p.Z)({},rto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}cto.isMDXComponent=!0;const ato={toc:[]},ito="wrapper";function lto(t){let{components:e,...n}=t;return(0,s.kt)(ito,(0,p.Z)({},ato,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}lto.isMDXComponent=!0;const uto={toc:[]},mto="wrapper";function dto(t){let{components:e,...n}=t;return(0,s.kt)(mto,(0,p.Z)({},uto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}dto.isMDXComponent=!0;const hto={toc:[]},fto="wrapper";function kto(t){let{components:e,...n}=t;return(0,s.kt)(fto,(0,p.Z)({},hto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}kto.isMDXComponent=!0;const yto={toc:[]},Dto="wrapper";function Mto(t){let{components:e,...n}=t;return(0,s.kt)(Dto,(0,p.Z)({},yto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Mto.isMDXComponent=!0;const Xto={toc:[]},_to="wrapper";function wto(t){let{components:e,...n}=t;return(0,s.kt)(_to,(0,p.Z)({},Xto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}wto.isMDXComponent=!0;const Tto={toc:[]},Cto="wrapper";function xto(t){let{components:e,...n}=t;return(0,s.kt)(Cto,(0,p.Z)({},Tto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}xto.isMDXComponent=!0;const gto={toc:[]},vto="wrapper";function Lto(t){let{components:e,...n}=t;return(0,s.kt)(vto,(0,p.Z)({},gto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Lto.isMDXComponent=!0;const Zto={toc:[]},bto="wrapper";function Nto(t){let{components:e,...n}=t;return(0,s.kt)(bto,(0,p.Z)({},Zto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Nto.isMDXComponent=!0;const zto={toc:[]},Ato="wrapper";function Pto(t){let{components:e,...n}=t;return(0,s.kt)(Ato,(0,p.Z)({},zto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Pto.isMDXComponent=!0;const Wto={toc:[]},Rto="wrapper";function Ito(t){let{components:e,...n}=t;return(0,s.kt)(Rto,(0,p.Z)({},Wto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}Ito.isMDXComponent=!0;const Sto={toc:[]},Bto="wrapper";function Gto(t){let{components:e,...n}=t;return(0,s.kt)(Bto,(0,p.Z)({},Sto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Gto.isMDXComponent=!0;const Eto={toc:[]},Oto="wrapper";function Fto(t){let{components:e,...n}=t;return(0,s.kt)(Oto,(0,p.Z)({},Eto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Fto.isMDXComponent=!0;const Uto={toc:[]},Vto="wrapper";function qto(t){let{components:e,...n}=t;return(0,s.kt)(Vto,(0,p.Z)({},Uto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}qto.isMDXComponent=!0;const jto={toc:[]},Yto="wrapper";function Qto(t){let{components:e,...n}=t;return(0,s.kt)(Yto,(0,p.Z)({},jto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Qto.isMDXComponent=!0;const Hto={toc:[]},Kto="wrapper";function $to(t){let{components:e,...n}=t;return(0,s.kt)(Kto,(0,p.Z)({},Hto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}$to.isMDXComponent=!0;const Jto={toc:[]},teo="wrapper";function eeo(t){let{components:e,...n}=t;return(0,s.kt)(teo,(0,p.Z)({},Jto,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}eeo.isMDXComponent=!0;const neo={toc:[]},oeo="wrapper";function peo(t){let{components:e,...n}=t;return(0,s.kt)(oeo,(0,p.Z)({},neo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}peo.isMDXComponent=!0;const reo={toc:[]},seo="wrapper";function ceo(t){let{components:e,...n}=t;return(0,s.kt)(seo,(0,p.Z)({},reo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}ceo.isMDXComponent=!0;const aeo={toc:[]},ieo="wrapper";function leo(t){let{components:e,...n}=t;return(0,s.kt)(ieo,(0,p.Z)({},aeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}leo.isMDXComponent=!0;const ueo={toc:[]},meo="wrapper";function deo(t){let{components:e,...n}=t;return(0,s.kt)(meo,(0,p.Z)({},ueo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}deo.isMDXComponent=!0;const heo={toc:[]},feo="wrapper";function keo(t){let{components:e,...n}=t;return(0,s.kt)(feo,(0,p.Z)({},heo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}keo.isMDXComponent=!0;const yeo={toc:[]},Deo="wrapper";function Meo(t){let{components:e,...n}=t;return(0,s.kt)(Deo,(0,p.Z)({},yeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Meo.isMDXComponent=!0;const Xeo={toc:[]},_eo="wrapper";function weo(t){let{components:e,...n}=t;return(0,s.kt)(_eo,(0,p.Z)({},Xeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}weo.isMDXComponent=!0;const Teo={toc:[]},Ceo="wrapper";function xeo(t){let{components:e,...n}=t;return(0,s.kt)(Ceo,(0,p.Z)({},Teo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}xeo.isMDXComponent=!0;const geo={toc:[]},veo="wrapper";function Leo(t){let{components:e,...n}=t;return(0,s.kt)(veo,(0,p.Z)({},geo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Leo.isMDXComponent=!0;const Zeo={toc:[]},beo="wrapper";function Neo(t){let{components:e,...n}=t;return(0,s.kt)(beo,(0,p.Z)({},Zeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}Neo.isMDXComponent=!0;const zeo={toc:[]},Aeo="wrapper";function Peo(t){let{components:e,...n}=t;return(0,s.kt)(Aeo,(0,p.Z)({},zeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Peo.isMDXComponent=!0;const Weo={toc:[]},Reo="wrapper";function Ieo(t){let{components:e,...n}=t;return(0,s.kt)(Reo,(0,p.Z)({},Weo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Ieo.isMDXComponent=!0;const Seo={toc:[]},Beo="wrapper";function Geo(t){let{components:e,...n}=t;return(0,s.kt)(Beo,(0,p.Z)({},Seo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Geo.isMDXComponent=!0;const Eeo={toc:[]},Oeo="wrapper";function Feo(t){let{components:e,...n}=t;return(0,s.kt)(Oeo,(0,p.Z)({},Eeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Feo.isMDXComponent=!0;const Ueo={toc:[]},Veo="wrapper";function qeo(t){let{components:e,...n}=t;return(0,s.kt)(Veo,(0,p.Z)({},Ueo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}qeo.isMDXComponent=!0;const jeo={toc:[]},Yeo="wrapper";function Qeo(t){let{components:e,...n}=t;return(0,s.kt)(Yeo,(0,p.Z)({},jeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Qeo.isMDXComponent=!0;const Heo={toc:[]},Keo="wrapper";function $eo(t){let{components:e,...n}=t;return(0,s.kt)(Keo,(0,p.Z)({},Heo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}$eo.isMDXComponent=!0;const Jeo={toc:[]},tno="wrapper";function eno(t){let{components:e,...n}=t;return(0,s.kt)(tno,(0,p.Z)({},Jeo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}eno.isMDXComponent=!0;const nno={toc:[]},ono="wrapper";function pno(t){let{components:e,...n}=t;return(0,s.kt)(ono,(0,p.Z)({},nno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}pno.isMDXComponent=!0;const rno={toc:[]},sno="wrapper";function cno(t){let{components:e,...n}=t;return(0,s.kt)(sno,(0,p.Z)({},rno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVG#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}cno.isMDXComponent=!0;const ano={toc:[]},ino="wrapper";function lno(t){let{components:e,...n}=t;return(0,s.kt)(ino,(0,p.Z)({},ano,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}lno.isMDXComponent=!0;const uno={toc:[]},mno="wrapper";function dno(t){let{components:e,...n}=t;return(0,s.kt)(mno,(0,p.Z)({},uno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}dno.isMDXComponent=!0;const hno={toc:[]},fno="wrapper";function kno(t){let{components:e,...n}=t;return(0,s.kt)(fno,(0,p.Z)({},hno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}kno.isMDXComponent=!0;const yno={toc:[]},Dno="wrapper";function Mno(t){let{components:e,...n}=t;return(0,s.kt)(Dno,(0,p.Z)({},yno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Mno.isMDXComponent=!0;const Xno={toc:[]},_no="wrapper";function wno(t){let{components:e,...n}=t;return(0,s.kt)(_no,(0,p.Z)({},Xno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}wno.isMDXComponent=!0;const Tno={toc:[]},Cno="wrapper";function xno(t){let{components:e,...n}=t;return(0,s.kt)(Cno,(0,p.Z)({},Tno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}xno.isMDXComponent=!0;const gno={toc:[]},vno="wrapper";function Lno(t){let{components:e,...n}=t;return(0,s.kt)(vno,(0,p.Z)({},gno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"MotionCanvas Shape properties"))}Lno.isMDXComponent=!0;const Zno={toc:[]},bno="wrapper";function Nno(t){let{components:e,...n}=t;return(0,s.kt)(bno,(0,p.Z)({},Zno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get position, rotation and scale from Matrix transformation as Shape properties"))}Nno.isMDXComponent=!0;const zno={toc:[]},Ano="wrapper";function Pno(t){let{components:e,...n}=t;return(0,s.kt)(Ano,(0,p.Z)({},zno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Matrix transformation"))}Pno.isMDXComponent=!0;const Wno={toc:[]},Rno="wrapper";function Ino(t){let{components:e,...n}=t;return(0,s.kt)(Rno,(0,p.Z)({},Wno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData")," that can be used to build SVGDocument."))}Ino.isMDXComponent=!0;const Sno={toc:[]},Bno="wrapper";function Gno(t){let{components:e,...n}=t;return(0,s.kt)(Bno,(0,p.Z)({},Sno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse an SVG string as ",(0,s.kt)("inlineCode",{parentName:"p"},"SVGDocumentData"),"."))}Gno.isMDXComponent=!0;const Eno={toc:[]},Ono="wrapper";function Fno(t){let{components:e,...n}=t;return(0,s.kt)(Ono,(0,p.Z)({},Eno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"And SVG string to be parsed."))}Fno.isMDXComponent=!0;const Uno={toc:[]},Vno="wrapper";function qno(t){let{components:e,...n}=t;return(0,s.kt)(Vno,(0,p.Z)({},Uno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}qno.isMDXComponent=!0;const jno={toc:[]},Yno="wrapper";function Qno(t){let{components:e,...n}=t;return(0,s.kt)(Yno,(0,p.Z)({},jno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}Qno.isMDXComponent=!0;const Hno={toc:[]},Kno="wrapper";function $no(t){let{components:e,...n}=t;return(0,s.kt)(Kno,(0,p.Z)({},Hno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}$no.isMDXComponent=!0;const Jno={toc:[]},too="wrapper";function eoo(t){let{components:e,...n}=t;return(0,s.kt)(too,(0,p.Z)({},Jno,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}eoo.isMDXComponent=!0;const noo={toc:[]},ooo="wrapper";function poo(t){let{components:e,...n}=t;return(0,s.kt)(ooo,(0,p.Z)({},noo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}poo.isMDXComponent=!0;const roo={toc:[]},soo="wrapper";function coo(t){let{components:e,...n}=t;return(0,s.kt)(soo,(0,p.Z)({},roo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}coo.isMDXComponent=!0;const aoo={toc:[]},ioo="wrapper";function loo(t){let{components:e,...n}=t;return(0,s.kt)(ioo,(0,p.Z)({},aoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}loo.isMDXComponent=!0;const uoo={toc:[]},moo="wrapper";function doo(t){let{components:e,...n}=t;return(0,s.kt)(moo,(0,p.Z)({},uoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}doo.isMDXComponent=!0;const hoo={toc:[]},foo="wrapper";function koo(t){let{components:e,...n}=t;return(0,s.kt)(foo,(0,p.Z)({},hoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}koo.isMDXComponent=!0;const yoo={toc:[]},Doo="wrapper";function Moo(t){let{components:e,...n}=t;return(0,s.kt)(Doo,(0,p.Z)({},yoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Moo.isMDXComponent=!0;const Xoo={toc:[]},_oo="wrapper";function woo(t){let{components:e,...n}=t;return(0,s.kt)(_oo,(0,p.Z)({},Xoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}woo.isMDXComponent=!0;const Too={toc:[]},Coo="wrapper";function xoo(t){let{components:e,...n}=t;return(0,s.kt)(Coo,(0,p.Z)({},Too,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}xoo.isMDXComponent=!0;const goo={toc:[]},voo="wrapper";function Loo(t){let{components:e,...n}=t;return(0,s.kt)(voo,(0,p.Z)({},goo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Loo.isMDXComponent=!0;const Zoo={toc:[]},boo="wrapper";function Noo(t){let{components:e,...n}=t;return(0,s.kt)(boo,(0,p.Z)({},Zoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Noo.isMDXComponent=!0;const zoo={toc:[]},Aoo="wrapper";function Poo(t){let{components:e,...n}=t;return(0,s.kt)(Aoo,(0,p.Z)({},zoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}Poo.isMDXComponent=!0;const Woo={toc:[]},Roo="wrapper";function Ioo(t){let{components:e,...n}=t;return(0,s.kt)(Roo,(0,p.Z)({},Woo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Ioo.isMDXComponent=!0;const Soo={toc:[]},Boo="wrapper";function Goo(t){let{components:e,...n}=t;return(0,s.kt)(Boo,(0,p.Z)({},Soo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Goo.isMDXComponent=!0;const Eoo={toc:[]},Ooo="wrapper";function Foo(t){let{components:e,...n}=t;return(0,s.kt)(Ooo,(0,p.Z)({},Eoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Foo.isMDXComponent=!0;const Uoo={toc:[]},Voo="wrapper";function qoo(t){let{components:e,...n}=t;return(0,s.kt)(Voo,(0,p.Z)({},Uoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qoo.isMDXComponent=!0;const joo={toc:[]},Yoo="wrapper";function Qoo(t){let{components:e,...n}=t;return(0,s.kt)(Yoo,(0,p.Z)({},joo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Qoo.isMDXComponent=!0;const Hoo={toc:[]},Koo="wrapper";function $oo(t){let{components:e,...n}=t;return(0,s.kt)(Koo,(0,p.Z)({},Hoo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}$oo.isMDXComponent=!0;const Joo={toc:[]},tpo="wrapper";function epo(t){let{components:e,...n}=t;return(0,s.kt)(tpo,(0,p.Z)({},Joo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}epo.isMDXComponent=!0;const npo={toc:[]},opo="wrapper";function ppo(t){let{components:e,...n}=t;return(0,s.kt)(opo,(0,p.Z)({},npo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ppo.isMDXComponent=!0;const rpo={toc:[]},spo="wrapper";function cpo(t){let{components:e,...n}=t;return(0,s.kt)(spo,(0,p.Z)({},rpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}cpo.isMDXComponent=!0;const apo={toc:[]},ipo="wrapper";function lpo(t){let{components:e,...n}=t;return(0,s.kt)(ipo,(0,p.Z)({},apo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}lpo.isMDXComponent=!0;const upo={toc:[]},mpo="wrapper";function dpo(t){let{components:e,...n}=t;return(0,s.kt)(mpo,(0,p.Z)({},upo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}dpo.isMDXComponent=!0;const hpo={toc:[]},fpo="wrapper";function kpo(t){let{components:e,...n}=t;return(0,s.kt)(fpo,(0,p.Z)({},hpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}kpo.isMDXComponent=!0;const ypo={toc:[]},Dpo="wrapper";function Mpo(t){let{components:e,...n}=t;return(0,s.kt)(Dpo,(0,p.Z)({},ypo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Mpo.isMDXComponent=!0;const Xpo={toc:[]},_po="wrapper";function wpo(t){let{components:e,...n}=t;return(0,s.kt)(_po,(0,p.Z)({},Xpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}wpo.isMDXComponent=!0;const Tpo={toc:[]},Cpo="wrapper";function xpo(t){let{components:e,...n}=t;return(0,s.kt)(Cpo,(0,p.Z)({},Tpo,n,{components:e,mdxType:"MDXLayout"}))}xpo.isMDXComponent=!0;const gpo={toc:[]},vpo="wrapper";function Lpo(t){let{components:e,...n}=t;return(0,s.kt)(vpo,(0,p.Z)({},gpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Lpo.isMDXComponent=!0;const Zpo={toc:[]},bpo="wrapper";function Npo(t){let{components:e,...n}=t;return(0,s.kt)(bpo,(0,p.Z)({},Zpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Npo.isMDXComponent=!0;const zpo={toc:[]},Apo="wrapper";function Ppo(t){let{components:e,...n}=t;return(0,s.kt)(Apo,(0,p.Z)({},zpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}Ppo.isMDXComponent=!0;const Wpo={toc:[]},Rpo="wrapper";function Ipo(t){let{components:e,...n}=t;return(0,s.kt)(Rpo,(0,p.Z)({},Wpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Ipo.isMDXComponent=!0;const Spo={toc:[]},Bpo="wrapper";function Gpo(t){let{components:e,...n}=t;return(0,s.kt)(Bpo,(0,p.Z)({},Spo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Gpo.isMDXComponent=!0;const Epo={toc:[]},Opo="wrapper";function Fpo(t){let{components:e,...n}=t;return(0,s.kt)(Opo,(0,p.Z)({},Epo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Fpo.isMDXComponent=!0;const Upo={toc:[]},Vpo="wrapper";function qpo(t){let{components:e,...n}=t;return(0,s.kt)(Vpo,(0,p.Z)({},Upo,n,{components:e,mdxType:"MDXLayout"}))}qpo.isMDXComponent=!0;const jpo={toc:[]},Ypo="wrapper";function Qpo(t){let{components:e,...n}=t;return(0,s.kt)(Ypo,(0,p.Z)({},jpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}Qpo.isMDXComponent=!0;const Hpo={toc:[]},Kpo="wrapper";function $po(t){let{components:e,...n}=t;return(0,s.kt)(Kpo,(0,p.Z)({},Hpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}$po.isMDXComponent=!0;const Jpo={toc:[]},tro="wrapper";function ero(t){let{components:e,...n}=t;return(0,s.kt)(tro,(0,p.Z)({},Jpo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}ero.isMDXComponent=!0;const nro={toc:[]},oro="wrapper";function pro(t){let{components:e,...n}=t;return(0,s.kt)(oro,(0,p.Z)({},nro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}pro.isMDXComponent=!0;const rro={toc:[]},sro="wrapper";function cro(t){let{components:e,...n}=t;return(0,s.kt)(sro,(0,p.Z)({},rro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}cro.isMDXComponent=!0;const aro={toc:[]},iro="wrapper";function lro(t){let{components:e,...n}=t;return(0,s.kt)(iro,(0,p.Z)({},aro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}lro.isMDXComponent=!0;const uro={toc:[]},mro="wrapper";function dro(t){let{components:e,...n}=t;return(0,s.kt)(mro,(0,p.Z)({},uro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}dro.isMDXComponent=!0;const hro={toc:[]},fro="wrapper";function kro(t){let{components:e,...n}=t;return(0,s.kt)(fro,(0,p.Z)({},hro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}kro.isMDXComponent=!0;const yro={toc:[]},Dro="wrapper";function Mro(t){let{components:e,...n}=t;return(0,s.kt)(Dro,(0,p.Z)({},yro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Mro.isMDXComponent=!0;const Xro={toc:[]},_ro="wrapper";function wro(t){let{components:e,...n}=t;return(0,s.kt)(_ro,(0,p.Z)({},Xro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}wro.isMDXComponent=!0;const Tro={toc:[]},Cro="wrapper";function xro(t){let{components:e,...n}=t;return(0,s.kt)(Cro,(0,p.Z)({},Tro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}xro.isMDXComponent=!0;const gro={toc:[]},vro="wrapper";function Lro(t){let{components:e,...n}=t;return(0,s.kt)(vro,(0,p.Z)({},gro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Lro.isMDXComponent=!0;const Zro={toc:[]},bro="wrapper";function Nro(t){let{components:e,...n}=t;return(0,s.kt)(bro,(0,p.Z)({},Zro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Nro.isMDXComponent=!0;const zro={toc:[]},Aro="wrapper";function Pro(t){let{components:e,...n}=t;return(0,s.kt)(Aro,(0,p.Z)({},zro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Pro.isMDXComponent=!0;const Wro={toc:[]},Rro="wrapper";function Iro(t){let{components:e,...n}=t;return(0,s.kt)(Rro,(0,p.Z)({},Wro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Iro.isMDXComponent=!0;const Sro={toc:[]},Bro="wrapper";function Gro(t){let{components:e,...n}=t;return(0,s.kt)(Bro,(0,p.Z)({},Sro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Gro.isMDXComponent=!0;const Ero={toc:[]},Oro="wrapper";function Fro(t){let{components:e,...n}=t;return(0,s.kt)(Oro,(0,p.Z)({},Ero,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}Fro.isMDXComponent=!0;const Uro={toc:[]},Vro="wrapper";function qro(t){let{components:e,...n}=t;return(0,s.kt)(Vro,(0,p.Z)({},Uro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}qro.isMDXComponent=!0;const jro={toc:[]},Yro="wrapper";function Qro(t){let{components:e,...n}=t;return(0,s.kt)(Yro,(0,p.Z)({},jro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}Qro.isMDXComponent=!0;const Hro={toc:[]},Kro="wrapper";function $ro(t){let{components:e,...n}=t;return(0,s.kt)(Kro,(0,p.Z)({},Hro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}$ro.isMDXComponent=!0;const Jro={toc:[]},tso="wrapper";function eso(t){let{components:e,...n}=t;return(0,s.kt)(tso,(0,p.Z)({},Jro,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}eso.isMDXComponent=!0;const nso={toc:[]},oso="wrapper";function pso(t){let{components:e,...n}=t;return(0,s.kt)(oso,(0,p.Z)({},nso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}pso.isMDXComponent=!0;const rso={toc:[]},sso="wrapper";function cso(t){let{components:e,...n}=t;return(0,s.kt)(sso,(0,p.Z)({},rso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}cso.isMDXComponent=!0;const aso={toc:[]},iso="wrapper";function lso(t){let{components:e,...n}=t;return(0,s.kt)(iso,(0,p.Z)({},aso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}lso.isMDXComponent=!0;const uso={toc:[]},mso="wrapper";function dso(t){let{components:e,...n}=t;return(0,s.kt)(mso,(0,p.Z)({},uso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}dso.isMDXComponent=!0;const hso={toc:[]},fso="wrapper";function kso(t){let{components:e,...n}=t;return(0,s.kt)(fso,(0,p.Z)({},hso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}kso.isMDXComponent=!0;const yso={toc:[]},Dso="wrapper";function Mso(t){let{components:e,...n}=t;return(0,s.kt)(Dso,(0,p.Z)({},yso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Mso.isMDXComponent=!0;const Xso={toc:[]},_so="wrapper";function wso(t){let{components:e,...n}=t;return(0,s.kt)(_so,(0,p.Z)({},Xso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}wso.isMDXComponent=!0;const Tso={toc:[]},Cso="wrapper";function xso(t){let{components:e,...n}=t;return(0,s.kt)(Cso,(0,p.Z)({},Tso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}xso.isMDXComponent=!0;const gso={toc:[]},vso="wrapper";function Lso(t){let{components:e,...n}=t;return(0,s.kt)(vso,(0,p.Z)({},gso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}Lso.isMDXComponent=!0;const Zso={toc:[]},bso="wrapper";function Nso(t){let{components:e,...n}=t;return(0,s.kt)(bso,(0,p.Z)({},Zso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Nso.isMDXComponent=!0;const zso={toc:[]},Aso="wrapper";function Pso(t){let{components:e,...n}=t;return(0,s.kt)(Aso,(0,p.Z)({},zso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}Pso.isMDXComponent=!0;const Wso={toc:[]},Rso="wrapper";function Iso(t){let{components:e,...n}=t;return(0,s.kt)(Rso,(0,p.Z)({},Wso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Iso.isMDXComponent=!0;const Sso={toc:[]},Bso="wrapper";function Gso(t){let{components:e,...n}=t;return(0,s.kt)(Bso,(0,p.Z)({},Sso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Gso.isMDXComponent=!0;const Eso={toc:[]},Oso="wrapper";function Fso(t){let{components:e,...n}=t;return(0,s.kt)(Oso,(0,p.Z)({},Eso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}Fso.isMDXComponent=!0;const Uso={toc:[]},Vso="wrapper";function qso(t){let{components:e,...n}=t;return(0,s.kt)(Vso,(0,p.Z)({},Uso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}qso.isMDXComponent=!0;const jso={toc:[]},Yso="wrapper";function Qso(t){let{components:e,...n}=t;return(0,s.kt)(Yso,(0,p.Z)({},jso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}Qso.isMDXComponent=!0;const Hso={toc:[]},Kso="wrapper";function $so(t){let{components:e,...n}=t;return(0,s.kt)(Kso,(0,p.Z)({},Hso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}$so.isMDXComponent=!0;const Jso={toc:[]},tco="wrapper";function eco(t){let{components:e,...n}=t;return(0,s.kt)(tco,(0,p.Z)({},Jso,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}eco.isMDXComponent=!0;const nco={toc:[]},oco="wrapper";function pco(t){let{components:e,...n}=t;return(0,s.kt)(oco,(0,p.Z)({},nco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}pco.isMDXComponent=!0;const rco={toc:[]},sco="wrapper";function cco(t){let{components:e,...n}=t;return(0,s.kt)(sco,(0,p.Z)({},rco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cco.isMDXComponent=!0;const aco={toc:[]},ico="wrapper";function lco(t){let{components:e,...n}=t;return(0,s.kt)(ico,(0,p.Z)({},aco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}lco.isMDXComponent=!0;const uco={toc:[]},mco="wrapper";function dco(t){let{components:e,...n}=t;return(0,s.kt)(mco,(0,p.Z)({},uco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dco.isMDXComponent=!0;const hco={toc:[]},fco="wrapper";function kco(t){let{components:e,...n}=t;return(0,s.kt)(fco,(0,p.Z)({},hco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}kco.isMDXComponent=!0;const yco={toc:[]},Dco="wrapper";function Mco(t){let{components:e,...n}=t;return(0,s.kt)(Dco,(0,p.Z)({},yco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Mco.isMDXComponent=!0;const Xco={toc:[]},_co="wrapper";function wco(t){let{components:e,...n}=t;return(0,s.kt)(_co,(0,p.Z)({},Xco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}wco.isMDXComponent=!0;const Tco={toc:[]},Cco="wrapper";function xco(t){let{components:e,...n}=t;return(0,s.kt)(Cco,(0,p.Z)({},Tco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}xco.isMDXComponent=!0;const gco={toc:[]},vco="wrapper";function Lco(t){let{components:e,...n}=t;return(0,s.kt)(vco,(0,p.Z)({},gco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Lco.isMDXComponent=!0;const Zco={toc:[]},bco="wrapper";function Nco(t){let{components:e,...n}=t;return(0,s.kt)(bco,(0,p.Z)({},Zco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Nco.isMDXComponent=!0;const zco={toc:[]},Aco="wrapper";function Pco(t){let{components:e,...n}=t;return(0,s.kt)(Aco,(0,p.Z)({},zco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Pco.isMDXComponent=!0;const Wco={toc:[]},Rco="wrapper";function Ico(t){let{components:e,...n}=t;return(0,s.kt)(Rco,(0,p.Z)({},Wco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Ico.isMDXComponent=!0;const Sco={toc:[]},Bco="wrapper";function Gco(t){let{components:e,...n}=t;return(0,s.kt)(Bco,(0,p.Z)({},Sco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}Gco.isMDXComponent=!0;const Eco={toc:[]},Oco="wrapper";function Fco(t){let{components:e,...n}=t;return(0,s.kt)(Oco,(0,p.Z)({},Eco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}Fco.isMDXComponent=!0;const Uco={toc:[]},Vco="wrapper";function qco(t){let{components:e,...n}=t;return(0,s.kt)(Vco,(0,p.Z)({},Uco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}qco.isMDXComponent=!0;const jco={toc:[]},Yco="wrapper";function Qco(t){let{components:e,...n}=t;return(0,s.kt)(Yco,(0,p.Z)({},jco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}Qco.isMDXComponent=!0;const Hco={toc:[]},Kco="wrapper";function $co(t){let{components:e,...n}=t;return(0,s.kt)(Kco,(0,p.Z)({},Hco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}$co.isMDXComponent=!0;const Jco={toc:[]},tao="wrapper";function eao(t){let{components:e,...n}=t;return(0,s.kt)(tao,(0,p.Z)({},Jco,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}eao.isMDXComponent=!0;const nao={toc:[]},oao="wrapper";function pao(t){let{components:e,...n}=t;return(0,s.kt)(oao,(0,p.Z)({},nao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}pao.isMDXComponent=!0;const rao={toc:[]},sao="wrapper";function cao(t){let{components:e,...n}=t;return(0,s.kt)(sao,(0,p.Z)({},rao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}cao.isMDXComponent=!0;const aao={toc:[]},iao="wrapper";function lao(t){let{components:e,...n}=t;return(0,s.kt)(iao,(0,p.Z)({},aao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}lao.isMDXComponent=!0;const uao={toc:[]},mao="wrapper";function dao(t){let{components:e,...n}=t;return(0,s.kt)(mao,(0,p.Z)({},uao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}dao.isMDXComponent=!0;const hao={toc:[]},fao="wrapper";function kao(t){let{components:e,...n}=t;return(0,s.kt)(fao,(0,p.Z)({},hao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}kao.isMDXComponent=!0;const yao={toc:[]},Dao="wrapper";function Mao(t){let{components:e,...n}=t;return(0,s.kt)(Dao,(0,p.Z)({},yao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Mao.isMDXComponent=!0;const Xao={toc:[]},_ao="wrapper";function wao(t){let{components:e,...n}=t;return(0,s.kt)(_ao,(0,p.Z)({},Xao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}wao.isMDXComponent=!0;const Tao={toc:[]},Cao="wrapper";function xao(t){let{components:e,...n}=t;return(0,s.kt)(Cao,(0,p.Z)({},Tao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}xao.isMDXComponent=!0;const gao={toc:[]},vao="wrapper";function Lao(t){let{components:e,...n}=t;return(0,s.kt)(vao,(0,p.Z)({},gao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Lao.isMDXComponent=!0;const Zao={toc:[]},bao="wrapper";function Nao(t){let{components:e,...n}=t;return(0,s.kt)(bao,(0,p.Z)({},Zao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Nao.isMDXComponent=!0;const zao={toc:[]},Aao="wrapper";function Pao(t){let{components:e,...n}=t;return(0,s.kt)(Aao,(0,p.Z)({},zao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Pao.isMDXComponent=!0;const Wao={toc:[]},Rao="wrapper";function Iao(t){let{components:e,...n}=t;return(0,s.kt)(Rao,(0,p.Z)({},Wao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Iao.isMDXComponent=!0;const Sao={toc:[]},Bao="wrapper";function Gao(t){let{components:e,...n}=t;return(0,s.kt)(Bao,(0,p.Z)({},Sao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Gao.isMDXComponent=!0;const Eao={toc:[]},Oao="wrapper";function Fao(t){let{components:e,...n}=t;return(0,s.kt)(Oao,(0,p.Z)({},Eao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}Fao.isMDXComponent=!0;const Uao={toc:[]},Vao="wrapper";function qao(t){let{components:e,...n}=t;return(0,s.kt)(Vao,(0,p.Z)({},Uao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}qao.isMDXComponent=!0;const jao={toc:[]},Yao="wrapper";function Qao(t){let{components:e,...n}=t;return(0,s.kt)(Yao,(0,p.Z)({},jao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Qao.isMDXComponent=!0;const Hao={toc:[]},Kao="wrapper";function $ao(t){let{components:e,...n}=t;return(0,s.kt)(Kao,(0,p.Z)({},Hao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}$ao.isMDXComponent=!0;const Jao={toc:[]},tio="wrapper";function eio(t){let{components:e,...n}=t;return(0,s.kt)(tio,(0,p.Z)({},Jao,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}eio.isMDXComponent=!0;const nio={toc:[]},oio="wrapper";function pio(t){let{components:e,...n}=t;return(0,s.kt)(oio,(0,p.Z)({},nio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}pio.isMDXComponent=!0;const rio={toc:[]},sio="wrapper";function cio(t){let{components:e,...n}=t;return(0,s.kt)(sio,(0,p.Z)({},rio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}cio.isMDXComponent=!0;const aio={toc:[]},iio="wrapper";function lio(t){let{components:e,...n}=t;return(0,s.kt)(iio,(0,p.Z)({},aio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}lio.isMDXComponent=!0;const uio={toc:[]},mio="wrapper";function dio(t){let{components:e,...n}=t;return(0,s.kt)(mio,(0,p.Z)({},uio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}dio.isMDXComponent=!0;const hio={toc:[]},fio="wrapper";function kio(t){let{components:e,...n}=t;return(0,s.kt)(fio,(0,p.Z)({},hio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}kio.isMDXComponent=!0;const yio={toc:[]},Dio="wrapper";function Mio(t){let{components:e,...n}=t;return(0,s.kt)(Dio,(0,p.Z)({},yio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Mio.isMDXComponent=!0;const Xio={toc:[]},_io="wrapper";function wio(t){let{components:e,...n}=t;return(0,s.kt)(_io,(0,p.Z)({},Xio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}wio.isMDXComponent=!0;const Tio={toc:[]},Cio="wrapper";function xio(t){let{components:e,...n}=t;return(0,s.kt)(Cio,(0,p.Z)({},Tio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}xio.isMDXComponent=!0;const gio={toc:[]},vio="wrapper";function Lio(t){let{components:e,...n}=t;return(0,s.kt)(vio,(0,p.Z)({},gio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Lio.isMDXComponent=!0;const Zio={toc:[]},bio="wrapper";function Nio(t){let{components:e,...n}=t;return(0,s.kt)(bio,(0,p.Z)({},Zio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Nio.isMDXComponent=!0;const zio={toc:[]},Aio="wrapper";function Pio(t){let{components:e,...n}=t;return(0,s.kt)(Aio,(0,p.Z)({},zio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Pio.isMDXComponent=!0;const Wio={toc:[]},Rio="wrapper";function Iio(t){let{components:e,...n}=t;return(0,s.kt)(Rio,(0,p.Z)({},Wio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}Iio.isMDXComponent=!0;const Sio={toc:[]},Bio="wrapper";function Gio(t){let{components:e,...n}=t;return(0,s.kt)(Bio,(0,p.Z)({},Sio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Gio.isMDXComponent=!0;const Eio={toc:[]},Oio="wrapper";function Fio(t){let{components:e,...n}=t;return(0,s.kt)(Oio,(0,p.Z)({},Eio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}Fio.isMDXComponent=!0;const Uio={toc:[]},Vio="wrapper";function qio(t){let{components:e,...n}=t;return(0,s.kt)(Vio,(0,p.Z)({},Uio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}qio.isMDXComponent=!0;const jio={toc:[]},Yio="wrapper";function Qio(t){let{components:e,...n}=t;return(0,s.kt)(Yio,(0,p.Z)({},jio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Qio.isMDXComponent=!0;const Hio={toc:[]},Kio="wrapper";function $io(t){let{components:e,...n}=t;return(0,s.kt)(Kio,(0,p.Z)({},Hio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}$io.isMDXComponent=!0;const Jio={toc:[]},tlo="wrapper";function elo(t){let{components:e,...n}=t;return(0,s.kt)(tlo,(0,p.Z)({},Jio,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}elo.isMDXComponent=!0;const nlo={toc:[]},olo="wrapper";function plo(t){let{components:e,...n}=t;return(0,s.kt)(olo,(0,p.Z)({},nlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}plo.isMDXComponent=!0;const rlo={toc:[]},slo="wrapper";function clo(t){let{components:e,...n}=t;return(0,s.kt)(slo,(0,p.Z)({},rlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}clo.isMDXComponent=!0;const alo={toc:[]},ilo="wrapper";function llo(t){let{components:e,...n}=t;return(0,s.kt)(ilo,(0,p.Z)({},alo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}llo.isMDXComponent=!0;const ulo={toc:[]},mlo="wrapper";function dlo(t){let{components:e,...n}=t;return(0,s.kt)(mlo,(0,p.Z)({},ulo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}dlo.isMDXComponent=!0;const hlo={toc:[]},flo="wrapper";function klo(t){let{components:e,...n}=t;return(0,s.kt)(flo,(0,p.Z)({},hlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}klo.isMDXComponent=!0;const ylo={toc:[]},Dlo="wrapper";function Mlo(t){let{components:e,...n}=t;return(0,s.kt)(Dlo,(0,p.Z)({},ylo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Mlo.isMDXComponent=!0;const Xlo={toc:[]},_lo="wrapper";function wlo(t){let{components:e,...n}=t;return(0,s.kt)(_lo,(0,p.Z)({},Xlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}wlo.isMDXComponent=!0;const Tlo={toc:[]},Clo="wrapper";function xlo(t){let{components:e,...n}=t;return(0,s.kt)(Clo,(0,p.Z)({},Tlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}xlo.isMDXComponent=!0;const glo={toc:[]},vlo="wrapper";function Llo(t){let{components:e,...n}=t;return(0,s.kt)(vlo,(0,p.Z)({},glo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Llo.isMDXComponent=!0;const Zlo={toc:[]},blo="wrapper";function Nlo(t){let{components:e,...n}=t;return(0,s.kt)(blo,(0,p.Z)({},Zlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Nlo.isMDXComponent=!0;const zlo={toc:[]},Alo="wrapper";function Plo(t){let{components:e,...n}=t;return(0,s.kt)(Alo,(0,p.Z)({},zlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Plo.isMDXComponent=!0;const Wlo={toc:[]},Rlo="wrapper";function Ilo(t){let{components:e,...n}=t;return(0,s.kt)(Rlo,(0,p.Z)({},Wlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Ilo.isMDXComponent=!0;const Slo={toc:[]},Blo="wrapper";function Glo(t){let{components:e,...n}=t;return(0,s.kt)(Blo,(0,p.Z)({},Slo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Glo.isMDXComponent=!0;const Elo={toc:[]},Olo="wrapper";function Flo(t){let{components:e,...n}=t;return(0,s.kt)(Olo,(0,p.Z)({},Elo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}Flo.isMDXComponent=!0;const Ulo={toc:[]},Vlo="wrapper";function qlo(t){let{components:e,...n}=t;return(0,s.kt)(Vlo,(0,p.Z)({},Ulo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}qlo.isMDXComponent=!0;const jlo={toc:[]},Ylo="wrapper";function Qlo(t){let{components:e,...n}=t;return(0,s.kt)(Ylo,(0,p.Z)({},jlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}Qlo.isMDXComponent=!0;const Hlo={toc:[]},Klo="wrapper";function $lo(t){let{components:e,...n}=t;return(0,s.kt)(Klo,(0,p.Z)({},Hlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}$lo.isMDXComponent=!0;const Jlo={toc:[]},tuo="wrapper";function euo(t){let{components:e,...n}=t;return(0,s.kt)(tuo,(0,p.Z)({},Jlo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}euo.isMDXComponent=!0;const nuo={toc:[]},ouo="wrapper";function puo(t){let{components:e,...n}=t;return(0,s.kt)(ouo,(0,p.Z)({},nuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}puo.isMDXComponent=!0;const ruo={toc:[]},suo="wrapper";function cuo(t){let{components:e,...n}=t;return(0,s.kt)(suo,(0,p.Z)({},ruo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}cuo.isMDXComponent=!0;const auo={toc:[]},iuo="wrapper";function luo(t){let{components:e,...n}=t;return(0,s.kt)(iuo,(0,p.Z)({},auo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}luo.isMDXComponent=!0;const uuo={toc:[]},muo="wrapper";function duo(t){let{components:e,...n}=t;return(0,s.kt)(muo,(0,p.Z)({},uuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}duo.isMDXComponent=!0;const huo={toc:[]},fuo="wrapper";function kuo(t){let{components:e,...n}=t;return(0,s.kt)(fuo,(0,p.Z)({},huo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}kuo.isMDXComponent=!0;const yuo={toc:[]},Duo="wrapper";function Muo(t){let{components:e,...n}=t;return(0,s.kt)(Duo,(0,p.Z)({},yuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}Muo.isMDXComponent=!0;const Xuo={toc:[]},_uo="wrapper";function wuo(t){let{components:e,...n}=t;return(0,s.kt)(_uo,(0,p.Z)({},Xuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}wuo.isMDXComponent=!0;const Tuo={toc:[]},Cuo="wrapper";function xuo(t){let{components:e,...n}=t;return(0,s.kt)(Cuo,(0,p.Z)({},Tuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}xuo.isMDXComponent=!0;const guo={toc:[]},vuo="wrapper";function Luo(t){let{components:e,...n}=t;return(0,s.kt)(vuo,(0,p.Z)({},guo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}Luo.isMDXComponent=!0;const Zuo={toc:[]},buo="wrapper";function Nuo(t){let{components:e,...n}=t;return(0,s.kt)(buo,(0,p.Z)({},Zuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}Nuo.isMDXComponent=!0;const zuo={toc:[]},Auo="wrapper";function Puo(t){let{components:e,...n}=t;return(0,s.kt)(Auo,(0,p.Z)({},zuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Puo.isMDXComponent=!0;const Wuo={toc:[]},Ruo="wrapper";function Iuo(t){let{components:e,...n}=t;return(0,s.kt)(Ruo,(0,p.Z)({},Wuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}Iuo.isMDXComponent=!0;const Suo={toc:[]},Buo="wrapper";function Guo(t){let{components:e,...n}=t;return(0,s.kt)(Buo,(0,p.Z)({},Suo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}Guo.isMDXComponent=!0;const Euo={toc:[]},Ouo="wrapper";function Fuo(t){let{components:e,...n}=t;return(0,s.kt)(Ouo,(0,p.Z)({},Euo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}Fuo.isMDXComponent=!0;const Uuo={toc:[]},Vuo="wrapper";function quo(t){let{components:e,...n}=t;return(0,s.kt)(Vuo,(0,p.Z)({},Uuo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}quo.isMDXComponent=!0;const juo={toc:[]},Yuo="wrapper";function Quo(t){let{components:e,...n}=t;return(0,s.kt)(Yuo,(0,p.Z)({},juo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Quo.isMDXComponent=!0;const Huo={toc:[]},Kuo="wrapper";function $uo(t){let{components:e,...n}=t;return(0,s.kt)(Kuo,(0,p.Z)({},Huo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}$uo.isMDXComponent=!0;const Juo={toc:[]},tmo="wrapper";function emo(t){let{components:e,...n}=t;return(0,s.kt)(tmo,(0,p.Z)({},Juo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}emo.isMDXComponent=!0;const nmo={toc:[]},omo="wrapper";function pmo(t){let{components:e,...n}=t;return(0,s.kt)(omo,(0,p.Z)({},nmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}pmo.isMDXComponent=!0;const rmo={toc:[]},smo="wrapper";function cmo(t){let{components:e,...n}=t;return(0,s.kt)(smo,(0,p.Z)({},rmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}cmo.isMDXComponent=!0;const amo={toc:[]},imo="wrapper";function lmo(t){let{components:e,...n}=t;return(0,s.kt)(imo,(0,p.Z)({},amo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lmo.isMDXComponent=!0;const umo={toc:[]},mmo="wrapper";function dmo(t){let{components:e,...n}=t;return(0,s.kt)(mmo,(0,p.Z)({},umo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}dmo.isMDXComponent=!0;const hmo={toc:[]},fmo="wrapper";function kmo(t){let{components:e,...n}=t;return(0,s.kt)(fmo,(0,p.Z)({},hmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}kmo.isMDXComponent=!0;const ymo={toc:[]},Dmo="wrapper";function Mmo(t){let{components:e,...n}=t;return(0,s.kt)(Dmo,(0,p.Z)({},ymo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Mmo.isMDXComponent=!0;const Xmo={toc:[]},_mo="wrapper";function wmo(t){let{components:e,...n}=t;return(0,s.kt)(_mo,(0,p.Z)({},Xmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}wmo.isMDXComponent=!0;const Tmo={toc:[]},Cmo="wrapper";function xmo(t){let{components:e,...n}=t;return(0,s.kt)(Cmo,(0,p.Z)({},Tmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}xmo.isMDXComponent=!0;const gmo={toc:[]},vmo="wrapper";function Lmo(t){let{components:e,...n}=t;return(0,s.kt)(vmo,(0,p.Z)({},gmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}Lmo.isMDXComponent=!0;const Zmo={toc:[]},bmo="wrapper";function Nmo(t){let{components:e,...n}=t;return(0,s.kt)(bmo,(0,p.Z)({},Zmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}Nmo.isMDXComponent=!0;const zmo={toc:[]},Amo="wrapper";function Pmo(t){let{components:e,...n}=t;return(0,s.kt)(Amo,(0,p.Z)({},zmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Pmo.isMDXComponent=!0;const Wmo={toc:[]},Rmo="wrapper";function Imo(t){let{components:e,...n}=t;return(0,s.kt)(Rmo,(0,p.Z)({},Wmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Imo.isMDXComponent=!0;const Smo={toc:[]},Bmo="wrapper";function Gmo(t){let{components:e,...n}=t;return(0,s.kt)(Bmo,(0,p.Z)({},Smo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}Gmo.isMDXComponent=!0;const Emo={toc:[]},Omo="wrapper";function Fmo(t){let{components:e,...n}=t;return(0,s.kt)(Omo,(0,p.Z)({},Emo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Fmo.isMDXComponent=!0;const Umo={toc:[]},Vmo="wrapper";function qmo(t){let{components:e,...n}=t;return(0,s.kt)(Vmo,(0,p.Z)({},Umo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}qmo.isMDXComponent=!0;const jmo={toc:[]},Ymo="wrapper";function Qmo(t){let{components:e,...n}=t;return(0,s.kt)(Ymo,(0,p.Z)({},jmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This node uses B\xe9zier curves for drawing each segment of the spline."))}Qmo.isMDXComponent=!0;const Hmo={toc:[]},Kmo="wrapper";function $mo(t){let{components:e,...n}=t;return(0,s.kt)(Kmo,(0,p.Z)({},Hmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Defining knots using the ",(0,s.kt)("inlineCode",{parentName:"p"},"points")," property. This will automatically\ncalculate the handle positions for each knot do draw a smooth curve. You\ncan control the smoothness of the resulting curve via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline\n  lineWidth={4}\n  stroke={'white'}\n  smoothness={0.4}\n  points={[\n    [-400, 0],\n    [-200, -300],\n    [0, 0],\n    [200, -300],\n    [400, 0],\n  ]}\n/>\n")),(0,s.kt)("p",null,"Defining knots with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Knot"},(0,s.kt)("inlineCode",{parentName:"a"},"Knot"))," nodes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Spline lineWidth={4} stroke={'white'}>\n  <Knot position={[-400, 0]} />\n  <Knot position={[-200, -300]} />\n  <Knot\n    position={[0, 0]}\n    startHandle={[-100, 200]}\n    endHandle={[100, 200]}\n  />\n  <Knot position={[200, -300]} />\n  <Knot position={[400, 0]} />\n</Spline>\n")))}$mo.isMDXComponent=!0;const Jmo={toc:[]},tdo="wrapper";function edo(t){let{components:e,...n}=t;return(0,s.kt)(tdo,(0,p.Z)({},Jmo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node for drawing a smooth line through a number of points."))}edo.isMDXComponent=!0;const ndo={toc:[]},odo="wrapper";function pdo(t){let{components:e,...n}=t;return(0,s.kt)(odo,(0,p.Z)({},ndo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}pdo.isMDXComponent=!0;const rdo={toc:[]},sdo="wrapper";function cdo(t){let{components:e,...n}=t;return(0,s.kt)(sdo,(0,p.Z)({},rdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}cdo.isMDXComponent=!0;const ado={toc:[]},ido="wrapper";function ldo(t){let{components:e,...n}=t;return(0,s.kt)(ido,(0,p.Z)({},ado,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}ldo.isMDXComponent=!0;const udo={toc:[]},mdo="wrapper";function ddo(t){let{components:e,...n}=t;return(0,s.kt)(mdo,(0,p.Z)({},udo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}ddo.isMDXComponent=!0;const hdo={toc:[]},fdo="wrapper";function kdo(t){let{components:e,...n}=t;return(0,s.kt)(fdo,(0,p.Z)({},hdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}kdo.isMDXComponent=!0;const ydo={toc:[]},Ddo="wrapper";function Mdo(t){let{components:e,...n}=t;return(0,s.kt)(Ddo,(0,p.Z)({},ydo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Mdo.isMDXComponent=!0;const Xdo={toc:[]},_do="wrapper";function wdo(t){let{components:e,...n}=t;return(0,s.kt)(_do,(0,p.Z)({},Xdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}wdo.isMDXComponent=!0;const Tdo={toc:[]},Cdo="wrapper";function xdo(t){let{components:e,...n}=t;return(0,s.kt)(Cdo,(0,p.Z)({},Tdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}xdo.isMDXComponent=!0;const gdo={toc:[]},vdo="wrapper";function Ldo(t){let{components:e,...n}=t;return(0,s.kt)(vdo,(0,p.Z)({},gdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}Ldo.isMDXComponent=!0;const Zdo={toc:[]},bdo="wrapper";function Ndo(t){let{components:e,...n}=t;return(0,s.kt)(bdo,(0,p.Z)({},Zdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Ndo.isMDXComponent=!0;const zdo={toc:[]},Ado="wrapper";function Pdo(t){let{components:e,...n}=t;return(0,s.kt)(Ado,(0,p.Z)({},zdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Pdo.isMDXComponent=!0;const Wdo={toc:[]},Rdo="wrapper";function Ido(t){let{components:e,...n}=t;return(0,s.kt)(Rdo,(0,p.Z)({},Wdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Ido.isMDXComponent=!0;const Sdo={toc:[]},Bdo="wrapper";function Gdo(t){let{components:e,...n}=t;return(0,s.kt)(Bdo,(0,p.Z)({},Sdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Gdo.isMDXComponent=!0;const Edo={toc:[]},Odo="wrapper";function Fdo(t){let{components:e,...n}=t;return(0,s.kt)(Odo,(0,p.Z)({},Edo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Fdo.isMDXComponent=!0;const Udo={toc:[]},Vdo="wrapper";function qdo(t){let{components:e,...n}=t;return(0,s.kt)(Vdo,(0,p.Z)({},Udo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}qdo.isMDXComponent=!0;const jdo={toc:[]},Ydo="wrapper";function Qdo(t){let{components:e,...n}=t;return(0,s.kt)(Ydo,(0,p.Z)({},jdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Qdo.isMDXComponent=!0;const Hdo={toc:[]},Kdo="wrapper";function $do(t){let{components:e,...n}=t;return(0,s.kt)(Kdo,(0,p.Z)({},Hdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}$do.isMDXComponent=!0;const Jdo={toc:[]},tho="wrapper";function eho(t){let{components:e,...n}=t;return(0,s.kt)(tho,(0,p.Z)({},Jdo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}eho.isMDXComponent=!0;const nho={toc:[]},oho="wrapper";function pho(t){let{components:e,...n}=t;return(0,s.kt)(oho,(0,p.Z)({},nho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pho.isMDXComponent=!0;const rho={toc:[]},sho="wrapper";function cho(t){let{components:e,...n}=t;return(0,s.kt)(sho,(0,p.Z)({},rho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}cho.isMDXComponent=!0;const aho={toc:[]},iho="wrapper";function lho(t){let{components:e,...n}=t;return(0,s.kt)(iho,(0,p.Z)({},aho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}lho.isMDXComponent=!0;const uho={toc:[]},mho="wrapper";function dho(t){let{components:e,...n}=t;return(0,s.kt)(mho,(0,p.Z)({},uho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}dho.isMDXComponent=!0;const hho={toc:[]},fho="wrapper";function kho(t){let{components:e,...n}=t;return(0,s.kt)(fho,(0,p.Z)({},hho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}kho.isMDXComponent=!0;const yho={toc:[]},Dho="wrapper";function Mho(t){let{components:e,...n}=t;return(0,s.kt)(Dho,(0,p.Z)({},yho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Mho.isMDXComponent=!0;const Xho={toc:[]},_ho="wrapper";function who(t){let{components:e,...n}=t;return(0,s.kt)(_ho,(0,p.Z)({},Xho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}who.isMDXComponent=!0;const Tho={toc:[]},Cho="wrapper";function xho(t){let{components:e,...n}=t;return(0,s.kt)(Cho,(0,p.Z)({},Tho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}xho.isMDXComponent=!0;const gho={toc:[]},vho="wrapper";function Lho(t){let{components:e,...n}=t;return(0,s.kt)(vho,(0,p.Z)({},gho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}Lho.isMDXComponent=!0;const Zho={toc:[]},bho="wrapper";function Nho(t){let{components:e,...n}=t;return(0,s.kt)(bho,(0,p.Z)({},Zho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Nho.isMDXComponent=!0;const zho={toc:[]},Aho="wrapper";function Pho(t){let{components:e,...n}=t;return(0,s.kt)(Aho,(0,p.Z)({},zho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Pho.isMDXComponent=!0;const Who={toc:[]},Rho="wrapper";function Iho(t){let{components:e,...n}=t;return(0,s.kt)(Rho,(0,p.Z)({},Who,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}Iho.isMDXComponent=!0;const Sho={toc:[]},Bho="wrapper";function Gho(t){let{components:e,...n}=t;return(0,s.kt)(Bho,(0,p.Z)({},Sho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}Gho.isMDXComponent=!0;const Eho={toc:[]},Oho="wrapper";function Fho(t){let{components:e,...n}=t;return(0,s.kt)(Oho,(0,p.Z)({},Eho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}Fho.isMDXComponent=!0;const Uho={toc:[]},Vho="wrapper";function qho(t){let{components:e,...n}=t;return(0,s.kt)(Vho,(0,p.Z)({},Uho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}qho.isMDXComponent=!0;const jho={toc:[]},Yho="wrapper";function Qho(t){let{components:e,...n}=t;return(0,s.kt)(Yho,(0,p.Z)({},jho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Qho.isMDXComponent=!0;const Hho={toc:[]},Kho="wrapper";function $ho(t){let{components:e,...n}=t;return(0,s.kt)(Kho,(0,p.Z)({},Hho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}$ho.isMDXComponent=!0;const Jho={toc:[]},tfo="wrapper";function efo(t){let{components:e,...n}=t;return(0,s.kt)(tfo,(0,p.Z)({},Jho,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}efo.isMDXComponent=!0;const nfo={toc:[]},ofo="wrapper";function pfo(t){let{components:e,...n}=t;return(0,s.kt)(ofo,(0,p.Z)({},nfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}pfo.isMDXComponent=!0;const rfo={toc:[]},sfo="wrapper";function cfo(t){let{components:e,...n}=t;return(0,s.kt)(sfo,(0,p.Z)({},rfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}cfo.isMDXComponent=!0;const afo={toc:[]},ifo="wrapper";function lfo(t){let{components:e,...n}=t;return(0,s.kt)(ifo,(0,p.Z)({},afo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}lfo.isMDXComponent=!0;const ufo={toc:[]},mfo="wrapper";function dfo(t){let{components:e,...n}=t;return(0,s.kt)(mfo,(0,p.Z)({},ufo,n,{components:e,mdxType:"MDXLayout"}))}dfo.isMDXComponent=!0;const hfo={toc:[]},ffo="wrapper";function kfo(t){let{components:e,...n}=t;return(0,s.kt)(ffo,(0,p.Z)({},hfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}kfo.isMDXComponent=!0;const yfo={toc:[]},Dfo="wrapper";function Mfo(t){let{components:e,...n}=t;return(0,s.kt)(Dfo,(0,p.Z)({},yfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Mfo.isMDXComponent=!0;const Xfo={toc:[]},_fo="wrapper";function wfo(t){let{components:e,...n}=t;return(0,s.kt)(_fo,(0,p.Z)({},Xfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}wfo.isMDXComponent=!0;const Tfo={toc:[]},Cfo="wrapper";function xfo(t){let{components:e,...n}=t;return(0,s.kt)(Cfo,(0,p.Z)({},Tfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}xfo.isMDXComponent=!0;const gfo={toc:[]},vfo="wrapper";function Lfo(t){let{components:e,...n}=t;return(0,s.kt)(vfo,(0,p.Z)({},gfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}Lfo.isMDXComponent=!0;const Zfo={toc:[]},bfo="wrapper";function Nfo(t){let{components:e,...n}=t;return(0,s.kt)(bfo,(0,p.Z)({},Zfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}Nfo.isMDXComponent=!0;const zfo={toc:[]},Afo="wrapper";function Pfo(t){let{components:e,...n}=t;return(0,s.kt)(Afo,(0,p.Z)({},zfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"0.4"))}Pfo.isMDXComponent=!0;const Wfo={toc:[]},Rfo="wrapper";function Ifo(t){let{components:e,...n}=t;return(0,s.kt)(Rfo,(0,p.Z)({},Wfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}Ifo.isMDXComponent=!0;const Sfo={toc:[]},Bfo="wrapper";function Gfo(t){let{components:e,...n}=t;return(0,s.kt)(Bfo,(0,p.Z)({},Sfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Gfo.isMDXComponent=!0;const Efo={toc:[]},Ofo="wrapper";function Ffo(t){let{components:e,...n}=t;return(0,s.kt)(Ofo,(0,p.Z)({},Efo,n,{components:e,mdxType:"MDXLayout"}))}Ffo.isMDXComponent=!0;const Ufo={toc:[]},Vfo="wrapper";function qfo(t){let{components:e,...n}=t;return(0,s.kt)(Vfo,(0,p.Z)({},Ufo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qfo.isMDXComponent=!0;const jfo={toc:[]},Yfo="wrapper";function Qfo(t){let{components:e,...n}=t;return(0,s.kt)(Yfo,(0,p.Z)({},jfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Qfo.isMDXComponent=!0;const Hfo={toc:[]},Kfo="wrapper";function $fo(t){let{components:e,...n}=t;return(0,s.kt)(Kfo,(0,p.Z)({},Hfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}$fo.isMDXComponent=!0;const Jfo={toc:[]},tko="wrapper";function eko(t){let{components:e,...n}=t;return(0,s.kt)(tko,(0,p.Z)({},Jfo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}eko.isMDXComponent=!0;const nko={toc:[]},oko="wrapper";function pko(t){let{components:e,...n}=t;return(0,s.kt)(oko,(0,p.Z)({},nko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}pko.isMDXComponent=!0;const rko={toc:[]},sko="wrapper";function cko(t){let{components:e,...n}=t;return(0,s.kt)(sko,(0,p.Z)({},rko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}cko.isMDXComponent=!0;const ako={toc:[]},iko="wrapper";function lko(t){let{components:e,...n}=t;return(0,s.kt)(iko,(0,p.Z)({},ako,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}lko.isMDXComponent=!0;const uko={toc:[]},mko="wrapper";function dko(t){let{components:e,...n}=t;return(0,s.kt)(mko,(0,p.Z)({},uko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}dko.isMDXComponent=!0;const hko={toc:[]},fko="wrapper";function kko(t){let{components:e,...n}=t;return(0,s.kt)(fko,(0,p.Z)({},hko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}kko.isMDXComponent=!0;const yko={toc:[]},Dko="wrapper";function Mko(t){let{components:e,...n}=t;return(0,s.kt)(Dko,(0,p.Z)({},yko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Mko.isMDXComponent=!0;const Xko={toc:[]},_ko="wrapper";function wko(t){let{components:e,...n}=t;return(0,s.kt)(_ko,(0,p.Z)({},Xko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}wko.isMDXComponent=!0;const Tko={toc:[]},Cko="wrapper";function xko(t){let{components:e,...n}=t;return(0,s.kt)(Cko,(0,p.Z)({},Tko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}xko.isMDXComponent=!0;const gko={toc:[]},vko="wrapper";function Lko(t){let{components:e,...n}=t;return(0,s.kt)(vko,(0,p.Z)({},gko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}Lko.isMDXComponent=!0;const Zko={toc:[]},bko="wrapper";function Nko(t){let{components:e,...n}=t;return(0,s.kt)(bko,(0,p.Z)({},Zko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Nko.isMDXComponent=!0;const zko={toc:[]},Ako="wrapper";function Pko(t){let{components:e,...n}=t;return(0,s.kt)(Ako,(0,p.Z)({},zko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Pko.isMDXComponent=!0;const Wko={toc:[]},Rko="wrapper";function Iko(t){let{components:e,...n}=t;return(0,s.kt)(Rko,(0,p.Z)({},Wko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Iko.isMDXComponent=!0;const Sko={toc:[]},Bko="wrapper";function Gko(t){let{components:e,...n}=t;return(0,s.kt)(Bko,(0,p.Z)({},Sko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Gko.isMDXComponent=!0;const Eko={toc:[]},Oko="wrapper";function Fko(t){let{components:e,...n}=t;return(0,s.kt)(Oko,(0,p.Z)({},Eko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Fko.isMDXComponent=!0;const Uko={toc:[]},Vko="wrapper";function qko(t){let{components:e,...n}=t;return(0,s.kt)(Vko,(0,p.Z)({},Uko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}qko.isMDXComponent=!0;const jko={toc:[]},Yko="wrapper";function Qko(t){let{components:e,...n}=t;return(0,s.kt)(Yko,(0,p.Z)({},jko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}Qko.isMDXComponent=!0;const Hko={toc:[]},Kko="wrapper";function $ko(t){let{components:e,...n}=t;return(0,s.kt)(Kko,(0,p.Z)({},Hko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}$ko.isMDXComponent=!0;const Jko={toc:[]},tyo="wrapper";function eyo(t){let{components:e,...n}=t;return(0,s.kt)(tyo,(0,p.Z)({},Jko,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}eyo.isMDXComponent=!0;const nyo={toc:[]},oyo="wrapper";function pyo(t){let{components:e,...n}=t;return(0,s.kt)(oyo,(0,p.Z)({},nyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}pyo.isMDXComponent=!0;const ryo={toc:[]},syo="wrapper";function cyo(t){let{components:e,...n}=t;return(0,s.kt)(syo,(0,p.Z)({},ryo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}cyo.isMDXComponent=!0;const ayo={toc:[]},iyo="wrapper";function lyo(t){let{components:e,...n}=t;return(0,s.kt)(iyo,(0,p.Z)({},ayo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}lyo.isMDXComponent=!0;const uyo={toc:[]},myo="wrapper";function dyo(t){let{components:e,...n}=t;return(0,s.kt)(myo,(0,p.Z)({},uyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}dyo.isMDXComponent=!0;const hyo={toc:[]},fyo="wrapper";function kyo(t){let{components:e,...n}=t;return(0,s.kt)(fyo,(0,p.Z)({},hyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}kyo.isMDXComponent=!0;const yyo={toc:[]},Dyo="wrapper";function Myo(t){let{components:e,...n}=t;return(0,s.kt)(Dyo,(0,p.Z)({},yyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Myo.isMDXComponent=!0;const Xyo={toc:[]},_yo="wrapper";function wyo(t){let{components:e,...n}=t;return(0,s.kt)(_yo,(0,p.Z)({},Xyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}wyo.isMDXComponent=!0;const Tyo={toc:[]},Cyo="wrapper";function xyo(t){let{components:e,...n}=t;return(0,s.kt)(Cyo,(0,p.Z)({},Tyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}xyo.isMDXComponent=!0;const gyo={toc:[]},vyo="wrapper";function Lyo(t){let{components:e,...n}=t;return(0,s.kt)(vyo,(0,p.Z)({},gyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}Lyo.isMDXComponent=!0;const Zyo={toc:[]},byo="wrapper";function Nyo(t){let{components:e,...n}=t;return(0,s.kt)(byo,(0,p.Z)({},Zyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Nyo.isMDXComponent=!0;const zyo={toc:[]},Ayo="wrapper";function Pyo(t){let{components:e,...n}=t;return(0,s.kt)(Ayo,(0,p.Z)({},zyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Pyo.isMDXComponent=!0;const Wyo={toc:[]},Ryo="wrapper";function Iyo(t){let{components:e,...n}=t;return(0,s.kt)(Ryo,(0,p.Z)({},Wyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}Iyo.isMDXComponent=!0;const Syo={toc:[]},Byo="wrapper";function Gyo(t){let{components:e,...n}=t;return(0,s.kt)(Byo,(0,p.Z)({},Syo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}Gyo.isMDXComponent=!0;const Eyo={toc:[]},Oyo="wrapper";function Fyo(t){let{components:e,...n}=t;return(0,s.kt)(Oyo,(0,p.Z)({},Eyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}Fyo.isMDXComponent=!0;const Uyo={toc:[]},Vyo="wrapper";function qyo(t){let{components:e,...n}=t;return(0,s.kt)(Vyo,(0,p.Z)({},Uyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}qyo.isMDXComponent=!0;const jyo={toc:[]},Yyo="wrapper";function Qyo(t){let{components:e,...n}=t;return(0,s.kt)(Yyo,(0,p.Z)({},jyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}Qyo.isMDXComponent=!0;const Hyo={toc:[]},Kyo="wrapper";function $yo(t){let{components:e,...n}=t;return(0,s.kt)(Kyo,(0,p.Z)({},Hyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}$yo.isMDXComponent=!0;const Jyo={toc:[]},tDo="wrapper";function eDo(t){let{components:e,...n}=t;return(0,s.kt)(tDo,(0,p.Z)({},Jyo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}eDo.isMDXComponent=!0;const nDo={toc:[]},oDo="wrapper";function pDo(t){let{components:e,...n}=t;return(0,s.kt)(oDo,(0,p.Z)({},nDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}pDo.isMDXComponent=!0;const rDo={toc:[]},sDo="wrapper";function cDo(t){let{components:e,...n}=t;return(0,s.kt)(sDo,(0,p.Z)({},rDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}cDo.isMDXComponent=!0;const aDo={toc:[]},iDo="wrapper";function lDo(t){let{components:e,...n}=t;return(0,s.kt)(iDo,(0,p.Z)({},aDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}lDo.isMDXComponent=!0;const uDo={toc:[]},mDo="wrapper";function dDo(t){let{components:e,...n}=t;return(0,s.kt)(mDo,(0,p.Z)({},uDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}dDo.isMDXComponent=!0;const hDo={toc:[]},fDo="wrapper";function kDo(t){let{components:e,...n}=t;return(0,s.kt)(fDo,(0,p.Z)({},hDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}kDo.isMDXComponent=!0;const yDo={toc:[]},DDo="wrapper";function MDo(t){let{components:e,...n}=t;return(0,s.kt)(DDo,(0,p.Z)({},yDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}MDo.isMDXComponent=!0;const XDo={toc:[]},_Do="wrapper";function wDo(t){let{components:e,...n}=t;return(0,s.kt)(_Do,(0,p.Z)({},XDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}wDo.isMDXComponent=!0;const TDo={toc:[]},CDo="wrapper";function xDo(t){let{components:e,...n}=t;return(0,s.kt)(CDo,(0,p.Z)({},TDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}xDo.isMDXComponent=!0;const gDo={toc:[]},vDo="wrapper";function LDo(t){let{components:e,...n}=t;return(0,s.kt)(vDo,(0,p.Z)({},gDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}LDo.isMDXComponent=!0;const ZDo={toc:[]},bDo="wrapper";function NDo(t){let{components:e,...n}=t;return(0,s.kt)(bDo,(0,p.Z)({},ZDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}NDo.isMDXComponent=!0;const zDo={toc:[]},ADo="wrapper";function PDo(t){let{components:e,...n}=t;return(0,s.kt)(ADo,(0,p.Z)({},zDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}PDo.isMDXComponent=!0;const WDo={toc:[]},RDo="wrapper";function IDo(t){let{components:e,...n}=t;return(0,s.kt)(RDo,(0,p.Z)({},WDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}IDo.isMDXComponent=!0;const SDo={toc:[]},BDo="wrapper";function GDo(t){let{components:e,...n}=t;return(0,s.kt)(BDo,(0,p.Z)({},SDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}GDo.isMDXComponent=!0;const EDo={toc:[]},ODo="wrapper";function FDo(t){let{components:e,...n}=t;return(0,s.kt)(ODo,(0,p.Z)({},EDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}FDo.isMDXComponent=!0;const UDo={toc:[]},VDo="wrapper";function qDo(t){let{components:e,...n}=t;return(0,s.kt)(VDo,(0,p.Z)({},UDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}qDo.isMDXComponent=!0;const jDo={toc:[]},YDo="wrapper";function QDo(t){let{components:e,...n}=t;return(0,s.kt)(YDo,(0,p.Z)({},jDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}QDo.isMDXComponent=!0;const HDo={toc:[]},KDo="wrapper";function $Do(t){let{components:e,...n}=t;return(0,s.kt)(KDo,(0,p.Z)({},HDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}$Do.isMDXComponent=!0;const JDo={toc:[]},tMo="wrapper";function eMo(t){let{components:e,...n}=t;return(0,s.kt)(tMo,(0,p.Z)({},JDo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}eMo.isMDXComponent=!0;const nMo={toc:[]},oMo="wrapper";function pMo(t){let{components:e,...n}=t;return(0,s.kt)(oMo,(0,p.Z)({},nMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}pMo.isMDXComponent=!0;const rMo={toc:[]},sMo="wrapper";function cMo(t){let{components:e,...n}=t;return(0,s.kt)(sMo,(0,p.Z)({},rMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cMo.isMDXComponent=!0;const aMo={toc:[]},iMo="wrapper";function lMo(t){let{components:e,...n}=t;return(0,s.kt)(iMo,(0,p.Z)({},aMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}lMo.isMDXComponent=!0;const uMo={toc:[]},mMo="wrapper";function dMo(t){let{components:e,...n}=t;return(0,s.kt)(mMo,(0,p.Z)({},uMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dMo.isMDXComponent=!0;const hMo={toc:[]},fMo="wrapper";function kMo(t){let{components:e,...n}=t;return(0,s.kt)(fMo,(0,p.Z)({},hMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}kMo.isMDXComponent=!0;const yMo={toc:[]},DMo="wrapper";function MMo(t){let{components:e,...n}=t;return(0,s.kt)(DMo,(0,p.Z)({},yMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}MMo.isMDXComponent=!0;const XMo={toc:[]},_Mo="wrapper";function wMo(t){let{components:e,...n}=t;return(0,s.kt)(_Mo,(0,p.Z)({},XMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}wMo.isMDXComponent=!0;const TMo={toc:[]},CMo="wrapper";function xMo(t){let{components:e,...n}=t;return(0,s.kt)(CMo,(0,p.Z)({},TMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}xMo.isMDXComponent=!0;const gMo={toc:[]},vMo="wrapper";function LMo(t){let{components:e,...n}=t;return(0,s.kt)(vMo,(0,p.Z)({},gMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}LMo.isMDXComponent=!0;const ZMo={toc:[]},bMo="wrapper";function NMo(t){let{components:e,...n}=t;return(0,s.kt)(bMo,(0,p.Z)({},ZMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NMo.isMDXComponent=!0;const zMo={toc:[]},AMo="wrapper";function PMo(t){let{components:e,...n}=t;return(0,s.kt)(AMo,(0,p.Z)({},zMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}PMo.isMDXComponent=!0;const WMo={toc:[]},RMo="wrapper";function IMo(t){let{components:e,...n}=t;return(0,s.kt)(RMo,(0,p.Z)({},WMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}IMo.isMDXComponent=!0;const SMo={toc:[]},BMo="wrapper";function GMo(t){let{components:e,...n}=t;return(0,s.kt)(BMo,(0,p.Z)({},SMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}GMo.isMDXComponent=!0;const EMo={toc:[]},OMo="wrapper";function FMo(t){let{components:e,...n}=t;return(0,s.kt)(OMo,(0,p.Z)({},EMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}FMo.isMDXComponent=!0;const UMo={toc:[]},VMo="wrapper";function qMo(t){let{components:e,...n}=t;return(0,s.kt)(VMo,(0,p.Z)({},UMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}qMo.isMDXComponent=!0;const jMo={toc:[]},YMo="wrapper";function QMo(t){let{components:e,...n}=t;return(0,s.kt)(YMo,(0,p.Z)({},jMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}QMo.isMDXComponent=!0;const HMo={toc:[]},KMo="wrapper";function $Mo(t){let{components:e,...n}=t;return(0,s.kt)(KMo,(0,p.Z)({},HMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}$Mo.isMDXComponent=!0;const JMo={toc:[]},tXo="wrapper";function eXo(t){let{components:e,...n}=t;return(0,s.kt)(tXo,(0,p.Z)({},JMo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}eXo.isMDXComponent=!0;const nXo={toc:[]},oXo="wrapper";function pXo(t){let{components:e,...n}=t;return(0,s.kt)(oXo,(0,p.Z)({},nXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}pXo.isMDXComponent=!0;const rXo={toc:[]},sXo="wrapper";function cXo(t){let{components:e,...n}=t;return(0,s.kt)(sXo,(0,p.Z)({},rXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}cXo.isMDXComponent=!0;const aXo={toc:[]},iXo="wrapper";function lXo(t){let{components:e,...n}=t;return(0,s.kt)(iXo,(0,p.Z)({},aXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}lXo.isMDXComponent=!0;const uXo={toc:[]},mXo="wrapper";function dXo(t){let{components:e,...n}=t;return(0,s.kt)(mXo,(0,p.Z)({},uXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}dXo.isMDXComponent=!0;const hXo={toc:[]},fXo="wrapper";function kXo(t){let{components:e,...n}=t;return(0,s.kt)(fXo,(0,p.Z)({},hXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}kXo.isMDXComponent=!0;const yXo={toc:[]},DXo="wrapper";function MXo(t){let{components:e,...n}=t;return(0,s.kt)(DXo,(0,p.Z)({},yXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}MXo.isMDXComponent=!0;const XXo={toc:[]},_Xo="wrapper";function wXo(t){let{components:e,...n}=t;return(0,s.kt)(_Xo,(0,p.Z)({},XXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}wXo.isMDXComponent=!0;const TXo={toc:[]},CXo="wrapper";function xXo(t){let{components:e,...n}=t;return(0,s.kt)(CXo,(0,p.Z)({},TXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}xXo.isMDXComponent=!0;const gXo={toc:[]},vXo="wrapper";function LXo(t){let{components:e,...n}=t;return(0,s.kt)(vXo,(0,p.Z)({},gXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}LXo.isMDXComponent=!0;const ZXo={toc:[]},bXo="wrapper";function NXo(t){let{components:e,...n}=t;return(0,s.kt)(bXo,(0,p.Z)({},ZXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}NXo.isMDXComponent=!0;const zXo={toc:[]},AXo="wrapper";function PXo(t){let{components:e,...n}=t;return(0,s.kt)(AXo,(0,p.Z)({},zXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}PXo.isMDXComponent=!0;const WXo={toc:[]},RXo="wrapper";function IXo(t){let{components:e,...n}=t;return(0,s.kt)(RXo,(0,p.Z)({},WXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}IXo.isMDXComponent=!0;const SXo={toc:[]},BXo="wrapper";function GXo(t){let{components:e,...n}=t;return(0,s.kt)(BXo,(0,p.Z)({},SXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}GXo.isMDXComponent=!0;const EXo={toc:[]},OXo="wrapper";function FXo(t){let{components:e,...n}=t;return(0,s.kt)(OXo,(0,p.Z)({},EXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}FXo.isMDXComponent=!0;const UXo={toc:[]},VXo="wrapper";function qXo(t){let{components:e,...n}=t;return(0,s.kt)(VXo,(0,p.Z)({},UXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}qXo.isMDXComponent=!0;const jXo={toc:[]},YXo="wrapper";function QXo(t){let{components:e,...n}=t;return(0,s.kt)(YXo,(0,p.Z)({},jXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}QXo.isMDXComponent=!0;const HXo={toc:[]},KXo="wrapper";function $Xo(t){let{components:e,...n}=t;return(0,s.kt)(KXo,(0,p.Z)({},HXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}$Xo.isMDXComponent=!0;const JXo={toc:[]},t_o="wrapper";function e_o(t){let{components:e,...n}=t;return(0,s.kt)(t_o,(0,p.Z)({},JXo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}e_o.isMDXComponent=!0;const n_o={toc:[]},o_o="wrapper";function p_o(t){let{components:e,...n}=t;return(0,s.kt)(o_o,(0,p.Z)({},n_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}p_o.isMDXComponent=!0;const r_o={toc:[]},s_o="wrapper";function c_o(t){let{components:e,...n}=t;return(0,s.kt)(s_o,(0,p.Z)({},r_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}c_o.isMDXComponent=!0;const a_o={toc:[]},i_o="wrapper";function l_o(t){let{components:e,...n}=t;return(0,s.kt)(i_o,(0,p.Z)({},a_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}l_o.isMDXComponent=!0;const u_o={toc:[]},m_o="wrapper";function d_o(t){let{components:e,...n}=t;return(0,s.kt)(m_o,(0,p.Z)({},u_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}d_o.isMDXComponent=!0;const h_o={toc:[]},f_o="wrapper";function k_o(t){let{components:e,...n}=t;return(0,s.kt)(f_o,(0,p.Z)({},h_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}k_o.isMDXComponent=!0;const y_o={toc:[]},D_o="wrapper";function M_o(t){let{components:e,...n}=t;return(0,s.kt)(D_o,(0,p.Z)({},y_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}M_o.isMDXComponent=!0;const X_o={toc:[]},__o="wrapper";function w_o(t){let{components:e,...n}=t;return(0,s.kt)(__o,(0,p.Z)({},X_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}w_o.isMDXComponent=!0;const T_o={toc:[]},C_o="wrapper";function x_o(t){let{components:e,...n}=t;return(0,s.kt)(C_o,(0,p.Z)({},T_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}x_o.isMDXComponent=!0;const g_o={toc:[]},v_o="wrapper";function L_o(t){let{components:e,...n}=t;return(0,s.kt)(v_o,(0,p.Z)({},g_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}L_o.isMDXComponent=!0;const Z_o={toc:[]},b_o="wrapper";function N_o(t){let{components:e,...n}=t;return(0,s.kt)(b_o,(0,p.Z)({},Z_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}N_o.isMDXComponent=!0;const z_o={toc:[]},A_o="wrapper";function P_o(t){let{components:e,...n}=t;return(0,s.kt)(A_o,(0,p.Z)({},z_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}P_o.isMDXComponent=!0;const W_o={toc:[]},R_o="wrapper";function I_o(t){let{components:e,...n}=t;return(0,s.kt)(R_o,(0,p.Z)({},W_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}I_o.isMDXComponent=!0;const S_o={toc:[]},B_o="wrapper";function G_o(t){let{components:e,...n}=t;return(0,s.kt)(B_o,(0,p.Z)({},S_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}G_o.isMDXComponent=!0;const E_o={toc:[]},O_o="wrapper";function F_o(t){let{components:e,...n}=t;return(0,s.kt)(O_o,(0,p.Z)({},E_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}F_o.isMDXComponent=!0;const U_o={toc:[]},V_o="wrapper";function q_o(t){let{components:e,...n}=t;return(0,s.kt)(V_o,(0,p.Z)({},U_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}q_o.isMDXComponent=!0;const j_o={toc:[]},Y_o="wrapper";function Q_o(t){let{components:e,...n}=t;return(0,s.kt)(Y_o,(0,p.Z)({},j_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Q_o.isMDXComponent=!0;const H_o={toc:[]},K_o="wrapper";function $_o(t){let{components:e,...n}=t;return(0,s.kt)(K_o,(0,p.Z)({},H_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}$_o.isMDXComponent=!0;const J_o={toc:[]},two="wrapper";function ewo(t){let{components:e,...n}=t;return(0,s.kt)(two,(0,p.Z)({},J_o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}ewo.isMDXComponent=!0;const nwo={toc:[]},owo="wrapper";function pwo(t){let{components:e,...n}=t;return(0,s.kt)(owo,(0,p.Z)({},nwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}pwo.isMDXComponent=!0;const rwo={toc:[]},swo="wrapper";function cwo(t){let{components:e,...n}=t;return(0,s.kt)(swo,(0,p.Z)({},rwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}cwo.isMDXComponent=!0;const awo={toc:[]},iwo="wrapper";function lwo(t){let{components:e,...n}=t;return(0,s.kt)(iwo,(0,p.Z)({},awo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}lwo.isMDXComponent=!0;const uwo={toc:[]},mwo="wrapper";function dwo(t){let{components:e,...n}=t;return(0,s.kt)(mwo,(0,p.Z)({},uwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}dwo.isMDXComponent=!0;const hwo={toc:[]},fwo="wrapper";function kwo(t){let{components:e,...n}=t;return(0,s.kt)(fwo,(0,p.Z)({},hwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}kwo.isMDXComponent=!0;const ywo={toc:[]},Dwo="wrapper";function Mwo(t){let{components:e,...n}=t;return(0,s.kt)(Dwo,(0,p.Z)({},ywo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Mwo.isMDXComponent=!0;const Xwo={toc:[]},_wo="wrapper";function wwo(t){let{components:e,...n}=t;return(0,s.kt)(_wo,(0,p.Z)({},Xwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}wwo.isMDXComponent=!0;const Two={toc:[]},Cwo="wrapper";function xwo(t){let{components:e,...n}=t;return(0,s.kt)(Cwo,(0,p.Z)({},Two,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}xwo.isMDXComponent=!0;const gwo={toc:[]},vwo="wrapper";function Lwo(t){let{components:e,...n}=t;return(0,s.kt)(vwo,(0,p.Z)({},gwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}Lwo.isMDXComponent=!0;const Zwo={toc:[]},bwo="wrapper";function Nwo(t){let{components:e,...n}=t;return(0,s.kt)(bwo,(0,p.Z)({},Zwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Nwo.isMDXComponent=!0;const zwo={toc:[]},Awo="wrapper";function Pwo(t){let{components:e,...n}=t;return(0,s.kt)(Awo,(0,p.Z)({},zwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Pwo.isMDXComponent=!0;const Wwo={toc:[]},Rwo="wrapper";function Iwo(t){let{components:e,...n}=t;return(0,s.kt)(Rwo,(0,p.Z)({},Wwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Iwo.isMDXComponent=!0;const Swo={toc:[]},Bwo="wrapper";function Gwo(t){let{components:e,...n}=t;return(0,s.kt)(Bwo,(0,p.Z)({},Swo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Gwo.isMDXComponent=!0;const Ewo={toc:[]},Owo="wrapper";function Fwo(t){let{components:e,...n}=t;return(0,s.kt)(Owo,(0,p.Z)({},Ewo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}Fwo.isMDXComponent=!0;const Uwo={toc:[]},Vwo="wrapper";function qwo(t){let{components:e,...n}=t;return(0,s.kt)(Vwo,(0,p.Z)({},Uwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}qwo.isMDXComponent=!0;const jwo={toc:[]},Ywo="wrapper";function Qwo(t){let{components:e,...n}=t;return(0,s.kt)(Ywo,(0,p.Z)({},jwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}Qwo.isMDXComponent=!0;const Hwo={toc:[]},Kwo="wrapper";function $wo(t){let{components:e,...n}=t;return(0,s.kt)(Kwo,(0,p.Z)({},Hwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$wo.isMDXComponent=!0;const Jwo={toc:[]},tTo="wrapper";function eTo(t){let{components:e,...n}=t;return(0,s.kt)(tTo,(0,p.Z)({},Jwo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}eTo.isMDXComponent=!0;const nTo={toc:[]},oTo="wrapper";function pTo(t){let{components:e,...n}=t;return(0,s.kt)(oTo,(0,p.Z)({},nTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}pTo.isMDXComponent=!0;const rTo={toc:[]},sTo="wrapper";function cTo(t){let{components:e,...n}=t;return(0,s.kt)(sTo,(0,p.Z)({},rTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}cTo.isMDXComponent=!0;const aTo={toc:[]},iTo="wrapper";function lTo(t){let{components:e,...n}=t;return(0,s.kt)(iTo,(0,p.Z)({},aTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}lTo.isMDXComponent=!0;const uTo={toc:[]},mTo="wrapper";function dTo(t){let{components:e,...n}=t;return(0,s.kt)(mTo,(0,p.Z)({},uTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}dTo.isMDXComponent=!0;const hTo={toc:[]},fTo="wrapper";function kTo(t){let{components:e,...n}=t;return(0,s.kt)(fTo,(0,p.Z)({},hTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}kTo.isMDXComponent=!0;const yTo={toc:[]},DTo="wrapper";function MTo(t){let{components:e,...n}=t;return(0,s.kt)(DTo,(0,p.Z)({},yTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}MTo.isMDXComponent=!0;const XTo={toc:[]},_To="wrapper";function wTo(t){let{components:e,...n}=t;return(0,s.kt)(_To,(0,p.Z)({},XTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}wTo.isMDXComponent=!0;const TTo={toc:[]},CTo="wrapper";function xTo(t){let{components:e,...n}=t;return(0,s.kt)(CTo,(0,p.Z)({},TTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}xTo.isMDXComponent=!0;const gTo={toc:[]},vTo="wrapper";function LTo(t){let{components:e,...n}=t;return(0,s.kt)(vTo,(0,p.Z)({},gTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}LTo.isMDXComponent=!0;const ZTo={toc:[]},bTo="wrapper";function NTo(t){let{components:e,...n}=t;return(0,s.kt)(bTo,(0,p.Z)({},ZTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}NTo.isMDXComponent=!0;const zTo={toc:[]},ATo="wrapper";function PTo(t){let{components:e,...n}=t;return(0,s.kt)(ATo,(0,p.Z)({},zTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}PTo.isMDXComponent=!0;const WTo={toc:[]},RTo="wrapper";function ITo(t){let{components:e,...n}=t;return(0,s.kt)(RTo,(0,p.Z)({},WTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}ITo.isMDXComponent=!0;const STo={toc:[]},BTo="wrapper";function GTo(t){let{components:e,...n}=t;return(0,s.kt)(BTo,(0,p.Z)({},STo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}GTo.isMDXComponent=!0;const ETo={toc:[]},OTo="wrapper";function FTo(t){let{components:e,...n}=t;return(0,s.kt)(OTo,(0,p.Z)({},ETo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}FTo.isMDXComponent=!0;const UTo={toc:[]},VTo="wrapper";function qTo(t){let{components:e,...n}=t;return(0,s.kt)(VTo,(0,p.Z)({},UTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}qTo.isMDXComponent=!0;const jTo={toc:[]},YTo="wrapper";function QTo(t){let{components:e,...n}=t;return(0,s.kt)(YTo,(0,p.Z)({},jTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}QTo.isMDXComponent=!0;const HTo={toc:[]},KTo="wrapper";function $To(t){let{components:e,...n}=t;return(0,s.kt)(KTo,(0,p.Z)({},HTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}$To.isMDXComponent=!0;const JTo={toc:[]},tCo="wrapper";function eCo(t){let{components:e,...n}=t;return(0,s.kt)(tCo,(0,p.Z)({},JTo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}eCo.isMDXComponent=!0;const nCo={toc:[]},oCo="wrapper";function pCo(t){let{components:e,...n}=t;return(0,s.kt)(oCo,(0,p.Z)({},nCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}pCo.isMDXComponent=!0;const rCo={toc:[]},sCo="wrapper";function cCo(t){let{components:e,...n}=t;return(0,s.kt)(sCo,(0,p.Z)({},rCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}cCo.isMDXComponent=!0;const aCo={toc:[]},iCo="wrapper";function lCo(t){let{components:e,...n}=t;return(0,s.kt)(iCo,(0,p.Z)({},aCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}lCo.isMDXComponent=!0;const uCo={toc:[]},mCo="wrapper";function dCo(t){let{components:e,...n}=t;return(0,s.kt)(mCo,(0,p.Z)({},uCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}dCo.isMDXComponent=!0;const hCo={toc:[]},fCo="wrapper";function kCo(t){let{components:e,...n}=t;return(0,s.kt)(fCo,(0,p.Z)({},hCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}kCo.isMDXComponent=!0;const yCo={toc:[]},DCo="wrapper";function MCo(t){let{components:e,...n}=t;return(0,s.kt)(DCo,(0,p.Z)({},yCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}MCo.isMDXComponent=!0;const XCo={toc:[]},_Co="wrapper";function wCo(t){let{components:e,...n}=t;return(0,s.kt)(_Co,(0,p.Z)({},XCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}wCo.isMDXComponent=!0;const TCo={toc:[]},CCo="wrapper";function xCo(t){let{components:e,...n}=t;return(0,s.kt)(CCo,(0,p.Z)({},TCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}xCo.isMDXComponent=!0;const gCo={toc:[]},vCo="wrapper";function LCo(t){let{components:e,...n}=t;return(0,s.kt)(vCo,(0,p.Z)({},gCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}LCo.isMDXComponent=!0;const ZCo={toc:[]},bCo="wrapper";function NCo(t){let{components:e,...n}=t;return(0,s.kt)(bCo,(0,p.Z)({},ZCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}NCo.isMDXComponent=!0;const zCo={toc:[]},ACo="wrapper";function PCo(t){let{components:e,...n}=t;return(0,s.kt)(ACo,(0,p.Z)({},zCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}PCo.isMDXComponent=!0;const WCo={toc:[]},RCo="wrapper";function ICo(t){let{components:e,...n}=t;return(0,s.kt)(RCo,(0,p.Z)({},WCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}ICo.isMDXComponent=!0;const SCo={toc:[]},BCo="wrapper";function GCo(t){let{components:e,...n}=t;return(0,s.kt)(BCo,(0,p.Z)({},SCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}GCo.isMDXComponent=!0;const ECo={toc:[]},OCo="wrapper";function FCo(t){let{components:e,...n}=t;return(0,s.kt)(OCo,(0,p.Z)({},ECo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}FCo.isMDXComponent=!0;const UCo={toc:[]},VCo="wrapper";function qCo(t){let{components:e,...n}=t;return(0,s.kt)(VCo,(0,p.Z)({},UCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}qCo.isMDXComponent=!0;const jCo={toc:[]},YCo="wrapper";function QCo(t){let{components:e,...n}=t;return(0,s.kt)(YCo,(0,p.Z)({},jCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}QCo.isMDXComponent=!0;const HCo={toc:[]},KCo="wrapper";function $Co(t){let{components:e,...n}=t;return(0,s.kt)(KCo,(0,p.Z)({},HCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}$Co.isMDXComponent=!0;const JCo={toc:[]},txo="wrapper";function exo(t){let{components:e,...n}=t;return(0,s.kt)(txo,(0,p.Z)({},JCo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}exo.isMDXComponent=!0;const nxo={toc:[]},oxo="wrapper";function pxo(t){let{components:e,...n}=t;return(0,s.kt)(oxo,(0,p.Z)({},nxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}pxo.isMDXComponent=!0;const rxo={toc:[]},sxo="wrapper";function cxo(t){let{components:e,...n}=t;return(0,s.kt)(sxo,(0,p.Z)({},rxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}cxo.isMDXComponent=!0;const axo={toc:[]},ixo="wrapper";function lxo(t){let{components:e,...n}=t;return(0,s.kt)(ixo,(0,p.Z)({},axo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}lxo.isMDXComponent=!0;const uxo={toc:[]},mxo="wrapper";function dxo(t){let{components:e,...n}=t;return(0,s.kt)(mxo,(0,p.Z)({},uxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}dxo.isMDXComponent=!0;const hxo={toc:[]},fxo="wrapper";function kxo(t){let{components:e,...n}=t;return(0,s.kt)(fxo,(0,p.Z)({},hxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}kxo.isMDXComponent=!0;const yxo={toc:[]},Dxo="wrapper";function Mxo(t){let{components:e,...n}=t;return(0,s.kt)(Dxo,(0,p.Z)({},yxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}Mxo.isMDXComponent=!0;const Xxo={toc:[]},_xo="wrapper";function wxo(t){let{components:e,...n}=t;return(0,s.kt)(_xo,(0,p.Z)({},Xxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}wxo.isMDXComponent=!0;const Txo={toc:[]},Cxo="wrapper";function xxo(t){let{components:e,...n}=t;return(0,s.kt)(Cxo,(0,p.Z)({},Txo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}xxo.isMDXComponent=!0;const gxo={toc:[]},vxo="wrapper";function Lxo(t){let{components:e,...n}=t;return(0,s.kt)(vxo,(0,p.Z)({},gxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}Lxo.isMDXComponent=!0;const Zxo={toc:[]},bxo="wrapper";function Nxo(t){let{components:e,...n}=t;return(0,s.kt)(bxo,(0,p.Z)({},Zxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Nxo.isMDXComponent=!0;const zxo={toc:[]},Axo="wrapper";function Pxo(t){let{components:e,...n}=t;return(0,s.kt)(Axo,(0,p.Z)({},zxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}Pxo.isMDXComponent=!0;const Wxo={toc:[]},Rxo="wrapper";function Ixo(t){let{components:e,...n}=t;return(0,s.kt)(Rxo,(0,p.Z)({},Wxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ixo.isMDXComponent=!0;const Sxo={toc:[]},Bxo="wrapper";function Gxo(t){let{components:e,...n}=t;return(0,s.kt)(Bxo,(0,p.Z)({},Sxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Gxo.isMDXComponent=!0;const Exo={toc:[]},Oxo="wrapper";function Fxo(t){let{components:e,...n}=t;return(0,s.kt)(Oxo,(0,p.Z)({},Exo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Fxo.isMDXComponent=!0;const Uxo={toc:[]},Vxo="wrapper";function qxo(t){let{components:e,...n}=t;return(0,s.kt)(Vxo,(0,p.Z)({},Uxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}qxo.isMDXComponent=!0;const jxo={toc:[]},Yxo="wrapper";function Qxo(t){let{components:e,...n}=t;return(0,s.kt)(Yxo,(0,p.Z)({},jxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Qxo.isMDXComponent=!0;const Hxo={toc:[]},Kxo="wrapper";function $xo(t){let{components:e,...n}=t;return(0,s.kt)(Kxo,(0,p.Z)({},Hxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}$xo.isMDXComponent=!0;const Jxo={toc:[]},tgo="wrapper";function ego(t){let{components:e,...n}=t;return(0,s.kt)(tgo,(0,p.Z)({},Jxo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}ego.isMDXComponent=!0;const ngo={toc:[]},ogo="wrapper";function pgo(t){let{components:e,...n}=t;return(0,s.kt)(ogo,(0,p.Z)({},ngo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}pgo.isMDXComponent=!0;const rgo={toc:[]},sgo="wrapper";function cgo(t){let{components:e,...n}=t;return(0,s.kt)(sgo,(0,p.Z)({},rgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}cgo.isMDXComponent=!0;const ago={toc:[]},igo="wrapper";function lgo(t){let{components:e,...n}=t;return(0,s.kt)(igo,(0,p.Z)({},ago,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}lgo.isMDXComponent=!0;const ugo={toc:[]},mgo="wrapper";function dgo(t){let{components:e,...n}=t;return(0,s.kt)(mgo,(0,p.Z)({},ugo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}dgo.isMDXComponent=!0;const hgo={toc:[]},fgo="wrapper";function kgo(t){let{components:e,...n}=t;return(0,s.kt)(fgo,(0,p.Z)({},hgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}kgo.isMDXComponent=!0;const ygo={toc:[]},Dgo="wrapper";function Mgo(t){let{components:e,...n}=t;return(0,s.kt)(Dgo,(0,p.Z)({},ygo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}Mgo.isMDXComponent=!0;const Xgo={toc:[]},_go="wrapper";function wgo(t){let{components:e,...n}=t;return(0,s.kt)(_go,(0,p.Z)({},Xgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}wgo.isMDXComponent=!0;const Tgo={toc:[]},Cgo="wrapper";function xgo(t){let{components:e,...n}=t;return(0,s.kt)(Cgo,(0,p.Z)({},Tgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}xgo.isMDXComponent=!0;const ggo={toc:[]},vgo="wrapper";function Lgo(t){let{components:e,...n}=t;return(0,s.kt)(vgo,(0,p.Z)({},ggo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Lgo.isMDXComponent=!0;const Zgo={toc:[]},bgo="wrapper";function Ngo(t){let{components:e,...n}=t;return(0,s.kt)(bgo,(0,p.Z)({},Zgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Ngo.isMDXComponent=!0;const zgo={toc:[]},Ago="wrapper";function Pgo(t){let{components:e,...n}=t;return(0,s.kt)(Ago,(0,p.Z)({},zgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Pgo.isMDXComponent=!0;const Wgo={toc:[]},Rgo="wrapper";function Igo(t){let{components:e,...n}=t;return(0,s.kt)(Rgo,(0,p.Z)({},Wgo,n,{components:e,mdxType:"MDXLayout"}))}Igo.isMDXComponent=!0;const Sgo={toc:[]},Bgo="wrapper";function Ggo(t){let{components:e,...n}=t;return(0,s.kt)(Bgo,(0,p.Z)({},Sgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Ggo.isMDXComponent=!0;const Ego={toc:[]},Ogo="wrapper";function Fgo(t){let{components:e,...n}=t;return(0,s.kt)(Ogo,(0,p.Z)({},Ego,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Fgo.isMDXComponent=!0;const Ugo={toc:[]},Vgo="wrapper";function qgo(t){let{components:e,...n}=t;return(0,s.kt)(Vgo,(0,p.Z)({},Ugo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}qgo.isMDXComponent=!0;const jgo={toc:[]},Ygo="wrapper";function Qgo(t){let{components:e,...n}=t;return(0,s.kt)(Ygo,(0,p.Z)({},jgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}Qgo.isMDXComponent=!0;const Hgo={toc:[]},Kgo="wrapper";function $go(t){let{components:e,...n}=t;return(0,s.kt)(Kgo,(0,p.Z)({},Hgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}$go.isMDXComponent=!0;const Jgo={toc:[]},tvo="wrapper";function evo(t){let{components:e,...n}=t;return(0,s.kt)(tvo,(0,p.Z)({},Jgo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}evo.isMDXComponent=!0;const nvo={toc:[]},ovo="wrapper";function pvo(t){let{components:e,...n}=t;return(0,s.kt)(ovo,(0,p.Z)({},nvo,n,{components:e,mdxType:"MDXLayout"}))}pvo.isMDXComponent=!0;const rvo={toc:[]},svo="wrapper";function cvo(t){let{components:e,...n}=t;return(0,s.kt)(svo,(0,p.Z)({},rvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}cvo.isMDXComponent=!0;const avo={toc:[]},ivo="wrapper";function lvo(t){let{components:e,...n}=t;return(0,s.kt)(ivo,(0,p.Z)({},avo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}lvo.isMDXComponent=!0;const uvo={toc:[]},mvo="wrapper";function dvo(t){let{components:e,...n}=t;return(0,s.kt)(mvo,(0,p.Z)({},uvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}dvo.isMDXComponent=!0;const hvo={toc:[]},fvo="wrapper";function kvo(t){let{components:e,...n}=t;return(0,s.kt)(fvo,(0,p.Z)({},hvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}kvo.isMDXComponent=!0;const yvo={toc:[]},Dvo="wrapper";function Mvo(t){let{components:e,...n}=t;return(0,s.kt)(Dvo,(0,p.Z)({},yvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}Mvo.isMDXComponent=!0;const Xvo={toc:[]},_vo="wrapper";function wvo(t){let{components:e,...n}=t;return(0,s.kt)(_vo,(0,p.Z)({},Xvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}wvo.isMDXComponent=!0;const Tvo={toc:[]},Cvo="wrapper";function xvo(t){let{components:e,...n}=t;return(0,s.kt)(Cvo,(0,p.Z)({},Tvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}xvo.isMDXComponent=!0;const gvo={toc:[]},vvo="wrapper";function Lvo(t){let{components:e,...n}=t;return(0,s.kt)(vvo,(0,p.Z)({},gvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Lvo.isMDXComponent=!0;const Zvo={toc:[]},bvo="wrapper";function Nvo(t){let{components:e,...n}=t;return(0,s.kt)(bvo,(0,p.Z)({},Zvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}Nvo.isMDXComponent=!0;const zvo={toc:[]},Avo="wrapper";function Pvo(t){let{components:e,...n}=t;return(0,s.kt)(Avo,(0,p.Z)({},zvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}Pvo.isMDXComponent=!0;const Wvo={toc:[]},Rvo="wrapper";function Ivo(t){let{components:e,...n}=t;return(0,s.kt)(Rvo,(0,p.Z)({},Wvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}Ivo.isMDXComponent=!0;const Svo={toc:[]},Bvo="wrapper";function Gvo(t){let{components:e,...n}=t;return(0,s.kt)(Bvo,(0,p.Z)({},Svo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}Gvo.isMDXComponent=!0;const Evo={toc:[]},Ovo="wrapper";function Fvo(t){let{components:e,...n}=t;return(0,s.kt)(Ovo,(0,p.Z)({},Evo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}Fvo.isMDXComponent=!0;const Uvo={toc:[]},Vvo="wrapper";function qvo(t){let{components:e,...n}=t;return(0,s.kt)(Vvo,(0,p.Z)({},Uvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}qvo.isMDXComponent=!0;const jvo={toc:[]},Yvo="wrapper";function Qvo(t){let{components:e,...n}=t;return(0,s.kt)(Yvo,(0,p.Z)({},jvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}Qvo.isMDXComponent=!0;const Hvo={toc:[]},Kvo="wrapper";function $vo(t){let{components:e,...n}=t;return(0,s.kt)(Kvo,(0,p.Z)({},Hvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}$vo.isMDXComponent=!0;const Jvo={toc:[]},tLo="wrapper";function eLo(t){let{components:e,...n}=t;return(0,s.kt)(tLo,(0,p.Z)({},Jvo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}eLo.isMDXComponent=!0;const nLo={toc:[]},oLo="wrapper";function pLo(t){let{components:e,...n}=t;return(0,s.kt)(oLo,(0,p.Z)({},nLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}pLo.isMDXComponent=!0;const rLo={toc:[]},sLo="wrapper";function cLo(t){let{components:e,...n}=t;return(0,s.kt)(sLo,(0,p.Z)({},rLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}cLo.isMDXComponent=!0;const aLo={toc:[]},iLo="wrapper";function lLo(t){let{components:e,...n}=t;return(0,s.kt)(iLo,(0,p.Z)({},aLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}lLo.isMDXComponent=!0;const uLo={toc:[]},mLo="wrapper";function dLo(t){let{components:e,...n}=t;return(0,s.kt)(mLo,(0,p.Z)({},uLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}dLo.isMDXComponent=!0;const hLo={toc:[]},fLo="wrapper";function kLo(t){let{components:e,...n}=t;return(0,s.kt)(fLo,(0,p.Z)({},hLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}kLo.isMDXComponent=!0;const yLo={toc:[]},DLo="wrapper";function MLo(t){let{components:e,...n}=t;return(0,s.kt)(DLo,(0,p.Z)({},yLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}MLo.isMDXComponent=!0;const XLo={toc:[]},_Lo="wrapper";function wLo(t){let{components:e,...n}=t;return(0,s.kt)(_Lo,(0,p.Z)({},XLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}wLo.isMDXComponent=!0;const TLo={toc:[]},CLo="wrapper";function xLo(t){let{components:e,...n}=t;return(0,s.kt)(CLo,(0,p.Z)({},TLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}xLo.isMDXComponent=!0;const gLo={toc:[]},vLo="wrapper";function LLo(t){let{components:e,...n}=t;return(0,s.kt)(vLo,(0,p.Z)({},gLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}LLo.isMDXComponent=!0;const ZLo={toc:[]},bLo="wrapper";function NLo(t){let{components:e,...n}=t;return(0,s.kt)(bLo,(0,p.Z)({},ZLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}NLo.isMDXComponent=!0;const zLo={toc:[]},ALo="wrapper";function PLo(t){let{components:e,...n}=t;return(0,s.kt)(ALo,(0,p.Z)({},zLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}PLo.isMDXComponent=!0;const WLo={toc:[]},RLo="wrapper";function ILo(t){let{components:e,...n}=t;return(0,s.kt)(RLo,(0,p.Z)({},WLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}ILo.isMDXComponent=!0;const SLo={toc:[]},BLo="wrapper";function GLo(t){let{components:e,...n}=t;return(0,s.kt)(BLo,(0,p.Z)({},SLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}GLo.isMDXComponent=!0;const ELo={toc:[]},OLo="wrapper";function FLo(t){let{components:e,...n}=t;return(0,s.kt)(OLo,(0,p.Z)({},ELo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}FLo.isMDXComponent=!0;const ULo={toc:[]},VLo="wrapper";function qLo(t){let{components:e,...n}=t;return(0,s.kt)(VLo,(0,p.Z)({},ULo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}qLo.isMDXComponent=!0;const jLo={toc:[]},YLo="wrapper";function QLo(t){let{components:e,...n}=t;return(0,s.kt)(YLo,(0,p.Z)({},jLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}QLo.isMDXComponent=!0;const HLo={toc:[]},KLo="wrapper";function $Lo(t){let{components:e,...n}=t;return(0,s.kt)(KLo,(0,p.Z)({},HLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}$Lo.isMDXComponent=!0;const JLo={toc:[]},tZo="wrapper";function eZo(t){let{components:e,...n}=t;return(0,s.kt)(tZo,(0,p.Z)({},JLo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}eZo.isMDXComponent=!0;const nZo={toc:[]},oZo="wrapper";function pZo(t){let{components:e,...n}=t;return(0,s.kt)(oZo,(0,p.Z)({},nZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}pZo.isMDXComponent=!0;const rZo={toc:[]},sZo="wrapper";function cZo(t){let{components:e,...n}=t;return(0,s.kt)(sZo,(0,p.Z)({},rZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}cZo.isMDXComponent=!0;const aZo={toc:[]},iZo="wrapper";function lZo(t){let{components:e,...n}=t;return(0,s.kt)(iZo,(0,p.Z)({},aZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}lZo.isMDXComponent=!0;const uZo={toc:[]},mZo="wrapper";function dZo(t){let{components:e,...n}=t;return(0,s.kt)(mZo,(0,p.Z)({},uZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dZo.isMDXComponent=!0;const hZo={toc:[]},fZo="wrapper";function kZo(t){let{components:e,...n}=t;return(0,s.kt)(fZo,(0,p.Z)({},hZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}kZo.isMDXComponent=!0;const yZo={toc:[]},DZo="wrapper";function MZo(t){let{components:e,...n}=t;return(0,s.kt)(DZo,(0,p.Z)({},yZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}MZo.isMDXComponent=!0;const XZo={toc:[]},_Zo="wrapper";function wZo(t){let{components:e,...n}=t;return(0,s.kt)(_Zo,(0,p.Z)({},XZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wZo.isMDXComponent=!0;const TZo={toc:[]},CZo="wrapper";function xZo(t){let{components:e,...n}=t;return(0,s.kt)(CZo,(0,p.Z)({},TZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}xZo.isMDXComponent=!0;const gZo={toc:[]},vZo="wrapper";function LZo(t){let{components:e,...n}=t;return(0,s.kt)(vZo,(0,p.Z)({},gZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}LZo.isMDXComponent=!0;const ZZo={toc:[]},bZo="wrapper";function NZo(t){let{components:e,...n}=t;return(0,s.kt)(bZo,(0,p.Z)({},ZZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NZo.isMDXComponent=!0;const zZo={toc:[]},AZo="wrapper";function PZo(t){let{components:e,...n}=t;return(0,s.kt)(AZo,(0,p.Z)({},zZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}PZo.isMDXComponent=!0;const WZo={toc:[]},RZo="wrapper";function IZo(t){let{components:e,...n}=t;return(0,s.kt)(RZo,(0,p.Z)({},WZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}IZo.isMDXComponent=!0;const SZo={toc:[]},BZo="wrapper";function GZo(t){let{components:e,...n}=t;return(0,s.kt)(BZo,(0,p.Z)({},SZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}GZo.isMDXComponent=!0;const EZo={toc:[]},OZo="wrapper";function FZo(t){let{components:e,...n}=t;return(0,s.kt)(OZo,(0,p.Z)({},EZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}FZo.isMDXComponent=!0;const UZo={toc:[]},VZo="wrapper";function qZo(t){let{components:e,...n}=t;return(0,s.kt)(VZo,(0,p.Z)({},UZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}qZo.isMDXComponent=!0;const jZo={toc:[]},YZo="wrapper";function QZo(t){let{components:e,...n}=t;return(0,s.kt)(YZo,(0,p.Z)({},jZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}QZo.isMDXComponent=!0;const HZo={toc:[]},KZo="wrapper";function $Zo(t){let{components:e,...n}=t;return(0,s.kt)(KZo,(0,p.Z)({},HZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}$Zo.isMDXComponent=!0;const JZo={toc:[]},tbo="wrapper";function ebo(t){let{components:e,...n}=t;return(0,s.kt)(tbo,(0,p.Z)({},JZo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}ebo.isMDXComponent=!0;const nbo={toc:[]},obo="wrapper";function pbo(t){let{components:e,...n}=t;return(0,s.kt)(obo,(0,p.Z)({},nbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pbo.isMDXComponent=!0;const rbo={toc:[]},sbo="wrapper";function cbo(t){let{components:e,...n}=t;return(0,s.kt)(sbo,(0,p.Z)({},rbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}cbo.isMDXComponent=!0;const abo={toc:[]},ibo="wrapper";function lbo(t){let{components:e,...n}=t;return(0,s.kt)(ibo,(0,p.Z)({},abo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}lbo.isMDXComponent=!0;const ubo={toc:[]},mbo="wrapper";function dbo(t){let{components:e,...n}=t;return(0,s.kt)(mbo,(0,p.Z)({},ubo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}dbo.isMDXComponent=!0;const hbo={toc:[]},fbo="wrapper";function kbo(t){let{components:e,...n}=t;return(0,s.kt)(fbo,(0,p.Z)({},hbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}kbo.isMDXComponent=!0;const ybo={toc:[]},Dbo="wrapper";function Mbo(t){let{components:e,...n}=t;return(0,s.kt)(Dbo,(0,p.Z)({},ybo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}Mbo.isMDXComponent=!0;const Xbo={toc:[]},_bo="wrapper";function wbo(t){let{components:e,...n}=t;return(0,s.kt)(_bo,(0,p.Z)({},Xbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}wbo.isMDXComponent=!0;const Tbo={toc:[]},Cbo="wrapper";function xbo(t){let{components:e,...n}=t;return(0,s.kt)(Cbo,(0,p.Z)({},Tbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}xbo.isMDXComponent=!0;const gbo={toc:[]},vbo="wrapper";function Lbo(t){let{components:e,...n}=t;return(0,s.kt)(vbo,(0,p.Z)({},gbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Lbo.isMDXComponent=!0;const Zbo={toc:[]},bbo="wrapper";function Nbo(t){let{components:e,...n}=t;return(0,s.kt)(bbo,(0,p.Z)({},Zbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Nbo.isMDXComponent=!0;const zbo={toc:[]},Abo="wrapper";function Pbo(t){let{components:e,...n}=t;return(0,s.kt)(Abo,(0,p.Z)({},zbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}Pbo.isMDXComponent=!0;const Wbo={toc:[]},Rbo="wrapper";function Ibo(t){let{components:e,...n}=t;return(0,s.kt)(Rbo,(0,p.Z)({},Wbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}Ibo.isMDXComponent=!0;const Sbo={toc:[]},Bbo="wrapper";function Gbo(t){let{components:e,...n}=t;return(0,s.kt)(Bbo,(0,p.Z)({},Sbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}Gbo.isMDXComponent=!0;const Ebo={toc:[]},Obo="wrapper";function Fbo(t){let{components:e,...n}=t;return(0,s.kt)(Obo,(0,p.Z)({},Ebo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}Fbo.isMDXComponent=!0;const Ubo={toc:[]},Vbo="wrapper";function qbo(t){let{components:e,...n}=t;return(0,s.kt)(Vbo,(0,p.Z)({},Ubo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}qbo.isMDXComponent=!0;const jbo={toc:[]},Ybo="wrapper";function Qbo(t){let{components:e,...n}=t;return(0,s.kt)(Ybo,(0,p.Z)({},jbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}Qbo.isMDXComponent=!0;const Hbo={toc:[]},Kbo="wrapper";function $bo(t){let{components:e,...n}=t;return(0,s.kt)(Kbo,(0,p.Z)({},Hbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}$bo.isMDXComponent=!0;const Jbo={toc:[]},tNo="wrapper";function eNo(t){let{components:e,...n}=t;return(0,s.kt)(tNo,(0,p.Z)({},Jbo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}eNo.isMDXComponent=!0;const nNo={toc:[]},oNo="wrapper";function pNo(t){let{components:e,...n}=t;return(0,s.kt)(oNo,(0,p.Z)({},nNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}pNo.isMDXComponent=!0;const rNo={toc:[]},sNo="wrapper";function cNo(t){let{components:e,...n}=t;return(0,s.kt)(sNo,(0,p.Z)({},rNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}cNo.isMDXComponent=!0;const aNo={toc:[]},iNo="wrapper";function lNo(t){let{components:e,...n}=t;return(0,s.kt)(iNo,(0,p.Z)({},aNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}lNo.isMDXComponent=!0;const uNo={toc:[]},mNo="wrapper";function dNo(t){let{components:e,...n}=t;return(0,s.kt)(mNo,(0,p.Z)({},uNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dNo.isMDXComponent=!0;const hNo={toc:[]},fNo="wrapper";function kNo(t){let{components:e,...n}=t;return(0,s.kt)(fNo,(0,p.Z)({},hNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}kNo.isMDXComponent=!0;const yNo={toc:[]},DNo="wrapper";function MNo(t){let{components:e,...n}=t;return(0,s.kt)(DNo,(0,p.Z)({},yNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}MNo.isMDXComponent=!0;const XNo={toc:[]},_No="wrapper";function wNo(t){let{components:e,...n}=t;return(0,s.kt)(_No,(0,p.Z)({},XNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}wNo.isMDXComponent=!0;const TNo={toc:[]},CNo="wrapper";function xNo(t){let{components:e,...n}=t;return(0,s.kt)(CNo,(0,p.Z)({},TNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}xNo.isMDXComponent=!0;const gNo={toc:[]},vNo="wrapper";function LNo(t){let{components:e,...n}=t;return(0,s.kt)(vNo,(0,p.Z)({},gNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}LNo.isMDXComponent=!0;const ZNo={toc:[]},bNo="wrapper";function NNo(t){let{components:e,...n}=t;return(0,s.kt)(bNo,(0,p.Z)({},ZNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}NNo.isMDXComponent=!0;const zNo={toc:[]},ANo="wrapper";function PNo(t){let{components:e,...n}=t;return(0,s.kt)(ANo,(0,p.Z)({},zNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}PNo.isMDXComponent=!0;const WNo={toc:[]},RNo="wrapper";function INo(t){let{components:e,...n}=t;return(0,s.kt)(RNo,(0,p.Z)({},WNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}INo.isMDXComponent=!0;const SNo={toc:[]},BNo="wrapper";function GNo(t){let{components:e,...n}=t;return(0,s.kt)(BNo,(0,p.Z)({},SNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}GNo.isMDXComponent=!0;const ENo={toc:[]},ONo="wrapper";function FNo(t){let{components:e,...n}=t;return(0,s.kt)(ONo,(0,p.Z)({},ENo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}FNo.isMDXComponent=!0;const UNo={toc:[]},VNo="wrapper";function qNo(t){let{components:e,...n}=t;return(0,s.kt)(VNo,(0,p.Z)({},UNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qNo.isMDXComponent=!0;const jNo={toc:[]},YNo="wrapper";function QNo(t){let{components:e,...n}=t;return(0,s.kt)(YNo,(0,p.Z)({},jNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}QNo.isMDXComponent=!0;const HNo={toc:[]},KNo="wrapper";function $No(t){let{components:e,...n}=t;return(0,s.kt)(KNo,(0,p.Z)({},HNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}$No.isMDXComponent=!0;const JNo={toc:[]},tzo="wrapper";function ezo(t){let{components:e,...n}=t;return(0,s.kt)(tzo,(0,p.Z)({},JNo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}ezo.isMDXComponent=!0;const nzo={toc:[]},ozo="wrapper";function pzo(t){let{components:e,...n}=t;return(0,s.kt)(ozo,(0,p.Z)({},nzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}pzo.isMDXComponent=!0;const rzo={toc:[]},szo="wrapper";function czo(t){let{components:e,...n}=t;return(0,s.kt)(szo,(0,p.Z)({},rzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}czo.isMDXComponent=!0;const azo={toc:[]},izo="wrapper";function lzo(t){let{components:e,...n}=t;return(0,s.kt)(izo,(0,p.Z)({},azo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}lzo.isMDXComponent=!0;const uzo={toc:[]},mzo="wrapper";function dzo(t){let{components:e,...n}=t;return(0,s.kt)(mzo,(0,p.Z)({},uzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}dzo.isMDXComponent=!0;const hzo={toc:[]},fzo="wrapper";function kzo(t){let{components:e,...n}=t;return(0,s.kt)(fzo,(0,p.Z)({},hzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}kzo.isMDXComponent=!0;const yzo={toc:[]},Dzo="wrapper";function Mzo(t){let{components:e,...n}=t;return(0,s.kt)(Dzo,(0,p.Z)({},yzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Mzo.isMDXComponent=!0;const Xzo={toc:[]},_zo="wrapper";function wzo(t){let{components:e,...n}=t;return(0,s.kt)(_zo,(0,p.Z)({},Xzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}wzo.isMDXComponent=!0;const Tzo={toc:[]},Czo="wrapper";function xzo(t){let{components:e,...n}=t;return(0,s.kt)(Czo,(0,p.Z)({},Tzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}xzo.isMDXComponent=!0;const gzo={toc:[]},vzo="wrapper";function Lzo(t){let{components:e,...n}=t;return(0,s.kt)(vzo,(0,p.Z)({},gzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Lzo.isMDXComponent=!0;const Zzo={toc:[]},bzo="wrapper";function Nzo(t){let{components:e,...n}=t;return(0,s.kt)(bzo,(0,p.Z)({},Zzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}Nzo.isMDXComponent=!0;const zzo={toc:[]},Azo="wrapper";function Pzo(t){let{components:e,...n}=t;return(0,s.kt)(Azo,(0,p.Z)({},zzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}Pzo.isMDXComponent=!0;const Wzo={toc:[]},Rzo="wrapper";function Izo(t){let{components:e,...n}=t;return(0,s.kt)(Rzo,(0,p.Z)({},Wzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}Izo.isMDXComponent=!0;const Szo={toc:[]},Bzo="wrapper";function Gzo(t){let{components:e,...n}=t;return(0,s.kt)(Bzo,(0,p.Z)({},Szo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Gzo.isMDXComponent=!0;const Ezo={toc:[]},Ozo="wrapper";function Fzo(t){let{components:e,...n}=t;return(0,s.kt)(Ozo,(0,p.Z)({},Ezo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}Fzo.isMDXComponent=!0;const Uzo={toc:[]},Vzo="wrapper";function qzo(t){let{components:e,...n}=t;return(0,s.kt)(Vzo,(0,p.Z)({},Uzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}qzo.isMDXComponent=!0;const jzo={toc:[]},Yzo="wrapper";function Qzo(t){let{components:e,...n}=t;return(0,s.kt)(Yzo,(0,p.Z)({},jzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}Qzo.isMDXComponent=!0;const Hzo={toc:[]},Kzo="wrapper";function $zo(t){let{components:e,...n}=t;return(0,s.kt)(Kzo,(0,p.Z)({},Hzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}$zo.isMDXComponent=!0;const Jzo={toc:[]},tAo="wrapper";function eAo(t){let{components:e,...n}=t;return(0,s.kt)(tAo,(0,p.Z)({},Jzo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}eAo.isMDXComponent=!0;const nAo={toc:[]},oAo="wrapper";function pAo(t){let{components:e,...n}=t;return(0,s.kt)(oAo,(0,p.Z)({},nAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}pAo.isMDXComponent=!0;const rAo={toc:[]},sAo="wrapper";function cAo(t){let{components:e,...n}=t;return(0,s.kt)(sAo,(0,p.Z)({},rAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}cAo.isMDXComponent=!0;const aAo={toc:[]},iAo="wrapper";function lAo(t){let{components:e,...n}=t;return(0,s.kt)(iAo,(0,p.Z)({},aAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}lAo.isMDXComponent=!0;const uAo={toc:[]},mAo="wrapper";function dAo(t){let{components:e,...n}=t;return(0,s.kt)(mAo,(0,p.Z)({},uAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}dAo.isMDXComponent=!0;const hAo={toc:[]},fAo="wrapper";function kAo(t){let{components:e,...n}=t;return(0,s.kt)(fAo,(0,p.Z)({},hAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}kAo.isMDXComponent=!0;const yAo={toc:[]},DAo="wrapper";function MAo(t){let{components:e,...n}=t;return(0,s.kt)(DAo,(0,p.Z)({},yAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}MAo.isMDXComponent=!0;const XAo={toc:[]},_Ao="wrapper";function wAo(t){let{components:e,...n}=t;return(0,s.kt)(_Ao,(0,p.Z)({},XAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}wAo.isMDXComponent=!0;const TAo={toc:[]},CAo="wrapper";function xAo(t){let{components:e,...n}=t;return(0,s.kt)(CAo,(0,p.Z)({},TAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}xAo.isMDXComponent=!0;const gAo={toc:[]},vAo="wrapper";function LAo(t){let{components:e,...n}=t;return(0,s.kt)(vAo,(0,p.Z)({},gAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}LAo.isMDXComponent=!0;const ZAo={toc:[]},bAo="wrapper";function NAo(t){let{components:e,...n}=t;return(0,s.kt)(bAo,(0,p.Z)({},ZAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}NAo.isMDXComponent=!0;const zAo={toc:[]},AAo="wrapper";function PAo(t){let{components:e,...n}=t;return(0,s.kt)(AAo,(0,p.Z)({},zAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}PAo.isMDXComponent=!0;const WAo={toc:[]},RAo="wrapper";function IAo(t){let{components:e,...n}=t;return(0,s.kt)(RAo,(0,p.Z)({},WAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}IAo.isMDXComponent=!0;const SAo={toc:[]},BAo="wrapper";function GAo(t){let{components:e,...n}=t;return(0,s.kt)(BAo,(0,p.Z)({},SAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}GAo.isMDXComponent=!0;const EAo={toc:[]},OAo="wrapper";function FAo(t){let{components:e,...n}=t;return(0,s.kt)(OAo,(0,p.Z)({},EAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}FAo.isMDXComponent=!0;const UAo={toc:[]},VAo="wrapper";function qAo(t){let{components:e,...n}=t;return(0,s.kt)(VAo,(0,p.Z)({},UAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}qAo.isMDXComponent=!0;const jAo={toc:[]},YAo="wrapper";function QAo(t){let{components:e,...n}=t;return(0,s.kt)(YAo,(0,p.Z)({},jAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}QAo.isMDXComponent=!0;const HAo={toc:[]},KAo="wrapper";function $Ao(t){let{components:e,...n}=t;return(0,s.kt)(KAo,(0,p.Z)({},HAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}$Ao.isMDXComponent=!0;const JAo={toc:[]},tPo="wrapper";function ePo(t){let{components:e,...n}=t;return(0,s.kt)(tPo,(0,p.Z)({},JAo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}ePo.isMDXComponent=!0;const nPo={toc:[]},oPo="wrapper";function pPo(t){let{components:e,...n}=t;return(0,s.kt)(oPo,(0,p.Z)({},nPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}pPo.isMDXComponent=!0;const rPo={toc:[]},sPo="wrapper";function cPo(t){let{components:e,...n}=t;return(0,s.kt)(sPo,(0,p.Z)({},rPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}cPo.isMDXComponent=!0;const aPo={toc:[]},iPo="wrapper";function lPo(t){let{components:e,...n}=t;return(0,s.kt)(iPo,(0,p.Z)({},aPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}lPo.isMDXComponent=!0;const uPo={toc:[]},mPo="wrapper";function dPo(t){let{components:e,...n}=t;return(0,s.kt)(mPo,(0,p.Z)({},uPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}dPo.isMDXComponent=!0;const hPo={toc:[]},fPo="wrapper";function kPo(t){let{components:e,...n}=t;return(0,s.kt)(fPo,(0,p.Z)({},hPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}kPo.isMDXComponent=!0;const yPo={toc:[]},DPo="wrapper";function MPo(t){let{components:e,...n}=t;return(0,s.kt)(DPo,(0,p.Z)({},yPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}MPo.isMDXComponent=!0;const XPo={toc:[]},_Po="wrapper";function wPo(t){let{components:e,...n}=t;return(0,s.kt)(_Po,(0,p.Z)({},XPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}wPo.isMDXComponent=!0;const TPo={toc:[]},CPo="wrapper";function xPo(t){let{components:e,...n}=t;return(0,s.kt)(CPo,(0,p.Z)({},TPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}xPo.isMDXComponent=!0;const gPo={toc:[]},vPo="wrapper";function LPo(t){let{components:e,...n}=t;return(0,s.kt)(vPo,(0,p.Z)({},gPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}LPo.isMDXComponent=!0;const ZPo={toc:[]},bPo="wrapper";function NPo(t){let{components:e,...n}=t;return(0,s.kt)(bPo,(0,p.Z)({},ZPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}NPo.isMDXComponent=!0;const zPo={toc:[]},APo="wrapper";function PPo(t){let{components:e,...n}=t;return(0,s.kt)(APo,(0,p.Z)({},zPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}PPo.isMDXComponent=!0;const WPo={toc:[]},RPo="wrapper";function IPo(t){let{components:e,...n}=t;return(0,s.kt)(RPo,(0,p.Z)({},WPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}IPo.isMDXComponent=!0;const SPo={toc:[]},BPo="wrapper";function GPo(t){let{components:e,...n}=t;return(0,s.kt)(BPo,(0,p.Z)({},SPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Txt#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}GPo.isMDXComponent=!0;const EPo={toc:[]},OPo="wrapper";function FPo(t){let{components:e,...n}=t;return(0,s.kt)(OPo,(0,p.Z)({},EPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}FPo.isMDXComponent=!0;const UPo={toc:[]},VPo="wrapper";function qPo(t){let{components:e,...n}=t;return(0,s.kt)(VPo,(0,p.Z)({},UPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}qPo.isMDXComponent=!0;const jPo={toc:[]},YPo="wrapper";function QPo(t){let{components:e,...n}=t;return(0,s.kt)(YPo,(0,p.Z)({},jPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}QPo.isMDXComponent=!0;const HPo={toc:[]},KPo="wrapper";function $Po(t){let{components:e,...n}=t;return(0,s.kt)(KPo,(0,p.Z)({},HPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}$Po.isMDXComponent=!0;const JPo={toc:[]},tWo="wrapper";function eWo(t){let{components:e,...n}=t;return(0,s.kt)(tWo,(0,p.Z)({},JPo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}eWo.isMDXComponent=!0;const nWo={toc:[]},oWo="wrapper";function pWo(t){let{components:e,...n}=t;return(0,s.kt)(oWo,(0,p.Z)({},nWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}pWo.isMDXComponent=!0;const rWo={toc:[]},sWo="wrapper";function cWo(t){let{components:e,...n}=t;return(0,s.kt)(sWo,(0,p.Z)({},rWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut for"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Txt fontWeight={700} />\n")))}cWo.isMDXComponent=!0;const aWo={toc:[]},iWo="wrapper";function lWo(t){let{components:e,...n}=t;return(0,s.kt)(iWo,(0,p.Z)({},aWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a bold text node."))}lWo.isMDXComponent=!0;const uWo={toc:[]},mWo="wrapper";function dWo(t){let{components:e,...n}=t;return(0,s.kt)(mWo,(0,p.Z)({},uWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Additional text properties."))}dWo.isMDXComponent=!0;const hWo={toc:[]},fWo="wrapper";function kWo(t){let{components:e,...n}=t;return(0,s.kt)(fWo,(0,p.Z)({},hWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut for"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Txt fontStyle={'italic'} />\n")))}kWo.isMDXComponent=!0;const yWo={toc:[]},DWo="wrapper";function MWo(t){let{components:e,...n}=t;return(0,s.kt)(DWo,(0,p.Z)({},yWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an italic text node."))}MWo.isMDXComponent=!0;const XWo={toc:[]},_Wo="wrapper";function wWo(t){let{components:e,...n}=t;return(0,s.kt)(_Wo,(0,p.Z)({},XWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Additional text properties."))}wWo.isMDXComponent=!0;const TWo={toc:[]},CWo="wrapper";function xWo(t){let{components:e,...n}=t;return(0,s.kt)(CWo,(0,p.Z)({},TWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}xWo.isMDXComponent=!0;const gWo={toc:[]},vWo="wrapper";function LWo(t){let{components:e,...n}=t;return(0,s.kt)(vWo,(0,p.Z)({},gWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}LWo.isMDXComponent=!0;const ZWo={toc:[]},bWo="wrapper";function NWo(t){let{components:e,...n}=t;return(0,s.kt)(bWo,(0,p.Z)({},ZWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}NWo.isMDXComponent=!0;const zWo={toc:[]},AWo="wrapper";function PWo(t){let{components:e,...n}=t;return(0,s.kt)(AWo,(0,p.Z)({},zWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}PWo.isMDXComponent=!0;const WWo={toc:[]},RWo="wrapper";function IWo(t){let{components:e,...n}=t;return(0,s.kt)(RWo,(0,p.Z)({},WWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}IWo.isMDXComponent=!0;const SWo={toc:[]},BWo="wrapper";function GWo(t){let{components:e,...n}=t;return(0,s.kt)(BWo,(0,p.Z)({},SWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}GWo.isMDXComponent=!0;const EWo={toc:[]},OWo="wrapper";function FWo(t){let{components:e,...n}=t;return(0,s.kt)(OWo,(0,p.Z)({},EWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}FWo.isMDXComponent=!0;const UWo={toc:[]},VWo="wrapper";function qWo(t){let{components:e,...n}=t;return(0,s.kt)(VWo,(0,p.Z)({},UWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}qWo.isMDXComponent=!0;const jWo={toc:[]},YWo="wrapper";function QWo(t){let{components:e,...n}=t;return(0,s.kt)(YWo,(0,p.Z)({},jWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}QWo.isMDXComponent=!0;const HWo={toc:[]},KWo="wrapper";function $Wo(t){let{components:e,...n}=t;return(0,s.kt)(KWo,(0,p.Z)({},HWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}$Wo.isMDXComponent=!0;const JWo={toc:[]},tRo="wrapper";function eRo(t){let{components:e,...n}=t;return(0,s.kt)(tRo,(0,p.Z)({},JWo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}eRo.isMDXComponent=!0;const nRo={toc:[]},oRo="wrapper";function pRo(t){let{components:e,...n}=t;return(0,s.kt)(oRo,(0,p.Z)({},nRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}pRo.isMDXComponent=!0;const rRo={toc:[]},sRo="wrapper";function cRo(t){let{components:e,...n}=t;return(0,s.kt)(sRo,(0,p.Z)({},rRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}cRo.isMDXComponent=!0;const aRo={toc:[]},iRo="wrapper";function lRo(t){let{components:e,...n}=t;return(0,s.kt)(iRo,(0,p.Z)({},aRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}lRo.isMDXComponent=!0;const uRo={toc:[]},mRo="wrapper";function dRo(t){let{components:e,...n}=t;return(0,s.kt)(mRo,(0,p.Z)({},uRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}dRo.isMDXComponent=!0;const hRo={toc:[]},fRo="wrapper";function kRo(t){let{components:e,...n}=t;return(0,s.kt)(fRo,(0,p.Z)({},hRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kRo.isMDXComponent=!0;const yRo={toc:[]},DRo="wrapper";function MRo(t){let{components:e,...n}=t;return(0,s.kt)(DRo,(0,p.Z)({},yRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}MRo.isMDXComponent=!0;const XRo={toc:[]},_Ro="wrapper";function wRo(t){let{components:e,...n}=t;return(0,s.kt)(_Ro,(0,p.Z)({},XRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}wRo.isMDXComponent=!0;const TRo={toc:[]},CRo="wrapper";function xRo(t){let{components:e,...n}=t;return(0,s.kt)(CRo,(0,p.Z)({},TRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}xRo.isMDXComponent=!0;const gRo={toc:[]},vRo="wrapper";function LRo(t){let{components:e,...n}=t;return(0,s.kt)(vRo,(0,p.Z)({},gRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}LRo.isMDXComponent=!0;const ZRo={toc:[]},bRo="wrapper";function NRo(t){let{components:e,...n}=t;return(0,s.kt)(bRo,(0,p.Z)({},ZRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}NRo.isMDXComponent=!0;const zRo={toc:[]},ARo="wrapper";function PRo(t){let{components:e,...n}=t;return(0,s.kt)(ARo,(0,p.Z)({},zRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}PRo.isMDXComponent=!0;const WRo={toc:[]},RRo="wrapper";function IRo(t){let{components:e,...n}=t;return(0,s.kt)(RRo,(0,p.Z)({},WRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}IRo.isMDXComponent=!0;const SRo={toc:[]},BRo="wrapper";function GRo(t){let{components:e,...n}=t;return(0,s.kt)(BRo,(0,p.Z)({},SRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}GRo.isMDXComponent=!0;const ERo={toc:[]},ORo="wrapper";function FRo(t){let{components:e,...n}=t;return(0,s.kt)(ORo,(0,p.Z)({},ERo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}FRo.isMDXComponent=!0;const URo={toc:[]},VRo="wrapper";function qRo(t){let{components:e,...n}=t;return(0,s.kt)(VRo,(0,p.Z)({},URo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qRo.isMDXComponent=!0;const jRo={toc:[]},YRo="wrapper";function QRo(t){let{components:e,...n}=t;return(0,s.kt)(YRo,(0,p.Z)({},jRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}QRo.isMDXComponent=!0;const HRo={toc:[]},KRo="wrapper";function $Ro(t){let{components:e,...n}=t;return(0,s.kt)(KRo,(0,p.Z)({},HRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}$Ro.isMDXComponent=!0;const JRo={toc:[]},tIo="wrapper";function eIo(t){let{components:e,...n}=t;return(0,s.kt)(tIo,(0,p.Z)({},JRo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}eIo.isMDXComponent=!0;const nIo={toc:[]},oIo="wrapper";function pIo(t){let{components:e,...n}=t;return(0,s.kt)(oIo,(0,p.Z)({},nIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}pIo.isMDXComponent=!0;const rIo={toc:[]},sIo="wrapper";function cIo(t){let{components:e,...n}=t;return(0,s.kt)(sIo,(0,p.Z)({},rIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}cIo.isMDXComponent=!0;const aIo={toc:[]},iIo="wrapper";function lIo(t){let{components:e,...n}=t;return(0,s.kt)(iIo,(0,p.Z)({},aIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}lIo.isMDXComponent=!0;const uIo={toc:[]},mIo="wrapper";function dIo(t){let{components:e,...n}=t;return(0,s.kt)(mIo,(0,p.Z)({},uIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}dIo.isMDXComponent=!0;const hIo={toc:[]},fIo="wrapper";function kIo(t){let{components:e,...n}=t;return(0,s.kt)(fIo,(0,p.Z)({},hIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}kIo.isMDXComponent=!0;const yIo={toc:[]},DIo="wrapper";function MIo(t){let{components:e,...n}=t;return(0,s.kt)(DIo,(0,p.Z)({},yIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}MIo.isMDXComponent=!0;const XIo={toc:[]},_Io="wrapper";function wIo(t){let{components:e,...n}=t;return(0,s.kt)(_Io,(0,p.Z)({},XIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}wIo.isMDXComponent=!0;const TIo={toc:[]},CIo="wrapper";function xIo(t){let{components:e,...n}=t;return(0,s.kt)(CIo,(0,p.Z)({},TIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}xIo.isMDXComponent=!0;const gIo={toc:[]},vIo="wrapper";function LIo(t){let{components:e,...n}=t;return(0,s.kt)(vIo,(0,p.Z)({},gIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}LIo.isMDXComponent=!0;const ZIo={toc:[]},bIo="wrapper";function NIo(t){let{components:e,...n}=t;return(0,s.kt)(bIo,(0,p.Z)({},ZIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"1"))}NIo.isMDXComponent=!0;const zIo={toc:[]},AIo="wrapper";function PIo(t){let{components:e,...n}=t;return(0,s.kt)(AIo,(0,p.Z)({},zIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rate at which the video plays, as multiples of the normal speed."))}PIo.isMDXComponent=!0;const WIo={toc:[]},RIo="wrapper";function IIo(t){let{components:e,...n}=t;return(0,s.kt)(RIo,(0,p.Z)({},WIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}IIo.isMDXComponent=!0;const SIo={toc:[]},BIo="wrapper";function GIo(t){let{components:e,...n}=t;return(0,s.kt)(BIo,(0,p.Z)({},SIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}GIo.isMDXComponent=!0;const EIo={toc:[]},OIo="wrapper";function FIo(t){let{components:e,...n}=t;return(0,s.kt)(OIo,(0,p.Z)({},EIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}FIo.isMDXComponent=!0;const UIo={toc:[]},VIo="wrapper";function qIo(t){let{components:e,...n}=t;return(0,s.kt)(VIo,(0,p.Z)({},UIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}qIo.isMDXComponent=!0;const jIo={toc:[]},YIo="wrapper";function QIo(t){let{components:e,...n}=t;return(0,s.kt)(YIo,(0,p.Z)({},jIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}QIo.isMDXComponent=!0;const HIo={toc:[]},KIo="wrapper";function $Io(t){let{components:e,...n}=t;return(0,s.kt)(KIo,(0,p.Z)({},HIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}$Io.isMDXComponent=!0;const JIo={toc:[]},tSo="wrapper";function eSo(t){let{components:e,...n}=t;return(0,s.kt)(tSo,(0,p.Z)({},JIo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}eSo.isMDXComponent=!0;const nSo={toc:[]},oSo="wrapper";function pSo(t){let{components:e,...n}=t;return(0,s.kt)(oSo,(0,p.Z)({},nSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pSo.isMDXComponent=!0;const rSo={toc:[]},sSo="wrapper";function cSo(t){let{components:e,...n}=t;return(0,s.kt)(sSo,(0,p.Z)({},rSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}cSo.isMDXComponent=!0;const aSo={toc:[]},iSo="wrapper";function lSo(t){let{components:e,...n}=t;return(0,s.kt)(iSo,(0,p.Z)({},aSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}lSo.isMDXComponent=!0;const uSo={toc:[]},mSo="wrapper";function dSo(t){let{components:e,...n}=t;return(0,s.kt)(mSo,(0,p.Z)({},uSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}dSo.isMDXComponent=!0;const hSo={toc:[]},fSo="wrapper";function kSo(t){let{components:e,...n}=t;return(0,s.kt)(fSo,(0,p.Z)({},hSo,n,{components:e,mdxType:"MDXLayout"}))}kSo.isMDXComponent=!0;const ySo={toc:[]},DSo="wrapper";function MSo(t){let{components:e,...n}=t;return(0,s.kt)(DSo,(0,p.Z)({},ySo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}MSo.isMDXComponent=!0;const XSo={toc:[]},_So="wrapper";function wSo(t){let{components:e,...n}=t;return(0,s.kt)(_So,(0,p.Z)({},XSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}wSo.isMDXComponent=!0;const TSo={toc:[]},CSo="wrapper";function xSo(t){let{components:e,...n}=t;return(0,s.kt)(CSo,(0,p.Z)({},TSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}xSo.isMDXComponent=!0;const gSo={toc:[]},vSo="wrapper";function LSo(t){let{components:e,...n}=t;return(0,s.kt)(vSo,(0,p.Z)({},gSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}LSo.isMDXComponent=!0;const ZSo={toc:[]},bSo="wrapper";function NSo(t){let{components:e,...n}=t;return(0,s.kt)(bSo,(0,p.Z)({},ZSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}NSo.isMDXComponent=!0;const zSo={toc:[]},ASo="wrapper";function PSo(t){let{components:e,...n}=t;return(0,s.kt)(ASo,(0,p.Z)({},zSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}PSo.isMDXComponent=!0;const WSo={toc:[]},RSo="wrapper";function ISo(t){let{components:e,...n}=t;return(0,s.kt)(RSo,(0,p.Z)({},WSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}ISo.isMDXComponent=!0;const SSo={toc:[]},BSo="wrapper";function GSo(t){let{components:e,...n}=t;return(0,s.kt)(BSo,(0,p.Z)({},SSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}GSo.isMDXComponent=!0;const ESo={toc:[]},OSo="wrapper";function FSo(t){let{components:e,...n}=t;return(0,s.kt)(OSo,(0,p.Z)({},ESo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}FSo.isMDXComponent=!0;const USo={toc:[]},VSo="wrapper";function qSo(t){let{components:e,...n}=t;return(0,s.kt)(VSo,(0,p.Z)({},USo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"true"))}qSo.isMDXComponent=!0;const jSo={toc:[]},YSo="wrapper";function QSo(t){let{components:e,...n}=t;return(0,s.kt)(YSo,(0,p.Z)({},jSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}QSo.isMDXComponent=!0;const HSo={toc:[]},KSo="wrapper";function $So(t){let{components:e,...n}=t;return(0,s.kt)(KSo,(0,p.Z)({},HSo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}$So.isMDXComponent=!0;const JSo={toc:[]},tBo="wrapper";function eBo(t){let{components:e,...n}=t;return(0,s.kt)(tBo,(0,p.Z)({},JSo,n,{components:e,mdxType:"MDXLayout"}))}eBo.isMDXComponent=!0;const nBo={toc:[]},oBo="wrapper";function pBo(t){let{components:e,...n}=t;return(0,s.kt)(oBo,(0,p.Z)({},nBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Using a local video:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import video from './example.mp4';\n// ...\nview.add(<Video src={video} />)\n")),(0,s.kt)("p",null,"Loading an image from the internet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'view.add(<Video src="https://example.com/video.mp4" />)\n')))}pBo.isMDXComponent=!0;const rBo={toc:[]},sBo="wrapper";function cBo(t){let{components:e,...n}=t;return(0,s.kt)(sBo,(0,p.Z)({},rBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}cBo.isMDXComponent=!0;const aBo={toc:[]},iBo="wrapper";function lBo(t){let{components:e,...n}=t;return(0,s.kt)(iBo,(0,p.Z)({},aBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}lBo.isMDXComponent=!0;const uBo={toc:[]},mBo="wrapper";function dBo(t){let{components:e,...n}=t;return(0,s.kt)(mBo,(0,p.Z)({},uBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}dBo.isMDXComponent=!0;const hBo={toc:[]},fBo="wrapper";function kBo(t){let{components:e,...n}=t;return(0,s.kt)(fBo,(0,p.Z)({},hBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kBo.isMDXComponent=!0;const yBo={toc:[]},DBo="wrapper";function MBo(t){let{components:e,...n}=t;return(0,s.kt)(DBo,(0,p.Z)({},yBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}MBo.isMDXComponent=!0;const XBo={toc:[]},_Bo="wrapper";function wBo(t){let{components:e,...n}=t;return(0,s.kt)(_Bo,(0,p.Z)({},XBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}wBo.isMDXComponent=!0;const TBo={toc:[]},CBo="wrapper";function xBo(t){let{components:e,...n}=t;return(0,s.kt)(CBo,(0,p.Z)({},TBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}xBo.isMDXComponent=!0;const gBo={toc:[]},vBo="wrapper";function LBo(t){let{components:e,...n}=t;return(0,s.kt)(vBo,(0,p.Z)({},gBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}LBo.isMDXComponent=!0;const ZBo={toc:[]},bBo="wrapper";function NBo(t){let{components:e,...n}=t;return(0,s.kt)(bBo,(0,p.Z)({},ZBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}NBo.isMDXComponent=!0;const zBo={toc:[]},ABo="wrapper";function PBo(t){let{components:e,...n}=t;return(0,s.kt)(ABo,(0,p.Z)({},zBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}PBo.isMDXComponent=!0;const WBo={toc:[]},RBo="wrapper";function IBo(t){let{components:e,...n}=t;return(0,s.kt)(RBo,(0,p.Z)({},WBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}IBo.isMDXComponent=!0;const SBo={toc:[]},BBo="wrapper";function GBo(t){let{components:e,...n}=t;return(0,s.kt)(BBo,(0,p.Z)({},SBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}GBo.isMDXComponent=!0;const EBo={toc:[]},OBo="wrapper";function FBo(t){let{components:e,...n}=t;return(0,s.kt)(OBo,(0,p.Z)({},EBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}FBo.isMDXComponent=!0;const UBo={toc:[]},VBo="wrapper";function qBo(t){let{components:e,...n}=t;return(0,s.kt)(VBo,(0,p.Z)({},UBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}qBo.isMDXComponent=!0;const jBo={toc:[]},YBo="wrapper";function QBo(t){let{components:e,...n}=t;return(0,s.kt)(YBo,(0,p.Z)({},jBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}QBo.isMDXComponent=!0;const HBo={toc:[]},KBo="wrapper";function $Bo(t){let{components:e,...n}=t;return(0,s.kt)(KBo,(0,p.Z)({},HBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}$Bo.isMDXComponent=!0;const JBo={toc:[]},tGo="wrapper";function eGo(t){let{components:e,...n}=t;return(0,s.kt)(tGo,(0,p.Z)({},JBo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}eGo.isMDXComponent=!0;const nGo={toc:[]},oGo="wrapper";function pGo(t){let{components:e,...n}=t;return(0,s.kt)(oGo,(0,p.Z)({},nGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}pGo.isMDXComponent=!0;const rGo={toc:[]},sGo="wrapper";function cGo(t){let{components:e,...n}=t;return(0,s.kt)(sGo,(0,p.Z)({},rGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}cGo.isMDXComponent=!0;const aGo={toc:[]},iGo="wrapper";function lGo(t){let{components:e,...n}=t;return(0,s.kt)(iGo,(0,p.Z)({},aGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}lGo.isMDXComponent=!0;const uGo={toc:[]},mGo="wrapper";function dGo(t){let{components:e,...n}=t;return(0,s.kt)(mGo,(0,p.Z)({},uGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}dGo.isMDXComponent=!0;const hGo={toc:[]},fGo="wrapper";function kGo(t){let{components:e,...n}=t;return(0,s.kt)(fGo,(0,p.Z)({},hGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}kGo.isMDXComponent=!0;const yGo={toc:[]},DGo="wrapper";function MGo(t){let{components:e,...n}=t;return(0,s.kt)(DGo,(0,p.Z)({},yGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}MGo.isMDXComponent=!0;const XGo={toc:[]},_Go="wrapper";function wGo(t){let{components:e,...n}=t;return(0,s.kt)(_Go,(0,p.Z)({},XGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}wGo.isMDXComponent=!0;const TGo={toc:[]},CGo="wrapper";function xGo(t){let{components:e,...n}=t;return(0,s.kt)(CGo,(0,p.Z)({},TGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}xGo.isMDXComponent=!0;const gGo={toc:[]},vGo="wrapper";function LGo(t){let{components:e,...n}=t;return(0,s.kt)(vGo,(0,p.Z)({},gGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}LGo.isMDXComponent=!0;const ZGo={toc:[]},bGo="wrapper";function NGo(t){let{components:e,...n}=t;return(0,s.kt)(bGo,(0,p.Z)({},ZGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}NGo.isMDXComponent=!0;const zGo={toc:[]},AGo="wrapper";function PGo(t){let{components:e,...n}=t;return(0,s.kt)(AGo,(0,p.Z)({},zGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}PGo.isMDXComponent=!0;const WGo={toc:[]},RGo="wrapper";function IGo(t){let{components:e,...n}=t;return(0,s.kt)(RGo,(0,p.Z)({},WGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}IGo.isMDXComponent=!0;const SGo={toc:[]},BGo="wrapper";function GGo(t){let{components:e,...n}=t;return(0,s.kt)(BGo,(0,p.Z)({},SGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}GGo.isMDXComponent=!0;const EGo={toc:[]},OGo="wrapper";function FGo(t){let{components:e,...n}=t;return(0,s.kt)(OGo,(0,p.Z)({},EGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}FGo.isMDXComponent=!0;const UGo={toc:[]},VGo="wrapper";function qGo(t){let{components:e,...n}=t;return(0,s.kt)(VGo,(0,p.Z)({},UGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}qGo.isMDXComponent=!0;const jGo={toc:[]},YGo="wrapper";function QGo(t){let{components:e,...n}=t;return(0,s.kt)(YGo,(0,p.Z)({},jGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}QGo.isMDXComponent=!0;const HGo={toc:[]},KGo="wrapper";function $Go(t){let{components:e,...n}=t;return(0,s.kt)(KGo,(0,p.Z)({},HGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}$Go.isMDXComponent=!0;const JGo={toc:[]},tEo="wrapper";function eEo(t){let{components:e,...n}=t;return(0,s.kt)(tEo,(0,p.Z)({},JGo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}eEo.isMDXComponent=!0;const nEo={toc:[]},oEo="wrapper";function pEo(t){let{components:e,...n}=t;return(0,s.kt)(oEo,(0,p.Z)({},nEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}pEo.isMDXComponent=!0;const rEo={toc:[]},sEo="wrapper";function cEo(t){let{components:e,...n}=t;return(0,s.kt)(sEo,(0,p.Z)({},rEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}cEo.isMDXComponent=!0;const aEo={toc:[]},iEo="wrapper";function lEo(t){let{components:e,...n}=t;return(0,s.kt)(iEo,(0,p.Z)({},aEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}lEo.isMDXComponent=!0;const uEo={toc:[]},mEo="wrapper";function dEo(t){let{components:e,...n}=t;return(0,s.kt)(mEo,(0,p.Z)({},uEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}dEo.isMDXComponent=!0;const hEo={toc:[]},fEo="wrapper";function kEo(t){let{components:e,...n}=t;return(0,s.kt)(fEo,(0,p.Z)({},hEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}kEo.isMDXComponent=!0;const yEo={toc:[]},DEo="wrapper";function MEo(t){let{components:e,...n}=t;return(0,s.kt)(DEo,(0,p.Z)({},yEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}MEo.isMDXComponent=!0;const XEo={toc:[]},_Eo="wrapper";function wEo(t){let{components:e,...n}=t;return(0,s.kt)(_Eo,(0,p.Z)({},XEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}wEo.isMDXComponent=!0;const TEo={toc:[]},CEo="wrapper";function xEo(t){let{components:e,...n}=t;return(0,s.kt)(CEo,(0,p.Z)({},TEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}xEo.isMDXComponent=!0;const gEo={toc:[]},vEo="wrapper";function LEo(t){let{components:e,...n}=t;return(0,s.kt)(vEo,(0,p.Z)({},gEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}LEo.isMDXComponent=!0;const ZEo={toc:[]},bEo="wrapper";function NEo(t){let{components:e,...n}=t;return(0,s.kt)(bEo,(0,p.Z)({},ZEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}NEo.isMDXComponent=!0;const zEo={toc:[]},AEo="wrapper";function PEo(t){let{components:e,...n}=t;return(0,s.kt)(AEo,(0,p.Z)({},zEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}PEo.isMDXComponent=!0;const WEo={toc:[]},REo="wrapper";function IEo(t){let{components:e,...n}=t;return(0,s.kt)(REo,(0,p.Z)({},WEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}IEo.isMDXComponent=!0;const SEo={toc:[]},BEo="wrapper";function GEo(t){let{components:e,...n}=t;return(0,s.kt)(BEo,(0,p.Z)({},SEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}GEo.isMDXComponent=!0;const EEo={toc:[]},OEo="wrapper";function FEo(t){let{components:e,...n}=t;return(0,s.kt)(OEo,(0,p.Z)({},EEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}FEo.isMDXComponent=!0;const UEo={toc:[]},VEo="wrapper";function qEo(t){let{components:e,...n}=t;return(0,s.kt)(VEo,(0,p.Z)({},UEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}qEo.isMDXComponent=!0;const jEo={toc:[]},YEo="wrapper";function QEo(t){let{components:e,...n}=t;return(0,s.kt)(YEo,(0,p.Z)({},jEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}QEo.isMDXComponent=!0;const HEo={toc:[]},KEo="wrapper";function $Eo(t){let{components:e,...n}=t;return(0,s.kt)(KEo,(0,p.Z)({},HEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}$Eo.isMDXComponent=!0;const JEo={toc:[]},tOo="wrapper";function eOo(t){let{components:e,...n}=t;return(0,s.kt)(tOo,(0,p.Z)({},JEo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}eOo.isMDXComponent=!0;const nOo={toc:[]},oOo="wrapper";function pOo(t){let{components:e,...n}=t;return(0,s.kt)(oOo,(0,p.Z)({},nOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}pOo.isMDXComponent=!0;const rOo={toc:[]},sOo="wrapper";function cOo(t){let{components:e,...n}=t;return(0,s.kt)(sOo,(0,p.Z)({},rOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}cOo.isMDXComponent=!0;const aOo={toc:[]},iOo="wrapper";function lOo(t){let{components:e,...n}=t;return(0,s.kt)(iOo,(0,p.Z)({},aOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}lOo.isMDXComponent=!0;const uOo={toc:[]},mOo="wrapper";function dOo(t){let{components:e,...n}=t;return(0,s.kt)(mOo,(0,p.Z)({},uOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}dOo.isMDXComponent=!0;const hOo={toc:[]},fOo="wrapper";function kOo(t){let{components:e,...n}=t;return(0,s.kt)(fOo,(0,p.Z)({},hOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}kOo.isMDXComponent=!0;const yOo={toc:[]},DOo="wrapper";function MOo(t){let{components:e,...n}=t;return(0,s.kt)(DOo,(0,p.Z)({},yOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}MOo.isMDXComponent=!0;const XOo={toc:[]},_Oo="wrapper";function wOo(t){let{components:e,...n}=t;return(0,s.kt)(_Oo,(0,p.Z)({},XOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}wOo.isMDXComponent=!0;const TOo={toc:[]},COo="wrapper";function xOo(t){let{components:e,...n}=t;return(0,s.kt)(COo,(0,p.Z)({},TOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}xOo.isMDXComponent=!0;const gOo={toc:[]},vOo="wrapper";function LOo(t){let{components:e,...n}=t;return(0,s.kt)(vOo,(0,p.Z)({},gOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}LOo.isMDXComponent=!0;const ZOo={toc:[]},bOo="wrapper";function NOo(t){let{components:e,...n}=t;return(0,s.kt)(bOo,(0,p.Z)({},ZOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}NOo.isMDXComponent=!0;const zOo={toc:[]},AOo="wrapper";function POo(t){let{components:e,...n}=t;return(0,s.kt)(AOo,(0,p.Z)({},zOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}POo.isMDXComponent=!0;const WOo={toc:[]},ROo="wrapper";function IOo(t){let{components:e,...n}=t;return(0,s.kt)(ROo,(0,p.Z)({},WOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}IOo.isMDXComponent=!0;const SOo={toc:[]},BOo="wrapper";function GOo(t){let{components:e,...n}=t;return(0,s.kt)(BOo,(0,p.Z)({},SOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}GOo.isMDXComponent=!0;const EOo={toc:[]},OOo="wrapper";function FOo(t){let{components:e,...n}=t;return(0,s.kt)(OOo,(0,p.Z)({},EOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}FOo.isMDXComponent=!0;const UOo={toc:[]},VOo="wrapper";function qOo(t){let{components:e,...n}=t;return(0,s.kt)(VOo,(0,p.Z)({},UOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}qOo.isMDXComponent=!0;const jOo={toc:[]},YOo="wrapper";function QOo(t){let{components:e,...n}=t;return(0,s.kt)(YOo,(0,p.Z)({},jOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}QOo.isMDXComponent=!0;const HOo={toc:[]},KOo="wrapper";function $Oo(t){let{components:e,...n}=t;return(0,s.kt)(KOo,(0,p.Z)({},HOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}$Oo.isMDXComponent=!0;const JOo={toc:[]},tFo="wrapper";function eFo(t){let{components:e,...n}=t;return(0,s.kt)(tFo,(0,p.Z)({},JOo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}eFo.isMDXComponent=!0;const nFo={toc:[]},oFo="wrapper";function pFo(t){let{components:e,...n}=t;return(0,s.kt)(oFo,(0,p.Z)({},nFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}pFo.isMDXComponent=!0;const rFo={toc:[]},sFo="wrapper";function cFo(t){let{components:e,...n}=t;return(0,s.kt)(sFo,(0,p.Z)({},rFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}cFo.isMDXComponent=!0;const aFo={toc:[]},iFo="wrapper";function lFo(t){let{components:e,...n}=t;return(0,s.kt)(iFo,(0,p.Z)({},aFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}lFo.isMDXComponent=!0;const uFo={toc:[]},mFo="wrapper";function dFo(t){let{components:e,...n}=t;return(0,s.kt)(mFo,(0,p.Z)({},uFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}dFo.isMDXComponent=!0;const hFo={toc:[]},fFo="wrapper";function kFo(t){let{components:e,...n}=t;return(0,s.kt)(fFo,(0,p.Z)({},hFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}kFo.isMDXComponent=!0;const yFo={toc:[]},DFo="wrapper";function MFo(t){let{components:e,...n}=t;return(0,s.kt)(DFo,(0,p.Z)({},yFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}MFo.isMDXComponent=!0;const XFo={toc:[]},_Fo="wrapper";function wFo(t){let{components:e,...n}=t;return(0,s.kt)(_Fo,(0,p.Z)({},XFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}wFo.isMDXComponent=!0;const TFo={toc:[]},CFo="wrapper";function xFo(t){let{components:e,...n}=t;return(0,s.kt)(CFo,(0,p.Z)({},TFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}xFo.isMDXComponent=!0;const gFo={toc:[]},vFo="wrapper";function LFo(t){let{components:e,...n}=t;return(0,s.kt)(vFo,(0,p.Z)({},gFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}LFo.isMDXComponent=!0;const ZFo={toc:[]},bFo="wrapper";function NFo(t){let{components:e,...n}=t;return(0,s.kt)(bFo,(0,p.Z)({},ZFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}NFo.isMDXComponent=!0;const zFo={toc:[]},AFo="wrapper";function PFo(t){let{components:e,...n}=t;return(0,s.kt)(AFo,(0,p.Z)({},zFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}PFo.isMDXComponent=!0;const WFo={toc:[]},RFo="wrapper";function IFo(t){let{components:e,...n}=t;return(0,s.kt)(RFo,(0,p.Z)({},WFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}IFo.isMDXComponent=!0;const SFo={toc:[]},BFo="wrapper";function GFo(t){let{components:e,...n}=t;return(0,s.kt)(BFo,(0,p.Z)({},SFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}GFo.isMDXComponent=!0;const EFo={toc:[]},OFo="wrapper";function FFo(t){let{components:e,...n}=t;return(0,s.kt)(OFo,(0,p.Z)({},EFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}FFo.isMDXComponent=!0;const UFo={toc:[]},VFo="wrapper";function qFo(t){let{components:e,...n}=t;return(0,s.kt)(VFo,(0,p.Z)({},UFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}qFo.isMDXComponent=!0;const jFo={toc:[]},YFo="wrapper";function QFo(t){let{components:e,...n}=t;return(0,s.kt)(YFo,(0,p.Z)({},jFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}QFo.isMDXComponent=!0;const HFo={toc:[]},KFo="wrapper";function $Fo(t){let{components:e,...n}=t;return(0,s.kt)(KFo,(0,p.Z)({},HFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}$Fo.isMDXComponent=!0;const JFo={toc:[]},tUo="wrapper";function eUo(t){let{components:e,...n}=t;return(0,s.kt)(tUo,(0,p.Z)({},JFo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}eUo.isMDXComponent=!0;const nUo={toc:[]},oUo="wrapper";function pUo(t){let{components:e,...n}=t;return(0,s.kt)(oUo,(0,p.Z)({},nUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}pUo.isMDXComponent=!0;const rUo={toc:[]},sUo="wrapper";function cUo(t){let{components:e,...n}=t;return(0,s.kt)(sUo,(0,p.Z)({},rUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}cUo.isMDXComponent=!0;const aUo={toc:[]},iUo="wrapper";function lUo(t){let{components:e,...n}=t;return(0,s.kt)(iUo,(0,p.Z)({},aUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}lUo.isMDXComponent=!0;const uUo={toc:[]},mUo="wrapper";function dUo(t){let{components:e,...n}=t;return(0,s.kt)(mUo,(0,p.Z)({},uUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}dUo.isMDXComponent=!0;const hUo={toc:[]},fUo="wrapper";function kUo(t){let{components:e,...n}=t;return(0,s.kt)(fUo,(0,p.Z)({},hUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}kUo.isMDXComponent=!0;const yUo={toc:[]},DUo="wrapper";function MUo(t){let{components:e,...n}=t;return(0,s.kt)(DUo,(0,p.Z)({},yUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}MUo.isMDXComponent=!0;const XUo={toc:[]},_Uo="wrapper";function wUo(t){let{components:e,...n}=t;return(0,s.kt)(_Uo,(0,p.Z)({},XUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}wUo.isMDXComponent=!0;const TUo={toc:[]},CUo="wrapper";function xUo(t){let{components:e,...n}=t;return(0,s.kt)(CUo,(0,p.Z)({},TUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}xUo.isMDXComponent=!0;const gUo={toc:[]},vUo="wrapper";function LUo(t){let{components:e,...n}=t;return(0,s.kt)(vUo,(0,p.Z)({},gUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}LUo.isMDXComponent=!0;const ZUo={toc:[]},bUo="wrapper";function NUo(t){let{components:e,...n}=t;return(0,s.kt)(bUo,(0,p.Z)({},ZUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}NUo.isMDXComponent=!0;const zUo={toc:[]},AUo="wrapper";function PUo(t){let{components:e,...n}=t;return(0,s.kt)(AUo,(0,p.Z)({},zUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}PUo.isMDXComponent=!0;const WUo={toc:[]},RUo="wrapper";function IUo(t){let{components:e,...n}=t;return(0,s.kt)(RUo,(0,p.Z)({},WUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}IUo.isMDXComponent=!0;const SUo={toc:[]},BUo="wrapper";function GUo(t){let{components:e,...n}=t;return(0,s.kt)(BUo,(0,p.Z)({},SUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}GUo.isMDXComponent=!0;const EUo={toc:[]},OUo="wrapper";function FUo(t){let{components:e,...n}=t;return(0,s.kt)(OUo,(0,p.Z)({},EUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}FUo.isMDXComponent=!0;const UUo={toc:[]},VUo="wrapper";function qUo(t){let{components:e,...n}=t;return(0,s.kt)(VUo,(0,p.Z)({},UUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}qUo.isMDXComponent=!0;const jUo={toc:[]},YUo="wrapper";function QUo(t){let{components:e,...n}=t;return(0,s.kt)(YUo,(0,p.Z)({},jUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}QUo.isMDXComponent=!0;const HUo={toc:[]},KUo="wrapper";function $Uo(t){let{components:e,...n}=t;return(0,s.kt)(KUo,(0,p.Z)({},HUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}$Uo.isMDXComponent=!0;const JUo={toc:[]},tVo="wrapper";function eVo(t){let{components:e,...n}=t;return(0,s.kt)(tVo,(0,p.Z)({},JUo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}eVo.isMDXComponent=!0;const nVo={toc:[]},oVo="wrapper";function pVo(t){let{components:e,...n}=t;return(0,s.kt)(oVo,(0,p.Z)({},nVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}pVo.isMDXComponent=!0;const rVo={toc:[]},sVo="wrapper";function cVo(t){let{components:e,...n}=t;return(0,s.kt)(sVo,(0,p.Z)({},rVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}cVo.isMDXComponent=!0;const aVo={toc:[]},iVo="wrapper";function lVo(t){let{components:e,...n}=t;return(0,s.kt)(iVo,(0,p.Z)({},aVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}lVo.isMDXComponent=!0;const uVo={toc:[]},mVo="wrapper";function dVo(t){let{components:e,...n}=t;return(0,s.kt)(mVo,(0,p.Z)({},uVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}dVo.isMDXComponent=!0;const hVo={toc:[]},fVo="wrapper";function kVo(t){let{components:e,...n}=t;return(0,s.kt)(fVo,(0,p.Z)({},hVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}kVo.isMDXComponent=!0;const yVo={toc:[]},DVo="wrapper";function MVo(t){let{components:e,...n}=t;return(0,s.kt)(DVo,(0,p.Z)({},yVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}MVo.isMDXComponent=!0;const XVo={toc:[]},_Vo="wrapper";function wVo(t){let{components:e,...n}=t;return(0,s.kt)(_Vo,(0,p.Z)({},XVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}wVo.isMDXComponent=!0;const TVo={toc:[]},CVo="wrapper";function xVo(t){let{components:e,...n}=t;return(0,s.kt)(CVo,(0,p.Z)({},TVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}xVo.isMDXComponent=!0;const gVo={toc:[]},vVo="wrapper";function LVo(t){let{components:e,...n}=t;return(0,s.kt)(vVo,(0,p.Z)({},gVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}LVo.isMDXComponent=!0;const ZVo={toc:[]},bVo="wrapper";function NVo(t){let{components:e,...n}=t;return(0,s.kt)(bVo,(0,p.Z)({},ZVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}NVo.isMDXComponent=!0;const zVo={toc:[]},AVo="wrapper";function PVo(t){let{components:e,...n}=t;return(0,s.kt)(AVo,(0,p.Z)({},zVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}PVo.isMDXComponent=!0;const WVo={toc:[]},RVo="wrapper";function IVo(t){let{components:e,...n}=t;return(0,s.kt)(RVo,(0,p.Z)({},WVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}IVo.isMDXComponent=!0;const SVo={toc:[]},BVo="wrapper";function GVo(t){let{components:e,...n}=t;return(0,s.kt)(BVo,(0,p.Z)({},SVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}GVo.isMDXComponent=!0;const EVo={toc:[]},OVo="wrapper";function FVo(t){let{components:e,...n}=t;return(0,s.kt)(OVo,(0,p.Z)({},EVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}FVo.isMDXComponent=!0;const UVo={toc:[]},VVo="wrapper";function qVo(t){let{components:e,...n}=t;return(0,s.kt)(VVo,(0,p.Z)({},UVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}qVo.isMDXComponent=!0;const jVo={toc:[]},YVo="wrapper";function QVo(t){let{components:e,...n}=t;return(0,s.kt)(YVo,(0,p.Z)({},jVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}QVo.isMDXComponent=!0;const HVo={toc:[]},KVo="wrapper";function $Vo(t){let{components:e,...n}=t;return(0,s.kt)(KVo,(0,p.Z)({},HVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}$Vo.isMDXComponent=!0;const JVo={toc:[]},tqo="wrapper";function eqo(t){let{components:e,...n}=t;return(0,s.kt)(tqo,(0,p.Z)({},JVo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}eqo.isMDXComponent=!0;const nqo={toc:[]},oqo="wrapper";function pqo(t){let{components:e,...n}=t;return(0,s.kt)(oqo,(0,p.Z)({},nqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}pqo.isMDXComponent=!0;const rqo={toc:[]},sqo="wrapper";function cqo(t){let{components:e,...n}=t;return(0,s.kt)(sqo,(0,p.Z)({},rqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}cqo.isMDXComponent=!0;const aqo={toc:[]},iqo="wrapper";function lqo(t){let{components:e,...n}=t;return(0,s.kt)(iqo,(0,p.Z)({},aqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}lqo.isMDXComponent=!0;const uqo={toc:[]},mqo="wrapper";function dqo(t){let{components:e,...n}=t;return(0,s.kt)(mqo,(0,p.Z)({},uqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}dqo.isMDXComponent=!0;const hqo={toc:[]},fqo="wrapper";function kqo(t){let{components:e,...n}=t;return(0,s.kt)(fqo,(0,p.Z)({},hqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}kqo.isMDXComponent=!0;const yqo={toc:[]},Dqo="wrapper";function Mqo(t){let{components:e,...n}=t;return(0,s.kt)(Dqo,(0,p.Z)({},yqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Mqo.isMDXComponent=!0;const Xqo={toc:[]},_qo="wrapper";function wqo(t){let{components:e,...n}=t;return(0,s.kt)(_qo,(0,p.Z)({},Xqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}wqo.isMDXComponent=!0;const Tqo={toc:[]},Cqo="wrapper";function xqo(t){let{components:e,...n}=t;return(0,s.kt)(Cqo,(0,p.Z)({},Tqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}xqo.isMDXComponent=!0;const gqo={toc:[]},vqo="wrapper";function Lqo(t){let{components:e,...n}=t;return(0,s.kt)(vqo,(0,p.Z)({},gqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Lqo.isMDXComponent=!0;const Zqo={toc:[]},bqo="wrapper";function Nqo(t){let{components:e,...n}=t;return(0,s.kt)(bqo,(0,p.Z)({},Zqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Nqo.isMDXComponent=!0;const zqo={toc:[]},Aqo="wrapper";function Pqo(t){let{components:e,...n}=t;return(0,s.kt)(Aqo,(0,p.Z)({},zqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}Pqo.isMDXComponent=!0;const Wqo={toc:[]},Rqo="wrapper";function Iqo(t){let{components:e,...n}=t;return(0,s.kt)(Rqo,(0,p.Z)({},Wqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}Iqo.isMDXComponent=!0;const Sqo={toc:[]},Bqo="wrapper";function Gqo(t){let{components:e,...n}=t;return(0,s.kt)(Bqo,(0,p.Z)({},Sqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}Gqo.isMDXComponent=!0;const Eqo={toc:[]},Oqo="wrapper";function Fqo(t){let{components:e,...n}=t;return(0,s.kt)(Oqo,(0,p.Z)({},Eqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}Fqo.isMDXComponent=!0;const Uqo={toc:[]},Vqo="wrapper";function qqo(t){let{components:e,...n}=t;return(0,s.kt)(Vqo,(0,p.Z)({},Uqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}qqo.isMDXComponent=!0;const jqo={toc:[]},Yqo="wrapper";function Qqo(t){let{components:e,...n}=t;return(0,s.kt)(Yqo,(0,p.Z)({},jqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}Qqo.isMDXComponent=!0;const Hqo={toc:[]},Kqo="wrapper";function $qo(t){let{components:e,...n}=t;return(0,s.kt)(Kqo,(0,p.Z)({},Hqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}$qo.isMDXComponent=!0;const Jqo={toc:[]},tjo="wrapper";function ejo(t){let{components:e,...n}=t;return(0,s.kt)(tjo,(0,p.Z)({},Jqo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}ejo.isMDXComponent=!0;const njo={toc:[]},ojo="wrapper";function pjo(t){let{components:e,...n}=t;return(0,s.kt)(ojo,(0,p.Z)({},njo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}pjo.isMDXComponent=!0;const rjo={toc:[]},sjo="wrapper";function cjo(t){let{components:e,...n}=t;return(0,s.kt)(sjo,(0,p.Z)({},rjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}cjo.isMDXComponent=!0;const ajo={toc:[]},ijo="wrapper";function ljo(t){let{components:e,...n}=t;return(0,s.kt)(ijo,(0,p.Z)({},ajo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}ljo.isMDXComponent=!0;const ujo={toc:[]},mjo="wrapper";function djo(t){let{components:e,...n}=t;return(0,s.kt)(mjo,(0,p.Z)({},ujo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}djo.isMDXComponent=!0;const hjo={toc:[]},fjo="wrapper";function kjo(t){let{components:e,...n}=t;return(0,s.kt)(fjo,(0,p.Z)({},hjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}kjo.isMDXComponent=!0;const yjo={toc:[]},Djo="wrapper";function Mjo(t){let{components:e,...n}=t;return(0,s.kt)(Djo,(0,p.Z)({},yjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}Mjo.isMDXComponent=!0;const Xjo={toc:[]},_jo="wrapper";function wjo(t){let{components:e,...n}=t;return(0,s.kt)(_jo,(0,p.Z)({},Xjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}wjo.isMDXComponent=!0;const Tjo={toc:[]},Cjo="wrapper";function xjo(t){let{components:e,...n}=t;return(0,s.kt)(Cjo,(0,p.Z)({},Tjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}xjo.isMDXComponent=!0;const gjo={toc:[]},vjo="wrapper";function Ljo(t){let{components:e,...n}=t;return(0,s.kt)(vjo,(0,p.Z)({},gjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Ljo.isMDXComponent=!0;const Zjo={toc:[]},bjo="wrapper";function Njo(t){let{components:e,...n}=t;return(0,s.kt)(bjo,(0,p.Z)({},Zjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Njo.isMDXComponent=!0;const zjo={toc:[]},Ajo="wrapper";function Pjo(t){let{components:e,...n}=t;return(0,s.kt)(Ajo,(0,p.Z)({},zjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}Pjo.isMDXComponent=!0;const Wjo={toc:[]},Rjo="wrapper";function Ijo(t){let{components:e,...n}=t;return(0,s.kt)(Rjo,(0,p.Z)({},Wjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Ijo.isMDXComponent=!0;const Sjo={toc:[]},Bjo="wrapper";function Gjo(t){let{components:e,...n}=t;return(0,s.kt)(Bjo,(0,p.Z)({},Sjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}Gjo.isMDXComponent=!0;const Ejo={toc:[]},Ojo="wrapper";function Fjo(t){let{components:e,...n}=t;return(0,s.kt)(Ojo,(0,p.Z)({},Ejo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}Fjo.isMDXComponent=!0;const Ujo={toc:[]},Vjo="wrapper";function qjo(t){let{components:e,...n}=t;return(0,s.kt)(Vjo,(0,p.Z)({},Ujo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qjo.isMDXComponent=!0;const jjo={toc:[]},Yjo="wrapper";function Qjo(t){let{components:e,...n}=t;return(0,s.kt)(Yjo,(0,p.Z)({},jjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Qjo.isMDXComponent=!0;const Hjo={toc:[]},Kjo="wrapper";function $jo(t){let{components:e,...n}=t;return(0,s.kt)(Kjo,(0,p.Z)({},Hjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}$jo.isMDXComponent=!0;const Jjo={toc:[]},tYo="wrapper";function eYo(t){let{components:e,...n}=t;return(0,s.kt)(tYo,(0,p.Z)({},Jjo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Video#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}eYo.isMDXComponent=!0;const nYo={toc:[]},oYo="wrapper";function pYo(t){let{components:e,...n}=t;return(0,s.kt)(oYo,(0,p.Z)({},nYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}pYo.isMDXComponent=!0;const rYo={toc:[]},sYo="wrapper";function cYo(t){let{components:e,...n}=t;return(0,s.kt)(sYo,(0,p.Z)({},rYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}cYo.isMDXComponent=!0;const aYo={toc:[]},iYo="wrapper";function lYo(t){let{components:e,...n}=t;return(0,s.kt)(iYo,(0,p.Z)({},aYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}lYo.isMDXComponent=!0;const uYo={toc:[]},mYo="wrapper";function dYo(t){let{components:e,...n}=t;return(0,s.kt)(mYo,(0,p.Z)({},uYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}dYo.isMDXComponent=!0;const hYo={toc:[]},fYo="wrapper";function kYo(t){let{components:e,...n}=t;return(0,s.kt)(fYo,(0,p.Z)({},hYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}kYo.isMDXComponent=!0;const yYo={toc:[]},DYo="wrapper";function MYo(t){let{components:e,...n}=t;return(0,s.kt)(DYo,(0,p.Z)({},yYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}MYo.isMDXComponent=!0;const XYo={toc:[]},_Yo="wrapper";function wYo(t){let{components:e,...n}=t;return(0,s.kt)(_Yo,(0,p.Z)({},XYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}wYo.isMDXComponent=!0;const TYo={toc:[]},CYo="wrapper";function xYo(t){let{components:e,...n}=t;return(0,s.kt)(CYo,(0,p.Z)({},TYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the position in world space."))}xYo.isMDXComponent=!0;const gYo={toc:[]},vYo="wrapper";function LYo(t){let{components:e,...n}=t;return(0,s.kt)(vYo,(0,p.Z)({},gYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,s.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}LYo.isMDXComponent=!0;const ZYo={toc:[]},bYo="wrapper";function NYo(t){let{components:e,...n}=t;return(0,s.kt)(bYo,(0,p.Z)({},ZYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the rotation in world space."))}NYo.isMDXComponent=!0;const zYo={toc:[]},AYo="wrapper";function PYo(t){let{components:e,...n}=t;return(0,s.kt)(AYo,(0,p.Z)({},zYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,s.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,s.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y")," components."))}PYo.isMDXComponent=!0;const WYo={toc:[]},RYo="wrapper";function IYo(t){let{components:e,...n}=t;return(0,s.kt)(RYo,(0,p.Z)({},WYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A helper signal for operating on the scale in world space."))}IYo.isMDXComponent=!0;const SYo={toc:[]},BYo="wrapper";function GYo(t){let{components:e,...n}=t;return(0,s.kt)(BYo,(0,p.Z)({},SYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}GYo.isMDXComponent=!0;const EYo={toc:[]},OYo="wrapper";function FYo(t){let{components:e,...n}=t;return(0,s.kt)(OYo,(0,p.Z)({},EYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}FYo.isMDXComponent=!0;const UYo={toc:[]},VYo="wrapper";function qYo(t){let{components:e,...n}=t;return(0,s.kt)(VYo,(0,p.Z)({},UYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom edge in the\nparent space."))}qYo.isMDXComponent=!0;const jYo={toc:[]},YYo="wrapper";function QYo(t){let{components:e,...n}=t;return(0,s.kt)(YYo,(0,p.Z)({},jYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}QYo.isMDXComponent=!0;const HYo={toc:[]},KYo="wrapper";function $Yo(t){let{components:e,...n}=t;return(0,s.kt)(KYo,(0,p.Z)({},HYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom left corner in\nthe parent space."))}$Yo.isMDXComponent=!0;const JYo={toc:[]},tQo="wrapper";function eQo(t){let{components:e,...n}=t;return(0,s.kt)(tQo,(0,p.Z)({},JYo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}eQo.isMDXComponent=!0;const nQo={toc:[]},oQo="wrapper";function pQo(t){let{components:e,...n}=t;return(0,s.kt)(oQo,(0,p.Z)({},nQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe bottom right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the bottom right corner in\nthe parent space."))}pQo.isMDXComponent=!0;const rQo={toc:[]},sQo="wrapper";function cQo(t){let{components:e,...n}=t;return(0,s.kt)(sQo,(0,p.Z)({},rQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}cQo.isMDXComponent=!0;const aQo={toc:[]},iQo="wrapper";function lQo(t){let{components:e,...n}=t;return(0,s.kt)(iQo,(0,p.Z)({},aQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}lQo.isMDXComponent=!0;const uQo={toc:[]},mQo="wrapper";function dQo(t){let{components:e,...n}=t;return(0,s.kt)(mQo,(0,p.Z)({},uQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}dQo.isMDXComponent=!0;const hQo={toc:[]},fQo="wrapper";function kQo(t){let{components:e,...n}=t;return(0,s.kt)(fQo,(0,p.Z)({},hQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}kQo.isMDXComponent=!0;const yQo={toc:[]},DQo="wrapper";function MQo(t){let{components:e,...n}=t;return(0,s.kt)(DQo,(0,p.Z)({},yQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}MQo.isMDXComponent=!0;const XQo={toc:[]},_Qo="wrapper";function wQo(t){let{components:e,...n}=t;return(0,s.kt)(_Qo,(0,p.Z)({},XQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}wQo.isMDXComponent=!0;const TQo={toc:[]},CQo="wrapper";function xQo(t){let{components:e,...n}=t;return(0,s.kt)(CQo,(0,p.Z)({},TQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={300}\n  smoothCorners={true}\n  cornerSharpness={0.7}\n/>\n")))}xQo.isMDXComponent=!0;const gQo={toc:[]},vQo="wrapper";function LQo(t){let{components:e,...n}=t;return(0,s.kt)(vQo,(0,p.Z)({},gQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}LQo.isMDXComponent=!0;const ZQo={toc:[]},bQo="wrapper";function NQo(t){let{components:e,...n}=t;return(0,s.kt)(bQo,(0,p.Z)({},ZQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}NQo.isMDXComponent=!0;const zQo={toc:[]},AQo="wrapper";function PQo(t){let{components:e,...n}=t;return(0,s.kt)(AQo,(0,p.Z)({},zQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}PQo.isMDXComponent=!0;const WQo={toc:[]},RQo="wrapper";function IQo(t){let{components:e,...n}=t;return(0,s.kt)(RQo,(0,p.Z)({},WQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}IQo.isMDXComponent=!0;const SQo={toc:[]},BQo="wrapper";function GQo(t){let{components:e,...n}=t;return(0,s.kt)(BQo,(0,p.Z)({},SQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}GQo.isMDXComponent=!0;const EQo={toc:[]},OQo="wrapper";function FQo(t){let{components:e,...n}=t;return(0,s.kt)(OQo,(0,p.Z)({},EQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}FQo.isMDXComponent=!0;const UQo={toc:[]},VQo="wrapper";function qQo(t){let{components:e,...n}=t;return(0,s.kt)(VQo,(0,p.Z)({},UQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}qQo.isMDXComponent=!0;const jQo={toc:[]},YQo="wrapper";function QQo(t){let{components:e,...n}=t;return(0,s.kt)(YQo,(0,p.Z)({},jQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe left edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the left edge in the parent\nspace."))}QQo.isMDXComponent=!0;const HQo={toc:[]},KQo="wrapper";function $Qo(t){let{components:e,...n}=t;return(0,s.kt)(KQo,(0,p.Z)({},HQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}$Qo.isMDXComponent=!0;const JQo={toc:[]},tHo="wrapper";function eHo(t){let{components:e,...n}=t;return(0,s.kt)(tHo,(0,p.Z)({},JQo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe center ends up in the given place."),(0,s.kt)("p",null,"If the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," has not been changed, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."),(0,s.kt)("p",null,"When retrieved, it will return the position of the center in the parent\nspace."))}eHo.isMDXComponent=!0;const nHo={toc:[]},oHo="wrapper";function pHo(t){let{components:e,...n}=t;return(0,s.kt)(oHo,(0,p.Z)({},nHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}pHo.isMDXComponent=!0;const rHo={toc:[]},sHo="wrapper";function cHo(t){let{components:e,...n}=t;return(0,s.kt)(sHo,(0,p.Z)({},rHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,s.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}cHo.isMDXComponent=!0;const aHo={toc:[]},iHo="wrapper";function lHo(t){let{components:e,...n}=t;return(0,s.kt)(iHo,(0,p.Z)({},aHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the offset of this node's origin."))}lHo.isMDXComponent=!0;const uHo={toc:[]},mHo="wrapper";function dHo(t){let{components:e,...n}=t;return(0,s.kt)(mHo,(0,p.Z)({},uHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value is clamped to the range 0-1."))}dHo.isMDXComponent=!0;const hHo={toc:[]},fHo="wrapper";function kHo(t){let{components:e,...n}=t;return(0,s.kt)(fHo,(0,p.Z)({},hHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the opacity of this node in the range 0-1."))}kHo.isMDXComponent=!0;const yHo={toc:[]},DHo="wrapper";function MHo(t){let{components:e,...n}=t;return(0,s.kt)(DHo,(0,p.Z)({},yHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,s.kt)("p",null,"Accessing the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,s.kt)("p",null,"Setting the position:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}MHo.isMDXComponent=!0;const XHo={toc:[]},_Ho="wrapper";function wHo(t){let{components:e,...n}=t;return(0,s.kt)(_Ho,(0,p.Z)({},XHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the position of this node in local space of its parent."))}wHo.isMDXComponent=!0;const THo={toc:[]},CHo="wrapper";function xHo(t){let{components:e,...n}=t;return(0,s.kt)(CHo,(0,p.Z)({},THo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}xHo.isMDXComponent=!0;const gHo={toc:[]},vHo="wrapper";function LHo(t){let{components:e,...n}=t;return(0,s.kt)(vHo,(0,p.Z)({},gHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"One uniform radius:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={40}\n  fill={'white'}\n/>\n")))}LHo.isMDXComponent=!0;const ZHo={toc:[]},bHo="wrapper";function NHo(t){let{components:e,...n}=t;return(0,s.kt)(bHo,(0,p.Z)({},ZHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Individual radii for each corner:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  size={320}\n  radius={[10, 20, 30, 40]}\n  fill={'white'}\n/>\n")))}NHo.isMDXComponent=!0;const zHo={toc:[]},AHo="wrapper";function PHo(t){let{components:e,...n}=t;return(0,s.kt)(AHo,(0,p.Z)({},zHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}PHo.isMDXComponent=!0;const WHo={toc:[]},RHo="wrapper";function IHo(t){let{components:e,...n}=t;return(0,s.kt)(RHo,(0,p.Z)({},WHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe right edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the right edge in the parent\nspace."))}IHo.isMDXComponent=!0;const SHo={toc:[]},BHo="wrapper";function GHo(t){let{components:e,...n}=t;return(0,s.kt)(BHo,(0,p.Z)({},SHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}GHo.isMDXComponent=!0;const EHo={toc:[]},OHo="wrapper";function FHo(t){let{components:e,...n}=t;return(0,s.kt)(OHo,(0,p.Z)({},EHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}FHo.isMDXComponent=!0;const UHo={toc:[]},VHo="wrapper";function qHo(t){let{components:e,...n}=t;return(0,s.kt)(VHo,(0,p.Z)({},UHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,s.kt)("p",null,"Accessing the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,s.kt)("p",null,"Setting the scale:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}qHo.isMDXComponent=!0;const jHo={toc:[]},YHo="wrapper";function QHo(t){let{components:e,...n}=t;return(0,s.kt)(YHo,(0,p.Z)({},jHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the scale of this node in local space of its parent."))}QHo.isMDXComponent=!0;const HHo={toc:[]},KHo="wrapper";function $Ho(t){let{components:e,...n}=t;return(0,s.kt)(KHo,(0,p.Z)({},HHo,n,{components:e,mdxType:"MDXLayout"}))}$Ho.isMDXComponent=!0;const JHo={toc:[]},tKo="wrapper";function eKo(t){let{components:e,...n}=t;return(0,s.kt)(tKo,(0,p.Z)({},JHo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A size is a two-dimensional vector, where ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,s.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,s.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,s.kt)("p",null,"The value of both x and y is of type ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,s.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,s.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,s.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,s.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,s.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,s.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}eKo.isMDXComponent=!0;const nKo={toc:[]},oKo="wrapper";function pKo(t){let{components:e,...n}=t;return(0,s.kt)(oKo,(0,p.Z)({},nKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,s.kt)("p",null,"Accessing the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,s.kt)("p",null,"Setting the size:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}pKo.isMDXComponent=!0;const rKo={toc:[]},sKo="wrapper";function cKo(t){let{components:e,...n}=t;return(0,s.kt)(sKo,(0,p.Z)({},rKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the size of this node."))}cKo.isMDXComponent=!0;const aKo={toc:[]},iKo="wrapper";function lKo(t){let{components:e,...n}=t;return(0,s.kt)(iKo,(0,p.Z)({},aKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Initializing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node skew={[40, 20]} />\n// with individual components:\n<Node skewX={40} skewY={20} />\n")),(0,s.kt)("p",null,"Accessing the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst skew = node.skew();\n// retrieving an individual component:\nconst skewX = node.skew.x();\n")),(0,s.kt)("p",null,"Setting the skew:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.skew([40, 20]);\nnode.skew(() => [40, 20]);\n// with individual components:\nnode.skew.x(40);\nnode.skew.x(() => 40);\n")))}lKo.isMDXComponent=!0;const uKo={toc:[]},mKo="wrapper";function dKo(t){let{components:e,...n}=t;return(0,s.kt)(mKo,(0,p.Z)({},uKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents the skew of this node in local space of its parent."))}dKo.isMDXComponent=!0;const hKo={toc:[]},fKo="wrapper";function kKo(t){let{components:e,...n}=t;return(0,s.kt)(fKo,(0,p.Z)({},hKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}kKo.isMDXComponent=!0;const yKo={toc:[]},DKo="wrapper";function MKo(t){let{components:e,...n}=t;return(0,s.kt)(DKo,(0,p.Z)({},yKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Rect\n  width={300}\n  height={300}\n  smoothCorners={true}\n/>\n")))}MKo.isMDXComponent=!0;const XKo={toc:[]},_Ko="wrapper";function wKo(t){let{components:e,...n}=t;return(0,s.kt)(_Ko,(0,p.Z)({},XKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}wKo.isMDXComponent=!0;const TKo={toc:[]},CKo="wrapper";function xKo(t){let{components:e,...n}=t;return(0,s.kt)(CKo,(0,p.Z)({},TKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}xKo.isMDXComponent=!0;const gKo={toc:[]},vKo="wrapper";function LKo(t){let{components:e,...n}=t;return(0,s.kt)(vKo,(0,p.Z)({},gKo,n,{components:e,mdxType:"MDXLayout"}))}LKo.isMDXComponent=!0;const ZKo={toc:[]},bKo="wrapper";function NKo(t){let{components:e,...n}=t;return(0,s.kt)(bKo,(0,p.Z)({},ZKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}NKo.isMDXComponent=!0;const zKo={toc:[]},AKo="wrapper";function PKo(t){let{components:e,...n}=t;return(0,s.kt)(AKo,(0,p.Z)({},zKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}PKo.isMDXComponent=!0;const WKo={toc:[]},RKo="wrapper";function IKo(t){let{components:e,...n}=t;return(0,s.kt)(RKo,(0,p.Z)({},WKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}IKo.isMDXComponent=!0;const SKo={toc:[]},BKo="wrapper";function GKo(t){let{components:e,...n}=t;return(0,s.kt)(BKo,(0,p.Z)({},SKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}GKo.isMDXComponent=!0;const EKo={toc:[]},OKo="wrapper";function FKo(t){let{components:e,...n}=t;return(0,s.kt)(OKo,(0,p.Z)({},EKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}FKo.isMDXComponent=!0;const UKo={toc:[]},VKo="wrapper";function qKo(t){let{components:e,...n}=t;return(0,s.kt)(VKo,(0,p.Z)({},UKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}qKo.isMDXComponent=!0;const jKo={toc:[]},YKo="wrapper";function QKo(t){let{components:e,...n}=t;return(0,s.kt)(YKo,(0,p.Z)({},jKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top edge ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top edge in the parent\nspace."))}QKo.isMDXComponent=!0;const HKo={toc:[]},KKo="wrapper";function $Ko(t){let{components:e,...n}=t;return(0,s.kt)(KKo,(0,p.Z)({},HKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}$Ko.isMDXComponent=!0;const JKo={toc:[]},t$o="wrapper";function e$o(t){let{components:e,...n}=t;return(0,s.kt)(t$o,(0,p.Z)({},JKo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top left corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top left corner in the\nparent space."))}e$o.isMDXComponent=!0;const n$o={toc:[]},o$o="wrapper";function p$o(t){let{components:e,...n}=t;return(0,s.kt)(o$o,(0,p.Z)({},n$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}p$o.isMDXComponent=!0;const r$o={toc:[]},s$o="wrapper";function c$o(t){let{components:e,...n}=t;return(0,s.kt)(s$o,(0,p.Z)({},r$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set, this shortcut property will modify the node's position so that\nthe top right corner ends up in the given place."),(0,s.kt)("p",null,"When retrieved, it will return the position of the top right corner in the\nparent space."))}c$o.isMDXComponent=!0;const a$o={toc:[]},i$o="wrapper";function l$o(t){let{components:e,...n}=t;return(0,s.kt)(i$o,(0,p.Z)({},a$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}l$o.isMDXComponent=!0;const u$o={toc:[]},m$o="wrapper";function d$o(t){let{components:e,...n}=t;return(0,s.kt)(m$o,(0,p.Z)({},u$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The nodes will be appended at the end of the children list."))}d$o.isMDXComponent=!0;const h$o={toc:[]},f$o="wrapper";function k$o(t){let{components:e,...n}=t;return(0,s.kt)(f$o,(0,p.Z)({},h$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}k$o.isMDXComponent=!0;const y$o={toc:[]},D$o="wrapper";function M$o(t){let{components:e,...n}=t;return(0,s.kt)(D$o,(0,p.Z)({},y$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Add the given node(s) as the children of this node."))}M$o.isMDXComponent=!0;const X$o={toc:[]},_$o="wrapper";function w$o(t){let{components:e,...n}=t;return(0,s.kt)(_$o,(0,p.Z)({},X$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to append."))}w$o.isMDXComponent=!0;const T$o={toc:[]},C$o="wrapper";function x$o(t){let{components:e,...n}=t;return(0,s.kt)(C$o,(0,p.Z)({},T$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply the given state to the node, setting all matching signal values to\nthe provided values."))}x$o.isMDXComponent=!0;const g$o={toc:[]},v$o="wrapper";function L$o(t){let{components:e,...n}=t;return(0,s.kt)(v$o,(0,p.Z)({},g$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to apply to the node."))}L$o.isMDXComponent=!0;const Z$o={toc:[]},b$o="wrapper";function N$o(t){let{components:e,...n}=t;return(0,s.kt)(b$o,(0,p.Z)({},Z$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Smoothly transition between the current state of the node and the given\nstate."))}N$o.isMDXComponent=!0;const z$o={toc:[]},A$o="wrapper";function P$o(t){let{components:e,...n}=t;return(0,s.kt)(A$o,(0,p.Z)({},z$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The state to transition to."))}P$o.isMDXComponent=!0;const W$o={toc:[]},R$o="wrapper";function I$o(t){let{components:e,...n}=t;return(0,s.kt)(R$o,(0,p.Z)({},W$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}I$o.isMDXComponent=!0;const S$o={toc:[]},B$o="wrapper";function G$o(t){let{components:e,...n}=t;return(0,s.kt)(B$o,(0,p.Z)({},S$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}G$o.isMDXComponent=!0;const E$o={toc:[]},O$o="wrapper";function F$o(t){let{components:e,...n}=t;return(0,s.kt)(O$o,(0,p.Z)({},E$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This arc length accounts for both the offset and the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end"))," properties."))}F$o.isMDXComponent=!0;const U$o={toc:[]},V$o="wrapper";function q$o(t){let{components:e,...n}=t;return(0,s.kt)(V$o,(0,p.Z)({},U$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The visible arc length of this curve."))}q$o.isMDXComponent=!0;const j$o={toc:[]},Y$o="wrapper";function Q$o(t){let{components:e,...n}=t;return(0,s.kt)(Y$o,(0,p.Z)({},j$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the entire length of this curve, not accounting for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}Q$o.isMDXComponent=!0;const H$o={toc:[]},K$o="wrapper";function $$o(t){let{components:e,...n}=t;return(0,s.kt)(K$o,(0,p.Z)({},H$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The base arc length of this curve."))}$$o.isMDXComponent=!0;const J$o={toc:[]},tJo="wrapper";function eJo(t){let{components:e,...n}=t;return(0,s.kt)(tJo,(0,p.Z)({},J$o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node as well\nas its children."))}eJo.isMDXComponent=!0;const nJo={toc:[]},oJo="wrapper";function pJo(t){let{components:e,...n}=t;return(0,s.kt)(oJo,(0,p.Z)({},nJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}pJo.isMDXComponent=!0;const rJo={toc:[]},sJo="wrapper";function cJo(t){let{components:e,...n}=t;return(0,s.kt)(sJo,(0,p.Z)({},rJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the nth children cast to the specified type."))}cJo.isMDXComponent=!0;const aJo={toc:[]},iJo="wrapper";function lJo(t){let{components:e,...n}=t;return(0,s.kt)(iJo,(0,p.Z)({},aJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index of the child to retrieve."))}lJo.isMDXComponent=!0;const uJo={toc:[]},mJo="wrapper";function dJo(t){let{components:e,...n}=t;return(0,s.kt)(mJo,(0,p.Z)({},uJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the children array cast to the specified type."))}dJo.isMDXComponent=!0;const hJo={toc:[]},fJo="wrapper";function kJo(t){let{components:e,...n}=t;return(0,s.kt)(fJo,(0,p.Z)({},hJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}kJo.isMDXComponent=!0;const yJo={toc:[]},DJo="wrapper";function MJo(t){let{components:e,...n}=t;return(0,s.kt)(DJo,(0,p.Z)({},yJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}MJo.isMDXComponent=!0;const XJo={toc:[]},_Jo="wrapper";function wJo(t){let{components:e,...n}=t;return(0,s.kt)(_Jo,(0,p.Z)({},XJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Collect all asynchronous resources used by this node."))}wJo.isMDXComponent=!0;const TJo={toc:[]},CJo="wrapper";function xJo(t){let{components:e,...n}=t;return(0,s.kt)(CJo,(0,p.Z)({},TJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned value is the ratio between the visible length (as defined by\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),") and the offset length of the curve."))}xJo.isMDXComponent=!0;const gJo={toc:[]},vJo="wrapper";function LJo(t){let{components:e,...n}=t;return(0,s.kt)(vJo,(0,p.Z)({},gJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage of the curve that's currently visible."))}LJo.isMDXComponent=!0;const ZJo={toc:[]},bJo="wrapper";function NJo(t){let{components:e,...n}=t;return(0,s.kt)(bJo,(0,p.Z)({},ZJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closest composite root."))}NJo.isMDXComponent=!0;const zJo={toc:[]},AJo="wrapper";function PJo(t){let{components:e,...n}=t;return(0,s.kt)(AJo,(0,p.Z)({},zJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A matrix mapping composite space to world space."))}PJo.isMDXComponent=!0;const WJo={toc:[]},RJo="wrapper";function IJo(t){let{components:e,...n}=t;return(0,s.kt)(RJo,(0,p.Z)({},WJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}IJo.isMDXComponent=!0;const SJo={toc:[]},BJo="wrapper";function GJo(t){let{components:e,...n}=t;return(0,s.kt)(BJo,(0,p.Z)({},SJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the desired size of this node."))}GJo.isMDXComponent=!0;const EJo={toc:[]},OJo="wrapper";function FJo(t){let{components:e,...n}=t;return(0,s.kt)(OJo,(0,p.Z)({},EJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,s.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}FJo.isMDXComponent=!0;const UJo={toc:[]},VJo="wrapper";function qJo(t){let{components:e,...n}=t;return(0,s.kt)(VJo,(0,p.Z)({},UJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare this node to be disposed of."))}qJo.isMDXComponent=!0;const jJo={toc:[]},YJo="wrapper";function QJo(t){let{components:e,...n}=t;return(0,s.kt)(YJo,(0,p.Z)({},jJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance should be given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}QJo.isMDXComponent=!0;const HJo={toc:[]},KJo="wrapper";function $Jo(t){let{components:e,...n}=t;return(0,s.kt)(KJo,(0,p.Z)({},HJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a distance along the curve to a percentage."))}$Jo.isMDXComponent=!0;const JJo={toc:[]},t0o="wrapper";function e0o(t){let{components:e,...n}=t;return(0,s.kt)(t0o,(0,p.Z)({},JJo,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The distance along the curve."))}e0o.isMDXComponent=!0;const n0o={toc:[]},o0o="wrapper";function p0o(t){let{components:e,...n}=t;return(0,s.kt)(o0o,(0,p.Z)({},n0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}p0o.isMDXComponent=!0;const r0o={toc:[]},s0o="wrapper";function c0o(t){let{components:e,...n}=t;return(0,s.kt)(s0o,(0,p.Z)({},r0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw this node onto the canvas."))}c0o.isMDXComponent=!0;const a0o={toc:[]},i0o="wrapper";function l0o(t){let{components:e,...n}=t;return(0,s.kt)(i0o,(0,p.Z)({},a0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}l0o.isMDXComponent=!0;const u0o={toc:[]},m0o="wrapper";function d0o(t){let{components:e,...n}=t;return(0,s.kt)(m0o,(0,p.Z)({},u0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,s.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}d0o.isMDXComponent=!0;const h0o={toc:[]},f0o="wrapper";function k0o(t){let{components:e,...n}=t;return(0,s.kt)(f0o,(0,p.Z)({},h0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Draw an overlay for this node."))}k0o.isMDXComponent=!0;const y0o={toc:[]},D0o="wrapper";function M0o(t){let{components:e,...n}=t;return(0,s.kt)(D0o,(0,p.Z)({},y0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}M0o.isMDXComponent=!0;const X0o={toc:[]},_0o="wrapper";function w0o(t){let{components:e,...n}=t;return(0,s.kt)(_0o,(0,p.Z)({},X0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A local-to-screen matrix."))}w0o.isMDXComponent=!0;const T0o={toc:[]},C0o="wrapper";function x0o(t){let{components:e,...n}=t;return(0,s.kt)(C0o,(0,p.Z)({},T0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}x0o.isMDXComponent=!0;const g0o={toc:[]},v0o="wrapper";function L0o(t){let{components:e,...n}=t;return(0,s.kt)(v0o,(0,p.Z)({},g0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}L0o.isMDXComponent=!0;const Z0o={toc:[]},b0o="wrapper";function N0o(t){let{components:e,...n}=t;return(0,s.kt)(b0o,(0,p.Z)({},Z0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find all descendants of this node that match the given predicate."))}N0o.isMDXComponent=!0;const z0o={toc:[]},A0o="wrapper";function P0o(t){let{components:e,...n}=t;return(0,s.kt)(A0o,(0,p.Z)({},z0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}P0o.isMDXComponent=!0;const W0o={toc:[]},R0o="wrapper";function I0o(t){let{components:e,...n}=t;return(0,s.kt)(R0o,(0,p.Z)({},W0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}I0o.isMDXComponent=!0;const S0o={toc:[]},B0o="wrapper";function G0o(t){let{components:e,...n}=t;return(0,s.kt)(B0o,(0,p.Z)({},S0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}G0o.isMDXComponent=!0;const E0o={toc:[]},O0o="wrapper";function F0o(t){let{components:e,...n}=t;return(0,s.kt)(O0o,(0,p.Z)({},E0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest ancestor of this node that matches the given predicate."))}F0o.isMDXComponent=!0;const U0o={toc:[]},V0o="wrapper";function q0o(t){let{components:e,...n}=t;return(0,s.kt)(V0o,(0,p.Z)({},U0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}q0o.isMDXComponent=!0;const j0o={toc:[]},Y0o="wrapper";function Q0o(t){let{components:e,...n}=t;return(0,s.kt)(Y0o,(0,p.Z)({},j0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}Q0o.isMDXComponent=!0;const H0o={toc:[]},K0o="wrapper";function $0o(t){let{components:e,...n}=t;return(0,s.kt)(K0o,(0,p.Z)({},H0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}$0o.isMDXComponent=!0;const J0o={toc:[]},t4o="wrapper";function e4o(t){let{components:e,...n}=t;return(0,s.kt)(t4o,(0,p.Z)({},J0o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the first descendant of this node that matches the given predicate."))}e4o.isMDXComponent=!0;const n4o={toc:[]},o4o="wrapper";function p4o(t){let{components:e,...n}=t;return(0,s.kt)(o4o,(0,p.Z)({},n4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}p4o.isMDXComponent=!0;const r4o={toc:[]},s4o="wrapper";function c4o(t){let{components:e,...n}=t;return(0,s.kt)(s4o,(0,p.Z)({},r4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find a node by its key."))}c4o.isMDXComponent=!0;const a4o={toc:[]},i4o="wrapper";function l4o(t){let{components:e,...n}=t;return(0,s.kt)(i4o,(0,p.Z)({},a4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The key of the node."))}l4o.isMDXComponent=!0;const u4o={toc:[]},m4o="wrapper";function d4o(t){let{components:e,...n}=t;return(0,s.kt)(m4o,(0,p.Z)({},u4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}d4o.isMDXComponent=!0;const h4o={toc:[]},f4o="wrapper";function k4o(t){let{components:e,...n}=t;return(0,s.kt)(f4o,(0,p.Z)({},h4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}k4o.isMDXComponent=!0;const y4o={toc:[]},D4o="wrapper";function M4o(t){let{components:e,...n}=t;return(0,s.kt)(D4o,(0,p.Z)({},y4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the last descendant of this node that matches the given predicate."))}M4o.isMDXComponent=!0;const X4o={toc:[]},_4o="wrapper";function w4o(t){let{components:e,...n}=t;return(0,s.kt)(_4o,(0,p.Z)({},X4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A function that returns true if the node matches."))}w4o.isMDXComponent=!0;const T4o={toc:[]},C4o="wrapper";function x4o(t){let{components:e,...n}=t;return(0,s.kt)(C4o,(0,p.Z)({},T4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}x4o.isMDXComponent=!0;const g4o={toc:[]},v4o="wrapper";function L4o(t){let{components:e,...n}=t;return(0,s.kt)(v4o,(0,p.Z)({},g4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node (including\neffects applied after caching)."))}L4o.isMDXComponent=!0;const Z4o={toc:[]},b4o="wrapper";function N4o(t){let{components:e,...n}=t;return(0,s.kt)(b4o,(0,p.Z)({},Z4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned bounding box should be in local space."))}N4o.isMDXComponent=!0;const z4o={toc:[]},A4o="wrapper";function P4o(t){let{components:e,...n}=t;return(0,s.kt)(A4o,(0,p.Z)({},z4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box for the contents rendered by this node."))}P4o.isMDXComponent=!0;const W4o={toc:[]},R4o="wrapper";function I4o(t){let{components:e,...n}=t;return(0,s.kt)(R4o,(0,p.Z)({},W4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method will calculate the values of any reactive properties of the\nnode at the time the method is called."))}I4o.isMDXComponent=!0;const S4o={toc:[]},B4o="wrapper";function G4o(t){let{components:e,...n}=t;return(0,s.kt)(B4o,(0,p.Z)({},S4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return a snapshot of the node's current signal values."))}G4o.isMDXComponent=!0;const E4o={toc:[]},O4o="wrapper";function F4o(t){let{components:e,...n}=t;return(0,s.kt)(O4o,(0,p.Z)({},E4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Try to find a node intersecting the given position."))}F4o.isMDXComponent=!0;const U4o={toc:[]},V4o="wrapper";function q4o(t){let{components:e,...n}=t;return(0,s.kt)(V4o,(0,p.Z)({},U4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The searched position."))}q4o.isMDXComponent=!0;const j4o={toc:[]},Y4o="wrapper";function Q4o(t){let{components:e,...n}=t;return(0,s.kt)(Y4o,(0,p.Z)({},j4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Txt />, 1);\n")),(0,s.kt)("p",null,"Result:"),(0,s.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Q4o.isMDXComponent=!0;const H4o={toc:[]},K4o="wrapper";function $4o(t){let{components:e,...n}=t;return(0,s.kt)(K4o,(0,p.Z)({},H4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}$4o.isMDXComponent=!0;const J4o={toc:[]},t6o="wrapper";function e6o(t){let{components:e,...n}=t;return(0,s.kt)(t6o,(0,p.Z)({},J4o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A node or an array of nodes to insert."))}e6o.isMDXComponent=!0;const n6o={toc:[]},o6o="wrapper";function p6o(t){let{components:e,...n}=t;return(0,s.kt)(o6o,(0,p.Z)({},n6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An index at which to insert the node(s)."))}p6o.isMDXComponent=!0;const r6o={toc:[]},s6o="wrapper";function c6o(t){let{components:e,...n}=t;return(0,s.kt)(s6o,(0,p.Z)({},r6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an instance of this node's class."))}c6o.isMDXComponent=!0;const a6o={toc:[]},i6o="wrapper";function l6o(t){let{components:e,...n}=t;return(0,s.kt)(i6o,(0,p.Z)({},a6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to pass to the constructor."))}l6o.isMDXComponent=!0;const u6o={toc:[]},m6o="wrapper";function d6o(t){let{components:e,...n}=t;return(0,s.kt)(m6o,(0,p.Z)({},u6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the mode is ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,s.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}d6o.isMDXComponent=!0;const h6o={toc:[]},f6o="wrapper";function k6o(t){let{components:e,...n}=t;return(0,s.kt)(f6o,(0,p.Z)({},h6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the resolved layout mode of this node."))}k6o.isMDXComponent=!0;const y6o={toc:[]},D6o="wrapper";function M6o(t){let{components:e,...n}=t;return(0,s.kt)(D6o,(0,p.Z)({},y6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}M6o.isMDXComponent=!0;const X6o={toc:[]},_6o="wrapper";function w6o(t){let{components:e,...n}=t;return(0,s.kt)(_6o,(0,p.Z)({},X6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-parent matrix for this node."))}w6o.isMDXComponent=!0;const T6o={toc:[]},C6o="wrapper";function x6o(t){let{components:e,...n}=t;return(0,s.kt)(C6o,(0,p.Z)({},T6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}x6o.isMDXComponent=!0;const g6o={toc:[]},v6o="wrapper";function L6o(t){let{components:e,...n}=t;return(0,s.kt)(v6o,(0,p.Z)({},g6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}L6o.isMDXComponent=!0;const Z6o={toc:[]},b6o="wrapper";function N6o(t){let{components:e,...n}=t;return(0,s.kt)(b6o,(0,p.Z)({},Z6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the local-to-world matrix for this node."))}N6o.isMDXComponent=!0;const z6o={toc:[]},A6o="wrapper";function P6o(t){let{components:e,...n}=t;return(0,s.kt)(A6o,(0,p.Z)({},z6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,s.kt)("p",null,"A positive ",(0,s.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}P6o.isMDXComponent=!0;const W6o={toc:[]},R6o="wrapper";function I6o(t){let{components:e,...n}=t;return(0,s.kt)(R6o,(0,p.Z)({},W6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rearrange this node in relation to its siblings."))}I6o.isMDXComponent=!0;const S6o={toc:[]},B6o="wrapper";function G6o(t){let{components:e,...n}=t;return(0,s.kt)(B6o,(0,p.Z)({},S6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Number of places by which the node should be moved."))}G6o.isMDXComponent=!0;const E6o={toc:[]},O6o="wrapper";function F6o(t){let{components:e,...n}=t;return(0,s.kt)(O6o,(0,p.Z)({},E6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}F6o.isMDXComponent=!0;const U6o={toc:[]},V6o="wrapper";function q6o(t){let{components:e,...n}=t;return(0,s.kt)(V6o,(0,p.Z)({},U6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node above the provided node in the parent's layout."))}q6o.isMDXComponent=!0;const j6o={toc:[]},Y6o="wrapper";function Q6o(t){let{components:e,...n}=t;return(0,s.kt)(Y6o,(0,p.Z)({},j6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}Q6o.isMDXComponent=!0;const H6o={toc:[]},K6o="wrapper";function $6o(t){let{components:e,...n}=t;return(0,s.kt)(K6o,(0,p.Z)({},H6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}$6o.isMDXComponent=!0;const J6o={toc:[]},t3o="wrapper";function e3o(t){let{components:e,...n}=t;return(0,s.kt)(t3o,(0,p.Z)({},J6o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}e3o.isMDXComponent=!0;const n3o={toc:[]},o3o="wrapper";function p3o(t){let{components:e,...n}=t;return(0,s.kt)(o3o,(0,p.Z)({},n3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node below the provided node in the parent's layout."))}p3o.isMDXComponent=!0;const r3o={toc:[]},s3o="wrapper";function c3o(t){let{components:e,...n}=t;return(0,s.kt)(s3o,(0,p.Z)({},r3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The sibling node below which to move."))}c3o.isMDXComponent=!0;const a3o={toc:[]},i3o="wrapper";function l3o(t){let{components:e,...n}=t;return(0,s.kt)(i3o,(0,p.Z)({},a3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}l3o.isMDXComponent=!0;const u3o={toc:[]},m3o="wrapper";function d3o(t){let{components:e,...n}=t;return(0,s.kt)(m3o,(0,p.Z)({},u3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}d3o.isMDXComponent=!0;const h3o={toc:[]},f3o="wrapper";function k3o(t){let{components:e,...n}=t;return(0,s.kt)(f3o,(0,p.Z)({},h3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node down in relation to its siblings."))}k3o.isMDXComponent=!0;const y3o={toc:[]},D3o="wrapper";function M3o(t){let{components:e,...n}=t;return(0,s.kt)(D3o,(0,p.Z)({},y3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}M3o.isMDXComponent=!0;const X3o={toc:[]},_3o="wrapper";function w3o(t){let{components:e,...n}=t;return(0,s.kt)(_3o,(0,p.Z)({},X3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new offset."))}w3o.isMDXComponent=!0;const T3o={toc:[]},C3o="wrapper";function x3o(t){let{components:e,...n}=t;return(0,s.kt)(C3o,(0,p.Z)({},T3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}x3o.isMDXComponent=!0;const g3o={toc:[]},v3o="wrapper";function L3o(t){let{components:e,...n}=t;return(0,s.kt)(v3o,(0,p.Z)({},g3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the provided position relative to its siblings."))}L3o.isMDXComponent=!0;const Z3o={toc:[]},b3o="wrapper";function N3o(t){let{components:e,...n}=t;return(0,s.kt)(b3o,(0,p.Z)({},Z3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The index to move the node to."))}N3o.isMDXComponent=!0;const z3o={toc:[]},A3o="wrapper";function P3o(t){let{components:e,...n}=t;return(0,s.kt)(A3o,(0,p.Z)({},z3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}P3o.isMDXComponent=!0;const W3o={toc:[]},R3o="wrapper";function I3o(t){let{components:e,...n}=t;return(0,s.kt)(R3o,(0,p.Z)({},W3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}I3o.isMDXComponent=!0;const S3o={toc:[]},B3o="wrapper";function G3o(t){let{components:e,...n}=t;return(0,s.kt)(B3o,(0,p.Z)({},S3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}G3o.isMDXComponent=!0;const E3o={toc:[]},O3o="wrapper";function F3o(t){let{components:e,...n}=t;return(0,s.kt)(O3o,(0,p.Z)({},E3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node to the top in relation to its siblings."))}F3o.isMDXComponent=!0;const U3o={toc:[]},V3o="wrapper";function q3o(t){let{components:e,...n}=t;return(0,s.kt)(V3o,(0,p.Z)({},U3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}q3o.isMDXComponent=!0;const j3o={toc:[]},Y3o="wrapper";function Q3o(t){let{components:e,...n}=t;return(0,s.kt)(Y3o,(0,p.Z)({},j3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Move the node up in relation to its siblings."))}Q3o.isMDXComponent=!0;const H3o={toc:[]},K3o="wrapper";function $3o(t){let{components:e,...n}=t;return(0,s.kt)(K3o,(0,p.Z)({},H3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the length of the curve that accounts for\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"the offsets")),"."))}$3o.isMDXComponent=!0;const J3o={toc:[]},t7o="wrapper";function e7o(t){let{components:e,...n}=t;return(0,s.kt)(t7o,(0,p.Z)({},J3o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset arc length of this curve."))}e7o.isMDXComponent=!0;const n7o={toc:[]},o7o="wrapper";function p7o(t){let{components:e,...n}=t;return(0,s.kt)(o7o,(0,p.Z)({},n7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the parent cast to the specified type."))}p7o.isMDXComponent=!0;const r7o={toc:[]},s7o="wrapper";function c7o(t){let{components:e,...n}=t;return(0,s.kt)(s7o,(0,p.Z)({},r7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Parse any ",(0,s.kt)("inlineCode",{parentName:"p"},"ComponentChildren")," into an array of nodes."))}c7o.isMDXComponent=!0;const a7o={toc:[]},i7o="wrapper";function l7o(t){let{components:e,...n}=t;return(0,s.kt)(i7o,(0,p.Z)({},a7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to parse."))}l7o.isMDXComponent=!0;const u7o={toc:[]},m7o="wrapper";function d7o(t){let{components:e,...n}=t;return(0,s.kt)(m7o,(0,p.Z)({},u7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The returned distance is given in relation to the full curve, not\naccounting for ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset"))," and ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),"."))}d7o.isMDXComponent=!0;const h7o={toc:[]},f7o="wrapper";function k7o(t){let{components:e,...n}=t;return(0,s.kt)(f7o,(0,p.Z)({},h7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Convert a percentage along the curve to a distance."))}k7o.isMDXComponent=!0;const y7o={toc:[]},D7o="wrapper";function M7o(t){let{components:e,...n}=t;return(0,s.kt)(D7o,(0,p.Z)({},y7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage along the curve."))}M7o.isMDXComponent=!0;const X7o={toc:[]},_7o="wrapper";function w7o(t){let{components:e,...n}=t;return(0,s.kt)(_7o,(0,p.Z)({},X7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}w7o.isMDXComponent=!0;const T7o={toc:[]},C7o="wrapper";function x7o(t){let{components:e,...n}=t;return(0,s.kt)(C7o,(0,p.Z)({},T7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a reactive copy of this node."))}x7o.isMDXComponent=!0;const g7o={toc:[]},v7o="wrapper";function L7o(t){let{components:e,...n}=t;return(0,s.kt)(v7o,(0,p.Z)({},g7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}L7o.isMDXComponent=!0;const Z7o={toc:[]},b7o="wrapper";function N7o(t){let{components:e,...n}=t;return(0,s.kt)(b7o,(0,p.Z)({},Z7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove this node from the tree."))}N7o.isMDXComponent=!0;const z7o={toc:[]},A7o="wrapper";function P7o(t){let{components:e,...n}=t;return(0,s.kt)(A7o,(0,p.Z)({},z7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove the given child."))}P7o.isMDXComponent=!0;const W7o={toc:[]},R7o="wrapper";function I7o(t){let{components:e,...n}=t;return(0,s.kt)(R7o,(0,p.Z)({},W7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Remove all children of this node."))}I7o.isMDXComponent=!0;const S7o={toc:[]},B7o="wrapper";function G7o(t){let{components:e,...n}=t;return(0,s.kt)(B7o,(0,p.Z)({},S7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Render this node onto the given canvas."))}G7o.isMDXComponent=!0;const E7o={toc:[]},O7o="wrapper";function F7o(t){let{components:e,...n}=t;return(0,s.kt)(O7o,(0,p.Z)({},E7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context to draw with."))}F7o.isMDXComponent=!0;const U7o={toc:[]},V7o="wrapper";function q7o(t){let{components:e,...n}=t;return(0,s.kt)(V7o,(0,p.Z)({},U7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}q7o.isMDXComponent=!0;const j7o={toc:[]},Y7o="wrapper";function Q7o(t){let{components:e,...n}=t;return(0,s.kt)(Y7o,(0,p.Z)({},j7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Q7o.isMDXComponent=!0;const H7o={toc:[]},K7o="wrapper";function $7o(t){let{components:e,...n}=t;return(0,s.kt)(K7o,(0,p.Z)({},H7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The new parent of this node."))}$7o.isMDXComponent=!0;const J7o={toc:[]},t2o="wrapper";function e2o(t){let{components:e,...n}=t;return(0,s.kt)(t2o,(0,p.Z)({},J7o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}e2o.isMDXComponent=!0;const n2o={toc:[]},o2o="wrapper";function p2o(t){let{components:e,...n}=t;return(0,s.kt)(o2o,(0,p.Z)({},n2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}p2o.isMDXComponent=!0;const r2o={toc:[]},s2o="wrapper";function c2o(t){let{components:e,...n}=t;return(0,s.kt)(s2o,(0,p.Z)({},r2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this node should be cached or not."))}c2o.isMDXComponent=!0;const a2o={toc:[]},i2o="wrapper";function l2o(t){let{components:e,...n}=t;return(0,s.kt)(i2o,(0,p.Z)({},a2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The profile is only required if certain features are used. Otherwise, the\nprofile generation can be skipped, and the curve can be drawn directly\nusing the 2D context."))}l2o.isMDXComponent=!0;const u2o={toc:[]},m2o="wrapper";function d2o(t){let{components:e,...n}=t;return(0,s.kt)(m2o,(0,p.Z)({},u2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the path requires a profile."))}d2o.isMDXComponent=!0;const h2o={toc:[]},f2o="wrapper";function k2o(t){let{components:e,...n}=t;return(0,s.kt)(f2o,(0,p.Z)({},h2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}k2o.isMDXComponent=!0;const y2o={toc:[]},D2o="wrapper";function M2o(t){let{components:e,...n}=t;return(0,s.kt)(D2o,(0,p.Z)({},y2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Restore the node to its saved state\nnode.restore();\n")))}M2o.isMDXComponent=!0;const X2o={toc:[]},_2o="wrapper";function w2o(t){let{components:e,...n}=t;return(0,s.kt)(_2o,(0,p.Z)({},X2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Restore the node to its last saved state."))}w2o.isMDXComponent=!0;const T2o={toc:[]},C2o="wrapper";function x2o(t){let{components:e,...n}=t;return(0,s.kt)(C2o,(0,p.Z)({},T2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#save"},(0,s.kt)("inlineCode",{parentName:"a"},"save"))," method to restore a\nnode to a previously saved state. Restoring a node to a previous state\nremoves that state from the state stack."))}x2o.isMDXComponent=!0;const g2o={toc:[]},v2o="wrapper";function L2o(t){let{components:e,...n}=t;return(0,s.kt)(v2o,(0,p.Z)({},g2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n\nview.add(node);\n\n// Save the node's current state\nnode.save();\n\n// Modify some of the node's properties\nyield* node.scale(2, 1);\nyield* node.fill('hotpink', 1);\n\n// Tween the node to its saved state over 1 second\nyield* node.restore(1);\n")))}L2o.isMDXComponent=!0;const Z2o={toc:[]},b2o="wrapper";function N2o(t){let{components:e,...n}=t;return(0,s.kt)(b2o,(0,p.Z)({},Z2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Tween the node to its last saved state."))}N2o.isMDXComponent=!0;const z2o={toc:[]},A2o="wrapper";function P2o(t){let{components:e,...n}=t;return(0,s.kt)(A2o,(0,p.Z)({},z2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The duration of the transition."))}P2o.isMDXComponent=!0;const W2o={toc:[]},R2o="wrapper";function I2o(t){let{components:e,...n}=t;return(0,s.kt)(R2o,(0,p.Z)({},W2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The timing function to use for the transition."))}I2o.isMDXComponent=!0;const S2o={toc:[]},B2o="wrapper";function G2o(t){let{components:e,...n}=t;return(0,s.kt)(B2o,(0,p.Z)({},S2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used together with the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#restore"},(0,s.kt)("inlineCode",{parentName:"a"},"restore"))," method to save a\nnode's current state and later restore it. It is possible to store more\nthan one state by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"save")," method multiple times."))}G2o.isMDXComponent=!0;const E2o={toc:[]},O2o="wrapper";function F2o(t){let{components:e,...n}=t;return(0,s.kt)(O2o,(0,p.Z)({},E2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Push a snapshot of the node's current state onto the node's state stack."))}F2o.isMDXComponent=!0;const U2o={toc:[]},V2o="wrapper";function q2o(t){let{components:e,...n}=t;return(0,s.kt)(V2o,(0,p.Z)({},U2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method assumes that the caller took care of parsing the children and\nupdating the hierarchy."))}q2o.isMDXComponent=!0;const j2o={toc:[]},Y2o="wrapper";function Q2o(t){let{components:e,...n}=t;return(0,s.kt)(Y2o,(0,p.Z)({},j2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Set the children without parsing them."))}Q2o.isMDXComponent=!0;const H2o={toc:[]},K2o="wrapper";function $2o(t){let{components:e,...n}=t;return(0,s.kt)(K2o,(0,p.Z)({},H2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The children to set."))}$2o.isMDXComponent=!0;const J2o={toc:[]},t1o="wrapper";function e1o(t){let{components:e,...n}=t;return(0,s.kt)(t1o,(0,p.Z)({},J2o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,s.kt)("p",null,"Whether the node is cached is decided by the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,s.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}e1o.isMDXComponent=!0;const n1o={toc:[]},o1o="wrapper";function p1o(t){let{components:e,...n}=t;return(0,s.kt)(o1o,(0,p.Z)({},n1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}p1o.isMDXComponent=!0;const r1o={toc:[]},s1o="wrapper";function c1o(t){let{components:e,...n}=t;return(0,s.kt)(s1o,(0,p.Z)({},r1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The context using which the cache will be drawn."))}c1o.isMDXComponent=!0;const a1o={toc:[]},i1o="wrapper";function l1o(t){let{components:e,...n}=t;return(0,s.kt)(i1o,(0,p.Z)({},a1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,s.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}l1o.isMDXComponent=!0;const u1o={toc:[]},m1o="wrapper";function d1o(t){let{components:e,...n}=t;return(0,s.kt)(m1o,(0,p.Z)({},u1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a copy of this node."))}d1o.isMDXComponent=!0;const h1o={toc:[]},f1o="wrapper";function k1o(t){let{components:e,...n}=t;return(0,s.kt)(f1o,(0,p.Z)({},h1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Properties to override."))}k1o.isMDXComponent=!0;const y1o={toc:[]},D1o="wrapper";function M1o(t){let{components:e,...n}=t;return(0,s.kt)(D1o,(0,p.Z)({},y1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}M1o.isMDXComponent=!0;const X1o={toc:[]},_1o="wrapper";function w1o(t){let{components:e,...n}=t;return(0,s.kt)(_1o,(0,p.Z)({},X1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}w1o.isMDXComponent=!0;const T1o={toc:[]},C1o="wrapper";function x1o(t){let{components:e,...n}=t;return(0,s.kt)(C1o,(0,p.Z)({},T1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apply any new layout changes to this node and its children."))}x1o.isMDXComponent=!0;const g1o={toc:[]},v1o="wrapper";function L1o(t){let{components:e,...n}=t;return(0,s.kt)(v1o,(0,p.Z)({},g1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is the same the bounding box returned by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#cacheBBox"},(0,s.kt)("inlineCode",{parentName:"a"},"cacheBBox"))," only\ntransformed to world space."))}L1o.isMDXComponent=!0;const Z1o={toc:[]},b1o="wrapper";function N1o(t){let{components:e,...n}=t;return(0,s.kt)(b1o,(0,p.Z)({},Z1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get a bounding box in world space for the contents rendered by this node as\nwell as its children."))}N1o.isMDXComponent=!0;const z1o={toc:[]},A1o="wrapper";function P1o(t){let{components:e,...n}=t;return(0,s.kt)(A1o,(0,p.Z)({},z1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}P1o.isMDXComponent=!0;const W1o={toc:[]},R1o="wrapper";function I1o(t){let{components:e,...n}=t;return(0,s.kt)(R1o,(0,p.Z)({},W1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}I1o.isMDXComponent=!0;const S1o={toc:[]},B1o="wrapper";function G1o(t){let{components:e,...n}=t;return(0,s.kt)(B1o,(0,p.Z)({},S1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-local matrix for this node."))}G1o.isMDXComponent=!0;const E1o={toc:[]},O1o="wrapper";function F1o(t){let{components:e,...n}=t;return(0,s.kt)(O1o,(0,p.Z)({},E1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}F1o.isMDXComponent=!0;const U1o={toc:[]},V1o="wrapper";function q1o(t){let{components:e,...n}=t;return(0,s.kt)(V1o,(0,p.Z)({},U1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the world-to-parent matrix for this node."))}q1o.isMDXComponent=!0;const j1o={toc:[]},Y1o="wrapper";function Q1o(t){let{components:e,...n}=t;return(0,s.kt)(Y1o,(0,p.Z)({},j1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Q1o.isMDXComponent=!0;const H1o={toc:[]},K1o="wrapper";function $1o(t){let{components:e,...n}=t;return(0,s.kt)(K1o,(0,p.Z)({},H1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}$1o.isMDXComponent=!0;const J1o={toc:[]},t8o="wrapper";function e8o(t){let{components:e,...n}=t;return(0,s.kt)(t8o,(0,p.Z)({},J1o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}e8o.isMDXComponent=!0;const n8o={toc:[]},o8o="wrapper";function p8o(t){let{components:e,...n}=t;return(0,s.kt)(o8o,(0,p.Z)({},n8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}p8o.isMDXComponent=!0;const r8o={toc:[]},s8o="wrapper";function c8o(t){let{components:e,...n}=t;return(0,s.kt)(s8o,(0,p.Z)({},r8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}c8o.isMDXComponent=!0;const a8o={toc:[]},i8o="wrapper";function l8o(t){let{components:e,...n}=t;return(0,s.kt)(i8o,(0,p.Z)({},a8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}l8o.isMDXComponent=!0;const u8o={toc:[]},m8o="wrapper";function d8o(t){let{components:e,...n}=t;return(0,s.kt)(m8o,(0,p.Z)({},u8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}d8o.isMDXComponent=!0;const h8o={toc:[]},f8o="wrapper";function k8o(t){let{components:e,...n}=t;return(0,s.kt)(f8o,(0,p.Z)({},h8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}k8o.isMDXComponent=!0;const y8o={toc:[]},D8o="wrapper";function M8o(t){let{components:e,...n}=t;return(0,s.kt)(D8o,(0,p.Z)({},y8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}M8o.isMDXComponent=!0;const X8o={toc:[]},_8o="wrapper";function w8o(t){let{components:e,...n}=t;return(0,s.kt)(_8o,(0,p.Z)({},X8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}w8o.isMDXComponent=!0;const T8o={toc:[]},C8o="wrapper";function x8o(t){let{components:e,...n}=t;return(0,s.kt)(C8o,(0,p.Z)({},T8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}x8o.isMDXComponent=!0;const g8o={toc:[]},v8o="wrapper";function L8o(t){let{components:e,...n}=t;return(0,s.kt)(v8o,(0,p.Z)({},g8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}L8o.isMDXComponent=!0;const Z8o={toc:[]},b8o="wrapper";function N8o(t){let{components:e,...n}=t;return(0,s.kt)(b8o,(0,p.Z)({},Z8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}N8o.isMDXComponent=!0;const z8o={toc:[]},A8o="wrapper";function P8o(t){let{components:e,...n}=t;return(0,s.kt)(A8o,(0,p.Z)({},z8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}P8o.isMDXComponent=!0;const W8o={toc:[]},R8o="wrapper";function I8o(t){let{components:e,...n}=t;return(0,s.kt)(R8o,(0,p.Z)({},W8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}I8o.isMDXComponent=!0;const S8o={toc:[]},B8o="wrapper";function G8o(t){let{components:e,...n}=t;return(0,s.kt)(B8o,(0,p.Z)({},S8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}G8o.isMDXComponent=!0;const E8o={toc:[]},O8o="wrapper";function F8o(t){let{components:e,...n}=t;return(0,s.kt)(O8o,(0,p.Z)({},E8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}F8o.isMDXComponent=!0;const U8o={toc:[]},V8o="wrapper";function q8o(t){let{components:e,...n}=t;return(0,s.kt)(V8o,(0,p.Z)({},U8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}q8o.isMDXComponent=!0;const j8o={toc:[]},Y8o="wrapper";function Q8o(t){let{components:e,...n}=t;return(0,s.kt)(Y8o,(0,p.Z)({},j8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to true, the path of this circle will start and end at the center.\nThis can be used to fine-tune how sectors are rendered."))}Q8o.isMDXComponent=!0;const H8o={toc:[]},K8o="wrapper";function $8o(t){let{components:e,...n}=t;return(0,s.kt)(K8o,(0,p.Z)({},H8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the path of this circle should be closed."))}$8o.isMDXComponent=!0;const J8o={toc:[]},t5o="wrapper";function e5o(t){let{components:e,...n}=t;return(0,s.kt)(t5o,(0,p.Z)({},J8o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the circle begins at ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," and is drawn clockwise\nuntil reaching ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle")),". Setting this property to true will reverse\nthis direction."))}e5o.isMDXComponent=!0;const n5o={toc:[]},o5o="wrapper";function p5o(t){let{components:e,...n}=t;return(0,s.kt)(o5o,(0,p.Z)({},n5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the circle sector should be drawn counterclockwise."))}p5o.isMDXComponent=!0;const r5o={toc:[]},s5o="wrapper";function c5o(t){let{components:e,...n}=t;return(0,s.kt)(s5o,(0,p.Z)({},r5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}c5o.isMDXComponent=!0;const a5o={toc:[]},i5o="wrapper";function l5o(t){let{components:e,...n}=t;return(0,s.kt)(i5o,(0,p.Z)({},a5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}l5o.isMDXComponent=!0;const u5o={toc:[]},m5o="wrapper";function d5o(t){let{components:e,...n}=t;return(0,s.kt)(m5o,(0,p.Z)({},u5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"endAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}d5o.isMDXComponent=!0;const h5o={toc:[]},f5o="wrapper";function k5o(t){let{components:e,...n}=t;return(0,s.kt)(f5o,(0,p.Z)({},h5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending angle in degrees for the circle sector."))}k5o.isMDXComponent=!0;const y5o={toc:[]},D5o="wrapper";function M5o(t){let{components:e,...n}=t;return(0,s.kt)(D5o,(0,p.Z)({},y5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}M5o.isMDXComponent=!0;const X5o={toc:[]},_5o="wrapper";function w5o(t){let{components:e,...n}=t;return(0,s.kt)(_5o,(0,p.Z)({},X5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}w5o.isMDXComponent=!0;const T5o={toc:[]},C5o="wrapper";function x5o(t){let{components:e,...n}=t;return(0,s.kt)(C5o,(0,p.Z)({},T5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}x5o.isMDXComponent=!0;const g5o={toc:[]},v5o="wrapper";function L5o(t){let{components:e,...n}=t;return(0,s.kt)(v5o,(0,p.Z)({},g5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}L5o.isMDXComponent=!0;const Z5o={toc:[]},b5o="wrapper";function N5o(t){let{components:e,...n}=t;return(0,s.kt)(b5o,(0,p.Z)({},Z5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}N5o.isMDXComponent=!0;const z5o={toc:[]},A5o="wrapper";function P5o(t){let{components:e,...n}=t;return(0,s.kt)(A5o,(0,p.Z)({},z5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}P5o.isMDXComponent=!0;const W5o={toc:[]},R5o="wrapper";function I5o(t){let{components:e,...n}=t;return(0,s.kt)(R5o,(0,p.Z)({},W5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}I5o.isMDXComponent=!0;const S5o={toc:[]},B5o="wrapper";function G5o(t){let{components:e,...n}=t;return(0,s.kt)(B5o,(0,p.Z)({},S5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}G5o.isMDXComponent=!0;const E5o={toc:[]},O5o="wrapper";function F5o(t){let{components:e,...n}=t;return(0,s.kt)(O5o,(0,p.Z)({},E5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}F5o.isMDXComponent=!0;const U5o={toc:[]},V5o="wrapper";function q5o(t){let{components:e,...n}=t;return(0,s.kt)(V5o,(0,p.Z)({},U5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}q5o.isMDXComponent=!0;const j5o={toc:[]},Y5o="wrapper";function Q5o(t){let{components:e,...n}=t;return(0,s.kt)(Y5o,(0,p.Z)({},j5o,n,{components:e,mdxType:"MDXLayout"}))}Q5o.isMDXComponent=!0;const H5o={toc:[]},K5o="wrapper";function $5o(t){let{components:e,...n}=t;return(0,s.kt)(K5o,(0,p.Z)({},H5o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}$5o.isMDXComponent=!0;const J5o={toc:[]},t9o="wrapper";function e9o(t){let{components:e,...n}=t;return(0,s.kt)(t9o,(0,p.Z)({},J5o,n,{components:e,mdxType:"MDXLayout"}))}e9o.isMDXComponent=!0;const n9o={toc:[]},o9o="wrapper";function p9o(t){let{components:e,...n}=t;return(0,s.kt)(o9o,(0,p.Z)({},n9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}p9o.isMDXComponent=!0;const r9o={toc:[]},s9o="wrapper";function c9o(t){let{components:e,...n}=t;return(0,s.kt)(s9o,(0,p.Z)({},r9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}c9o.isMDXComponent=!0;const a9o={toc:[]},i9o="wrapper";function l9o(t){let{components:e,...n}=t;return(0,s.kt)(i9o,(0,p.Z)({},a9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property can be used together with ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#startAngle"},(0,s.kt)("inlineCode",{parentName:"a"},"startAngle"))," to turn this\ncircle into a sector (when using fill) or an arc (when using stroke)."))}l9o.isMDXComponent=!0;const u9o={toc:[]},m9o="wrapper";function d9o(t){let{components:e,...n}=t;return(0,s.kt)(m9o,(0,p.Z)({},u9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting angle in degrees for the circle sector."))}d9o.isMDXComponent=!0;const h9o={toc:[]},f9o="wrapper";function k9o(t){let{components:e,...n}=t;return(0,s.kt)(f9o,(0,p.Z)({},h9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}k9o.isMDXComponent=!0;const y9o={toc:[]},D9o="wrapper";function M9o(t){let{components:e,...n}=t;return(0,s.kt)(D9o,(0,p.Z)({},y9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}M9o.isMDXComponent=!0;const X9o={toc:[]},_9o="wrapper";function w9o(t){let{components:e,...n}=t;return(0,s.kt)(_9o,(0,p.Z)({},X9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CircleProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}w9o.isMDXComponent=!0;const T9o={toc:[]},C9o="wrapper";function x9o(t){let{components:e,...n}=t;return(0,s.kt)(C9o,(0,p.Z)({},T9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}x9o.isMDXComponent=!0;const g9o={toc:[]},v9o="wrapper";function L9o(t){let{components:e,...n}=t;return(0,s.kt)(v9o,(0,p.Z)({},g9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}L9o.isMDXComponent=!0;const Z9o={toc:[]},b9o="wrapper";function N9o(t){let{components:e,...n}=t;return(0,s.kt)(b9o,(0,p.Z)({},Z9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}N9o.isMDXComponent=!0;const z9o={toc:[]},A9o="wrapper";function P9o(t){let{components:e,...n}=t;return(0,s.kt)(A9o,(0,p.Z)({},z9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}P9o.isMDXComponent=!0;const W9o={toc:[]},R9o="wrapper";function I9o(t){let{components:e,...n}=t;return(0,s.kt)(R9o,(0,p.Z)({},W9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}I9o.isMDXComponent=!0;const S9o={toc:[]},B9o="wrapper";function G9o(t){let{components:e,...n}=t;return(0,s.kt)(B9o,(0,p.Z)({},S9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}G9o.isMDXComponent=!0;const E9o={toc:[]},O9o="wrapper";function F9o(t){let{components:e,...n}=t;return(0,s.kt)(O9o,(0,p.Z)({},E9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}F9o.isMDXComponent=!0;const U9o={toc:[]},V9o="wrapper";function q9o(t){let{components:e,...n}=t;return(0,s.kt)(V9o,(0,p.Z)({},U9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}q9o.isMDXComponent=!0;const j9o={toc:[]},Y9o="wrapper";function Q9o(t){let{components:e,...n}=t;return(0,s.kt)(Y9o,(0,p.Z)({},j9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Q9o.isMDXComponent=!0;const H9o={toc:[]},K9o="wrapper";function $9o(t){let{components:e,...n}=t;return(0,s.kt)(K9o,(0,p.Z)({},H9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$9o.isMDXComponent=!0;const J9o={toc:[]},ttp="wrapper";function etp(t){let{components:e,...n}=t;return(0,s.kt)(ttp,(0,p.Z)({},J9o,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}etp.isMDXComponent=!0;const ntp={toc:[]},otp="wrapper";function ptp(t){let{components:e,...n}=t;return(0,s.kt)(otp,(0,p.Z)({},ntp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ptp.isMDXComponent=!0;const rtp={toc:[]},stp="wrapper";function ctp(t){let{components:e,...n}=t;return(0,s.kt)(stp,(0,p.Z)({},rtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}ctp.isMDXComponent=!0;const atp={toc:[]},itp="wrapper";function ltp(t){let{components:e,...n}=t;return(0,s.kt)(itp,(0,p.Z)({},atp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ltp.isMDXComponent=!0;const utp={toc:[]},mtp="wrapper";function dtp(t){let{components:e,...n}=t;return(0,s.kt)(mtp,(0,p.Z)({},utp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}dtp.isMDXComponent=!0;const htp={toc:[]},ftp="wrapper";function ktp(t){let{components:e,...n}=t;return(0,s.kt)(ftp,(0,p.Z)({},htp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}ktp.isMDXComponent=!0;const ytp={toc:[]},Dtp="wrapper";function Mtp(t){let{components:e,...n}=t;return(0,s.kt)(Dtp,(0,p.Z)({},ytp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Mtp.isMDXComponent=!0;const Xtp={toc:[]},_tp="wrapper";function wtp(t){let{components:e,...n}=t;return(0,s.kt)(_tp,(0,p.Z)({},Xtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}wtp.isMDXComponent=!0;const Ttp={toc:[]},Ctp="wrapper";function xtp(t){let{components:e,...n}=t;return(0,s.kt)(Ctp,(0,p.Z)({},Ttp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}xtp.isMDXComponent=!0;const gtp={toc:[]},vtp="wrapper";function Ltp(t){let{components:e,...n}=t;return(0,s.kt)(vtp,(0,p.Z)({},gtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Ltp.isMDXComponent=!0;const Ztp={toc:[]},btp="wrapper";function Ntp(t){let{components:e,...n}=t;return(0,s.kt)(btp,(0,p.Z)({},Ztp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Ntp.isMDXComponent=!0;const ztp={toc:[]},Atp="wrapper";function Ptp(t){let{components:e,...n}=t;return(0,s.kt)(Atp,(0,p.Z)({},ztp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Ptp.isMDXComponent=!0;const Wtp={toc:[]},Rtp="wrapper";function Itp(t){let{components:e,...n}=t;return(0,s.kt)(Rtp,(0,p.Z)({},Wtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Itp.isMDXComponent=!0;const Stp={toc:[]},Btp="wrapper";function Gtp(t){let{components:e,...n}=t;return(0,s.kt)(Btp,(0,p.Z)({},Stp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Gtp.isMDXComponent=!0;const Etp={toc:[]},Otp="wrapper";function Ftp(t){let{components:e,...n}=t;return(0,s.kt)(Otp,(0,p.Z)({},Etp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Ftp.isMDXComponent=!0;const Utp={toc:[]},Vtp="wrapper";function qtp(t){let{components:e,...n}=t;return(0,s.kt)(Vtp,(0,p.Z)({},Utp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}qtp.isMDXComponent=!0;const jtp={toc:[]},Ytp="wrapper";function Qtp(t){let{components:e,...n}=t;return(0,s.kt)(Ytp,(0,p.Z)({},jtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Qtp.isMDXComponent=!0;const Htp={toc:[]},Ktp="wrapper";function $tp(t){let{components:e,...n}=t;return(0,s.kt)(Ktp,(0,p.Z)({},Htp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}$tp.isMDXComponent=!0;const Jtp={toc:[]},tep="wrapper";function eep(t){let{components:e,...n}=t;return(0,s.kt)(tep,(0,p.Z)({},Jtp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}eep.isMDXComponent=!0;const nep={toc:[]},oep="wrapper";function pep(t){let{components:e,...n}=t;return(0,s.kt)(oep,(0,p.Z)({},nep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}pep.isMDXComponent=!0;const rep={toc:[]},sep="wrapper";function cep(t){let{components:e,...n}=t;return(0,s.kt)(sep,(0,p.Z)({},rep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}cep.isMDXComponent=!0;const aep={toc:[]},iep="wrapper";function lep(t){let{components:e,...n}=t;return(0,s.kt)(iep,(0,p.Z)({},aep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}lep.isMDXComponent=!0;const uep={toc:[]},mep="wrapper";function dep(t){let{components:e,...n}=t;return(0,s.kt)(mep,(0,p.Z)({},uep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}dep.isMDXComponent=!0;const hep={toc:[]},fep="wrapper";function kep(t){let{components:e,...n}=t;return(0,s.kt)(fep,(0,p.Z)({},hep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kep.isMDXComponent=!0;const yep={toc:[]},Dep="wrapper";function Mep(t){let{components:e,...n}=t;return(0,s.kt)(Dep,(0,p.Z)({},yep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Mep.isMDXComponent=!0;const Xep={toc:[]},_ep="wrapper";function wep(t){let{components:e,...n}=t;return(0,s.kt)(_ep,(0,p.Z)({},Xep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}wep.isMDXComponent=!0;const Tep={toc:[]},Cep="wrapper";function xep(t){let{components:e,...n}=t;return(0,s.kt)(Cep,(0,p.Z)({},Tep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}xep.isMDXComponent=!0;const gep={toc:[]},vep="wrapper";function Lep(t){let{components:e,...n}=t;return(0,s.kt)(vep,(0,p.Z)({},gep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lep.isMDXComponent=!0;const Zep={toc:[]},bep="wrapper";function Nep(t){let{components:e,...n}=t;return(0,s.kt)(bep,(0,p.Z)({},Zep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Nep.isMDXComponent=!0;const zep={toc:[]},Aep="wrapper";function Pep(t){let{components:e,...n}=t;return(0,s.kt)(Aep,(0,p.Z)({},zep,n,{components:e,mdxType:"MDXLayout"}))}Pep.isMDXComponent=!0;const Wep={toc:[]},Rep="wrapper";function Iep(t){let{components:e,...n}=t;return(0,s.kt)(Rep,(0,p.Z)({},Wep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Iep.isMDXComponent=!0;const Sep={toc:[]},Bep="wrapper";function Gep(t){let{components:e,...n}=t;return(0,s.kt)(Bep,(0,p.Z)({},Sep,n,{components:e,mdxType:"MDXLayout"}))}Gep.isMDXComponent=!0;const Eep={toc:[]},Oep="wrapper";function Fep(t){let{components:e,...n}=t;return(0,s.kt)(Oep,(0,p.Z)({},Eep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Fep.isMDXComponent=!0;const Uep={toc:[]},Vep="wrapper";function qep(t){let{components:e,...n}=t;return(0,s.kt)(Vep,(0,p.Z)({},Uep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}qep.isMDXComponent=!0;const jep={toc:[]},Yep="wrapper";function Qep(t){let{components:e,...n}=t;return(0,s.kt)(Yep,(0,p.Z)({},jep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Qep.isMDXComponent=!0;const Hep={toc:[]},Kep="wrapper";function $ep(t){let{components:e,...n}=t;return(0,s.kt)(Kep,(0,p.Z)({},Hep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}$ep.isMDXComponent=!0;const Jep={toc:[]},tnp="wrapper";function enp(t){let{components:e,...n}=t;return(0,s.kt)(tnp,(0,p.Z)({},Jep,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CubicBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}enp.isMDXComponent=!0;const nnp={toc:[]},onp="wrapper";function pnp(t){let{components:e,...n}=t;return(0,s.kt)(onp,(0,p.Z)({},nnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}pnp.isMDXComponent=!0;const rnp={toc:[]},snp="wrapper";function cnp(t){let{components:e,...n}=t;return(0,s.kt)(snp,(0,p.Z)({},rnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cnp.isMDXComponent=!0;const anp={toc:[]},inp="wrapper";function lnp(t){let{components:e,...n}=t;return(0,s.kt)(inp,(0,p.Z)({},anp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}lnp.isMDXComponent=!0;const unp={toc:[]},mnp="wrapper";function dnp(t){let{components:e,...n}=t;return(0,s.kt)(mnp,(0,p.Z)({},unp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dnp.isMDXComponent=!0;const hnp={toc:[]},fnp="wrapper";function knp(t){let{components:e,...n}=t;return(0,s.kt)(fnp,(0,p.Z)({},hnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}knp.isMDXComponent=!0;const ynp={toc:[]},Dnp="wrapper";function Mnp(t){let{components:e,...n}=t;return(0,s.kt)(Dnp,(0,p.Z)({},ynp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mnp.isMDXComponent=!0;const Xnp={toc:[]},_np="wrapper";function wnp(t){let{components:e,...n}=t;return(0,s.kt)(_np,(0,p.Z)({},Xnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}wnp.isMDXComponent=!0;const Tnp={toc:[]},Cnp="wrapper";function xnp(t){let{components:e,...n}=t;return(0,s.kt)(Cnp,(0,p.Z)({},Tnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}xnp.isMDXComponent=!0;const gnp={toc:[]},vnp="wrapper";function Lnp(t){let{components:e,...n}=t;return(0,s.kt)(vnp,(0,p.Z)({},gnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Lnp.isMDXComponent=!0;const Znp={toc:[]},bnp="wrapper";function Nnp(t){let{components:e,...n}=t;return(0,s.kt)(bnp,(0,p.Z)({},Znp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Nnp.isMDXComponent=!0;const znp={toc:[]},Anp="wrapper";function Pnp(t){let{components:e,...n}=t;return(0,s.kt)(Anp,(0,p.Z)({},znp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Pnp.isMDXComponent=!0;const Wnp={toc:[]},Rnp="wrapper";function Inp(t){let{components:e,...n}=t;return(0,s.kt)(Rnp,(0,p.Z)({},Wnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Inp.isMDXComponent=!0;const Snp={toc:[]},Bnp="wrapper";function Gnp(t){let{components:e,...n}=t;return(0,s.kt)(Bnp,(0,p.Z)({},Snp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Gnp.isMDXComponent=!0;const Enp={toc:[]},Onp="wrapper";function Fnp(t){let{components:e,...n}=t;return(0,s.kt)(Onp,(0,p.Z)({},Enp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Fnp.isMDXComponent=!0;const Unp={toc:[]},Vnp="wrapper";function qnp(t){let{components:e,...n}=t;return(0,s.kt)(Vnp,(0,p.Z)({},Unp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}qnp.isMDXComponent=!0;const jnp={toc:[]},Ynp="wrapper";function Qnp(t){let{components:e,...n}=t;return(0,s.kt)(Ynp,(0,p.Z)({},jnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Qnp.isMDXComponent=!0;const Hnp={toc:[]},Knp="wrapper";function $np(t){let{components:e,...n}=t;return(0,s.kt)(Knp,(0,p.Z)({},Hnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}$np.isMDXComponent=!0;const Jnp={toc:[]},top="wrapper";function eop(t){let{components:e,...n}=t;return(0,s.kt)(top,(0,p.Z)({},Jnp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}eop.isMDXComponent=!0;const nop={toc:[]},oop="wrapper";function pop(t){let{components:e,...n}=t;return(0,s.kt)(oop,(0,p.Z)({},nop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}pop.isMDXComponent=!0;const rop={toc:[]},sop="wrapper";function cop(t){let{components:e,...n}=t;return(0,s.kt)(sop,(0,p.Z)({},rop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}cop.isMDXComponent=!0;const aop={toc:[]},iop="wrapper";function lop(t){let{components:e,...n}=t;return(0,s.kt)(iop,(0,p.Z)({},aop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}lop.isMDXComponent=!0;const uop={toc:[]},mop="wrapper";function dop(t){let{components:e,...n}=t;return(0,s.kt)(mop,(0,p.Z)({},uop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}dop.isMDXComponent=!0;const hop={toc:[]},fop="wrapper";function kop(t){let{components:e,...n}=t;return(0,s.kt)(fop,(0,p.Z)({},hop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}kop.isMDXComponent=!0;const yop={toc:[]},Dop="wrapper";function Mop(t){let{components:e,...n}=t;return(0,s.kt)(Dop,(0,p.Z)({},yop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Mop.isMDXComponent=!0;const Xop={toc:[]},_op="wrapper";function wop(t){let{components:e,...n}=t;return(0,s.kt)(_op,(0,p.Z)({},Xop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}wop.isMDXComponent=!0;const Top={toc:[]},Cop="wrapper";function xop(t){let{components:e,...n}=t;return(0,s.kt)(Cop,(0,p.Z)({},Top,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}xop.isMDXComponent=!0;const gop={toc:[]},vop="wrapper";function Lop(t){let{components:e,...n}=t;return(0,s.kt)(vop,(0,p.Z)({},gop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Lop.isMDXComponent=!0;const Zop={toc:[]},bop="wrapper";function Nop(t){let{components:e,...n}=t;return(0,s.kt)(bop,(0,p.Z)({},Zop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Nop.isMDXComponent=!0;const zop={toc:[]},Aop="wrapper";function Pop(t){let{components:e,...n}=t;return(0,s.kt)(Aop,(0,p.Z)({},zop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Pop.isMDXComponent=!0;const Wop={toc:[]},Rop="wrapper";function Iop(t){let{components:e,...n}=t;return(0,s.kt)(Rop,(0,p.Z)({},Wop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Iop.isMDXComponent=!0;const Sop={toc:[]},Bop="wrapper";function Gop(t){let{components:e,...n}=t;return(0,s.kt)(Bop,(0,p.Z)({},Sop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Gop.isMDXComponent=!0;const Eop={toc:[]},Oop="wrapper";function Fop(t){let{components:e,...n}=t;return(0,s.kt)(Oop,(0,p.Z)({},Eop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Fop.isMDXComponent=!0;const Uop={toc:[]},Vop="wrapper";function qop(t){let{components:e,...n}=t;return(0,s.kt)(Vop,(0,p.Z)({},Uop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}qop.isMDXComponent=!0;const jop={toc:[]},Yop="wrapper";function Qop(t){let{components:e,...n}=t;return(0,s.kt)(Yop,(0,p.Z)({},jop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qop.isMDXComponent=!0;const Hop={toc:[]},Kop="wrapper";function $op(t){let{components:e,...n}=t;return(0,s.kt)(Kop,(0,p.Z)({},Hop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}$op.isMDXComponent=!0;const Jop={toc:[]},tpp="wrapper";function epp(t){let{components:e,...n}=t;return(0,s.kt)(tpp,(0,p.Z)({},Jop,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}epp.isMDXComponent=!0;const npp={toc:[]},opp="wrapper";function ppp(t){let{components:e,...n}=t;return(0,s.kt)(opp,(0,p.Z)({},npp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}ppp.isMDXComponent=!0;const rpp={toc:[]},spp="wrapper";function cpp(t){let{components:e,...n}=t;return(0,s.kt)(spp,(0,p.Z)({},rpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cpp.isMDXComponent=!0;const app={toc:[]},ipp="wrapper";function lpp(t){let{components:e,...n}=t;return(0,s.kt)(ipp,(0,p.Z)({},app,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lpp.isMDXComponent=!0;const upp={toc:[]},mpp="wrapper";function dpp(t){let{components:e,...n}=t;return(0,s.kt)(mpp,(0,p.Z)({},upp,n,{components:e,mdxType:"MDXLayout"}))}dpp.isMDXComponent=!0;const hpp={toc:[]},fpp="wrapper";function kpp(t){let{components:e,...n}=t;return(0,s.kt)(fpp,(0,p.Z)({},hpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}kpp.isMDXComponent=!0;const ypp={toc:[]},Dpp="wrapper";function Mpp(t){let{components:e,...n}=t;return(0,s.kt)(Dpp,(0,p.Z)({},ypp,n,{components:e,mdxType:"MDXLayout"}))}Mpp.isMDXComponent=!0;const Xpp={toc:[]},_pp="wrapper";function wpp(t){let{components:e,...n}=t;return(0,s.kt)(_pp,(0,p.Z)({},Xpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wpp.isMDXComponent=!0;const Tpp={toc:[]},Cpp="wrapper";function xpp(t){let{components:e,...n}=t;return(0,s.kt)(Cpp,(0,p.Z)({},Tpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}xpp.isMDXComponent=!0;const gpp={toc:[]},vpp="wrapper";function Lpp(t){let{components:e,...n}=t;return(0,s.kt)(vpp,(0,p.Z)({},gpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Lpp.isMDXComponent=!0;const Zpp={toc:[]},bpp="wrapper";function Npp(t){let{components:e,...n}=t;return(0,s.kt)(bpp,(0,p.Z)({},Zpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Npp.isMDXComponent=!0;const zpp={toc:[]},App="wrapper";function Ppp(t){let{components:e,...n}=t;return(0,s.kt)(App,(0,p.Z)({},zpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/CurveProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Ppp.isMDXComponent=!0;const Wpp={toc:[]},Rpp="wrapper";function Ipp(t){let{components:e,...n}=t;return(0,s.kt)(Rpp,(0,p.Z)({},Wpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Ipp.isMDXComponent=!0;const Spp={toc:[]},Bpp="wrapper";function Gpp(t){let{components:e,...n}=t;return(0,s.kt)(Bpp,(0,p.Z)({},Spp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Gpp.isMDXComponent=!0;const Epp={toc:[]},Opp="wrapper";function Fpp(t){let{components:e,...n}=t;return(0,s.kt)(Opp,(0,p.Z)({},Epp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Fpp.isMDXComponent=!0;const Upp={toc:[]},Vpp="wrapper";function qpp(t){let{components:e,...n}=t;return(0,s.kt)(Vpp,(0,p.Z)({},Upp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qpp.isMDXComponent=!0;const jpp={toc:[]},Ypp="wrapper";function Qpp(t){let{components:e,...n}=t;return(0,s.kt)(Ypp,(0,p.Z)({},jpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Qpp.isMDXComponent=!0;const Hpp={toc:[]},Kpp="wrapper";function $pp(t){let{components:e,...n}=t;return(0,s.kt)(Kpp,(0,p.Z)({},Hpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$pp.isMDXComponent=!0;const Jpp={toc:[]},trp="wrapper";function erp(t){let{components:e,...n}=t;return(0,s.kt)(trp,(0,p.Z)({},Jpp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}erp.isMDXComponent=!0;const nrp={toc:[]},orp="wrapper";function prp(t){let{components:e,...n}=t;return(0,s.kt)(orp,(0,p.Z)({},nrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}prp.isMDXComponent=!0;const rrp={toc:[]},srp="wrapper";function crp(t){let{components:e,...n}=t;return(0,s.kt)(srp,(0,p.Z)({},rrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}crp.isMDXComponent=!0;const arp={toc:[]},irp="wrapper";function lrp(t){let{components:e,...n}=t;return(0,s.kt)(irp,(0,p.Z)({},arp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lrp.isMDXComponent=!0;const urp={toc:[]},mrp="wrapper";function drp(t){let{components:e,...n}=t;return(0,s.kt)(mrp,(0,p.Z)({},urp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}drp.isMDXComponent=!0;const hrp={toc:[]},frp="wrapper";function krp(t){let{components:e,...n}=t;return(0,s.kt)(frp,(0,p.Z)({},hrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}krp.isMDXComponent=!0;const yrp={toc:[]},Drp="wrapper";function Mrp(t){let{components:e,...n}=t;return(0,s.kt)(Drp,(0,p.Z)({},yrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Mrp.isMDXComponent=!0;const Xrp={toc:[]},_rp="wrapper";function wrp(t){let{components:e,...n}=t;return(0,s.kt)(_rp,(0,p.Z)({},Xrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}wrp.isMDXComponent=!0;const Trp={toc:[]},Crp="wrapper";function xrp(t){let{components:e,...n}=t;return(0,s.kt)(Crp,(0,p.Z)({},Trp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}xrp.isMDXComponent=!0;const grp={toc:[]},vrp="wrapper";function Lrp(t){let{components:e,...n}=t;return(0,s.kt)(vrp,(0,p.Z)({},grp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Lrp.isMDXComponent=!0;const Zrp={toc:[]},brp="wrapper";function Nrp(t){let{components:e,...n}=t;return(0,s.kt)(brp,(0,p.Z)({},Zrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Nrp.isMDXComponent=!0;const zrp={toc:[]},Arp="wrapper";function Prp(t){let{components:e,...n}=t;return(0,s.kt)(Arp,(0,p.Z)({},zrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Prp.isMDXComponent=!0;const Wrp={toc:[]},Rrp="wrapper";function Irp(t){let{components:e,...n}=t;return(0,s.kt)(Rrp,(0,p.Z)({},Wrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Irp.isMDXComponent=!0;const Srp={toc:[]},Brp="wrapper";function Grp(t){let{components:e,...n}=t;return(0,s.kt)(Brp,(0,p.Z)({},Srp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Grp.isMDXComponent=!0;const Erp={toc:[]},Orp="wrapper";function Frp(t){let{components:e,...n}=t;return(0,s.kt)(Orp,(0,p.Z)({},Erp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Frp.isMDXComponent=!0;const Urp={toc:[]},Vrp="wrapper";function qrp(t){let{components:e,...n}=t;return(0,s.kt)(Vrp,(0,p.Z)({},Urp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}qrp.isMDXComponent=!0;const jrp={toc:[]},Yrp="wrapper";function Qrp(t){let{components:e,...n}=t;return(0,s.kt)(Yrp,(0,p.Z)({},jrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Qrp.isMDXComponent=!0;const Hrp={toc:[]},Krp="wrapper";function $rp(t){let{components:e,...n}=t;return(0,s.kt)(Krp,(0,p.Z)({},Hrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes after the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}$rp.isMDXComponent=!0;const Jrp={toc:[]},tsp="wrapper";function esp(t){let{components:e,...n}=t;return(0,s.kt)(tsp,(0,p.Z)({},Jrp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the end of each grid line."))}esp.isMDXComponent=!0;const nsp={toc:[]},osp="wrapper";function psp(t){let{components:e,...n}=t;return(0,s.kt)(osp,(0,p.Z)({},nsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}psp.isMDXComponent=!0;const rsp={toc:[]},ssp="wrapper";function csp(t){let{components:e,...n}=t;return(0,s.kt)(ssp,(0,p.Z)({},rsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}csp.isMDXComponent=!0;const asp={toc:[]},isp="wrapper";function lsp(t){let{components:e,...n}=t;return(0,s.kt)(isp,(0,p.Z)({},asp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}lsp.isMDXComponent=!0;const usp={toc:[]},msp="wrapper";function dsp(t){let{components:e,...n}=t;return(0,s.kt)(msp,(0,p.Z)({},usp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}dsp.isMDXComponent=!0;const hsp={toc:[]},fsp="wrapper";function ksp(t){let{components:e,...n}=t;return(0,s.kt)(fsp,(0,p.Z)({},hsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ksp.isMDXComponent=!0;const ysp={toc:[]},Dsp="wrapper";function Msp(t){let{components:e,...n}=t;return(0,s.kt)(Dsp,(0,p.Z)({},ysp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Msp.isMDXComponent=!0;const Xsp={toc:[]},_sp="wrapper";function wsp(t){let{components:e,...n}=t;return(0,s.kt)(_sp,(0,p.Z)({},Xsp,n,{components:e,mdxType:"MDXLayout"}))}wsp.isMDXComponent=!0;const Tsp={toc:[]},Csp="wrapper";function xsp(t){let{components:e,...n}=t;return(0,s.kt)(Csp,(0,p.Z)({},Tsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The spacing between the grid lines."))}xsp.isMDXComponent=!0;const gsp={toc:[]},vsp="wrapper";function Lsp(t){let{components:e,...n}=t;return(0,s.kt)(vsp,(0,p.Z)({},gsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/GridProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Lsp.isMDXComponent=!0;const Zsp={toc:[]},bsp="wrapper";function Nsp(t){let{components:e,...n}=t;return(0,s.kt)(bsp,(0,p.Z)({},Zsp,n,{components:e,mdxType:"MDXLayout"}))}Nsp.isMDXComponent=!0;const zsp={toc:[]},Asp="wrapper";function Psp(t){let{components:e,...n}=t;return(0,s.kt)(Asp,(0,p.Z)({},zsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of each grid line that comes before the given percentage will\nbe made invisible."),(0,s.kt)("p",null,"This property is useful for animating the grid appearing on-screen."))}Psp.isMDXComponent=!0;const Wsp={toc:[]},Rsp="wrapper";function Isp(t){let{components:e,...n}=t;return(0,s.kt)(Rsp,(0,p.Z)({},Wsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The percentage that should be clipped from the beginning of each grid line."))}Isp.isMDXComponent=!0;const Ssp={toc:[]},Bsp="wrapper";function Gsp(t){let{components:e,...n}=t;return(0,s.kt)(Bsp,(0,p.Z)({},Ssp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Gsp.isMDXComponent=!0;const Esp={toc:[]},Osp="wrapper";function Fsp(t){let{components:e,...n}=t;return(0,s.kt)(Osp,(0,p.Z)({},Esp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Fsp.isMDXComponent=!0;const Usp={toc:[]},Vsp="wrapper";function qsp(t){let{components:e,...n}=t;return(0,s.kt)(Vsp,(0,p.Z)({},Usp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qsp.isMDXComponent=!0;const jsp={toc:[]},Ysp="wrapper";function Qsp(t){let{components:e,...n}=t;return(0,s.kt)(Ysp,(0,p.Z)({},jsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Qsp.isMDXComponent=!0;const Hsp={toc:[]},Ksp="wrapper";function $sp(t){let{components:e,...n}=t;return(0,s.kt)(Ksp,(0,p.Z)({},Hsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$sp.isMDXComponent=!0;const Jsp={toc:[]},tcp="wrapper";function ecp(t){let{components:e,...n}=t;return(0,s.kt)(tcp,(0,p.Z)({},Jsp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}ecp.isMDXComponent=!0;const ncp={toc:[]},ocp="wrapper";function pcp(t){let{components:e,...n}=t;return(0,s.kt)(ocp,(0,p.Z)({},ncp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}pcp.isMDXComponent=!0;const rcp={toc:[]},scp="wrapper";function ccp(t){let{components:e,...n}=t;return(0,s.kt)(scp,(0,p.Z)({},rcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}ccp.isMDXComponent=!0;const acp={toc:[]},icp="wrapper";function lcp(t){let{components:e,...n}=t;return(0,s.kt)(icp,(0,p.Z)({},acp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}lcp.isMDXComponent=!0;const ucp={toc:[]},mcp="wrapper";function dcp(t){let{components:e,...n}=t;return(0,s.kt)(mcp,(0,p.Z)({},ucp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}dcp.isMDXComponent=!0;const hcp={toc:[]},fcp="wrapper";function kcp(t){let{components:e,...n}=t;return(0,s.kt)(fcp,(0,p.Z)({},hcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kcp.isMDXComponent=!0;const ycp={toc:[]},Dcp="wrapper";function Mcp(t){let{components:e,...n}=t;return(0,s.kt)(Dcp,(0,p.Z)({},ycp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Mcp.isMDXComponent=!0;const Xcp={toc:[]},_cp="wrapper";function wcp(t){let{components:e,...n}=t;return(0,s.kt)(_cp,(0,p.Z)({},Xcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wcp.isMDXComponent=!0;const Tcp={toc:[]},Ccp="wrapper";function xcp(t){let{components:e,...n}=t;return(0,s.kt)(Ccp,(0,p.Z)({},Tcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}xcp.isMDXComponent=!0;const gcp={toc:[]},vcp="wrapper";function Lcp(t){let{components:e,...n}=t;return(0,s.kt)(vcp,(0,p.Z)({},gcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lcp.isMDXComponent=!0;const Zcp={toc:[]},bcp="wrapper";function Ncp(t){let{components:e,...n}=t;return(0,s.kt)(bcp,(0,p.Z)({},Zcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ncp.isMDXComponent=!0;const zcp={toc:[]},Acp="wrapper";function Pcp(t){let{components:e,...n}=t;return(0,s.kt)(Acp,(0,p.Z)({},zcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Pcp.isMDXComponent=!0;const Wcp={toc:[]},Rcp="wrapper";function Icp(t){let{components:e,...n}=t;return(0,s.kt)(Rcp,(0,p.Z)({},Wcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Icp.isMDXComponent=!0;const Scp={toc:[]},Bcp="wrapper";function Gcp(t){let{components:e,...n}=t;return(0,s.kt)(Bcp,(0,p.Z)({},Scp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Gcp.isMDXComponent=!0;const Ecp={toc:[]},Ocp="wrapper";function Fcp(t){let{components:e,...n}=t;return(0,s.kt)(Ocp,(0,p.Z)({},Ecp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Fcp.isMDXComponent=!0;const Ucp={toc:[]},Vcp="wrapper";function qcp(t){let{components:e,...n}=t;return(0,s.kt)(Vcp,(0,p.Z)({},Ucp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}qcp.isMDXComponent=!0;const jcp={toc:[]},Ycp="wrapper";function Qcp(t){let{components:e,...n}=t;return(0,s.kt)(Ycp,(0,p.Z)({},jcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Qcp.isMDXComponent=!0;const Hcp={toc:[]},Kcp="wrapper";function $cp(t){let{components:e,...n}=t;return(0,s.kt)(Kcp,(0,p.Z)({},Hcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}$cp.isMDXComponent=!0;const Jcp={toc:[]},tap="wrapper";function eap(t){let{components:e,...n}=t;return(0,s.kt)(tap,(0,p.Z)({},Jcp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}eap.isMDXComponent=!0;const nap={toc:[]},oap="wrapper";function pap(t){let{components:e,...n}=t;return(0,s.kt)(oap,(0,p.Z)({},nap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}pap.isMDXComponent=!0;const rap={toc:[]},sap="wrapper";function cap(t){let{components:e,...n}=t;return(0,s.kt)(sap,(0,p.Z)({},rap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}cap.isMDXComponent=!0;const aap={toc:[]},iap="wrapper";function lap(t){let{components:e,...n}=t;return(0,s.kt)(iap,(0,p.Z)({},aap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}lap.isMDXComponent=!0;const uap={toc:[]},map="wrapper";function dap(t){let{components:e,...n}=t;return(0,s.kt)(map,(0,p.Z)({},uap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}dap.isMDXComponent=!0;const hap={toc:[]},fap="wrapper";function kap(t){let{components:e,...n}=t;return(0,s.kt)(fap,(0,p.Z)({},hap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Provide the color in one of the following formats:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"named color like ",(0,s.kt)("inlineCode",{parentName:"li"},"red"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"darkgray"),", \u2026"),(0,s.kt)("li",{parentName:"ul"},"hexadecimal string with # like ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#141414"),"\nValue can be either RGB or RGBA: ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"#bada55aa")," (latter is partially transparent)\nThe shorthand version (e.g. ",(0,s.kt)("inlineCode",{parentName:"li"},"#abc")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"#aabbcc")," is also possible.)")))}kap.isMDXComponent=!0;const yap={toc:[]},Dap="wrapper";function Map(t){let{components:e,...n}=t;return(0,s.kt)(Dap,(0,p.Z)({},yap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The color of the icon"))}Map.isMDXComponent=!0;const Xap={toc:[]},_ap="wrapper";function wap(t){let{components:e,...n}=t;return(0,s.kt)(_ap,(0,p.Z)({},Xap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}wap.isMDXComponent=!0;const Tap={toc:[]},Cap="wrapper";function xap(t){let{components:e,...n}=t;return(0,s.kt)(Cap,(0,p.Z)({},Tap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}xap.isMDXComponent=!0;const gap={toc:[]},vap="wrapper";function Lap(t){let{components:e,...n}=t;return(0,s.kt)(vap,(0,p.Z)({},gap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Lap.isMDXComponent=!0;const Zap={toc:[]},bap="wrapper";function Nap(t){let{components:e,...n}=t;return(0,s.kt)(bap,(0,p.Z)({},Zap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Nap.isMDXComponent=!0;const zap={toc:[]},Aap="wrapper";function Pap(t){let{components:e,...n}=t;return(0,s.kt)(Aap,(0,p.Z)({},zap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Pap.isMDXComponent=!0;const Wap={toc:[]},Rap="wrapper";function Iap(t){let{components:e,...n}=t;return(0,s.kt)(Rap,(0,p.Z)({},Wap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}Iap.isMDXComponent=!0;const Sap={toc:[]},Bap="wrapper";function Gap(t){let{components:e,...n}=t;return(0,s.kt)(Bap,(0,p.Z)({},Sap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Gap.isMDXComponent=!0;const Eap={toc:[]},Oap="wrapper";function Fap(t){let{components:e,...n}=t;return(0,s.kt)(Oap,(0,p.Z)({},Eap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}Fap.isMDXComponent=!0;const Uap={toc:[]},Vap="wrapper";function qap(t){let{components:e,...n}=t;return(0,s.kt)(Vap,(0,p.Z)({},Uap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"You can find identifiers on ",(0,s.kt)("a",{parentName:"p",href:"https://icones.js.org"},"Ic\xf4nes"),".\nThey can look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"mdi:language-typescript")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:anchor-simple-bold")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ph:activity-bold"))))}qap.isMDXComponent=!0;const jap={toc:[]},Yap="wrapper";function Qap(t){let{components:e,...n}=t;return(0,s.kt)(Yap,(0,p.Z)({},jap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The identifier of the icon."))}Qap.isMDXComponent=!0;const Hap={toc:[]},Kap="wrapper";function $ap(t){let{components:e,...n}=t;return(0,s.kt)(Kap,(0,p.Z)({},Hap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$ap.isMDXComponent=!0;const Jap={toc:[]},tip="wrapper";function eip(t){let{components:e,...n}=t;return(0,s.kt)(tip,(0,p.Z)({},Jap,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}eip.isMDXComponent=!0;const nip={toc:[]},oip="wrapper";function pip(t){let{components:e,...n}=t;return(0,s.kt)(oip,(0,p.Z)({},nip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}pip.isMDXComponent=!0;const rip={toc:[]},sip="wrapper";function cip(t){let{components:e,...n}=t;return(0,s.kt)(sip,(0,p.Z)({},rip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}cip.isMDXComponent=!0;const aip={toc:[]},iip="wrapper";function lip(t){let{components:e,...n}=t;return(0,s.kt)(iip,(0,p.Z)({},aip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}lip.isMDXComponent=!0;const uip={toc:[]},mip="wrapper";function dip(t){let{components:e,...n}=t;return(0,s.kt)(mip,(0,p.Z)({},uip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}dip.isMDXComponent=!0;const hip={toc:[]},fip="wrapper";function kip(t){let{components:e,...n}=t;return(0,s.kt)(fip,(0,p.Z)({},hip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kip.isMDXComponent=!0;const yip={toc:[]},Dip="wrapper";function Mip(t){let{components:e,...n}=t;return(0,s.kt)(Dip,(0,p.Z)({},yip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Mip.isMDXComponent=!0;const Xip={toc:[]},_ip="wrapper";function wip(t){let{components:e,...n}=t;return(0,s.kt)(_ip,(0,p.Z)({},Xip,n,{components:e,mdxType:"MDXLayout"}))}wip.isMDXComponent=!0;const Tip={toc:[]},Cip="wrapper";function xip(t){let{components:e,...n}=t;return(0,s.kt)(Cip,(0,p.Z)({},Tip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}xip.isMDXComponent=!0;const gip={toc:[]},vip="wrapper";function Lip(t){let{components:e,...n}=t;return(0,s.kt)(vip,(0,p.Z)({},gip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Lip.isMDXComponent=!0;const Zip={toc:[]},bip="wrapper";function Nip(t){let{components:e,...n}=t;return(0,s.kt)(bip,(0,p.Z)({},Zip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Nip.isMDXComponent=!0;const zip={toc:[]},Aip="wrapper";function Pip(t){let{components:e,...n}=t;return(0,s.kt)(Aip,(0,p.Z)({},zip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}Pip.isMDXComponent=!0;const Wip={toc:[]},Rip="wrapper";function Iip(t){let{components:e,...n}=t;return(0,s.kt)(Rip,(0,p.Z)({},Wip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Iip.isMDXComponent=!0;const Sip={toc:[]},Bip="wrapper";function Gip(t){let{components:e,...n}=t;return(0,s.kt)(Bip,(0,p.Z)({},Sip,n,{components:e,mdxType:"MDXLayout"}))}Gip.isMDXComponent=!0;const Eip={toc:[]},Oip="wrapper";function Fip(t){let{components:e,...n}=t;return(0,s.kt)(Oip,(0,p.Z)({},Eip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}Fip.isMDXComponent=!0;const Uip={toc:[]},Vip="wrapper";function qip(t){let{components:e,...n}=t;return(0,s.kt)(Vip,(0,p.Z)({},Uip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qip.isMDXComponent=!0;const jip={toc:[]},Yip="wrapper";function Qip(t){let{components:e,...n}=t;return(0,s.kt)(Yip,(0,p.Z)({},jip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Qip.isMDXComponent=!0;const Hip={toc:[]},Kip="wrapper";function $ip(t){let{components:e,...n}=t;return(0,s.kt)(Kip,(0,p.Z)({},Hip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}$ip.isMDXComponent=!0;const Jip={toc:[]},tlp="wrapper";function elp(t){let{components:e,...n}=t;return(0,s.kt)(tlp,(0,p.Z)({},Jip,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}elp.isMDXComponent=!0;const nlp={toc:[]},olp="wrapper";function plp(t){let{components:e,...n}=t;return(0,s.kt)(olp,(0,p.Z)({},nlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/IconProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}plp.isMDXComponent=!0;const rlp={toc:[]},slp="wrapper";function clp(t){let{components:e,...n}=t;return(0,s.kt)(slp,(0,p.Z)({},rlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}clp.isMDXComponent=!0;const alp={toc:[]},ilp="wrapper";function llp(t){let{components:e,...n}=t;return(0,s.kt)(ilp,(0,p.Z)({},alp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}llp.isMDXComponent=!0;const ulp={toc:[]},mlp="wrapper";function dlp(t){let{components:e,...n}=t;return(0,s.kt)(mlp,(0,p.Z)({},ulp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}dlp.isMDXComponent=!0;const hlp={toc:[]},flp="wrapper";function klp(t){let{components:e,...n}=t;return(0,s.kt)(flp,(0,p.Z)({},hlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}klp.isMDXComponent=!0;const ylp={toc:[]},Dlp="wrapper";function Mlp(t){let{components:e,...n}=t;return(0,s.kt)(Dlp,(0,p.Z)({},ylp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Mlp.isMDXComponent=!0;const Xlp={toc:[]},_lp="wrapper";function wlp(t){let{components:e,...n}=t;return(0,s.kt)(_lp,(0,p.Z)({},Xlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wlp.isMDXComponent=!0;const Tlp={toc:[]},Clp="wrapper";function xlp(t){let{components:e,...n}=t;return(0,s.kt)(Clp,(0,p.Z)({},Tlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}xlp.isMDXComponent=!0;const glp={toc:[]},vlp="wrapper";function Llp(t){let{components:e,...n}=t;return(0,s.kt)(vlp,(0,p.Z)({},glp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Llp.isMDXComponent=!0;const Zlp={toc:[]},blp="wrapper";function Nlp(t){let{components:e,...n}=t;return(0,s.kt)(blp,(0,p.Z)({},Zlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}Nlp.isMDXComponent=!0;const zlp={toc:[]},Alp="wrapper";function Plp(t){let{components:e,...n}=t;return(0,s.kt)(Alp,(0,p.Z)({},zlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Plp.isMDXComponent=!0;const Wlp={toc:[]},Rlp="wrapper";function Ilp(t){let{components:e,...n}=t;return(0,s.kt)(Rlp,(0,p.Z)({},Wlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Ilp.isMDXComponent=!0;const Slp={toc:[]},Blp="wrapper";function Glp(t){let{components:e,...n}=t;return(0,s.kt)(Blp,(0,p.Z)({},Slp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Glp.isMDXComponent=!0;const Elp={toc:[]},Olp="wrapper";function Flp(t){let{components:e,...n}=t;return(0,s.kt)(Olp,(0,p.Z)({},Elp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Flp.isMDXComponent=!0;const Ulp={toc:[]},Vlp="wrapper";function qlp(t){let{components:e,...n}=t;return(0,s.kt)(Vlp,(0,p.Z)({},Ulp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qlp.isMDXComponent=!0;const jlp={toc:[]},Ylp="wrapper";function Qlp(t){let{components:e,...n}=t;return(0,s.kt)(Ylp,(0,p.Z)({},jlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Qlp.isMDXComponent=!0;const Hlp={toc:[]},Klp="wrapper";function $lp(t){let{components:e,...n}=t;return(0,s.kt)(Klp,(0,p.Z)({},Hlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$lp.isMDXComponent=!0;const Jlp={toc:[]},tup="wrapper";function eup(t){let{components:e,...n}=t;return(0,s.kt)(tup,(0,p.Z)({},Jlp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}eup.isMDXComponent=!0;const nup={toc:[]},oup="wrapper";function pup(t){let{components:e,...n}=t;return(0,s.kt)(oup,(0,p.Z)({},nup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}pup.isMDXComponent=!0;const rup={toc:[]},sup="wrapper";function cup(t){let{components:e,...n}=t;return(0,s.kt)(sup,(0,p.Z)({},rup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}cup.isMDXComponent=!0;const aup={toc:[]},iup="wrapper";function lup(t){let{components:e,...n}=t;return(0,s.kt)(iup,(0,p.Z)({},aup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}lup.isMDXComponent=!0;const uup={toc:[]},mup="wrapper";function dup(t){let{components:e,...n}=t;return(0,s.kt)(mup,(0,p.Z)({},uup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}dup.isMDXComponent=!0;const hup={toc:[]},fup="wrapper";function kup(t){let{components:e,...n}=t;return(0,s.kt)(fup,(0,p.Z)({},hup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}kup.isMDXComponent=!0;const yup={toc:[]},Dup="wrapper";function Mup(t){let{components:e,...n}=t;return(0,s.kt)(Dup,(0,p.Z)({},yup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Mup.isMDXComponent=!0;const Xup={toc:[]},_up="wrapper";function wup(t){let{components:e,...n}=t;return(0,s.kt)(_up,(0,p.Z)({},Xup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}wup.isMDXComponent=!0;const Tup={toc:[]},Cup="wrapper";function xup(t){let{components:e,...n}=t;return(0,s.kt)(Cup,(0,p.Z)({},Tup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}xup.isMDXComponent=!0;const gup={toc:[]},vup="wrapper";function Lup(t){let{components:e,...n}=t;return(0,s.kt)(vup,(0,p.Z)({},gup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Lup.isMDXComponent=!0;const Zup={toc:[]},bup="wrapper";function Nup(t){let{components:e,...n}=t;return(0,s.kt)(bup,(0,p.Z)({},Zup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Nup.isMDXComponent=!0;const zup={toc:[]},Aup="wrapper";function Pup(t){let{components:e,...n}=t;return(0,s.kt)(Aup,(0,p.Z)({},zup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Pup.isMDXComponent=!0;const Wup={toc:[]},Rup="wrapper";function Iup(t){let{components:e,...n}=t;return(0,s.kt)(Rup,(0,p.Z)({},Wup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}Iup.isMDXComponent=!0;const Sup={toc:[]},Bup="wrapper";function Gup(t){let{components:e,...n}=t;return(0,s.kt)(Bup,(0,p.Z)({},Sup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}Gup.isMDXComponent=!0;const Eup={toc:[]},Oup="wrapper";function Fup(t){let{components:e,...n}=t;return(0,s.kt)(Oup,(0,p.Z)({},Eup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}Fup.isMDXComponent=!0;const Uup={toc:[]},Vup="wrapper";function qup(t){let{components:e,...n}=t;return(0,s.kt)(Vup,(0,p.Z)({},Uup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qup.isMDXComponent=!0;const jup={toc:[]},Yup="wrapper";function Qup(t){let{components:e,...n}=t;return(0,s.kt)(Yup,(0,p.Z)({},jup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}Qup.isMDXComponent=!0;const Hup={toc:[]},Kup="wrapper";function $up(t){let{components:e,...n}=t;return(0,s.kt)(Kup,(0,p.Z)({},Hup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}$up.isMDXComponent=!0;const Jup={toc:[]},tmp="wrapper";function emp(t){let{components:e,...n}=t;return(0,s.kt)(tmp,(0,p.Z)({},Jup,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}emp.isMDXComponent=!0;const nmp={toc:[]},omp="wrapper";function pmp(t){let{components:e,...n}=t;return(0,s.kt)(omp,(0,p.Z)({},nmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}pmp.isMDXComponent=!0;const rmp={toc:[]},smp="wrapper";function cmp(t){let{components:e,...n}=t;return(0,s.kt)(smp,(0,p.Z)({},rmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}cmp.isMDXComponent=!0;const amp={toc:[]},imp="wrapper";function lmp(t){let{components:e,...n}=t;return(0,s.kt)(imp,(0,p.Z)({},amp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lmp.isMDXComponent=!0;const ump={toc:[]},mmp="wrapper";function dmp(t){let{components:e,...n}=t;return(0,s.kt)(mmp,(0,p.Z)({},ump,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}dmp.isMDXComponent=!0;const hmp={toc:[]},fmp="wrapper";function kmp(t){let{components:e,...n}=t;return(0,s.kt)(fmp,(0,p.Z)({},hmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}kmp.isMDXComponent=!0;const ymp={toc:[]},Dmp="wrapper";function Mmp(t){let{components:e,...n}=t;return(0,s.kt)(Dmp,(0,p.Z)({},ymp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Mmp.isMDXComponent=!0;const Xmp={toc:[]},_mp="wrapper";function wmp(t){let{components:e,...n}=t;return(0,s.kt)(_mp,(0,p.Z)({},Xmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}wmp.isMDXComponent=!0;const Tmp={toc:[]},Cmp="wrapper";function xmp(t){let{components:e,...n}=t;return(0,s.kt)(Cmp,(0,p.Z)({},Tmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}xmp.isMDXComponent=!0;const gmp={toc:[]},vmp="wrapper";function Lmp(t){let{components:e,...n}=t;return(0,s.kt)(vmp,(0,p.Z)({},gmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lmp.isMDXComponent=!0;const Zmp={toc:[]},bmp="wrapper";function Nmp(t){let{components:e,...n}=t;return(0,s.kt)(bmp,(0,p.Z)({},Zmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}Nmp.isMDXComponent=!0;const zmp={toc:[]},Amp="wrapper";function Pmp(t){let{components:e,...n}=t;return(0,s.kt)(Amp,(0,p.Z)({},zmp,n,{components:e,mdxType:"MDXLayout"}))}Pmp.isMDXComponent=!0;const Wmp={toc:[]},Rmp="wrapper";function Imp(t){let{components:e,...n}=t;return(0,s.kt)(Rmp,(0,p.Z)({},Wmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}Imp.isMDXComponent=!0;const Smp={toc:[]},Bmp="wrapper";function Gmp(t){let{components:e,...n}=t;return(0,s.kt)(Bmp,(0,p.Z)({},Smp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}Gmp.isMDXComponent=!0;const Emp={toc:[]},Omp="wrapper";function Fmp(t){let{components:e,...n}=t;return(0,s.kt)(Omp,(0,p.Z)({},Emp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}Fmp.isMDXComponent=!0;const Ump={toc:[]},Vmp="wrapper";function qmp(t){let{components:e,...n}=t;return(0,s.kt)(Vmp,(0,p.Z)({},Ump,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}qmp.isMDXComponent=!0;const jmp={toc:[]},Ymp="wrapper";function Qmp(t){let{components:e,...n}=t;return(0,s.kt)(Ymp,(0,p.Z)({},jmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Qmp.isMDXComponent=!0;const Hmp={toc:[]},Kmp="wrapper";function $mp(t){let{components:e,...n}=t;return(0,s.kt)(Kmp,(0,p.Z)({},Hmp,n,{components:e,mdxType:"MDXLayout"}))}$mp.isMDXComponent=!0;const Jmp={toc:[]},tdp="wrapper";function edp(t){let{components:e,...n}=t;return(0,s.kt)(tdp,(0,p.Z)({},Jmp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}edp.isMDXComponent=!0;const ndp={toc:[]},odp="wrapper";function pdp(t){let{components:e,...n}=t;return(0,s.kt)(odp,(0,p.Z)({},ndp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}pdp.isMDXComponent=!0;const rdp={toc:[]},sdp="wrapper";function cdp(t){let{components:e,...n}=t;return(0,s.kt)(sdp,(0,p.Z)({},rdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}cdp.isMDXComponent=!0;const adp={toc:[]},idp="wrapper";function ldp(t){let{components:e,...n}=t;return(0,s.kt)(idp,(0,p.Z)({},adp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}ldp.isMDXComponent=!0;const udp={toc:[]},mdp="wrapper";function ddp(t){let{components:e,...n}=t;return(0,s.kt)(mdp,(0,p.Z)({},udp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}ddp.isMDXComponent=!0;const hdp={toc:[]},fdp="wrapper";function kdp(t){let{components:e,...n}=t;return(0,s.kt)(fdp,(0,p.Z)({},hdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ImgProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}kdp.isMDXComponent=!0;const ydp={toc:[]},Ddp="wrapper";function Mdp(t){let{components:e,...n}=t;return(0,s.kt)(Ddp,(0,p.Z)({},ydp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Mdp.isMDXComponent=!0;const Xdp={toc:[]},_dp="wrapper";function wdp(t){let{components:e,...n}=t;return(0,s.kt)(_dp,(0,p.Z)({},Xdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wdp.isMDXComponent=!0;const Tdp={toc:[]},Cdp="wrapper";function xdp(t){let{components:e,...n}=t;return(0,s.kt)(Cdp,(0,p.Z)({},Tdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}xdp.isMDXComponent=!0;const gdp={toc:[]},vdp="wrapper";function Ldp(t){let{components:e,...n}=t;return(0,s.kt)(vdp,(0,p.Z)({},gdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ldp.isMDXComponent=!0;const Zdp={toc:[]},bdp="wrapper";function Ndp(t){let{components:e,...n}=t;return(0,s.kt)(bdp,(0,p.Z)({},Zdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Ndp.isMDXComponent=!0;const zdp={toc:[]},Adp="wrapper";function Pdp(t){let{components:e,...n}=t;return(0,s.kt)(Adp,(0,p.Z)({},zdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pdp.isMDXComponent=!0;const Wdp={toc:[]},Rdp="wrapper";function Idp(t){let{components:e,...n}=t;return(0,s.kt)(Rdp,(0,p.Z)({},Wdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Idp.isMDXComponent=!0;const Sdp={toc:[]},Bdp="wrapper";function Gdp(t){let{components:e,...n}=t;return(0,s.kt)(Bdp,(0,p.Z)({},Sdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property has no effect if no explicit handles are provided for the\nknot."))}Gdp.isMDXComponent=!0;const Edp={toc:[]},Odp="wrapper";function Fdp(t){let{components:e,...n}=t;return(0,s.kt)(Odp,(0,p.Z)({},Edp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"How much to blend between the user-provided handles and the auto-calculated\nhandles."))}Fdp.isMDXComponent=!0;const Udp={toc:[]},Vdp="wrapper";function qdp(t){let{components:e,...n}=t;return(0,s.kt)(Vdp,(0,p.Z)({},Udp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}qdp.isMDXComponent=!0;const jdp={toc:[]},Ydp="wrapper";function Qdp(t){let{components:e,...n}=t;return(0,s.kt)(Ydp,(0,p.Z)({},jdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Qdp.isMDXComponent=!0;const Hdp={toc:[]},Kdp="wrapper";function $dp(t){let{components:e,...n}=t;return(0,s.kt)(Kdp,(0,p.Z)({},Hdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}$dp.isMDXComponent=!0;const Jdp={toc:[]},thp="wrapper";function ehp(t){let{components:e,...n}=t;return(0,s.kt)(thp,(0,p.Z)({},Jdp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}ehp.isMDXComponent=!0;const nhp={toc:[]},ohp="wrapper";function php(t){let{components:e,...n}=t;return(0,s.kt)(ohp,(0,p.Z)({},nhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}php.isMDXComponent=!0;const rhp={toc:[]},shp="wrapper";function chp(t){let{components:e,...n}=t;return(0,s.kt)(shp,(0,p.Z)({},rhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}chp.isMDXComponent=!0;const ahp={toc:[]},ihp="wrapper";function lhp(t){let{components:e,...n}=t;return(0,s.kt)(ihp,(0,p.Z)({},ahp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}lhp.isMDXComponent=!0;const uhp={toc:[]},mhp="wrapper";function dhp(t){let{components:e,...n}=t;return(0,s.kt)(mhp,(0,p.Z)({},uhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}dhp.isMDXComponent=!0;const hhp={toc:[]},fhp="wrapper";function khp(t){let{components:e,...n}=t;return(0,s.kt)(fhp,(0,p.Z)({},hhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}khp.isMDXComponent=!0;const yhp={toc:[]},Dhp="wrapper";function Mhp(t){let{components:e,...n}=t;return(0,s.kt)(Dhp,(0,p.Z)({},yhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Mhp.isMDXComponent=!0;const Xhp={toc:[]},_hp="wrapper";function whp(t){let{components:e,...n}=t;return(0,s.kt)(_hp,(0,p.Z)({},Xhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the end handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#startHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"startHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}whp.isMDXComponent=!0;const Thp={toc:[]},Chp="wrapper";function xhp(t){let{components:e,...n}=t;return(0,s.kt)(Chp,(0,p.Z)({},Thp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's end handle. The position is provided relative\nto the knot's position."))}xhp.isMDXComponent=!0;const ghp={toc:[]},vhp="wrapper";function Lhp(t){let{components:e,...n}=t;return(0,s.kt)(vhp,(0,p.Z)({},ghp,n,{components:e,mdxType:"MDXLayout"}))}Lhp.isMDXComponent=!0;const Zhp={toc:[]},bhp="wrapper";function Nhp(t){let{components:e,...n}=t;return(0,s.kt)(bhp,(0,p.Z)({},Zhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Nhp.isMDXComponent=!0;const zhp={toc:[]},Ahp="wrapper";function Php(t){let{components:e,...n}=t;return(0,s.kt)(Ahp,(0,p.Z)({},zhp,n,{components:e,mdxType:"MDXLayout"}))}Php.isMDXComponent=!0;const Whp={toc:[]},Rhp="wrapper";function Ihp(t){let{components:e,...n}=t;return(0,s.kt)(Rhp,(0,p.Z)({},Whp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the position of the start handle will be the mirrored position\nof the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#endHandle"},(0,s.kt)("inlineCode",{parentName:"a"},"endHandle")),"."),(0,s.kt)("p",null,"If neither an end handle nor a start handle is provided, the positions of\nthe handles gets calculated automatically to create smooth curve through\nthe knot. The smoothness of the resulting curve can be controlled via the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/Spline#smoothness"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothness"))," property."),(0,s.kt)("p",null,"It is also possible to blend between a user-defined position and the\nauto-calculated position by using the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/KnotProps#auto"},(0,s.kt)("inlineCode",{parentName:"a"},"auto"))," property."))}Ihp.isMDXComponent=!0;const Shp={toc:[]},Bhp="wrapper";function Ghp(t){let{components:e,...n}=t;return(0,s.kt)(Bhp,(0,p.Z)({},Shp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the knot's start handle. The position is provided relative\nto the knot's position."))}Ghp.isMDXComponent=!0;const Ehp={toc:[]},Ohp="wrapper";function Fhp(t){let{components:e,...n}=t;return(0,s.kt)(Ohp,(0,p.Z)({},Ehp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the image itself, leaving the\nfill, stroke, and children intact."))}Fhp.isMDXComponent=!0;const Uhp={toc:[]},Vhp="wrapper";function qhp(t){let{components:e,...n}=t;return(0,s.kt)(Vhp,(0,p.Z)({},Uhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this image."))}qhp.isMDXComponent=!0;const jhp={toc:[]},Yhp="wrapper";function Qhp(t){let{components:e,...n}=t;return(0,s.kt)(Yhp,(0,p.Z)({},jhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Qhp.isMDXComponent=!0;const Hhp={toc:[]},Khp="wrapper";function $hp(t){let{components:e,...n}=t;return(0,s.kt)(Khp,(0,p.Z)({},Hhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}$hp.isMDXComponent=!0;const Jhp={toc:[]},tfp="wrapper";function efp(t){let{components:e,...n}=t;return(0,s.kt)(tfp,(0,p.Z)({},Jhp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}efp.isMDXComponent=!0;const nfp={toc:[]},ofp="wrapper";function pfp(t){let{components:e,...n}=t;return(0,s.kt)(ofp,(0,p.Z)({},nfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}pfp.isMDXComponent=!0;const rfp={toc:[]},sfp="wrapper";function cfp(t){let{components:e,...n}=t;return(0,s.kt)(sfp,(0,p.Z)({},rfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cfp.isMDXComponent=!0;const afp={toc:[]},ifp="wrapper";function lfp(t){let{components:e,...n}=t;return(0,s.kt)(ifp,(0,p.Z)({},afp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}lfp.isMDXComponent=!0;const ufp={toc:[]},mfp="wrapper";function dfp(t){let{components:e,...n}=t;return(0,s.kt)(mfp,(0,p.Z)({},ufp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dfp.isMDXComponent=!0;const hfp={toc:[]},ffp="wrapper";function kfp(t){let{components:e,...n}=t;return(0,s.kt)(ffp,(0,p.Z)({},hfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kfp.isMDXComponent=!0;const yfp={toc:[]},Dfp="wrapper";function Mfp(t){let{components:e,...n}=t;return(0,s.kt)(Dfp,(0,p.Z)({},yfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Mfp.isMDXComponent=!0;const Xfp={toc:[]},_fp="wrapper";function wfp(t){let{components:e,...n}=t;return(0,s.kt)(_fp,(0,p.Z)({},Xfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}wfp.isMDXComponent=!0;const Tfp={toc:[]},Cfp="wrapper";function xfp(t){let{components:e,...n}=t;return(0,s.kt)(Cfp,(0,p.Z)({},Tfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}xfp.isMDXComponent=!0;const gfp={toc:[]},vfp="wrapper";function Lfp(t){let{components:e,...n}=t;return(0,s.kt)(vfp,(0,p.Z)({},gfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Lfp.isMDXComponent=!0;const Zfp={toc:[]},bfp="wrapper";function Nfp(t){let{components:e,...n}=t;return(0,s.kt)(bfp,(0,p.Z)({},Zfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Nfp.isMDXComponent=!0;const zfp={toc:[]},Afp="wrapper";function Pfp(t){let{components:e,...n}=t;return(0,s.kt)(Afp,(0,p.Z)({},zfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Pfp.isMDXComponent=!0;const Wfp={toc:[]},Rfp="wrapper";function Ifp(t){let{components:e,...n}=t;return(0,s.kt)(Rfp,(0,p.Z)({},Wfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Ifp.isMDXComponent=!0;const Sfp={toc:[]},Bfp="wrapper";function Gfp(t){let{components:e,...n}=t;return(0,s.kt)(Bfp,(0,p.Z)({},Sfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Gfp.isMDXComponent=!0;const Efp={toc:[]},Ofp="wrapper";function Ffp(t){let{components:e,...n}=t;return(0,s.kt)(Ofp,(0,p.Z)({},Efp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Ffp.isMDXComponent=!0;const Ufp={toc:[]},Vfp="wrapper";function qfp(t){let{components:e,...n}=t;return(0,s.kt)(Vfp,(0,p.Z)({},Ufp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}qfp.isMDXComponent=!0;const jfp={toc:[]},Yfp="wrapper";function Qfp(t){let{components:e,...n}=t;return(0,s.kt)(Yfp,(0,p.Z)({},jfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}Qfp.isMDXComponent=!0;const Hfp={toc:[]},Kfp="wrapper";function $fp(t){let{components:e,...n}=t;return(0,s.kt)(Kfp,(0,p.Z)({},Hfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}$fp.isMDXComponent=!0;const Jfp={toc:[]},tkp="wrapper";function ekp(t){let{components:e,...n}=t;return(0,s.kt)(tkp,(0,p.Z)({},Jfp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}ekp.isMDXComponent=!0;const nkp={toc:[]},okp="wrapper";function pkp(t){let{components:e,...n}=t;return(0,s.kt)(okp,(0,p.Z)({},nkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}pkp.isMDXComponent=!0;const rkp={toc:[]},skp="wrapper";function ckp(t){let{components:e,...n}=t;return(0,s.kt)(skp,(0,p.Z)({},rkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}ckp.isMDXComponent=!0;const akp={toc:[]},ikp="wrapper";function lkp(t){let{components:e,...n}=t;return(0,s.kt)(ikp,(0,p.Z)({},akp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}lkp.isMDXComponent=!0;const ukp={toc:[]},mkp="wrapper";function dkp(t){let{components:e,...n}=t;return(0,s.kt)(mkp,(0,p.Z)({},ukp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}dkp.isMDXComponent=!0;const hkp={toc:[]},fkp="wrapper";function kkp(t){let{components:e,...n}=t;return(0,s.kt)(fkp,(0,p.Z)({},hkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}kkp.isMDXComponent=!0;const ykp={toc:[]},Dkp="wrapper";function Mkp(t){let{components:e,...n}=t;return(0,s.kt)(Dkp,(0,p.Z)({},ykp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}Mkp.isMDXComponent=!0;const Xkp={toc:[]},_kp="wrapper";function wkp(t){let{components:e,...n}=t;return(0,s.kt)(_kp,(0,p.Z)({},Xkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}wkp.isMDXComponent=!0;const Tkp={toc:[]},Ckp="wrapper";function xkp(t){let{components:e,...n}=t;return(0,s.kt)(Ckp,(0,p.Z)({},Tkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xkp.isMDXComponent=!0;const gkp={toc:[]},vkp="wrapper";function Lkp(t){let{components:e,...n}=t;return(0,s.kt)(vkp,(0,p.Z)({},gkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Lkp.isMDXComponent=!0;const Zkp={toc:[]},bkp="wrapper";function Nkp(t){let{components:e,...n}=t;return(0,s.kt)(bkp,(0,p.Z)({},Zkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}Nkp.isMDXComponent=!0;const zkp={toc:[]},Akp="wrapper";function Pkp(t){let{components:e,...n}=t;return(0,s.kt)(Akp,(0,p.Z)({},zkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Pkp.isMDXComponent=!0;const Wkp={toc:[]},Rkp="wrapper";function Ikp(t){let{components:e,...n}=t;return(0,s.kt)(Rkp,(0,p.Z)({},Wkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}Ikp.isMDXComponent=!0;const Skp={toc:[]},Bkp="wrapper";function Gkp(t){let{components:e,...n}=t;return(0,s.kt)(Bkp,(0,p.Z)({},Skp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}Gkp.isMDXComponent=!0;const Ekp={toc:[]},Okp="wrapper";function Fkp(t){let{components:e,...n}=t;return(0,s.kt)(Okp,(0,p.Z)({},Ekp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Fkp.isMDXComponent=!0;const Ukp={toc:[]},Vkp="wrapper";function qkp(t){let{components:e,...n}=t;return(0,s.kt)(Vkp,(0,p.Z)({},Ukp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}qkp.isMDXComponent=!0;const jkp={toc:[]},Ykp="wrapper";function Qkp(t){let{components:e,...n}=t;return(0,s.kt)(Ykp,(0,p.Z)({},jkp,n,{components:e,mdxType:"MDXLayout"}))}Qkp.isMDXComponent=!0;const Hkp={toc:[]},Kkp="wrapper";function $kp(t){let{components:e,...n}=t;return(0,s.kt)(Kkp,(0,p.Z)({},Hkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}$kp.isMDXComponent=!0;const Jkp={toc:[]},typ="wrapper";function eyp(t){let{components:e,...n}=t;return(0,s.kt)(typ,(0,p.Z)({},Jkp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}eyp.isMDXComponent=!0;const nyp={toc:[]},oyp="wrapper";function pyp(t){let{components:e,...n}=t;return(0,s.kt)(oyp,(0,p.Z)({},nyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the image will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting image will appear pixelated."))}pyp.isMDXComponent=!0;const ryp={toc:[]},syp="wrapper";function cyp(t){let{components:e,...n}=t;return(0,s.kt)(syp,(0,p.Z)({},ryp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the image should be smoothed."))}cyp.isMDXComponent=!0;const ayp={toc:[]},iyp="wrapper";function lyp(t){let{components:e,...n}=t;return(0,s.kt)(iyp,(0,p.Z)({},ayp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}lyp.isMDXComponent=!0;const uyp={toc:[]},myp="wrapper";function dyp(t){let{components:e,...n}=t;return(0,s.kt)(myp,(0,p.Z)({},uyp,n,{components:e,mdxType:"MDXLayout"}))}dyp.isMDXComponent=!0;const hyp={toc:[]},fyp="wrapper";function kyp(t){let{components:e,...n}=t;return(0,s.kt)(fyp,(0,p.Z)({},hyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this image."))}kyp.isMDXComponent=!0;const yyp={toc:[]},Dyp="wrapper";function Myp(t){let{components:e,...n}=t;return(0,s.kt)(Dyp,(0,p.Z)({},yyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Myp.isMDXComponent=!0;const Xyp={toc:[]},_yp="wrapper";function wyp(t){let{components:e,...n}=t;return(0,s.kt)(_yp,(0,p.Z)({},Xyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}wyp.isMDXComponent=!0;const Typ={toc:[]},Cyp="wrapper";function xyp(t){let{components:e,...n}=t;return(0,s.kt)(Cyp,(0,p.Z)({},Typ,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xyp.isMDXComponent=!0;const gyp={toc:[]},vyp="wrapper";function Lyp(t){let{components:e,...n}=t;return(0,s.kt)(vyp,(0,p.Z)({},gyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Lyp.isMDXComponent=!0;const Zyp={toc:[]},byp="wrapper";function Nyp(t){let{components:e,...n}=t;return(0,s.kt)(byp,(0,p.Z)({},Zyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LatexProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Nyp.isMDXComponent=!0;const zyp={toc:[]},Ayp="wrapper";function Pyp(t){let{components:e,...n}=t;return(0,s.kt)(Ayp,(0,p.Z)({},zyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Pyp.isMDXComponent=!0;const Wyp={toc:[]},Ryp="wrapper";function Iyp(t){let{components:e,...n}=t;return(0,s.kt)(Ryp,(0,p.Z)({},Wyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Iyp.isMDXComponent=!0;const Syp={toc:[]},Byp="wrapper";function Gyp(t){let{components:e,...n}=t;return(0,s.kt)(Byp,(0,p.Z)({},Syp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Gyp.isMDXComponent=!0;const Eyp={toc:[]},Oyp="wrapper";function Fyp(t){let{components:e,...n}=t;return(0,s.kt)(Oyp,(0,p.Z)({},Eyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Fyp.isMDXComponent=!0;const Uyp={toc:[]},Vyp="wrapper";function qyp(t){let{components:e,...n}=t;return(0,s.kt)(Vyp,(0,p.Z)({},Uyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}qyp.isMDXComponent=!0;const jyp={toc:[]},Yyp="wrapper";function Qyp(t){let{components:e,...n}=t;return(0,s.kt)(Yyp,(0,p.Z)({},jyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qyp.isMDXComponent=!0;const Hyp={toc:[]},Kyp="wrapper";function $yp(t){let{components:e,...n}=t;return(0,s.kt)(Kyp,(0,p.Z)({},Hyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}$yp.isMDXComponent=!0;const Jyp={toc:[]},tDp="wrapper";function eDp(t){let{components:e,...n}=t;return(0,s.kt)(tDp,(0,p.Z)({},Jyp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eDp.isMDXComponent=!0;const nDp={toc:[]},oDp="wrapper";function pDp(t){let{components:e,...n}=t;return(0,s.kt)(oDp,(0,p.Z)({},nDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}pDp.isMDXComponent=!0;const rDp={toc:[]},sDp="wrapper";function cDp(t){let{components:e,...n}=t;return(0,s.kt)(sDp,(0,p.Z)({},rDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cDp.isMDXComponent=!0;const aDp={toc:[]},iDp="wrapper";function lDp(t){let{components:e,...n}=t;return(0,s.kt)(iDp,(0,p.Z)({},aDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}lDp.isMDXComponent=!0;const uDp={toc:[]},mDp="wrapper";function dDp(t){let{components:e,...n}=t;return(0,s.kt)(mDp,(0,p.Z)({},uDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dDp.isMDXComponent=!0;const hDp={toc:[]},fDp="wrapper";function kDp(t){let{components:e,...n}=t;return(0,s.kt)(fDp,(0,p.Z)({},hDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}kDp.isMDXComponent=!0;const yDp={toc:[]},DDp="wrapper";function MDp(t){let{components:e,...n}=t;return(0,s.kt)(DDp,(0,p.Z)({},yDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}MDp.isMDXComponent=!0;const XDp={toc:[]},_Dp="wrapper";function wDp(t){let{components:e,...n}=t;return(0,s.kt)(_Dp,(0,p.Z)({},XDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}wDp.isMDXComponent=!0;const TDp={toc:[]},CDp="wrapper";function xDp(t){let{components:e,...n}=t;return(0,s.kt)(CDp,(0,p.Z)({},TDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}xDp.isMDXComponent=!0;const gDp={toc:[]},vDp="wrapper";function LDp(t){let{components:e,...n}=t;return(0,s.kt)(vDp,(0,p.Z)({},gDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}LDp.isMDXComponent=!0;const ZDp={toc:[]},bDp="wrapper";function NDp(t){let{components:e,...n}=t;return(0,s.kt)(bDp,(0,p.Z)({},ZDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}NDp.isMDXComponent=!0;const zDp={toc:[]},ADp="wrapper";function PDp(t){let{components:e,...n}=t;return(0,s.kt)(ADp,(0,p.Z)({},zDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}PDp.isMDXComponent=!0;const WDp={toc:[]},RDp="wrapper";function IDp(t){let{components:e,...n}=t;return(0,s.kt)(RDp,(0,p.Z)({},WDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}IDp.isMDXComponent=!0;const SDp={toc:[]},BDp="wrapper";function GDp(t){let{components:e,...n}=t;return(0,s.kt)(BDp,(0,p.Z)({},SDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}GDp.isMDXComponent=!0;const EDp={toc:[]},ODp="wrapper";function FDp(t){let{components:e,...n}=t;return(0,s.kt)(ODp,(0,p.Z)({},EDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}FDp.isMDXComponent=!0;const UDp={toc:[]},VDp="wrapper";function qDp(t){let{components:e,...n}=t;return(0,s.kt)(VDp,(0,p.Z)({},UDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}qDp.isMDXComponent=!0;const jDp={toc:[]},YDp="wrapper";function QDp(t){let{components:e,...n}=t;return(0,s.kt)(YDp,(0,p.Z)({},jDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}QDp.isMDXComponent=!0;const HDp={toc:[]},KDp="wrapper";function $Dp(t){let{components:e,...n}=t;return(0,s.kt)(KDp,(0,p.Z)({},HDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}$Dp.isMDXComponent=!0;const JDp={toc:[]},tMp="wrapper";function eMp(t){let{components:e,...n}=t;return(0,s.kt)(tMp,(0,p.Z)({},JDp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}eMp.isMDXComponent=!0;const nMp={toc:[]},oMp="wrapper";function pMp(t){let{components:e,...n}=t;return(0,s.kt)(oMp,(0,p.Z)({},nMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}pMp.isMDXComponent=!0;const rMp={toc:[]},sMp="wrapper";function cMp(t){let{components:e,...n}=t;return(0,s.kt)(sMp,(0,p.Z)({},rMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cMp.isMDXComponent=!0;const aMp={toc:[]},iMp="wrapper";function lMp(t){let{components:e,...n}=t;return(0,s.kt)(iMp,(0,p.Z)({},aMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}lMp.isMDXComponent=!0;const uMp={toc:[]},mMp="wrapper";function dMp(t){let{components:e,...n}=t;return(0,s.kt)(mMp,(0,p.Z)({},uMp,n,{components:e,mdxType:"MDXLayout"}))}dMp.isMDXComponent=!0;const hMp={toc:[]},fMp="wrapper";function kMp(t){let{components:e,...n}=t;return(0,s.kt)(fMp,(0,p.Z)({},hMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LayoutProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}kMp.isMDXComponent=!0;const yMp={toc:[]},DMp="wrapper";function MMp(t){let{components:e,...n}=t;return(0,s.kt)(DMp,(0,p.Z)({},yMp,n,{components:e,mdxType:"MDXLayout"}))}MMp.isMDXComponent=!0;const XMp={toc:[]},_Mp="wrapper";function wMp(t){let{components:e,...n}=t;return(0,s.kt)(_Mp,(0,p.Z)({},XMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wMp.isMDXComponent=!0;const TMp={toc:[]},CMp="wrapper";function xMp(t){let{components:e,...n}=t;return(0,s.kt)(CMp,(0,p.Z)({},TMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}xMp.isMDXComponent=!0;const gMp={toc:[]},vMp="wrapper";function LMp(t){let{components:e,...n}=t;return(0,s.kt)(vMp,(0,p.Z)({},gMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LMp.isMDXComponent=!0;const ZMp={toc:[]},bMp="wrapper";function NMp(t){let{components:e,...n}=t;return(0,s.kt)(bMp,(0,p.Z)({},ZMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}NMp.isMDXComponent=!0;const zMp={toc:[]},AMp="wrapper";function PMp(t){let{components:e,...n}=t;return(0,s.kt)(AMp,(0,p.Z)({},zMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}PMp.isMDXComponent=!0;const WMp={toc:[]},RMp="wrapper";function IMp(t){let{components:e,...n}=t;return(0,s.kt)(RMp,(0,p.Z)({},WMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}IMp.isMDXComponent=!0;const SMp={toc:[]},BMp="wrapper";function GMp(t){let{components:e,...n}=t;return(0,s.kt)(BMp,(0,p.Z)({},SMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}GMp.isMDXComponent=!0;const EMp={toc:[]},OMp="wrapper";function FMp(t){let{components:e,...n}=t;return(0,s.kt)(OMp,(0,p.Z)({},EMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}FMp.isMDXComponent=!0;const UMp={toc:[]},VMp="wrapper";function qMp(t){let{components:e,...n}=t;return(0,s.kt)(VMp,(0,p.Z)({},UMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qMp.isMDXComponent=!0;const jMp={toc:[]},YMp="wrapper";function QMp(t){let{components:e,...n}=t;return(0,s.kt)(YMp,(0,p.Z)({},jMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}QMp.isMDXComponent=!0;const HMp={toc:[]},KMp="wrapper";function $Mp(t){let{components:e,...n}=t;return(0,s.kt)(KMp,(0,p.Z)({},HMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$Mp.isMDXComponent=!0;const JMp={toc:[]},tXp="wrapper";function eXp(t){let{components:e,...n}=t;return(0,s.kt)(tXp,(0,p.Z)({},JMp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}eXp.isMDXComponent=!0;const nXp={toc:[]},oXp="wrapper";function pXp(t){let{components:e,...n}=t;return(0,s.kt)(oXp,(0,p.Z)({},nXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pXp.isMDXComponent=!0;const rXp={toc:[]},sXp="wrapper";function cXp(t){let{components:e,...n}=t;return(0,s.kt)(sXp,(0,p.Z)({},rXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}cXp.isMDXComponent=!0;const aXp={toc:[]},iXp="wrapper";function lXp(t){let{components:e,...n}=t;return(0,s.kt)(iXp,(0,p.Z)({},aXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}lXp.isMDXComponent=!0;const uXp={toc:[]},mXp="wrapper";function dXp(t){let{components:e,...n}=t;return(0,s.kt)(mXp,(0,p.Z)({},uXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}dXp.isMDXComponent=!0;const hXp={toc:[]},fXp="wrapper";function kXp(t){let{components:e,...n}=t;return(0,s.kt)(fXp,(0,p.Z)({},hXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}kXp.isMDXComponent=!0;const yXp={toc:[]},DXp="wrapper";function MXp(t){let{components:e,...n}=t;return(0,s.kt)(DXp,(0,p.Z)({},yXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}MXp.isMDXComponent=!0;const XXp={toc:[]},_Xp="wrapper";function wXp(t){let{components:e,...n}=t;return(0,s.kt)(_Xp,(0,p.Z)({},XXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}wXp.isMDXComponent=!0;const TXp={toc:[]},CXp="wrapper";function xXp(t){let{components:e,...n}=t;return(0,s.kt)(CXp,(0,p.Z)({},TXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}xXp.isMDXComponent=!0;const gXp={toc:[]},vXp="wrapper";function LXp(t){let{components:e,...n}=t;return(0,s.kt)(vXp,(0,p.Z)({},gXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}LXp.isMDXComponent=!0;const ZXp={toc:[]},bXp="wrapper";function NXp(t){let{components:e,...n}=t;return(0,s.kt)(bXp,(0,p.Z)({},ZXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}NXp.isMDXComponent=!0;const zXp={toc:[]},AXp="wrapper";function PXp(t){let{components:e,...n}=t;return(0,s.kt)(AXp,(0,p.Z)({},zXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}PXp.isMDXComponent=!0;const WXp={toc:[]},RXp="wrapper";function IXp(t){let{components:e,...n}=t;return(0,s.kt)(RXp,(0,p.Z)({},WXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}IXp.isMDXComponent=!0;const SXp={toc:[]},BXp="wrapper";function GXp(t){let{components:e,...n}=t;return(0,s.kt)(BXp,(0,p.Z)({},SXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}GXp.isMDXComponent=!0;const EXp={toc:[]},OXp="wrapper";function FXp(t){let{components:e,...n}=t;return(0,s.kt)(OXp,(0,p.Z)({},EXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}FXp.isMDXComponent=!0;const UXp={toc:[]},VXp="wrapper";function qXp(t){let{components:e,...n}=t;return(0,s.kt)(VXp,(0,p.Z)({},UXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}qXp.isMDXComponent=!0;const jXp={toc:[]},YXp="wrapper";function QXp(t){let{components:e,...n}=t;return(0,s.kt)(YXp,(0,p.Z)({},jXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}QXp.isMDXComponent=!0;const HXp={toc:[]},KXp="wrapper";function $Xp(t){let{components:e,...n}=t;return(0,s.kt)(KXp,(0,p.Z)({},HXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}$Xp.isMDXComponent=!0;const JXp={toc:[]},t_p="wrapper";function e_p(t){let{components:e,...n}=t;return(0,s.kt)(t_p,(0,p.Z)({},JXp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}e_p.isMDXComponent=!0;const n_p={toc:[]},o_p="wrapper";function p_p(t){let{components:e,...n}=t;return(0,s.kt)(o_p,(0,p.Z)({},n_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}p_p.isMDXComponent=!0;const r_p={toc:[]},s_p="wrapper";function c_p(t){let{components:e,...n}=t;return(0,s.kt)(s_p,(0,p.Z)({},r_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}c_p.isMDXComponent=!0;const a_p={toc:[]},i_p="wrapper";function l_p(t){let{components:e,...n}=t;return(0,s.kt)(i_p,(0,p.Z)({},a_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}l_p.isMDXComponent=!0;const u_p={toc:[]},m_p="wrapper";function d_p(t){let{components:e,...n}=t;return(0,s.kt)(m_p,(0,p.Z)({},u_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}d_p.isMDXComponent=!0;const h_p={toc:[]},f_p="wrapper";function k_p(t){let{components:e,...n}=t;return(0,s.kt)(f_p,(0,p.Z)({},h_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}k_p.isMDXComponent=!0;const y_p={toc:[]},D_p="wrapper";function M_p(t){let{components:e,...n}=t;return(0,s.kt)(D_p,(0,p.Z)({},y_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}M_p.isMDXComponent=!0;const X_p={toc:[]},__p="wrapper";function w_p(t){let{components:e,...n}=t;return(0,s.kt)(__p,(0,p.Z)({},X_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", the Line will use the positions of its children as\npoints."))}w_p.isMDXComponent=!0;const T_p={toc:[]},C_p="wrapper";function x_p(t){let{components:e,...n}=t;return(0,s.kt)(C_p,(0,p.Z)({},T_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The points of the line."))}x_p.isMDXComponent=!0;const g_p={toc:[]},v_p="wrapper";function L_p(t){let{components:e,...n}=t;return(0,s.kt)(v_p,(0,p.Z)({},g_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The radius of the line's corners."))}L_p.isMDXComponent=!0;const Z_p={toc:[]},b_p="wrapper";function N_p(t){let{components:e,...n}=t;return(0,s.kt)(b_p,(0,p.Z)({},Z_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}N_p.isMDXComponent=!0;const z_p={toc:[]},A_p="wrapper";function P_p(t){let{components:e,...n}=t;return(0,s.kt)(A_p,(0,p.Z)({},z_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}P_p.isMDXComponent=!0;const W_p={toc:[]},R_p="wrapper";function I_p(t){let{components:e,...n}=t;return(0,s.kt)(R_p,(0,p.Z)({},W_p,n,{components:e,mdxType:"MDXLayout"}))}I_p.isMDXComponent=!0;const S_p={toc:[]},B_p="wrapper";function G_p(t){let{components:e,...n}=t;return(0,s.kt)(B_p,(0,p.Z)({},S_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}G_p.isMDXComponent=!0;const E_p={toc:[]},O_p="wrapper";function F_p(t){let{components:e,...n}=t;return(0,s.kt)(O_p,(0,p.Z)({},E_p,n,{components:e,mdxType:"MDXLayout"}))}F_p.isMDXComponent=!0;const U_p={toc:[]},V_p="wrapper";function q_p(t){let{components:e,...n}=t;return(0,s.kt)(V_p,(0,p.Z)({},U_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}q_p.isMDXComponent=!0;const j_p={toc:[]},Y_p="wrapper";function Q_p(t){let{components:e,...n}=t;return(0,s.kt)(Y_p,(0,p.Z)({},j_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Q_p.isMDXComponent=!0;const H_p={toc:[]},K_p="wrapper";function $_p(t){let{components:e,...n}=t;return(0,s.kt)(K_p,(0,p.Z)({},H_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}$_p.isMDXComponent=!0;const J_p={toc:[]},twp="wrapper";function ewp(t){let{components:e,...n}=t;return(0,s.kt)(twp,(0,p.Z)({},J_p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}ewp.isMDXComponent=!0;const nwp={toc:[]},owp="wrapper";function pwp(t){let{components:e,...n}=t;return(0,s.kt)(owp,(0,p.Z)({},nwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/LineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}pwp.isMDXComponent=!0;const rwp={toc:[]},swp="wrapper";function cwp(t){let{components:e,...n}=t;return(0,s.kt)(swp,(0,p.Z)({},rwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}cwp.isMDXComponent=!0;const awp={toc:[]},iwp="wrapper";function lwp(t){let{components:e,...n}=t;return(0,s.kt)(iwp,(0,p.Z)({},awp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lwp.isMDXComponent=!0;const uwp={toc:[]},mwp="wrapper";function dwp(t){let{components:e,...n}=t;return(0,s.kt)(mwp,(0,p.Z)({},uwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}dwp.isMDXComponent=!0;const hwp={toc:[]},fwp="wrapper";function kwp(t){let{components:e,...n}=t;return(0,s.kt)(fwp,(0,p.Z)({},hwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kwp.isMDXComponent=!0;const ywp={toc:[]},Dwp="wrapper";function Mwp(t){let{components:e,...n}=t;return(0,s.kt)(Dwp,(0,p.Z)({},ywp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Mwp.isMDXComponent=!0;const Xwp={toc:[]},_wp="wrapper";function wwp(t){let{components:e,...n}=t;return(0,s.kt)(_wp,(0,p.Z)({},Xwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wwp.isMDXComponent=!0;const Twp={toc:[]},Cwp="wrapper";function xwp(t){let{components:e,...n}=t;return(0,s.kt)(Cwp,(0,p.Z)({},Twp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}xwp.isMDXComponent=!0;const gwp={toc:[]},vwp="wrapper";function Lwp(t){let{components:e,...n}=t;return(0,s.kt)(vwp,(0,p.Z)({},gwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Lwp.isMDXComponent=!0;const Zwp={toc:[]},bwp="wrapper";function Nwp(t){let{components:e,...n}=t;return(0,s.kt)(bwp,(0,p.Z)({},Zwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Nwp.isMDXComponent=!0;const zwp={toc:[]},Awp="wrapper";function Pwp(t){let{components:e,...n}=t;return(0,s.kt)(Awp,(0,p.Z)({},zwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Pwp.isMDXComponent=!0;const Wwp={toc:[]},Rwp="wrapper";function Iwp(t){let{components:e,...n}=t;return(0,s.kt)(Rwp,(0,p.Z)({},Wwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Iwp.isMDXComponent=!0;const Swp={toc:[]},Bwp="wrapper";function Gwp(t){let{components:e,...n}=t;return(0,s.kt)(Bwp,(0,p.Z)({},Swp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Gwp.isMDXComponent=!0;const Ewp={toc:[]},Owp="wrapper";function Fwp(t){let{components:e,...n}=t;return(0,s.kt)(Owp,(0,p.Z)({},Ewp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Fwp.isMDXComponent=!0;const Uwp={toc:[]},Vwp="wrapper";function qwp(t){let{components:e,...n}=t;return(0,s.kt)(Vwp,(0,p.Z)({},Uwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}qwp.isMDXComponent=!0;const jwp={toc:[]},Ywp="wrapper";function Qwp(t){let{components:e,...n}=t;return(0,s.kt)(Ywp,(0,p.Z)({},jwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Qwp.isMDXComponent=!0;const Hwp={toc:[]},Kwp="wrapper";function $wp(t){let{components:e,...n}=t;return(0,s.kt)(Kwp,(0,p.Z)({},Hwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}$wp.isMDXComponent=!0;const Jwp={toc:[]},tTp="wrapper";function eTp(t){let{components:e,...n}=t;return(0,s.kt)(tTp,(0,p.Z)({},Jwp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}eTp.isMDXComponent=!0;const nTp={toc:[]},oTp="wrapper";function pTp(t){let{components:e,...n}=t;return(0,s.kt)(oTp,(0,p.Z)({},nTp,n,{components:e,mdxType:"MDXLayout"}))}pTp.isMDXComponent=!0;const rTp={toc:[]},sTp="wrapper";function cTp(t){let{components:e,...n}=t;return(0,s.kt)(sTp,(0,p.Z)({},rTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}cTp.isMDXComponent=!0;const aTp={toc:[]},iTp="wrapper";function lTp(t){let{components:e,...n}=t;return(0,s.kt)(iTp,(0,p.Z)({},aTp,n,{components:e,mdxType:"MDXLayout"}))}lTp.isMDXComponent=!0;const uTp={toc:[]},mTp="wrapper";function dTp(t){let{components:e,...n}=t;return(0,s.kt)(mTp,(0,p.Z)({},uTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}dTp.isMDXComponent=!0;const hTp={toc:[]},fTp="wrapper";function kTp(t){let{components:e,...n}=t;return(0,s.kt)(fTp,(0,p.Z)({},hTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}kTp.isMDXComponent=!0;const yTp={toc:[]},DTp="wrapper";function MTp(t){let{components:e,...n}=t;return(0,s.kt)(DTp,(0,p.Z)({},yTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MTp.isMDXComponent=!0;const XTp={toc:[]},_Tp="wrapper";function wTp(t){let{components:e,...n}=t;return(0,s.kt)(_Tp,(0,p.Z)({},XTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}wTp.isMDXComponent=!0;const TTp={toc:[]},CTp="wrapper";function xTp(t){let{components:e,...n}=t;return(0,s.kt)(CTp,(0,p.Z)({},TTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xTp.isMDXComponent=!0;const gTp={toc:[]},vTp="wrapper";function LTp(t){let{components:e,...n}=t;return(0,s.kt)(vTp,(0,p.Z)({},gTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}LTp.isMDXComponent=!0;const ZTp={toc:[]},bTp="wrapper";function NTp(t){let{components:e,...n}=t;return(0,s.kt)(bTp,(0,p.Z)({},ZTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}NTp.isMDXComponent=!0;const zTp={toc:[]},ATp="wrapper";function PTp(t){let{components:e,...n}=t;return(0,s.kt)(ATp,(0,p.Z)({},zTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}PTp.isMDXComponent=!0;const WTp={toc:[]},RTp="wrapper";function ITp(t){let{components:e,...n}=t;return(0,s.kt)(RTp,(0,p.Z)({},WTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}ITp.isMDXComponent=!0;const STp={toc:[]},BTp="wrapper";function GTp(t){let{components:e,...n}=t;return(0,s.kt)(BTp,(0,p.Z)({},STp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}GTp.isMDXComponent=!0;const ETp={toc:[]},OTp="wrapper";function FTp(t){let{components:e,...n}=t;return(0,s.kt)(OTp,(0,p.Z)({},ETp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}FTp.isMDXComponent=!0;const UTp={toc:[]},VTp="wrapper";function qTp(t){let{components:e,...n}=t;return(0,s.kt)(VTp,(0,p.Z)({},UTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}qTp.isMDXComponent=!0;const jTp={toc:[]},YTp="wrapper";function QTp(t){let{components:e,...n}=t;return(0,s.kt)(YTp,(0,p.Z)({},jTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}QTp.isMDXComponent=!0;const HTp={toc:[]},KTp="wrapper";function $Tp(t){let{components:e,...n}=t;return(0,s.kt)(KTp,(0,p.Z)({},HTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}$Tp.isMDXComponent=!0;const JTp={toc:[]},tCp="wrapper";function eCp(t){let{components:e,...n}=t;return(0,s.kt)(tCp,(0,p.Z)({},JTp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}eCp.isMDXComponent=!0;const nCp={toc:[]},oCp="wrapper";function pCp(t){let{components:e,...n}=t;return(0,s.kt)(oCp,(0,p.Z)({},nCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}pCp.isMDXComponent=!0;const rCp={toc:[]},sCp="wrapper";function cCp(t){let{components:e,...n}=t;return(0,s.kt)(sCp,(0,p.Z)({},rCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}cCp.isMDXComponent=!0;const aCp={toc:[]},iCp="wrapper";function lCp(t){let{components:e,...n}=t;return(0,s.kt)(iCp,(0,p.Z)({},aCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}lCp.isMDXComponent=!0;const uCp={toc:[]},mCp="wrapper";function dCp(t){let{components:e,...n}=t;return(0,s.kt)(mCp,(0,p.Z)({},uCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}dCp.isMDXComponent=!0;const hCp={toc:[]},fCp="wrapper";function kCp(t){let{components:e,...n}=t;return(0,s.kt)(fCp,(0,p.Z)({},hCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}kCp.isMDXComponent=!0;const yCp={toc:[]},DCp="wrapper";function MCp(t){let{components:e,...n}=t;return(0,s.kt)(DCp,(0,p.Z)({},yCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}MCp.isMDXComponent=!0;const XCp={toc:[]},_Cp="wrapper";function wCp(t){let{components:e,...n}=t;return(0,s.kt)(_Cp,(0,p.Z)({},XCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}wCp.isMDXComponent=!0;const TCp={toc:[]},CCp="wrapper";function xCp(t){let{components:e,...n}=t;return(0,s.kt)(CCp,(0,p.Z)({},TCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}xCp.isMDXComponent=!0;const gCp={toc:[]},vCp="wrapper";function LCp(t){let{components:e,...n}=t;return(0,s.kt)(vCp,(0,p.Z)({},gCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}LCp.isMDXComponent=!0;const ZCp={toc:[]},bCp="wrapper";function NCp(t){let{components:e,...n}=t;return(0,s.kt)(bCp,(0,p.Z)({},ZCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}NCp.isMDXComponent=!0;const zCp={toc:[]},ACp="wrapper";function PCp(t){let{components:e,...n}=t;return(0,s.kt)(ACp,(0,p.Z)({},zCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}PCp.isMDXComponent=!0;const WCp={toc:[]},RCp="wrapper";function ICp(t){let{components:e,...n}=t;return(0,s.kt)(RCp,(0,p.Z)({},WCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ICp.isMDXComponent=!0;const SCp={toc:[]},BCp="wrapper";function GCp(t){let{components:e,...n}=t;return(0,s.kt)(BCp,(0,p.Z)({},SCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}GCp.isMDXComponent=!0;const ECp={toc:[]},OCp="wrapper";function FCp(t){let{components:e,...n}=t;return(0,s.kt)(OCp,(0,p.Z)({},ECp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}FCp.isMDXComponent=!0;const UCp={toc:[]},VCp="wrapper";function qCp(t){let{components:e,...n}=t;return(0,s.kt)(VCp,(0,p.Z)({},UCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}qCp.isMDXComponent=!0;const jCp={toc:[]},YCp="wrapper";function QCp(t){let{components:e,...n}=t;return(0,s.kt)(YCp,(0,p.Z)({},jCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}QCp.isMDXComponent=!0;const HCp={toc:[]},KCp="wrapper";function $Cp(t){let{components:e,...n}=t;return(0,s.kt)(KCp,(0,p.Z)({},HCp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}$Cp.isMDXComponent=!0;const JCp={toc:[]},txp="wrapper";function exp(t){let{components:e,...n}=t;return(0,s.kt)(txp,(0,p.Z)({},JCp,n,{components:e,mdxType:"MDXLayout"}))}exp.isMDXComponent=!0;const nxp={toc:[]},oxp="wrapper";function pxp(t){let{components:e,...n}=t;return(0,s.kt)(oxp,(0,p.Z)({},nxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}pxp.isMDXComponent=!0;const rxp={toc:[]},sxp="wrapper";function cxp(t){let{components:e,...n}=t;return(0,s.kt)(sxp,(0,p.Z)({},rxp,n,{components:e,mdxType:"MDXLayout"}))}cxp.isMDXComponent=!0;const axp={toc:[]},ixp="wrapper";function lxp(t){let{components:e,...n}=t;return(0,s.kt)(ixp,(0,p.Z)({},axp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}lxp.isMDXComponent=!0;const uxp={toc:[]},mxp="wrapper";function dxp(t){let{components:e,...n}=t;return(0,s.kt)(mxp,(0,p.Z)({},uxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}dxp.isMDXComponent=!0;const hxp={toc:[]},fxp="wrapper";function kxp(t){let{components:e,...n}=t;return(0,s.kt)(fxp,(0,p.Z)({},hxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}kxp.isMDXComponent=!0;const yxp={toc:[]},Dxp="wrapper";function Mxp(t){let{components:e,...n}=t;return(0,s.kt)(Dxp,(0,p.Z)({},yxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}Mxp.isMDXComponent=!0;const Xxp={toc:[]},_xp="wrapper";function wxp(t){let{components:e,...n}=t;return(0,s.kt)(_xp,(0,p.Z)({},Xxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PathProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}wxp.isMDXComponent=!0;const Txp={toc:[]},Cxp="wrapper";function xxp(t){let{components:e,...n}=t;return(0,s.kt)(Cxp,(0,p.Z)({},Txp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}xxp.isMDXComponent=!0;const gxp={toc:[]},vxp="wrapper";function Lxp(t){let{components:e,...n}=t;return(0,s.kt)(vxp,(0,p.Z)({},gxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lxp.isMDXComponent=!0;const Zxp={toc:[]},bxp="wrapper";function Nxp(t){let{components:e,...n}=t;return(0,s.kt)(bxp,(0,p.Z)({},Zxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Nxp.isMDXComponent=!0;const zxp={toc:[]},Axp="wrapper";function Pxp(t){let{components:e,...n}=t;return(0,s.kt)(Axp,(0,p.Z)({},zxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pxp.isMDXComponent=!0;const Wxp={toc:[]},Rxp="wrapper";function Ixp(t){let{components:e,...n}=t;return(0,s.kt)(Rxp,(0,p.Z)({},Wxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Ixp.isMDXComponent=!0;const Sxp={toc:[]},Bxp="wrapper";function Gxp(t){let{components:e,...n}=t;return(0,s.kt)(Bxp,(0,p.Z)({},Sxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Gxp.isMDXComponent=!0;const Exp={toc:[]},Oxp="wrapper";function Fxp(t){let{components:e,...n}=t;return(0,s.kt)(Oxp,(0,p.Z)({},Exp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Fxp.isMDXComponent=!0;const Uxp={toc:[]},Vxp="wrapper";function qxp(t){let{components:e,...n}=t;return(0,s.kt)(Vxp,(0,p.Z)({},Uxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qxp.isMDXComponent=!0;const jxp={toc:[]},Yxp="wrapper";function Qxp(t){let{components:e,...n}=t;return(0,s.kt)(Yxp,(0,p.Z)({},jxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Qxp.isMDXComponent=!0;const Hxp={toc:[]},Kxp="wrapper";function $xp(t){let{components:e,...n}=t;return(0,s.kt)(Kxp,(0,p.Z)({},Hxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$xp.isMDXComponent=!0;const Jxp={toc:[]},tgp="wrapper";function egp(t){let{components:e,...n}=t;return(0,s.kt)(tgp,(0,p.Z)({},Jxp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}egp.isMDXComponent=!0;const ngp={toc:[]},ogp="wrapper";function pgp(t){let{components:e,...n}=t;return(0,s.kt)(ogp,(0,p.Z)({},ngp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pgp.isMDXComponent=!0;const rgp={toc:[]},sgp="wrapper";function cgp(t){let{components:e,...n}=t;return(0,s.kt)(sgp,(0,p.Z)({},rgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}cgp.isMDXComponent=!0;const agp={toc:[]},igp="wrapper";function lgp(t){let{components:e,...n}=t;return(0,s.kt)(igp,(0,p.Z)({},agp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}lgp.isMDXComponent=!0;const ugp={toc:[]},mgp="wrapper";function dgp(t){let{components:e,...n}=t;return(0,s.kt)(mgp,(0,p.Z)({},ugp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}dgp.isMDXComponent=!0;const hgp={toc:[]},fgp="wrapper";function kgp(t){let{components:e,...n}=t;return(0,s.kt)(fgp,(0,p.Z)({},hgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}kgp.isMDXComponent=!0;const ygp={toc:[]},Dgp="wrapper";function Mgp(t){let{components:e,...n}=t;return(0,s.kt)(Dgp,(0,p.Z)({},ygp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Mgp.isMDXComponent=!0;const Xgp={toc:[]},_gp="wrapper";function wgp(t){let{components:e,...n}=t;return(0,s.kt)(_gp,(0,p.Z)({},Xgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}wgp.isMDXComponent=!0;const Tgp={toc:[]},Cgp="wrapper";function xgp(t){let{components:e,...n}=t;return(0,s.kt)(Cgp,(0,p.Z)({},Tgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}xgp.isMDXComponent=!0;const ggp={toc:[]},vgp="wrapper";function Lgp(t){let{components:e,...n}=t;return(0,s.kt)(vgp,(0,p.Z)({},ggp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Lgp.isMDXComponent=!0;const Zgp={toc:[]},bgp="wrapper";function Ngp(t){let{components:e,...n}=t;return(0,s.kt)(bgp,(0,p.Z)({},Zgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Ngp.isMDXComponent=!0;const zgp={toc:[]},Agp="wrapper";function Pgp(t){let{components:e,...n}=t;return(0,s.kt)(Agp,(0,p.Z)({},zgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Pgp.isMDXComponent=!0;const Wgp={toc:[]},Rgp="wrapper";function Igp(t){let{components:e,...n}=t;return(0,s.kt)(Rgp,(0,p.Z)({},Wgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Igp.isMDXComponent=!0;const Sgp={toc:[]},Bgp="wrapper";function Ggp(t){let{components:e,...n}=t;return(0,s.kt)(Bgp,(0,p.Z)({},Sgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Ggp.isMDXComponent=!0;const Egp={toc:[]},Ogp="wrapper";function Fgp(t){let{components:e,...n}=t;return(0,s.kt)(Ogp,(0,p.Z)({},Egp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}Fgp.isMDXComponent=!0;const Ugp={toc:[]},Vgp="wrapper";function qgp(t){let{components:e,...n}=t;return(0,s.kt)(Vgp,(0,p.Z)({},Ugp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}qgp.isMDXComponent=!0;const jgp={toc:[]},Ygp="wrapper";function Qgp(t){let{components:e,...n}=t;return(0,s.kt)(Ygp,(0,p.Z)({},jgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}Qgp.isMDXComponent=!0;const Hgp={toc:[]},Kgp="wrapper";function $gp(t){let{components:e,...n}=t;return(0,s.kt)(Kgp,(0,p.Z)({},Hgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$gp.isMDXComponent=!0;const Jgp={toc:[]},tvp="wrapper";function evp(t){let{components:e,...n}=t;return(0,s.kt)(tvp,(0,p.Z)({},Jgp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}evp.isMDXComponent=!0;const nvp={toc:[]},ovp="wrapper";function pvp(t){let{components:e,...n}=t;return(0,s.kt)(ovp,(0,p.Z)({},nvp,n,{components:e,mdxType:"MDXLayout"}))}pvp.isMDXComponent=!0;const rvp={toc:[]},svp="wrapper";function cvp(t){let{components:e,...n}=t;return(0,s.kt)(svp,(0,p.Z)({},rvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"For example, a value of 6 creates a hexagon."))}cvp.isMDXComponent=!0;const avp={toc:[]},ivp="wrapper";function lvp(t){let{components:e,...n}=t;return(0,s.kt)(ivp,(0,p.Z)({},avp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets the number of sides of the polygon."))}lvp.isMDXComponent=!0;const uvp={toc:[]},mvp="wrapper";function dvp(t){let{components:e,...n}=t;return(0,s.kt)(mvp,(0,p.Z)({},uvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/PolygonProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}dvp.isMDXComponent=!0;const hvp={toc:[]},fvp="wrapper";function kvp(t){let{components:e,...n}=t;return(0,s.kt)(fvp,(0,p.Z)({},hvp,n,{components:e,mdxType:"MDXLayout"}))}kvp.isMDXComponent=!0;const yvp={toc:[]},Dvp="wrapper";function Mvp(t){let{components:e,...n}=t;return(0,s.kt)(Dvp,(0,p.Z)({},yvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Mvp.isMDXComponent=!0;const Xvp={toc:[]},_vp="wrapper";function wvp(t){let{components:e,...n}=t;return(0,s.kt)(_vp,(0,p.Z)({},Xvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}wvp.isMDXComponent=!0;const Tvp={toc:[]},Cvp="wrapper";function xvp(t){let{components:e,...n}=t;return(0,s.kt)(Cvp,(0,p.Z)({},Tvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xvp.isMDXComponent=!0;const gvp={toc:[]},vvp="wrapper";function Lvp(t){let{components:e,...n}=t;return(0,s.kt)(vvp,(0,p.Z)({},gvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Lvp.isMDXComponent=!0;const Zvp={toc:[]},bvp="wrapper";function Nvp(t){let{components:e,...n}=t;return(0,s.kt)(bvp,(0,p.Z)({},Zvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Nvp.isMDXComponent=!0;const zvp={toc:[]},Avp="wrapper";function Pvp(t){let{components:e,...n}=t;return(0,s.kt)(Avp,(0,p.Z)({},zvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}Pvp.isMDXComponent=!0;const Wvp={toc:[]},Rvp="wrapper";function Ivp(t){let{components:e,...n}=t;return(0,s.kt)(Rvp,(0,p.Z)({},Wvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Ivp.isMDXComponent=!0;const Svp={toc:[]},Bvp="wrapper";function Gvp(t){let{components:e,...n}=t;return(0,s.kt)(Bvp,(0,p.Z)({},Svp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Gvp.isMDXComponent=!0;const Evp={toc:[]},Ovp="wrapper";function Fvp(t){let{components:e,...n}=t;return(0,s.kt)(Ovp,(0,p.Z)({},Evp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Fvp.isMDXComponent=!0;const Uvp={toc:[]},Vvp="wrapper";function qvp(t){let{components:e,...n}=t;return(0,s.kt)(Vvp,(0,p.Z)({},Uvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}qvp.isMDXComponent=!0;const jvp={toc:[]},Yvp="wrapper";function Qvp(t){let{components:e,...n}=t;return(0,s.kt)(Yvp,(0,p.Z)({},jvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qvp.isMDXComponent=!0;const Hvp={toc:[]},Kvp="wrapper";function $vp(t){let{components:e,...n}=t;return(0,s.kt)(Kvp,(0,p.Z)({},Hvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}$vp.isMDXComponent=!0;const Jvp={toc:[]},tLp="wrapper";function eLp(t){let{components:e,...n}=t;return(0,s.kt)(tLp,(0,p.Z)({},Jvp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eLp.isMDXComponent=!0;const nLp={toc:[]},oLp="wrapper";function pLp(t){let{components:e,...n}=t;return(0,s.kt)(oLp,(0,p.Z)({},nLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}pLp.isMDXComponent=!0;const rLp={toc:[]},sLp="wrapper";function cLp(t){let{components:e,...n}=t;return(0,s.kt)(sLp,(0,p.Z)({},rLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}cLp.isMDXComponent=!0;const aLp={toc:[]},iLp="wrapper";function lLp(t){let{components:e,...n}=t;return(0,s.kt)(iLp,(0,p.Z)({},aLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}lLp.isMDXComponent=!0;const uLp={toc:[]},mLp="wrapper";function dLp(t){let{components:e,...n}=t;return(0,s.kt)(mLp,(0,p.Z)({},uLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}dLp.isMDXComponent=!0;const hLp={toc:[]},fLp="wrapper";function kLp(t){let{components:e,...n}=t;return(0,s.kt)(fLp,(0,p.Z)({},hLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}kLp.isMDXComponent=!0;const yLp={toc:[]},DLp="wrapper";function MLp(t){let{components:e,...n}=t;return(0,s.kt)(DLp,(0,p.Z)({},yLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}MLp.isMDXComponent=!0;const XLp={toc:[]},_Lp="wrapper";function wLp(t){let{components:e,...n}=t;return(0,s.kt)(_Lp,(0,p.Z)({},XLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}wLp.isMDXComponent=!0;const TLp={toc:[]},CLp="wrapper";function xLp(t){let{components:e,...n}=t;return(0,s.kt)(CLp,(0,p.Z)({},TLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}xLp.isMDXComponent=!0;const gLp={toc:[]},vLp="wrapper";function LLp(t){let{components:e,...n}=t;return(0,s.kt)(vLp,(0,p.Z)({},gLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}LLp.isMDXComponent=!0;const ZLp={toc:[]},bLp="wrapper";function NLp(t){let{components:e,...n}=t;return(0,s.kt)(bLp,(0,p.Z)({},ZLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}NLp.isMDXComponent=!0;const zLp={toc:[]},ALp="wrapper";function PLp(t){let{components:e,...n}=t;return(0,s.kt)(ALp,(0,p.Z)({},zLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}PLp.isMDXComponent=!0;const WLp={toc:[]},RLp="wrapper";function ILp(t){let{components:e,...n}=t;return(0,s.kt)(RLp,(0,p.Z)({},WLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}ILp.isMDXComponent=!0;const SLp={toc:[]},BLp="wrapper";function GLp(t){let{components:e,...n}=t;return(0,s.kt)(BLp,(0,p.Z)({},SLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}GLp.isMDXComponent=!0;const ELp={toc:[]},OLp="wrapper";function FLp(t){let{components:e,...n}=t;return(0,s.kt)(OLp,(0,p.Z)({},ELp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}FLp.isMDXComponent=!0;const ULp={toc:[]},VLp="wrapper";function qLp(t){let{components:e,...n}=t;return(0,s.kt)(VLp,(0,p.Z)({},ULp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}qLp.isMDXComponent=!0;const jLp={toc:[]},YLp="wrapper";function QLp(t){let{components:e,...n}=t;return(0,s.kt)(YLp,(0,p.Z)({},jLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}QLp.isMDXComponent=!0;const HLp={toc:[]},KLp="wrapper";function $Lp(t){let{components:e,...n}=t;return(0,s.kt)(KLp,(0,p.Z)({},HLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}$Lp.isMDXComponent=!0;const JLp={toc:[]},tZp="wrapper";function eZp(t){let{components:e,...n}=t;return(0,s.kt)(tZp,(0,p.Z)({},JLp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}eZp.isMDXComponent=!0;const nZp={toc:[]},oZp="wrapper";function pZp(t){let{components:e,...n}=t;return(0,s.kt)(oZp,(0,p.Z)({},nZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}pZp.isMDXComponent=!0;const rZp={toc:[]},sZp="wrapper";function cZp(t){let{components:e,...n}=t;return(0,s.kt)(sZp,(0,p.Z)({},rZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cZp.isMDXComponent=!0;const aZp={toc:[]},iZp="wrapper";function lZp(t){let{components:e,...n}=t;return(0,s.kt)(iZp,(0,p.Z)({},aZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}lZp.isMDXComponent=!0;const uZp={toc:[]},mZp="wrapper";function dZp(t){let{components:e,...n}=t;return(0,s.kt)(mZp,(0,p.Z)({},uZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}dZp.isMDXComponent=!0;const hZp={toc:[]},fZp="wrapper";function kZp(t){let{components:e,...n}=t;return(0,s.kt)(fZp,(0,p.Z)({},hZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}kZp.isMDXComponent=!0;const yZp={toc:[]},DZp="wrapper";function MZp(t){let{components:e,...n}=t;return(0,s.kt)(DZp,(0,p.Z)({},yZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MZp.isMDXComponent=!0;const XZp={toc:[]},_Zp="wrapper";function wZp(t){let{components:e,...n}=t;return(0,s.kt)(_Zp,(0,p.Z)({},XZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}wZp.isMDXComponent=!0;const TZp={toc:[]},CZp="wrapper";function xZp(t){let{components:e,...n}=t;return(0,s.kt)(CZp,(0,p.Z)({},TZp,n,{components:e,mdxType:"MDXLayout"}))}xZp.isMDXComponent=!0;const gZp={toc:[]},vZp="wrapper";function LZp(t){let{components:e,...n}=t;return(0,s.kt)(vZp,(0,p.Z)({},gZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}LZp.isMDXComponent=!0;const ZZp={toc:[]},bZp="wrapper";function NZp(t){let{components:e,...n}=t;return(0,s.kt)(bZp,(0,p.Z)({},ZZp,n,{components:e,mdxType:"MDXLayout"}))}NZp.isMDXComponent=!0;const zZp={toc:[]},AZp="wrapper";function PZp(t){let{components:e,...n}=t;return(0,s.kt)(AZp,(0,p.Z)({},zZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}PZp.isMDXComponent=!0;const WZp={toc:[]},RZp="wrapper";function IZp(t){let{components:e,...n}=t;return(0,s.kt)(RZp,(0,p.Z)({},WZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}IZp.isMDXComponent=!0;const SZp={toc:[]},BZp="wrapper";function GZp(t){let{components:e,...n}=t;return(0,s.kt)(BZp,(0,p.Z)({},SZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}GZp.isMDXComponent=!0;const EZp={toc:[]},OZp="wrapper";function FZp(t){let{components:e,...n}=t;return(0,s.kt)(OZp,(0,p.Z)({},EZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}FZp.isMDXComponent=!0;const UZp={toc:[]},VZp="wrapper";function qZp(t){let{components:e,...n}=t;return(0,s.kt)(VZp,(0,p.Z)({},UZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/QuadBezierProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}qZp.isMDXComponent=!0;const jZp={toc:[]},YZp="wrapper";function QZp(t){let{components:e,...n}=t;return(0,s.kt)(YZp,(0,p.Z)({},jZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}QZp.isMDXComponent=!0;const HZp={toc:[]},KZp="wrapper";function $Zp(t){let{components:e,...n}=t;return(0,s.kt)(KZp,(0,p.Z)({},HZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$Zp.isMDXComponent=!0;const JZp={toc:[]},tbp="wrapper";function ebp(t){let{components:e,...n}=t;return(0,s.kt)(tbp,(0,p.Z)({},JZp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}ebp.isMDXComponent=!0;const nbp={toc:[]},obp="wrapper";function pbp(t){let{components:e,...n}=t;return(0,s.kt)(obp,(0,p.Z)({},nbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pbp.isMDXComponent=!0;const rbp={toc:[]},sbp="wrapper";function cbp(t){let{components:e,...n}=t;return(0,s.kt)(sbp,(0,p.Z)({},rbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}cbp.isMDXComponent=!0;const abp={toc:[]},ibp="wrapper";function lbp(t){let{components:e,...n}=t;return(0,s.kt)(ibp,(0,p.Z)({},abp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lbp.isMDXComponent=!0;const ubp={toc:[]},mbp="wrapper";function dbp(t){let{components:e,...n}=t;return(0,s.kt)(mbp,(0,p.Z)({},ubp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}dbp.isMDXComponent=!0;const hbp={toc:[]},fbp="wrapper";function kbp(t){let{components:e,...n}=t;return(0,s.kt)(fbp,(0,p.Z)({},hbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}kbp.isMDXComponent=!0;const ybp={toc:[]},Dbp="wrapper";function Mbp(t){let{components:e,...n}=t;return(0,s.kt)(Dbp,(0,p.Z)({},ybp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Mbp.isMDXComponent=!0;const Xbp={toc:[]},_bp="wrapper";function wbp(t){let{components:e,...n}=t;return(0,s.kt)(_bp,(0,p.Z)({},Xbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wbp.isMDXComponent=!0;const Tbp={toc:[]},Cbp="wrapper";function xbp(t){let{components:e,...n}=t;return(0,s.kt)(Cbp,(0,p.Z)({},Tbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}xbp.isMDXComponent=!0;const gbp={toc:[]},vbp="wrapper";function Lbp(t){let{components:e,...n}=t;return(0,s.kt)(vbp,(0,p.Z)({},gbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Lbp.isMDXComponent=!0;const Zbp={toc:[]},bbp="wrapper";function Nbp(t){let{components:e,...n}=t;return(0,s.kt)(bbp,(0,p.Z)({},Zbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Nbp.isMDXComponent=!0;const zbp={toc:[]},Abp="wrapper";function Pbp(t){let{components:e,...n}=t;return(0,s.kt)(Abp,(0,p.Z)({},zbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pbp.isMDXComponent=!0;const Wbp={toc:[]},Rbp="wrapper";function Ibp(t){let{components:e,...n}=t;return(0,s.kt)(Rbp,(0,p.Z)({},Wbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Ibp.isMDXComponent=!0;const Sbp={toc:[]},Bbp="wrapper";function Gbp(t){let{components:e,...n}=t;return(0,s.kt)(Bbp,(0,p.Z)({},Sbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}Gbp.isMDXComponent=!0;const Ebp={toc:[]},Obp="wrapper";function Fbp(t){let{components:e,...n}=t;return(0,s.kt)(Obp,(0,p.Z)({},Ebp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Fbp.isMDXComponent=!0;const Ubp={toc:[]},Vbp="wrapper";function qbp(t){let{components:e,...n}=t;return(0,s.kt)(Vbp,(0,p.Z)({},Ubp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}qbp.isMDXComponent=!0;const jbp={toc:[]},Ybp="wrapper";function Qbp(t){let{components:e,...n}=t;return(0,s.kt)(Ybp,(0,p.Z)({},jbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}Qbp.isMDXComponent=!0;const Hbp={toc:[]},Kbp="wrapper";function $bp(t){let{components:e,...n}=t;return(0,s.kt)(Kbp,(0,p.Z)({},Hbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}$bp.isMDXComponent=!0;const Jbp={toc:[]},tNp="wrapper";function eNp(t){let{components:e,...n}=t;return(0,s.kt)(tNp,(0,p.Z)({},Jbp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}eNp.isMDXComponent=!0;const nNp={toc:[]},oNp="wrapper";function pNp(t){let{components:e,...n}=t;return(0,s.kt)(oNp,(0,p.Z)({},nNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}pNp.isMDXComponent=!0;const rNp={toc:[]},sNp="wrapper";function cNp(t){let{components:e,...n}=t;return(0,s.kt)(sNp,(0,p.Z)({},rNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}cNp.isMDXComponent=!0;const aNp={toc:[]},iNp="wrapper";function lNp(t){let{components:e,...n}=t;return(0,s.kt)(iNp,(0,p.Z)({},aNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}lNp.isMDXComponent=!0;const uNp={toc:[]},mNp="wrapper";function dNp(t){let{components:e,...n}=t;return(0,s.kt)(mNp,(0,p.Z)({},uNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}dNp.isMDXComponent=!0;const hNp={toc:[]},fNp="wrapper";function kNp(t){let{components:e,...n}=t;return(0,s.kt)(fNp,(0,p.Z)({},hNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}kNp.isMDXComponent=!0;const yNp={toc:[]},DNp="wrapper";function MNp(t){let{components:e,...n}=t;return(0,s.kt)(DNp,(0,p.Z)({},yNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}MNp.isMDXComponent=!0;const XNp={toc:[]},_Np="wrapper";function wNp(t){let{components:e,...n}=t;return(0,s.kt)(_Np,(0,p.Z)({},XNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}wNp.isMDXComponent=!0;const TNp={toc:[]},CNp="wrapper";function xNp(t){let{components:e,...n}=t;return(0,s.kt)(CNp,(0,p.Z)({},TNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}xNp.isMDXComponent=!0;const gNp={toc:[]},vNp="wrapper";function LNp(t){let{components:e,...n}=t;return(0,s.kt)(vNp,(0,p.Z)({},gNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}LNp.isMDXComponent=!0;const ZNp={toc:[]},bNp="wrapper";function NNp(t){let{components:e,...n}=t;return(0,s.kt)(bNp,(0,p.Z)({},ZNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}NNp.isMDXComponent=!0;const zNp={toc:[]},ANp="wrapper";function PNp(t){let{components:e,...n}=t;return(0,s.kt)(ANp,(0,p.Z)({},zNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}PNp.isMDXComponent=!0;const WNp={toc:[]},RNp="wrapper";function INp(t){let{components:e,...n}=t;return(0,s.kt)(RNp,(0,p.Z)({},WNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}INp.isMDXComponent=!0;const SNp={toc:[]},BNp="wrapper";function GNp(t){let{components:e,...n}=t;return(0,s.kt)(BNp,(0,p.Z)({},SNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting point of the ray."))}GNp.isMDXComponent=!0;const ENp={toc:[]},ONp="wrapper";function FNp(t){let{components:e,...n}=t;return(0,s.kt)(ONp,(0,p.Z)({},ENp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FNp.isMDXComponent=!0;const UNp={toc:[]},VNp="wrapper";function qNp(t){let{components:e,...n}=t;return(0,s.kt)(VNp,(0,p.Z)({},UNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qNp.isMDXComponent=!0;const jNp={toc:[]},YNp="wrapper";function QNp(t){let{components:e,...n}=t;return(0,s.kt)(YNp,(0,p.Z)({},jNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}QNp.isMDXComponent=!0;const HNp={toc:[]},KNp="wrapper";function $Np(t){let{components:e,...n}=t;return(0,s.kt)(KNp,(0,p.Z)({},HNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}$Np.isMDXComponent=!0;const JNp={toc:[]},tzp="wrapper";function ezp(t){let{components:e,...n}=t;return(0,s.kt)(tzp,(0,p.Z)({},JNp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ezp.isMDXComponent=!0;const nzp={toc:[]},ozp="wrapper";function pzp(t){let{components:e,...n}=t;return(0,s.kt)(ozp,(0,p.Z)({},nzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pzp.isMDXComponent=!0;const rzp={toc:[]},szp="wrapper";function czp(t){let{components:e,...n}=t;return(0,s.kt)(szp,(0,p.Z)({},rzp,n,{components:e,mdxType:"MDXLayout"}))}czp.isMDXComponent=!0;const azp={toc:[]},izp="wrapper";function lzp(t){let{components:e,...n}=t;return(0,s.kt)(izp,(0,p.Z)({},azp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}lzp.isMDXComponent=!0;const uzp={toc:[]},mzp="wrapper";function dzp(t){let{components:e,...n}=t;return(0,s.kt)(mzp,(0,p.Z)({},uzp,n,{components:e,mdxType:"MDXLayout"}))}dzp.isMDXComponent=!0;const hzp={toc:[]},fzp="wrapper";function kzp(t){let{components:e,...n}=t;return(0,s.kt)(fzp,(0,p.Z)({},hzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kzp.isMDXComponent=!0;const yzp={toc:[]},Dzp="wrapper";function Mzp(t){let{components:e,...n}=t;return(0,s.kt)(Dzp,(0,p.Z)({},yzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}Mzp.isMDXComponent=!0;const Xzp={toc:[]},_zp="wrapper";function wzp(t){let{components:e,...n}=t;return(0,s.kt)(_zp,(0,p.Z)({},Xzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wzp.isMDXComponent=!0;const Tzp={toc:[]},Czp="wrapper";function xzp(t){let{components:e,...n}=t;return(0,s.kt)(Czp,(0,p.Z)({},Tzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}xzp.isMDXComponent=!0;const gzp={toc:[]},vzp="wrapper";function Lzp(t){let{components:e,...n}=t;return(0,s.kt)(vzp,(0,p.Z)({},gzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RayProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}Lzp.isMDXComponent=!0;const Zzp={toc:[]},bzp="wrapper";function Nzp(t){let{components:e,...n}=t;return(0,s.kt)(bzp,(0,p.Z)({},Zzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}Nzp.isMDXComponent=!0;const zzp={toc:[]},Azp="wrapper";function Pzp(t){let{components:e,...n}=t;return(0,s.kt)(Azp,(0,p.Z)({},zzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The ending point of the ray."))}Pzp.isMDXComponent=!0;const Wzp={toc:[]},Rzp="wrapper";function Izp(t){let{components:e,...n}=t;return(0,s.kt)(Rzp,(0,p.Z)({},Wzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Izp.isMDXComponent=!0;const Szp={toc:[]},Bzp="wrapper";function Gzp(t){let{components:e,...n}=t;return(0,s.kt)(Bzp,(0,p.Z)({},Szp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}Gzp.isMDXComponent=!0;const Ezp={toc:[]},Ozp="wrapper";function Fzp(t){let{components:e,...n}=t;return(0,s.kt)(Ozp,(0,p.Z)({},Ezp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Fzp.isMDXComponent=!0;const Uzp={toc:[]},Vzp="wrapper";function qzp(t){let{components:e,...n}=t;return(0,s.kt)(Vzp,(0,p.Z)({},Uzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}qzp.isMDXComponent=!0;const jzp={toc:[]},Yzp="wrapper";function Qzp(t){let{components:e,...n}=t;return(0,s.kt)(Yzp,(0,p.Z)({},jzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Qzp.isMDXComponent=!0;const Hzp={toc:[]},Kzp="wrapper";function $zp(t){let{components:e,...n}=t;return(0,s.kt)(Kzp,(0,p.Z)({},Hzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}$zp.isMDXComponent=!0;const Jzp={toc:[]},tAp="wrapper";function eAp(t){let{components:e,...n}=t;return(0,s.kt)(tAp,(0,p.Z)({},Jzp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}eAp.isMDXComponent=!0;const nAp={toc:[]},oAp="wrapper";function pAp(t){let{components:e,...n}=t;return(0,s.kt)(oAp,(0,p.Z)({},nAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}pAp.isMDXComponent=!0;const rAp={toc:[]},sAp="wrapper";function cAp(t){let{components:e,...n}=t;return(0,s.kt)(sAp,(0,p.Z)({},rAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cAp.isMDXComponent=!0;const aAp={toc:[]},iAp="wrapper";function lAp(t){let{components:e,...n}=t;return(0,s.kt)(iAp,(0,p.Z)({},aAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}lAp.isMDXComponent=!0;const uAp={toc:[]},mAp="wrapper";function dAp(t){let{components:e,...n}=t;return(0,s.kt)(mAp,(0,p.Z)({},uAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dAp.isMDXComponent=!0;const hAp={toc:[]},fAp="wrapper";function kAp(t){let{components:e,...n}=t;return(0,s.kt)(fAp,(0,p.Z)({},hAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}kAp.isMDXComponent=!0;const yAp={toc:[]},DAp="wrapper";function MAp(t){let{components:e,...n}=t;return(0,s.kt)(DAp,(0,p.Z)({},yAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MAp.isMDXComponent=!0;const XAp={toc:[]},_Ap="wrapper";function wAp(t){let{components:e,...n}=t;return(0,s.kt)(_Ap,(0,p.Z)({},XAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}wAp.isMDXComponent=!0;const TAp={toc:[]},CAp="wrapper";function xAp(t){let{components:e,...n}=t;return(0,s.kt)(CAp,(0,p.Z)({},TAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}xAp.isMDXComponent=!0;const gAp={toc:[]},vAp="wrapper";function LAp(t){let{components:e,...n}=t;return(0,s.kt)(vAp,(0,p.Z)({},gAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}LAp.isMDXComponent=!0;const ZAp={toc:[]},bAp="wrapper";function NAp(t){let{components:e,...n}=t;return(0,s.kt)(bAp,(0,p.Z)({},ZAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}NAp.isMDXComponent=!0;const zAp={toc:[]},AAp="wrapper";function PAp(t){let{components:e,...n}=t;return(0,s.kt)(AAp,(0,p.Z)({},zAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}PAp.isMDXComponent=!0;const WAp={toc:[]},RAp="wrapper";function IAp(t){let{components:e,...n}=t;return(0,s.kt)(RAp,(0,p.Z)({},WAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}IAp.isMDXComponent=!0;const SAp={toc:[]},BAp="wrapper";function GAp(t){let{components:e,...n}=t;return(0,s.kt)(BAp,(0,p.Z)({},SAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}GAp.isMDXComponent=!0;const EAp={toc:[]},OAp="wrapper";function FAp(t){let{components:e,...n}=t;return(0,s.kt)(OAp,(0,p.Z)({},EAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}FAp.isMDXComponent=!0;const UAp={toc:[]},VAp="wrapper";function qAp(t){let{components:e,...n}=t;return(0,s.kt)(VAp,(0,p.Z)({},UAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}qAp.isMDXComponent=!0;const jAp={toc:[]},YAp="wrapper";function QAp(t){let{components:e,...n}=t;return(0,s.kt)(YAp,(0,p.Z)({},jAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}QAp.isMDXComponent=!0;const HAp={toc:[]},KAp="wrapper";function $Ap(t){let{components:e,...n}=t;return(0,s.kt)(KAp,(0,p.Z)({},HAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}$Ap.isMDXComponent=!0;const JAp={toc:[]},tPp="wrapper";function ePp(t){let{components:e,...n}=t;return(0,s.kt)(tPp,(0,p.Z)({},JAp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}ePp.isMDXComponent=!0;const nPp={toc:[]},oPp="wrapper";function pPp(t){let{components:e,...n}=t;return(0,s.kt)(oPp,(0,p.Z)({},nPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}pPp.isMDXComponent=!0;const rPp={toc:[]},sPp="wrapper";function cPp(t){let{components:e,...n}=t;return(0,s.kt)(sPp,(0,p.Z)({},rPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}cPp.isMDXComponent=!0;const aPp={toc:[]},iPp="wrapper";function lPp(t){let{components:e,...n}=t;return(0,s.kt)(iPp,(0,p.Z)({},aPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}lPp.isMDXComponent=!0;const uPp={toc:[]},mPp="wrapper";function dPp(t){let{components:e,...n}=t;return(0,s.kt)(mPp,(0,p.Z)({},uPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}dPp.isMDXComponent=!0;const hPp={toc:[]},fPp="wrapper";function kPp(t){let{components:e,...n}=t;return(0,s.kt)(fPp,(0,p.Z)({},hPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}kPp.isMDXComponent=!0;const yPp={toc:[]},DPp="wrapper";function MPp(t){let{components:e,...n}=t;return(0,s.kt)(DPp,(0,p.Z)({},yPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}MPp.isMDXComponent=!0;const XPp={toc:[]},_Pp="wrapper";function wPp(t){let{components:e,...n}=t;return(0,s.kt)(_Pp,(0,p.Z)({},XPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}wPp.isMDXComponent=!0;const TPp={toc:[]},CPp="wrapper";function xPp(t){let{components:e,...n}=t;return(0,s.kt)(CPp,(0,p.Z)({},TPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}xPp.isMDXComponent=!0;const gPp={toc:[]},vPp="wrapper";function LPp(t){let{components:e,...n}=t;return(0,s.kt)(vPp,(0,p.Z)({},gPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}LPp.isMDXComponent=!0;const ZPp={toc:[]},bPp="wrapper";function NPp(t){let{components:e,...n}=t;return(0,s.kt)(bPp,(0,p.Z)({},ZPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}NPp.isMDXComponent=!0;const zPp={toc:[]},APp="wrapper";function PPp(t){let{components:e,...n}=t;return(0,s.kt)(APp,(0,p.Z)({},zPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}PPp.isMDXComponent=!0;const WPp={toc:[]},RPp="wrapper";function IPp(t){let{components:e,...n}=t;return(0,s.kt)(RPp,(0,p.Z)({},WPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}IPp.isMDXComponent=!0;const SPp={toc:[]},BPp="wrapper";function GPp(t){let{components:e,...n}=t;return(0,s.kt)(BPp,(0,p.Z)({},SPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}GPp.isMDXComponent=!0;const EPp={toc:[]},OPp="wrapper";function FPp(t){let{components:e,...n}=t;return(0,s.kt)(OPp,(0,p.Z)({},EPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}FPp.isMDXComponent=!0;const UPp={toc:[]},VPp="wrapper";function qPp(t){let{components:e,...n}=t;return(0,s.kt)(VPp,(0,p.Z)({},UPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}qPp.isMDXComponent=!0;const jPp={toc:[]},YPp="wrapper";function QPp(t){let{components:e,...n}=t;return(0,s.kt)(YPp,(0,p.Z)({},jPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}QPp.isMDXComponent=!0;const HPp={toc:[]},KPp="wrapper";function $Pp(t){let{components:e,...n}=t;return(0,s.kt)(KPp,(0,p.Z)({},HPp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}$Pp.isMDXComponent=!0;const JPp={toc:[]},tWp="wrapper";function eWp(t){let{components:e,...n}=t;return(0,s.kt)(tWp,(0,p.Z)({},JPp,n,{components:e,mdxType:"MDXLayout"}))}eWp.isMDXComponent=!0;const nWp={toc:[]},oWp="wrapper";function pWp(t){let{components:e,...n}=t;return(0,s.kt)(oWp,(0,p.Z)({},nWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}pWp.isMDXComponent=!0;const rWp={toc:[]},sWp="wrapper";function cWp(t){let{components:e,...n}=t;return(0,s.kt)(sWp,(0,p.Z)({},rWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}cWp.isMDXComponent=!0;const aWp={toc:[]},iWp="wrapper";function lWp(t){let{components:e,...n}=t;return(0,s.kt)(iWp,(0,p.Z)({},aWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}lWp.isMDXComponent=!0;const uWp={toc:[]},mWp="wrapper";function dWp(t){let{components:e,...n}=t;return(0,s.kt)(mWp,(0,p.Z)({},uWp,n,{components:e,mdxType:"MDXLayout"}))}dWp.isMDXComponent=!0;const hWp={toc:[]},fWp="wrapper";function kWp(t){let{components:e,...n}=t;return(0,s.kt)(fWp,(0,p.Z)({},hWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}kWp.isMDXComponent=!0;const yWp={toc:[]},DWp="wrapper";function MWp(t){let{components:e,...n}=t;return(0,s.kt)(DWp,(0,p.Z)({},yWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}MWp.isMDXComponent=!0;const XWp={toc:[]},_Wp="wrapper";function wWp(t){let{components:e,...n}=t;return(0,s.kt)(_Wp,(0,p.Z)({},XWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}wWp.isMDXComponent=!0;const TWp={toc:[]},CWp="wrapper";function xWp(t){let{components:e,...n}=t;return(0,s.kt)(CWp,(0,p.Z)({},TWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}xWp.isMDXComponent=!0;const gWp={toc:[]},vWp="wrapper";function LWp(t){let{components:e,...n}=t;return(0,s.kt)(vWp,(0,p.Z)({},gWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/RectProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}LWp.isMDXComponent=!0;const ZWp={toc:[]},bWp="wrapper";function NWp(t){let{components:e,...n}=t;return(0,s.kt)(bWp,(0,p.Z)({},ZWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}NWp.isMDXComponent=!0;const zWp={toc:[]},AWp="wrapper";function PWp(t){let{components:e,...n}=t;return(0,s.kt)(AWp,(0,p.Z)({},zWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}PWp.isMDXComponent=!0;const WWp={toc:[]},RWp="wrapper";function IWp(t){let{components:e,...n}=t;return(0,s.kt)(RWp,(0,p.Z)({},WWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}IWp.isMDXComponent=!0;const SWp={toc:[]},BWp="wrapper";function GWp(t){let{components:e,...n}=t;return(0,s.kt)(BWp,(0,p.Z)({},SWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}GWp.isMDXComponent=!0;const EWp={toc:[]},OWp="wrapper";function FWp(t){let{components:e,...n}=t;return(0,s.kt)(OWp,(0,p.Z)({},EWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}FWp.isMDXComponent=!0;const UWp={toc:[]},VWp="wrapper";function qWp(t){let{components:e,...n}=t;return(0,s.kt)(VWp,(0,p.Z)({},UWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qWp.isMDXComponent=!0;const jWp={toc:[]},YWp="wrapper";function QWp(t){let{components:e,...n}=t;return(0,s.kt)(YWp,(0,p.Z)({},jWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}QWp.isMDXComponent=!0;const HWp={toc:[]},KWp="wrapper";function $Wp(t){let{components:e,...n}=t;return(0,s.kt)(KWp,(0,p.Z)({},HWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represent SVG document that contains SVG shapes.\nThis only used single time because ",(0,s.kt)("inlineCode",{parentName:"p"},"nodes")," have reference to parent SVG renderer."))}$Wp.isMDXComponent=!0;const JWp={toc:[]},tRp="wrapper";function eRp(t){let{components:e,...n}=t;return(0,s.kt)(tRp,(0,p.Z)({},JWp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Data of SVGDocument.\nThis can used many times because it do not reference parent SVG.\nThis must build into SVGDocument"))}eRp.isMDXComponent=!0;const nRp={toc:[]},oRp="wrapper";function pRp(t){let{components:e,...n}=t;return(0,s.kt)(oRp,(0,p.Z)({},nRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pRp.isMDXComponent=!0;const rRp={toc:[]},sRp="wrapper";function cRp(t){let{components:e,...n}=t;return(0,s.kt)(sRp,(0,p.Z)({},rRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}cRp.isMDXComponent=!0;const aRp={toc:[]},iRp="wrapper";function lRp(t){let{components:e,...n}=t;return(0,s.kt)(iRp,(0,p.Z)({},aRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lRp.isMDXComponent=!0;const uRp={toc:[]},mRp="wrapper";function dRp(t){let{components:e,...n}=t;return(0,s.kt)(mRp,(0,p.Z)({},uRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}dRp.isMDXComponent=!0;const hRp={toc:[]},fRp="wrapper";function kRp(t){let{components:e,...n}=t;return(0,s.kt)(fRp,(0,p.Z)({},hRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kRp.isMDXComponent=!0;const yRp={toc:[]},DRp="wrapper";function MRp(t){let{components:e,...n}=t;return(0,s.kt)(DRp,(0,p.Z)({},yRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}MRp.isMDXComponent=!0;const XRp={toc:[]},_Rp="wrapper";function wRp(t){let{components:e,...n}=t;return(0,s.kt)(_Rp,(0,p.Z)({},XRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}wRp.isMDXComponent=!0;const TRp={toc:[]},CRp="wrapper";function xRp(t){let{components:e,...n}=t;return(0,s.kt)(CRp,(0,p.Z)({},TRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}xRp.isMDXComponent=!0;const gRp={toc:[]},vRp="wrapper";function LRp(t){let{components:e,...n}=t;return(0,s.kt)(vRp,(0,p.Z)({},gRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}LRp.isMDXComponent=!0;const ZRp={toc:[]},bRp="wrapper";function NRp(t){let{components:e,...n}=t;return(0,s.kt)(bRp,(0,p.Z)({},ZRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}NRp.isMDXComponent=!0;const zRp={toc:[]},ARp="wrapper";function PRp(t){let{components:e,...n}=t;return(0,s.kt)(ARp,(0,p.Z)({},zRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}PRp.isMDXComponent=!0;const WRp={toc:[]},RRp="wrapper";function IRp(t){let{components:e,...n}=t;return(0,s.kt)(RRp,(0,p.Z)({},WRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}IRp.isMDXComponent=!0;const SRp={toc:[]},BRp="wrapper";function GRp(t){let{components:e,...n}=t;return(0,s.kt)(BRp,(0,p.Z)({},SRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}GRp.isMDXComponent=!0;const ERp={toc:[]},ORp="wrapper";function FRp(t){let{components:e,...n}=t;return(0,s.kt)(ORp,(0,p.Z)({},ERp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}FRp.isMDXComponent=!0;const URp={toc:[]},VRp="wrapper";function qRp(t){let{components:e,...n}=t;return(0,s.kt)(VRp,(0,p.Z)({},URp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}qRp.isMDXComponent=!0;const jRp={toc:[]},YRp="wrapper";function QRp(t){let{components:e,...n}=t;return(0,s.kt)(YRp,(0,p.Z)({},jRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}QRp.isMDXComponent=!0;const HRp={toc:[]},KRp="wrapper";function $Rp(t){let{components:e,...n}=t;return(0,s.kt)(KRp,(0,p.Z)({},HRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$Rp.isMDXComponent=!0;const JRp={toc:[]},tIp="wrapper";function eIp(t){let{components:e,...n}=t;return(0,s.kt)(tIp,(0,p.Z)({},JRp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}eIp.isMDXComponent=!0;const nIp={toc:[]},oIp="wrapper";function pIp(t){let{components:e,...n}=t;return(0,s.kt)(oIp,(0,p.Z)({},nIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}pIp.isMDXComponent=!0;const rIp={toc:[]},sIp="wrapper";function cIp(t){let{components:e,...n}=t;return(0,s.kt)(sIp,(0,p.Z)({},rIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}cIp.isMDXComponent=!0;const aIp={toc:[]},iIp="wrapper";function lIp(t){let{components:e,...n}=t;return(0,s.kt)(iIp,(0,p.Z)({},aIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lIp.isMDXComponent=!0;const uIp={toc:[]},mIp="wrapper";function dIp(t){let{components:e,...n}=t;return(0,s.kt)(mIp,(0,p.Z)({},uIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}dIp.isMDXComponent=!0;const hIp={toc:[]},fIp="wrapper";function kIp(t){let{components:e,...n}=t;return(0,s.kt)(fIp,(0,p.Z)({},hIp,n,{components:e,mdxType:"MDXLayout"}))}kIp.isMDXComponent=!0;const yIp={toc:[]},DIp="wrapper";function MIp(t){let{components:e,...n}=t;return(0,s.kt)(DIp,(0,p.Z)({},yIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SVGProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}MIp.isMDXComponent=!0;const XIp={toc:[]},_Ip="wrapper";function wIp(t){let{components:e,...n}=t;return(0,s.kt)(_Ip,(0,p.Z)({},XIp,n,{components:e,mdxType:"MDXLayout"}))}wIp.isMDXComponent=!0;const TIp={toc:[]},CIp="wrapper";function xIp(t){let{components:e,...n}=t;return(0,s.kt)(CIp,(0,p.Z)({},TIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xIp.isMDXComponent=!0;const gIp={toc:[]},vIp="wrapper";function LIp(t){let{components:e,...n}=t;return(0,s.kt)(vIp,(0,p.Z)({},gIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}LIp.isMDXComponent=!0;const ZIp={toc:[]},bIp="wrapper";function NIp(t){let{components:e,...n}=t;return(0,s.kt)(bIp,(0,p.Z)({},ZIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}NIp.isMDXComponent=!0;const zIp={toc:[]},AIp="wrapper";function PIp(t){let{components:e,...n}=t;return(0,s.kt)(AIp,(0,p.Z)({},zIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}PIp.isMDXComponent=!0;const WIp={toc:[]},RIp="wrapper";function IIp(t){let{components:e,...n}=t;return(0,s.kt)(RIp,(0,p.Z)({},WIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}IIp.isMDXComponent=!0;const SIp={toc:[]},BIp="wrapper";function GIp(t){let{components:e,...n}=t;return(0,s.kt)(BIp,(0,p.Z)({},SIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}GIp.isMDXComponent=!0;const EIp={toc:[]},OIp="wrapper";function FIp(t){let{components:e,...n}=t;return(0,s.kt)(OIp,(0,p.Z)({},EIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represent SVG shape.\nThis only used single time because ",(0,s.kt)("inlineCode",{parentName:"p"},"node")," may have reference to parent SVG renderer."))}FIp.isMDXComponent=!0;const UIp={toc:[]},VIp="wrapper";function qIp(t){let{components:e,...n}=t;return(0,s.kt)(VIp,(0,p.Z)({},UIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Data of SVGShape.\nThis can used many times  because it do not reference parent SVG.\nThis must build into SVGShape"))}qIp.isMDXComponent=!0;const jIp={toc:[]},YIp="wrapper";function QIp(t){let{components:e,...n}=t;return(0,s.kt)(YIp,(0,p.Z)({},jIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}QIp.isMDXComponent=!0;const HIp={toc:[]},KIp="wrapper";function $Ip(t){let{components:e,...n}=t;return(0,s.kt)(KIp,(0,p.Z)({},HIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}$Ip.isMDXComponent=!0;const JIp={toc:[]},tSp="wrapper";function eSp(t){let{components:e,...n}=t;return(0,s.kt)(tSp,(0,p.Z)({},JIp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eSp.isMDXComponent=!0;const nSp={toc:[]},oSp="wrapper";function pSp(t){let{components:e,...n}=t;return(0,s.kt)(oSp,(0,p.Z)({},nSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}pSp.isMDXComponent=!0;const rSp={toc:[]},sSp="wrapper";function cSp(t){let{components:e,...n}=t;return(0,s.kt)(sSp,(0,p.Z)({},rSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cSp.isMDXComponent=!0;const aSp={toc:[]},iSp="wrapper";function lSp(t){let{components:e,...n}=t;return(0,s.kt)(iSp,(0,p.Z)({},aSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}lSp.isMDXComponent=!0;const uSp={toc:[]},mSp="wrapper";function dSp(t){let{components:e,...n}=t;return(0,s.kt)(mSp,(0,p.Z)({},uSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}dSp.isMDXComponent=!0;const hSp={toc:[]},fSp="wrapper";function kSp(t){let{components:e,...n}=t;return(0,s.kt)(fSp,(0,p.Z)({},hSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}kSp.isMDXComponent=!0;const ySp={toc:[]},DSp="wrapper";function MSp(t){let{components:e,...n}=t;return(0,s.kt)(DSp,(0,p.Z)({},ySp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}MSp.isMDXComponent=!0;const XSp={toc:[]},_Sp="wrapper";function wSp(t){let{components:e,...n}=t;return(0,s.kt)(_Sp,(0,p.Z)({},XSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}wSp.isMDXComponent=!0;const TSp={toc:[]},CSp="wrapper";function xSp(t){let{components:e,...n}=t;return(0,s.kt)(CSp,(0,p.Z)({},TSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}xSp.isMDXComponent=!0;const gSp={toc:[]},vSp="wrapper";function LSp(t){let{components:e,...n}=t;return(0,s.kt)(vSp,(0,p.Z)({},gSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}LSp.isMDXComponent=!0;const ZSp={toc:[]},bSp="wrapper";function NSp(t){let{components:e,...n}=t;return(0,s.kt)(bSp,(0,p.Z)({},ZSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}NSp.isMDXComponent=!0;const zSp={toc:[]},ASp="wrapper";function PSp(t){let{components:e,...n}=t;return(0,s.kt)(ASp,(0,p.Z)({},zSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}PSp.isMDXComponent=!0;const WSp={toc:[]},RSp="wrapper";function ISp(t){let{components:e,...n}=t;return(0,s.kt)(RSp,(0,p.Z)({},WSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}ISp.isMDXComponent=!0;const SSp={toc:[]},BSp="wrapper";function GSp(t){let{components:e,...n}=t;return(0,s.kt)(BSp,(0,p.Z)({},SSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}GSp.isMDXComponent=!0;const ESp={toc:[]},OSp="wrapper";function FSp(t){let{components:e,...n}=t;return(0,s.kt)(OSp,(0,p.Z)({},ESp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FSp.isMDXComponent=!0;const USp={toc:[]},VSp="wrapper";function qSp(t){let{components:e,...n}=t;return(0,s.kt)(VSp,(0,p.Z)({},USp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qSp.isMDXComponent=!0;const jSp={toc:[]},YSp="wrapper";function QSp(t){let{components:e,...n}=t;return(0,s.kt)(YSp,(0,p.Z)({},jSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}QSp.isMDXComponent=!0;const HSp={toc:[]},KSp="wrapper";function $Sp(t){let{components:e,...n}=t;return(0,s.kt)(KSp,(0,p.Z)({},HSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}$Sp.isMDXComponent=!0;const JSp={toc:[]},tBp="wrapper";function eBp(t){let{components:e,...n}=t;return(0,s.kt)(tBp,(0,p.Z)({},JSp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eBp.isMDXComponent=!0;const nBp={toc:[]},oBp="wrapper";function pBp(t){let{components:e,...n}=t;return(0,s.kt)(oBp,(0,p.Z)({},nBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}pBp.isMDXComponent=!0;const rBp={toc:[]},sBp="wrapper";function cBp(t){let{components:e,...n}=t;return(0,s.kt)(sBp,(0,p.Z)({},rBp,n,{components:e,mdxType:"MDXLayout"}))}cBp.isMDXComponent=!0;const aBp={toc:[]},iBp="wrapper";function lBp(t){let{components:e,...n}=t;return(0,s.kt)(iBp,(0,p.Z)({},aBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/ShapeProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}lBp.isMDXComponent=!0;const uBp={toc:[]},mBp="wrapper";function dBp(t){let{components:e,...n}=t;return(0,s.kt)(mBp,(0,p.Z)({},uBp,n,{components:e,mdxType:"MDXLayout"}))}dBp.isMDXComponent=!0;const hBp={toc:[]},fBp="wrapper";function kBp(t){let{components:e,...n}=t;return(0,s.kt)(fBp,(0,p.Z)({},hBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kBp.isMDXComponent=!0;const yBp={toc:[]},DBp="wrapper";function MBp(t){let{components:e,...n}=t;return(0,s.kt)(DBp,(0,p.Z)({},yBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}MBp.isMDXComponent=!0;const XBp={toc:[]},_Bp="wrapper";function wBp(t){let{components:e,...n}=t;return(0,s.kt)(_Bp,(0,p.Z)({},XBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wBp.isMDXComponent=!0;const TBp={toc:[]},CBp="wrapper";function xBp(t){let{components:e,...n}=t;return(0,s.kt)(CBp,(0,p.Z)({},TBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}xBp.isMDXComponent=!0;const gBp={toc:[]},vBp="wrapper";function LBp(t){let{components:e,...n}=t;return(0,s.kt)(vBp,(0,p.Z)({},gBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LBp.isMDXComponent=!0;const ZBp={toc:[]},bBp="wrapper";function NBp(t){let{components:e,...n}=t;return(0,s.kt)(bBp,(0,p.Z)({},ZBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}NBp.isMDXComponent=!0;const zBp={toc:[]},ABp="wrapper";function PBp(t){let{components:e,...n}=t;return(0,s.kt)(ABp,(0,p.Z)({},zBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}PBp.isMDXComponent=!0;const WBp={toc:[]},RBp="wrapper";function IBp(t){let{components:e,...n}=t;return(0,s.kt)(RBp,(0,p.Z)({},WBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}IBp.isMDXComponent=!0;const SBp={toc:[]},BBp="wrapper";function GBp(t){let{components:e,...n}=t;return(0,s.kt)(BBp,(0,p.Z)({},SBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}GBp.isMDXComponent=!0;const EBp={toc:[]},OBp="wrapper";function FBp(t){let{components:e,...n}=t;return(0,s.kt)(OBp,(0,p.Z)({},EBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}FBp.isMDXComponent=!0;const UBp={toc:[]},VBp="wrapper";function qBp(t){let{components:e,...n}=t;return(0,s.kt)(VBp,(0,p.Z)({},UBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qBp.isMDXComponent=!0;const jBp={toc:[]},YBp="wrapper";function QBp(t){let{components:e,...n}=t;return(0,s.kt)(YBp,(0,p.Z)({},jBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}QBp.isMDXComponent=!0;const HBp={toc:[]},KBp="wrapper";function $Bp(t){let{components:e,...n}=t;return(0,s.kt)(KBp,(0,p.Z)({},HBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}$Bp.isMDXComponent=!0;const JBp={toc:[]},tGp="wrapper";function eGp(t){let{components:e,...n}=t;return(0,s.kt)(tGp,(0,p.Z)({},JBp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}eGp.isMDXComponent=!0;const nGp={toc:[]},oGp="wrapper";function pGp(t){let{components:e,...n}=t;return(0,s.kt)(oGp,(0,p.Z)({},nGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}pGp.isMDXComponent=!0;const rGp={toc:[]},sGp="wrapper";function cGp(t){let{components:e,...n}=t;return(0,s.kt)(sGp,(0,p.Z)({},rGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}cGp.isMDXComponent=!0;const aGp={toc:[]},iGp="wrapper";function lGp(t){let{components:e,...n}=t;return(0,s.kt)(iGp,(0,p.Z)({},aGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}lGp.isMDXComponent=!0;const uGp={toc:[]},mGp="wrapper";function dGp(t){let{components:e,...n}=t;return(0,s.kt)(mGp,(0,p.Z)({},uGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}dGp.isMDXComponent=!0;const hGp={toc:[]},fGp="wrapper";function kGp(t){let{components:e,...n}=t;return(0,s.kt)(fGp,(0,p.Z)({},hGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}kGp.isMDXComponent=!0;const yGp={toc:[]},DGp="wrapper";function MGp(t){let{components:e,...n}=t;return(0,s.kt)(DGp,(0,p.Z)({},yGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}MGp.isMDXComponent=!0;const XGp={toc:[]},_Gp="wrapper";function wGp(t){let{components:e,...n}=t;return(0,s.kt)(_Gp,(0,p.Z)({},XGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}wGp.isMDXComponent=!0;const TGp={toc:[]},CGp="wrapper";function xGp(t){let{components:e,...n}=t;return(0,s.kt)(CGp,(0,p.Z)({},TGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}xGp.isMDXComponent=!0;const gGp={toc:[]},vGp="wrapper";function LGp(t){let{components:e,...n}=t;return(0,s.kt)(vGp,(0,p.Z)({},gGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}LGp.isMDXComponent=!0;const ZGp={toc:[]},bGp="wrapper";function NGp(t){let{components:e,...n}=t;return(0,s.kt)(bGp,(0,p.Z)({},ZGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}NGp.isMDXComponent=!0;const zGp={toc:[]},AGp="wrapper";function PGp(t){let{components:e,...n}=t;return(0,s.kt)(AGp,(0,p.Z)({},zGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}PGp.isMDXComponent=!0;const WGp={toc:[]},RGp="wrapper";function IGp(t){let{components:e,...n}=t;return(0,s.kt)(RGp,(0,p.Z)({},WGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}IGp.isMDXComponent=!0;const SGp={toc:[]},BGp="wrapper";function GGp(t){let{components:e,...n}=t;return(0,s.kt)(BGp,(0,p.Z)({},SGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}GGp.isMDXComponent=!0;const EGp={toc:[]},OGp="wrapper";function FGp(t){let{components:e,...n}=t;return(0,s.kt)(OGp,(0,p.Z)({},EGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}FGp.isMDXComponent=!0;const UGp={toc:[]},VGp="wrapper";function qGp(t){let{components:e,...n}=t;return(0,s.kt)(VGp,(0,p.Z)({},UGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qGp.isMDXComponent=!0;const jGp={toc:[]},YGp="wrapper";function QGp(t){let{components:e,...n}=t;return(0,s.kt)(YGp,(0,p.Z)({},jGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}QGp.isMDXComponent=!0;const HGp={toc:[]},KGp="wrapper";function $Gp(t){let{components:e,...n}=t;return(0,s.kt)(KGp,(0,p.Z)({},HGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}$Gp.isMDXComponent=!0;const JGp={toc:[]},tEp="wrapper";function eEp(t){let{components:e,...n}=t;return(0,s.kt)(tEp,(0,p.Z)({},JGp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}eEp.isMDXComponent=!0;const nEp={toc:[]},oEp="wrapper";function pEp(t){let{components:e,...n}=t;return(0,s.kt)(oEp,(0,p.Z)({},nEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pEp.isMDXComponent=!0;const rEp={toc:[]},sEp="wrapper";function cEp(t){let{components:e,...n}=t;return(0,s.kt)(sEp,(0,p.Z)({},rEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}cEp.isMDXComponent=!0;const aEp={toc:[]},iEp="wrapper";function lEp(t){let{components:e,...n}=t;return(0,s.kt)(iEp,(0,p.Z)({},aEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}lEp.isMDXComponent=!0;const uEp={toc:[]},mEp="wrapper";function dEp(t){let{components:e,...n}=t;return(0,s.kt)(mEp,(0,p.Z)({},uEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}dEp.isMDXComponent=!0;const hEp={toc:[]},fEp="wrapper";function kEp(t){let{components:e,...n}=t;return(0,s.kt)(fEp,(0,p.Z)({},hEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Spline.points"))}kEp.isMDXComponent=!0;const yEp={toc:[]},DEp="wrapper";function MEp(t){let{components:e,...n}=t;return(0,s.kt)(DEp,(0,p.Z)({},yEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MEp.isMDXComponent=!0;const XEp={toc:[]},_Ep="wrapper";function wEp(t){let{components:e,...n}=t;return(0,s.kt)(_Ep,(0,p.Z)({},XEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}wEp.isMDXComponent=!0;const TEp={toc:[]},CEp="wrapper";function xEp(t){let{components:e,...n}=t;return(0,s.kt)(CEp,(0,p.Z)({},TEp,n,{components:e,mdxType:"MDXLayout"}))}xEp.isMDXComponent=!0;const gEp={toc:[]},vEp="wrapper";function LEp(t){let{components:e,...n}=t;return(0,s.kt)(vEp,(0,p.Z)({},gEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property is only applied to knots that don't use explicit handles."))}LEp.isMDXComponent=!0;const ZEp={toc:[]},bEp="wrapper";function NEp(t){let{components:e,...n}=t;return(0,s.kt)(bEp,(0,p.Z)({},ZEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Determine the smoothness of the spline when using auto-calculated handles."))}NEp.isMDXComponent=!0;const zEp={toc:[]},AEp="wrapper";function PEp(t){let{components:e,...n}=t;return(0,s.kt)(AEp,(0,p.Z)({},zEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}PEp.isMDXComponent=!0;const WEp={toc:[]},REp="wrapper";function IEp(t){let{components:e,...n}=t;return(0,s.kt)(REp,(0,p.Z)({},WEp,n,{components:e,mdxType:"MDXLayout"}))}IEp.isMDXComponent=!0;const SEp={toc:[]},BEp="wrapper";function GEp(t){let{components:e,...n}=t;return(0,s.kt)(BEp,(0,p.Z)({},SEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}GEp.isMDXComponent=!0;const EEp={toc:[]},OEp="wrapper";function FEp(t){let{components:e,...n}=t;return(0,s.kt)(OEp,(0,p.Z)({},EEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}FEp.isMDXComponent=!0;const UEp={toc:[]},VEp="wrapper";function qEp(t){let{components:e,...n}=t;return(0,s.kt)(VEp,(0,p.Z)({},UEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qEp.isMDXComponent=!0;const jEp={toc:[]},YEp="wrapper";function QEp(t){let{components:e,...n}=t;return(0,s.kt)(YEp,(0,p.Z)({},jEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}QEp.isMDXComponent=!0;const HEp={toc:[]},KEp="wrapper";function $Ep(t){let{components:e,...n}=t;return(0,s.kt)(KEp,(0,p.Z)({},HEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/SplineProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}$Ep.isMDXComponent=!0;const JEp={toc:[]},tOp="wrapper";function eOp(t){let{components:e,...n}=t;return(0,s.kt)(tOp,(0,p.Z)({},JEp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}eOp.isMDXComponent=!0;const nOp={toc:[]},oOp="wrapper";function pOp(t){let{components:e,...n}=t;return(0,s.kt)(oOp,(0,p.Z)({},nOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pOp.isMDXComponent=!0;const rOp={toc:[]},sOp="wrapper";function cOp(t){let{components:e,...n}=t;return(0,s.kt)(sOp,(0,p.Z)({},rOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}cOp.isMDXComponent=!0;const aOp={toc:[]},iOp="wrapper";function lOp(t){let{components:e,...n}=t;return(0,s.kt)(iOp,(0,p.Z)({},aOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}lOp.isMDXComponent=!0;const uOp={toc:[]},mOp="wrapper";function dOp(t){let{components:e,...n}=t;return(0,s.kt)(mOp,(0,p.Z)({},uOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}dOp.isMDXComponent=!0;const hOp={toc:[]},fOp="wrapper";function kOp(t){let{components:e,...n}=t;return(0,s.kt)(fOp,(0,p.Z)({},hOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kOp.isMDXComponent=!0;const yOp={toc:[]},DOp="wrapper";function MOp(t){let{components:e,...n}=t;return(0,s.kt)(DOp,(0,p.Z)({},yOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}MOp.isMDXComponent=!0;const XOp={toc:[]},_Op="wrapper";function wOp(t){let{components:e,...n}=t;return(0,s.kt)(_Op,(0,p.Z)({},XOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wOp.isMDXComponent=!0;const TOp={toc:[]},COp="wrapper";function xOp(t){let{components:e,...n}=t;return(0,s.kt)(COp,(0,p.Z)({},TOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}xOp.isMDXComponent=!0;const gOp={toc:[]},vOp="wrapper";function LOp(t){let{components:e,...n}=t;return(0,s.kt)(vOp,(0,p.Z)({},gOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LOp.isMDXComponent=!0;const ZOp={toc:[]},bOp="wrapper";function NOp(t){let{components:e,...n}=t;return(0,s.kt)(bOp,(0,p.Z)({},ZOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}NOp.isMDXComponent=!0;const zOp={toc:[]},AOp="wrapper";function POp(t){let{components:e,...n}=t;return(0,s.kt)(AOp,(0,p.Z)({},zOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}POp.isMDXComponent=!0;const WOp={toc:[]},ROp="wrapper";function IOp(t){let{components:e,...n}=t;return(0,s.kt)(ROp,(0,p.Z)({},WOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}IOp.isMDXComponent=!0;const SOp={toc:[]},BOp="wrapper";function GOp(t){let{components:e,...n}=t;return(0,s.kt)(BOp,(0,p.Z)({},SOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}GOp.isMDXComponent=!0;const EOp={toc:[]},OOp="wrapper";function FOp(t){let{components:e,...n}=t;return(0,s.kt)(OOp,(0,p.Z)({},EOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}FOp.isMDXComponent=!0;const UOp={toc:[]},VOp="wrapper";function qOp(t){let{components:e,...n}=t;return(0,s.kt)(VOp,(0,p.Z)({},UOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}qOp.isMDXComponent=!0;const jOp={toc:[]},YOp="wrapper";function QOp(t){let{components:e,...n}=t;return(0,s.kt)(YOp,(0,p.Z)({},jOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}QOp.isMDXComponent=!0;const HOp={toc:[]},KOp="wrapper";function $Op(t){let{components:e,...n}=t;return(0,s.kt)(KOp,(0,p.Z)({},HOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}$Op.isMDXComponent=!0;const JOp={toc:[]},tFp="wrapper";function eFp(t){let{components:e,...n}=t;return(0,s.kt)(tFp,(0,p.Z)({},JOp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}eFp.isMDXComponent=!0;const nFp={toc:[]},oFp="wrapper";function pFp(t){let{components:e,...n}=t;return(0,s.kt)(oFp,(0,p.Z)({},nFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}pFp.isMDXComponent=!0;const rFp={toc:[]},sFp="wrapper";function cFp(t){let{components:e,...n}=t;return(0,s.kt)(sFp,(0,p.Z)({},rFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}cFp.isMDXComponent=!0;const aFp={toc:[]},iFp="wrapper";function lFp(t){let{components:e,...n}=t;return(0,s.kt)(iFp,(0,p.Z)({},aFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}lFp.isMDXComponent=!0;const uFp={toc:[]},mFp="wrapper";function dFp(t){let{components:e,...n}=t;return(0,s.kt)(mFp,(0,p.Z)({},uFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}dFp.isMDXComponent=!0;const hFp={toc:[]},fFp="wrapper";function kFp(t){let{components:e,...n}=t;return(0,s.kt)(fFp,(0,p.Z)({},hFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kFp.isMDXComponent=!0;const yFp={toc:[]},DFp="wrapper";function MFp(t){let{components:e,...n}=t;return(0,s.kt)(DFp,(0,p.Z)({},yFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}MFp.isMDXComponent=!0;const XFp={toc:[]},_Fp="wrapper";function wFp(t){let{components:e,...n}=t;return(0,s.kt)(_Fp,(0,p.Z)({},XFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}wFp.isMDXComponent=!0;const TFp={toc:[]},CFp="wrapper";function xFp(t){let{components:e,...n}=t;return(0,s.kt)(CFp,(0,p.Z)({},TFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}xFp.isMDXComponent=!0;const gFp={toc:[]},vFp="wrapper";function LFp(t){let{components:e,...n}=t;return(0,s.kt)(vFp,(0,p.Z)({},gFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}LFp.isMDXComponent=!0;const ZFp={toc:[]},bFp="wrapper";function NFp(t){let{components:e,...n}=t;return(0,s.kt)(bFp,(0,p.Z)({},ZFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}NFp.isMDXComponent=!0;const zFp={toc:[]},AFp="wrapper";function PFp(t){let{components:e,...n}=t;return(0,s.kt)(AFp,(0,p.Z)({},zFp,n,{components:e,mdxType:"MDXLayout"}))}PFp.isMDXComponent=!0;const WFp={toc:[]},RFp="wrapper";function IFp(t){let{components:e,...n}=t;return(0,s.kt)(RFp,(0,p.Z)({},WFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/TxtProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}IFp.isMDXComponent=!0;const SFp={toc:[]},BFp="wrapper";function GFp(t){let{components:e,...n}=t;return(0,s.kt)(BFp,(0,p.Z)({},SFp,n,{components:e,mdxType:"MDXLayout"}))}GFp.isMDXComponent=!0;const EFp={toc:[]},OFp="wrapper";function FFp(t){let{components:e,...n}=t;return(0,s.kt)(OFp,(0,p.Z)({},EFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FFp.isMDXComponent=!0;const UFp={toc:[]},VFp="wrapper";function qFp(t){let{components:e,...n}=t;return(0,s.kt)(VFp,(0,p.Z)({},UFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}qFp.isMDXComponent=!0;const jFp={toc:[]},YFp="wrapper";function QFp(t){let{components:e,...n}=t;return(0,s.kt)(YFp,(0,p.Z)({},jFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}QFp.isMDXComponent=!0;const HFp={toc:[]},KFp="wrapper";function $Fp(t){let{components:e,...n}=t;return(0,s.kt)(KFp,(0,p.Z)({},HFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}$Fp.isMDXComponent=!0;const JFp={toc:[]},tUp="wrapper";function eUp(t){let{components:e,...n}=t;return(0,s.kt)(tUp,(0,p.Z)({},JFp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}eUp.isMDXComponent=!0;const nUp={toc:[]},oUp="wrapper";function pUp(t){let{components:e,...n}=t;return(0,s.kt)(oUp,(0,p.Z)({},nUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}pUp.isMDXComponent=!0;const rUp={toc:[]},sUp="wrapper";function cUp(t){let{components:e,...n}=t;return(0,s.kt)(sUp,(0,p.Z)({},rUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Unlike opacity, the alpha value affects only the video itself, leaving the\nfill, stroke, and children intact."))}cUp.isMDXComponent=!0;const aUp={toc:[]},iUp="wrapper";function lUp(t){let{components:e,...n}=t;return(0,s.kt)(iUp,(0,p.Z)({},aUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The alpha value of this video."))}lUp.isMDXComponent=!0;const uUp={toc:[]},mUp="wrapper";function dUp(t){let{components:e,...n}=t;return(0,s.kt)(mUp,(0,p.Z)({},uUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}dUp.isMDXComponent=!0;const hUp={toc:[]},fUp="wrapper";function kUp(t){let{components:e,...n}=t;return(0,s.kt)(fUp,(0,p.Z)({},hUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}kUp.isMDXComponent=!0;const yUp={toc:[]},DUp="wrapper";function MUp(t){let{components:e,...n}=t;return(0,s.kt)(DUp,(0,p.Z)({},yUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MUp.isMDXComponent=!0;const XUp={toc:[]},_Up="wrapper";function wUp(t){let{components:e,...n}=t;return(0,s.kt)(_Up,(0,p.Z)({},XUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}wUp.isMDXComponent=!0;const TUp={toc:[]},CUp="wrapper";function xUp(t){let{components:e,...n}=t;return(0,s.kt)(CUp,(0,p.Z)({},TUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}xUp.isMDXComponent=!0;const gUp={toc:[]},vUp="wrapper";function LUp(t){let{components:e,...n}=t;return(0,s.kt)(vUp,(0,p.Z)({},gUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}LUp.isMDXComponent=!0;const ZUp={toc:[]},bUp="wrapper";function NUp(t){let{components:e,...n}=t;return(0,s.kt)(bUp,(0,p.Z)({},ZUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}NUp.isMDXComponent=!0;const zUp={toc:[]},AUp="wrapper";function PUp(t){let{components:e,...n}=t;return(0,s.kt)(AUp,(0,p.Z)({},zUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}PUp.isMDXComponent=!0;const WUp={toc:[]},RUp="wrapper";function IUp(t){let{components:e,...n}=t;return(0,s.kt)(RUp,(0,p.Z)({},WUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}IUp.isMDXComponent=!0;const SUp={toc:[]},BUp="wrapper";function GUp(t){let{components:e,...n}=t;return(0,s.kt)(BUp,(0,p.Z)({},SUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}GUp.isMDXComponent=!0;const EUp={toc:[]},OUp="wrapper";function FUp(t){let{components:e,...n}=t;return(0,s.kt)(OUp,(0,p.Z)({},EUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}FUp.isMDXComponent=!0;const UUp={toc:[]},VUp="wrapper";function qUp(t){let{components:e,...n}=t;return(0,s.kt)(VUp,(0,p.Z)({},UUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}qUp.isMDXComponent=!0;const jUp={toc:[]},YUp="wrapper";function QUp(t){let{components:e,...n}=t;return(0,s.kt)(YUp,(0,p.Z)({},jUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}QUp.isMDXComponent=!0;const HUp={toc:[]},KUp="wrapper";function $Up(t){let{components:e,...n}=t;return(0,s.kt)(KUp,(0,p.Z)({},HUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}$Up.isMDXComponent=!0;const JUp={toc:[]},tVp="wrapper";function eVp(t){let{components:e,...n}=t;return(0,s.kt)(tVp,(0,p.Z)({},JUp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}eVp.isMDXComponent=!0;const nVp={toc:[]},oVp="wrapper";function pVp(t){let{components:e,...n}=t;return(0,s.kt)(oVp,(0,p.Z)({},nVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}pVp.isMDXComponent=!0;const rVp={toc:[]},sVp="wrapper";function cVp(t){let{components:e,...n}=t;return(0,s.kt)(sVp,(0,p.Z)({},rVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}cVp.isMDXComponent=!0;const aVp={toc:[]},iVp="wrapper";function lVp(t){let{components:e,...n}=t;return(0,s.kt)(iVp,(0,p.Z)({},aVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}lVp.isMDXComponent=!0;const uVp={toc:[]},mVp="wrapper";function dVp(t){let{components:e,...n}=t;return(0,s.kt)(mVp,(0,p.Z)({},uVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}dVp.isMDXComponent=!0;const hVp={toc:[]},fVp="wrapper";function kVp(t){let{components:e,...n}=t;return(0,s.kt)(fVp,(0,p.Z)({},hVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}kVp.isMDXComponent=!0;const yVp={toc:[]},DVp="wrapper";function MVp(t){let{components:e,...n}=t;return(0,s.kt)(DVp,(0,p.Z)({},yVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}MVp.isMDXComponent=!0;const XVp={toc:[]},_Vp="wrapper";function wVp(t){let{components:e,...n}=t;return(0,s.kt)(_Vp,(0,p.Z)({},XVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}wVp.isMDXComponent=!0;const TVp={toc:[]},CVp="wrapper";function xVp(t){let{components:e,...n}=t;return(0,s.kt)(CVp,(0,p.Z)({},TVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}xVp.isMDXComponent=!0;const gVp={toc:[]},vVp="wrapper";function LVp(t){let{components:e,...n}=t;return(0,s.kt)(vVp,(0,p.Z)({},gVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}LVp.isMDXComponent=!0;const ZVp={toc:[]},bVp="wrapper";function NVp(t){let{components:e,...n}=t;return(0,s.kt)(bVp,(0,p.Z)({},ZVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}NVp.isMDXComponent=!0;const zVp={toc:[]},AVp="wrapper";function PVp(t){let{components:e,...n}=t;return(0,s.kt)(AVp,(0,p.Z)({},zVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}PVp.isMDXComponent=!0;const WVp={toc:[]},RVp="wrapper";function IVp(t){let{components:e,...n}=t;return(0,s.kt)(RVp,(0,p.Z)({},WVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}IVp.isMDXComponent=!0;const SVp={toc:[]},BVp="wrapper";function GVp(t){let{components:e,...n}=t;return(0,s.kt)(BVp,(0,p.Z)({},SVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}GVp.isMDXComponent=!0;const EVp={toc:[]},OVp="wrapper";function FVp(t){let{components:e,...n}=t;return(0,s.kt)(OVp,(0,p.Z)({},EVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}FVp.isMDXComponent=!0;const UVp={toc:[]},VVp="wrapper";function qVp(t){let{components:e,...n}=t;return(0,s.kt)(VVp,(0,p.Z)({},UVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}qVp.isMDXComponent=!0;const jVp={toc:[]},YVp="wrapper";function QVp(t){let{components:e,...n}=t;return(0,s.kt)(YVp,(0,p.Z)({},jVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether this video should loop upon reaching the end."))}QVp.isMDXComponent=!0;const HVp={toc:[]},KVp="wrapper";function $Vp(t){let{components:e,...n}=t;return(0,s.kt)(KVp,(0,p.Z)({},HVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}$Vp.isMDXComponent=!0;const JVp={toc:[]},tqp="wrapper";function eqp(t){let{components:e,...n}=t;return(0,s.kt)(tqp,(0,p.Z)({},JVp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}eqp.isMDXComponent=!0;const nqp={toc:[]},oqp="wrapper";function pqp(t){let{components:e,...n}=t;return(0,s.kt)(oqp,(0,p.Z)({},nqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The rate at which the video plays, as multiples of the normal speed."))}pqp.isMDXComponent=!0;const rqp={toc:[]},sqp="wrapper";function cqp(t){let{components:e,...n}=t;return(0,s.kt)(sqp,(0,p.Z)({},rqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}cqp.isMDXComponent=!0;const aqp={toc:[]},iqp="wrapper";function lqp(t){let{components:e,...n}=t;return(0,s.kt)(iqp,(0,p.Z)({},aqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}lqp.isMDXComponent=!0;const uqp={toc:[]},mqp="wrapper";function dqp(t){let{components:e,...n}=t;return(0,s.kt)(mqp,(0,p.Z)({},uqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dqp.isMDXComponent=!0;const hqp={toc:[]},fqp="wrapper";function kqp(t){let{components:e,...n}=t;return(0,s.kt)(fqp,(0,p.Z)({},hqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}kqp.isMDXComponent=!0;const yqp={toc:[]},Dqp="wrapper";function Mqp(t){let{components:e,...n}=t;return(0,s.kt)(Dqp,(0,p.Z)({},yqp,n,{components:e,mdxType:"MDXLayout"}))}Mqp.isMDXComponent=!0;const Xqp={toc:[]},_qp="wrapper";function wqp(t){let{components:e,...n}=t;return(0,s.kt)(_qp,(0,p.Z)({},Xqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}wqp.isMDXComponent=!0;const Tqp={toc:[]},Cqp="wrapper";function xqp(t){let{components:e,...n}=t;return(0,s.kt)(Cqp,(0,p.Z)({},Tqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}xqp.isMDXComponent=!0;const gqp={toc:[]},vqp="wrapper";function Lqp(t){let{components:e,...n}=t;return(0,s.kt)(vqp,(0,p.Z)({},gqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When disabled, the video will be scaled using the nearest neighbor\ninterpolation with no smoothing. The resulting video will appear pixelated."))}Lqp.isMDXComponent=!0;const Zqp={toc:[]},bqp="wrapper";function Nqp(t){let{components:e,...n}=t;return(0,s.kt)(bqp,(0,p.Z)({},Zqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the video should be smoothed."))}Nqp.isMDXComponent=!0;const zqp={toc:[]},Aqp="wrapper";function Pqp(t){let{components:e,...n}=t;return(0,s.kt)(Aqp,(0,p.Z)({},zqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}Pqp.isMDXComponent=!0;const Wqp={toc:[]},Rqp="wrapper";function Iqp(t){let{components:e,...n}=t;return(0,s.kt)(Rqp,(0,p.Z)({},Wqp,n,{components:e,mdxType:"MDXLayout"}))}Iqp.isMDXComponent=!0;const Sqp={toc:[]},Bqp="wrapper";function Gqp(t){let{components:e,...n}=t;return(0,s.kt)(Bqp,(0,p.Z)({},Sqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The source of this video."))}Gqp.isMDXComponent=!0;const Eqp={toc:[]},Oqp="wrapper";function Fqp(t){let{components:e,...n}=t;return(0,s.kt)(Oqp,(0,p.Z)({},Eqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}Fqp.isMDXComponent=!0;const Uqp={toc:[]},Vqp="wrapper";function qqp(t){let{components:e,...n}=t;return(0,s.kt)(Vqp,(0,p.Z)({},Uqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}qqp.isMDXComponent=!0;const jqp={toc:[]},Yqp="wrapper";function Qqp(t){let{components:e,...n}=t;return(0,s.kt)(Yqp,(0,p.Z)({},jqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}Qqp.isMDXComponent=!0;const Hqp={toc:[]},Kqp="wrapper";function $qp(t){let{components:e,...n}=t;return(0,s.kt)(Kqp,(0,p.Z)({},Hqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}$qp.isMDXComponent=!0;const Jqp={toc:[]},tjp="wrapper";function ejp(t){let{components:e,...n}=t;return(0,s.kt)(tjp,(0,p.Z)({},Jqp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/VideoProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}ejp.isMDXComponent=!0;const njp={toc:[]},ojp="wrapper";function pjp(t){let{components:e,...n}=t;return(0,s.kt)(ojp,(0,p.Z)({},njp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}pjp.isMDXComponent=!0;const rjp={toc:[]},sjp="wrapper";function cjp(t){let{components:e,...n}=t;return(0,s.kt)(sjp,(0,p.Z)({},rjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The starting time for this video in seconds."))}cjp.isMDXComponent=!0;const ajp={toc:[]},ijp="wrapper";function ljp(t){let{components:e,...n}=t;return(0,s.kt)(ijp,(0,p.Z)({},ajp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}ljp.isMDXComponent=!0;const ujp={toc:[]},mjp="wrapper";function djp(t){let{components:e,...n}=t;return(0,s.kt)(mjp,(0,p.Z)({},ujp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}djp.isMDXComponent=!0;const hjp={toc:[]},fjp="wrapper";function kjp(t){let{components:e,...n}=t;return(0,s.kt)(fjp,(0,p.Z)({},hjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}kjp.isMDXComponent=!0;const yjp={toc:[]},Djp="wrapper";function Mjp(t){let{components:e,...n}=t;return(0,s.kt)(Djp,(0,p.Z)({},yjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}Mjp.isMDXComponent=!0;const Xjp={toc:[]},_jp="wrapper";function wjp(t){let{components:e,...n}=t;return(0,s.kt)(_jp,(0,p.Z)({},Xjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wjp.isMDXComponent=!0;const Tjp={toc:[]},Cjp="wrapper";function xjp(t){let{components:e,...n}=t;return(0,s.kt)(Cjp,(0,p.Z)({},Tjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}xjp.isMDXComponent=!0;const gjp={toc:[]},vjp="wrapper";function Ljp(t){let{components:e,...n}=t;return(0,s.kt)(vjp,(0,p.Z)({},gjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"To make the arrows visible make sure to enable ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"startArrow"))," and/or\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endArrow"},(0,s.kt)("inlineCode",{parentName:"a"},"endArrow")),"."))}Ljp.isMDXComponent=!0;const Zjp={toc:[]},bjp="wrapper";function Njp(t){let{components:e,...n}=t;return(0,s.kt)(bjp,(0,p.Z)({},Zjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the size of the end and start arrows."))}Njp.isMDXComponent=!0;const zjp={toc:[]},Ajp="wrapper";function Pjp(t){let{components:e,...n}=t;return(0,s.kt)(Ajp,(0,p.Z)({},zjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Pjp.isMDXComponent=!0;const Wjp={toc:[]},Rjp="wrapper";function Ijp(t){let{components:e,...n}=t;return(0,s.kt)(Rjp,(0,p.Z)({},Wjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom edge of this node."))}Ijp.isMDXComponent=!0;const Sjp={toc:[]},Bjp="wrapper";function Gjp(t){let{components:e,...n}=t;return(0,s.kt)(Bjp,(0,p.Z)({},Sjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}Gjp.isMDXComponent=!0;const Ejp={toc:[]},Ojp="wrapper";function Fjp(t){let{components:e,...n}=t;return(0,s.kt)(Ojp,(0,p.Z)({},Ejp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom left corner of this node."))}Fjp.isMDXComponent=!0;const Ujp={toc:[]},Vjp="wrapper";function qjp(t){let{components:e,...n}=t;return(0,s.kt)(Vjp,(0,p.Z)({},Ujp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the bottom\nright corner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}qjp.isMDXComponent=!0;const jjp={toc:[]},Yjp="wrapper";function Qjp(t){let{components:e,...n}=t;return(0,s.kt)(Yjp,(0,p.Z)({},jjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the bottom right corner of this node."))}Qjp.isMDXComponent=!0;const Hjp={toc:[]},Kjp="wrapper";function $jp(t){let{components:e,...n}=t;return(0,s.kt)(Kjp,(0,p.Z)({},Hjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}$jp.isMDXComponent=!0;const Jjp={toc:[]},tYp="wrapper";function eYp(t){let{components:e,...n}=t;return(0,s.kt)(tYp,(0,p.Z)({},Jjp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}eYp.isMDXComponent=!0;const nYp={toc:[]},oYp="wrapper";function pYp(t){let{components:e,...n}=t;return(0,s.kt)(oYp,(0,p.Z)({},nYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}pYp.isMDXComponent=!0;const rYp={toc:[]},sYp="wrapper";function cYp(t){let{components:e,...n}=t;return(0,s.kt)(sYp,(0,p.Z)({},rYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}cYp.isMDXComponent=!0;const aYp={toc:[]},iYp="wrapper";function lYp(t){let{components:e,...n}=t;return(0,s.kt)(iYp,(0,p.Z)({},aYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}lYp.isMDXComponent=!0;const uYp={toc:[]},mYp="wrapper";function dYp(t){let{components:e,...n}=t;return(0,s.kt)(mYp,(0,p.Z)({},uYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}dYp.isMDXComponent=!0;const hYp={toc:[]},fYp="wrapper";function kYp(t){let{components:e,...n}=t;return(0,s.kt)(fYp,(0,p.Z)({},hYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}kYp.isMDXComponent=!0;const yYp={toc:[]},DYp="wrapper";function MYp(t){let{components:e,...n}=t;return(0,s.kt)(DYp,(0,p.Z)({},yYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}MYp.isMDXComponent=!0;const XYp={toc:[]},_Yp="wrapper";function wYp(t){let{components:e,...n}=t;return(0,s.kt)(_Yp,(0,p.Z)({},XYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By default, the size of the cache is determined based on the bounding box\nof the node and its children. That includes effects such as stroke or\nshadow. This property can be used to expand the cache area further.\nUsually used to account for custom effects created by ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#shaders"},(0,s.kt)("inlineCode",{parentName:"a"},"shaders")),"."))}wYp.isMDXComponent=!0;const TYp={toc:[]},CYp="wrapper";function xYp(t){let{components:e,...n}=t;return(0,s.kt)(CYp,(0,p.Z)({},TYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the padding of the cached canvas used by this node."))}xYp.isMDXComponent=!0;const gYp={toc:[]},vYp="wrapper";function LYp(t){let{components:e,...n}=t;return(0,s.kt)(vYp,(0,p.Z)({},gYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Closed curves have their start and end points connected."))}LYp.isMDXComponent=!0;const ZYp={toc:[]},bYp="wrapper";function NYp(t){let{components:e,...n}=t;return(0,s.kt)(bYp,(0,p.Z)({},ZYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the curve should be closed."))}NYp.isMDXComponent=!0;const zYp={toc:[]},AYp="wrapper";function PYp(t){let{components:e,...n}=t;return(0,s.kt)(AYp,(0,p.Z)({},zYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"Requires ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners"))," to be enabled to have any effect.\nBy default, corner sharpness is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0.6")," which represents a smooth,\ncircle-like rounding. At ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," the edges are squared off."))}PYp.isMDXComponent=!0;const WYp={toc:[]},RYp="wrapper";function IYp(t){let{components:e,...n}=t;return(0,s.kt)(RYp,(0,p.Z)({},WYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Controls the sharpness of ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#smoothCorners"},(0,s.kt)("inlineCode",{parentName:"a"},"smoothCorners")),"."))}IYp.isMDXComponent=!0;const SYp={toc:[]},BYp="wrapper";function GYp(t){let{components:e,...n}=t;return(0,s.kt)(BYp,(0,p.Z)({},SYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes after the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}GYp.isMDXComponent=!0;const EYp={toc:[]},OYp="wrapper";function FYp(t){let{components:e,...n}=t;return(0,s.kt)(OYp,(0,p.Z)({},EYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start after which the curve should be clipped."))}FYp.isMDXComponent=!0;const UYp={toc:[]},VYp="wrapper";function qYp(t){let{components:e,...n}=t;return(0,s.kt)(VYp,(0,p.Z)({},UYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}qYp.isMDXComponent=!0;const jYp={toc:[]},YYp="wrapper";function QYp(t){let{components:e,...n}=t;return(0,s.kt)(YYp,(0,p.Z)({},jYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the end of the visible curve."))}QYp.isMDXComponent=!0;const HYp={toc:[]},KYp="wrapper";function $Yp(t){let{components:e,...n}=t;return(0,s.kt)(KYp,(0,p.Z)({},HYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion ends. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the last\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#end"},(0,s.kt)("inlineCode",{parentName:"a"},"end")),"\ninstead."))}$Yp.isMDXComponent=!0;const JYp={toc:[]},tQp="wrapper";function eQp(t){let{components:e,...n}=t;return(0,s.kt)(tQp,(0,p.Z)({},JYp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the end of the curve."))}eQp.isMDXComponent=!0;const nQp={toc:[]},oQp="wrapper";function pQp(t){let{components:e,...n}=t;return(0,s.kt)(oQp,(0,p.Z)({},nQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the left edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}pQp.isMDXComponent=!0;const rQp={toc:[]},sQp="wrapper";function cQp(t){let{components:e,...n}=t;return(0,s.kt)(sQp,(0,p.Z)({},rQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the left edge of this node."))}cQp.isMDXComponent=!0;const aQp={toc:[]},iQp="wrapper";function lQp(t){let{components:e,...n}=t;return(0,s.kt)(iQp,(0,p.Z)({},aQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the center ends\nup in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property.\nWhen ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#offset"},(0,s.kt)("inlineCode",{parentName:"a"},"offset"))," is not set, this will be the same as the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position")),"."))}lQp.isMDXComponent=!0;const uQp={toc:[]},mQp="wrapper";function dQp(t){let{components:e,...n}=t;return(0,s.kt)(mQp,(0,p.Z)({},uQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the center of this node."))}dQp.isMDXComponent=!0;const hQp={toc:[]},fQp="wrapper";function kQp(t){let{components:e,...n}=t;return(0,s.kt)(fQp,(0,p.Z)({},hQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value represents the radius of the quarter circle that is used to round\nthe corners. If the value is a number, the same radius is used for all\ncorners. Passing an array of two to four numbers will set individual radii\nfor each corner. Individual radii correspond to different corners depending\non the number of values passed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// top-left-and-bottom-right | top-right-and-bottom-left\n[10, 30]\n// top-left | top-right-and-bottom-left | bottom-right\n[10, 20, 30]\n// top-left | top-right | bottom-right | bottom-left\n[10, 20, 30, 40]\n")))}kQp.isMDXComponent=!0;const yQp={toc:[]},DQp="wrapper";function MQp(t){let{components:e,...n}=t;return(0,s.kt)(DQp,(0,p.Z)({},yQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Rounds the corners of this rectangle."))}MQp.isMDXComponent=!0;const XQp={toc:[]},_Qp="wrapper";function wQp(t){let{components:e,...n}=t;return(0,s.kt)(_Qp,(0,p.Z)({},XQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the right edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}wQp.isMDXComponent=!0;const TQp={toc:[]},CQp="wrapper";function xQp(t){let{components:e,...n}=t;return(0,s.kt)(CQp,(0,p.Z)({},TQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the right edge of this node."))}xQp.isMDXComponent=!0;const gQp={toc:[]},vQp="wrapper";function LQp(t){let{components:e,...n}=t;return(0,s.kt)(vQp,(0,p.Z)({},gQp,n,{components:e,mdxType:"MDXLayout"}))}LQp.isMDXComponent=!0;const ZQp={toc:[]},bQp="wrapper";function NQp(t){let{components:e,...n}=t;return(0,s.kt)(bQp,(0,p.Z)({},ZQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property only affects the way rounded corners are drawn. To control\nthe corner radius use the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#radius"},(0,s.kt)("inlineCode",{parentName:"a"},"radius"))," property."),(0,s.kt)("p",null,"When enabled, rounded corners are drawn continuously using B\xe9zier curves\nrather than quarter circles. The sharpness of the curve can be controlled\nwith ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#cornerSharpness"},(0,s.kt)("inlineCode",{parentName:"a"},"cornerSharpness")),"."),(0,s.kt)("p",null,"You can read more about corner smoothing in\n",(0,s.kt)("a",{parentName:"p",href:"https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48"},"this article by Nick Lawrence"),"."))}NQp.isMDXComponent=!0;const zQp={toc:[]},AQp="wrapper";function PQp(t){let{components:e,...n}=t;return(0,s.kt)(AQp,(0,p.Z)({},zQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Enables corner smoothing."))}PQp.isMDXComponent=!0;const WQp={toc:[]},RQp="wrapper";function IQp(t){let{components:e,...n}=t;return(0,s.kt)(RQp,(0,p.Z)({},WQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#children"},(0,s.kt)("inlineCode",{parentName:"a"},"children"))," instead."))}IQp.isMDXComponent=!0;const SQp={toc:[]},BQp="wrapper";function GQp(t){let{components:e,...n}=t;return(0,s.kt)(BQp,(0,p.Z)({},SQp,n,{components:e,mdxType:"MDXLayout"}))}GQp.isMDXComponent=!0;const EQp={toc:[]},OQp="wrapper";function FQp(t){let{components:e,...n}=t;return(0,s.kt)(OQp,(0,p.Z)({},EQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The portion of the curve that comes before the given percentage will be\nmade invisible."),(0,s.kt)("p",null,"This property is usefully for animating the curve appearing on the screen.\nThe value of ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," means the very start of the curve (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#startOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"startOffset")),") while ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," means the very end (accounting for the\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#endOffset"},(0,s.kt)("inlineCode",{parentName:"a"},"endOffset")),")."))}FQp.isMDXComponent=!0;const UQp={toc:[]},VQp="wrapper";function qQp(t){let{components:e,...n}=t;return(0,s.kt)(VQp,(0,p.Z)({},UQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A percentage from the start before which the curve should be clipped."))}qQp.isMDXComponent=!0;const jQp={toc:[]},YQp="wrapper";function QQp(t){let{components:e,...n}=t;return(0,s.kt)(YQp,(0,p.Z)({},jQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#arrowSize"},(0,s.kt)("inlineCode",{parentName:"a"},"arrowSize"))," to control the size of the arrow."))}QQp.isMDXComponent=!0;const HQp={toc:[]},KQp="wrapper";function $Qp(t){let{components:e,...n}=t;return(0,s.kt)(KQp,(0,p.Z)({},HQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether to display an arrow at the start of the visible curve."))}$Qp.isMDXComponent=!0;const JQp={toc:[]},tHp="wrapper";function eHp(t){let{components:e,...n}=t;return(0,s.kt)(tHp,(0,p.Z)({},JQp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This property lets you specify where along the defined curve the actual\nvisible portion starts. For example, setting it to ",(0,s.kt)("inlineCode",{parentName:"p"},"20")," will make the first\n20 pixels of the curve invisible."),(0,s.kt)("p",null,"This property is useful for trimming the curve using a fixed distance.\nIf you want to animate the curve appearing on the screen, use ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/View2DProps#start"},(0,s.kt)("inlineCode",{parentName:"a"},"start")),"\ninstead."))}eHp.isMDXComponent=!0;const nHp={toc:[]},oHp="wrapper";function pHp(t){let{components:e,...n}=t;return(0,s.kt)(oHp,(0,p.Z)({},nHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The offset in pixels from the start of the curve."))}pHp.isMDXComponent=!0;const rHp={toc:[]},sHp="wrapper";function cHp(t){let{components:e,...n}=t;return(0,s.kt)(sHp,(0,p.Z)({},rHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top edge\nends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}cHp.isMDXComponent=!0;const aHp={toc:[]},iHp="wrapper";function lHp(t){let{components:e,...n}=t;return(0,s.kt)(iHp,(0,p.Z)({},aHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top edge of this node."))}lHp.isMDXComponent=!0;const uHp={toc:[]},mHp="wrapper";function dHp(t){let{components:e,...n}=t;return(0,s.kt)(mHp,(0,p.Z)({},uHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top left\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}dHp.isMDXComponent=!0;const hHp={toc:[]},fHp="wrapper";function kHp(t){let{components:e,...n}=t;return(0,s.kt)(fHp,(0,p.Z)({},hHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top left corner of this node."))}kHp.isMDXComponent=!0;const yHp={toc:[]},DHp="wrapper";function MHp(t){let{components:e,...n}=t;return(0,s.kt)(DHp,(0,p.Z)({},yHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This shortcut property will set the node's position so that the top right\ncorner ends up in the given place.\nIf present, overrides the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/components/NodeProps#position"},(0,s.kt)("inlineCode",{parentName:"a"},"position"))," property."))}MHp.isMDXComponent=!0;const XHp={toc:[]},_Hp="wrapper";function wHp(t){let{components:e,...n}=t;return(0,s.kt)(_Hp,(0,p.Z)({},XHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The position of the top right corner of this node."))}wHp.isMDXComponent=!0;const THp={toc:[]},CHp="wrapper";function xHp(t){let{components:e,...n}=t;return(0,s.kt)(CHp,(0,p.Z)({},THp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a cubic B\xe9zier curve."))}xHp.isMDXComponent=!0;const gHp={toc:[]},vHp="wrapper";function LHp(t){let{components:e,...n}=t;return(0,s.kt)(vHp,(0,p.Z)({},gHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}LHp.isMDXComponent=!0;const ZHp={toc:[]},bHp="wrapper";function NHp(t){let{components:e,...n}=t;return(0,s.kt)(bHp,(0,p.Z)({},ZHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}NHp.isMDXComponent=!0;const zHp={toc:[]},AHp="wrapper";function PHp(t){let{components:e,...n}=t;return(0,s.kt)(AHp,(0,p.Z)({},zHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}PHp.isMDXComponent=!0;const WHp={toc:[]},RHp="wrapper";function IHp(t){let{components:e,...n}=t;return(0,s.kt)(RHp,(0,p.Z)({},WHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}IHp.isMDXComponent=!0;const SHp={toc:[]},BHp="wrapper";function GHp(t){let{components:e,...n}=t;return(0,s.kt)(BHp,(0,p.Z)({},SHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial."),(0,s.kt)("p",null,"Source code liberally taken from:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs"},"https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs")))}GHp.isMDXComponent=!0;const EHp={toc:[]},OHp="wrapper";function FHp(t){let{components:e,...n}=t;return(0,s.kt)(OHp,(0,p.Z)({},EHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}FHp.isMDXComponent=!0;const UHp={toc:[]},VHp="wrapper";function qHp(t){let{components:e,...n}=t;return(0,s.kt)(VHp,(0,p.Z)({},UHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}qHp.isMDXComponent=!0;const jHp={toc:[]},YHp="wrapper";function QHp(t){let{components:e,...n}=t;return(0,s.kt)(YHp,(0,p.Z)({},jHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}QHp.isMDXComponent=!0;const HHp={toc:[]},KHp="wrapper";function $Hp(t){let{components:e,...n}=t;return(0,s.kt)(KHp,(0,p.Z)({},HHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}$Hp.isMDXComponent=!0;const JHp={toc:[]},tKp="wrapper";function eKp(t){let{components:e,...n}=t;return(0,s.kt)(tKp,(0,p.Z)({},JHp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}eKp.isMDXComponent=!0;const nKp={toc:[]},oKp="wrapper";function pKp(t){let{components:e,...n}=t;return(0,s.kt)(oKp,(0,p.Z)({},nKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}pKp.isMDXComponent=!0;const rKp={toc:[]},sKp="wrapper";function cKp(t){let{components:e,...n}=t;return(0,s.kt)(sKp,(0,p.Z)({},rKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}cKp.isMDXComponent=!0;const aKp={toc:[]},iKp="wrapper";function lKp(t){let{components:e,...n}=t;return(0,s.kt)(iKp,(0,p.Z)({},aKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}lKp.isMDXComponent=!0;const uKp={toc:[]},mKp="wrapper";function dKp(t){let{components:e,...n}=t;return(0,s.kt)(mKp,(0,p.Z)({},uKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}dKp.isMDXComponent=!0;const hKp={toc:[]},fKp="wrapper";function kKp(t){let{components:e,...n}=t;return(0,s.kt)(fKp,(0,p.Z)({},hKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}kKp.isMDXComponent=!0;const yKp={toc:[]},DKp="wrapper";function MKp(t){let{components:e,...n}=t;return(0,s.kt)(DKp,(0,p.Z)({},yKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The degree of the polynomial"))}MKp.isMDXComponent=!0;const XKp={toc:[]},_Kp="wrapper";function wKp(t){let{components:e,...n}=t;return(0,s.kt)(_Kp,(0,p.Z)({},XKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the nth derivative of the polynomial."))}wKp.isMDXComponent=!0;const TKp={toc:[]},CKp="wrapper";function xKp(t){let{components:e,...n}=t;return(0,s.kt)(CKp,(0,p.Z)({},TKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The number of times to differentiate the polynomial."))}xKp.isMDXComponent=!0;const gKp={toc:[]},vKp="wrapper";function LKp(t){let{components:e,...n}=t;return(0,s.kt)(vKp,(0,p.Z)({},gKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given value t."))}LKp.isMDXComponent=!0;const ZKp={toc:[]},bKp="wrapper";function NKp(t){let{components:e,...n}=t;return(0,s.kt)(bKp,(0,p.Z)({},ZKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}NKp.isMDXComponent=!0;const zKp={toc:[]},AKp="wrapper";function PKp(t){let{components:e,...n}=t;return(0,s.kt)(AKp,(0,p.Z)({},zKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the nth derivative of the polynomial at the given value t."))}PKp.isMDXComponent=!0;const WKp={toc:[]},RKp="wrapper";function IKp(t){let{components:e,...n}=t;return(0,s.kt)(RKp,(0,p.Z)({},WKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value to sample at"))}IKp.isMDXComponent=!0;const SKp={toc:[]},BKp="wrapper";function GKp(t){let{components:e,...n}=t;return(0,s.kt)(BKp,(0,p.Z)({},SKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The derivative of the polynomial to sample from"))}GKp.isMDXComponent=!0;const EKp={toc:[]},OKp="wrapper";function FKp(t){let{components:e,...n}=t;return(0,s.kt)(OKp,(0,p.Z)({},EKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial."))}FKp.isMDXComponent=!0;const UKp={toc:[]},VKp="wrapper";function qKp(t){let{components:e,...n}=t;return(0,s.kt)(VKp,(0,p.Z)({},UKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the local extrema of the polynomial in the unit interval."))}qKp.isMDXComponent=!0;const jKp={toc:[]},YKp="wrapper";function QKp(t){let{components:e,...n}=t;return(0,s.kt)(YKp,(0,p.Z)({},jKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the output value range within the unit interval."))}QKp.isMDXComponent=!0;const HKp={toc:[]},KKp="wrapper";function $Kp(t){let{components:e,...n}=t;return(0,s.kt)(KKp,(0,p.Z)({},HKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Depending on the degree of the polynomial, returns between 0 and 3 results."))}$Kp.isMDXComponent=!0;const JKp={toc:[]},t$p="wrapper";function e$p(t){let{components:e,...n}=t;return(0,s.kt)(t$p,(0,p.Z)({},JKp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the roots (values where this polynomial = 0)."))}e$p.isMDXComponent=!0;const n$p={toc:[]},o$p="wrapper";function p$p(t){let{components:e,...n}=t;return(0,s.kt)(o$p,(0,p.Z)({},n$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Split the polynomial into two polynomials of the same overall shape."))}p$p.isMDXComponent=!0;const r$p={toc:[]},s$p="wrapper";function c$p(t){let{components:e,...n}=t;return(0,s.kt)(s$p,(0,p.Z)({},r$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The point at which to split the polynomial."))}c$p.isMDXComponent=!0;const a$p={toc:[]},i$p="wrapper";function l$p(t){let{components:e,...n}=t;return(0,s.kt)(i$p,(0,p.Z)({},a$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a constant polynomial"))}l$p.isMDXComponent=!0;const u$p={toc:[]},m$p="wrapper";function d$p(t){let{components:e,...n}=t;return(0,s.kt)(m$p,(0,p.Z)({},u$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}d$p.isMDXComponent=!0;const h$p={toc:[]},f$p="wrapper";function k$p(t){let{components:e,...n}=t;return(0,s.kt)(f$p,(0,p.Z)({},h$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a cubic polynomial"))}k$p.isMDXComponent=!0;const y$p={toc:[]},D$p="wrapper";function M$p(t){let{components:e,...n}=t;return(0,s.kt)(D$p,(0,p.Z)({},y$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}M$p.isMDXComponent=!0;const X$p={toc:[]},_$p="wrapper";function w$p(t){let{components:e,...n}=t;return(0,s.kt)(_$p,(0,p.Z)({},X$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}w$p.isMDXComponent=!0;const T$p={toc:[]},C$p="wrapper";function x$p(t){let{components:e,...n}=t;return(0,s.kt)(C$p,(0,p.Z)({},T$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}x$p.isMDXComponent=!0;const g$p={toc:[]},v$p="wrapper";function L$p(t){let{components:e,...n}=t;return(0,s.kt)(v$p,(0,p.Z)({},g$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The cubic coefficient"))}L$p.isMDXComponent=!0;const Z$p={toc:[]},b$p="wrapper";function N$p(t){let{components:e,...n}=t;return(0,s.kt)(b$p,(0,p.Z)({},Z$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a linear polynomial"))}N$p.isMDXComponent=!0;const z$p={toc:[]},A$p="wrapper";function P$p(t){let{components:e,...n}=t;return(0,s.kt)(A$p,(0,p.Z)({},z$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}P$p.isMDXComponent=!0;const W$p={toc:[]},R$p="wrapper";function I$p(t){let{components:e,...n}=t;return(0,s.kt)(R$p,(0,p.Z)({},W$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}I$p.isMDXComponent=!0;const S$p={toc:[]},B$p="wrapper";function G$p(t){let{components:e,...n}=t;return(0,s.kt)(B$p,(0,p.Z)({},S$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constructs a quadratic polynomial"))}G$p.isMDXComponent=!0;const E$p={toc:[]},O$p="wrapper";function F$p(t){let{components:e,...n}=t;return(0,s.kt)(O$p,(0,p.Z)({},E$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The constant coefficient"))}F$p.isMDXComponent=!0;const U$p={toc:[]},V$p="wrapper";function q$p(t){let{components:e,...n}=t;return(0,s.kt)(V$p,(0,p.Z)({},U$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The linear coefficient"))}q$p.isMDXComponent=!0;const j$p={toc:[]},Y$p="wrapper";function Q$p(t){let{components:e,...n}=t;return(0,s.kt)(Y$p,(0,p.Z)({},j$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The quadratic coefficient"))}Q$p.isMDXComponent=!0;const H$p={toc:[]},K$p="wrapper";function $$p(t){let{components:e,...n}=t;return(0,s.kt)(K$p,(0,p.Z)({},H$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the tight axis-aligned bounds of the curve in the unit interval."))}$$p.isMDXComponent=!0;const J$p={toc:[]},tJp="wrapper";function eJp(t){let{components:e,...n}=t;return(0,s.kt)(tJp,(0,p.Z)({},J$p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A spline segment representing a quadratic B\xe9zier curve."))}eJp.isMDXComponent=!0;const nJp={toc:[]},oJp="wrapper";function pJp(t){let{components:e,...n}=t;return(0,s.kt)(oJp,(0,p.Z)({},nJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Evaluate the polynomial at the given t value."))}pJp.isMDXComponent=!0;const rJp={toc:[]},sJp="wrapper";function cJp(t){let{components:e,...n}=t;return(0,s.kt)(sJp,(0,p.Z)({},rJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}cJp.isMDXComponent=!0;const aJp={toc:[]},iJp="wrapper";function lJp(t){let{components:e,...n}=t;return(0,s.kt)(iJp,(0,p.Z)({},aJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Return the tangent of the point that sits at the provided t value on the\ncurve."))}lJp.isMDXComponent=!0;const uJp={toc:[]},mJp="wrapper";function dJp(t){let{components:e,...n}=t;return(0,s.kt)(mJp,(0,p.Z)({},uJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The t value at which to evaluate the curve."))}dJp.isMDXComponent=!0;const hJp={toc:[]},fJp="wrapper";function kJp(t){let{components:e,...n}=t;return(0,s.kt)(fJp,(0,p.Z)({},hJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The tangent is currently inconsistent for different types of curves and may\nsometimes return the normal of the point, instead. This will be fixed in\nthe next major version but is kept as is for now for backwards\ncompatibility reasons. To always get the real tangent of the point, you can\nuse ",(0,s.kt)("inlineCode",{parentName:"p"},"normal.flipped.perpendicular"),", instead."))}kJp.isMDXComponent=!0;const yJp={toc:[]},DJp="wrapper";function MJp(t){let{components:e,...n}=t;return(0,s.kt)(DJp,(0,p.Z)({},yJp,n,{components:e,mdxType:"MDXLayout"}))}MJp.isMDXComponent=!0;const XJp={toc:[]},_Jp="wrapper";function wJp(t){let{components:e,...n}=t;return(0,s.kt)(_Jp,(0,p.Z)({},XJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Calculate the curve profile of a spline based on a set of knots."))}wJp.isMDXComponent=!0;const TJp={toc:[]},CJp="wrapper";function xJp(t){let{components:e,...n}=t;return(0,s.kt)(CJp,(0,p.Z)({},TJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The knots defining the spline"))}xJp.isMDXComponent=!0;const gJp={toc:[]},vJp="wrapper";function LJp(t){let{components:e,...n}=t;return(0,s.kt)(vJp,(0,p.Z)({},gJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the spline should be closed or not"))}LJp.isMDXComponent=!0;const ZJp={toc:[]},bJp="wrapper";function NJp(t){let{components:e,...n}=t;return(0,s.kt)(bJp,(0,p.Z)({},ZJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The desired smoothness of the spline when using auto\ncalculated handles."))}NJp.isMDXComponent=!0;const zJp={toc:[]},AJp="wrapper";function PJp(t){let{components:e,...n}=t;return(0,s.kt)(AJp,(0,p.Z)({},zJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the initial value of this signal."))}PJp.isMDXComponent=!0;const WJp={toc:[]},RJp="wrapper";function IJp(t){let{components:e,...n}=t;return(0,s.kt)(RJp,(0,p.Z)({},WJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}IJp.isMDXComponent=!0;const SJp={toc:[]},BJp="wrapper";function GJp(t){let{components:e,...n}=t;return(0,s.kt)(BJp,(0,p.Z)({},SJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Check if the signal is currently using its initial value."))}GJp.isMDXComponent=!0;const EJp={toc:[]},OJp="wrapper";function FJp(t){let{components:e,...n}=t;return(0,s.kt)(OJp,(0,p.Z)({},EJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Is the signal undergoing a tween?"))}FJp.isMDXComponent=!0;const UJp={toc:[]},VJp="wrapper";function qJp(t){let{components:e,...n}=t;return(0,s.kt)(VJp,(0,p.Z)({},UJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,s.kt)("p",null,"This method can be used to create copies of signals."))}qJp.isMDXComponent=!0;const jJp={toc:[]},YJp="wrapper";function QJp(t){let{components:e,...n}=t;return(0,s.kt)(YJp,(0,p.Z)({},jJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}QJp.isMDXComponent=!0;const HJp={toc:[]},KJp="wrapper";function $Jp(t){let{components:e,...n}=t;return(0,s.kt)(KJp,(0,p.Z)({},HJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Get the raw value of this signal."))}$Jp.isMDXComponent=!0;const JJp={toc:[]},t0p="wrapper";function e0p(t){let{components:e,...n}=t;return(0,s.kt)(t0p,(0,p.Z)({},JJp,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}e0p.isMDXComponent=!0;const n0p={toc:[]},o0p="wrapper";function p0p(t){let{components:e,...n}=t;return(0,s.kt)(o0p,(0,p.Z)({},n0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}p0p.isMDXComponent=!0;const r0p={toc:[]},s0p="wrapper";function c0p(t){let{components:e,...n}=t;return(0,s.kt)(s0p,(0,p.Z)({},r0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}c0p.isMDXComponent=!0;const a0p={toc:[]},i0p="wrapper";function l0p(t){let{components:e,...n}=t;return(0,s.kt)(i0p,(0,p.Z)({},a0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}l0p.isMDXComponent=!0;const u0p={toc:[]},m0p="wrapper";function d0p(t){let{components:e,...n}=t;return(0,s.kt)(m0p,(0,p.Z)({},u0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Compute the current value of the signal and immediately set it."))}d0p.isMDXComponent=!0;const h0p={toc:[]},f0p="wrapper";function k0p(t){let{components:e,...n}=t;return(0,s.kt)(f0p,(0,p.Z)({},h0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,s.kt)("p",null,"By default, any property is cloneable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}k0p.isMDXComponent=!0;const y0p={toc:[]},D0p="wrapper";function M0p(t){let{components:e,...n}=t;return(0,s.kt)(D0p,(0,p.Z)({},y0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}M0p.isMDXComponent=!0;const X0p={toc:[]},_0p="wrapper";function w0p(t){let{components:e,...n}=t;return(0,s.kt)(_0p,(0,p.Z)({},X0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a cloneable property decorator."))}w0p.isMDXComponent=!0;const T0p={toc:[]},C0p="wrapper";function x0p(t){let{components:e,...n}=t;return(0,s.kt)(C0p,(0,p.Z)({},T0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be cloneable."))}x0p.isMDXComponent=!0;const g0p={toc:[]},v0p="wrapper";function L0p(t){let{components:e,...n}=t;return(0,s.kt)(v0p,(0,p.Z)({},g0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}L0p.isMDXComponent=!0;const Z0p={toc:[]},b0p="wrapper";function N0p(t){let{components:e,...n}=t;return(0,s.kt)(b0p,(0,p.Z)({},Z0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}N0p.isMDXComponent=!0;const z0p={toc:[]},A0p="wrapper";function P0p(t){let{components:e,...n}=t;return(0,s.kt)(A0p,(0,p.Z)({},z0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a compound property decorator."))}P0p.isMDXComponent=!0;const W0p={toc:[]},R0p="wrapper";function I0p(t){let{components:e,...n}=t;return(0,s.kt)(R0p,(0,p.Z)({},W0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}I0p.isMDXComponent=!0;const S0p={toc:[]},B0p="wrapper";function G0p(t){let{components:e,...n}=t;return(0,s.kt)(B0p,(0,p.Z)({},S0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,s.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,s.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}G0p.isMDXComponent=!0;const E0p={toc:[]},O0p="wrapper";function F0p(t){let{components:e,...n}=t;return(0,s.kt)(O0p,(0,p.Z)({},E0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a computed method decorator."))}F0p.isMDXComponent=!0;const U0p={toc:[]},V0p="wrapper";function q0p(t){let{components:e,...n}=t;return(0,s.kt)(V0p,(0,p.Z)({},U0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the initial value of a property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}q0p.isMDXComponent=!0;const j0p={toc:[]},Y0p="wrapper";function Q0p(t){let{components:e,...n}=t;return(0,s.kt)(Y0p,(0,p.Z)({},j0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}Q0p.isMDXComponent=!0;const H0p={toc:[]},K0p="wrapper";function $0p(t){let{components:e,...n}=t;return(0,s.kt)(K0p,(0,p.Z)({},H0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an initial signal value decorator."))}$0p.isMDXComponent=!0;const J0p={toc:[]},t4p="wrapper";function e4p(t){let{components:e,...n}=t;return(0,s.kt)(t4p,(0,p.Z)({},J0p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The initial value of the property."))}e4p.isMDXComponent=!0;const n4p={toc:[]},o4p="wrapper";function p4p(t){let{components:e,...n}=t;return(0,s.kt)(o4p,(0,p.Z)({},n4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,s.kt)("p",null,"By default, any property is inspectable."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}p4p.isMDXComponent=!0;const r4p={toc:[]},s4p="wrapper";function c4p(t){let{components:e,...n}=t;return(0,s.kt)(s4p,(0,p.Z)({},r4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}c4p.isMDXComponent=!0;const a4p={toc:[]},i4p="wrapper";function l4p(t){let{components:e,...n}=t;return(0,s.kt)(i4p,(0,p.Z)({},a4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an inspectable property decorator."))}l4p.isMDXComponent=!0;const u4p={toc:[]},m4p="wrapper";function d4p(t){let{components:e,...n}=t;return(0,s.kt)(m4p,(0,p.Z)({},u4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Whether the property should be inspectable."))}d4p.isMDXComponent=!0;const h4p={toc:[]},f4p="wrapper";function k4p(t){let{components:e,...n}=t;return(0,s.kt)(f4p,(0,p.Z)({},h4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}k4p.isMDXComponent=!0;const y4p={toc:[]},D4p="wrapper";function M4p(t){let{components:e,...n}=t;return(0,s.kt)(D4p,(0,p.Z)({},y4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}M4p.isMDXComponent=!0;const X4p={toc:[]},_4p="wrapper";function w4p(t){let{components:e,...n}=t;return(0,s.kt)(_4p,(0,p.Z)({},X4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal interpolation function decorator."))}w4p.isMDXComponent=!0;const T4p={toc:[]},C4p="wrapper";function x4p(t){let{components:e,...n}=t;return(0,s.kt)(C4p,(0,p.Z)({},T4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The interpolation function for the property."))}x4p.isMDXComponent=!0;const g4p={toc:[]},v4p="wrapper";function L4p(t){let{components:e,...n}=t;return(0,s.kt)(v4p,(0,p.Z)({},g4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,s.kt)("p",null,"If the wrapper class has a method called ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}L4p.isMDXComponent=!0;const Z4p={toc:[]},b4p="wrapper";function N4p(t){let{components:e,...n}=t;return(0,s.kt)(b4p,(0,p.Z)({},Z4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}N4p.isMDXComponent=!0;const z4p={toc:[]},A4p="wrapper";function P4p(t){let{components:e,...n}=t;return(0,s.kt)(A4p,(0,p.Z)({},z4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal parser decorator."))}P4p.isMDXComponent=!0;const W4p={toc:[]},R4p="wrapper";function I4p(t){let{components:e,...n}=t;return(0,s.kt)(R4p,(0,p.Z)({},W4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}I4p.isMDXComponent=!0;const S4p={toc:[]},B4p="wrapper";function G4p(t){let{components:e,...n}=t;return(0,s.kt)(B4p,(0,p.Z)({},S4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This decorator turns the given property into a signal."),(0,s.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}G4p.isMDXComponent=!0;const E4p={toc:[]},O4p="wrapper";function F4p(t){let{components:e,...n}=t;return(0,s.kt)(O4p,(0,p.Z)({},E4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}F4p.isMDXComponent=!0;const U4p={toc:[]},V4p="wrapper";function q4p(t){let{components:e,...n}=t;return(0,s.kt)(V4p,(0,p.Z)({},U4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal decorator."))}q4p.isMDXComponent=!0;const j4p={toc:[]},Y4p="wrapper";function Q4p(t){let{components:e,...n}=t;return(0,s.kt)(Y4p,(0,p.Z)({},j4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,s.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,s.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,s.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,s.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,s.kt)("p",null,"Must be specified before the ",(0,s.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,s.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Q4p.isMDXComponent=!0;const H4p={toc:[]},K4p="wrapper";function $4p(t){let{components:e,...n}=t;return(0,s.kt)(K4p,(0,p.Z)({},H4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}$4p.isMDXComponent=!0;const J4p={toc:[]},t6p="wrapper";function e6p(t){let{components:e,...n}=t;return(0,s.kt)(t6p,(0,p.Z)({},J4p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a signal wrapper decorator."))}e6p.isMDXComponent=!0;const n6p={toc:[]},o6p="wrapper";function p6p(t){let{components:e,...n}=t;return(0,s.kt)(o6p,(0,p.Z)({},n6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The wrapper class for the property."))}p6p.isMDXComponent=!0;const r6p={toc:[]},s6p="wrapper";function c6p(t){let{components:e,...n}=t;return(0,s.kt)(s6p,(0,p.Z)({},r6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A unified abstraction for all CSS filters."))}c6p.isMDXComponent=!0;const a6p={toc:[]},i6p="wrapper";function l6p(t){let{components:e,...n}=t;return(0,s.kt)(i6p,(0,p.Z)({},a6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"When the desired length is set to ",(0,s.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}l6p.isMDXComponent=!0;const u6p={toc:[]},m6p="wrapper";function d6p(t){let{components:e,...n}=t;return(0,s.kt)(m6p,(0,p.Z)({},u6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}d6p.isMDXComponent=!0;const h6p={toc:[]},f6p="wrapper";function k6p(t){let{components:e,...n}=t;return(0,s.kt)(f6p,(0,p.Z)({},h6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value can be either:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,s.kt)("inlineCode",{parentName:"li"},"'50%'"))))}k6p.isMDXComponent=!0;const y6p={toc:[]},D6p="wrapper";function M6p(t){let{components:e,...n}=t;return(0,s.kt)(D6p,(0,p.Z)({},y6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length used by most layout properties."))}M6p.isMDXComponent=!0;const X6p={toc:[]},_6p="wrapper";function w6p(t){let{components:e,...n}=t;return(0,s.kt)(_6p,(0,p.Z)({},X6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,s.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}w6p.isMDXComponent=!0;const T6p={toc:[]},C6p="wrapper";function x6p(t){let{components:e,...n}=t;return(0,s.kt)(C6p,(0,p.Z)({},T6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,s.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}x6p.isMDXComponent=!0;const g6p={toc:[]},v6p="wrapper";function L6p(t){let{components:e,...n}=t;return(0,s.kt)(v6p,(0,p.Z)({},g6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in pixels."))}L6p.isMDXComponent=!0;const Z6p={toc:[]},b6p="wrapper";function N6p(t){let{components:e,...n}=t;return(0,s.kt)(b6p,(0,p.Z)({},Z6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,s.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}N6p.isMDXComponent=!0;const z6p={toc:[]},A6p="wrapper";function P6p(t){let{components:e,...n}=t;return(0,s.kt)(A6p,(0,p.Z)({},z6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}P6p.isMDXComponent=!0;const W6p={toc:[]},R6p="wrapper";function I6p(t){let{components:e,...n}=t;return(0,s.kt)(R6p,(0,p.Z)({},W6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,s.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}I6p.isMDXComponent=!0;const S6p={toc:[]},B6p="wrapper";function G6p(t){let{components:e,...n}=t;return(0,s.kt)(B6p,(0,p.Z)({},S6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}G6p.isMDXComponent=!0;const E6p={toc:[]},O6p="wrapper";function F6p(t){let{components:e,...n}=t;return(0,s.kt)(O6p,(0,p.Z)({},E6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,s.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}F6p.isMDXComponent=!0;const U6p={toc:[]},V6p="wrapper";function q6p(t){let{components:e,...n}=t;return(0,s.kt)(V6p,(0,p.Z)({},U6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}q6p.isMDXComponent=!0;const j6p={toc:[]},Y6p="wrapper";function Q6p(t){let{components:e,...n}=t;return(0,s.kt)(Y6p,(0,p.Z)({},j6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,s.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}Q6p.isMDXComponent=!0;const H6p={toc:[]},K6p="wrapper";function $6p(t){let{components:e,...n}=t;return(0,s.kt)(K6p,(0,p.Z)({},H6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter in degrees."))}$6p.isMDXComponent=!0;const J6p={toc:[]},t3p="wrapper";function e3p(t){let{components:e,...n}=t;return(0,s.kt)(t3p,(0,p.Z)({},J6p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create an ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,s.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}e3p.isMDXComponent=!0;const n3p={toc:[]},o3p="wrapper";function p3p(t){let{components:e,...n}=t;return(0,s.kt)(o3p,(0,p.Z)({},n3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}p3p.isMDXComponent=!0;const r3p={toc:[]},s3p="wrapper";function c3p(t){let{components:e,...n}=t;return(0,s.kt)(s3p,(0,p.Z)({},r3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,s.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}c3p.isMDXComponent=!0;const a3p={toc:[]},i3p="wrapper";function l3p(t){let{components:e,...n}=t;return(0,s.kt)(i3p,(0,p.Z)({},a3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}l3p.isMDXComponent=!0;const u3p={toc:[]},m3p="wrapper";function d3p(t){let{components:e,...n}=t;return(0,s.kt)(m3p,(0,p.Z)({},u3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,s.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}d3p.isMDXComponent=!0;const h3p={toc:[]},f3p="wrapper";function k3p(t){let{components:e,...n}=t;return(0,s.kt)(f3p,(0,p.Z)({},h3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The value of the filter."))}k3p.isMDXComponent=!0;const y3p={toc:[]},D3p="wrapper";function M3p(t){let{components:e,...n}=t;return(0,s.kt)(D3p,(0,p.Z)({},y3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This method makes sure that the context of this scene is globally available\nduring the execution of the callback."))}M3p.isMDXComponent=!0;const X3p={toc:[]},_3p="wrapper";function w3p(t){let{components:e,...n}=t;return(0,s.kt)(_3p,(0,p.Z)({},X3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Invoke the given callback in the context of this scene."))}w3p.isMDXComponent=!0;const T3p={toc:[]},C3p="wrapper";function x3p(t){let{components:e,...n}=t;return(0,s.kt)(C3p,(0,p.Z)({},T3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The callback to invoke."))}x3p.isMDXComponent=!0;const g3p={toc:[]},v3p="wrapper";function L3p(t){let{components:e,...n}=t;return(0,s.kt)(v3p,(0,p.Z)({},g3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Update the view."),(0,s.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,s.kt)("p",null,"Can modify the state of the view."))}L3p.isMDXComponent=!0;const Z3p={toc:[]},b3p="wrapper";function N3p(t){let{components:e,...n}=t;return(0,s.kt)(b3p,(0,p.Z)({},Z3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Create a predicate that checks if the given object is an instance of the\ngiven class."))}N3p.isMDXComponent=!0;const z3p={toc:[]},A3p="wrapper";function P3p(t){let{components:e,...n}=t;return(0,s.kt)(A3p,(0,p.Z)({},z3p,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The class to check against."))}function W3p(t){let{id:e}=t;const n=o[e]??r.Fragment;return r.createElement(n,null)}P3p.isMDXComponent=!0},9322:(t,e,n)=>{n.d(e,{Z:()=>i});var o=n(8698),p=n(5302),r=n(8770),s=n(6277),c=n(2784);const a={toggle:"toggle_S_IX",collapsed:"collapsed_wdUB",collapse:"collapse_TjTN",inverse:"inverse_g6vW",clearFix:"clearFix_HQ1T"};function i(t){let{comment:e,full:n=!0}=t;const o=(0,c.useMemo)((()=>e?.blockTags?.find((t=>{let{tag:e}=t;return"@remarks"===e}))),[e]);return c.createElement(c.Fragment,null,n&&c.createElement(l,{comment:e}),c.createElement(p.Z,{id:e?.summaryId}),c.createElement(p.Z,{id:o?.contentId}),n&&c.createElement(u,{comment:e}))}function l(t){let{comment:e}=t;return(0,c.useMemo)((()=>e?.modifierTags?.includes("@experimental")),[e])?c.createElement(r.Z,null):null}function u(t){let{comment:e}=t;const[n,r]=(0,c.useState)(!0),i=(0,c.useMemo)((()=>e?.blockTags?.find((t=>{let{tag:e}=t;return"@preview"===e}))),[e]),l=(0,c.useMemo)((()=>e?.blockTags?.filter((t=>{let{tag:e}=t;return"@example"===e}))??[]),[e]),u=(0,c.useMemo)((()=>e?.blockTags?.find((t=>{let{tag:e}=t;return"@defaultValue"===e}))),[e]),m=(0,c.useMemo)((()=>e?.blockTags?.find((t=>{let{tag:e}=t;return"@deprecated"===e}))),[e]),d=(0,c.useMemo)((()=>e?.blockTags?.find((t=>{let{tag:e}=t;return"@see"===e}))),[e]);return c.createElement(c.Fragment,null,c.createElement(p.Z,{id:i?.contentId}),l.length>0&&c.createElement(c.Fragment,null,c.createElement("h4",null,c.createElement("a",{className:(0,s.Z)(a.toggle,n&&a.collapsed),onClick:t=>{t.preventDefault(),r(!n)},href:"#"},"Examples")),c.createElement(o.z,{lazy:!0,as:"div",collapsed:n},c.createElement("div",{className:a.collapse},l.map((t=>c.createElement(p.Z,{key:t.contentId,id:t.contentId})))),c.createElement("div",{className:a.clearFix})),c.createElement("div",{className:(0,s.Z)(a.clearFix,a.inverse)})),u&&c.createElement(c.Fragment,null,"Default Value:"," ",c.createElement("code",null,u.content.map((t=>t.text)).join(""))),m&&c.createElement(c.Fragment,null,c.createElement("h4",null,"Deprecated"),c.createElement(p.Z,{id:m.contentId})),d&&c.createElement(c.Fragment,null,c.createElement("h4",null,"See also"),c.createElement(p.Z,{id:d.contentId})))}},2830:(t,e,n)=>{n.d(e,{Z:()=>wt});var o=n(8569),p=n(6835),r=n(7896),s=n(2784);function c(t){let{width:e=24,height:n=24,...o}=t;return s.createElement("svg",(0,r.Z)({width:e,height:n,"aria-hidden":"true",viewBox:"0 0 24 24"},o),s.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}const a={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var i=n(68),l=n(6277);function u(t){let{children:e,highlight:n,onClick:r,link:u}=t;const m=(0,p.F)(),d=(0,i.s2)();return s.createElement("div",{className:(0,l.Z)(o.Z.codeBlockContent,a.codeBlock,n&&a.highlight,r&&a.pointer)},s.createElement("pre",{onClick:r,onKeyDown:t=>{"Enter"===t.key&&r?.()},tabIndex:0,ref:m.codeBlockRef,className:(0,l.Z)(o.Z.codeBlock,"thin-scrollbar")},s.createElement("code",{className:o.Z.codeBlockLines,style:d},e)),u&&s.createElement("div",{className:o.Z.buttonGroup},s.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(u,"_blank")}},s.createElement(c,{width:18,height:18}))))}var m=n(9318);function d(t){let{children:e}=t;return s.createElement(m.Z,{as:"div",className:(0,l.Z)(a.codeBlockContainer,"language-typescript")},e)}function h(t){let{children:e}=t;const n=(0,s.useRef)();return(0,s.useLayoutEffect)((()=>{if(!n.current)return;const t=n.current.closest("pre");if(t.scrollWidth>t.clientWidth){const e=Array.from(n.current.querySelectorAll(`.${a.elements}`)).sort(((t,e)=>function(t,e){return t>e?1:t<e?-1:0}(e.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&e.length>0;)e.shift().classList.add(a.wrap)}})),s.createElement(s.Fragment,null,e&&s.createElement("span",{ref:n,className:(0,l.Z)(a.line,"token-line")},e),s.createElement("br",null))}var f=n(9322),k=n(7390);function y(t){let{width:e=24,height:n=24,...o}=t;return s.createElement("svg",(0,r.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},o),s.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}var D=n(7708);const M={header:"header_nSmr",filters:"filters_z1iC",icon:"icon_ROIU"};function X(){const t=(0,s.useRef)(null),[e,n]=(0,s.useState)(!1),[o,p]=(0,D.mN)();return(0,s.useEffect)((()=>{const e=e=>{t.current&&!t.current.contains(e.target)&&n(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e)}}),[t]),s.createElement(s.Fragment,null,s.createElement("div",{ref:t,className:(0,l.Z)("dropdown dropdown--right margin-bottom--md",e&&"dropdown--show")},s.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),n(!e)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),n(!e))}},"Filters",s.createElement(y,{className:M.icon})),s.createElement("ul",{className:"dropdown__menu"},s.createElement("li",null,s.createElement("label",{htmlFor:"private",className:(0,l.Z)("dropdown__link",o.private&&"dropdown__link--active")},s.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:o.private,onChange:t=>{p({...o,private:t.target.checked})}}),"Protected members")),s.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&n(!1)}},s.createElement("label",{htmlFor:"inherited",className:(0,l.Z)("dropdown__link",o.inherited&&"dropdown__link--active")},s.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:o.inherited,onChange:t=>{p({...o,inherited:t.target.checked})}}),"Inherited members")))))}function _(t){let{children:e,kind:n}=t;return n===k.W.Class||n===k.W.Interface?s.createElement("div",{className:(0,l.Z)("row",M.header)},s.createElement("div",{className:(0,l.Z)("col",M.filters)},s.createElement(X,null)),s.createElement("div",{className:"col"},e)):s.createElement(s.Fragment,null,e)}var w=n(3181),T=n(9817);function C(t){let{children:e,type:n,to:o,id:p,tooltip:c}=t;const a=(0,i.Ld)(n);return o?s.createElement(T.Z,(0,r.Z)({id:p,to:o,"data-tooltip":c},a),e):s.createElement("span",(0,r.Z)({id:p},a),e)}let x=function(t){return t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses",t}({}),g=function(t){return t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & ",t}({});const v={[x.None]:a.none,[x.Angle]:a.angle,[x.Curly]:a.curly,[x.Square]:a.square,[x.Parentheses]:a.parentheses};function L(t){let{children:e,type:n,separator:o=g.Comma}=t;return s.createElement("span",{className:(0,l.Z)(a.list,v[n??x.None])},s.createElement("span",{className:(0,l.Z)(a.elements,o!==g.Comma&&a.left)},(Array.isArray(e)?e:[e]).flatMap(((t,e)=>s.createElement("span",{"data-separator":o,key:e,className:a.element},t)))))}function Z(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(ot,{type:e.elementType}),"[]")}function b(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(ot,{type:e.checkType}),s.createElement(C,{type:"keyword"}," extends "),s.createElement(ot,{type:e.extendsType})," ? ",s.createElement(ot,{type:e.trueType})," : ",s.createElement(ot,{type:e.falseType}))}function N(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(ot,{type:e.objectType}),"[",s.createElement(ot,{type:e.indexType}),"]")}function z(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"infer "),s.createElement(C,{type:"constant"},e.name))}function A(t){let{type:e}=t;return s.createElement(L,{type:x.Parentheses,separator:g.Ampersand},e.types.map(((t,e)=>s.createElement(ot,{key:e,type:t}))))}function P(t){let{type:e}=t;return s.createElement(C,{type:"keyword"},e.name)}function W(t){let{type:e}=t;const[n,o]=(0,s.useMemo)((()=>{if(null===e.value)return["null","keyword"];switch(typeof e.value){case"object":return[(e.value.negative?"-":"")+e.value.value,"number"];case"boolean":return[e.value,"keyword"];case"number":return[e.value,"number"];case"string":return[`'${e.value}'`,"string"];default:return[e.value,"constant"]}}),[e.value]);return s.createElement(C,{type:o},n)}function R(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(L,{type:x.Curly},s.createElement(s.Fragment,null,"[",s.createElement(C,{type:"class"},e.parameter),s.createElement(C,{type:"keyword"}," in "),s.createElement(ot,{type:e.parameterType}),"]: ",s.createElement(ot,{type:e.templateType}))))}function I(t){let{type:e}=t;return s.createElement(s.Fragment,null,e.name,": ",s.createElement(ot,{type:e.element}))}function S(t){let{type:e}=t;return e.asserts?s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"asserts "),s.createElement(C,null,e.name," ")):s.createElement(s.Fragment,null,s.createElement(C,null,e.name," "),s.createElement(C,{type:"keyword"},"is "),s.createElement(ot,{type:e.targetType}))}function B(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"typeof "),s.createElement(ot,{type:e.queryType}))}function G(t){let{flags:e,explicitAccessModifier:n}=t;const o=[];return e?.isAbstract&&o.push("abstract"),e?.isStatic&&o.push("static"),e?.isConst&&o.push("const"),e?.isReadonly&&o.push("readonly"),e?.isPrivate&&o.push("private"),e?.isProtected&&o.push("protected"),(e?.isPublic||n&&!e?.isProtected&&!e?.isPrivate)&&o.push("public"),s.createElement(s.Fragment,null,o.map((t=>s.createElement(C,{key:t,type:"keyword"},t," "))))}function E(t){let{reflection:e}=t;return s.createElement(s.Fragment,null,s.createElement(G,{flags:e.flags}),e.varianceModifier&&s.createElement(C,{type:"keyword"},e.varianceModifier," "),s.createElement(C,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"class-name"},e.name),e.type&&s.createElement(s.Fragment,null," extends ",s.createElement(ot,{type:e.type})),e.default&&s.createElement(s.Fragment,null," = ",s.createElement(ot,{type:e.default})))}var O=n(8617);const F={[k.W.Namespace]:"namespace",[k.W.Enum]:"enum",[k.W.Class]:"class",[k.W.Interface]:"interface"};function U(t){let{reflection:e}=t;const n=(0,O.in)();return s.createElement(s.Fragment,null,s.createElement(G,{flags:e.flags}),s.createElement(C,{type:"keyword"},F[e.kind]," "),s.createElement(C,{type:"class-name"},e.name),!!e.typeParameters?.length&&s.createElement(L,{type:x.Angle},e.typeParameters.map((t=>s.createElement(E,{key:t.id,reflection:n(t)}))))," ",!!e.extendedTypes?.length&&s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"extends "),s.createElement(L,null,e.extendedTypes.map(((t,e)=>s.createElement(ot,{key:e,type:t}))))),!!e.implementedTypes?.length&&s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"implements "),s.createElement(L,null,e.implementedTypes.map(((t,e)=>s.createElement(ot,{key:e,type:t}))))))}function V(t){let{reflection:e}=t;const n="__namedParameters"===e.name?"{...}":e.name;return s.createElement(s.Fragment,null,s.createElement(G,{flags:e.flags}),e.flags.isRest&&"...",s.createElement(C,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"plain"},n),e.flags.isOptional&&"?",": ",e.type&&s.createElement(ot,{type:e.type}),e.defaultValue&&s.createElement(s.Fragment,null," = ",s.createElement(C,{type:"plain"},e.defaultValue)))}function q(t){let{reflection:e,flags:n}=t;const o=(0,O.in)(),p="__type"===e.name;return s.createElement(s.Fragment,null,s.createElement(G,{flags:n??e.flags,explicitAccessModifier:!p}),e.kind===k.W.GetSignature&&s.createElement(C,{type:"keyword"},"get "),e.kind===k.W.SetSignature&&s.createElement(C,{type:"keyword"},"set "),e.overwrites&&s.createElement(s.Fragment,null,s.createElement(C,{to:e.overwrites.externalUrl??(0,O.Gr)(o(e.overwrites.id)),type:"keyword"},"override")," "),e.kind===k.W.ConstructorSignature?s.createElement(s.Fragment,null,s.createElement(C,{to:"#",type:"keyword"},"new")," ",s.createElement(C,{type:"plain"},e.type.name)):p?"":s.createElement(C,{type:"function"},e.name),!!e.typeParameter?.length&&s.createElement(L,{type:x.Angle},e.typeParameter.map((t=>s.createElement(E,{key:t.id,reflection:o(t)})))),e.parameters?.length?s.createElement(L,{type:x.Parentheses},e.parameters.map((t=>s.createElement(V,{key:t,reflection:o(t)})))):"()",e.type&&s.createElement(s.Fragment,null,p?" => ":": ",s.createElement(ot,{type:e.type})))}function j(t){let{reflection:e}=t;const n=e.signatures?.[0]??e.getSignature??e.setSignature??e.indexSignature;return s.createElement(q,{reflection:n})}function Y(t){let{reflection:e}=t;return s.createElement(V,{reflection:e})}function Q(t){let{reflection:e}=t;const n=(0,O.in)();return s.createElement(s.Fragment,null,s.createElement(G,{flags:e.flags}),s.createElement(C,{type:"keyword"},"type "),s.createElement(C,{type:"class-name"},e.name),e.typeParameters&&s.createElement(L,{type:x.Angle},e.typeParameters.map((t=>s.createElement(E,{key:t.id,reflection:n(t)}))))," = ",s.createElement(ot,{type:e.type}))}function H(t){let{reflection:e}=t;const n=(0,O.in)();return e.signatures?s.createElement(q,{reflection:e.signatures[0]}):e.children?s.createElement(L,{type:x.Curly},e.children.map((t=>s.createElement(K,{key:t.id,reflection:n(t)})))):s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},"unknown"))}function K(t){let{reflection:e}=t;const n=(0,s.useMemo)((()=>{switch(e.kind){case k.W.Project:case k.W.Module:case k.W.EnumMember:case k.W.Variable:case k.W.Function:break;case k.W.Namespace:case k.W.Enum:case k.W.Class:case k.W.Interface:return U;case k.W.Constructor:return q;case k.W.Property:return Y;case k.W.Method:return j;case k.W.CallSignature:case k.W.IndexSignature:case k.W.ConstructorSignature:case k.W.Parameter:break;case k.W.TypeLiteral:return H;case k.W.TypeParameter:return E;case k.W.Accessor:case k.W.GetSignature:case k.W.SetSignature:case k.W.ObjectLiteral:break;case k.W.TypeAlias:return Q;case k.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.id]);return s.createElement(n,{reflection:e})}function $(t){let{type:e}=t;const n=(0,O.in)();return s.createElement(K,{reflection:n(e.declaration)})}function J(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(C,{type:"string"},"`",e.head),e.tail.map(((t,e)=>{let[n,o]=t;return s.createElement(s.Fragment,null,"${",s.createElement(ot,{key:e,type:n}),"}",s.createElement(C,{type:"string"},o))})),s.createElement(C,{type:"string"},"`"))}function tt(t){let{type:e}=t;return e.elements?s.createElement(L,{type:x.Square},e.elements.map(((t,e)=>s.createElement(ot,{key:e,type:t})))):s.createElement(s.Fragment,null,"[]")}function et(t){let{type:e}=t;return s.createElement(s.Fragment,null,s.createElement(C,{type:"keyword"},e.operator," "),s.createElement(ot,{type:e.target}))}function nt(t){let{type:e}=t;return s.createElement(L,{type:x.Parentheses,separator:g.Pipe},e.types.map(((t,e)=>s.createElement(ot,{key:e,type:t}))))}function ot(t){const e=(0,s.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return et;case"conditional":return b;case"reflection":return $;case"query":return B;case"named-tuple-member":return I;case"union":return nt;case"intrinsic":return P;case"literal":return W;case"reference":return pt;case"predicate":return S;case"tuple":return tt;case"array":return Z;case"intersection":return A;case"inferred":return z;case"mapped":return R;case"template-literal":return J;case"indexedAccess":return N}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return s.createElement(e,t)}function pt(t){let{type:e}=t;const n=(0,O.RU)(e.project),o=n?.[e.id],p=e.externalUrl??(0,O.Gr)(o);return s.createElement(s.Fragment,null,s.createElement(C,{to:p,type:p?"class-name":"constant",tooltip:!0},e.name),!!e.typeArguments?.length&&s.createElement(L,{type:x.Angle},e.typeArguments.map(((t,e)=>s.createElement(ot,{key:e,type:t})))))}function rt(t){let{group:e}=t;return"Constructors"===e.title&&0===e.external.length&&1===e.nested.length?s.createElement(wt,{reflection:e.nested[0]}):s.createElement(s.Fragment,null,e.external.length>0&&s.createElement("ul",null,e.external.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(pt,{type:t})))))),e.nested.length>0&&e.nested.map(((t,e)=>s.createElement(s.Fragment,{key:t.id},e>0&&s.createElement("hr",null),s.createElement(wt,{reflection:t})))))}var st=n(3851),ct=n(2009),at=n(7336);function it(t){let{group:e,project:n}=t;const o=(0,w.TH)(),p=(0,O.RU)(n),r=o.hash.split("-")[0].slice(1),[c]=(0,D.mN)(),a=(0,s.useMemo)((()=>(e.categories??[e]).map((t=>function(t,e,n){const o=[],p=[],r=[];for(const s of t.children){const t=e[s];t&&(0,D.It)(n,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,p,c))).filter((t=>!!t))),[e,p,c]);return(0,s.useEffect)((()=>{if(1===a.length)return;const t=o.hash.split("-")[0].slice(1);for(const e of a)if(e.anchors.includes(t))return}),[o.hash,a]),0===a.length?s.createElement(s.Fragment,null):s.createElement(s.Fragment,null,s.createElement(st.Z,{as:"h2",id:e.title},e.title),a.length>1?s.createElement(at.Z,{groupId:e.title},a.map((t=>s.createElement(ct.Z,{default:t.anchors.includes(r),value:t.title,label:t.title,className:"margin-top--lg"},s.createElement(rt,{group:t}))))):s.createElement(rt,{group:a[0]}))}var lt=n(5302);function ut(t){let{parameters:e}=t;const n=(0,O.in)(),o=(0,s.useMemo)((()=>e?.map(n)),[e]);return o?.length?s.createElement(s.Fragment,null,s.createElement("h4",null,"Parameters"),s.createElement("ul",null,o.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(V,{reflection:t})),s.createElement(lt.Z,{id:t.comment?.summaryId})))))):s.createElement(s.Fragment,null)}function mt(t){let{parameters:e}=t;const n=(0,O.in)(),o=(0,s.useMemo)((()=>e?.map(n)),[e]);return o?.length?s.createElement(s.Fragment,null,s.createElement("h4",null,"Type Parameters"),s.createElement("ul",null,o.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(E,{reflection:t})),s.createElement(lt.Z,{id:t.comment?.summaryId})))))):s.createElement(s.Fragment,null)}function dt(t){let{signatures:e,flags:n,source:o}=t;const p=(0,O.in)(),r=(0,s.useMemo)((()=>e.map(p)),[e]),[c,a]=(0,s.useState)(r[0]);return s.createElement(s.Fragment,null,s.createElement(d,null,r.map((t=>s.createElement(u,{link:o?.url,key:t.id,highlight:e.length>1&&t.id===c.id,onClick:e.length>1?()=>a(t):void 0},s.createElement(h,null,s.createElement(q,{reflection:t,flags:n})))))),s.createElement(f.Z,{comment:c.comment}),s.createElement(mt,{parameters:c.typeParameter}),s.createElement(ut,{parameters:c.parameters}))}function ht(t){let{reflection:e}=t;return s.createElement(s.Fragment,null,s.createElement(d,null,s.createElement(u,{link:e.sources?.[0]?.url},s.createElement(h,null,s.createElement(K,{reflection:e})))),s.createElement(_,{kind:e.kind},s.createElement(f.Z,{comment:e.comment})),s.createElement(mt,{parameters:e.typeParameters}),e.implementedBy?.length&&s.createElement(s.Fragment,null,s.createElement("h4",null,"Implemented by"),s.createElement("ul",null,e.implementedBy.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(pt,{type:t}))))))),e.extendedBy?.length&&s.createElement(s.Fragment,null,s.createElement("h4",null,"Extended by"),s.createElement("ul",null,e.extendedBy.map((t=>s.createElement("li",{key:t.id},s.createElement("code",null,s.createElement(pt,{type:t}))))))),e.signatures&&s.createElement(s.Fragment,null,s.createElement("h2",null,"Callable"),s.createElement(dt,{signatures:e.signatures})),e.groups?.map((t=>s.createElement(it,{group:t,key:t.title,project:e.project}))))}function ft(t){let{reflection:e,headless:n}=t;const o=[...e.signatures??[],e.setSignature,e.getSignature,e.indexSignature].filter((t=>!!t));return s.createElement(s.Fragment,null,!n&&(e.hasOwnPage?s.createElement("h1",null,e.name):s.createElement(st.Z,{as:"h3",id:e.anchor},s.createElement("code",null,e.name))),s.createElement(dt,{signatures:o,flags:e.flags,source:e.sources?.[0]}),e.inheritedFrom&&s.createElement("small",null,"Inherited from"," ",s.createElement("code",null,s.createElement(pt,{type:e.inheritedFrom}))),e.overwrites&&s.createElement("small",null,"Overwrites"," ",s.createElement("code",null,s.createElement(pt,{type:e.overwrites}))))}var kt=n(6109);function yt(t){let{reflection:e}=t;return s.createElement(s.Fragment,null,s.createElement(kt.Z,{language:"ts"},"import ","{...}",' from "',e.importPath,'";'),s.createElement(_,{kind:e.kind},s.createElement(f.Z,{comment:e.comment})),e.groups?.map((t=>s.createElement(it,{group:t,key:t.title,project:e.project}))))}const Dt={cardContainer:"cardContainer_ybwo",cardTitle:"cardTitle_Ehd1",cardDescription:"cardDescription_b6wr"};function Mt(t){let{reflection:e}=t;const n=(0,O.RU)(e.project),o=e.groups[0].children.map((t=>n[t])).filter((t=>!!t));return s.createElement("article",{className:"margin-top--lg"},s.createElement("section",{className:(0,l.Z)("row")},o.map((t=>s.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},s.createElement(T.Z,{href:t.href,className:(0,l.Z)("card padding--lg",Dt.cardContainer)},s.createElement("h2",{className:(0,l.Z)("text--truncate",Dt.cardTitle)},s.createElement("code",null,t.name)),s.createElement("div",{className:(0,l.Z)("text--truncate",Dt.cardDescription)},t.comment?.summaryText??"\xa0")))))))}function Xt(t){let{reflection:e,headless:n}=t;return s.createElement(s.Fragment,null,!n&&(e.hasOwnPage?s.createElement("h1",null,e.name):s.createElement(st.Z,{as:"h3",id:e.anchor},s.createElement("code",null,e.name))),s.createElement(d,null,s.createElement(u,{link:e.sources?.[0]?.url},s.createElement(h,null,s.createElement(Y,{reflection:e})))),s.createElement(f.Z,{comment:e.comment}),e.inheritedFrom&&s.createElement("small",null,"Inherited from"," ",s.createElement("code",null,s.createElement(pt,{type:e.inheritedFrom}))))}function _t(t){let{reflection:e}=t;const n=(0,O.RU)(e.project);return s.createElement(s.Fragment,null,s.createElement(st.Z,{as:"h3",id:e.anchor},s.createElement("code",null,e.name)),s.createElement(d,null,s.createElement(u,{link:e.sources?.[0]?.url},s.createElement(h,null,s.createElement(K,{reflection:e})))),s.createElement(f.Z,{comment:e.comment}),s.createElement(mt,{parameters:e.typeParameters}),e.signatures&&s.createElement(s.Fragment,null,s.createElement("h2",null,"Callable"),s.createElement(dt,{signatures:e.signatures})),e.groups?.map((t=>s.createElement(s.Fragment,{key:t.title},s.createElement("h2",null,t.title),t.children.map((t=>n[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>s.createElement(wt,{key:t.id,reflection:t})))))))}function wt(t){let{reflection:e,headless:n=!1}=t;const o=(0,s.useMemo)((()=>{switch(e.kind){case k.W.Project:return Mt;case k.W.Module:return yt;case k.W.Namespace:case k.W.Enum:case k.W.Class:case k.W.Interface:return ht;case k.W.Function:case k.W.Accessor:case k.W.Constructor:case k.W.Method:return ft;case k.W.Variable:case k.W.Property:case k.W.EnumMember:return Xt;case k.W.CallSignature:case k.W.IndexSignature:case k.W.ConstructorSignature:case k.W.Parameter:case k.W.TypeLiteral:case k.W.TypeParameter:case k.W.GetSignature:case k.W.SetSignature:case k.W.ObjectLiteral:break;case k.W.TypeAlias:return _t;case k.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.kind]);return s.createElement(o,{reflection:e,headless:n})}},7390:(t,e,n)=>{n.d(e,{W:()=>o});let o=function(t){return t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference",t}({})},8770:(t,e,n)=>{n.d(e,{Z:()=>s});var o=n(9817),p=n(6047),r=n(2784);function s(){return r.createElement(p.Z,{type:"experimental"},"This is an ",r.createElement(o.Z,{to:"/docs/experimental"},"experimental feature"),". The behavior and API may change drastically between minor releases.")}},8617:(t,e,n)=>{n.d(e,{Gr:()=>i,RU:()=>s,gs:()=>r,in:()=>c,rG:()=>a});var o=n(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:e,lookup:n,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:n,urlLookup:r}},e)}function s(t){const{lookup:e}=(0,o.useContext)(p);return e[t]}function c(){const{lookup:t}=(0,o.useContext)(p);return e=>{if("number"==typeof e?.project)return t[e.project][e.id]}}function a(){const{urlLookup:t,lookup:e}=(0,o.useContext)(p);return n=>{const o=t[n];return o?e[o.projectId]?.[o.id]??null:null}}function i(t){if(t)return t.href}},68:(t,e,n)=>{n.d(e,{Ld:()=>c,Y0:()=>s,s2:()=>a});var o=n(822),p=n(2784);const r=p.createContext(null);function s(t){let{children:e}=t;const n=(0,o.p)(),s=(0,p.useMemo)((()=>function(t,e){const{plain:n}=t,o=Object.create(null),p=t.styles.reduce(((t,n)=>{const{languages:o,style:p}=n;return o&&!o.includes(e)||n.types.forEach((e=>{t[e]={...t[e],...p}})),t}),o);return p.root=n,p.plain={...n,backgroundColor:null},p}(n,"typescript")),[n]);return p.createElement(r.Provider,{value:s},e)}function c(t){void 0===t&&(t="plain");const e=(0,p.useContext)(r);return{className:`token ${t}`,style:e[t]??e.plain}}function a(t){void 0===t&&(t="plain");const e=(0,p.useContext)(r);return e[t]??e.plain}},7708:(t,e,n)=>{n.d(e,{It:()=>m,Wy:()=>l,mN:()=>u});var o=n(1263),p=n(9741),r=n(2784);const s="api-filters",c=o.Z.canUseDOM?localStorage.getItem(s):null,a=c?JSON.parse(c):{inherited:!0,private:!1},i=r.createContext([a,()=>{}]);function l(t){let{children:e}=t;const[n,o]=(0,r.useState)(a),c=(0,p.Z)();return r.createElement(i.Provider,{value:[n,t=>{c&&localStorage.setItem(s,JSON.stringify(t)),o(t)}]},e)}function u(){return(0,r.useContext)(i)}function m(t,e){const n=e.flags?.isPrivate||e.flags?.isProtected;if(!t.private&&n)return!1;const o=!!e.inheritedFrom;return!(!t.inherited&&o)}},6047:(t,e,n)=>{n.d(e,{Z:()=>m});var o=n(7896),p=n(8046),r=n(2784);function s(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"}))}function c(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"}))}function a(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}))}function i(t){return r.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),r.createElement("path",{d:"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"}))}var l=n(9055);const u={icon:"icon_Fw4I"};function m(t){let{title:e,type:n,...m}=t;const d=(0,r.useMemo)((()=>{switch(n){case"tip":return a;case"caution":return i;case"danger":return s;case"experimental":return p.Z;default:return c}}),[n]);return"experimental"===n&&(e??="Experimental",n="caution"),r.createElement(r.Fragment,null,r.createElement(l.Z,(0,o.Z)({icon:r.createElement(d,{className:u.icon}),title:e,type:n},m)))}},2253:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>i,contentTitle:()=>c,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var o=n(7896),p=(n(2784),n(876)),r=n(2072);const s={sidebar_position:2,slug:"/flow"},c="Animation flow",a={unversionedId:"getting-started/flow",id:"getting-started/flow",title:"Animation flow",description:"Motion Canvas uses generator functions to describe animations.",source:"@site/docs/getting-started/flow.mdx",sourceDirName:"getting-started",slug:"/flow",permalink:"/docs/flow",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/flow.mdx",tags:[],version:"current",lastUpdatedBy:"Akshat Giri",sidebarPosition:2,frontMatter:{sidebar_position:2,slug:"/flow"},sidebar:"docs",previous:{title:"Quickstart",permalink:"/docs/quickstart"},next:{title:"Scene hierarchy",permalink:"/docs/hierarchy"}},i={},l=[{value:"Flow Generators",id:"flow-generators",level:2},{value:"<code>all</code>",id:"all",level:3},{value:"<code>any</code>",id:"any",level:3},{value:"<code>chain</code>",id:"chain",level:3},{value:"<code>delay</code>",id:"delay",level:3},{value:"<code>sequence</code>",id:"sequence",level:3},{value:"<code>loop</code>",id:"loop",level:3},{value:"Looping",id:"looping",level:2},{value:"Using <code>Array.map</code> and <code>all</code>",id:"using-arraymap-and-all",level:3},{value:"Using a <code>for</code> loop and <code>all</code>",id:"using-a-for-loop-and-all",level:3},{value:"Using a <code>for</code> loop",id:"using-a-for-loop",level:3}],u={toc:l},m="wrapper";function d(t){let{components:e,...n}=t;return(0,p.kt)(m,(0,o.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"animation-flow"},"Animation flow"),(0,p.kt)("p",null,"Motion Canvas uses generator functions to describe animations."),(0,p.kt)("p",null,"A generator function is a function that can return multiple values:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"function* example() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst generator = example();\n\nconsole.log(generator.next().value); // 1;\nconsole.log(generator.next().value); // 2;\nconsole.log(generator.next().value); // 3;\n")),(0,p.kt)("p",null,"When the ",(0,p.kt)("inlineCode",{parentName:"p"},"yield")," keyword is encountered, the execution of the function pauses,\nand resumes only when the caller requests another value. This is particularly\nuseful when declaring animations - usually we want to change the things on the\nscreen in incremental steps to create an illusion of movement. We also want to\nwait a constant amount of time between these updates so that our eyes can\nregister what's happening. With generators, we can update things in-between the\n",(0,p.kt)("inlineCode",{parentName:"p"},"yield")," keywords, and then wait for a bit whenever the function yields."),(0,p.kt)("p",null,"This is the fundamental idea of Motion Canvas. ",(0,p.kt)("inlineCode",{parentName:"p"},"yield"),' means: "The current frame\nis ready, display it on the screen and come back to me later."'),(0,p.kt)("p",null,"With that in mind, we can make a circle flicker on the screen using the\nfollowing code:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n  view.add(<Circle ref={circle} width={100} height={100} />);\n\n  circle().fill('red');\n  yield;\n  circle().fill('blue');\n  yield;\n  circle().fill('red');\n  yield;\n});\n")),(0,p.kt)("p",null,"Needless to say, it would be extremely cumbersome if we had to write all\nanimations like that. Fortunately, JavaScript has another keyword for use within\ngenerators - ",(0,p.kt)("inlineCode",{parentName:"p"},"yield*"),". It allows us to delegate the yielding to another\ngenerator."),(0,p.kt)("p",null,"For instance, we could extract the flickering code from the above example to a\nseparate generator and delegate our scene function to it:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"import {ThreadGenerator} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n  view.add(<Circle ref={circle} width={100} height={100} />);\n\n  yield* flicker(circle());\n});\n\nfunction* flicker(circle: Circle): ThreadGenerator {\n  circle.fill('red');\n  yield;\n  circle.fill('blue');\n  yield;\n  circle.fill('red');\n  yield;\n}\n")),(0,p.kt)("p",null,"The resulting animation is exactly the same, but now we have a reusable function\nthat we can use whenever we need some flickering."),(0,p.kt)("p",null,"Motion Canvas provides a lot of useful generators like this. You may remember\nthis snippet from ",(0,p.kt)("a",{parentName:"p",href:"/docs/quickstart"},"quickstart"),":"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield * myCircle().fill('#e6a700', 1);\n")),(0,p.kt)("p",null,"It animates the fill color of the circle from its current value to ",(0,p.kt)("inlineCode",{parentName:"p"},"#e6a700"),"\nover a span of one second. As you may guess, the result of calling\n",(0,p.kt)("inlineCode",{parentName:"p"},"fill('#e6a700', 1)")," is another generator to which we can redirect our scene\nfunction. Generators like this are called tweens, because they animate\nbe",(0,p.kt)("strong",{parentName:"p"},"tween")," two values. You can read more about them in the\n",(0,p.kt)("a",{parentName:"p",href:"/docs/tweening"},"tweening")," section."),(0,p.kt)("h2",{id:"flow-generators"},"Flow Generators"),(0,p.kt)("p",null,"Another kind of generators are ",(0,p.kt)("em",{parentName:"p"},"flow generators"),". They take one or more\ngenerators as their input and combine them together. We've mentioned the ",(0,p.kt)("inlineCode",{parentName:"p"},"all()"),"\ngenerator in the quickstart section, there's a few more:"),(0,p.kt)("h3",{id:"all"},(0,p.kt)("inlineCode",{parentName:"h3"},"all")),(0,p.kt)(r.Z,{url:"/api/core/flow#all",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"any"},(0,p.kt)("inlineCode",{parentName:"h3"},"any")),(0,p.kt)(r.Z,{url:"/api/core/flow#any",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"chain"},(0,p.kt)("inlineCode",{parentName:"h3"},"chain")),(0,p.kt)(r.Z,{url:"/api/core/flow#chain",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"delay"},(0,p.kt)("inlineCode",{parentName:"h3"},"delay")),(0,p.kt)(r.Z,{url:"/api/core/flow#delay",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"sequence"},(0,p.kt)("inlineCode",{parentName:"h3"},"sequence")),(0,p.kt)(r.Z,{url:"/api/core/flow#sequence",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"loop"},(0,p.kt)("inlineCode",{parentName:"h3"},"loop")),(0,p.kt)(r.Z,{url:"/api/core/flow#loop",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"looping"},"Looping"),(0,p.kt)("p",null,"There are many ways to animate multiple objects. Here are some examples. Try\nusing them in the below editor."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"editor ratio=2",editor:!0,ratio:"2"},"import {makeScene2D, Rect} from '@motion-canvas/2d';\nimport {all, waitFor, makeRef, range} from '@motion-canvas/core';\n\nexport default makeScene2D(function* (view) {\n  const rects: Rect[] = [];\n\n  // Create some rects\n  view.add(\n    range(5).map(i => (\n      <Rect\n        ref={makeRef(rects, i)}\n        width={100}\n        height={100}\n        x={-250 + 125 * i}\n        fill=\"#88C0D0\"\n        radius={10}\n      />\n    )),\n  );\n\n  yield* waitFor(1);\n\n  // Animate them\n  yield* all(\n    ...rects.map(rect => rect.position.y(100, 1).to(-100, 2).to(0, 1)),\n  );\n});\n")),(0,p.kt)("h3",{id:"using-arraymap-and-all"},"Using ",(0,p.kt)("inlineCode",{parentName:"h3"},"Array.map")," and ",(0,p.kt)("inlineCode",{parentName:"h3"},"all")),(0,p.kt)("p",null,"This is one of the most elegant ways to do simple tweens, but requires nesting\n",(0,p.kt)("inlineCode",{parentName:"p"},"all")," to do multiple tweens on an object since the ",(0,p.kt)("inlineCode",{parentName:"p"},"map")," callback must return a\n",(0,p.kt)("inlineCode",{parentName:"p"},"ThreadGenerator"),"."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"yield *\n  all(\n    ...rects.map(rect =>\n      // No yield or anything; we return this generator and deal with it outside\n      rect.position.y(100, 1).to(-100, 2).to(0, 1),\n    ),\n  );\n")),(0,p.kt)("h3",{id:"using-a-for-loop-and-all"},"Using a ",(0,p.kt)("inlineCode",{parentName:"h3"},"for")," loop and ",(0,p.kt)("inlineCode",{parentName:"h3"},"all")),(0,p.kt)("p",null,"This is similar to above, but uses a ",(0,p.kt)("inlineCode",{parentName:"p"},"for")," loop and an array of generators."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const generators = [];\nfor (const rect of rects) {\n  // No yield here, just store the generators.\n  generators.push(rect.position.y(100, 1).to(-100, 2).to(0, 1));\n}\n\n// Run all of the generators.\nyield * all(...generators);\n")),(0,p.kt)("h3",{id:"using-a-for-loop"},"Using a ",(0,p.kt)("inlineCode",{parentName:"h3"},"for")," loop"),(0,p.kt)("p",null,"This is a bit of a cumbersome option because you have to figure out how long it\nwould take for the generator in the loop to complete, but is useful in some\nsituations."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"for (const rect of rects) {\n  // Note the absence of a * after this yield\n  yield rect.position.y(100, 1).to(-100, 2).to(0, 1);\n}\n\n// Wait for the duration of the above generators\nyield * waitFor(4);\n")))}d.isMDXComponent=!0}}]);